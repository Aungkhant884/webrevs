{"files":[{"patch":"@@ -38,1 +38,1 @@\n-        location: ${{ runner.tool_cache }}\/msys2\n+        location: msys2\n@@ -44,1 +44,1 @@\n-        echo \"$env:RUNNER_TOOL_CACHE\/msys2\/msys64\/usr\/bin\" >> $env:GITHUB_PATH\n+        echo \"$env:GITHUB_WORKSPACE\/msys2\/msys64\/usr\/bin\" >> $env:GITHUB_PATH\n","filename":".github\/actions\/get-msys2\/action.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,9 +32,0 @@\n-        required: true\n-        type: string\n-      apt-gcc-version:\n-        required: true\n-        type: string\n-      apt-gcc-cross-version:\n-        required: true\n-        type: string\n-      extra-conf-options:\n@@ -43,1 +34,2 @@\n-      configure-arguments:\n+        default: '10'\n+      apt-gcc-version:\n@@ -46,1 +38,2 @@\n-      make-arguments:\n+        default: '10.3.0-1ubuntu1~20.04'\n+      apt-gcc-cross-suffix:\n@@ -49,0 +42,1 @@\n+        default: 'cross1'\n@@ -53,1 +47,1 @@\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-20.04\n@@ -118,2 +112,2 @@\n-              gcc-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-cross-version }} \\\n-              g++-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-cross-version }} \\\n+              gcc-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-version }}${{ inputs.apt-gcc-cross-suffix }} \\\n+              g++-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-version }}${{ inputs.apt-gcc-cross-suffix }} \\\n@@ -136,1 +130,1 @@\n-          sudo debootstrap\n+          sudo qemu-debootstrap\n@@ -141,1 +135,0 @@\n-          --variant=minbase\n@@ -152,3 +145,1 @@\n-          rm -rf sysroot\/{dev,proc,run,sys,var}\n-          rm -rf sysroot\/usr\/{sbin,bin,share}\n-          rm -rf sysroot\/usr\/lib\/{apt,udev,systemd}\n+          rm -rf sysroot\/{dev,proc,run,sys}\n@@ -169,6 +160,2 @@\n-          CC=${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}-gcc-${{ inputs.gcc-major-version }}\n-          CXX=${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}-g++-${{ inputs.gcc-major-version }}\n-          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n-          echo \"Dumping config.log:\" &&\n-          cat config.log &&\n-          exit 1)\n+          CC=${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}-gcc-10\n+          CXX=${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}-g++-10\n@@ -180,1 +167,1 @@\n-          make-target: 'hotspot ${{ inputs.make-arguments }}'\n+          make-target: 'hotspot'\n","filename":".github\/workflows\/build-cross-compile.yml","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -45,7 +45,0 @@\n-      gcc-major-version:\n-        required: true\n-        type: string\n-      gcc-package-suffix:\n-        required: false\n-        type: string\n-        default: ''\n@@ -61,6 +54,0 @@\n-      configure-arguments:\n-        required: false\n-        type: string\n-      make-arguments:\n-        required: false\n-        type: string\n@@ -71,1 +58,1 @@\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-20.04\n@@ -117,2 +104,2 @@\n-          sudo apt-get install gcc-${{ inputs.gcc-major-version }}${{ inputs.gcc-package-suffix }}=${{ inputs.apt-gcc-version }} g++-${{ inputs.gcc-major-version }}${{ inputs.gcc-package-suffix }}=${{ inputs.apt-gcc-version }} libxrandr-dev${{ steps.arch.outputs.suffix }} libxtst-dev${{ steps.arch.outputs.suffix }} libcups2-dev${{ steps.arch.outputs.suffix }} libasound2-dev${{ steps.arch.outputs.suffix }} ${{ inputs.apt-extra-packages }}\n-          sudo update-alternatives --install \/usr\/bin\/gcc gcc \/usr\/bin\/gcc-${{ inputs.gcc-major-version }} 100 --slave \/usr\/bin\/g++ g++ \/usr\/bin\/g++-${{ inputs.gcc-major-version }}\n+          sudo apt-get install gcc-${{ inputs.apt-gcc-version }} g++-${{ inputs.apt-gcc-version }} libxrandr-dev${{ steps.arch.outputs.suffix }} libxtst-dev${{ steps.arch.outputs.suffix }} libcups2-dev${{ steps.arch.outputs.suffix }} libasound2-dev${{ steps.arch.outputs.suffix }} ${{ inputs.apt-extra-packages }}\n+          sudo update-alternatives --install \/usr\/bin\/gcc gcc \/usr\/bin\/gcc-10 100 --slave \/usr\/bin\/g++ g++ \/usr\/bin\/g++-10\n@@ -131,4 +118,1 @@\n-          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n-          echo \"Dumping config.log:\" &&\n-          cat config.log &&\n-          exit 1)\n+          ${{ inputs.extra-conf-options }}\n@@ -140,1 +124,1 @@\n-          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          make-target: '${{ inputs.make-target }}'\n","filename":".github\/workflows\/build-linux.yml","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -48,6 +48,0 @@\n-      configure-arguments:\n-        required: false\n-        type: string\n-      make-arguments:\n-        required: false\n-        type: string\n@@ -106,4 +100,1 @@\n-          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n-          echo \"Dumping config.log:\" &&\n-          cat config.log &&\n-          exit 1)\n+          ${{ inputs.extra-conf-options }}\n@@ -115,1 +106,1 @@\n-          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          make-target: '${{ inputs.make-target }}'\n","filename":".github\/workflows\/build-macos.yml","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,6 +51,0 @@\n-      configure-arguments:\n-        required: false\n-        type: string\n-      make-arguments:\n-        required: false\n-        type: string\n@@ -133,4 +127,1 @@\n-          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n-          echo \"Dumping config.log:\" &&\n-          cat config.log &&\n-          exit 1)\n+          ${{ inputs.extra-conf-options }}\n@@ -141,1 +132,0 @@\n-        shell: env \/usr\/bin\/bash --login -eo pipefail {0}\n@@ -147,1 +137,1 @@\n-          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          make-target: '${{ inputs.make-target }}'\n","filename":".github\/workflows\/build-windows.yml","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,6 +39,0 @@\n-      configure-arguments:\n-        description: 'Additional configure arguments'\n-        required: false\n-      make-arguments:\n-        description: 'Additional make arguments'\n-        required: false\n@@ -58,1 +52,1 @@\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-20.04\n@@ -130,4 +124,1 @@\n-      gcc-major-version: '10'\n-      apt-gcc-version: '10.5.0-1ubuntu1~22.04'\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -143,3 +134,1 @@\n-      gcc-major-version: '10'\n-      gcc-package-suffix: '-multilib'\n-      apt-gcc-version: '10.5.0-1ubuntu1~22.04'\n+      apt-gcc-version: '10-multilib'\n@@ -151,2 +140,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -163,2 +150,1 @@\n-      gcc-major-version: '10'\n-      apt-gcc-version: '10.5.0-1ubuntu1~22.04'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -166,2 +152,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -178,2 +162,1 @@\n-      gcc-major-version: '10'\n-      apt-gcc-version: '10.5.0-1ubuntu1~22.04'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -181,2 +164,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -193,2 +174,1 @@\n-      gcc-major-version: '10'\n-      apt-gcc-version: '10.5.0-1ubuntu1~22.04'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -196,2 +176,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -209,2 +187,1 @@\n-      gcc-major-version: '10'\n-      apt-gcc-version: '10.5.0-1ubuntu1~22.04'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -212,2 +189,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -222,6 +197,0 @@\n-    with:\n-      gcc-major-version: '10'\n-      apt-gcc-version: '10.5.0-1ubuntu1~22.04'\n-      apt-gcc-cross-version: '10.5.0-1ubuntu1~22.04cross1'\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -237,2 +206,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -249,2 +216,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -261,2 +226,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -275,2 +238,0 @@\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -291,1 +252,1 @@\n-      runs-on: ubuntu-22.04\n+      runs-on: ubuntu-20.04\n@@ -301,1 +262,1 @@\n-      runs-on: ubuntu-22.04\n+      runs-on: ubuntu-20.04\n@@ -326,1 +287,1 @@\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-20.04\n","filename":".github\/workflows\/main.yml","additions":10,"deletions":49,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-          - 'lib-test\/tier1'\n@@ -102,4 +101,0 @@\n-          - test-name: 'lib-test\/tier1'\n-            test-suite: 'test\/lib-test\/:tier1'\n-            debug-suffix: -debug\n-\n","filename":".github\/workflows\/test.yml","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,4 +91,1 @@\n-\t$(GREP) -v HelloClasslist $@.raw.2 > $@.raw.3\n-\t$(FIXPATH) $(INTERIM_IMAGE_DIR)\/bin\/java \\\n-\t    -cp $(SUPPORT_OUTPUTDIR)\/classlist.jar \\\n-\t    build.tools.classlist.SortClasslist $@.raw.3 > $@\n+\t$(GREP) -v HelloClasslist $@.raw.2 > $@\n","filename":"make\/GenerateLinkOptData.gmk","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,4 +141,1 @@\n-            $(if $(CUSTOM_CONFIG_DIR), $(wildcard $(CUSTOM_CONFIG_DIR)\/*)) \\\n-            $(addprefix $(topdir)\/make\/conf\/, version-numbers.conf branding.conf) \\\n-            $(if $(CUSTOM_CONF_DIR), $(wildcard $(addprefix $(CUSTOM_CONF_DIR)\/, \\\n-                version-numbers.conf branding.conf)))\n+            $(if $(CUSTOM_CONFIG_DIR), $(wildcard $(CUSTOM_CONFIG_DIR)\/*))\n","filename":"make\/Init.gmk","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -169,3 +169,1 @@\n-    # On windows and aix default is bundled\n-    DEFAULT_ZLIB=bundled\n-  elif test \"x$OPENJDK_TARGET_OS\" = xmacosx -a \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+    # On windows and aix default is bundled, on others default is system\n","filename":"make\/autoconf\/lib-bundled.m4","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-            configure_args: concat(common.configure_args_64bit,\n+            configure_args: concat(common.configure_args_64bit, \"--with-zlib=system\",\n@@ -1170,1 +1170,1 @@\n-            revision: \"1.35+1.0\"\n+            revision: \"1.28+1.0\"\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=\n+DEFAULT_PROMOTED_VERSION_PRE=ea\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+Owner: OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP\n+Issuer: OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP\n+Serial number: 0\n+Valid from: Tue Sep 30 04:20:49 GMT 2003 until: Sat Sep 30 04:20:49 GMT 2023\n+Signature algorithm name: SHA1withRSA\n+Subject Public Key Algorithm: 2048-bit RSA key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\n+MIIDWjCCAkKgAwIBAgIBADANBgkqhkiG9w0BAQUFADBQMQswCQYDVQQGEwJKUDEY\r\n+MBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYDVQQLEx5TZWN1cml0eSBDb21t\r\n+dW5pY2F0aW9uIFJvb3RDQTEwHhcNMDMwOTMwMDQyMDQ5WhcNMjMwOTMwMDQyMDQ5\r\n+WjBQMQswCQYDVQQGEwJKUDEYMBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYD\r\n+VQQLEx5TZWN1cml0eSBDb21tdW5pY2F0aW9uIFJvb3RDQTEwggEiMA0GCSqGSIb3\r\n+DQEBAQUAA4IBDwAwggEKAoIBAQCzs\/5\/022x7xZ8V6UMbXaKL0u\/ZPtM7orw8yl8\r\n+9f\/uKuDp6bpbZCKamm8sOiZpUQWZJtzVHGpxxpp9Hp3dfGzGjGdnSj74cbAZJ6kJ\r\n+DKaVv0uMDPpVmDvY6CKhS3E4eayXkmmziX7qIWgGmBSWh9JhNrxtJ1aeV+7AwFb9\r\n+Ms+k2Y7CI9eNqPPYJayX5HA49LY6tJ07lyZDo6G8SVlyTCMwhwFY9k6+HGhWZq\/N\r\n+QV3Is00qVUarH9oe4kA92819uZKAnDfdDJZkndwi92SL32HeFZRSFaB9UslLqCHJ\r\n+xrHty8OVYNEP8Ktw+N\/LTX7s1vqr2b1\/VPKl6Xn62dZ2JChzAgMBAAGjPzA9MB0G\r\n+A1UdDgQWBBSgc0mZaNyFW2XjmygvV5+9M7wHSDALBgNVHQ8EBAMCAQYwDwYDVR0T\r\n+AQH\/BAUwAwEB\/zANBgkqhkiG9w0BAQUFAAOCAQEAaECpqLvkT115swW1F7NgE+vG\r\n+kl3g0dNq\/vu+m22\/xwVtWSDEHPC32oRYAmP6SBbvT6UL90qY8j+eG61Ha2POCEfr\r\n+Uj94nK9NrvjVT8+amCoQQTlSxN3Zmw7vkwGusi7KaEIkQmywszo+zenaSMQVy+n5\r\n+Bw+SUEmK3TGXX8npN6o7WWWXlDLJs58+OmJYxUmtYg5xpTKqL8aJdkNAExNnPaJU\r\n+JRDL8Try2frbSVa7pv6nQTXD4IhhyYjH3zYQIphZ6rBK+1YWc26sTfcioU+tHXot\r\n+RSflMMFe8toTyyVCUZVHA4xsIcx0Qu1T\/zOLjw9XARYvz6buyXAiFL39vmwLAw==\n+-----END CERTIFICATE-----\n","filename":"make\/data\/cacerts\/secomscrootca1","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -1,2 +1,2 @@\n-Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/88467c960d6cdad2ca1623e892e5e17506bc269f\/public_suffix_list.dat\n-Date: 2023-04-14\n+Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/3c213aab32b3c014f171b1673d4ce9b5cd72bf1c\/public_suffix_list.dat\n+Date: 2021-11-27\n","filename":"make\/data\/publicsuffixlist\/VERSION","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-\/\/ ac : http:\/\/nic.ac\/rules.htm\n+\/\/ ac : https:\/\/en.wikipedia.org\/wiki\/.ac\n@@ -25,1 +25,2 @@\n-\/\/ ae : https:\/\/tdra.gov.ae\/en\/aeda\/ae-policies\n+\/\/ ae : https:\/\/en.wikipedia.org\/wiki\/.ae\n+\/\/ see also: \"Domain Name Eligibility Policy\" at http:\/\/www.aeda.ae\/eng\/aepolicy.php\n@@ -383,2 +384,1 @@\n-\/\/ bj : https:\/\/nic.bj\/bj-suffixes.txt\n-\/\/ submitted by registry <contact@nic.bj>\n+\/\/ bj : https:\/\/en.wikipedia.org\/wiki\/.bj\n@@ -386,20 +386,3 @@\n-africa.bj\n-agro.bj\n-architectes.bj\n-assur.bj\n-avocats.bj\n-co.bj\n-com.bj\n-eco.bj\n-econo.bj\n-edu.bj\n-info.bj\n-loisirs.bj\n-money.bj\n-net.bj\n-org.bj\n-ote.bj\n-resto.bj\n-restaurant.bj\n-tourism.bj\n-univ.bj\n+asso.bj\n+barreau.bj\n+gouv.bj\n@@ -885,1 +868,0 @@\n-\/\/ namespace policies URL https:\/\/www.nic.cy\/portal\/\/sites\/default\/files\/symfonia_gia_eggrafi.pdf\n@@ -893,1 +875,1 @@\n-mil.cy\n+name.cy\n@@ -896,0 +878,1 @@\n+parliament.cy\n@@ -1054,1 +1037,2 @@\n-\/\/ fr : https:\/\/www.afnic.fr\/ https:\/\/www.afnic.fr\/wp-media\/uploads\/2022\/12\/afnic-naming-policy-2023-01-01.pdf\n+\/\/ fr : http:\/\/www.afnic.fr\/\n+\/\/ domaines descriptifs : https:\/\/www.afnic.fr\/medias\/documents\/Cadre_legal\/Afnic_Naming_Policy_12122016_VEN.pdf\n@@ -1062,1 +1046,1 @@\n-\/\/ Former \"domaines sectoriels\", still registration suffixes\n+\/\/ domaines sectoriels : https:\/\/www.afnic.fr\/en\/products-and-services\/the-fr-tld\/sector-based-fr-domains-4.html\n@@ -1335,3 +1319,1 @@\n-\/\/ il :         http:\/\/www.isoc.org.il\/domains\/\n-\/\/ see also:    https:\/\/en.isoc.org.il\/il-cctld\/registration-rules\n-\/\/ ISOC-IL      (operated by .il Registry)\n+\/\/ il : http:\/\/www.isoc.org.il\/domains\/\n@@ -1347,10 +1329,0 @@\n-\/\/ xn--4dbrk0ce (\"Israel\", Hebrew) : IL\n-ישראל\n-\/\/ xn--4dbgdty6c.xn--4dbrk0ce.\n-אקדמיה.ישראל\n-\/\/ xn--5dbhl8d.xn--4dbrk0ce.\n-ישוב.ישראל\n-\/\/ xn--8dbq2a.xn--4dbrk0ce.\n-צהל.ישראל\n-\/\/ xn--hebda8b.xn--4dbrk0ce.\n-ממשל.ישראל\n@@ -1372,1 +1344,1 @@\n-\/\/ see also: https:\/\/registry.in\/policies\n+\/\/ see also: https:\/\/registry.in\/Policies\n@@ -1376,10 +1348,0 @@\n-5g.in\n-6g.in\n-ac.in\n-ai.in\n-am.in\n-bihar.in\n-biz.in\n-business.in\n-ca.in\n-cn.in\n@@ -1387,7 +1349,0 @@\n-com.in\n-coop.in\n-cs.in\n-delhi.in\n-dr.in\n-edu.in\n-er.in\n@@ -1395,0 +1350,2 @@\n+net.in\n+org.in\n@@ -1396,2 +1353,0 @@\n-gov.in\n-gujarat.in\n@@ -1399,7 +1354,0 @@\n-info.in\n-int.in\n-internet.in\n-io.in\n-me.in\n-mil.in\n-net.in\n@@ -1407,4 +1355,2 @@\n-org.in\n-pg.in\n-post.in\n-pro.in\n+ac.in\n+edu.in\n@@ -1412,5 +1358,2 @@\n-travel.in\n-tv.in\n-uk.in\n-up.in\n-us.in\n+gov.in\n+mil.in\n@@ -1426,1 +1369,1 @@\n-\/\/ io : http:\/\/www.nic.io\/rules.htm\n+\/\/ io : http:\/\/www.nic.io\/rules.html\n@@ -3825,1 +3768,0 @@\n-com.ky\n@@ -3827,1 +3769,2 @@\n-net.ky\n+gov.ky\n+com.ky\n@@ -3829,0 +3772,1 @@\n+net.ky\n@@ -4072,1 +4016,2 @@\n-\/\/ museum : https:\/\/welcome.museum\/wp-content\/uploads\/2018\/05\/20180525-Registration-Policy-MUSEUM-EN_VF-2.pdf https:\/\/welcome.museum\/buy-your-dot-museum-2\/\n+\/\/ museum : http:\/\/about.museum\/naming\/\n+\/\/ http:\/\/index.museum\/\n@@ -4074,0 +4019,546 @@\n+academy.museum\n+agriculture.museum\n+air.museum\n+airguard.museum\n+alabama.museum\n+alaska.museum\n+amber.museum\n+ambulance.museum\n+american.museum\n+americana.museum\n+americanantiques.museum\n+americanart.museum\n+amsterdam.museum\n+and.museum\n+annefrank.museum\n+anthro.museum\n+anthropology.museum\n+antiques.museum\n+aquarium.museum\n+arboretum.museum\n+archaeological.museum\n+archaeology.museum\n+architecture.museum\n+art.museum\n+artanddesign.museum\n+artcenter.museum\n+artdeco.museum\n+arteducation.museum\n+artgallery.museum\n+arts.museum\n+artsandcrafts.museum\n+asmatart.museum\n+assassination.museum\n+assisi.museum\n+association.museum\n+astronomy.museum\n+atlanta.museum\n+austin.museum\n+australia.museum\n+automotive.museum\n+aviation.museum\n+axis.museum\n+badajoz.museum\n+baghdad.museum\n+bahn.museum\n+bale.museum\n+baltimore.museum\n+barcelona.museum\n+baseball.museum\n+basel.museum\n+baths.museum\n+bauern.museum\n+beauxarts.museum\n+beeldengeluid.museum\n+bellevue.museum\n+bergbau.museum\n+berkeley.museum\n+berlin.museum\n+bern.museum\n+bible.museum\n+bilbao.museum\n+bill.museum\n+birdart.museum\n+birthplace.museum\n+bonn.museum\n+boston.museum\n+botanical.museum\n+botanicalgarden.museum\n+botanicgarden.museum\n+botany.museum\n+brandywinevalley.museum\n+brasil.museum\n+bristol.museum\n+british.museum\n+britishcolumbia.museum\n+broadcast.museum\n+brunel.museum\n+brussel.museum\n+brussels.museum\n+bruxelles.museum\n+building.museum\n+burghof.museum\n+bus.museum\n+bushey.museum\n+cadaques.museum\n+california.museum\n+cambridge.museum\n+can.museum\n+canada.museum\n+capebreton.museum\n+carrier.museum\n+cartoonart.museum\n+casadelamoneda.museum\n+castle.museum\n+castres.museum\n+celtic.museum\n+center.museum\n+chattanooga.museum\n+cheltenham.museum\n+chesapeakebay.museum\n+chicago.museum\n+children.museum\n+childrens.museum\n+childrensgarden.museum\n+chiropractic.museum\n+chocolate.museum\n+christiansburg.museum\n+cincinnati.museum\n+cinema.museum\n+circus.museum\n+civilisation.museum\n+civilization.museum\n+civilwar.museum\n+clinton.museum\n+clock.museum\n+coal.museum\n+coastaldefence.museum\n+cody.museum\n+coldwar.museum\n+collection.museum\n+colonialwilliamsburg.museum\n+coloradoplateau.museum\n+columbia.museum\n+columbus.museum\n+communication.museum\n+communications.museum\n+community.museum\n+computer.museum\n+computerhistory.museum\n+comunicações.museum\n+contemporary.museum\n+contemporaryart.museum\n+convent.museum\n+copenhagen.museum\n+corporation.museum\n+correios-e-telecomunicações.museum\n+corvette.museum\n+costume.museum\n+countryestate.museum\n+county.museum\n+crafts.museum\n+cranbrook.museum\n+creation.museum\n+cultural.museum\n+culturalcenter.museum\n+culture.museum\n+cyber.museum\n+cymru.museum\n+dali.museum\n+dallas.museum\n+database.museum\n+ddr.museum\n+decorativearts.museum\n+delaware.museum\n+delmenhorst.museum\n+denmark.museum\n+depot.museum\n+design.museum\n+detroit.museum\n+dinosaur.museum\n+discovery.museum\n+dolls.museum\n+donostia.museum\n+durham.museum\n+eastafrica.museum\n+eastcoast.museum\n+education.museum\n+educational.museum\n+egyptian.museum\n+eisenbahn.museum\n+elburg.museum\n+elvendrell.museum\n+embroidery.museum\n+encyclopedic.museum\n+england.museum\n+entomology.museum\n+environment.museum\n+environmentalconservation.museum\n+epilepsy.museum\n+essex.museum\n+estate.museum\n+ethnology.museum\n+exeter.museum\n+exhibition.museum\n+family.museum\n+farm.museum\n+farmequipment.museum\n+farmers.museum\n+farmstead.museum\n+field.museum\n+figueres.museum\n+filatelia.museum\n+film.museum\n+fineart.museum\n+finearts.museum\n+finland.museum\n+flanders.museum\n+florida.museum\n+force.museum\n+fortmissoula.museum\n+fortworth.museum\n+foundation.museum\n+francaise.museum\n+frankfurt.museum\n+franziskaner.museum\n+freemasonry.museum\n+freiburg.museum\n+fribourg.museum\n+frog.museum\n+fundacio.museum\n+furniture.museum\n+gallery.museum\n+garden.museum\n+gateway.museum\n+geelvinck.museum\n+gemological.museum\n+geology.museum\n+georgia.museum\n+giessen.museum\n+glas.museum\n+glass.museum\n+gorge.museum\n+grandrapids.museum\n+graz.museum\n+guernsey.museum\n+halloffame.museum\n+hamburg.museum\n+handson.museum\n+harvestcelebration.museum\n+hawaii.museum\n+health.museum\n+heimatunduhren.museum\n+hellas.museum\n+helsinki.museum\n+hembygdsforbund.museum\n+heritage.museum\n+histoire.museum\n+historical.museum\n+historicalsociety.museum\n+historichouses.museum\n+historisch.museum\n+historisches.museum\n+history.museum\n+historyofscience.museum\n+horology.museum\n+house.museum\n+humanities.museum\n+illustration.museum\n+imageandsound.museum\n+indian.museum\n+indiana.museum\n+indianapolis.museum\n+indianmarket.museum\n+intelligence.museum\n+interactive.museum\n+iraq.museum\n+iron.museum\n+isleofman.museum\n+jamison.museum\n+jefferson.museum\n+jerusalem.museum\n+jewelry.museum\n+jewish.museum\n+jewishart.museum\n+jfk.museum\n+journalism.museum\n+judaica.museum\n+judygarland.museum\n+juedisches.museum\n+juif.museum\n+karate.museum\n+karikatur.museum\n+kids.museum\n+koebenhavn.museum\n+koeln.museum\n+kunst.museum\n+kunstsammlung.museum\n+kunstunddesign.museum\n+labor.museum\n+labour.museum\n+lajolla.museum\n+lancashire.museum\n+landes.museum\n+lans.museum\n+läns.museum\n+larsson.museum\n+lewismiller.museum\n+lincoln.museum\n+linz.museum\n+living.museum\n+livinghistory.museum\n+localhistory.museum\n+london.museum\n+losangeles.museum\n+louvre.museum\n+loyalist.museum\n+lucerne.museum\n+luxembourg.museum\n+luzern.museum\n+mad.museum\n+madrid.museum\n+mallorca.museum\n+manchester.museum\n+mansion.museum\n+mansions.museum\n+manx.museum\n+marburg.museum\n+maritime.museum\n+maritimo.museum\n+maryland.museum\n+marylhurst.museum\n+media.museum\n+medical.museum\n+medizinhistorisches.museum\n+meeres.museum\n+memorial.museum\n+mesaverde.museum\n+michigan.museum\n+midatlantic.museum\n+military.museum\n+mill.museum\n+miners.museum\n+mining.museum\n+minnesota.museum\n+missile.museum\n+missoula.museum\n+modern.museum\n+moma.museum\n+money.museum\n+monmouth.museum\n+monticello.museum\n+montreal.museum\n+moscow.museum\n+motorcycle.museum\n+muenchen.museum\n+muenster.museum\n+mulhouse.museum\n+muncie.museum\n+museet.museum\n+museumcenter.museum\n+museumvereniging.museum\n+music.museum\n+national.museum\n+nationalfirearms.museum\n+nationalheritage.museum\n+nativeamerican.museum\n+naturalhistory.museum\n+naturalhistorymuseum.museum\n+naturalsciences.museum\n+nature.museum\n+naturhistorisches.museum\n+natuurwetenschappen.museum\n+naumburg.museum\n+naval.museum\n+nebraska.museum\n+neues.museum\n+newhampshire.museum\n+newjersey.museum\n+newmexico.museum\n+newport.museum\n+newspaper.museum\n+newyork.museum\n+niepce.museum\n+norfolk.museum\n+north.museum\n+nrw.museum\n+nyc.museum\n+nyny.museum\n+oceanographic.museum\n+oceanographique.museum\n+omaha.museum\n+online.museum\n+ontario.museum\n+openair.museum\n+oregon.museum\n+oregontrail.museum\n+otago.museum\n+oxford.museum\n+pacific.museum\n+paderborn.museum\n+palace.museum\n+paleo.museum\n+palmsprings.museum\n+panama.museum\n+paris.museum\n+pasadena.museum\n+pharmacy.museum\n+philadelphia.museum\n+philadelphiaarea.museum\n+philately.museum\n+phoenix.museum\n+photography.museum\n+pilots.museum\n+pittsburgh.museum\n+planetarium.museum\n+plantation.museum\n+plants.museum\n+plaza.museum\n+portal.museum\n+portland.museum\n+portlligat.museum\n+posts-and-telecommunications.museum\n+preservation.museum\n+presidio.museum\n+press.museum\n+project.museum\n+public.museum\n+pubol.museum\n+quebec.museum\n+railroad.museum\n+railway.museum\n+research.museum\n+resistance.museum\n+riodejaneiro.museum\n+rochester.museum\n+rockart.museum\n+roma.museum\n+russia.museum\n+saintlouis.museum\n+salem.museum\n+salvadordali.museum\n+salzburg.museum\n+sandiego.museum\n+sanfrancisco.museum\n+santabarbara.museum\n+santacruz.museum\n+santafe.museum\n+saskatchewan.museum\n+satx.museum\n+savannahga.museum\n+schlesisches.museum\n+schoenbrunn.museum\n+schokoladen.museum\n+school.museum\n+schweiz.museum\n+science.museum\n+scienceandhistory.museum\n+scienceandindustry.museum\n+sciencecenter.museum\n+sciencecenters.museum\n+science-fiction.museum\n+sciencehistory.museum\n+sciences.museum\n+sciencesnaturelles.museum\n+scotland.museum\n+seaport.museum\n+settlement.museum\n+settlers.museum\n+shell.museum\n+sherbrooke.museum\n+sibenik.museum\n+silk.museum\n+ski.museum\n+skole.museum\n+society.museum\n+sologne.museum\n+soundandvision.museum\n+southcarolina.museum\n+southwest.museum\n+space.museum\n+spy.museum\n+square.museum\n+stadt.museum\n+stalbans.museum\n+starnberg.museum\n+state.museum\n+stateofdelaware.museum\n+station.museum\n+steam.museum\n+steiermark.museum\n+stjohn.museum\n+stockholm.museum\n+stpetersburg.museum\n+stuttgart.museum\n+suisse.museum\n+surgeonshall.museum\n+surrey.museum\n+svizzera.museum\n+sweden.museum\n+sydney.museum\n+tank.museum\n+tcm.museum\n+technology.museum\n+telekommunikation.museum\n+television.museum\n+texas.museum\n+textile.museum\n+theater.museum\n+time.museum\n+timekeeping.museum\n+topology.museum\n+torino.museum\n+touch.museum\n+town.museum\n+transport.museum\n+tree.museum\n+trolley.museum\n+trust.museum\n+trustee.museum\n+uhren.museum\n+ulm.museum\n+undersea.museum\n+university.museum\n+usa.museum\n+usantiques.museum\n+usarts.museum\n+uscountryestate.museum\n+usculture.museum\n+usdecorativearts.museum\n+usgarden.museum\n+ushistory.museum\n+ushuaia.museum\n+uslivinghistory.museum\n+utah.museum\n+uvic.museum\n+valley.museum\n+vantaa.museum\n+versailles.museum\n+viking.museum\n+village.museum\n+virginia.museum\n+virtual.museum\n+virtuel.museum\n+vlaanderen.museum\n+volkenkunde.museum\n+wales.museum\n+wallonie.museum\n+war.museum\n+washingtondc.museum\n+watchandclock.museum\n+watch-and-clock.museum\n+western.museum\n+westfalen.museum\n+whaling.museum\n+wildlife.museum\n+williamsburg.museum\n+windmill.museum\n+workshop.museum\n+york.museum\n+yorkshire.museum\n+yosemite.museum\n+youth.museum\n+zoological.museum\n+zoology.museum\n+ירושלים.museum\n+иком.museum\n@@ -5316,1 +5807,1 @@\n-\/\/ pm : https:\/\/www.afnic.fr\/wp-media\/uploads\/2022\/12\/afnic-naming-policy-2023-01-01.pdf\n+\/\/ pm : http:\/\/www.afnic.fr\/medias\/documents\/AFNIC-naming-policy2012.pdf\n@@ -5414,1 +5905,1 @@\n-\/\/ re : https:\/\/www.afnic.fr\/wp-media\/uploads\/2022\/12\/afnic-naming-policy-2023-01-01.pdf\n+\/\/ re : http:\/\/www.afnic.re\/obtenir\/chartes\/nommage-re\/annexe-descriptifs\n@@ -5549,1 +6040,1 @@\n-\/\/ sh : http:\/\/nic.sh\/rules.htm\n+\/\/ sh : http:\/\/www.nic.sh\/registrar.html\n@@ -5671,1 +6162,1 @@\n-\/\/ tf : https:\/\/www.afnic.fr\/wp-media\/uploads\/2022\/12\/afnic-naming-policy-2023-01-01.pdf\n+\/\/ tf : https:\/\/en.wikipedia.org\/wiki\/.tf\n@@ -6290,1 +6781,1 @@\n-\/\/ wf : https:\/\/www.afnic.fr\/wp-media\/uploads\/2022\/12\/afnic-naming-policy-2023-01-01.pdf\n+\/\/ wf : http:\/\/www.afnic.fr\/medias\/documents\/AFNIC-naming-policy2012.pdf\n@@ -6302,1 +6793,1 @@\n-\/\/ yt : https:\/\/www.afnic.fr\/wp-media\/uploads\/2022\/12\/afnic-naming-policy-2023-01-01.pdf\n+\/\/ yt : http:\/\/www.afnic.fr\/medias\/documents\/AFNIC-naming-policy2012.pdf\n@@ -6644,1 +7135,1 @@\n-\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2023-04-14T15:13:16Z\n+\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2021-11-13T15:12:42Z\n@@ -6694,0 +7185,3 @@\n+\/\/ adac : 2015-07-16 Allgemeiner Deutscher Automobil-Club e.V. (ADAC)\n+adac\n+\n@@ -6706,0 +7200,3 @@\n+\/\/ afamilycompany : 2015-07-23 Johnson Shareholdings, Inc.\n+afamilycompany\n+\n@@ -6811,1 +7308,1 @@\n-\/\/ archi : 2014-02-06 Identity Digital Limited\n+\/\/ archi : 2014-02-06 Afilias Limited\n@@ -6844,1 +7341,1 @@\n-\/\/ audio : 2014-03-20 XYZ.COM LLC\n+\/\/ audio : 2014-03-20 UNR Corp.\n@@ -6859,1 +7356,1 @@\n-\/\/ avianca : 2015-01-08 Avianca Inc.\n+\/\/ avianca : 2015-01-08 Avianca Holdings S.A.\n@@ -6955,1 +7452,1 @@\n-\/\/ bet : 2015-05-07 Identity Digital Limited\n+\/\/ bet : 2015-05-07 Afilias Limited\n@@ -6976,1 +7473,1 @@\n-\/\/ bio : 2014-03-06 Identity Digital Limited\n+\/\/ bio : 2014-03-06 Afilias Limited\n@@ -6979,1 +7476,1 @@\n-\/\/ black : 2014-01-16 Identity Digital Limited\n+\/\/ black : 2014-01-16 Afilias Limited\n@@ -6982,1 +7479,1 @@\n-\/\/ blackfriday : 2014-01-16 Registry Services, LLC\n+\/\/ blackfriday : 2014-01-16 UNR Corp.\n@@ -6994,1 +7491,1 @@\n-\/\/ blue : 2013-11-07 Identity Digital Limited\n+\/\/ blue : 2013-11-07 Afilias Limited\n@@ -7036,1 +7533,1 @@\n-\/\/ boston : 2015-12-10 Registry Services, LLC\n+\/\/ boston : 2015-12-10 Boston TLD Management, LLC\n@@ -7066,0 +7563,6 @@\n+\/\/ budapest : 2013-11-21 Minds + Machines Group Limited\n+budapest\n+\n+\/\/ bugatti : 2015-07-23 Bugatti International SA\n+bugatti\n+\n@@ -7099,1 +7602,1 @@\n-\/\/ cam : 2016-04-21 Cam Connecting SARL\n+\/\/ cam : 2016-04-21 AC Webconnecting Holding B.V.\n@@ -7108,0 +7611,3 @@\n+\/\/ cancerresearch : 2014-05-15 Australian Cancer Research Foundation\n+cancerresearch\n+\n@@ -7144,1 +7650,1 @@\n-\/\/ case : 2015-09-03 Digity, LLC\n+\/\/ case : 2015-09-03 Helium TLDs Ltd\n@@ -7192,1 +7698,1 @@\n-\/\/ charity : 2018-04-11 Public Interest Registry\n+\/\/ charity : 2018-04-11 Binky Moon, LLC\n@@ -7207,1 +7713,1 @@\n-\/\/ christmas : 2013-11-21 XYZ.COM LLC\n+\/\/ christmas : 2013-11-21 UNR Corp.\n@@ -7246,1 +7752,1 @@\n-\/\/ click : 2014-06-05 Internet Naming Company LLC\n+\/\/ click : 2014-06-05 UNR Corp.\n@@ -7330,1 +7836,1 @@\n-\/\/ country : 2013-12-19 Internet Naming Company LLC\n+\/\/ country : 2013-12-19 DotCountry LLC\n@@ -7339,1 +7845,1 @@\n-\/\/ courses : 2014-12-04 Registry Services, LLC\n+\/\/ courses : 2014-12-04 OPEN UNIVERSITIES AUSTRALIA PTY LTD\n@@ -7369,0 +7875,3 @@\n+\/\/ csc : 2014-09-25 Alliance-One Services, Inc.\n+csc\n+\n@@ -7456,1 +7965,1 @@\n-\/\/ diet : 2014-06-26 XYZ.COM LLC\n+\/\/ diet : 2014-06-26 UNR Corp.\n@@ -7510,0 +8019,3 @@\n+\/\/ duck : 2015-07-23 Johnson Shareholdings, Inc.\n+duck\n+\n@@ -7525,1 +8037,1 @@\n-\/\/ earth : 2014-12-04 Interlink Systems Innovation Institute K.K.\n+\/\/ earth : 2014-12-04 Interlink Co., Ltd.\n@@ -7702,1 +8214,1 @@\n-\/\/ flowers : 2014-10-09 XYZ.COM LLC\n+\/\/ flowers : 2014-10-09 UNR Corp.\n@@ -7732,1 +8244,1 @@\n-\/\/ foundation : 2013-12-05 Public Interest Registry\n+\/\/ foundation : 2013-12-05 Binky Moon, LLC\n@@ -7789,1 +8301,1 @@\n-\/\/ game : 2015-05-28 XYZ.COM LLC\n+\/\/ game : 2015-05-28 UNR Corp.\n@@ -7813,1 +8325,1 @@\n-\/\/ gent : 2014-01-23 Easyhost BV\n+\/\/ gent : 2014-01-23 COMBELL NV\n@@ -7831,1 +8343,1 @@\n-\/\/ gives : 2014-03-06 Public Interest Registry\n+\/\/ gives : 2014-03-06 Dog Beach, LLC\n@@ -7834,1 +8346,1 @@\n-\/\/ giving : 2014-11-13 Public Interest Registry\n+\/\/ giving : 2014-11-13 Giving Limited\n@@ -7837,0 +8349,3 @@\n+\/\/ glade : 2015-07-23 Johnson Shareholdings, Inc.\n+glade\n+\n@@ -7843,1 +8358,1 @@\n-\/\/ global : 2014-04-17 Identity Digital Limited\n+\/\/ global : 2014-04-17 Dot Global Domain Registry Limited\n@@ -7900,1 +8415,1 @@\n-\/\/ green : 2014-05-08 Identity Digital Limited\n+\/\/ green : 2014-05-08 Afilias Limited\n@@ -7924,1 +8439,1 @@\n-\/\/ guitars : 2013-11-14 XYZ.COM LLC\n+\/\/ guitars : 2013-11-14 UNR Corp.\n@@ -7957,1 +8472,1 @@\n-\/\/ help : 2014-06-26 Innovation service Limited\n+\/\/ help : 2014-06-26 UNR Corp.\n@@ -7972,1 +8487,1 @@\n-\/\/ hiphop : 2014-03-06 Dot Hip Hop, LLC\n+\/\/ hiphop : 2014-03-06 UNR Corp.\n@@ -7981,1 +8496,1 @@\n-\/\/ hiv : 2014-03-13 Internet Naming Company LLC\n+\/\/ hiv : 2014-03-13 UNR Corp.\n@@ -8020,1 +8535,1 @@\n-\/\/ hosting : 2014-05-29 XYZ.COM LLC\n+\/\/ hosting : 2014-05-29 UNR Corp.\n@@ -8185,1 +8700,1 @@\n-\/\/ juegos : 2014-03-20 Internet Naming Company LLC\n+\/\/ juegos : 2014-03-20 UNR Corp.\n@@ -8215,1 +8730,1 @@\n-\/\/ kim : 2013-09-23 Identity Digital Limited\n+\/\/ kim : 2013-09-23 Afilias Limited\n@@ -8284,1 +8799,1 @@\n-\/\/ lat : 2014-10-16 XYZ.COM LLC\n+\/\/ lat : 2014-10-16 ECOM-LAC Federaciòn de Latinoamèrica y el Caribe para Internet y el Comercio Electrònico\n@@ -8320,1 +8835,1 @@\n-\/\/ lgbt : 2014-05-08 Identity Digital Limited\n+\/\/ lgbt : 2014-05-08 Afilias Limited\n@@ -8353,1 +8868,4 @@\n-\/\/ link : 2013-11-14 Nova Registry Ltd\n+\/\/ linde : 2014-12-04 Linde Aktiengesellschaft\n+linde\n+\n+\/\/ link : 2013-11-14 UNR Corp.\n@@ -8365,1 +8883,4 @@\n-\/\/ llc : 2017-12-14 Identity Digital Limited\n+\/\/ lixil : 2015-03-19 LIXIL Group Corporation\n+lixil\n+\n+\/\/ llc : 2017-12-14 Afilias Limited\n@@ -8368,1 +8889,1 @@\n-\/\/ llp : 2019-08-26 Intercap Registry Inc.\n+\/\/ llp : 2019-08-26 UNR Corp.\n@@ -8383,1 +8904,4 @@\n-\/\/ lol : 2015-01-30 XYZ.COM LLC\n+\/\/ loft : 2015-07-30 Annco, Inc.\n+loft\n+\n+\/\/ lol : 2015-01-30 UNR Corp.\n@@ -8392,1 +8916,1 @@\n-\/\/ lotto : 2014-04-10 Identity Digital Limited\n+\/\/ lotto : 2014-04-10 Afilias Limited\n@@ -8419,0 +8943,3 @@\n+\/\/ macys : 2015-07-31 Macys, Inc.\n+macys\n+\n@@ -8497,1 +9024,1 @@\n-\/\/ miami : 2013-12-19 Registry Services, LLC\n+\/\/ miami : 2013-12-19 Minds + Machines Group Limited\n@@ -8530,1 +9057,1 @@\n-\/\/ moe : 2013-11-13 Interlink Systems Innovation Institute K.K.\n+\/\/ moe : 2013-11-13 Interlink Co., Ltd.\n@@ -8536,1 +9063,1 @@\n-\/\/ mom : 2015-04-16 XYZ.COM LLC\n+\/\/ mom : 2015-04-16 UNR Corp.\n@@ -8692,0 +9219,3 @@\n+\/\/ off : 2015-07-23 Johnson Shareholdings, Inc.\n+off\n+\n@@ -8737,1 +9267,1 @@\n-\/\/ organic : 2014-03-27 Identity Digital Limited\n+\/\/ organic : 2014-03-27 Afilias Limited\n@@ -8758,1 +9288,1 @@\n-\/\/ panasonic : 2015-07-30 Panasonic Holdings Corporation\n+\/\/ panasonic : 2015-07-30 Panasonic Corporation\n@@ -8785,1 +9315,1 @@\n-\/\/ pet : 2015-05-07 Identity Digital Limited\n+\/\/ pet : 2015-05-07 Afilias Limited\n@@ -8803,1 +9333,1 @@\n-\/\/ photo : 2013-11-14 Registry Services, LLC\n+\/\/ photo : 2013-11-14 UNR Corp.\n@@ -8815,1 +9345,1 @@\n-\/\/ pics : 2013-11-14 XYZ.COM LLC\n+\/\/ pics : 2013-11-14 UNR Corp.\n@@ -8833,1 +9363,1 @@\n-\/\/ pink : 2013-10-01 Identity Digital Limited\n+\/\/ pink : 2013-10-01 Afilias Limited\n@@ -8863,1 +9393,1 @@\n-\/\/ poker : 2014-07-03 Identity Digital Limited\n+\/\/ poker : 2014-07-03 Afilias Limited\n@@ -8896,1 +9426,1 @@\n-\/\/ promo : 2014-12-18 Identity Digital Limited\n+\/\/ promo : 2014-12-18 Afilias Limited\n@@ -8902,1 +9432,1 @@\n-\/\/ property : 2014-05-22 Internet Naming Company LLC\n+\/\/ property : 2014-05-22 UNR Corp.\n@@ -8920,1 +9450,1 @@\n-\/\/ qpon : 2013-11-14 dotQPON LLC\n+\/\/ qpon : 2013-11-14 dotCOOL, Inc.\n@@ -8935,0 +9465,3 @@\n+\/\/ raid : 2015-07-23 Johnson Shareholdings, Inc.\n+raid\n+\n@@ -8950,1 +9483,1 @@\n-\/\/ red : 2013-11-07 Identity Digital Limited\n+\/\/ red : 2013-11-07 Afilias Limited\n@@ -9046,1 +9579,1 @@\n-\/\/ ruhr : 2013-10-02 dotSaarland GmbH\n+\/\/ ruhr : 2013-10-02 regiodot GmbH & Co. KG\n@@ -9139,0 +9672,3 @@\n+\/\/ scjohnson : 2015-07-23 Johnson Shareholdings, Inc.\n+scjohnson\n+\n@@ -9166,0 +9702,3 @@\n+\/\/ ses : 2015-07-23 SES\n+ses\n+\n@@ -9175,1 +9714,1 @@\n-\/\/ sexy : 2013-09-11 Internet Naming Company LLC\n+\/\/ sexy : 2013-09-11 UNR Corp.\n@@ -9196,1 +9735,1 @@\n-\/\/ shiksha : 2013-11-14 Identity Digital Limited\n+\/\/ shiksha : 2013-11-14 Afilias Limited\n@@ -9229,1 +9768,1 @@\n-\/\/ ski : 2015-04-09 Identity Digital Limited\n+\/\/ ski : 2015-04-09 Afilias Limited\n@@ -9250,1 +9789,1 @@\n-\/\/ sncf : 2015-02-19 Société Nationale SNCF\n+\/\/ sncf : 2015-02-19 Société Nationale des Chemins de fer Francais S N C F\n@@ -9334,1 +9873,1 @@\n-\/\/ study : 2014-12-11 Registry Services, LLC\n+\/\/ study : 2014-12-11 OPEN UNIVERSITIES AUSTRALIA PTY LTD\n@@ -9394,1 +9933,1 @@\n-\/\/ tattoo : 2013-08-30 Top Level Design, LLC\n+\/\/ tattoo : 2013-08-30 UNR Corp.\n@@ -9487,1 +10026,1 @@\n-\/\/ total : 2015-08-06 TotalEnergies SE\n+\/\/ total : 2015-08-06 Total SA\n@@ -9523,1 +10062,1 @@\n-\/\/ trust : 2014-10-16 Internet Naming Company LLC\n+\/\/ trust : 2014-10-16 UNR Corp.\n@@ -9670,1 +10209,1 @@\n-\/\/ watches : 2014-12-22 Identity Digital Limited\n+\/\/ watches : 2014-12-22 Afilias Limited\n@@ -9805,1 +10344,1 @@\n-\/\/ xn--6frz82g : 2013-09-23 Identity Digital Limited\n+\/\/ xn--6frz82g : 2013-09-23 Afilias Limited\n@@ -9922,0 +10461,3 @@\n+\/\/ xn--jlq61u9w7b : 2015-01-08 Nokia Corporation\n+诺基亚\n+\n@@ -10109,8 +10651,0 @@\n-\/\/ Acorn Labs : https:\/\/acorn.io\n-\/\/ Submitted by Craig Jellick <domains@acorn.io>\n-*.on-acorn.io\n-\n-\/\/ ActiveTrail: https:\/\/www.activetrail.biz\/\n-\/\/ Submitted by Ofer Kalaora <postmaster@activetrail.com>\n-activetrail.biz\n-\n@@ -10126,5 +10660,0 @@\n-\/\/ Adobe Developer Platform : https:\/\/developer.adobe.com\n-\/\/ Submitted by Jesse MacFadyen<jessem@adobe.com>\n-adobeio-static.net\n-adobeioruntime.net\n-\n@@ -10135,28 +10664,0 @@\n-\/\/ Airkit : https:\/\/www.airkit.com\/\n-\/\/ Submitted by Grant Cooksey <security@airkit.com>\n-airkitapps.com\n-airkitapps-au.com\n-airkitapps.eu\n-\n-\/\/ Aiven: https:\/\/aiven.io\/\n-\/\/ Submitted by Etienne Stalmans <security@aiven.io>\n-aivencloud.com\n-\n-\/\/ Akamai : https:\/\/www.akamai.com\/\n-\/\/ Submitted by Akamai Team <publicsuffixlist@akamai.com>\n-akadns.net\n-akamai.net\n-akamai-staging.net\n-akamaiedge.net\n-akamaiedge-staging.net\n-akamaihd.net\n-akamaihd-staging.net\n-akamaiorigin.net\n-akamaiorigin-staging.net\n-akamaized.net\n-akamaized-staging.net\n-edgekey.net\n-edgekey-staging.net\n-edgesuite.net\n-edgesuite-staging.net\n-\n@@ -10184,9 +10685,1 @@\n-\/\/ Amaze Software : https:\/\/amaze.co\n-\/\/ Submitted by Domain Admin <domainadmin@amaze.co>\n-myamaze.net\n-\n-\/\/ Amazon : https:\/\/www.amazon.com\/\n-\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n-\/\/ Subsections of Amazon\/subsidiaries will appear until \"concludes\" tag\n-\n-\/\/ Amazon CloudFront\n+\/\/ Amazon CloudFront : https:\/\/aws.amazon.com\/cloudfront\/\n@@ -10194,1 +10687,0 @@\n-\/\/ Reference: 54144616-fd49-4435-8535-19c6a601bdb3\n@@ -10197,1 +10689,1 @@\n-\/\/ Amazon EC2\n+\/\/ Amazon Elastic Compute Cloud : https:\/\/aws.amazon.com\/ec2\/\n@@ -10199,1 +10691,0 @@\n-\/\/ Reference: 4c38fa71-58ac-4768-99e5-689c1767e537\n@@ -10205,105 +10696,1 @@\n-\/\/ Amazon S3\n-\/\/ Submitted by Luke Wells <psl-maintainers@amazon.com>\n-\/\/ Reference: d068bd97-f0a9-4838-a6d8-954b622ef4ae\n-s3.cn-north-1.amazonaws.com.cn\n-s3.dualstack.ap-northeast-1.amazonaws.com\n-s3.dualstack.ap-northeast-2.amazonaws.com\n-s3.ap-northeast-2.amazonaws.com\n-s3-website.ap-northeast-2.amazonaws.com\n-s3.dualstack.ap-south-1.amazonaws.com\n-s3.ap-south-1.amazonaws.com\n-s3-website.ap-south-1.amazonaws.com\n-s3.dualstack.ap-southeast-1.amazonaws.com\n-s3.dualstack.ap-southeast-2.amazonaws.com\n-s3.dualstack.ca-central-1.amazonaws.com\n-s3.ca-central-1.amazonaws.com\n-s3-website.ca-central-1.amazonaws.com\n-s3.dualstack.eu-central-1.amazonaws.com\n-s3.eu-central-1.amazonaws.com\n-s3-website.eu-central-1.amazonaws.com\n-s3.dualstack.eu-west-1.amazonaws.com\n-s3.dualstack.eu-west-2.amazonaws.com\n-s3.eu-west-2.amazonaws.com\n-s3-website.eu-west-2.amazonaws.com\n-s3.dualstack.eu-west-3.amazonaws.com\n-s3.eu-west-3.amazonaws.com\n-s3-website.eu-west-3.amazonaws.com\n-s3.amazonaws.com\n-s3-ap-northeast-1.amazonaws.com\n-s3-ap-northeast-2.amazonaws.com\n-s3-ap-south-1.amazonaws.com\n-s3-ap-southeast-1.amazonaws.com\n-s3-ap-southeast-2.amazonaws.com\n-s3-ca-central-1.amazonaws.com\n-s3-eu-central-1.amazonaws.com\n-s3-eu-west-1.amazonaws.com\n-s3-eu-west-2.amazonaws.com\n-s3-eu-west-3.amazonaws.com\n-s3-external-1.amazonaws.com\n-s3-fips-us-gov-west-1.amazonaws.com\n-s3-sa-east-1.amazonaws.com\n-s3-us-east-2.amazonaws.com\n-s3-us-gov-west-1.amazonaws.com\n-s3-us-west-1.amazonaws.com\n-s3-us-west-2.amazonaws.com\n-s3-website-ap-northeast-1.amazonaws.com\n-s3-website-ap-southeast-1.amazonaws.com\n-s3-website-ap-southeast-2.amazonaws.com\n-s3-website-eu-west-1.amazonaws.com\n-s3-website-sa-east-1.amazonaws.com\n-s3-website-us-east-1.amazonaws.com\n-s3-website-us-west-1.amazonaws.com\n-s3-website-us-west-2.amazonaws.com\n-s3.dualstack.sa-east-1.amazonaws.com\n-s3.dualstack.us-east-1.amazonaws.com\n-s3.dualstack.us-east-2.amazonaws.com\n-s3.us-east-2.amazonaws.com\n-s3-website.us-east-2.amazonaws.com\n-\n-\/\/ AWS Cloud9\n-\/\/ Submitted by: AWS Security <psl-maintainers@amazon.com>\n-\/\/ Reference: 2b6dfa9a-3a7f-4367-b2e7-0321e77c0d59\n-vfs.cloud9.af-south-1.amazonaws.com\n-webview-assets.cloud9.af-south-1.amazonaws.com\n-vfs.cloud9.ap-east-1.amazonaws.com\n-webview-assets.cloud9.ap-east-1.amazonaws.com\n-vfs.cloud9.ap-northeast-1.amazonaws.com\n-webview-assets.cloud9.ap-northeast-1.amazonaws.com\n-vfs.cloud9.ap-northeast-2.amazonaws.com\n-webview-assets.cloud9.ap-northeast-2.amazonaws.com\n-vfs.cloud9.ap-northeast-3.amazonaws.com\n-webview-assets.cloud9.ap-northeast-3.amazonaws.com\n-vfs.cloud9.ap-south-1.amazonaws.com\n-webview-assets.cloud9.ap-south-1.amazonaws.com\n-vfs.cloud9.ap-southeast-1.amazonaws.com\n-webview-assets.cloud9.ap-southeast-1.amazonaws.com\n-vfs.cloud9.ap-southeast-2.amazonaws.com\n-webview-assets.cloud9.ap-southeast-2.amazonaws.com\n-vfs.cloud9.ca-central-1.amazonaws.com\n-webview-assets.cloud9.ca-central-1.amazonaws.com\n-vfs.cloud9.eu-central-1.amazonaws.com\n-webview-assets.cloud9.eu-central-1.amazonaws.com\n-vfs.cloud9.eu-north-1.amazonaws.com\n-webview-assets.cloud9.eu-north-1.amazonaws.com\n-vfs.cloud9.eu-south-1.amazonaws.com\n-webview-assets.cloud9.eu-south-1.amazonaws.com\n-vfs.cloud9.eu-west-1.amazonaws.com\n-webview-assets.cloud9.eu-west-1.amazonaws.com\n-vfs.cloud9.eu-west-2.amazonaws.com\n-webview-assets.cloud9.eu-west-2.amazonaws.com\n-vfs.cloud9.eu-west-3.amazonaws.com\n-webview-assets.cloud9.eu-west-3.amazonaws.com\n-vfs.cloud9.me-south-1.amazonaws.com\n-webview-assets.cloud9.me-south-1.amazonaws.com\n-vfs.cloud9.sa-east-1.amazonaws.com\n-webview-assets.cloud9.sa-east-1.amazonaws.com\n-vfs.cloud9.us-east-1.amazonaws.com\n-webview-assets.cloud9.us-east-1.amazonaws.com\n-vfs.cloud9.us-east-2.amazonaws.com\n-webview-assets.cloud9.us-east-2.amazonaws.com\n-vfs.cloud9.us-west-1.amazonaws.com\n-webview-assets.cloud9.us-west-1.amazonaws.com\n-vfs.cloud9.us-west-2.amazonaws.com\n-webview-assets.cloud9.us-west-2.amazonaws.com\n-\n-\/\/ AWS Elastic Beanstalk\n+\/\/ Amazon Elastic Beanstalk : https:\/\/aws.amazon.com\/elasticbeanstalk\/\n@@ -10311,1 +10698,0 @@\n-\/\/ Reference: aa202394-43a0-4857-b245-8db04549137e\n@@ -10333,1 +10719,1 @@\n-\/\/ (AWS) Elastic Load Balancing\n+\/\/ Amazon Elastic Load Balancing : https:\/\/aws.amazon.com\/elasticloadbalancing\/\n@@ -10335,2 +10721,0 @@\n-\/\/ Reference: 12a3d528-1bac-4433-a359-a395867ffed2\n-*.elb.amazonaws.com.cn\n@@ -10338,0 +10722,1 @@\n+*.elb.amazonaws.com.cn\n@@ -10339,1 +10724,1 @@\n-\/\/ AWS Global Accelerator\n+\/\/ Amazon Global Accelerator : https:\/\/aws.amazon.com\/global-accelerator\/\n@@ -10341,1 +10726,0 @@\n-\/\/ Reference: d916759d-a08b-4241-b536-4db887383a6a\n@@ -10344,7 +10728,56 @@\n-\/\/ eero\n-\/\/ Submitted by Yue Kang <eero-dynamic-dns@amazon.com>\n-\/\/ Reference: 264afe70-f62c-4c02-8ab9-b5281ed24461\n-eero.online\n-eero-stage.online\n-\n-\/\/ concludes Amazon\n+\/\/ Amazon S3 : https:\/\/aws.amazon.com\/s3\/\n+\/\/ Submitted by Luke Wells <psl-maintainers@amazon.com>\n+s3.amazonaws.com\n+s3-ap-northeast-1.amazonaws.com\n+s3-ap-northeast-2.amazonaws.com\n+s3-ap-south-1.amazonaws.com\n+s3-ap-southeast-1.amazonaws.com\n+s3-ap-southeast-2.amazonaws.com\n+s3-ca-central-1.amazonaws.com\n+s3-eu-central-1.amazonaws.com\n+s3-eu-west-1.amazonaws.com\n+s3-eu-west-2.amazonaws.com\n+s3-eu-west-3.amazonaws.com\n+s3-external-1.amazonaws.com\n+s3-fips-us-gov-west-1.amazonaws.com\n+s3-sa-east-1.amazonaws.com\n+s3-us-gov-west-1.amazonaws.com\n+s3-us-east-2.amazonaws.com\n+s3-us-west-1.amazonaws.com\n+s3-us-west-2.amazonaws.com\n+s3.ap-northeast-2.amazonaws.com\n+s3.ap-south-1.amazonaws.com\n+s3.cn-north-1.amazonaws.com.cn\n+s3.ca-central-1.amazonaws.com\n+s3.eu-central-1.amazonaws.com\n+s3.eu-west-2.amazonaws.com\n+s3.eu-west-3.amazonaws.com\n+s3.us-east-2.amazonaws.com\n+s3.dualstack.ap-northeast-1.amazonaws.com\n+s3.dualstack.ap-northeast-2.amazonaws.com\n+s3.dualstack.ap-south-1.amazonaws.com\n+s3.dualstack.ap-southeast-1.amazonaws.com\n+s3.dualstack.ap-southeast-2.amazonaws.com\n+s3.dualstack.ca-central-1.amazonaws.com\n+s3.dualstack.eu-central-1.amazonaws.com\n+s3.dualstack.eu-west-1.amazonaws.com\n+s3.dualstack.eu-west-2.amazonaws.com\n+s3.dualstack.eu-west-3.amazonaws.com\n+s3.dualstack.sa-east-1.amazonaws.com\n+s3.dualstack.us-east-1.amazonaws.com\n+s3.dualstack.us-east-2.amazonaws.com\n+s3-website-us-east-1.amazonaws.com\n+s3-website-us-west-1.amazonaws.com\n+s3-website-us-west-2.amazonaws.com\n+s3-website-ap-northeast-1.amazonaws.com\n+s3-website-ap-southeast-1.amazonaws.com\n+s3-website-ap-southeast-2.amazonaws.com\n+s3-website-eu-west-1.amazonaws.com\n+s3-website-sa-east-1.amazonaws.com\n+s3-website.ap-northeast-2.amazonaws.com\n+s3-website.ap-south-1.amazonaws.com\n+s3-website.ca-central-1.amazonaws.com\n+s3-website.eu-central-1.amazonaws.com\n+s3-website.eu-west-2.amazonaws.com\n+s3-website.eu-west-3.amazonaws.com\n+s3-website.us-east-2.amazonaws.com\n@@ -10403,8 +10836,0 @@\n-\/\/ Authentick UG (haftungsbeschränkt) : https:\/\/authentick.net\n-\/\/ Submitted by Lukas Reschke <lukas@authentick.net>\n-translated.page\n-\n-\/\/ Autocode : https:\/\/autocode.com\n-\/\/ Submitted by Jacob Lee <jacob@autocode.com>\n-autocode.dev\n-\n@@ -10425,1 +10850,1 @@\n-\/\/ Submitted by Krzysztof Wolski <krzysztof.wolski@home.eu>\n+\/\/ Submited by Krzysztof Wolski <krzysztof.wolski@home.eu>\n@@ -10451,20 +10876,0 @@\n-\/\/ BASE, Inc. : https:\/\/binc.jp\n-\/\/ Submitted by Yuya NAGASAWA <public-suffix-list@binc.jp>\n-base.ec\n-official.ec\n-buyshop.jp\n-fashionstore.jp\n-handcrafted.jp\n-kawaiishop.jp\n-supersale.jp\n-theshop.jp\n-shopselect.net\n-base.shop\n-\n-\/\/ BeagleBoard.org Foundation : https:\/\/beagleboard.org\n-\/\/ Submitted by Jason Kridner <jkridner@beagleboard.org>\n-beagleboard.io\n-\n-\/\/ Beget Ltd\n-\/\/ Submitted by Lev Nekrasov <lnekrasov@beget.com>\n-*.beget.app\n@@ -10539,5 +10944,0 @@\n-\/\/ Canva Pty Ltd : https:\/\/canva.com\/\n-\/\/ Submitted by Joel Aquilina <publicsuffixlist@canva.com>\n-canva-apps.cn\n-canva-apps.com\n-\n@@ -10673,3 +11073,0 @@\n-cf-ipfs.com\n-cloudflare-ipfs.com\n-trycloudflare.com\n@@ -10677,1 +11074,1 @@\n-r2.dev\n+trycloudflare.com\n@@ -10721,4 +11118,0 @@\n-\/\/ Codeberg e. V. : https:\/\/codeberg.org\n-\/\/ Submitted by Moritz Marquardt <git@momar.de>\n-codeberg.page\n-\n@@ -10851,5 +11244,0 @@\n-\/\/ Deta: https:\/\/www.deta.sh\/\n-\/\/ Submitted by Aavash Shrestha <aavash@deta.sh>\n-deta.app\n-deta.dev\n-\n@@ -10861,5 +11249,0 @@\n-\/\/ Discord Inc : https:\/\/discord.com\n-\/\/ Submitted by Sahn Lam <slam@discordapp.com>\n-discordsays.com\n-discordsez.com\n-\n@@ -11254,4 +11637,4 @@\n-\/\/ Easypanel : https:\/\/easypanel.io\n-\/\/ Submitted by Andrei Canta <andrei@easypanel.io>\n-easypanel.app\n-easypanel.host\n+\/\/ eero : https:\/\/eero.com\/\n+\/\/ Submitted by Yue Kang <eero-dynamic-dns@amazon.com>\n+eero.online\n+eero-stage.online\n@@ -11273,5 +11656,0 @@\n-\/\/ Encoretivity AB: https:\/\/encore.dev\n-\/\/ Submitted by André Eriksson <andre@encore.dev>\n-encr.app\n-encoreapi.com\n-\n@@ -11283,4 +11661,0 @@\n-\/\/ encoway GmbH : https:\/\/www.encoway.de\n-\/\/ Submitted by Marcel Daus <cloudops@encoway.de>\n-eu.encoway.cloud\n-\n@@ -11461,1 +11835,0 @@\n-fastly-edge.com\n@@ -11473,4 +11846,0 @@\n-\/\/ Fastmail : https:\/\/www.fastmail.com\/\n-\/\/ Submitted by Marc Bradshaw <marc@fastmailteam.com>\n-*.user.fm\n-\n@@ -11495,0 +11864,2 @@\n+couk.me\n+ukco.me\n@@ -11553,4 +11924,0 @@\n-framer.media\n-framer.photos\n-framer.website\n-framer.wiki\n@@ -11602,10 +11969,2 @@\n-\/\/ GDS : https:\/\/www.gov.uk\/service-manual\/technology\/managing-domain-names\n-\/\/ Submitted by Stephen Ford <hostmaster@digital.cabinet-office.gov.uk>\n-independent-commission.uk\n-independent-inquest.uk\n-independent-inquiry.uk\n-independent-panel.uk\n-independent-review.uk\n-public-inquiry.uk\n-royal-commission.uk\n-campaign.gov.uk\n+\/\/ GDS : https:\/\/www.gov.uk\/service-manual\/operations\/operating-servicegovuk-subdomains\n+\/\/ Submitted by David Illsley <david.illsley@digital.cabinet-office.gov.uk>\n@@ -11614,4 +11973,0 @@\n-\/\/ CDDO : https:\/\/www.gov.uk\/guidance\/get-an-api-domain-on-govuk\n-\/\/ Submitted by Jamie Tanna <jamie.tanna@digital.cabinet-office.gov.uk>\n-api.gov.uk\n-\n@@ -11667,1 +12022,1 @@\n-\/\/ Submitted by Hosting Div <admin@pepabo.com>\n+\/\/ Submitted by dojineko <admin@pepabo.com>\n@@ -11669,106 +12024,0 @@\n-angry.jp\n-babyblue.jp\n-babymilk.jp\n-backdrop.jp\n-bambina.jp\n-bitter.jp\n-blush.jp\n-boo.jp\n-boy.jp\n-boyfriend.jp\n-but.jp\n-candypop.jp\n-capoo.jp\n-catfood.jp\n-cheap.jp\n-chicappa.jp\n-chillout.jp\n-chips.jp\n-chowder.jp\n-chu.jp\n-ciao.jp\n-cocotte.jp\n-coolblog.jp\n-cranky.jp\n-cutegirl.jp\n-daa.jp\n-deca.jp\n-deci.jp\n-digick.jp\n-egoism.jp\n-fakefur.jp\n-fem.jp\n-flier.jp\n-floppy.jp\n-fool.jp\n-frenchkiss.jp\n-girlfriend.jp\n-girly.jp\n-gloomy.jp\n-gonna.jp\n-greater.jp\n-hacca.jp\n-heavy.jp\n-her.jp\n-hiho.jp\n-hippy.jp\n-holy.jp\n-hungry.jp\n-icurus.jp\n-itigo.jp\n-jellybean.jp\n-kikirara.jp\n-kill.jp\n-kilo.jp\n-kuron.jp\n-littlestar.jp\n-lolipopmc.jp\n-lolitapunk.jp\n-lomo.jp\n-lovepop.jp\n-lovesick.jp\n-main.jp\n-mods.jp\n-mond.jp\n-mongolian.jp\n-moo.jp\n-namaste.jp\n-nikita.jp\n-nobushi.jp\n-noor.jp\n-oops.jp\n-parallel.jp\n-parasite.jp\n-pecori.jp\n-peewee.jp\n-penne.jp\n-pepper.jp\n-perma.jp\n-pigboat.jp\n-pinoko.jp\n-punyu.jp\n-pupu.jp\n-pussycat.jp\n-pya.jp\n-raindrop.jp\n-readymade.jp\n-sadist.jp\n-schoolbus.jp\n-secret.jp\n-staba.jp\n-stripper.jp\n-sub.jp\n-sunnyday.jp\n-thick.jp\n-tonkotsu.jp\n-under.jp\n-upper.jp\n-velvet.jp\n-verse.jp\n-versus.jp\n-vivian.jp\n-watson.jp\n-weblike.jp\n-whitesnow.jp\n-zombie.jp\n-heteml.net\n@@ -11896,4 +12145,0 @@\n-\/\/ Government of the Netherlands: https:\/\/www.government.nl\n-\/\/ Submitted by <domeinnaam@minaz.nl>\n-gov.nl\n-\n@@ -11910,1 +12155,1 @@\n-\/\/ Submitted by Arseniy Sokolov <security@hakaran.cz>\n+\/\/ Submited by Arseniy Sokolov <security@hakaran.cz>\n@@ -11945,1 +12190,1 @@\n-ravendb.cloud\n+myravendb.com\n@@ -11952,1 +12197,1 @@\n-\/\/ Submitted by Krzysztof Wolski <krzysztof.wolski@home.eu>\n+\/\/ Submited by Krzysztof Wolski <krzysztof.wolski@home.eu>\n@@ -11959,5 +12204,0 @@\n-\/\/ Hoplix : https:\/\/www.hoplix.com\n-\/\/ Submitted by Danilo De Franco<info@hoplix.shop>\n-hoplix.shop\n-\n-\n@@ -11975,4 +12215,1 @@\n-\n-\/\/ HostFly : https:\/\/www.ie.ua\n-\/\/ Submitted by Bohdan Dub <support@hostfly.com.ua>\n-ie.ua\n+org.yt\n@@ -11996,5 +12233,0 @@\n-\/\/ iliad italia: https:\/\/www.iliad.it\n-\/\/ Submitted by Marios Makassikis <mmakassikis@freebox.fr>\n-ibxos.it\n-iliadboxos.it\n-\n@@ -12070,1 +12302,1 @@\n-\/\/ Submitted by Vasiliy Sheredeko <piphon@gmail.com>\n+\/\/ Submited by Vasiliy Sheredeko <piphon@gmail.com>\n@@ -12081,3 +12313,2 @@\n-\/\/ IServ GmbH : https:\/\/iserv.de\n-\/\/ Submitted by Mario Hoberg <info@iserv.de>\n-iservschule.de\n+\/\/ IServ GmbH : https:\/\/iserv.eu\n+\/\/ Submitted by Kim-Alexander Brodowski <info@iserv.eu>\n@@ -12085,1 +12316,0 @@\n-schulplattform.de\n@@ -12095,1 +12325,1 @@\n-\/\/ Submitted by Ihor Kolodyuk <ik@jelastic.com>\n+\/\/ Submited by Ihor Kolodyuk <ik@jelastic.com>\n@@ -12206,8 +12436,0 @@\n-\/\/ Kakao : https:\/\/www.kakaocorp.com\/\n-\/\/ Submitted by JaeYoong Lee <cec@kakaocorp.com>\n-ktistory.com\n-\n-\/\/ Kapsi : https:\/\/kapsi.fi\n-\/\/ Submitted by Tomi Juntunen <erani@kapsi.fi>\n-kapsi.fi\n-\n@@ -12227,4 +12449,0 @@\n-\/\/ KoobinEvent, SL: https:\/\/www.koobin.com\n-\/\/ Submitted by Iván Oliva <ivan.oliva@koobin.com>\n-koobin.events\n-\n@@ -12295,4 +12513,0 @@\n-\/\/ Localcert : https:\/\/localcert.dev\n-\/\/ Submitted by Lann Martin <security@localcert.dev>\n-*.user.localcert.dev\n-\n@@ -12407,4 +12621,0 @@\n-\/\/ Messerli Informatik AG : https:\/\/www.messerli.ch\/\n-\/\/ Submitted by Ruben Schmidmeister <psl-maintainers@messerli.ch>\n-messerli.app\n-\n@@ -12430,1 +12640,1 @@\n-\/\/ Submitted by Public Suffix List Admin <msftpsladmin@microsoft.com>\n+\/\/ Submitted by Mitch Webster <miwebst@microsoft.com>\n@@ -12436,3 +12646,0 @@\n-1.azurestaticapps.net\n-2.azurestaticapps.net\n-3.azurestaticapps.net\n@@ -12491,3 +12698,18 @@\n-\/\/ Net at Work Gmbh : https:\/\/www.netatwork.de\n-\/\/ Submitted by Jan Jaeschke <jan.jaeschke@netatwork.de>\n-cloud.nospamproxy.com\n+\/\/ Names.of.London : https:\/\/names.of.london\/\n+\/\/ Submitted by James Stevens <registry[at]names.of.london> or <publiclist[at]jrcs.net>\n+pony.club\n+of.fashion\n+in.london\n+of.london\n+from.marketing\n+with.marketing\n+for.men\n+repair.men\n+and.mom\n+for.mom\n+for.one\n+under.one\n+for.sale\n+that.win\n+from.work\n+to.work\n@@ -12505,4 +12727,0 @@\n-ngrok.app\n-ngrok-free.app\n-ngrok.dev\n-ngrok-free.dev\n@@ -12510,8 +12728,0 @@\n-ap.ngrok.io\n-au.ngrok.io\n-eu.ngrok.io\n-in.ngrok.io\n-jp.ngrok.io\n-sa.ngrok.io\n-us.ngrok.io\n-ngrok.pizza\n@@ -12535,1 +12745,0 @@\n-*.build.run\n@@ -12537,2 +12746,0 @@\n-*.database.run\n-*.migration.run\n@@ -12669,0 +12876,5 @@\n+\/\/ Nodum B.V. : https:\/\/nodum.io\/\n+\/\/ Submitted by Wietse Wind <hello+publicsuffixlist@nodum.io>\n+nodum.co\n+nodum.io\n+\n@@ -12699,15 +12911,0 @@\n-123hjemmeside.dk\n-123hjemmeside.no\n-123homepage.it\n-123kotisivu.fi\n-123minsida.se\n-123miweb.es\n-123paginaweb.pt\n-123sait.ru\n-123siteweb.fr\n-123webseite.at\n-123webseite.de\n-123website.be\n-123website.ch\n-123website.lu\n-123website.nl\n@@ -12715,4 +12912,0 @@\n-simplesite.com\n-simplesite.com.br\n-simplesite.gr\n-simplesite.pl\n@@ -12740,4 +12933,0 @@\n-\/\/ Orange : https:\/\/www.orange.com\n-\/\/ Submitted by Alexandre Linte <alexandre.linte@orange.com>\n-tech.orange\n-\n@@ -12745,1 +12934,1 @@\n-\/\/ Submitted by Authgear Team <hello@authgear.com>, Skygear Developer <hello@skygear.io>\n+\/\/ Submited by Authgear Team <hello@authgear.com>, Skygear Developer <hello@skygear.io>\n@@ -12853,4 +13042,0 @@\n-\/\/ Porter : https:\/\/porter.run\/\n-\/\/ Submitted by Rudraksh MK <rudi@porter.run>\n-onporter.run\n-\n@@ -12914,4 +13099,0 @@\n-\/\/ Quality Unit: https:\/\/qualityunit.com\n-\/\/ Submitted by Vasyl Tsalko <vtsalko@qualityunit.com>\n-ladesk.com\n-\n@@ -12991,3 +13172,1 @@\n-\/\/ Submitted by Lincoln Bergeson <lincoln@replit.com>\n-firewalledreplit.co\n-id.firewalledreplit.co\n+\/\/ Submitted by Mason Clayton <mason@repl.it>\n@@ -13024,4 +13203,0 @@\n-\/\/ Rocky Enterprise Software Foundation : https:\/\/resf.org\n-\/\/ Submitted by Neil Hanlon <neil@resf.org>\n-rocky.page\n-\n@@ -13041,56 +13216,0 @@\n-\/\/ SAKURA Internet Inc. : https:\/\/www.sakura.ad.jp\/\n-\/\/ Submitted by Internet Service Department <rs-vendor-ml@sakura.ad.jp>\n-180r.com\n-dojin.com\n-sakuratan.com\n-sakuraweb.com\n-x0.com\n-2-d.jp\n-bona.jp\n-crap.jp\n-daynight.jp\n-eek.jp\n-flop.jp\n-halfmoon.jp\n-jeez.jp\n-matrix.jp\n-mimoza.jp\n-ivory.ne.jp\n-mail-box.ne.jp\n-mints.ne.jp\n-mokuren.ne.jp\n-opal.ne.jp\n-sakura.ne.jp\n-sumomo.ne.jp\n-topaz.ne.jp\n-netgamers.jp\n-nyanta.jp\n-o0o0.jp\n-rdy.jp\n-rgr.jp\n-rulez.jp\n-s3.isk01.sakurastorage.jp\n-s3.isk02.sakurastorage.jp\n-saloon.jp\n-sblo.jp\n-skr.jp\n-tank.jp\n-uh-oh.jp\n-undo.jp\n-rs.webaccel.jp\n-user.webaccel.jp\n-websozai.jp\n-xii.jp\n-squares.net\n-jpn.org\n-kirara.st\n-x0.to\n-from.tv\n-sakura.tv\n-\n-\/\/ Salesforce.com, Inc. https:\/\/salesforce.com\/\n-\/\/ Submitted by Michael Biven <mbiven@salesforce.com>\n-*.builder.code.com\n-*.dev-builder.code.com\n-*.stg-builder.code.com\n-\n@@ -13106,28 +13225,0 @@\n-\/\/ Scaleway : https:\/\/www.scaleway.com\/\n-\/\/ Submitted by Rémy Léone <rleone@scaleway.com>\n-fr-par-1.baremetal.scw.cloud\n-fr-par-2.baremetal.scw.cloud\n-nl-ams-1.baremetal.scw.cloud\n-fnc.fr-par.scw.cloud\n-functions.fnc.fr-par.scw.cloud\n-k8s.fr-par.scw.cloud\n-nodes.k8s.fr-par.scw.cloud\n-s3.fr-par.scw.cloud\n-s3-website.fr-par.scw.cloud\n-whm.fr-par.scw.cloud\n-priv.instances.scw.cloud\n-pub.instances.scw.cloud\n-k8s.scw.cloud\n-k8s.nl-ams.scw.cloud\n-nodes.k8s.nl-ams.scw.cloud\n-s3.nl-ams.scw.cloud\n-s3-website.nl-ams.scw.cloud\n-whm.nl-ams.scw.cloud\n-k8s.pl-waw.scw.cloud\n-nodes.k8s.pl-waw.scw.cloud\n-s3.pl-waw.scw.cloud\n-s3-website.pl-waw.scw.cloud\n-scalebook.scw.cloud\n-smartlabeling.scw.cloud\n-dedibox.fr\n-\n@@ -13241,7 +13332,0 @@\n-\/\/ Snowflake Inc : https:\/\/www.snowflake.com\/\n-\/\/ Submitted by Faith Olapade <faith.olapade@snowflake.com>\n-snowflake.app\n-privatelink.snowflake.app\n-streamlit.app\n-streamlitapp.com\n-\n@@ -13261,2 +13345,0 @@\n-\/\/ Submitted by Q Misell <q@staclar.com>\n-musician.io\n@@ -13361,4 +13443,0 @@\n-dscloud.biz\n-direct.quickconnect.cn\n-dsmynas.com\n-familyds.com\n@@ -13366,0 +13444,1 @@\n+dscloud.biz\n@@ -13367,3 +13446,0 @@\n-i234.me\n-myds.me\n-synology.me\n@@ -13371,0 +13447,1 @@\n+dsmynas.com\n@@ -13372,1 +13449,0 @@\n-familyds.net\n@@ -13374,0 +13450,2 @@\n+familyds.com\n+familyds.net\n@@ -13375,0 +13453,3 @@\n+i234.me\n+myds.me\n+synology.me\n@@ -13381,2 +13462,0 @@\n-mytabit.co.il\n-mytabit.com\n@@ -13400,4 +13479,0 @@\n-\/\/ team.blue https:\/\/team.blue\n-\/\/ Submitted by Cedric Dubois <cedric.dubois@team.blue>\n-site.tb-hosting.com\n-\n@@ -13406,2 +13481,1 @@\n-edugit.io\n-s3.teckids.org\n+edugit.org\n@@ -13415,0 +13489,4 @@\n+\/\/ The Gwiddle Foundation : https:\/\/gwiddlefoundation.org.uk\n+\/\/ Submitted by Joshua Bayfield <joshua.bayfield@gwiddlefoundation.org.uk>\n+gwiddle.co.uk\n+\n@@ -13449,0 +13527,4 @@\n+\/\/ TradableBits: https:\/\/tradablebits.com\n+\/\/ Submitted by Dmitry Khrisanov dmitry@tradablebits.com\n+tbits.me\n+\n@@ -13477,4 +13559,0 @@\n-\/\/ TransIP: https:\/\/www.transip.nl\n-\/\/ Submitted by Cedric Dubois <cedric.dubois@team.blue>\n-site.transip.me\n-\n@@ -13501,8 +13579,0 @@\n-\/\/ Typedream : https:\/\/typedream.com\n-\/\/ Submitted by Putri Karunia <putri@typedream.com>\n-typedream.app\n-\n-\/\/ Typeform : https:\/\/www.typeform.com\n-\/\/ Submitted by Sergi Ferriz <sergi.ferriz@typeform.com>\n-pro.typeform.com\n-\n@@ -13521,13 +13591,0 @@\n-\/\/ UK Intis Telecom LTD : https:\/\/it.com\n-\/\/ Submitted by ITComdomains <to@it.com>\n-it.com\n-\n-\/\/ UNIVERSAL DOMAIN REGISTRY : https:\/\/www.udr.org.yt\/\n-\/\/ see also: whois -h whois.udr.org.yt help\n-\/\/ Submitted by Atanunu Igbunuroghene <publicsuffixlist@udr.org.yt>\n-name.pm\n-sch.tf\n-biz.wf\n-sch.wf\n-org.yt\n-\n@@ -13620,4 +13677,0 @@\n-\/\/ Vultr Objects : https:\/\/www.vultr.com\/products\/object-storage\/\n-\/\/ Submitted by Niels Maumenee <storage@vultr.com>\n-*.vultrobjects.com\n-\n@@ -13628,0 +13681,9 @@\n+\/\/ WapBlog.ID : https:\/\/www.wapblog.id\n+\/\/ Submitted by Fajar Sodik <official@wapblog.id>\n+idnblogger.com\n+indowapblog.com\n+bloger.id\n+wblog.id\n+wbq.me\n+fastblog.net\n+\n@@ -13664,4 +13726,0 @@\n-\/\/ Wizard Zines : https:\/\/wizardzines.com\n-\/\/ Submitted by Julia Evans <julia@wizardzines.com>\n-messwithdns.com\n-\n","filename":"make\/data\/publicsuffixlist\/public_suffix_list.dat","additions":827,"deletions":769,"binary":false,"changes":1596,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-JMH_VERSION=1.36\n+JMH_VERSION=1.35\n@@ -31,1 +31,1 @@\n-JOPT_SIMPLE_VERSION=5.0.4\n+JOPT_SIMPLE_VERSION=4.6\n","filename":"make\/devkit\/createJMHBundle.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2021,2023 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This application is meant to be run to create a classlist file representing\n- * common use.\n- *\n- * The classlist is produced by adding -XX:DumpLoadedClassList=classlist\n- *\/\n-package build.tools.classlist;\n-\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import java.util.Scanner;\n-\n-\/**\n- * The classlist generated by build.tools.classlist.HelloClasslist\n- * may have non-deterministic contents, affected by Java thread execution order.\n- * SortClasslist sorts the file to make the JDK image's contents more deterministic.\n- *\/\n-public class SortClasslist {\n-    public static void main(String args[]) throws FileNotFoundException  {\n-        ArrayList<String> classes = new ArrayList<>();\n-        ArrayList<String> lambdas = new ArrayList<>();\n-\n-        FileInputStream fis = new FileInputStream(args[0]);\n-        Scanner scanner = new Scanner(fis);\n-        while (scanner.hasNextLine()) {\n-            String line = scanner.nextLine();\n-            if (line.startsWith(\"#\")) {\n-                \/\/ Comments -- print them first without sorting. These appear only at the top\n-                \/\/ of the file.\n-                System.out.println(line);\n-            } else if (line.startsWith(\"@\")) {\n-                \/\/ @lambda-form-invoker, @lambda-proxy, etc.\n-                lambdas.add(line);\n-            } else {\n-                \/\/ Class name line\n-                classes.add(line);\n-            }\n-        }\n-\n-        Collections.sort(classes);\n-        Collections.sort(lambdas);\n-\n-        for (String s : classes) {\n-            System.out.println(s);\n-        }\n-        for (String s : lambdas) {\n-            System.out.println(s);\n-        }\n-    }\n-}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/classlist\/SortClasslist.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -419,1 +419,0 @@\n-  # gcc_ftobjs.c := maybe-uninitialized required for GCC 7 builds.\n@@ -428,1 +427,0 @@\n-      DISABLED_WARNINGS_gcc_ftobjs.c := maybe-uninitialized, \\\n@@ -469,1 +467,1 @@\n-        expansion-to-defined dangling-reference\n+        expansion-to-defined\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -360,2 +360,2 @@\n-            elif [ \"$SUFFIX\" = \"jar_contents\" ]; then\n-                # The jar_contents files may have some lines in random order\n+            elif [[ \"$f\" = *\"\/lib\/classlist\" ]] || [ \"$SUFFIX\" = \"jar_contents\" ]; then\n+                # The classlist files may have some lines in random order\n","filename":"make\/scripts\/compare.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,2 +151,4 @@\n-    # If $unixpath does not exist, add .exe (needed on WSL)\n-    if [[ ! -e \"$unixpath\" ]]; then\n+    # Now turn it into a windows path\n+    winpath=\"$($PATHTOOL -w \"$path\" 2>\/dev\/null)\"\n+    # If it fails, try again with an added .exe (needed on WSL)\n+    if [[ $? -ne 0 ]]; then\n@@ -154,0 +156,1 @@\n+      winpath=\"$($PATHTOOL -w \"$unixpath\" 2>\/dev\/null)\"\n@@ -155,3 +158,1 @@\n-    # Now turn it into a windows path\n-    winpath=\"$($PATHTOOL -w \"$unixpath\" 2>\/dev\/null)\"\n-    if [[ $? -eq 0 && -e \"$unixpath\" ]]; then\n+    if [[ $? -eq 0 ]]; then\n","filename":"make\/scripts\/fixpath.sh","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2967,16 +2967,0 @@\n-  \/\/ Big-endian 128-bit + 64-bit -> 128-bit addition.\n-  \/\/ Inputs: 128-bits. in is preserved.\n-  \/\/ The least-significant 64-bit word is in the upper dword of the vector\n-  \/\/ inc (the 64-bit increment) is preserved. Its lower dword must be zero\n-  \/\/ Output: result\n-  void be_add_128_64(FloatRegister result, FloatRegister in,\n-               FloatRegister inc, FloatRegister tmp) {\n-    assert_different_registers(result, tmp, inc);\n-\n-    __ addv(result, __ T2D, in, inc);      \/\/ Add inc to the least-significant dword of input\n-    __ cmhi(tmp, __ T2D, inc, result);     \/\/ Check for result overflowing\n-    __ ins(tmp, __ D, tmp, 0, 1);          \/\/ Move LSD of comparison result to MSD\n-    __ ins(tmp, __ D, inc, 1, 0);          \/\/ Move 0 to LSD of comparison result\n-    __ subv(result, __ T2D, result, tmp);  \/\/ Subtract -1 from MSD if there was an overflow\n-  }\n-\n@@ -3092,1 +3076,1 @@\n-      __ ins(v4, __ S, v5, 2, 2); \/\/ v4 contains { 0, 1 }\n+      __ ins(v4, __ S, v5, 3, 3); \/\/ v4 contains { 0, 0, 0, 1 }\n@@ -3094,8 +3078,5 @@\n-      \/\/ 128-bit big-endian increment\n-      __ ld1(v0, __ T16B, counter);\n-      __ rev64(v16, __ T16B, v0);\n-      be_add_128_64(v16, v16, v4, \/*tmp*\/v5);\n-      __ rev64(v16, __ T16B, v16);\n-      __ st1(v16, __ T16B, counter);\n-      \/\/ Previous counter value is in v0\n-      \/\/ v4 contains { 0, 1 }\n+      __ ld1(v0, __ T16B, counter); \/\/ Load the counter into v0\n+      __ rev32(v16, __ T16B, v0);\n+      __ addv(v16, __ T4S, v16, v4);\n+      __ rev32(v16, __ T16B, v16);\n+      __ st1(v16, __ T16B, counter); \/\/ Save the incremented counter back\n@@ -3133,3 +3114,3 @@\n-        __ rev64(v16, __ T16B, v16);\n-        be_add_128_64(v16, v16, v4, \/*tmp*\/v5);\n-        __ rev64(v16, __ T16B, v16);\n+        __ rev32(v16, __ T16B, v16);\n+        __ addv(v16, __ T4S, v16, v4);\n+        __ rev32(v16, __ T16B, v16);\n@@ -3183,1 +3164,1 @@\n-    __ rev64(v16, __ T16B, v0); \/\/ v16 contains byte-reversed counter\n+    __ rev32(v16, __ T16B, v0); \/\/ v16 contains byte-reversed counter\n@@ -3193,1 +3174,1 @@\n-      __ ins(v8, __ S, v9, 2, 2); \/\/ v8 contains { 0, 1 }\n+      __ ins(v8, __ S, v9, 3, 3); \/\/ v8 contains { 0, 0, 0, 1 }\n@@ -3196,2 +3177,2 @@\n-        __ rev64(f, __ T16B, v16);\n-        be_add_128_64(v16, v16, v8, \/*tmp*\/v9);\n+        __ rev32(f, __ T16B, v16);\n+        __ addv(v16, __ T4S, v16, v8);\n@@ -3225,1 +3206,1 @@\n-    __ rev64(v16, __ T16B, v16);\n+    __ rev32(v16, __ T16B, v16);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2059,1 +2059,1 @@\n-  enc_class riscv_enc_mov_imm(iRegIorL dst, immIorL src) %{\n+  enc_class riscv_enc_li_imm(iRegIorL dst, immIorL src) %{\n@@ -4675,1 +4675,1 @@\n-  format %{ \"mv $dst, $src\\t# int, #@loadConI\" %}\n+  format %{ \"li $dst, $src\\t# int, #@loadConI\" %}\n@@ -4677,1 +4677,1 @@\n-  ins_encode(riscv_enc_mov_imm(dst, src));\n+  ins_encode(riscv_enc_li_imm(dst, src));\n@@ -4688,1 +4688,1 @@\n-  format %{ \"mv $dst, $src\\t# long, #@loadConL\" %}\n+  format %{ \"li $dst, $src\\t# long, #@loadConL\" %}\n@@ -4690,1 +4690,1 @@\n-  ins_encode(riscv_enc_mov_imm(dst, src));\n+  ins_encode(riscv_enc_li_imm(dst, src));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2647,10 +2647,0 @@\n-\n-void Assembler::kshiftlbl(KRegister dst, KRegister src, int imm8) {\n-  assert(VM_Version::supports_avx512dq(), \"\");\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0 , src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n-  emit_int16(0x32, (0xC0 | encode));\n-  emit_int8(imm8);\n-}\n-\n-\n@@ -3972,8 +3962,0 @@\n-void Assembler::evpcmpuq(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n-  emit_int24(0x1E, (0xC0 | encode), vcc);\n-}\n-\n@@ -6606,13 +6588,0 @@\n-void Assembler::evpaddq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n-  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  attributes.set_embedded_opmask_register_specifier(mask);\n-  if (merge) {\n-    attributes.reset_is_clear_context();\n-  }\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xD4, (0xC0 | encode));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1494,2 +1494,0 @@\n-  void kshiftlbl(KRegister dst, KRegister src, int imm8);\n-\n@@ -1731,2 +1729,0 @@\n-  void evpcmpuq(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);\n-\n@@ -2255,4 +2251,0 @@\n-  \/\/ Leaf level assembler routines for masked operations.\n-  void evpaddq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n-\/\/ void evpaddq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -967,2 +967,0 @@\n-  void ev_add128(XMMRegister xmmdst, XMMRegister xmmsrc1, XMMRegister xmmsrc2,\n-                 int vector_len, KRegister ktmp, Register rscratch = noreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -782,13 +782,0 @@\n-\/\/ Add 128-bit integers in xmmsrc1 to xmmsrc2, then place the result in xmmdst.\n-\/\/ Clobber ktmp and rscratch.\n-\/\/ Used by aesctr_encrypt.\n-void MacroAssembler::ev_add128(XMMRegister xmmdst, XMMRegister xmmsrc1, XMMRegister xmmsrc2,\n-                            int vector_len, KRegister ktmp, Register rscratch) {\n-  vpaddq(xmmdst, xmmsrc1, xmmsrc2, vector_len);\n-  evpcmpuq(ktmp, xmmdst, xmmsrc2, lt, vector_len); \/\/ set mask[0\/1] bit if addq to dst[0\/1] wraps\n-  kshiftlbl(ktmp, ktmp, 1);                        \/\/ mask[1] <- mask[0], mask[0] <- 0, etc\n-\n-  evpaddq(xmmdst, ktmp, xmmdst, xmm17, \/*merge*\/true,\n-          vector_len);                             \/\/ dst[1]++ if mask[1] set\n-}\n-\n@@ -847,2 +834,0 @@\n-    \/\/ Vector value to propagate carries\n-    evmovdquq(xmm17, ExternalAddress(StubRoutines::x86::counter_mask_ones_addr()), Assembler::AVX_512bit, r15);\n@@ -854,10 +839,8 @@\n-    evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 64), Assembler::AVX_512bit, r15 \/*rscratch*\/);\/\/linc0\n-    ev_add128(xmm8, xmm8,   xmm19, Assembler::AVX_512bit,  \/*ktmp*\/k1, r15);\n-    evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15 \/*rscratch*\/);\/\/linc4\n-    ev_add128(xmm9,   xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15);\n-    ev_add128(xmm10,  xmm9, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15);\n-    ev_add128(xmm11, xmm10, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15);\n-    ev_add128(xmm12, xmm11, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15);\n-    ev_add128(xmm13, xmm12, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15);\n-    ev_add128(xmm14, xmm13, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15);\n-    ev_add128(xmm15, xmm14, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15);\n+    vpaddd(xmm8, xmm8, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 64), Assembler::AVX_512bit, r15);\/\/linc0\n+    vpaddd(xmm9, xmm8, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/linc4(rip)\n+    vpaddd(xmm10, xmm9, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n+    vpaddd(xmm11, xmm10, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n+    vpaddd(xmm12, xmm11, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n+    vpaddd(xmm13, xmm12, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n+    vpaddd(xmm14, xmm13, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n+    vpaddd(xmm15, xmm14, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n@@ -911,1 +894,1 @@\n-    ev_add128\/*!!!*\/(xmm8, xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);\n@@ -913,1 +896,1 @@\n-    ev_add128\/*!!!*\/(xmm9, xmm9, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm9, xmm9, xmm19, Assembler::AVX_512bit);\n@@ -915,1 +898,1 @@\n-    ev_add128\/*!!!*\/(xmm10, xmm10, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm10, xmm10, xmm19, Assembler::AVX_512bit);\n@@ -917,1 +900,1 @@\n-    ev_add128\/*!!!*\/(xmm11, xmm11, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm11, xmm11, xmm19, Assembler::AVX_512bit);\n@@ -919,1 +902,1 @@\n-    ev_add128\/*!!!*\/(xmm12, xmm12, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm12, xmm12, xmm19, Assembler::AVX_512bit);\n@@ -921,1 +904,1 @@\n-    ev_add128\/*!!!*\/(xmm13, xmm13, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm13, xmm13, xmm19, Assembler::AVX_512bit);\n@@ -923,1 +906,1 @@\n-    ev_add128\/*!!!*\/(xmm14, xmm14, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm14, xmm14, xmm19, Assembler::AVX_512bit);\n@@ -925,1 +908,1 @@\n-    ev_add128\/*!!!*\/(xmm15, xmm15, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm15, xmm15, xmm19, Assembler::AVX_512bit);\n@@ -1003,2 +986,2 @@\n-    ev_add128\/*!!!*\/(xmm8, xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n-    ev_add128\/*!!!*\/(xmm9, xmm9, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);\n+    vpaddq(xmm9, xmm9, xmm19, Assembler::AVX_512bit);\n@@ -1071,1 +1054,1 @@\n-    ev_add128\/*!!!*\/(xmm8, xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);\n@@ -1129,1 +1112,1 @@\n-    ev_add128\/*!!!*\/(xmm8, xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);\n@@ -1179,1 +1162,1 @@\n-    ev_add128\/*!!!*\/(xmm8, xmm8, xmm19, Assembler::AVX_128bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+    vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_128bit);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_aes.cpp","additions":21,"deletions":38,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -4387,13 +4387,1 @@\n-  \/\/ Vector AES Counter implementation\n-\n-  address counter_mask_ones_addr() {\n-    __ align64();\n-    StubCodeMark mark(this, \"StubRoutines\", \"counter_mask_addr\");\n-    address start = __ pc();\n-    for (int i = 0; i < 4; i ++) {\n-      __ emit_data64(0x0000000000000000, relocInfo::none);\n-      __ emit_data64(0x0000000000000001, relocInfo::none);\n-    }\n-    return start;\n-  }\n-\n+ \/\/ Vector AES Counter implementation\n@@ -7620,1 +7608,0 @@\n-        StubRoutines::x86::_counter_mask_ones_addr = counter_mask_ones_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-address StubRoutines::x86::_counter_mask_ones_addr = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -187,1 +187,0 @@\n-  static address _counter_mask_ones_addr;\n@@ -347,1 +346,0 @@\n-  static address counter_mask_ones_addr() { return _counter_mask_ones_addr; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,4 +50,0 @@\n-\/\/ stubbed-out trim-native support\n-inline bool os::can_trim_native_heap() { return false; }\n-inline bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,4 +54,0 @@\n-\/\/ stubbed-out trim-native support\n-inline bool os::can_trim_native_heap() { return false; }\n-inline bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,13 +89,1 @@\n-          \"Write map file for Linux perf tool at exit\")                 \\\n-                                                                        \\\n-  product(intx, TimerSlack, -1, EXPERIMENTAL,                           \\\n-          \"Overrides the timer slack value to the given number of \"     \\\n-          \"nanoseconds. Lower value provides more accurate \"            \\\n-          \"high-precision timers, at the expense of (possibly) worse \"  \\\n-          \"power efficiency. In current Linux, 0 means using the \"      \\\n-          \"system-wide default, which would disable the override, but \" \\\n-          \"VM would still print the current timer slack values. Use -1 \"\\\n-          \"to disable both the override and the printouts.\"             \\\n-          \"See prctl(PR_SET_TIMERSLACK) for more info.\")                \\\n-                                                                        \\\n-\n+          \"Write map file for Linux perf tool at exit\")\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-# include <sys\/prctl.h>\n@@ -917,10 +916,0 @@\n-\n-      \/\/ Print current timer slack if override is enabled and timer slack value is available.\n-      \/\/ Avoid calling prctl otherwise for extra safety.\n-      if (TimerSlack >= 0) {\n-        int slack = prctl(PR_GET_TIMERSLACK);\n-        if (slack >= 0) {\n-          log_info(os, thread)(\"Thread \\\"%s\\\" (pthread id: \" UINTX_FORMAT \") timer slack: %dns\",\n-                               thread->name(), (uintx) tid, slack);\n-        }\n-      }\n@@ -4698,9 +4687,0 @@\n-  \/\/ Override the timer slack value if needed. The adjustment for the main\n-  \/\/ thread will establish the setting for child threads, which would be\n-  \/\/ most threads in JDK\/JVM.\n-  if (TimerSlack >= 0) {\n-    if (prctl(PR_SET_TIMERSLACK, TimerSlack) < 0) {\n-      vm_exit_during_initialization(\"Setting timer slack failed: %s\", os::strerror(errno));\n-    }\n-  }\n-\n@@ -5532,29 +5512,0 @@\n-\n-bool os::trim_native_heap(os::size_change_t* rss_change) {\n-#ifdef __GLIBC__\n-  os::Linux::meminfo_t info1;\n-  os::Linux::meminfo_t info2;\n-\n-  bool have_info1 = rss_change != nullptr &&\n-                    os::Linux::query_process_memory_info(&info1);\n-  ::malloc_trim(0);\n-  bool have_info2 = rss_change != nullptr && have_info1 &&\n-                    os::Linux::query_process_memory_info(&info2);\n-  ssize_t delta = (ssize_t) -1;\n-  if (rss_change != nullptr) {\n-    if (have_info1 && have_info2 &&\n-        info1.vmrss != -1 && info2.vmrss != -1 &&\n-        info1.vmswap != -1 && info2.vmswap != -1) {\n-      \/\/ Note: query_process_memory_info returns values in K\n-      rss_change->before = (info1.vmrss + info1.vmswap) * K;\n-      rss_change->after = (info2.vmrss + info2.vmswap) * K;\n-    } else {\n-      rss_change->after = rss_change->before = SIZE_MAX;\n-    }\n-  }\n-\n-  return true;\n-#else\n-  return false; \/\/ musl\n-#endif\n-}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -46,9 +46,0 @@\n-\/\/ Trim-native support\n-inline bool os::can_trim_native_heap() {\n-#ifdef __GLIBC__\n-  return true;\n-#else\n-  return false; \/\/ musl\n-#endif\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2022 SAP SE. All rights reserved.\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n-#include \"runtime\/os.inline.hpp\"\n-#include \"trimCHeapDCmd.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"trimCHeapDCmd.hpp\"\n@@ -36,12 +36,32 @@\n-  if (os::can_trim_native_heap()) {\n-    os::size_change_t sc;\n-    if (os::trim_native_heap(&sc)) {\n-      _output->print(\"Trim native heap: \");\n-      if (sc.after != SIZE_MAX) {\n-        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n-        const char sign = sc.after < sc.before ? '-' : '+';\n-        _output->print_cr(\"RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \")\",\n-                          PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta));\n-      } else {\n-        _output->print_cr(\"(no details available).\");\n-      }\n+#ifdef __GLIBC__\n+  stringStream ss_report(1024); \/\/ Note: before calling trim\n+\n+  os::Linux::meminfo_t info1;\n+  os::Linux::meminfo_t info2;\n+  \/\/ Query memory before...\n+  bool have_info1 = os::Linux::query_process_memory_info(&info1);\n+\n+  _output->print_cr(\"Attempting trim...\");\n+  ::malloc_trim(0);\n+  _output->print_cr(\"Done.\");\n+\n+  \/\/ ...and after trim.\n+  bool have_info2 = os::Linux::query_process_memory_info(&info2);\n+\n+  \/\/ Print report both to output stream as well to UL\n+  bool wrote_something = false;\n+  if (have_info1 && have_info2) {\n+    if (info1.vmsize != -1 && info2.vmsize != -1) {\n+      ss_report.print_cr(\"Virtual size before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmsize, info2.vmsize, (info2.vmsize - info1.vmsize));\n+      wrote_something = true;\n+    }\n+    if (info1.vmrss != -1 && info2.vmrss != -1) {\n+      ss_report.print_cr(\"RSS before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmrss, info2.vmrss, (info2.vmrss - info1.vmrss));\n+      wrote_something = true;\n+    }\n+    if (info1.vmswap != -1 && info2.vmswap != -1) {\n+      ss_report.print_cr(\"Swap before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmswap, info2.vmswap, (info2.vmswap - info1.vmswap));\n+      wrote_something = true;\n@@ -49,2 +69,0 @@\n-  } else {\n-    _output->print_cr(\"Not available.\");\n@@ -52,0 +70,9 @@\n+  if (!wrote_something) {\n+    ss_report.print_raw(\"No details available.\");\n+  }\n+\n+  _output->print_raw(ss_report.base());\n+  log_info(os)(\"malloc_trim:\\n%s\", ss_report.base());\n+#else\n+  _output->print_cr(\"Not available.\");\n+#endif\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -96,4 +96,0 @@\n-\/\/ stubbed-out trim-native support\n-inline bool os::can_trim_native_heap() { return false; }\n-inline bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -963,1 +963,1 @@\n-  HASHING3(LoadIndexed, true, elt_type(), array()->subst(), index()->subst())\n+  HASHING3(LoadIndexed, true, type()->tag(), array()->subst(), index()->subst())\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,2 +231,1 @@\n-    } else if (x_bound->has_lower() && x_bound->lower() >= 0 && y->type()->as_IntConstant() &&\n-               y->type()->as_IntConstant()->value() != 0 && y->type()->as_IntConstant()->value() != min_jint) {\n+    } else if (y->type()->as_IntConstant() && y->type()->as_IntConstant()->value() != 0) {\n@@ -236,1 +235,1 @@\n-      \/\/ It follows from this rule that the result of the remainder operation can be negative only\n+      \/\/ % operator follows from this rule that the result of the remainder operation can be negative only\n@@ -238,1 +237,1 @@\n-      \/\/ magnitude of the result is always less than the magnitude of the divisor (see JLS 15.17.3).\n+      \/\/ magnitude of the result is always less than the magnitude of the divisor(See JLS 15.17.3).\n@@ -245,3 +244,5 @@\n-      \/\/\n-      \/\/ Use the absolute value of y as an upper bound. Skip min_jint because abs(min_jint) is undefined.\n-      _bound = new Bound(0, NULL, abs(y->type()->as_IntConstant()->value()) - 1, NULL);\n+      if (x_bound->has_lower() && x_bound->lower() >= 0) {\n+        _bound = new Bound(0, NULL, y->type()->as_IntConstant()->value() - 1, NULL);\n+      } else {\n+        _bound = new Bound();\n+      }\n@@ -272,8 +273,8 @@\n-          jint t_lo = bound->lower();\n-          jint t_hi = bound->upper();\n-          jint new_lower = java_add(t_lo, const_value);\n-          jint new_upper = java_add(t_hi, const_value);\n-          bool overflow = ((const_value < 0 && (new_lower > t_lo)) ||\n-                           (const_value > 0 && (new_upper < t_hi)));\n-          if (overflow) {\n-            _bound = new Bound();\n+          int new_lower = bound->lower() + const_value;\n+          jlong new_lowerl = ((jlong)bound->lower()) + const_value;\n+          int new_upper = bound->upper() + const_value;\n+          jlong new_upperl = ((jlong)bound->upper()) + const_value;\n+\n+          if (((jlong)new_lower) == new_lowerl && ((jlong)new_upper == new_upperl)) {\n+            Bound *newBound = new Bound(new_lower, bound->lower_instr(), new_upper, bound->upper_instr());\n+            _bound = newBound;\n@@ -281,1 +282,2 @@\n-            _bound = new Bound(new_lower, bound->lower_instr(), new_upper, bound->upper_instr());\n+            \/\/ overflow\n+            _bound = new Bound();\n@@ -1559,0 +1561,1 @@\n+      \/\/ TODO: Check that add operation does not overflow!\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1796,3 +1796,0 @@\n-JavaThread* java_lang_Thread::thread_acquire(oop java_thread) {\n-  return reinterpret_cast<JavaThread*>(java_thread->address_field_acquire(_eetop_offset));\n-}\n@@ -1804,4 +1801,0 @@\n-void java_lang_Thread::release_set_thread(oop java_thread, JavaThread* thread) {\n-  java_thread->release_address_field_put(_eetop_offset, (address)thread);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -423,1 +423,0 @@\n-  static JavaThread* thread_acquire(oop java_thread);\n@@ -426,1 +425,0 @@\n-  static void release_set_thread(oop java_thread, JavaThread* thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,4 +365,0 @@\n-\n-JVM_ENTRY_NO_ENV(void, jfr_emit_data_loss(JNIEnv* env, jclass jvm, jlong bytes))\n-  EventDataLoss::commit(bytes, min_jlong);\n-JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,2 +155,0 @@\n-void JNICALL jfr_emit_data_loss(JNIEnv* env, jclass jvm, jlong bytes);\n-\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,2 +93,1 @@\n-      (char*)\"getTypeId\", (char*)\"(Ljava\/lang\/String;)J\", (void*)jfr_get_type_id_from_string,\n-      (char*)\"emitDataLoss\", (char*)\"(J)V\", (void*)jfr_emit_data_loss\n+      (char*)\"getTypeId\", (char*)\"(Ljava\/lang\/String;)J\", (void*)jfr_get_type_id_from_string\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-\n@@ -88,2 +87,1 @@\n-    _reference_stack[_depth] = reference;\n-  } else {\n+  }  else {\n@@ -93,6 +91,0 @@\n-    _mark_bits->mark_obj(pointee);\n-    _reference_stack[_depth] = reference;\n-    \/\/ is the pointee a sample object?\n-    if (pointee->mark().is_marked()) {\n-      add_chain();\n-    }\n@@ -100,0 +92,9 @@\n+  _reference_stack[_depth] = reference;\n+  _mark_bits->mark_obj(pointee);\n+  assert(_mark_bits->is_marked(pointee), \"invariant\");\n+\n+  \/\/ is the pointee a sample object?\n+  if (pointee->mark().is_marked()) {\n+    add_chain();\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"jfr\/leakprofiler\/sampling\/objectSample.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"runtime\/safepoint.hpp\"\n@@ -41,0 +39,9 @@\n+EdgeStore::EdgeStore() : _edges(NULL) {\n+  _edges = new EdgeHashTable(this);\n+}\n+\n+EdgeStore::~EdgeStore() {\n+  assert(_edges != NULL, \"invariant\");\n+  delete _edges;\n+}\n+\n@@ -220,80 +227,1 @@\n-static GrowableArray<const StoredEdge*>* _leak_context_edges = nullptr;\n-\n-EdgeStore::EdgeStore() : _edges(new EdgeHashTable(this)) {}\n-\n-EdgeStore::~EdgeStore() {\n-  assert(_edges != NULL, \"invariant\");\n-  delete _edges;\n-  delete _leak_context_edges;\n-  _leak_context_edges = nullptr;\n-}\n-\n-static int leak_context_edge_idx(const ObjectSample* sample) {\n-  assert(sample != nullptr, \"invariant\");\n-  return static_cast<int>(sample->object()->mark().value()) >> markWord::lock_bits;\n-}\n-\n-bool EdgeStore::has_leak_context(const ObjectSample* sample) const {\n-  const int idx = leak_context_edge_idx(sample);\n-  if (idx == 0) {\n-    return false;\n-  }\n-  assert(idx > 0, \"invariant\");\n-  assert(_leak_context_edges != nullptr, \"invariant\");\n-  assert(idx < _leak_context_edges->length(), \"invariant\");\n-  assert(_leak_context_edges->at(idx) != nullptr, \"invariant\");\n-  return true;\n-}\n-\n-const StoredEdge* EdgeStore::get(const ObjectSample* sample) const {\n-  assert(sample != nullptr, \"invariant\");\n-  if (_leak_context_edges != nullptr) {\n-    assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-    const int idx = leak_context_edge_idx(sample);\n-    if (idx > 0) {\n-      assert(idx < _leak_context_edges->length(), \"invariant\");\n-      const StoredEdge* const edge =_leak_context_edges->at(idx);\n-      assert(edge != nullptr, \"invariant\");\n-      return edge;\n-    }\n-  }\n-  return get(UnifiedOopRef::encode_in_native(sample->object_addr()));\n-}\n-\n-#ifdef ASSERT\n-\/\/ max_idx to ensure idx fit in lower 32-bits of markword together with lock bits.\n-static constexpr const int max_idx =  right_n_bits(32 - markWord::lock_bits);\n-\n-static void store_idx_precondition(oop sample_object, int idx) {\n-  assert(sample_object != NULL, \"invariant\");\n-  assert(sample_object->mark().is_marked(), \"invariant\");\n-  assert(idx > 0, \"invariant\");\n-  assert(idx <= max_idx, \"invariant\");\n-}\n-#endif\n-\n-static void store_idx_in_markword(oop sample_object, int idx) {\n-  DEBUG_ONLY(store_idx_precondition(sample_object, idx);)\n-  const markWord idx_mark_word(sample_object->mark().value() | idx << markWord::lock_bits);\n-  sample_object->set_mark(idx_mark_word);\n-  assert(sample_object->mark().is_marked(), \"must still be marked\");\n-}\n-\n-static const int initial_size = 64;\n-\n-static int save(const StoredEdge* edge) {\n-  assert(edge != nullptr, \"invariant\");\n-  if (_leak_context_edges == nullptr) {\n-    _leak_context_edges = new (ResourceObj::C_HEAP, mtTracing)GrowableArray<const StoredEdge*>(initial_size, mtTracing);\n-    _leak_context_edges->append(nullptr); \/\/ next idx now at 1, for disambiguation in markword.\n-  }\n-  return _leak_context_edges->append(edge);\n-}\n-\n-\/\/ We associate the leak context edge with the leak candidate object by saving the\n-\/\/ edge in an array and storing the array idx (shifted) into the markword of the candidate object.\n-static void associate_with_candidate(const StoredEdge* leak_context_edge) {\n-  assert(leak_context_edge != nullptr, \"invariant\");\n-  store_idx_in_markword(leak_context_edge->pointee(), save(leak_context_edge));\n-}\n-\n+\/\/ Install the immediate edge into the mark word of the leak candidate object\n@@ -304,1 +232,4 @@\n-  associate_with_candidate(leak_context_edge);\n+  oop sample_object = edge->pointee();\n+  assert(sample_object != NULL, \"invariant\");\n+  assert(sample_object->mark().is_marked(), \"invariant\");\n+  sample_object->set_mark(markWord::from_pointer(leak_context_edge));\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":15,"deletions":84,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-class ObjectSample;\n@@ -83,1 +82,0 @@\n-  const StoredEdge* get(const ObjectSample* sample) const;\n@@ -95,1 +93,0 @@\n-  bool has_leak_context(const ObjectSample* sample) const;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-    if (edge_store->has_leak_context(sample)) {\n+    if (!sample->object()->mark().is_marked()) {\n@@ -140,1 +140,12 @@\n-  const StoredEdge* const edge = edge_store->get(sample);\n+  traceid gc_root_id = 0;\n+  const Edge* edge = NULL;\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    if (!sample->object()->mark().is_marked()) {\n+      edge = (const Edge*)(sample->object())->mark().to_pointer();\n+    }\n+  }\n+  if (edge == NULL) {\n+    edge = edge_store->get(UnifiedOopRef::encode_in_native(sample->object_addr()));\n+  } else {\n+    gc_root_id = edge_store->gc_root_id(edge);\n+  }\n@@ -142,1 +153,0 @@\n-  assert(edge->pointee() == sample->object(), \"invariant\");\n@@ -145,1 +155,0 @@\n-  const traceid gc_root_id = edge->gc_root_id();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-    <Field type=\"uint\" name=\"regionsRefilled\" label=\"Region Refills\" description=\"Number of regions refilled\" \/>\n+    <Field type=\"uint\" contentType=\"bytes\" name=\"regionsRefilled\" label=\"Region Refills\" description=\"Total memory wasted at the end of regions due to refill\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -593,2 +593,2 @@\n-  \/\/ AArch64: Try to align metaspace class space so that we can decode a\n-  \/\/ compressed klass with a single MOVK instruction. We can do this iff the\n+  \/\/ AArch64: Try to align metaspace so that we can decode a compressed\n+  \/\/ klass with a single MOVK instruction. We can do this iff the\n@@ -617,4 +617,0 @@\n-  \/\/ Calculate a list of all possible values for the starting address for the\n-  \/\/ compressed class space.\n-  ResourceMark rm;\n-  GrowableArray<address> list(36);\n@@ -625,1 +621,6 @@\n-      list.append(a);\n+      ReservedSpace rs(size, Metaspace::reserve_alignment(),\n+                       os::vm_page_size(), (char*)a);\n+      if (rs.is_reserved()) {\n+        assert(a == (address)rs.base(), \"Sanity\");\n+        return rs;\n+      }\n@@ -629,21 +630,0 @@\n-\n-  int len = list.length();\n-  int r = 0;\n-  if (!DumpSharedSpaces) {\n-    \/\/ Starting from a random position in the list. If the address cannot be reserved\n-    \/\/ (the OS already assigned it for something else), go to the next position, wrapping\n-    \/\/ around if necessary, until we exhaust all the items.\n-    os::init_random((int)os::javaTimeNanos());\n-    r = os::random();\n-    log_info(metaspace)(\"Randomizing compressed class space: start from %d out of %d locations\",\n-                        r % len, len);\n-  }\n-  for (int i = 0; i < len; i++) {\n-    address a = list.at((i + r) % len);\n-    ReservedSpace rs(size, Metaspace::reserve_alignment(),\n-                     os::vm_page_size(), (char*)a);\n-    if (rs.is_reserved()) {\n-      assert(a == (address)rs.base(), \"Sanity\");\n-      return rs;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -778,4 +778,0 @@\n-    if (call->is_CallStaticJava() && call->as_CallStaticJava()->is_boxing_method()) {\n-      result = kit.must_be_not_null(result, false);\n-    }\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -822,3 +822,1 @@\n-    const Type* extype = TypeOopPtr::make_from_klass(env()->Throwable_klass())->is_instptr();\n-    extype = extype->join(TypeInstPtr::NOTNULL);\n-    extypes->append(extype);\n+    extypes->append(TypeOopPtr::make_from_klass(env()->Throwable_klass())->is_instptr());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,2 +94,1 @@\n-  RegionNode* phi_region = phi->region();\n-  for (i4 = 1; i4 < phi->req(); i4++ ) {\n+  for( i4 = 1; i4 < phi->req(); i4++ ) {\n@@ -97,5 +96,1 @@\n-    \/\/ Do not optimize partially collapsed merges\n-    if (con1 == nullptr || phi_region->in(i4) == nullptr || igvn->type(phi_region->in(i4)) == Type::TOP) {\n-      igvn->_worklist.push(iff);\n-      return nullptr;\n-    }\n+    if( !con1 ) return nullptr;    \/\/ Do not optimize partially collapsed merges\n@@ -123,1 +118,1 @@\n-  if (!r->is_Region() || r->is_Loop() || phi_region != r || r->as_Region()->is_copy()) {\n+  if (!r->is_Region() || r->is_Loop() || phi->region() != r || r->as_Region()->is_copy()) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3478,1 +3478,1 @@\n-      slow_call = generate_method_call(vmIntrinsics::_allocateUninitializedArray, false, false, true);\n+      slow_call = generate_method_call(vmIntrinsics::_allocateUninitializedArray, false, false);\n@@ -3480,1 +3480,1 @@\n-      slow_call = generate_method_call_static(vmIntrinsics::_newArray, true);\n+      slow_call = generate_method_call_static(vmIntrinsics::_newArray);\n@@ -3725,1 +3725,1 @@\n-LibraryCallKit::generate_method_call(vmIntrinsicID method_id, bool is_virtual, bool is_static, bool res_not_null) {\n+LibraryCallKit::generate_method_call(vmIntrinsics::ID method_id, bool is_virtual, bool is_static) {\n@@ -3734,8 +3734,0 @@\n-  if (res_not_null) {\n-    assert(tf->return_type() == T_OBJECT, \"\");\n-    const TypeTuple* range = tf->range();\n-    const Type** fields = TypeTuple::fields(range->cnt());\n-    fields[TypeFunc::Parms] = range->field_at(TypeFunc::Parms)->filter_speculative(TypePtr::NOTNULL);\n-    const TypeTuple* new_range = TypeTuple::make(range->cnt(), fields);\n-    tf = TypeFunc::make(tf->domain(), new_range);\n-  }\n@@ -3891,1 +3883,1 @@\n-    CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static, false);\n+    CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static);\n@@ -4361,1 +4353,1 @@\n-      CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual, false, true);\n+      CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -176,3 +176,7 @@\n-  CallJavaNode* generate_method_call(vmIntrinsicID method_id, bool is_virtual, bool is_static, bool res_not_null);\n-  CallJavaNode* generate_method_call_static(vmIntrinsicID method_id, bool res_not_null) {\n-    return generate_method_call(method_id, false, true, res_not_null);\n+  CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,\n+                                     bool is_virtual = false, bool is_static = false);\n+  CallJavaNode* generate_method_call_static(vmIntrinsics::ID method_id) {\n+    return generate_method_call(method_id, false, true);\n+  }\n+  CallJavaNode* generate_method_call_virtual(vmIntrinsics::ID method_id) {\n+    return generate_method_call(method_id, true, false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1434,0 +1434,4 @@\n+\n+  \/\/ Enable WXWrite: the function called directly by compiled code.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-  assert(sub_t != Type::TOP && !TypePtr::NULL_PTR->higher_equal(sub_t), \"should be not null\");\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -811,0 +811,2 @@\n+  \/\/ We do not check the EnableThreadSMRExtraValidityChecks option\n+  \/\/ for this includes() call because JVM\/TI's spec is tighter.\n@@ -852,0 +854,2 @@\n+  \/\/ We do not check the EnableThreadSMRExtraValidityChecks option\n+  \/\/ for this includes() call because JVM\/TI's spec is tighter.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -832,14 +832,12 @@\n-    oop thread_oop = JNIHandles::resolve_non_null(jthread);\n-    \/\/ Get the JavaThread* stored in the java.lang.Thread object _before_\n-    \/\/ the embedded ThreadsListHandle is constructed so we know if the\n-    \/\/ early life stage of the JavaThread* is protected. We use acquire\n-    \/\/ here to ensure that if we see a non-nullptr value, then we also\n-    \/\/ see the main ThreadsList updates from the JavaThread* being added.\n-    FastThreadsListHandle ftlh(thread_oop, java_lang_Thread::thread_acquire(thread_oop));\n-    JavaThread* thr = ftlh.protected_java_thread();\n-    if (thr != nullptr) {\n-      \/\/ The still live JavaThread* is protected by the FastThreadsListHandle\n-      \/\/ so it is safe to access.\n-      Parker* p = thr->parker();\n-      HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-      p->unpark();\n+    ThreadsListHandle tlh;\n+    JavaThread* thr = NULL;\n+    oop java_thread = NULL;\n+    (void) tlh.cv_internal_thread_to_JavaThread(jthread, &thr, &java_thread);\n+    if (java_thread != NULL) {\n+      \/\/ This is a valid oop.\n+      if (thr != NULL) {\n+        \/\/ The JavaThread is alive.\n+        Parker* p = thr->parker();\n+        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+        p->unpark();\n+      }\n@@ -847,1 +845,2 @@\n-  } \/\/ FastThreadsListHandle is destroyed here.\n+  } \/\/ ThreadsListHandle is destroyed here.\n+\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"runtime\/safefetch.hpp\"\n@@ -247,8 +246,0 @@\n-Method* frame::safe_interpreter_frame_method() const {\n-  Method** m_addr = interpreter_frame_method_addr();\n-  if (m_addr == nullptr) {\n-    return nullptr;\n-  }\n-  return (Method*) SafeFetchN((intptr_t*) m_addr, 0);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -180,2 +180,0 @@\n-  Method* safe_interpreter_frame_method() const;\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -985,0 +985,3 @@\n+  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n+             \"Enable Thread SMR extra validity checks\")                     \\\n+                                                                            \\\n@@ -2007,1 +2010,1 @@\n-  product(intx, ArchiveRelocationMode, 1, DIAGNOSTIC,                       \\\n+  product(intx, ArchiveRelocationMode, 0, DIAGNOSTIC,                       \\\n@@ -2009,2 +2012,2 @@\n-           \"unsuccessful, map at alternative address; \"                     \\\n-           \"(1) always map at alternative address (default); \"              \\\n+           \"unsuccessful, map at alternative address (default); \"           \\\n+           \"(1) always map at alternative address; \"                        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -328,0 +328,2 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite,                    \\\n+                                         JavaThread::current()));    \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -369,9 +369,0 @@\n-  \/\/ Does the platform support trimming the native heap?\n-  static bool can_trim_native_heap();\n-\n-  \/\/ Trim the C-heap. Optionally returns working set size change (RSS+Swap) in *rss_change.\n-  \/\/ Note: If trimming succeeded but no size change information could be obtained,\n-  \/\/ rss_change.after will contain SIZE_MAX upon return.\n-  struct size_change_t { size_t before; size_t after; };\n-  static bool trim_native_heap(size_change_t* rss_change = nullptr);\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -478,3 +478,0 @@\n-  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n-\n@@ -1970,3 +1967,0 @@\n-  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, JavaThread::current()));\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1344,1 +1344,2 @@\n-  java_lang_Thread::release_set_thread(threadObj(), NULL);\n+  OrderAccess::release();\n+  java_lang_Thread::set_thread(threadObj(), NULL);\n@@ -2263,0 +2264,1 @@\n+  java_lang_Thread::set_thread(thread_oop(), this);\n@@ -2278,5 +2280,0 @@\n-  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n-  \/\/ on a ThreadsList. We don't want to wait for the release when the\n-  \/\/ Theads_lock is dropped somewhere in the caller since the JavaThread*\n-  \/\/ is already visible to JVM\/TI via the ThreadsList.\n-  java_lang_Thread::release_set_thread(thread_oop(), this);\n@@ -4013,0 +4010,3 @@\n+\n+  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n+\n@@ -4025,5 +4025,0 @@\n-  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n-  \/\/ on a ThreadsList. We don't want to wait for the release when the\n-  \/\/ Theads_lock is dropped when the 'mu' destructor is run since the\n-  \/\/ JavaThread* is already visible to JVM\/TI via the ThreadsList.\n-  java_lang_Thread::release_set_thread(thread_oop(), target); \/\/ isAlive == true now\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-  JavaThread *java_thread = java_lang_Thread::thread_acquire(thread_oop);\n+  JavaThread *java_thread = java_lang_Thread::thread(thread_oop);\n@@ -797,3 +797,2 @@\n-    \/\/ The java.lang.Thread does not contain a JavaThread* so it has not\n-    \/\/ run enough to be put on a ThreadsList or it has exited enough to\n-    \/\/ make it past ensure_join() where the JavaThread* is cleared.\n+    \/\/ The java.lang.Thread does not contain a JavaThread * so it has\n+    \/\/ not yet run or it has died.\n@@ -805,4 +804,4 @@\n-    \/\/ java_thread is not the current JavaThread so we have to verify it\n-    \/\/ against the ThreadsList.\n-    if (!includes(java_thread)) {\n-      \/\/ Not on this ThreadsList so it is not protected.\n+    \/\/ jthread is not for the current JavaThread so have to verify\n+    \/\/ the JavaThread * against the ThreadsList.\n+    if (EnableThreadSMRExtraValidityChecks && !includes(java_thread)) {\n+      \/\/ Not on the JavaThreads list so it is not alive.\n@@ -819,14 +818,0 @@\n-FastThreadsListHandle::FastThreadsListHandle(oop thread_oop, JavaThread* java_thread) : _protected_java_thread(nullptr) {\n-  assert(thread_oop != nullptr, \"must be\");\n-  if (java_thread != nullptr) {\n-    \/\/ We captured a non-nullptr JavaThread* before the _tlh was created\n-    \/\/ so that covers the early life stage of the target JavaThread.\n-    _protected_java_thread = java_lang_Thread::thread(thread_oop);\n-    assert(_protected_java_thread == nullptr || _tlh.includes(_protected_java_thread), \"must be\");\n-    \/\/ If we captured a non-nullptr JavaThread* after the _tlh was created\n-    \/\/ then that covers the end life stage of the target JavaThread and we\n-    \/\/ we know that _tlh protects the JavaThread*. The underlying atomic\n-    \/\/ load is sufficient (no acquire necessary here).\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -323,23 +323,0 @@\n-\/\/ This stack allocated FastThreadsListHandle implements the special case\n-\/\/ where we want to quickly determine if a JavaThread* is protected by the\n-\/\/ embedded ThreadsListHandle.\n-\/\/\n-class FastThreadsListHandle : public StackObj {\n-  JavaThread* _protected_java_thread;\n-  ThreadsListHandle _tlh;\n-\n-public:\n-  \/\/ The 'java_thread' parameter to the constructor must be provided\n-  \/\/ by a java_lang_Thread::thread_acquire(thread_oop) call which gets\n-  \/\/ us the JavaThread* stored in the java.lang.Thread object _before_\n-  \/\/ the embedded ThreadsListHandle is constructed. We use acquire there\n-  \/\/ to ensure that if we see a non-nullptr value, then we also see the\n-  \/\/ main ThreadsList updates from the JavaThread* being added.\n-  \/\/\n-  FastThreadsListHandle(oop thread_oop, JavaThread* java_thread);\n-\n-  JavaThread* protected_java_thread() {\n-    return _protected_java_thread;\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -73,4 +73,0 @@\n-#ifndef PRAGMA_INFINITE_RECURSION_IGNORED\n-#define PRAGMA_INFINITE_RECURSION_IGNORED\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#if !defined(__clang_major__) && (__GNUC__ >= 12)\n@@ -43,0 +42,1 @@\n+#if !defined(__clang_major__) && (__GNUC__ >= 12)\n@@ -44,3 +44,0 @@\n-\n-\/\/ Disable -Winfinite-recursion which is introduced in GCC 12.\n-#define PRAGMA_INFINITE_RECURSION_IGNORED PRAGMA_DISABLE_GCC_WARNING(\"-Winfinite-recursion\")\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_gcc.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -327,3 +327,0 @@\n-#define PROPERFMT             SIZE_FORMAT \"%s\"\n-#define PROPERFMTARGS(s)      byte_size_in_proper_unit(s), proper_unit_for_byte_size(s)\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,2 +99,0 @@\n-  \"XDG_CACHE_HOME\", \"XDG_CONFIG_HOME\", \"FC_LANG\", \"FONTCONFIG_USE_MMAP\",\n-\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import sun.security.util.SignatureFileVerifier;\n@@ -155,0 +154,2 @@\n+    \/\/ The maximum size of array to allocate. Some VMs reserve some header words in an array.\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n@@ -802,5 +803,2 @@\n-            if (uncompressedSize > SignatureFileVerifier.MAX_SIG_FILE_SIZE) {\n-                throw new IOException(\"Unsupported size: \" + uncompressedSize +\n-                        \" for JarEntry \" + ze.getName() +\n-                        \". Allowed max size: \" +\n-                        SignatureFileVerifier.MAX_SIG_FILE_SIZE + \" bytes\");\n+            if (uncompressedSize > MAX_ARRAY_SIZE) {\n+                throw new IOException(\"Unsupported size: \" + uncompressedSize);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -125,6 +124,0 @@\n-    \/**\n-     * Flag which specifies whether the validation of the Zip64 extra\n-     * fields should be disabled\n-     *\/\n-    private static final boolean disableZip64ExtraFieldValidation =\n-            GetBooleanAction.privilegedGetProperty(\"jdk.util.zip.disableZip64ExtraFieldValidation\");\n@@ -1205,10 +1198,0 @@\n-\n-            int elen = CENEXT(cen, pos);\n-            if (elen > 0 && !disableZip64ExtraFieldValidation) {\n-                long extraStartingOffset = pos + CENHDR + nlen;\n-                if ((int)extraStartingOffset != extraStartingOffset) {\n-                    zerror(\"invalid CEN header (bad extra offset)\");\n-                }\n-                checkExtraFields(pos, (int)extraStartingOffset, elen);\n-            }\n-\n@@ -1231,113 +1214,0 @@\n-        \/**\n-         * Validate the Zip64 Extra block fields\n-         * @param startingOffset Extra Field starting offset within the CEN\n-         * @param extraFieldLen Length of this Extra field\n-         * @throws ZipException  If an error occurs validating the Zip64 Extra\n-         * block\n-         *\/\n-        private void checkExtraFields(int cenPos, int startingOffset,\n-                                      int extraFieldLen) throws ZipException {\n-            \/\/ Extra field Length cannot exceed 65,535 bytes per the PKWare\n-            \/\/ APP.note 4.4.11\n-            if (extraFieldLen > 0xFFFF) {\n-                zerror(\"invalid extra field length\");\n-            }\n-            \/\/ CEN Offset where this Extra field ends\n-            int extraEndOffset = startingOffset + extraFieldLen;\n-            if (extraEndOffset > cen.length) {\n-                zerror(\"Invalid CEN header (extra data field size too long)\");\n-            }\n-            int currentOffset = startingOffset;\n-            while (currentOffset < extraEndOffset) {\n-                int tag = get16(cen, currentOffset);\n-                currentOffset += Short.BYTES;\n-\n-                int tagBlockSize = get16(cen, currentOffset);\n-                int tagBlockEndingOffset = currentOffset + tagBlockSize;\n-\n-                \/\/  The ending offset for this tag block should not go past the\n-                \/\/  offset for the end of the extra field\n-                if (tagBlockEndingOffset > extraEndOffset) {\n-                    zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                }\n-                currentOffset += Short.BYTES;\n-\n-                if (tag == ZIP64_EXTID) {\n-                    \/\/ Get the compressed size;\n-                    long csize = CENSIZ(cen, cenPos);\n-                    \/\/ Get the uncompressed size;\n-                    long size = CENLEN(cen, cenPos);\n-                    checkZip64ExtraFieldValues(currentOffset, tagBlockSize,\n-                            csize, size);\n-                }\n-                currentOffset += tagBlockSize;\n-            }\n-        }\n-\n-        \/**\n-         * Validate the Zip64 Extended Information Extra Field (0x0001) block\n-         * size and that the uncompressed size and compressed size field\n-         * values are not negative.\n-         * Note:  As we do not use the LOC offset or Starting disk number\n-         * field value we will not validate them\n-         * @param off the starting offset for the Zip64 field value\n-         * @param blockSize the size of the Zip64 Extended Extra Field\n-         * @param csize CEN header compressed size value\n-         * @param size CEN header uncompressed size value\n-         * @throws ZipException if an error occurs\n-         *\/\n-        private void checkZip64ExtraFieldValues(int off, int blockSize, long csize,\n-                                                long size)\n-                throws ZipException {\n-            byte[] cen = this.cen;\n-            \/\/ Validate the Zip64 Extended Information Extra Field (0x0001)\n-            \/\/ length.\n-            if (!isZip64ExtBlockSizeValid(blockSize)) {\n-                zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-            }\n-            \/\/ Check the uncompressed size is not negative\n-            \/\/ Note we do not need to check blockSize is >= 8 as\n-            \/\/ we know its length is at least 8 from the call to\n-            \/\/ isZip64ExtBlockSizeValid()\n-            if ((size == ZIP64_MAGICVAL)) {\n-                if(get64(cen, off) < 0) {\n-                    zerror(\"Invalid zip64 extra block size value\");\n-                }\n-            }\n-            \/\/ Check the compressed size is not negative\n-            if ((csize == ZIP64_MAGICVAL) && (blockSize >= 16)) {\n-                if (get64(cen, off + 8) < 0) {\n-                    zerror(\"Invalid zip64 extra block compressed size value\");\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Validate the size and contents of a Zip64 extended information field\n-         * The order of the Zip64 fields is fixed, but the fields MUST\n-         * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n-         * or 0xFFFFFFFF:\n-         * Uncompressed Size - 8 bytes\n-         * Compressed Size   - 8 bytes\n-         * LOC Header offset - 8 bytes\n-         * Disk Start Number - 4 bytes\n-         * See PKWare APP.Note Section 4.5.3 for more details\n-         *\n-         * @param blockSize the Zip64 Extended Information Extra Field size\n-         * @return true if the extra block size is valid; false otherwise\n-         *\/\n-        private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n-            \/*\n-             * As the fields must appear in order, the block size indicates which\n-             * fields to expect:\n-             *  8 - uncompressed size\n-             * 16 - uncompressed size, compressed size\n-             * 24 - uncompressed size, compressed sise, LOC Header offset\n-             * 28 - uncompressed size, compressed sise, LOC Header offset,\n-             * and Disk start number\n-             *\/\n-            return switch(blockSize) {\n-                case 8, 16, 24, 28 -> true;\n-                default -> false;\n-            };\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-import sun.security.action.GetIntegerAction;\n@@ -101,6 +100,0 @@\n-    \/\/ the maximum allowed size in bytes for the signature-related files\n-    public static final int MAX_SIG_FILE_SIZE = initializeMaxSigFileSize();\n-\n-    \/\/ The maximum size of array to allocate. Some VMs reserve some header words in an array.\n-    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n-\n@@ -852,20 +845,0 @@\n-\n-    private static int initializeMaxSigFileSize() {\n-        \/*\n-         * System property \"jdk.jar.maxSignatureFileSize\" used to configure\n-         * the maximum allowed number of bytes for the signature-related files\n-         * in a JAR file.\n-         *\/\n-        Integer tmp = GetIntegerAction.privilegedGetProperty(\n-                \"jdk.jar.maxSignatureFileSize\", 8000000);\n-        if (tmp < 0 || tmp > MAX_ARRAY_SIZE) {\n-            if (debug != null) {\n-                debug.println(\"Default signature file size 8000000 bytes \" +\n-                        \"is used as the specified size for the \" +\n-                        \"jdk.jar.maxSignatureFileSize system property \" +\n-                        \"is out of range: \" + tmp);\n-            }\n-            tmp = 8000000;\n-        }\n-        return tmp;\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -891,2 +891,1 @@\n-jdk.tls.keyLimits=AES\/GCM\/NoPadding KeyUpdate 2^37, \\\n-                  ChaCha20-Poly1305 KeyUpdate 2^37\n+jdk.tls.keyLimits=AES\/GCM\/NoPadding KeyUpdate 2^37\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/88467c960d6cdad2ca1623e892e5e17506bc269f\/public_suffix_list.dat.\n+https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/3c213aab32b3c014f171b1673d4ce9b5cd72bf1c\/public_suffix_list.dat.\n","filename":"src\/java.base\/share\/legal\/public_suffix.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,4 @@\n+            if ((c == '\/') && (pos < len) && (p.charAt(pos) == '\/')) {\n+                \/\/ skip redundant slashes\n+                continue;\n+            }\n@@ -91,4 +95,0 @@\n-            if (b == '\/' && rlen > 0 && result[rlen-1] == '\/') {\n-                \/\/ skip redundant slashes\n-                continue;\n-            }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUriUtils.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -618,12 +618,0 @@\n-     * <p>\n-     * Whilst this API may be safe for loading local resources that are\n-     * delivered with a {@code LookAndFeel} or application, and so have an\n-     * equal level of trust with application code, using it to load from\n-     * remote resources, particularly any which may have a lower level of\n-     * trust, is strongly discouraged.\n-     * The alternative mechanisms to load styles from an {@code InputStream}\n-     * {@linkplain #load(InputStream, Class)}\n-     * using resources co-located with the application or by providing a\n-     * {@code SynthStyleFactory} to\n-     * {@linkplain #setStyleFactory setStyleFactory(SynthStyleFactory)}\n-     * are preferred.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthLookAndFeel.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-    <\/p>\n-    <p>\n@@ -99,5 +97,0 @@\n-    <p>Note: Synth's file format allows for the definition of code to be executed.\n-       Loading any code from a remote location should be used only\n-       with extreme caution from a trusted source over a secure connection.\n-       It is strongly discouraged for an application or a LookAndFeel to do so.\n-    <\/p>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/doc-files\/synthFileFormat.html","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## The FreeType Project: Freetype v2.13.0\n+## The FreeType Project: Freetype v2.12.1\n@@ -24,20 +24,21 @@\n-Copyright (C) 1996-2023 by David Turner, Robert Wilhelm, and Werner Lemberg.\n-Copyright (C) 2007-2023 by Dereg Clegg and Michael Toftdal.\n-Copyright (C) 1996-2023 by Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.\n-Copyright (C) 2022-2023 by David Turner, Robert Wilhelm, Werner Lemberg, George Williams, and\n-Copyright (C) 2004-2023 by Masatake YAMATO and Redhat K.K.\n-Copyright (C) 2007-2023 by Derek Clegg and Michael Toftdal.\n-Copyright (C) 2003-2023 by Masatake YAMATO, Red Hat K.K.,\n-Copyright (C) 1996-2023 by David Turner, Robert Wilhelm, Werner Lemberg, and Dominik Röttsches.\n-Copyright (C) 2007-2023 by David Turner.\n-Copyright (C) 2022-2023 by David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n-Copyright (C) 2007-2023 by Rahul Bhalerao <rahul.bhalerao@redhat.com>, <b.rahul.pm@gmail.com>.\n-Copyright (C) 2008-2023 by David Turner, Robert Wilhelm, Werner Lemberg, and suzuki toshiya.\n-Copyright (C) 2013-2023 by Google, Inc.\n-Copyright (C) 2019-2023 by Nikhil Ramakrishnan, David Turner, Robert Wilhelm, and Werner Lemberg.\n-Copyright (C) 2009-2023 by Oran Agra and Mickey Gabel.\n-Copyright (C) 2018-2023 by David Turner, Robert Wilhelm, Dominik Röttsches, and Werner Lemberg.\n-Copyright (C) 2004-2023 by David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.\n-\n-\n-                    The FreeType Project LICENSE\n+Copyright (C) 1996-2022 by David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2007-2022 by Dereg Clegg and Michael Toftdal.\n+Copyright (C) 1996-2022 by Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2004-2022 by Masatake YAMATO and Redhat K.K.\n+Copyright (C) 2007-2022 by Derek Clegg and Michael Toftdal.\n+Copyright (C) 2007-2022 by David Turner.\n+Copyright (C) 2022 by David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n+Copyright (C) 2007-2022 by Rahul Bhalerao <rahul.bhalerao@redhat.com>, <b.rahul.pm@gmail.com>.\n+Copyright (C) 2008-2022 by David Turner, Robert Wilhelm, Werner Lemberg, and suzuki toshiya.\n+Copyright (C) 2019-2022 by Nikhil Ramakrishnan, David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2009-2022 by Oran Agra and Mickey Gabel.\n+Copyright (C) 2004-2022 by David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.\n+Copyright (C) 2004-2022 by Masatake YAMATO, Red Hat K.K.,\n+Copyright (C) 2003-2022 by Masatake YAMATO, Redhat K.K.,\n+Copyright (C) 2013-2022 by Google, Inc.\n+Copyright (C) 2018-2022 by David Turner, Robert Wilhelm, Dominik Röttsches, and Werner Lemberg.\n+Copyright (C) 2005-2022 by David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright 2013 by Google, Inc.\n+\n+\n+                   The FreeType Project LICENSE\n@@ -208,1 +209,1 @@\n-    https:\/\/www.freetype.org\n+    http:\/\/www.freetype.org\n","filename":"src\/java.desktop\/share\/legal\/freetype.md","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftconfig.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftheader.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -464,3 +464,3 @@\n-   *     af_debug_disable_horz_hints_\n-   *     af_debug_disable_vert_hints_\n-   *     af_debug_disable_blue_hints_\n+   *     _af_debug_disable_horz_hints\n+   *     _af_debug_disable_vert_hints\n+   *     _af_debug_disable_blue_hints\n@@ -483,1 +483,1 @@\n-   *     af_debug_hints_\n+   *     _af_debug_hints\n@@ -587,1 +587,1 @@\n-   * load and enumerate Postscript names of glyphs in a TrueType or OpenType\n+   * load and enumerate the glyph Postscript names in a TrueType or OpenType\n@@ -590,3 +590,3 @@\n-   * Note that if you do not compile the 'psnames' module by undefining the\n-   * above `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` macro, the 'sfnt' module will\n-   * contain additional code to read the PostScript name table from a font.\n+   * Note that when you do not compile the 'psnames' module by undefining the\n+   * above `FT_CONFIG_OPTION_POSTSCRIPT_NAMES`, the 'sfnt' module will\n+   * contain additional code used to read the PS Names table from a font.\n@@ -742,18 +742,0 @@\n-  \/**************************************************************************\n-   *\n-   * Define `TT_CONFIG_OPTION_NO_BORING_EXPANSION` if you want to exclude\n-   * support for 'boring' OpenType specification expansions.\n-   *\n-   *   https:\/\/github.com\/harfbuzz\/boring-expansion-spec\n-   *\n-   * Right now, the following features are covered:\n-   *\n-   *   - 'avar' version 2.0\n-   *\n-   * Most likely, this is a temporary configuration option to be removed in\n-   * the near future, since it is assumed that eventually those features are\n-   * added to the OpenType standard.\n-   *\/\n-\/* #define TT_CONFIG_OPTION_NO_BORING_EXPANSION *\/\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftoption.h","additions":9,"deletions":27,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftstdlib.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/integer-types.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/mac-support.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020-2023 by\n+ * Copyright (C) 2020-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/public-macros.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -218,0 +218,1 @@\n+   *   FT_Get_Name_Index\n@@ -256,0 +257,2 @@\n+   *   FT_Get_Glyph_Name\n+   *   FT_Get_Postscript_Name\n@@ -262,3 +265,0 @@\n-   *   FT_Get_Name_Index\n-   *   FT_Get_Glyph_Name\n-   *   FT_Get_Postscript_Name\n@@ -649,1 +649,1 @@\n-   *   repertoires (i.e., charsets), and not text encoding methods (e.g.,\n+   *   repertories (i.e., charsets), and not text encoding methods (e.g.,\n@@ -782,1 +782,1 @@\n-   *   `TT_MAC_LANGID_FARSI` means the Farsi variant of the Arabic encoding.\n+   *   `TT_MAC_LANGID_FARSI` means the Farsi variant the Arabic encoding.\n@@ -1170,3 +1170,3 @@\n-   *     function always returns the vector (0,0).  Note that FreeType\n-   *     doesn't handle kerning data from the SFNT 'GPOS' table (as present\n-   *     in many OpenType fonts).\n+   *     function always return the vector (0,0).  Note that FreeType doesn't\n+   *     handle kerning data from the SFNT 'GPOS' table (as present in many\n+   *     OpenType fonts).\n@@ -1895,1 +1895,1 @@\n-   *     WYSIWYG layout.  Only relevant for scalable glyphs.\n+   *     WYSIWYG layout.  Only relevant for outline glyphs.\n@@ -1901,1 +1901,1 @@\n-   *     WYSIWYG layout.  Only relevant for scalable glyphs.\n+   *     WYSIWYG layout.  Only relevant for outline glyphs.\n@@ -2596,2 +2596,2 @@\n-  FT_Attach_Stream( FT_Face              face,\n-                    const FT_Open_Args*  parameters );\n+  FT_Attach_Stream( FT_Face        face,\n+                    FT_Open_Args*  parameters );\n@@ -3080,1 +3080,1 @@\n-   *     when the glyphs are rendered in any of the anti-aliased modes.  See\n+   *     when the glyph are rendered in any of the anti-aliased modes.  See\n@@ -3437,1 +3437,1 @@\n-   *     A pointer to a translation vector.  Set this to NULL if you are not\n+   *     A pointer a translation vector.  Set this to NULL if you are not\n@@ -3562,4 +3562,3 @@\n-   *      Self-intersection happens when a single connected contour\n-   *      intersects itself at some point; having these in your font\n-   *      definitely poses a problem to the rasterizer and cause artifacts,\n-   *      too.\n+   *      Self-intersection happens when a single connected contour intersect\n+   *      itself at some point; having these in your font definitely pose a\n+   *      problem to the rasterizer and cause artifacts, too.\n@@ -3844,0 +3843,83 @@\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Glyph_Name\n+   *\n+   * @description:\n+   *   Retrieve the ASCII name of a given glyph in a face.  This only works\n+   *   for those faces where @FT_HAS_GLYPH_NAMES(face) returns~1.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to a source face object.\n+   *\n+   *   glyph_index ::\n+   *     The glyph index.\n+   *\n+   *   buffer_max ::\n+   *     The maximum number of bytes available in the buffer.\n+   *\n+   * @output:\n+   *   buffer ::\n+   *     A pointer to a target buffer where the name is copied to.\n+   *\n+   * @return:\n+   *   FreeType error code.  0~means success.\n+   *\n+   * @note:\n+   *   An error is returned if the face doesn't provide glyph names or if the\n+   *   glyph index is invalid.  In all cases of failure, the first byte of\n+   *   `buffer` is set to~0 to indicate an empty name.\n+   *\n+   *   The glyph name is truncated to fit within the buffer if it is too\n+   *   long.  The returned string is always zero-terminated.\n+   *\n+   *   Be aware that FreeType reorders glyph indices internally so that glyph\n+   *   index~0 always corresponds to the 'missing glyph' (called '.notdef').\n+   *\n+   *   This function always returns an error if the config macro\n+   *   `FT_CONFIG_OPTION_NO_GLYPH_NAMES` is not defined in `ftoption.h`.\n+   *\/\n+  FT_EXPORT( FT_Error )\n+  FT_Get_Glyph_Name( FT_Face     face,\n+                     FT_UInt     glyph_index,\n+                     FT_Pointer  buffer,\n+                     FT_UInt     buffer_max );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Postscript_Name\n+   *\n+   * @description:\n+   *   Retrieve the ASCII PostScript name of a given face, if available.\n+   *   This only works with PostScript, TrueType, and OpenType fonts.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the source face object.\n+   *\n+   * @return:\n+   *   A pointer to the face's PostScript name.  `NULL` if unavailable.\n+   *\n+   * @note:\n+   *   The returned pointer is owned by the face and is destroyed with it.\n+   *\n+   *   For variation fonts, this string changes if you select a different\n+   *   instance, and you have to call `FT_Get_PostScript_Name` again to\n+   *   retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating\n+   *   PostScript Names for Fonts Using OpenType Font Variations'.\n+   *\n+   *     https:\/\/download.macromedia.com\/pub\/developer\/opentype\/tech-notes\/5902.AdobePSNameGeneration.html\n+   *\n+   *   [Since 2.9] Special PostScript names for named instances are only\n+   *   returned if the named instance is set with @FT_Set_Named_Instance (and\n+   *   the font has corresponding entries in its 'fvar' table).  If\n+   *   @FT_IS_VARIATION returns true, the algorithmically derived PostScript\n+   *   name is provided, not looking up special entries for named instances.\n+   *\/\n+  FT_EXPORT( const char* )\n+  FT_Get_Postscript_Name( FT_Face  face );\n+\n+\n@@ -4164,2 +4246,1 @@\n-   *   Return the glyph index of a given glyph name.  This only works\n-   *   for those faces where @FT_HAS_GLYPH_NAMES returns true.\n+   *   Return the glyph index of a given glyph name.\n@@ -4176,10 +4257,0 @@\n-   *\n-   * @note:\n-   *   Acceptable glyph names might come from the [Adobe Glyph\n-   *   List](https:\/\/github.com\/adobe-type-tools\/agl-aglfn).  See\n-   *   @FT_Get_Glyph_Name for the inverse functionality.\n-   *\n-   *   This function has limited capabilities if the config macro\n-   *   `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:\n-   *   It then works only for fonts that actually embed glyph names (which\n-   *   many recent OpenType fonts do not).\n@@ -4192,85 +4263,0 @@\n-  \/**************************************************************************\n-   *\n-   * @function:\n-   *   FT_Get_Glyph_Name\n-   *\n-   * @description:\n-   *   Retrieve the ASCII name of a given glyph in a face.  This only works\n-   *   for those faces where @FT_HAS_GLYPH_NAMES returns true.\n-   *\n-   * @input:\n-   *   face ::\n-   *     A handle to a source face object.\n-   *\n-   *   glyph_index ::\n-   *     The glyph index.\n-   *\n-   *   buffer_max ::\n-   *     The maximum number of bytes available in the buffer.\n-   *\n-   * @output:\n-   *   buffer ::\n-   *     A pointer to a target buffer where the name is copied to.\n-   *\n-   * @return:\n-   *   FreeType error code.  0~means success.\n-   *\n-   * @note:\n-   *   An error is returned if the face doesn't provide glyph names or if the\n-   *   glyph index is invalid.  In all cases of failure, the first byte of\n-   *   `buffer` is set to~0 to indicate an empty name.\n-   *\n-   *   The glyph name is truncated to fit within the buffer if it is too\n-   *   long.  The returned string is always zero-terminated.\n-   *\n-   *   Be aware that FreeType reorders glyph indices internally so that glyph\n-   *   index~0 always corresponds to the 'missing glyph' (called '.notdef').\n-   *\n-   *   This function has limited capabilities if the config macro\n-   *   `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:\n-   *   It then works only for fonts that actually embed glyph names (which\n-   *   many recent OpenType fonts do not).\n-   *\/\n-  FT_EXPORT( FT_Error )\n-  FT_Get_Glyph_Name( FT_Face     face,\n-                     FT_UInt     glyph_index,\n-                     FT_Pointer  buffer,\n-                     FT_UInt     buffer_max );\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @function:\n-   *   FT_Get_Postscript_Name\n-   *\n-   * @description:\n-   *   Retrieve the ASCII PostScript name of a given face, if available.\n-   *   This only works with PostScript, TrueType, and OpenType fonts.\n-   *\n-   * @input:\n-   *   face ::\n-   *     A handle to the source face object.\n-   *\n-   * @return:\n-   *   A pointer to the face's PostScript name.  `NULL` if unavailable.\n-   *\n-   * @note:\n-   *   The returned pointer is owned by the face and is destroyed with it.\n-   *\n-   *   For variation fonts, this string changes if you select a different\n-   *   instance, and you have to call `FT_Get_PostScript_Name` again to\n-   *   retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating\n-   *   PostScript Names for Fonts Using OpenType Font Variations'.\n-   *\n-   *     https:\/\/download.macromedia.com\/pub\/developer\/opentype\/tech-notes\/5902.AdobePSNameGeneration.html\n-   *\n-   *   [Since 2.9] Special PostScript names for named instances are only\n-   *   returned if the named instance is set with @FT_Set_Named_Instance (and\n-   *   the font has corresponding entries in its 'fvar' table).  If\n-   *   @FT_IS_VARIATION returns true, the algorithmically derived PostScript\n-   *   name is provided, not looking up special entries for named instances.\n-   *\/\n-  FT_EXPORT( const char* )\n-  FT_Get_Postscript_Name( FT_Face  face );\n-\n-\n@@ -4363,0 +4349,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   base_interface\n+   *\n+   *\/\n+\n@@ -4698,2 +4691,1 @@\n-   *   on 16.16 fixed-point numbers or 2D vectors.  FreeType does not use\n-   *   floating-point data types.\n+   *   on 16.16 fixed-float numbers or 2d vectors.\n@@ -4952,2 +4944,2 @@\n-#define FREETYPE_MINOR  13\n-#define FREETYPE_PATCH  0\n+#define FREETYPE_MINOR  12\n+#define FREETYPE_PATCH  1\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/freetype.h","additions":112,"deletions":120,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2023 by\n+ * Copyright (C) 2008-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftadvanc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbbox.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbdf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbitmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftcid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2022 by\n@@ -459,3 +459,0 @@\n-   *\n-   * @since:\n-   *   2.10\n@@ -481,1 +478,1 @@\n-   *   The enumeration values loosely correspond with the format numbers of\n+   *   The enumeration values losely correspond with the format numbers of\n@@ -495,1 +492,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -525,4 +524,3 @@\n-   *   state while iterating over the stops of an @FT_ColorLine, representing\n-   *   the `ColorLine` struct of the v1 extensions to 'COLR', see\n-   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  Do not manually\n-   *   modify fields of this iterator.\n+   *   state while iterating over the stops of an @FT_ColorLine,\n+   *   representing the `ColorLine` struct of the v1 extensions to 'COLR',\n+   *   see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n@@ -542,4 +540,0 @@\n-   *   read_variable ::\n-   *     A boolean keeping track of whether variable color lines are to be\n-   *     read.  Set by @FT_Get_Paint.\n-   *\n@@ -547,1 +541,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -556,2 +552,0 @@\n-    FT_Bool  read_variable;\n-\n@@ -578,1 +572,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -599,2 +595,1 @@\n-   *     The stop offset along the gradient, expressed as a 16.16 fixed-point\n-   *     coordinate.\n+   *     The stop offset between 0 and 1 along the gradient.\n@@ -606,1 +601,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -610,1 +607,1 @@\n-    FT_Fixed       stop_offset;\n+    FT_F2Dot14     stop_offset;\n@@ -627,1 +624,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -657,1 +656,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -701,1 +702,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -722,1 +725,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -784,1 +789,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -811,1 +818,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -836,1 +845,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -875,1 +886,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -898,1 +911,2 @@\n-   *   layer filled with this paint is drawn filled with a radial gradient.\n+   *   layer filled with this paint is drawn filled filled with a radial\n+   *   gradient.\n@@ -922,1 +936,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -970,1 +986,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1001,1 +1019,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1025,1 +1045,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1051,1 +1073,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1084,1 +1108,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1133,1 +1159,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward-compatibility of both the API and ABI.\n+   *\n@@ -1169,1 +1197,1 @@\n-   *     units represented as a 16.16 fixed-point value.\n+   *     units) represented as a 16.16 fixed-point value.\n@@ -1176,1 +1204,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1225,1 +1255,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1246,2 +1278,3 @@\n-   *   A structure representing a 'COLR' v1 `PaintComposite` paint table.\n-   *   Used for compositing two paints in a 'COLR' v1 directed acyclic graph.\n+   *   A structure representing a 'COLR'v1 `PaintComposite` paint table.\n+   *   Used for compositing two paints in a 'COLR' v1 directed acycling\n+   *   graph.\n@@ -1263,1 +1296,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1307,1 +1342,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1352,1 +1389,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1393,1 +1432,3 @@\n-   *   2.13\n+   *   2.12 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1486,1 +1527,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1528,1 +1571,3 @@\n-   *   2.13\n+   *   2.12 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1575,1 +1620,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1616,1 +1663,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n@@ -1652,1 +1701,3 @@\n-   *   2.13\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftcolor.h","additions":103,"deletions":52,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2022 by\n@@ -823,0 +823,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftdriver.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fterrdef.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -32,1 +32,1 @@\n-   *   `freetype.h`) defines the handling of FreeType's enumeration\n+   *   `freetype.h` defines the handling of FreeType's enumeration\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fterrors.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftfntfmt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftgasp.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -358,1 +358,1 @@\n-   *     A handle to the glyph object.  `NULL` in case of error.\n+   *     A handle to the glyph object.\n@@ -388,1 +388,1 @@\n-   *     A handle to the target glyph object.  `NULL` in case of error.\n+   *     A handle to the target glyph object.  0~in case of error.\n@@ -416,1 +416,1 @@\n-   *     1\/64 of a pixel.\n+   *     1\/64th of a pixel.\n@@ -503,1 +503,1 @@\n-   *     1\/64 of pixels if it is grid-fitted.\n+   *     1\/64th of pixels if it is grid-fitted.\n@@ -674,1 +674,1 @@\n-   *     A handle to the target glyph object.  Can be `NULL`.\n+   *     A handle to the target glyph object.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftglyph.h","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftgzip.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftimage.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftincrem.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n@@ -140,1 +140,1 @@\n-   *     with weights of [0x08 0x4D 0x56 0x4D 0x08] in 1\/256 units.\n+   *     with weights of [0x08 0x4D 0x56 0x4D 0x08] in 1\/256th units.\n@@ -144,1 +144,1 @@\n-   *     weights of [0x00 0x55 0x56 0x55 0x00] in 1\/256 units.\n+   *     weights of [0x00 0x55 0x56 0x55 0x00] in 1\/256th units.\n@@ -229,1 +229,1 @@\n-   *     uses them to specify the filter weights in 1\/256 units.\n+   *     uses them to specify the filter weights in 1\/256th units.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlcdfil.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlist.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020-2023 by\n+ * Copyright (C) 2020-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlogging.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmac.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -401,4 +401,0 @@\n-   *   The design coordinates are 16.16 fractional values for TrueType GX and\n-   *   OpenType variation fonts.  For Adobe MM fonts, the values are\n-   *   integers.\n-   *\n@@ -447,5 +443,0 @@\n-   * @note:\n-   *   The design coordinates are 16.16 fractional values for TrueType GX and\n-   *   OpenType variation fonts.  For Adobe MM fonts, the values are\n-   *   integers.\n-   *\n@@ -483,3 +474,3 @@\n-   *     The design coordinates array.  Each element is a 16.16 fractional\n-   *     value and must be between 0 and 1.0 for Adobe MM fonts, and between\n-   *     -1.0 and 1.0 for TrueType GX and OpenType variation fonts.\n+   *     The design coordinates array (each element must be between 0 and 1.0\n+   *     for Adobe MM fonts, and between -1.0 and 1.0 for TrueType GX and\n+   *     OpenType variation fonts).\n@@ -530,1 +521,1 @@\n-   *     The normalized blend coordinates array (as 16.16 fractional values).\n+   *     The normalized blend coordinates array.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmm.h","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmodapi.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmoderr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftoutln.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftparams.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftrender.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsizes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsnames.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n@@ -296,1 +296,1 @@\n-   *     expressed as 16.16 fixed-point value.\n+   *     expressed as 16.16 fixed point value.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftstroke.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n@@ -71,1 +71,1 @@\n-  \/* Slant an outline glyph to the right by about 12 degrees.              *\/\n+  \/* Slant an outline glyph to the right by about 12 degrees. *\/\n@@ -75,9 +75,0 @@\n-  \/* Slant an outline glyph by a given sine of an angle.  You can apply    *\/\n-  \/* slant along either x- or y-axis by choosing a corresponding non-zero  *\/\n-  \/* argument.  If both slants are non-zero, some affine transformation    *\/\n-  \/* will result.                                                          *\/\n-  FT_EXPORT( void )\n-  FT_GlyphSlot_Slant( FT_GlyphSlot  slot,\n-                      FT_Fixed      xslant,\n-                      FT_Fixed      yslant );\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsynth.h","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -232,2 +232,1 @@\n-   *     The offset from the start of the stream to seek to if this is a seek\n-   *     operation (see note).\n+   *     The offset of read in stream (always from start).\n@@ -245,7 +244,2 @@\n-   *   This function performs a seek *or* a read operation depending on the\n-   *   argument values.  If `count` is zero, the operation is a seek to\n-   *   `offset` bytes.  If `count` is >~0, the operation is a read of `count`\n-   *   bytes from the current position in the stream, and the `offset` value\n-   *   should be ignored.\n-   *\n-   *   For seek operations, a non-zero return value indicates an error.\n+   *   This function might be called to perform a seek or skip operation with\n+   *   a `count` of~0.  A non-zero return value then indicates an error.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsystem.h","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fttrigon.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -48,4 +48,1 @@\n-   *   font-specific structures are defined in a different section.  Note\n-   *   that FreeType does not use floating-point data types.  Fractional\n-   *   values are represented by fixed-point integers, with lower bits\n-   *   storing the fractional part.\n+   *   font-specific structures are defined in a different section.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fttypes.h","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/autohint.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/cffotypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -318,1 +318,1 @@\n-    \/* Blended values are stored as 5-byte fixed-point values.            *\/\n+    \/* Blended values are stored as 5-byte fixed point values.            *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/cfftypes.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020-2023 by\n+ * Copyright (C) 2020-2022 by\n@@ -37,13 +37,0 @@\n-#endif\n-\n-  \/* Newer compilers warn for fall-through case statements. *\/\n-#ifndef FALL_THROUGH\n-#  if ( defined( __STDC_VERSION__ ) && __STDC_VERSION__ > 201710L ) || \\\n-      ( defined( __cplusplus ) && __cplusplus > 201402L )\n-#    define FALL_THROUGH  [[__fallthrough__]]\n-#  elif ( defined( __GNUC__ ) && __GNUC__ >= 7 )          || \\\n-        ( defined( __clang__ ) && __clang_major__ >= 10 )\n-#    define FALL_THROUGH  __attribute__(( __fallthrough__ ))\n-#  else\n-#    define FALL_THROUGH  ( (void)0 )\n-#  endif\n@@ -274,1 +261,1 @@\n-  \/* See `freetype\/config\/public-macros.h` for the `FT_EXPORT` definition *\/\n+  \/* See `freetype\/config\/compiler_macros.h` for the `FT_EXPORT` definition *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/compiler-macros.h","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -281,34 +281,0 @@\n-  \/**************************************************************************\n-   *\n-   * @function:\n-   *   FT_MulAddFix\n-   *\n-   * @description:\n-   *   Compute `(s[0] * f[0] + s[1] * f[1] + ...) \/ 0x10000`, where `s[n]` is\n-   *   usually a 16.16 scalar.\n-   *\n-   * @input:\n-   *   s ::\n-   *     The array of scalars.\n-   *   f ::\n-   *     The array of factors.\n-   *   count ::\n-   *     The number of entries in the array.\n-   *\n-   * @return:\n-   *   The result of `(s[0] * f[0] + s[1] * f[1] + ...) \/ 0x10000`.\n-   *\n-   * @note:\n-   *   This function is currently used for the scaled delta computation of\n-   *   variation stores.  It internally uses 64-bit data types when\n-   *   available, otherwise it emulates 64-bit math by using 32-bit\n-   *   operations, which produce a correct result but most likely at a slower\n-   *   performance in comparison to the implementation base on `int64_t`.\n-   *\n-   *\/\n-  FT_BASE( FT_Int32 )\n-  FT_MulAddFix( FT_Fixed*  s,\n-                FT_Int32*  f,\n-                FT_UInt    count );\n-\n-\n@@ -450,5 +416,5 @@\n-#pragma aux FT_MSB_i386 =             \\\n-  \"bsr eax, eax\"                      \\\n-  __parm [__eax] __nomemory           \\\n-  __value [__eax]                     \\\n-  __modify __exact [__eax] __nomemory;\n+#pragma aux FT_MSB_i386 =     \\\n+  \"bsr eax, eax\"              \\\n+  parm [eax] nomemory         \\\n+  value [eax]                 \\\n+  modify exact [eax] nomemory;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftcalc.h","additions":6,"deletions":40,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftdebug.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftdrv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftgloadr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -99,2 +99,2 @@\n-  FT_BASE( const char* )  ft_debug_file_;\n-  FT_BASE( long )         ft_debug_lineno_;\n+  FT_BASE( const char* )  _ft_debug_file;\n+  FT_BASE( long )         _ft_debug_lineno;\n@@ -102,2 +102,2 @@\n-#define FT_DEBUG_INNER( exp )  ( ft_debug_file_   = __FILE__, \\\n-                                 ft_debug_lineno_ = __LINE__, \\\n+#define FT_DEBUG_INNER( exp )  ( _ft_debug_file   = __FILE__, \\\n+                                 _ft_debug_lineno = __LINE__, \\\n@@ -106,2 +106,2 @@\n-#define FT_ASSIGNP_INNER( p, exp )  ( ft_debug_file_   = __FILE__, \\\n-                                      ft_debug_lineno_ = __LINE__, \\\n+#define FT_ASSIGNP_INNER( p, exp )  ( _ft_debug_file   = __FILE__, \\\n+                                      _ft_debug_lineno = __LINE__, \\\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftmemory.h","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/****************************************************************************\n- *\n- * ftmmtypes.h\n- *\n- *   OpenType Variations type definitions for internal use\n- *   with the multi-masters service (specification).\n- *\n- * Copyright (C) 2022-2023 by\n- * David Turner, Robert Wilhelm, Werner Lemberg, George Williams, and\n- * Dominik Röttsches.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-#ifndef FTMMTYPES_H_\n-#define FTMMTYPES_H_\n-\n-FT_BEGIN_HEADER\n-\n-\n-  typedef FT_Int32  FT_ItemVarDelta;\n-\n-  typedef struct  GX_ItemVarDataRec_\n-  {\n-    FT_UInt            itemCount;       \/* number of delta sets per item    *\/\n-    FT_UInt            regionIdxCount;  \/* number of region indices         *\/\n-    FT_UInt*           regionIndices;   \/* array of `regionCount' indices;  *\/\n-                                        \/* these index `varRegionList'      *\/\n-    FT_ItemVarDelta*   deltaSet;        \/* array of `itemCount' deltas      *\/\n-                                        \/* use `innerIndex' for this array  *\/\n-\n-  } GX_ItemVarDataRec, *GX_ItemVarData;\n-\n-\n-  \/* contribution of one axis to a region *\/\n-  typedef struct  GX_AxisCoordsRec_\n-  {\n-    FT_Fixed  startCoord;\n-    FT_Fixed  peakCoord;      \/* zero means no effect (factor = 1) *\/\n-    FT_Fixed  endCoord;\n-\n-  } GX_AxisCoordsRec, *GX_AxisCoords;\n-\n-\n-  typedef struct  GX_VarRegionRec_\n-  {\n-    GX_AxisCoords  axisList;               \/* array of axisCount records *\/\n-\n-  } GX_VarRegionRec, *GX_VarRegion;\n-\n-\n-  \/* item variation store *\/\n-  typedef struct  GX_ItemVarStoreRec_\n-  {\n-    FT_UInt         dataCount;\n-    GX_ItemVarData  varData;            \/* array of dataCount records;     *\/\n-                                        \/* use `outerIndex' for this array *\/\n-    FT_UShort     axisCount;\n-    FT_UInt       regionCount;          \/* total number of regions defined *\/\n-    GX_VarRegion  varRegionList;\n-\n-  } GX_ItemVarStoreRec, *GX_ItemVarStore;\n-\n-\n-  typedef struct  GX_DeltaSetIdxMapRec_\n-  {\n-    FT_ULong  mapCount;\n-    FT_UInt*  outerIndex;               \/* indices to item var data *\/\n-    FT_UInt*  innerIndex;               \/* indices to delta set     *\/\n-\n-  } GX_DeltaSetIdxMapRec, *GX_DeltaSetIdxMap;\n-\n-\n-FT_END_HEADER\n-\n-#endif \/* FTMMTYPES_H_ *\/\n-\n-\n-\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftmmtypes.h","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftpsprop.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftrfork.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftserv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -241,2 +241,2 @@\n-#define FT_NEXT_SHORT( buffer )                        \\\n-          ( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) )\n+#define FT_NEXT_SHORT( buffer )                                   \\\n+          ( (short)( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) ) )\n@@ -244,2 +244,2 @@\n-#define FT_NEXT_USHORT( buffer )                        \\\n-          ( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) )\n+#define FT_NEXT_USHORT( buffer )                                            \\\n+          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) ) )\n@@ -247,2 +247,2 @@\n-#define FT_NEXT_OFF3( buffer )                        \\\n-          ( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) )\n+#define FT_NEXT_OFF3( buffer )                                  \\\n+          ( (long)( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) ) )\n@@ -250,2 +250,2 @@\n-#define FT_NEXT_UOFF3( buffer )                        \\\n-          ( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) )\n+#define FT_NEXT_UOFF3( buffer )                                           \\\n+          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) ) )\n@@ -253,2 +253,2 @@\n-#define FT_NEXT_LONG( buffer )                        \\\n-          ( buffer += 4, FT_PEEK_LONG( buffer - 4 ) )\n+#define FT_NEXT_LONG( buffer )                                  \\\n+          ( (long)( buffer += 4, FT_PEEK_LONG( buffer - 4 ) ) )\n@@ -256,2 +256,2 @@\n-#define FT_NEXT_ULONG( buffer )                        \\\n-          ( buffer += 4, FT_PEEK_ULONG( buffer - 4 ) )\n+#define FT_NEXT_ULONG( buffer )                                           \\\n+          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG( buffer - 4 ) ) )\n@@ -260,2 +260,2 @@\n-#define FT_NEXT_SHORT_LE( buffer )                        \\\n-          ( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) )\n+#define FT_NEXT_SHORT_LE( buffer )                                   \\\n+          ( (short)( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) ) )\n@@ -263,2 +263,2 @@\n-#define FT_NEXT_USHORT_LE( buffer )                        \\\n-          ( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) )\n+#define FT_NEXT_USHORT_LE( buffer )                                            \\\n+          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) ) )\n@@ -266,2 +266,2 @@\n-#define FT_NEXT_OFF3_LE( buffer )                        \\\n-          ( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) )\n+#define FT_NEXT_OFF3_LE( buffer )                                  \\\n+          ( (long)( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) ) )\n@@ -269,2 +269,2 @@\n-#define FT_NEXT_UOFF3_LE( buffer )                        \\\n-          ( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) )\n+#define FT_NEXT_UOFF3_LE( buffer )                                           \\\n+          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) ) )\n@@ -272,2 +272,2 @@\n-#define FT_NEXT_LONG_LE( buffer )                        \\\n-          ( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) )\n+#define FT_NEXT_LONG_LE( buffer )                                  \\\n+          ( (long)( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) ) )\n@@ -275,2 +275,2 @@\n-#define FT_NEXT_ULONG_LE( buffer )                        \\\n-          ( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) )\n+#define FT_NEXT_ULONG_LE( buffer )                                           \\\n+          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )\n@@ -310,11 +310,11 @@\n-#define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetUShort, FT_Int16 )\n-#define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetUShort, FT_UInt16 )\n-#define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetUOffset, FT_UInt32 )\n-#define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetULong, FT_Int32 )\n-#define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetULong, FT_UInt32 )\n-#define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetULong, FT_UInt32 )\n-\n-#define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetUShortLE, FT_Int16 )\n-#define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UInt16 )\n-#define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Int32 )\n-#define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_UInt32 )\n+#define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetUShort, FT_Short )\n+#define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetUShort, FT_UShort )\n+#define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetUOffset, FT_ULong )\n+#define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetULong, FT_Long )\n+#define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )\n+#define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )\n+\n+#define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetUShortLE, FT_Short )\n+#define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UShort )\n+#define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Long )\n+#define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_ULong )\n@@ -337,5 +337,5 @@\n-#define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Int16, var )\n-#define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UInt16, var )\n-#define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadUOffset, FT_UInt32, var )\n-#define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadULong, FT_Int32, var )\n-#define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadULong, FT_UInt32, var )\n+#define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Short, var )\n+#define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UShort, var )\n+#define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadUOffset, FT_ULong, var )\n+#define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadULong, FT_Long, var )\n+#define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadULong, FT_ULong, var )\n@@ -343,4 +343,4 @@\n-#define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_Int16, var )\n-#define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_UInt16, var )\n-#define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadULongLE, FT_Int32, var )\n-#define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadULongLE, FT_UInt32, var )\n+#define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_Short, var )\n+#define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_UShort, var )\n+#define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadULongLE, FT_Long, var )\n+#define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadULongLE, FT_ULong, var )\n@@ -462,1 +462,1 @@\n-  FT_BASE( FT_UInt16 )\n+  FT_BASE( FT_UShort )\n@@ -466,1 +466,1 @@\n-  FT_BASE( FT_UInt32 )\n+  FT_BASE( FT_ULong )\n@@ -470,1 +470,1 @@\n-  FT_BASE( FT_UInt32 )\n+  FT_BASE( FT_ULong )\n@@ -474,1 +474,1 @@\n-  FT_BASE( FT_UInt16 )\n+  FT_BASE( FT_UShort )\n@@ -478,1 +478,1 @@\n-  FT_BASE( FT_UInt32 )\n+  FT_BASE( FT_ULong )\n@@ -488,1 +488,1 @@\n-  FT_BASE( FT_UInt16 )\n+  FT_BASE( FT_UShort )\n@@ -498,1 +498,1 @@\n-  FT_BASE( FT_UInt32 )\n+  FT_BASE( FT_ULong )\n@@ -503,1 +503,1 @@\n-  FT_BASE( FT_UInt16 )\n+  FT_BASE( FT_UShort )\n@@ -508,1 +508,1 @@\n-  FT_BASE( FT_UInt32 )\n+  FT_BASE( FT_ULong )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftstream.h","additions":54,"deletions":54,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/fttrace.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftvalid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -135,0 +135,3 @@\n+   *   num_elems ::\n+   *     The current number of elements in table.\n+   *\n@@ -155,0 +158,1 @@\n+    FT_Int             num_elems;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/psaux.h","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n@@ -297,1 +297,1 @@\n-   *   output, they are in 1\/64 of pixels.\n+   *   output, they are in 1\/64th of pixels.\n@@ -610,1 +610,1 @@\n-   *   output, they are in 1\/64 of pixels.\n+   *   output, they are in 1\/64th of pixels.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/pshints.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svbdf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svcfftl.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svcid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svfntfmt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svgldict.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svgxval.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svkern.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2016-2023 by\n+ * Copyright (C) 2016-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svmetric.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (C) 2003-2023 by\n- * David Turner, Robert Wilhelm, Werner Lemberg, and Dominik Röttsches.\n+ * Copyright (C) 2003-2022 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n@@ -22,1 +22,0 @@\n-#include <freetype\/ftmm.h>\n@@ -24,1 +23,0 @@\n-#include <freetype\/internal\/ftmmtypes.h>\n@@ -101,26 +99,0 @@\n-  typedef FT_Error\n-  (*FT_Var_Load_Delta_Set_Idx_Map_Func)( FT_Face            face,\n-                                         FT_ULong           offset,\n-                                         GX_DeltaSetIdxMap  map,\n-                                         GX_ItemVarStore    itemStore,\n-                                         FT_ULong           table_len );\n-\n-  typedef FT_Error\n-  (*FT_Var_Load_Item_Var_Store_Func)( FT_Face          face,\n-                                      FT_ULong         offset,\n-                                      GX_ItemVarStore  itemStore );\n-\n-  typedef FT_ItemVarDelta\n-  (*FT_Var_Get_Item_Delta_Func)( FT_Face          face,\n-                                 GX_ItemVarStore  itemStore,\n-                                 FT_UInt          outerIndex,\n-                                 FT_UInt          innerIndex );\n-\n-  typedef void\n-  (*FT_Var_Done_Item_Var_Store_Func)( FT_Face          face,\n-                                      GX_ItemVarStore  itemStore );\n-\n-  typedef void\n-  (*FT_Var_Done_Delta_Set_Idx_Map_Func)( FT_Face            face,\n-                                         GX_DeltaSetIdxMap  deltaSetIdxMap );\n-\n@@ -130,10 +102,10 @@\n-    FT_Get_MM_Func                        get_mm;\n-    FT_Set_MM_Design_Func                 set_mm_design;\n-    FT_Set_MM_Blend_Func                  set_mm_blend;\n-    FT_Get_MM_Blend_Func                  get_mm_blend;\n-    FT_Get_MM_Var_Func                    get_mm_var;\n-    FT_Set_Var_Design_Func                set_var_design;\n-    FT_Get_Var_Design_Func                get_var_design;\n-    FT_Set_Instance_Func                  set_instance;\n-    FT_Set_MM_WeightVector_Func           set_mm_weightvector;\n-    FT_Get_MM_WeightVector_Func           get_mm_weightvector;\n+    FT_Get_MM_Func               get_mm;\n+    FT_Set_MM_Design_Func        set_mm_design;\n+    FT_Set_MM_Blend_Func         set_mm_blend;\n+    FT_Get_MM_Blend_Func         get_mm_blend;\n+    FT_Get_MM_Var_Func           get_mm_var;\n+    FT_Set_Var_Design_Func       set_var_design;\n+    FT_Get_Var_Design_Func       get_var_design;\n+    FT_Set_Instance_Func         set_instance;\n+    FT_Set_MM_WeightVector_Func  set_mm_weightvector;\n+    FT_Get_MM_WeightVector_Func  get_mm_weightvector;\n@@ -142,7 +114,2 @@\n-    FT_Var_Load_Delta_Set_Idx_Map_Func    load_delta_set_idx_map;\n-    FT_Var_Load_Item_Var_Store_Func       load_item_var_store;\n-    FT_Var_Get_Item_Delta_Func            get_item_delta;\n-    FT_Var_Done_Item_Var_Store_Func       done_item_var_store;\n-    FT_Var_Done_Delta_Set_Idx_Map_Func    done_delta_set_idx_map;\n-    FT_Get_Var_Blend_Func                 get_var_blend;\n-    FT_Done_Blend_Func                    done_blend;\n+    FT_Get_Var_Blend_Func  get_var_blend;\n+    FT_Done_Blend_Func     done_blend;\n@@ -152,37 +119,27 @@\n-#define FT_DEFINE_SERVICE_MULTIMASTERSREC( class_,                  \\\n-                                           get_mm_,                 \\\n-                                           set_mm_design_,          \\\n-                                           set_mm_blend_,           \\\n-                                           get_mm_blend_,           \\\n-                                           get_mm_var_,             \\\n-                                           set_var_design_,         \\\n-                                           get_var_design_,         \\\n-                                           set_instance_,           \\\n-                                           set_weightvector_,       \\\n-                                           get_weightvector_,       \\\n-                                           load_delta_set_idx_map_, \\\n-                                           load_item_var_store_,    \\\n-                                           get_item_delta_,         \\\n-                                           done_item_var_store_,    \\\n-                                           done_delta_set_idx_map_, \\\n-                                           get_var_blend_,          \\\n-                                           done_blend_ )            \\\n-  static const FT_Service_MultiMastersRec  class_ =                 \\\n-  {                                                                 \\\n-    get_mm_,                                                        \\\n-    set_mm_design_,                                                 \\\n-    set_mm_blend_,                                                  \\\n-    get_mm_blend_,                                                  \\\n-    get_mm_var_,                                                    \\\n-    set_var_design_,                                                \\\n-    get_var_design_,                                                \\\n-    set_instance_,                                                  \\\n-    set_weightvector_,                                              \\\n-    get_weightvector_,                                              \\\n-    load_delta_set_idx_map_,                                        \\\n-    load_item_var_store_,                                           \\\n-    get_item_delta_,                                                \\\n-    done_item_var_store_,                                           \\\n-    done_delta_set_idx_map_,                                        \\\n-    get_var_blend_,                                                 \\\n-    done_blend_                                                     \\\n+#define FT_DEFINE_SERVICE_MULTIMASTERSREC( class_,            \\\n+                                           get_mm_,           \\\n+                                           set_mm_design_,    \\\n+                                           set_mm_blend_,     \\\n+                                           get_mm_blend_,     \\\n+                                           get_mm_var_,       \\\n+                                           set_var_design_,   \\\n+                                           get_var_design_,   \\\n+                                           set_instance_,     \\\n+                                           set_weightvector_, \\\n+                                           get_weightvector_, \\\n+                                           get_var_blend_,    \\\n+                                           done_blend_ )      \\\n+  static const FT_Service_MultiMastersRec  class_ =           \\\n+  {                                                           \\\n+    get_mm_,                                                  \\\n+    set_mm_design_,                                           \\\n+    set_mm_blend_,                                            \\\n+    get_mm_blend_,                                            \\\n+    get_mm_var_,                                              \\\n+    set_var_design_,                                          \\\n+    get_var_design_,                                          \\\n+    set_instance_,                                            \\\n+    set_weightvector_,                                        \\\n+    get_weightvector_,                                        \\\n+    get_var_blend_,                                           \\\n+    done_blend_                                               \\\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svmm.h","additions":41,"deletions":84,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svotval.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpfr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpostnm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2012-2023 by\n+ * Copyright (C) 2012-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svprop.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpscmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpsinfo.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svsfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svttcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svtteng.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svttglyf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svwinfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/sfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2022-2023 by\n+ * Copyright (C) 2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/svginterface.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -175,2 +175,2 @@\n-    FT_Fixed       Ascender;     \/* optional, mind the zero *\/\n-    FT_Fixed       Descender;    \/* optional, mind the zero *\/\n+    FT_Fixed       Ascender;\n+    FT_Fixed       Descender;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/t1types.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/tttypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/wofftypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2022-2023 by\n+ * Copyright (C) 2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/otsvg.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/t1tables.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ttnameid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -427,2 +427,2 @@\n-    FT_UShort  usLowerOpticalPointSize;       \/* in twips (1\/20 points) *\/\n-    FT_UShort  usUpperOpticalPointSize;       \/* in twips (1\/20 points) *\/\n+    FT_UShort  usLowerOpticalPointSize;       \/* in twips (1\/20th points) *\/\n+    FT_UShort  usUpperOpticalPointSize;       \/* in twips (1\/20th points) *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/tttables.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/tttags.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/ft2build.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.cin","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-\/\/ Copyright (C) 2013-2023 by\n+\/\/ Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.dat","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.hin","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n@@ -653,1 +653,1 @@\n-    face->charmap = oldmap;\n+    FT_Set_Charmap( face, oldmap );\n@@ -744,2 +744,1 @@\n-                    (double)blue->ref.cur \/ 64,\n-                    (double)blue->ref.fit \/ 64 ));\n+                    blue->ref.cur \/ 64.0, blue->ref.fit \/ 64.0 ));\n@@ -747,2 +746,1 @@\n-                    (double)blue->shoot.cur \/ 64,\n-                    (double)blue->shoot.fit \/ 64 ));\n+                    blue->shoot.cur \/ 64.0, blue->shoot.fit \/ 64.0 ));\n@@ -1049,1 +1047,1 @@\n-      FT_UInt  ee;\n+      FT_Int   ee;\n@@ -1634,4 +1632,2 @@\n-                (double)stem_edge->opos \/ 64,\n-                (double)stem_edge->pos \/ 64,\n-                (double)dist \/ 64,\n-                (double)fitted_width \/ 64 ));\n+                stem_edge->opos \/ 64.0, stem_edge->pos \/ 64.0,\n+                dist \/ 64.0, fitted_width \/ 64.0 ));\n@@ -1857,2 +1853,2 @@\n-                    edge1 - edges, edge1->fpos, (double)edge1->opos \/ 64,\n-                    (double)blue->fit \/ 64, (double)edge1->pos \/ 64 ));\n+                    edge1 - edges, edge1->fpos, edge1->opos \/ 64.0,\n+                    blue->fit \/ 64.0, edge1->pos \/ 64.0 ));\n@@ -2031,2 +2027,2 @@\n-               (double)( edge->pos - edge->opos ) \/ 64,\n-               (double)( edge2->pos - edge2->opos ) \/ 64 );\n+               ( edge->pos - edge->opos ) \/ 64.0,\n+               ( edge2->pos - edge2->opos ) \/ 64.0 );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcjk.c","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcjk.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcover.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afdummy.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afdummy.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2023 by\n+ * Copyright (C) 2005-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aferrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -132,2 +132,1 @@\n-    FT_UShort   ss;\n-    FT_UShort   dflt        = 0xFFFFU; \/* a non-valid value *\/\n+    FT_UInt     ss;\n@@ -135,0 +134,1 @@\n+    FT_UInt     dflt        = ~0U; \/* a non-valid value *\/\n@@ -138,1 +138,1 @@\n-    for ( i = 0; i < globals->glyph_count; i++ )\n+    for ( i = 0; i < (FT_UInt)globals->glyph_count; i++ )\n@@ -171,1 +171,2 @@\n-        if ( style_class->script == globals->module->default_script )\n+        if ( (FT_UInt)style_class->script ==\n+             globals->module->default_script )\n@@ -185,1 +186,1 @@\n-               gindex < globals->glyph_count                              &&\n+               gindex < (FT_ULong)globals->glyph_count                    &&\n@@ -187,1 +188,1 @@\n-            gstyles[gindex] = ss;\n+            gstyles[gindex] = (FT_UShort)ss;\n@@ -196,1 +197,1 @@\n-            if ( gindex < globals->glyph_count                              &&\n+            if ( gindex < (FT_ULong)globals->glyph_count                    &&\n@@ -198,1 +199,1 @@\n-              gstyles[gindex] = ss;\n+              gstyles[gindex] = (FT_UShort)ss;\n@@ -213,3 +214,3 @@\n-          if ( gindex != 0                               &&\n-               gindex < globals->glyph_count             &&\n-               ( gstyles[gindex] & AF_STYLE_MASK ) == ss )\n+          if ( gindex != 0                                          &&\n+               gindex < (FT_ULong)globals->glyph_count              &&\n+               ( gstyles[gindex] & AF_STYLE_MASK ) == (FT_UShort)ss )\n@@ -225,2 +226,2 @@\n-            if ( gindex < globals->glyph_count             &&\n-                 ( gstyles[gindex] & AF_STYLE_MASK ) == ss )\n+            if ( gindex < (FT_ULong)globals->glyph_count              &&\n+                 ( gstyles[gindex] & AF_STYLE_MASK ) == (FT_UShort)ss )\n@@ -257,1 +258,1 @@\n-      if ( gindex != 0 && gindex < globals->glyph_count )\n+      if ( gindex != 0 && gindex < (FT_ULong)globals->glyph_count )\n@@ -268,1 +269,1 @@\n-      FT_UInt  nn;\n+      FT_Long  nn;\n@@ -292,1 +293,1 @@\n-      FT_UInt        idx;\n+      FT_Long        idx;\n@@ -304,1 +305,1 @@\n-          FT_TRACE4(( \" %d\", idx ));\n+          FT_TRACE4(( \" %ld\", idx ));\n@@ -320,1 +321,1 @@\n-    face->charmap = old_charmap;\n+    FT_Set_Charmap( face, old_charmap );\n@@ -347,1 +348,1 @@\n-    globals->glyph_count               = (FT_UInt)face->num_glyphs;\n+    globals->glyph_count               = face->num_glyphs;\n@@ -359,1 +360,1 @@\n-    globals->hb_font = hb_ft_font_create_( face, NULL );\n+    globals->hb_font = hb_ft_font_create( face, NULL );\n@@ -431,1 +432,1 @@\n-    if ( gindex >= globals->glyph_count )\n+    if ( gindex >= (FT_ULong)globals->glyph_count )\n@@ -503,1 +504,1 @@\n-    if ( gindex < globals->glyph_count )\n+    if ( gindex < (FT_ULong)globals->glyph_count )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afglobal.c","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -108,1 +108,1 @@\n-    FT_UInt          glyph_count;    \/* unsigned face->num_glyphs *\/\n+    FT_Long          glyph_count;    \/* same as face->num_glyphs *\/\n@@ -161,1 +161,1 @@\n-  FT_LOCAL( FT_Bool )\n+  FT_LOCAL_DEF( FT_Bool )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afglobal.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -154,3 +154,3 @@\n-      FT_UInt  old_max = axis->max_segments;\n-      FT_UInt  new_max = old_max;\n-      FT_UInt  big_max = FT_INT_MAX \/ sizeof ( *segment );\n+      FT_Int  old_max = axis->max_segments;\n+      FT_Int  new_max = old_max;\n+      FT_Int  big_max = (FT_Int)( FT_INT_MAX \/ sizeof ( *segment ) );\n@@ -196,1 +196,1 @@\n-  FT_LOCAL_DEF( FT_Error )\n+  FT_LOCAL( FT_Error )\n@@ -219,3 +219,3 @@\n-      FT_UInt  old_max = axis->max_edges;\n-      FT_UInt  new_max = old_max;\n-      FT_UInt  big_max = FT_INT_MAX \/ sizeof ( *edge );\n+      FT_Int  old_max = axis->max_edges;\n+      FT_Int  new_max = old_max;\n+      FT_Int  big_max = (FT_Int)( FT_INT_MAX \/ sizeof ( *edge ) );\n@@ -474,4 +474,4 @@\n-                (double)point->ox \/ 64,\n-                (double)point->oy \/ 64,\n-                (double)point->x \/ 64,\n-                (double)point->y \/ 64,\n+                point->ox \/ 64.0,\n+                point->oy \/ 64.0,\n+                point->x \/ 64.0,\n+                point->y \/ 64.0,\n@@ -600,1 +600,1 @@\n-                                   FT_UInt*       num_segments )\n+                                   FT_Int*        num_segments )\n@@ -626,1 +626,1 @@\n-                                     FT_UInt        idx,\n+                                     FT_Int         idx,\n@@ -643,1 +643,1 @@\n-    if ( idx >= axis->num_segments )\n+    if ( idx < 0 || idx >= axis->num_segments )\n@@ -695,2 +695,2 @@\n-                  65536 * 64 \/ (double)hints->x_scale,\n-                  10 * (double)hints->x_scale \/ 65536 \/ 64 ));\n+                  65536.0 * 64.0 \/ hints->x_scale,\n+                  10.0 * hints->x_scale \/ 65536.0 \/ 64.0 ));\n@@ -700,2 +700,2 @@\n-                  65536 * 64 \/ (double)hints->y_scale,\n-                  10 * (double)hints->y_scale \/ 65536 \/ 64 ));\n+                  65536.0 * 64.0 \/ hints->y_scale,\n+                  10.0 * hints->y_scale \/ 65536.0 \/ 64.0 ));\n@@ -717,1 +717,1 @@\n-                  (double)(int)edge->opos \/ 64,\n+                  (int)edge->opos \/ 64.0,\n@@ -723,2 +723,2 @@\n-                  (double)edge->opos \/ 64,\n-                  (double)edge->pos \/ 64,\n+                  edge->opos \/ 64.0,\n+                  edge->pos \/ 64.0,\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afhints.c","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -24,0 +24,2 @@\n+#define xxAF_SORT_SEGMENTS\n+\n@@ -311,2 +313,2 @@\n-    FT_UInt       num_segments; \/* number of used segments      *\/\n-    FT_UInt       max_segments; \/* number of allocated segments *\/\n+    FT_Int        num_segments; \/* number of used segments      *\/\n+    FT_Int        max_segments; \/* number of allocated segments *\/\n@@ -314,0 +316,3 @@\n+#ifdef AF_SORT_SEGMENTS\n+    FT_Int        mid_segments;\n+#endif\n@@ -315,2 +320,2 @@\n-    FT_UInt       num_edges;    \/* number of used edges      *\/\n-    FT_UInt       max_edges;    \/* number of allocated edges *\/\n+    FT_Int        num_edges;    \/* number of used edges      *\/\n+    FT_Int        max_edges;    \/* number of allocated edges *\/\n@@ -378,1 +383,1 @@\n-          ( !af_debug_disable_horz_hints_                            && \\\n+          ( !_af_debug_disable_horz_hints                            && \\\n@@ -382,1 +387,1 @@\n-          ( !af_debug_disable_vert_hints_                          && \\\n+          ( !_af_debug_disable_vert_hints                          && \\\n@@ -385,1 +390,1 @@\n-#define AF_HINTS_DO_BLUES( h )  ( !af_debug_disable_blue_hints_ )\n+#define AF_HINTS_DO_BLUES( h )  ( !_af_debug_disable_blue_hints )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afhints.h","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n@@ -52,1 +52,2 @@\n-    face->charmap = oldmap;\n+    FT_Set_Charmap( face, oldmap );\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afindic.c","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afindic.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -1046,1 +1046,1 @@\n-      FT_UInt  i;\n+      FT_Long  i;\n@@ -1160,1 +1160,1 @@\n-    face->charmap = oldmap;\n+    FT_Set_Charmap( face, oldmap );\n@@ -1278,2 +1278,2 @@\n-                          (double)scale \/ 65536,\n-                          (double)new_scale \/ 65536,\n+                          scale \/ 65536.0,\n+                          new_scale \/ 65536.0,\n@@ -1330,1 +1330,1 @@\n-                  (double)width->cur \/ 64 ));\n+                  width->cur \/ 64.0 ));\n@@ -1474,1 +1474,1 @@\n-                    (double)blue->ref.fit \/ 64,\n+                    blue->ref.fit \/ 64.0,\n@@ -1480,1 +1480,1 @@\n-                    (double)blue->shoot.fit \/ 64,\n+                    blue->shoot.fit \/ 64.0,\n@@ -2206,1 +2206,1 @@\n-      FT_UInt  ee;\n+      FT_Int   ee;\n@@ -2280,1 +2280,1 @@\n-      FT_UInt  ee;\n+      FT_Int   ee;\n@@ -2958,3 +2958,2 @@\n-                stem_edge - hints->axis[dim].edges,\n-                (double)stem_edge->opos \/ 64, (double)stem_edge->pos \/ 64,\n-                (double)dist \/ 64, (double)fitted_width \/ 64 ));\n+                stem_edge - hints->axis[dim].edges, stem_edge->opos \/ 64.0,\n+                stem_edge->pos \/ 64.0, dist \/ 64.0, fitted_width \/ 64.0 ));\n@@ -3083,3 +3082,2 @@\n-                      edge1 - edges,\n-                      (double)edge1->opos \/ 64, (double)blue->fit \/ 64,\n-                      (double)edge1->pos \/ 64, edge - edges ));\n+                      edge1 - edges, edge1->opos \/ 64.0, blue->fit \/ 64.0,\n+                      edge1->pos \/ 64.0, edge - edges ));\n@@ -3089,3 +3087,2 @@\n-                      edge1 - edges,\n-                      (double)edge1->opos \/ 64, (double)blue->fit \/ 64,\n-                      (double)edge1->pos \/ 64 ));\n+                      edge1 - edges, edge1->opos \/ 64.0, blue->fit \/ 64.0,\n+                      edge1->pos \/ 64.0 ));\n@@ -3207,3 +3204,3 @@\n-                    edge - edges, (double)edge->opos \/ 64,\n-                    edge2 - edges, (double)edge2->opos \/ 64,\n-                    (double)edge->pos \/ 64, (double)edge2->pos \/ 64 ));\n+                    edge - edges, edge->opos \/ 64.0,\n+                    edge2 - edges, edge2->opos \/ 64.0,\n+                    edge->pos \/ 64.0, edge2->pos \/ 64.0 ));\n@@ -3235,2 +3232,2 @@\n-                      edge - edges, (double)edge->pos \/ 64,\n-                      (double)( edge2->pos - cur_len ) \/ 64 ));\n+                      edge - edges, edge->pos \/ 64.0,\n+                      ( edge2->pos - cur_len ) \/ 64.0 ));\n@@ -3277,3 +3274,3 @@\n-                      edge - edges, (double)edge->opos \/ 64,\n-                      edge2 - edges, (double)edge2->opos \/ 64,\n-                      (double)edge->pos \/ 64, (double)edge2->pos \/ 64 ));\n+                      edge - edges, edge->opos \/ 64.0,\n+                      edge2 - edges, edge2->opos \/ 64.0,\n+                      edge->pos \/ 64.0, edge2->pos \/ 64.0 ));\n@@ -3308,3 +3305,3 @@\n-                      edge - edges, (double)edge->opos \/ 64,\n-                      edge2 - edges, (double)edge2->opos \/ 64,\n-                      (double)edge->pos \/ 64, (double)edge2->pos \/ 64 ));\n+                      edge - edges, edge->opos \/ 64.0,\n+                      edge2 - edges, edge2->opos \/ 64.0,\n+                      edge->pos \/ 64.0, edge2->pos \/ 64.0 ));\n@@ -3331,2 +3328,2 @@\n-                        (double)edge->pos \/ 64,\n-                        (double)edge[-1].pos \/ 64 ));\n+                        edge->pos \/ 64.0,\n+                        edge[-1].pos \/ 64.0 ));\n@@ -3433,3 +3430,3 @@\n-                      edge - edges, (double)edge->opos \/ 64,\n-                      edge->serif - edges, (double)edge->serif->opos \/ 64,\n-                      (double)edge->pos \/ 64 ));\n+                      edge - edges, edge->opos \/ 64.0,\n+                      edge->serif - edges, edge->serif->opos \/ 64.0,\n+                      edge->pos \/ 64.0 ));\n@@ -3443,2 +3440,1 @@\n-                      edge-edges,\n-                      (double)edge->opos \/ 64, (double)edge->pos \/ 64 ));\n+                      edge-edges, edge->opos \/ 64.0, edge->pos \/ 64.0 ));\n@@ -3472,3 +3468,3 @@\n-                        edge - edges, (double)edge->opos \/ 64,\n-                        (double)edge->pos \/ 64,\n-                        before - edges, (double)before->opos \/ 64 ));\n+                        edge - edges, edge->opos \/ 64.0,\n+                        edge->pos \/ 64.0,\n+                        before - edges, before->opos \/ 64.0 ));\n@@ -3482,2 +3478,1 @@\n-                        edge - edges,\n-                        (double)edge->opos \/ 64, (double)edge->pos \/ 64 ));\n+                        edge - edges, edge->opos \/ 64.0, edge->pos \/ 64.0 ));\n@@ -3503,2 +3498,2 @@\n-                        (double)edge->pos \/ 64,\n-                        (double)edge[-1].pos \/ 64 ));\n+                        edge->pos \/ 64.0,\n+                        edge[-1].pos \/ 64.0 ));\n@@ -3524,2 +3519,2 @@\n-                        (double)edge->pos \/ 64,\n-                        (double)edge[1].pos \/ 64 ));\n+                        edge->pos \/ 64.0,\n+                        edge[1].pos \/ 64.0 ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aflatin.c","additions":41,"deletions":46,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aflatin.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -232,0 +232,3 @@\n+    if ( !size )\n+      return FT_THROW( Invalid_Size_Handle );\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afloader.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -78,1 +78,1 @@\n-  FT_LOCAL( FT_Fixed )\n+  FT_LOCAL_DEF( FT_Fixed )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afloader.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -46,3 +46,3 @@\n-  int  af_debug_disable_horz_hints_;\n-  int  af_debug_disable_vert_hints_;\n-  int  af_debug_disable_blue_hints_;\n+  int  _af_debug_disable_horz_hints;\n+  int  _af_debug_disable_vert_hints;\n+  int  _af_debug_disable_blue_hints;\n@@ -51,1 +51,1 @@\n-  static AF_GlyphHintsRec  af_debug_hints_rec_[1];\n+  static AF_GlyphHintsRec  _af_debug_hints_rec[1];\n@@ -53,1 +53,1 @@\n-  void*  af_debug_hints_ = af_debug_hints_rec_;\n+  void*  _af_debug_hints = _af_debug_hints_rec;\n@@ -122,2 +122,2 @@\n-      AF_Script*  fallback_script;\n-      FT_UInt     ss;\n+      FT_UInt*  fallback_script;\n+      FT_UInt   ss;\n@@ -131,1 +131,1 @@\n-      fallback_script = (AF_Script*)value;\n+      fallback_script = (FT_UInt*)value;\n@@ -141,2 +141,2 @@\n-        if ( style_class->script   == *fallback_script    &&\n-             style_class->coverage == AF_COVERAGE_DEFAULT )\n+        if ( (FT_UInt)style_class->script == *fallback_script &&\n+             style_class->coverage == AF_COVERAGE_DEFAULT     )\n@@ -160,1 +160,1 @@\n-      AF_Script*  default_script;\n+      FT_UInt*  default_script;\n@@ -168,1 +168,1 @@\n-      default_script = (AF_Script*)value;\n+      default_script = (FT_UInt*)value;\n@@ -294,0 +294,2 @@\n+    FT_UInt    fallback_style = module->fallback_style;\n+    FT_UInt    default_script = module->default_script;\n@@ -310,1 +312,1 @@\n-      AF_Script*  val = (AF_Script*)value;\n+      FT_UInt*  val = (FT_UInt*)value;\n@@ -312,1 +314,1 @@\n-      AF_StyleClass  style_class = af_style_classes[module->fallback_style];\n+      AF_StyleClass  style_class = af_style_classes[fallback_style];\n@@ -321,1 +323,1 @@\n-      AF_Script*  val = (AF_Script*)value;\n+      FT_UInt*  val = (FT_UInt*)value;\n@@ -324,1 +326,1 @@\n-      *val = module->default_script;\n+      *val = default_script;\n@@ -426,2 +428,2 @@\n-    if ( af_debug_hints_rec_->memory )\n-      af_glyph_hints_done( af_debug_hints_rec_ );\n+    if ( _af_debug_hints_rec->memory )\n+      af_glyph_hints_done( _af_debug_hints_rec );\n@@ -446,1 +448,1 @@\n-    AF_GlyphHints  hints = af_debug_hints_rec_;\n+    AF_GlyphHints  hints = _af_debug_hints_rec;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afmodule.c","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -39,1 +39,1 @@\n-    AF_Script     default_script;\n+    FT_UInt       default_script;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afmodule.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afranges.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afranges.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afscript.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afshaper.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n@@ -30,1 +30,1 @@\n-#include \"ft-hb.h\"\n+#include <hb-ft.h>\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afshaper.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afstyles.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n@@ -60,4 +60,4 @@\n-extern int    af_debug_disable_horz_hints_;\n-extern int    af_debug_disable_vert_hints_;\n-extern int    af_debug_disable_blue_hints_;\n-extern void*  af_debug_hints_;\n+extern int    _af_debug_disable_horz_hints;\n+extern int    _af_debug_disable_vert_hints;\n+extern int    _af_debug_disable_blue_hints;\n+extern void*  _af_debug_hints;\n@@ -122,7 +122,7 @@\n-    FT_Face         face;        \/* source font face                      *\/\n-    FT_Fixed        x_scale;     \/* from font units to 1\/64 device pixels *\/\n-    FT_Fixed        y_scale;     \/* from font units to 1\/64 device pixels *\/\n-    FT_Pos          x_delta;     \/* in 1\/64 device pixels                 *\/\n-    FT_Pos          y_delta;     \/* in 1\/64 device pixels                 *\/\n-    FT_Render_Mode  render_mode; \/* monochrome, anti-aliased, LCD, etc.   *\/\n-    FT_UInt32       flags;       \/* additional control flags, see above   *\/\n+    FT_Face         face;        \/* source font face                        *\/\n+    FT_Fixed        x_scale;     \/* from font units to 1\/64th device pixels *\/\n+    FT_Fixed        y_scale;     \/* from font units to 1\/64th device pixels *\/\n+    FT_Pos          x_delta;     \/* in 1\/64th device pixels                 *\/\n+    FT_Pos          y_delta;     \/* in 1\/64th device pixels                 *\/\n+    FT_Render_Mode  render_mode; \/* monochrome, anti-aliased, LCD, etc.     *\/\n+    FT_UInt32       flags;       \/* additional control flags, see above     *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aftypes.h","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afws-decl.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afws-iter.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2023 by\n+ * Copyright (C) 2008-2022 by\n@@ -26,1 +26,1 @@\n-  ft_face_scale_advances_( FT_Face    face,\n+  _ft_face_scale_advances( FT_Face    face,\n@@ -99,1 +99,1 @@\n-        return ft_face_scale_advances_( face, padvance, 1, flags );\n+        return _ft_face_scale_advances( face, padvance, 1, flags );\n@@ -145,1 +145,1 @@\n-        return ft_face_scale_advances_( face, padvances, count, flags );\n+        return _ft_face_scale_advances( face, padvances, count, flags );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftadvanc.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2023 by\n+ * Copyright (C) 2008-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbase.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbbox.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n@@ -69,2 +69,5 @@\n-    FT_Int     pitch;\n-    FT_Int     flip;\n+\n+    FT_Int    pitch;\n+    FT_ULong  size;\n+\n+    FT_Int  source_pitch_sign, target_pitch_sign;\n@@ -82,10 +85,2 @@\n-    flip = ( source->pitch < 0 && target->pitch > 0 ) ||\n-           ( source->pitch > 0 && target->pitch < 0 );\n-\n-    memory = library->memory;\n-    FT_FREE( target->buffer );\n-\n-    *target = *source;\n-\n-    if ( flip )\n-      target->pitch = -target->pitch;\n+    source_pitch_sign = source->pitch < 0 ? -1 : 1;\n+    target_pitch_sign = target->pitch < 0 ? -1 : 1;\n@@ -94,0 +89,5 @@\n+    {\n+      *target = *source;\n+      if ( source_pitch_sign != target_pitch_sign )\n+        target->pitch = -target->pitch;\n+\n@@ -95,0 +95,1 @@\n+    }\n@@ -96,0 +97,1 @@\n+    memory = library->memory;\n@@ -97,0 +99,1 @@\n+\n@@ -99,0 +102,6 @@\n+    size = (FT_ULong)pitch * source->rows;\n+\n+    if ( target->buffer )\n+    {\n+      FT_Int    target_pitch = target->pitch;\n+      FT_ULong  target_size;\n@@ -100,1 +109,10 @@\n-    FT_MEM_QALLOC_MULT( target->buffer, target->rows, pitch );\n+\n+      if ( target_pitch < 0 )\n+        target_pitch = -target_pitch;\n+      target_size = (FT_ULong)target_pitch * target->rows;\n+\n+      if ( target_size != size )\n+        FT_MEM_QREALLOC( target->buffer, target_size, size );\n+    }\n+    else\n+      FT_MEM_QALLOC( target->buffer, size );\n@@ -104,1 +122,10 @@\n-      if ( flip )\n+      unsigned char *p;\n+\n+\n+      p = target->buffer;\n+      *target = *source;\n+      target->buffer = p;\n+\n+      if ( source_pitch_sign == target_pitch_sign )\n+        FT_MEM_COPY( target->buffer, source->buffer, size );\n+      else\n@@ -122,3 +149,0 @@\n-      else\n-        FT_MEM_COPY( target->buffer, source->buffer,\n-                     (FT_Long)source->rows * pitch );\n@@ -521,3 +545,2 @@\n-        FT_Int  width = (FT_Int)source->width;\n-        FT_Int  neg   = ( target->pitch == 0 && source->pitch < 0 ) ||\n-                          target->pitch  < 0;\n+        FT_Int    pad, old_target_pitch, target_pitch;\n+        FT_ULong  old_size;\n@@ -526,1 +549,5 @@\n-        FT_Bitmap_Done( library, target );\n+        old_target_pitch = target->pitch;\n+        if ( old_target_pitch < 0 )\n+          old_target_pitch = -old_target_pitch;\n+\n+        old_size = target->rows * (FT_UInt)old_target_pitch;\n@@ -532,1 +559,2 @@\n-        if ( alignment )\n+        pad = 0;\n+        if ( alignment > 0 )\n@@ -534,1 +562,4 @@\n-          FT_Int  rem = width % alignment;\n+          pad = (FT_Int)source->width % alignment;\n+          if ( pad != 0 )\n+            pad = alignment - pad;\n+        }\n@@ -536,0 +567,1 @@\n+        target_pitch = (FT_Int)source->width + pad;\n@@ -537,4 +569,3 @@\n-          if ( rem )\n-            width = alignment > 0 ? width - rem + alignment\n-                                  : width - rem - alignment;\n-        }\n+        if ( target_pitch > 0                                               &&\n+             (FT_ULong)target->rows > FT_ULONG_MAX \/ (FT_ULong)target_pitch )\n+          return FT_THROW( Invalid_Argument );\n@@ -542,1 +573,2 @@\n-        if ( FT_QALLOC_MULT( target->buffer, target->rows, width ) )\n+        if ( FT_QREALLOC( target->buffer,\n+                          old_size, target->rows * (FT_UInt)target_pitch ) )\n@@ -545,1 +577,1 @@\n-        target->pitch = neg ? -width : width;\n+        target->pitch = target->pitch < 0 ? -target_pitch : target_pitch;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbitmap.c","additions":62,"deletions":30,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -1088,67 +1088,0 @@\n-  FT_BASE_DEF( FT_Int32 )\n-  FT_MulAddFix( FT_Fixed*  s,\n-                FT_Int32*  f,\n-                FT_UInt    count )\n-  {\n-    FT_UInt   i;\n-    FT_Int64  temp;\n-#ifndef FT_INT64\n-    FT_Int64  halfUnit;\n-#endif\n-\n-\n-#ifdef FT_INT64\n-    temp = 0;\n-\n-    for ( i = 0; i < count; ++i )\n-      temp += (FT_Int64)s[i] * f[i];\n-\n-    return ( temp + 0x8000 ) >> 16;\n-#else\n-    temp.hi = 0;\n-    temp.lo = 0;\n-\n-    for ( i = 0; i < count; ++i )\n-    {\n-      FT_Int64  multResult;\n-\n-      FT_Int     sign  = 1;\n-      FT_UInt32  carry = 0;\n-\n-      FT_UInt32  scalar;\n-      FT_UInt32  factor;\n-\n-\n-      scalar = (FT_UInt32)s[i];\n-      factor = (FT_UInt32)f[i];\n-\n-      FT_MOVE_SIGN( s[i], scalar, sign );\n-      FT_MOVE_SIGN( f[i], factor, sign );\n-\n-      ft_multo64( scalar, factor, &multResult );\n-\n-      if ( sign < 0 )\n-      {\n-        \/* Emulated `FT_Int64` negation. *\/\n-        carry = ( multResult.lo == 0 );\n-\n-        multResult.lo = ~multResult.lo + 1;\n-        multResult.hi = ~multResult.hi + carry;\n-      }\n-\n-      FT_Add64( &temp, &multResult, &temp );\n-    }\n-\n-    \/* Round value. *\/\n-    halfUnit.hi = 0;\n-    halfUnit.lo = 0x8000;\n-    FT_Add64( &temp, &halfUnit, &temp );\n-\n-    return (FT_Int32)( ( (FT_Int32)( temp.hi & 0xFFFF ) << 16 ) |\n-                                   ( temp.lo >> 16 )            );\n-\n-#endif \/* !FT_INT64 *\/\n-\n-  }\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcalc.c","additions":1,"deletions":68,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcid.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcolor.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n@@ -38,2 +38,2 @@\n-  FT_BASE_DEF( const char* )  ft_debug_file_   = NULL;\n-  FT_BASE_DEF( long )         ft_debug_lineno_ = 0;\n+  FT_BASE_DEF( const char* )  _ft_debug_file   = NULL;\n+  FT_BASE_DEF( long )         _ft_debug_lineno = 0;\n@@ -418,2 +418,2 @@\n-    hash  = (FT_UInt32)(FT_PtrDist)(void*)ft_debug_file_ +\n-              (FT_UInt32)( 5 * ft_debug_lineno_ );\n+    hash  = (FT_UInt32)(FT_PtrDist)(void*)_ft_debug_file +\n+              (FT_UInt32)( 5 * _ft_debug_lineno );\n@@ -428,2 +428,2 @@\n-      if ( node->file_name == ft_debug_file_   &&\n-           node->line_no   == ft_debug_lineno_ )\n+      if ( node->file_name == _ft_debug_file   &&\n+           node->line_no   == _ft_debug_lineno )\n@@ -440,2 +440,2 @@\n-    node->file_name = ft_debug_file_;\n-    node->line_no   = ft_debug_lineno_;\n+    node->file_name = _ft_debug_file;\n+    node->line_no   = _ft_debug_lineno;\n@@ -498,1 +498,1 @@\n-            FT_FILENAME( ft_debug_file_ ), ft_debug_lineno_ );\n+            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );\n@@ -585,1 +585,1 @@\n-            FT_FILENAME( ft_debug_file_ ), ft_debug_lineno_,\n+            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno,\n@@ -607,2 +607,2 @@\n-          node->free_file_name = ft_debug_file_;\n-          node->free_line_no   = ft_debug_lineno_;\n+          node->free_file_name = _ft_debug_file;\n+          node->free_line_no   = _ft_debug_lineno;\n@@ -630,1 +630,1 @@\n-          FT_FILENAME( ft_debug_file_ ), ft_debug_lineno_ );\n+          FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );\n@@ -664,2 +664,2 @@\n-    ft_debug_file_   = \"<unknown>\";\n-    ft_debug_lineno_ = 0;\n+    _ft_debug_file   = \"<unknown>\";\n+    _ft_debug_lineno = 0;\n@@ -680,2 +680,2 @@\n-                          FT_FILENAME( ft_debug_file_ ),\n-                          ft_debug_lineno_ );\n+                          FT_FILENAME( _ft_debug_file ),\n+                          _ft_debug_lineno );\n@@ -690,2 +690,2 @@\n-    ft_debug_file_   = \"<unknown>\";\n-    ft_debug_lineno_ = 0;\n+    _ft_debug_file   = \"<unknown>\";\n+    _ft_debug_lineno = 0;\n@@ -706,2 +706,2 @@\n-    const char*  file_name = FT_FILENAME( ft_debug_file_ );\n-    FT_Long      line_no   = ft_debug_lineno_;\n+    const char*  file_name = FT_FILENAME( _ft_debug_file );\n+    FT_Long      line_no   = _ft_debug_lineno;\n@@ -770,2 +770,2 @@\n-    ft_debug_file_   = \"<unknown>\";\n-    ft_debug_lineno_ = 0;\n+    _ft_debug_file   = \"<unknown>\";\n+    _ft_debug_lineno = 0;\n@@ -877,1 +877,1 @@\n-  FT_COMPARE_DEF( int )\n+  static int\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftdbgmem.c","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftdebug.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftfntfmt.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2023 by\n+ * Copyright (C) 2008-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftfstype.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftgasp.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n@@ -215,1 +215,1 @@\n-    FT_UInt  new_max, old_max, min_new_max;\n+    FT_UInt      new_max, old_max;\n@@ -220,1 +220,1 @@\n-      goto Exit;\n+      return error;\n@@ -229,9 +229,0 @@\n-      if ( new_max > FT_OUTLINE_POINTS_MAX )\n-      {\n-        error = FT_THROW( Array_Too_Large );\n-        goto Exit;\n-      }\n-\n-      min_new_max = old_max + ( old_max >> 1 );\n-      if ( new_max < min_new_max )\n-        new_max = min_new_max;\n@@ -239,0 +230,1 @@\n+\n@@ -240,1 +232,1 @@\n-        new_max = FT_OUTLINE_POINTS_MAX;\n+        return FT_THROW( Array_Too_Large );\n@@ -265,1 +257,1 @@\n-      goto Exit;\n+      return error;\n@@ -273,9 +265,0 @@\n-      if ( new_max > FT_OUTLINE_CONTOURS_MAX )\n-      {\n-        error = FT_THROW( Array_Too_Large );\n-        goto Exit;\n-      }\n-\n-      min_new_max = old_max + ( old_max >> 1 );\n-      if ( new_max < min_new_max )\n-        new_max = min_new_max;\n@@ -283,0 +266,1 @@\n+\n@@ -284,1 +268,1 @@\n-        new_max = FT_OUTLINE_CONTOURS_MAX;\n+        return FT_THROW( Array_Too_Large );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftgloadr.c","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -685,1 +685,0 @@\n-    {\n@@ -687,2 +686,0 @@\n-      *aglyph = NULL;\n-    }\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftglyph.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftinit.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftlcdfil.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -70,1 +70,0 @@\n-#include <freetype\/internal\/ftdebug.h>\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftmac.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftmm.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -511,1 +511,1 @@\n-      FALL_THROUGH;\n+      \/* fall through *\/\n@@ -608,1 +608,1 @@\n-        slot->internal->flags &= ~FT_GLYPH_OWN_GZIP_SVG;\n+        slot->internal->load_flags &= ~FT_GLYPH_OWN_GZIP_SVG;\n@@ -634,3 +634,2 @@\n-      \/* Free memory in case SVG was there.                          *\/\n-      \/* `slot->internal` might be NULL in out-of-memory situations. *\/\n-      if ( slot->internal && slot->internal->flags & FT_GLYPH_OWN_GZIP_SVG )\n+      \/* free memory in case SVG was there *\/\n+      if ( slot->internal->flags & FT_GLYPH_OWN_GZIP_SVG )\n@@ -1188,2 +1187,2 @@\n-    FT_TRACE5(( \"  x advance: %f\\n\", (double)slot->advance.x \/ 64 ));\n-    FT_TRACE5(( \"  y advance: %f\\n\", (double)slot->advance.y \/ 64 ));\n+    FT_TRACE5(( \"  x advance: %f\\n\", slot->advance.x \/ 64.0 ));\n+    FT_TRACE5(( \"  y advance: %f\\n\", slot->advance.y \/ 64.0 ));\n@@ -1191,1 +1190,1 @@\n-                (double)slot->linearHoriAdvance \/ 65536 ));\n+                slot->linearHoriAdvance \/ 65536.0 ));\n@@ -1193,1 +1192,1 @@\n-                (double)slot->linearVertAdvance \/ 65536 ));\n+                slot->linearVertAdvance \/ 65536.0 ));\n@@ -1200,2 +1199,2 @@\n-      FT_TRACE5(( \"    width:  %f\\n\", (double)metrics->width \/ 64 ));\n-      FT_TRACE5(( \"    height: %f\\n\", (double)metrics->height \/ 64 ));\n+      FT_TRACE5(( \"    width:  %f\\n\", metrics->width  \/ 64.0 ));\n+      FT_TRACE5(( \"    height: %f\\n\", metrics->height \/ 64.0 ));\n@@ -1203,6 +1202,3 @@\n-      FT_TRACE5(( \"    horiBearingX: %f\\n\",\n-                  (double)metrics->horiBearingX \/ 64 ));\n-      FT_TRACE5(( \"    horiBearingY: %f\\n\",\n-                  (double)metrics->horiBearingY \/ 64 ));\n-      FT_TRACE5(( \"    horiAdvance:  %f\\n\",\n-                  (double)metrics->horiAdvance \/ 64 ));\n+      FT_TRACE5(( \"    horiBearingX: %f\\n\", metrics->horiBearingX \/ 64.0 ));\n+      FT_TRACE5(( \"    horiBearingY: %f\\n\", metrics->horiBearingY \/ 64.0 ));\n+      FT_TRACE5(( \"    horiAdvance:  %f\\n\", metrics->horiAdvance  \/ 64.0 ));\n@@ -1210,6 +1206,3 @@\n-      FT_TRACE5(( \"    vertBearingX: %f\\n\",\n-                  (double)metrics->vertBearingX \/ 64 ));\n-      FT_TRACE5(( \"    vertBearingY: %f\\n\",\n-                  (double)metrics->vertBearingY \/ 64 ));\n-      FT_TRACE5(( \"    vertAdvance:  %f\\n\",\n-                  (double)metrics->vertAdvance \/ 64 ));\n+      FT_TRACE5(( \"    vertBearingX: %f\\n\", metrics->vertBearingX \/ 64.0 ));\n+      FT_TRACE5(( \"    vertBearingY: %f\\n\", metrics->vertBearingY \/ 64.0 ));\n+      FT_TRACE5(( \"    vertAdvance:  %f\\n\", metrics->vertAdvance  \/ 64.0 ));\n@@ -1498,1 +1491,1 @@\n-             FT_Bool        *anexternal_stream,\n+             FT_Bool        external_stream,\n@@ -1524,1 +1517,1 @@\n-    if ( *anexternal_stream )\n+    if ( external_stream )\n@@ -1554,4 +1547,1 @@\n-    \/* Stream may have been changed. *\/\n-    *astream = face->stream;\n-    *anexternal_stream =\n-      ( face->face_flags & FT_FACE_FLAG_EXTERNAL_STREAM ) != 0;\n+    *astream = face->stream; \/* Stream may have been changed. *\/\n@@ -1681,1 +1671,1 @@\n-    FT_Memory  memory = (FT_Memory)stream->descriptor.pointer;\n+    FT_Memory  memory = stream->memory;\n@@ -1685,0 +1675,1 @@\n+\n@@ -1687,1 +1678,0 @@\n-    FT_FREE( stream );\n@@ -1718,2 +1708,1 @@\n-    stream->descriptor.pointer = memory;\n-    stream->close              = close;\n+    stream->close = close;\n@@ -1740,0 +1729,1 @@\n+    FT_Stream     stream = NULL;\n@@ -1743,15 +1733,0 @@\n-    args.flags = 0;\n-\n-    if ( driver_name )\n-    {\n-      args.driver = FT_Get_Module( library, driver_name );\n-      if ( !args.driver )\n-      {\n-        FT_FREE( base );\n-        return FT_THROW( Missing_Module );\n-      }\n-\n-      args.flags = args.flags | FT_OPEN_DRIVER;\n-    }\n-\n-    \/* `memory_stream_close` also frees the stream object. *\/\n@@ -1762,1 +1737,1 @@\n-                               &args.stream );\n+                               &stream );\n@@ -1769,1 +1744,7 @@\n-    args.flags |= FT_OPEN_STREAM;\n+    args.flags  = FT_OPEN_STREAM;\n+    args.stream = stream;\n+    if ( driver_name )\n+    {\n+      args.flags  = args.flags | FT_OPEN_DRIVER;\n+      args.driver = FT_Get_Module( library, driver_name );\n+    }\n@@ -1781,1 +1762,15 @@\n-    return ft_open_face_internal( library, &args, face_index, aface, 0 );\n+    error = ft_open_face_internal( library, &args, face_index, aface, 0 );\n+\n+    if ( !error )\n+      (*aface)->face_flags &= ~FT_FACE_FLAG_EXTERNAL_STREAM;\n+    else\n+#ifdef FT_MACINTOSH\n+      FT_Stream_Free( stream, 0 );\n+#else\n+    {\n+      FT_Stream_Close( stream );\n+      FT_FREE( stream );\n+    }\n+#endif\n+\n+    return error;\n@@ -1924,1 +1919,1 @@\n-                                   is_sfnt_cid ? \"t1cid\" : \"type1\",\n+                                   is_sfnt_cid ? \"cid\" : \"type1\",\n@@ -2185,1 +2180,1 @@\n-    FT_ULong   rlen;\n+    FT_Long    rlen;\n@@ -2200,1 +2195,1 @@\n-    if ( FT_READ_ULONG( rlen ) )\n+    if ( FT_READ_LONG( rlen ) )\n@@ -2202,1 +2197,1 @@\n-    if ( !rlen )\n+    if ( rlen < 1 )\n@@ -2204,1 +2199,1 @@\n-    if ( rlen > FT_MAC_RFORK_MAX_LEN )\n+    if ( (FT_ULong)rlen > FT_MAC_RFORK_MAX_LEN )\n@@ -2222,3 +2217,2 @@\n-    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_data, rlen );\n-    if ( error )\n-    {\n+    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_data, (FT_ULong)rlen );\n+    if ( error ) {\n@@ -2232,1 +2226,1 @@\n-                                   rlen,\n+                                   (FT_ULong)rlen,\n@@ -2561,1 +2555,1 @@\n-    if ( !args )\n+    if ( ( !aface && face_index >= 0 ) || !args )\n@@ -2572,8 +2566,0 @@\n-    \/* Do this error check after `FT_Stream_New` to ensure that the *\/\n-    \/* 'close' callback is called.                                  *\/\n-    if ( !aface && face_index >= 0 )\n-    {\n-      error = FT_THROW( Invalid_Argument );\n-      goto Fail3;\n-    }\n-\n@@ -2601,1 +2587,1 @@\n-        error = open_face( driver, &stream, &external_stream, face_index,\n+        error = open_face( driver, &stream, external_stream, face_index,\n@@ -2637,1 +2623,1 @@\n-          error = open_face( driver, &stream, &external_stream, face_index,\n+          error = open_face( driver, &stream, external_stream, face_index,\n@@ -2869,2 +2855,2 @@\n-  FT_Attach_Stream( FT_Face              face,\n-                    const FT_Open_Args*  parameters )\n+  FT_Attach_Stream( FT_Face        face,\n+                    FT_Open_Args*  parameters )\n@@ -3295,1 +3281,1 @@\n-      if ( req->height || !req->width )\n+      if ( req->width )\n@@ -3297,6 +3283,1 @@\n-        if ( h == 0 )\n-        {\n-          FT_ERROR(( \"FT_Request_Metrics: Divide by zero\\n\" ));\n-          error = FT_ERR( Divide_By_Zero );\n-          goto Exit;\n-        }\n+        metrics->x_scale = FT_DivFix( scaled_w, w );\n@@ -3304,2 +3285,3 @@\n-        metrics->y_scale = FT_DivFix( scaled_h, h );\n-      }\n+        if ( req->height )\n+        {\n+          metrics->y_scale = FT_DivFix( scaled_h, h );\n@@ -3307,3 +3289,9 @@\n-      if ( req->width )\n-      {\n-        if ( w == 0 )\n+          if ( req->type == FT_SIZE_REQUEST_TYPE_CELL )\n+          {\n+            if ( metrics->y_scale > metrics->x_scale )\n+              metrics->y_scale = metrics->x_scale;\n+            else\n+              metrics->x_scale = metrics->y_scale;\n+          }\n+        }\n+        else\n@@ -3311,3 +3299,2 @@\n-          FT_ERROR(( \"FT_Request_Metrics: Divide by zero\\n\" ));\n-          error = FT_ERR( Divide_By_Zero );\n-          goto Exit;\n+          metrics->y_scale = metrics->x_scale;\n+          scaled_h = FT_MulDiv( scaled_w, h, w );\n@@ -3315,2 +3302,0 @@\n-\n-        metrics->x_scale = FT_DivFix( scaled_w, w );\n@@ -3320,1 +3305,1 @@\n-        metrics->x_scale = metrics->y_scale;\n+        metrics->x_scale = metrics->y_scale = FT_DivFix( scaled_h, h );\n@@ -3324,14 +3309,0 @@\n-      if ( !req->height )\n-      {\n-        metrics->y_scale = metrics->x_scale;\n-        scaled_h = FT_MulDiv( scaled_w, h, w );\n-      }\n-\n-      if ( req->type == FT_SIZE_REQUEST_TYPE_CELL )\n-      {\n-        if ( metrics->y_scale > metrics->x_scale )\n-          metrics->y_scale = metrics->x_scale;\n-        else\n-          metrics->x_scale = metrics->y_scale;\n-      }\n-\n@@ -3411,1 +3382,1 @@\n-                  metrics->x_scale, (double)metrics->x_scale \/ 65536 ));\n+                  metrics->x_scale, metrics->x_scale \/ 65536.0 ));\n@@ -3413,11 +3384,7 @@\n-                  metrics->y_scale, (double)metrics->y_scale \/ 65536 ));\n-      FT_TRACE5(( \"  ascender: %f\\n\",\n-                  (double)metrics->ascender \/ 64 ));\n-      FT_TRACE5(( \"  descender: %f\\n\",\n-                  (double)metrics->descender \/ 64 ));\n-      FT_TRACE5(( \"  height: %f\\n\",\n-                  (double)metrics->height \/ 64 ));\n-      FT_TRACE5(( \"  max advance: %f\\n\",\n-                  (double)metrics->max_advance \/ 64 ));\n-      FT_TRACE5(( \"  x ppem: %d\\n\", metrics->x_ppem ));\n-      FT_TRACE5(( \"  y ppem: %d\\n\", metrics->y_ppem ));\n+                  metrics->y_scale, metrics->y_scale \/ 65536.0 ));\n+      FT_TRACE5(( \"  ascender: %f\\n\",    metrics->ascender \/ 64.0 ));\n+      FT_TRACE5(( \"  descender: %f\\n\",   metrics->descender \/ 64.0 ));\n+      FT_TRACE5(( \"  height: %f\\n\",      metrics->height \/ 64.0 ));\n+      FT_TRACE5(( \"  max advance: %f\\n\", metrics->max_advance \/ 64.0 ));\n+      FT_TRACE5(( \"  x ppem: %d\\n\",      metrics->x_ppem ));\n+      FT_TRACE5(( \"  y ppem: %d\\n\",      metrics->y_ppem ));\n@@ -3495,1 +3462,1 @@\n-                  metrics->x_scale, (double)metrics->x_scale \/ 65536 ));\n+                  metrics->x_scale, metrics->x_scale \/ 65536.0 ));\n@@ -3497,11 +3464,7 @@\n-                  metrics->y_scale, (double)metrics->y_scale \/ 65536 ));\n-      FT_TRACE5(( \"  ascender: %f\\n\",\n-                  (double)metrics->ascender \/ 64 ));\n-      FT_TRACE5(( \"  descender: %f\\n\",\n-                  (double)metrics->descender \/ 64 ));\n-      FT_TRACE5(( \"  height: %f\\n\",\n-                  (double)metrics->height \/ 64 ));\n-      FT_TRACE5(( \"  max advance: %f\\n\",\n-                  (double)metrics->max_advance \/ 64 ));\n-      FT_TRACE5(( \"  x ppem: %d\\n\", metrics->x_ppem ));\n-      FT_TRACE5(( \"  y ppem: %d\\n\", metrics->y_ppem ));\n+                  metrics->y_scale, metrics->y_scale \/ 65536.0 ));\n+      FT_TRACE5(( \"  ascender: %f\\n\",    metrics->ascender \/ 64.0 ));\n+      FT_TRACE5(( \"  descender: %f\\n\",   metrics->descender \/ 64.0 ));\n+      FT_TRACE5(( \"  height: %f\\n\",      metrics->height \/ 64.0 ));\n+      FT_TRACE5(( \"  max advance: %f\\n\", metrics->max_advance \/ 64.0 ));\n+      FT_TRACE5(( \"  x ppem: %d\\n\",      metrics->x_ppem ));\n+      FT_TRACE5(( \"  y ppem: %d\\n\",      metrics->y_ppem ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftobjs.c","additions":93,"deletions":130,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -133,1 +133,1 @@\n-                  (double)v_start.x \/ 64, (double)v_start.y \/ 64 ));\n+                  v_start.x \/ 64.0, v_start.y \/ 64.0 ));\n@@ -155,1 +155,1 @@\n-                        (double)vec.x \/ 64, (double)vec.y \/ 64 ));\n+                        vec.x \/ 64.0, vec.y \/ 64.0 ));\n@@ -184,4 +184,2 @@\n-                          (double)vec.x \/ 64,\n-                          (double)vec.y \/ 64,\n-                          (double)v_control.x \/ 64,\n-                          (double)v_control.y \/ 64 ));\n+                          vec.x \/ 64.0, vec.y \/ 64.0,\n+                          v_control.x \/ 64.0, v_control.y \/ 64.0 ));\n@@ -202,4 +200,2 @@\n-                        (double)v_middle.x \/ 64,\n-                        (double)v_middle.y \/ 64,\n-                        (double)v_control.x \/ 64,\n-                        (double)v_control.y \/ 64 ));\n+                        v_middle.x \/ 64.0, v_middle.y \/ 64.0,\n+                        v_control.x \/ 64.0, v_control.y \/ 64.0 ));\n@@ -216,4 +212,2 @@\n-                      (double)v_start.x \/ 64,\n-                      (double)v_start.y \/ 64,\n-                      (double)v_control.x \/ 64,\n-                      (double)v_control.y \/ 64 ));\n+                      v_start.x \/ 64.0, v_start.y \/ 64.0,\n+                      v_control.x \/ 64.0, v_control.y \/ 64.0 ));\n@@ -251,6 +245,3 @@\n-                          (double)vec.x \/ 64,\n-                          (double)vec.y \/ 64,\n-                          (double)vec1.x \/ 64,\n-                          (double)vec1.y \/ 64,\n-                          (double)vec2.x \/ 64,\n-                          (double)vec2.y \/ 64 ));\n+                          vec.x \/ 64.0, vec.y \/ 64.0,\n+                          vec1.x \/ 64.0, vec1.y \/ 64.0,\n+                          vec2.x \/ 64.0, vec2.y \/ 64.0 ));\n@@ -265,6 +256,3 @@\n-                        (double)v_start.x \/ 64,\n-                        (double)v_start.y \/ 64,\n-                        (double)vec1.x \/ 64,\n-                        (double)vec1.y \/ 64,\n-                        (double)vec2.x \/ 64,\n-                        (double)vec2.y \/ 64 ));\n+                        v_start.x \/ 64.0, v_start.y \/ 64.0,\n+                        vec1.x \/ 64.0, vec1.y \/ 64.0,\n+                        vec2.x \/ 64.0, vec2.y \/ 64.0 ));\n@@ -279,1 +267,1 @@\n-                  (double)v_start.x \/ 64, (double)v_start.y \/ 64 ));\n+                  v_start.x \/ 64.0, v_start.y \/ 64.0 ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftoutln.c","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2007-2023 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftpatent.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftpsprop.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftrfork.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsnames.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n@@ -264,1 +264,1 @@\n-      \/* assume `ft_debug_file_` and `ft_debug_lineno_` are already set *\/\n+      \/* assume _ft_debug_file and _ft_debug_lineno are already set *\/\n@@ -366,1 +366,1 @@\n-  FT_BASE_DEF( FT_UInt16 )\n+  FT_BASE_DEF( FT_UShort )\n@@ -370,1 +370,1 @@\n-    FT_UInt16  result;\n+    FT_UShort  result;\n@@ -385,1 +385,1 @@\n-  FT_BASE_DEF( FT_UInt16 )\n+  FT_BASE_DEF( FT_UShort )\n@@ -389,1 +389,1 @@\n-    FT_UInt16  result;\n+    FT_UShort  result;\n@@ -404,1 +404,1 @@\n-  FT_BASE_DEF( FT_UInt32 )\n+  FT_BASE_DEF( FT_ULong )\n@@ -408,1 +408,1 @@\n-    FT_UInt32 result;\n+    FT_ULong  result;\n@@ -422,1 +422,1 @@\n-  FT_BASE_DEF( FT_UInt32 )\n+  FT_BASE_DEF( FT_ULong )\n@@ -426,1 +426,1 @@\n-    FT_UInt32 result;\n+    FT_ULong  result;\n@@ -440,1 +440,1 @@\n-  FT_BASE_DEF( FT_UInt32 )\n+  FT_BASE_DEF( FT_ULong )\n@@ -444,1 +444,1 @@\n-    FT_UInt32 result;\n+    FT_ULong  result;\n@@ -496,1 +496,1 @@\n-  FT_BASE_DEF( FT_UInt16 )\n+  FT_BASE_DEF( FT_UShort )\n@@ -502,1 +502,1 @@\n-    FT_UInt16  result = 0;\n+    FT_UShort  result = 0;\n@@ -541,1 +541,1 @@\n-  FT_BASE_DEF( FT_UInt16 )\n+  FT_BASE_DEF( FT_UShort )\n@@ -547,1 +547,1 @@\n-    FT_UInt16  result = 0;\n+    FT_UShort  result = 0;\n@@ -631,1 +631,1 @@\n-  FT_BASE_DEF( FT_UInt32 )\n+  FT_BASE_DEF( FT_ULong )\n@@ -637,1 +637,1 @@\n-    FT_UInt32 result = 0;\n+    FT_ULong  result = 0;\n@@ -676,1 +676,1 @@\n-  FT_BASE_DEF( FT_UInt32 )\n+  FT_BASE_DEF( FT_ULong )\n@@ -682,1 +682,1 @@\n-    FT_UInt32 result = 0;\n+    FT_ULong  result = 0;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftstream.c","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftstroke.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n@@ -48,12 +48,0 @@\n-  {\n-    \/* Value '0x0366A' corresponds to a shear angle of about 12 degrees. *\/\n-    FT_GlyphSlot_Slant( slot, 0x0366A, 0 );\n-  }\n-\n-\n-  \/* documentation is in ftsynth.h *\/\n-\n-  FT_EXPORT_DEF( void )\n-  FT_GlyphSlot_Slant( FT_GlyphSlot  slot,\n-                      FT_Fixed      xslant,\n-                      FT_Fixed      yslant )\n@@ -76,1 +64,3 @@\n-    \/* For italic, simply apply a shear transform *\/\n+    \/* For italic, simply apply a shear transform, with an angle *\/\n+    \/* of about 12 degrees.                                      *\/\n+\n@@ -78,1 +68,1 @@\n-    transform.yx = -yslant;\n+    transform.yx = 0x00000L;\n@@ -80,1 +70,1 @@\n-    transform.xy = xslant;\n+    transform.xy = 0x0366AL;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsynth.c","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsystem.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/fttrigon.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/fttype1.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftutil.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffcmap.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (C) 1996-2023 by\n- * David Turner, Robert Wilhelm, Werner Lemberg, and Dominik Röttsches.\n+ * Copyright (C) 1996-2022 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n@@ -939,64 +939,0 @@\n-  static FT_Error\n-  cff_load_item_variation_store( CFF_Face         face,\n-                                 FT_ULong         offset,\n-                                 GX_ItemVarStore  itemStore )\n-  {\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-\n-    return mm->load_item_var_store( FT_FACE(face), offset, itemStore );\n-  }\n-\n-\n-  static FT_Error\n-  cff_load_delta_set_index_mapping( CFF_Face           face,\n-                                    FT_ULong           offset,\n-                                    GX_DeltaSetIdxMap  map,\n-                                    GX_ItemVarStore    itemStore,\n-                                    FT_ULong           table_len )\n-  {\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-\n-    return mm->load_delta_set_idx_map( FT_FACE( face ), offset, map,\n-                                       itemStore, table_len );\n-  }\n-\n-\n-  static FT_Int\n-  cff_get_item_delta( CFF_Face         face,\n-                      GX_ItemVarStore  itemStore,\n-                      FT_UInt          outerIndex,\n-                      FT_UInt          innerIndex )\n-  {\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-\n-    return mm->get_item_delta( FT_FACE( face ), itemStore,\n-                               outerIndex, innerIndex );\n-  }\n-\n-\n-  static void\n-  cff_done_item_variation_store( CFF_Face          face,\n-                                 GX_ItemVarStore  itemStore )\n-  {\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-\n-    mm->done_item_var_store( FT_FACE( face ), itemStore );\n-  }\n-\n-\n-  static void\n-  cff_done_delta_set_index_map( CFF_Face           face,\n-                                GX_DeltaSetIdxMap  deltaSetIdxMap )\n-  {\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-\n-    mm->done_delta_set_idx_map( FT_FACE ( face ), deltaSetIdxMap );\n-  }\n-\n-\n-\n@@ -1006,30 +942,13 @@\n-    (FT_Get_MM_Func)        NULL,               \/* get_mm                    *\/\n-    (FT_Set_MM_Design_Func) NULL,               \/* set_mm_design             *\/\n-    (FT_Set_MM_Blend_Func)  cff_set_mm_blend,   \/* set_mm_blend              *\/\n-    (FT_Get_MM_Blend_Func)  cff_get_mm_blend,   \/* get_mm_blend              *\/\n-    (FT_Get_MM_Var_Func)    cff_get_mm_var,     \/* get_mm_var                *\/\n-    (FT_Set_Var_Design_Func)cff_set_var_design, \/* set_var_design            *\/\n-    (FT_Get_Var_Design_Func)cff_get_var_design, \/* get_var_design            *\/\n-    (FT_Set_Instance_Func)  cff_set_instance,   \/* set_instance              *\/\n-    (FT_Set_MM_WeightVector_Func)\n-                            cff_set_mm_weightvector,\n-                                                \/* set_mm_weightvector       *\/\n-    (FT_Get_MM_WeightVector_Func)\n-                            cff_get_mm_weightvector,\n-                                                \/* get_mm_weightvector       *\/\n-    (FT_Var_Load_Delta_Set_Idx_Map_Func)\n-                            cff_load_delta_set_index_mapping,\n-                                                \/* load_delta_set_idx_map    *\/\n-    (FT_Var_Load_Item_Var_Store_Func)\n-                            cff_load_item_variation_store,\n-                                                \/* load_item_variation_store *\/\n-    (FT_Var_Get_Item_Delta_Func)\n-                            cff_get_item_delta, \/* get_item_delta            *\/\n-    (FT_Var_Done_Item_Var_Store_Func)\n-                            cff_done_item_variation_store,\n-                                                \/* done_item_variation_store *\/\n-    (FT_Var_Done_Delta_Set_Idx_Map_Func)\n-                            cff_done_delta_set_index_map,\n-                                                \/* done_delta_set_index_map  *\/\n-    (FT_Get_Var_Blend_Func) cff_get_var_blend,  \/* get_var_blend             *\/\n-    (FT_Done_Blend_Func)    cff_done_blend      \/* done_blend                *\/\n+    (FT_Get_MM_Func)             NULL,                    \/* get_mm              *\/\n+    (FT_Set_MM_Design_Func)      NULL,                    \/* set_mm_design       *\/\n+    (FT_Set_MM_Blend_Func)       cff_set_mm_blend,        \/* set_mm_blend        *\/\n+    (FT_Get_MM_Blend_Func)       cff_get_mm_blend,        \/* get_mm_blend        *\/\n+    (FT_Get_MM_Var_Func)         cff_get_mm_var,          \/* get_mm_var          *\/\n+    (FT_Set_Var_Design_Func)     cff_set_var_design,      \/* set_var_design      *\/\n+    (FT_Get_Var_Design_Func)     cff_get_var_design,      \/* get_var_design      *\/\n+    (FT_Set_Instance_Func)       cff_set_instance,        \/* set_instance        *\/\n+    (FT_Set_MM_WeightVector_Func)cff_set_mm_weightvector, \/* set_mm_weightvector *\/\n+    (FT_Get_MM_WeightVector_Func)cff_get_mm_weightvector, \/* get_mm_weightvector *\/\n+\n+    (FT_Get_Var_Blend_Func)      cff_get_var_blend,       \/* get_var_blend       *\/\n+    (FT_Done_Blend_Func)         cff_done_blend           \/* done_blend          *\/\n@@ -1111,1 +1030,2 @@\n-#if defined TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+#if !defined FT_CONFIG_OPTION_NO_GLYPH_NAMES && \\\n+     defined TT_CONFIG_OPTION_GX_VAR_SUPPORT\n@@ -1126,1 +1046,1 @@\n-#else\n+#elif !defined FT_CONFIG_OPTION_NO_GLYPH_NAMES\n@@ -1139,0 +1059,26 @@\n+#elif defined TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+  FT_DEFINE_SERVICEDESCREC9(\n+    cff_services,\n+\n+    FT_SERVICE_ID_FONT_FORMAT,          FT_FONT_FORMAT_CFF,\n+    FT_SERVICE_ID_MULTI_MASTERS,        &cff_service_multi_masters,\n+    FT_SERVICE_ID_METRICS_VARIATIONS,   &cff_service_metrics_var,\n+    FT_SERVICE_ID_POSTSCRIPT_INFO,      &cff_service_ps_info,\n+    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &cff_service_ps_name,\n+    FT_SERVICE_ID_TT_CMAP,              &cff_service_get_cmap_info,\n+    FT_SERVICE_ID_CID,                  &cff_service_cid_info,\n+    FT_SERVICE_ID_PROPERTIES,           &cff_service_properties,\n+    FT_SERVICE_ID_CFF_LOAD,             &cff_service_cff_load\n+  )\n+#else\n+  FT_DEFINE_SERVICEDESCREC7(\n+    cff_services,\n+\n+    FT_SERVICE_ID_FONT_FORMAT,          FT_FONT_FORMAT_CFF,\n+    FT_SERVICE_ID_POSTSCRIPT_INFO,      &cff_service_ps_info,\n+    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &cff_service_ps_name,\n+    FT_SERVICE_ID_TT_CMAP,              &cff_service_get_cmap_info,\n+    FT_SERVICE_ID_CID,                  &cff_service_cid_info,\n+    FT_SERVICE_ID_PROPERTIES,           &cff_service_properties,\n+    FT_SERVICE_ID_CFF_LOAD,             &cff_service_cff_load\n+  )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffdrivr.c","additions":44,"deletions":98,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffdrivr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cfferrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -359,1 +359,2 @@\n-    if ( ( load_flags & FT_LOAD_COLOR ) && face->svg )\n+    if ( ( load_flags & FT_LOAD_COLOR )     &&\n+         ( (TT_Face)glyph->root.face )->svg )\n@@ -366,1 +367,4 @@\n-      SFNT_Service  sfnt  = (SFNT_Service)face->sfnt;\n+      FT_Short      dummy;\n+      FT_UShort     advanceX;\n+      FT_UShort     advanceY;\n+      SFNT_Service  sfnt;\n@@ -378,0 +382,1 @@\n+      sfnt  = (SFNT_Service)((TT_Face)glyph->root.face)->sfnt;\n@@ -381,8 +386,0 @@\n-        FT_Fixed  x_scale = size->root.metrics.x_scale;\n-        FT_Fixed  y_scale = size->root.metrics.y_scale;\n-\n-        FT_Short   dummy;\n-        FT_UShort  advanceX;\n-        FT_UShort  advanceY;\n-\n-\n@@ -410,2 +407,8 @@\n-        glyph->root.linearHoriAdvance = advanceX;\n-        glyph->root.linearVertAdvance = advanceY;\n+        advanceX =\n+          (FT_UShort)FT_MulDiv( advanceX,\n+                                glyph->root.face->size->metrics.x_ppem,\n+                                glyph->root.face->units_per_EM );\n+        advanceY =\n+          (FT_UShort)FT_MulDiv( advanceY,\n+                                glyph->root.face->size->metrics.y_ppem,\n+                                glyph->root.face->units_per_EM );\n@@ -413,2 +416,2 @@\n-        glyph->root.metrics.horiAdvance = FT_MulFix( advanceX, x_scale );\n-        glyph->root.metrics.vertAdvance = FT_MulFix( advanceY, y_scale );\n+        glyph->root.metrics.horiAdvance = advanceX << 6;\n+        glyph->root.metrics.vertAdvance = advanceY << 6;\n@@ -491,5 +494,0 @@\n-      \/* this function also checks for a valid subfont index *\/\n-      error = decoder_funcs->prepare( &decoder, size, glyph_index );\n-      if ( error )\n-        goto Glyph_Build_Finished;\n-\n@@ -502,0 +500,4 @@\n+      error = decoder_funcs->prepare( &decoder, size, glyph_index );\n+      if ( error )\n+        goto Glyph_Build_Finished;\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffgload.c","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -1291,1 +1291,1 @@\n-  \/* Blend calculation is done in 16.16 fixed-point.       *\/\n+  \/* Blend calculation is done in 16.16 fixed point.       *\/\n@@ -1367,1 +1367,1 @@\n-      \/* convert inputs to 16.16 fixed-point *\/\n+      \/* convert inputs to 16.16 fixed point *\/\n@@ -1376,1 +1376,1 @@\n-      \/* Push blended result as Type 2 5-byte fixed-point number.  This *\/\n+      \/* Push blended result as Type 2 5-byte fixed point number.  This *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffload.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -1034,0 +1034,1 @@\n+#ifndef FT_CONFIG_OPTION_NO_GLYPH_NAMES\n@@ -1038,0 +1039,1 @@\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffobjs.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -533,1 +533,1 @@\n-      \/* 16.16 fixed-point is used internally for CFF2 blend results. *\/\n+      \/* 16.16 fixed point is used internally for CFF2 blend results. *\/\n@@ -761,6 +761,6 @@\n-                  (double)matrix->xx \/ (double)*upm \/ 65536,\n-                  (double)matrix->xy \/ (double)*upm \/ 65536,\n-                  (double)matrix->yx \/ (double)*upm \/ 65536,\n-                  (double)matrix->yy \/ (double)*upm \/ 65536,\n-                  (double)offset->x  \/ (double)*upm \/ 65536,\n-                  (double)offset->y  \/ (double)*upm \/ 65536 ));\n+                  (double)matrix->xx \/ *upm \/ 65536,\n+                  (double)matrix->xy \/ *upm \/ 65536,\n+                  (double)matrix->yx \/ *upm \/ 65536,\n+                  (double)matrix->yy \/ *upm \/ 65536,\n+                  (double)offset->x  \/ *upm \/ 65536,\n+                  (double)offset->y  \/ *upm \/ 65536 ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffparse.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffparse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cfftoken.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/ciderrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidgload.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidload.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -156,1 +156,1 @@\n-  FT_LOCAL_DEF( FT_Error )\n+  FT_LOCAL( FT_Error )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidobjs.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidparse.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidparse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidriver.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidtoken.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n@@ -566,1 +566,1 @@\n-  FT_LOCAL_DEF( void )\n+  FT_LOCAL( void )\n@@ -1064,1 +1064,1 @@\n-        FALL_THROUGH;\n+        \/* fall through                      *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/afmparse.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/afmparse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/cffdecode.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2023 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/cffdecode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxerr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxmod.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxmod.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psconv.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psconv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- *   Adobe's code for Fixed-Point Mathematics (specification only).\n+ *   Adobe's code for Fixed Point Mathematics (specification only).\n@@ -46,1 +46,1 @@\n-  \/* rasterizer integer and fixed-point arithmetic must be 32-bit *\/\n+  \/* rasterizer integer and fixed point arithmetic must be 32-bit *\/\n@@ -49,1 +49,1 @@\n-  typedef FT_Int32   CF2_Frac;   \/* 2.30 fixed-point *\/\n+  typedef FT_Int32   CF2_Frac;   \/* 2.30 fixed point *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psfixed.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+    FT_ASSERT( unitsPerEm > 0 );\n+\n@@ -74,1 +76,0 @@\n-    FT_ASSERT( unitsPerEm > 0 );\n@@ -299,0 +300,1 @@\n+    FT_ASSERT( decoder->builder.face->units_per_EM );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psft.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  \/* a matrix of fixed-point values *\/\n+  \/* a matrix of fixed point values *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psglue.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -696,4 +696,2 @@\n-                       ADD_INT32(\n-                         firstHintEdge->csCoord,\n-                         SUB_INT32 ( secondHintEdge->csCoord,\n-                                     firstHintEdge->csCoord ) \/ 2 ) );\n+                       ADD_INT32( secondHintEdge->csCoord,\n+                                  firstHintEdge->csCoord ) \/ 2 );\n@@ -1039,1 +1037,1 @@\n-      FT_TRACE6(( \"Initial hintmap:\\n\" ));\n+      FT_TRACE6(( \"Initial hintmap\" ));\n@@ -1042,1 +1040,1 @@\n-      FT_TRACE6(( \"Hints:\\n\" ));\n+      FT_TRACE6(( \"Hints:\" ));\n@@ -1059,1 +1057,1 @@\n-    FT_TRACE6(( \"Hints adjusted:\\n\" ));\n+    FT_TRACE6(( \"(adjusted)\\n\" ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/pshints.c","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -87,0 +87,1 @@\n+    table->num_elems = 0;\n@@ -237,1 +238,1 @@\n-    if ( table->init == 0xDEADBEEFUL )\n+    if ( (FT_ULong)table->init == 0xDEADBEEFUL )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psobjs.c","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-      CF2_Fixed  r;      \/* 16.16 fixed-point *\/\n-      CF2_Frac   f;      \/* 2.30 fixed-point (for font matrix) *\/\n+      CF2_Fixed  r;      \/* 16.16 fixed point *\/\n+      CF2_Frac   f;      \/* 2.30 fixed point (for font matrix) *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psstack.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1cmap.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1cmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1decode.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1decode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshalgo.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshalgo.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshglob.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshglob.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshmod.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshmod.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2023 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshnterr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n@@ -768,1 +768,1 @@\n-  FT_LOCAL_DEF( void )\n+  FT_LOCAL( void )\n@@ -782,1 +782,1 @@\n-  FT_LOCAL_DEF( void )\n+  FT_LOCAL( void )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshrec.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshrec.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -415,4 +415,1 @@\n-    PS_UniMap  *result = NULL;\n-    PS_UniMap  *min = table->maps;\n-    PS_UniMap  *max = min + table->num_maps;\n-    PS_UniMap  *mid = min + ( ( max - min ) >> 1 );\n+    PS_UniMap  *min, *max, *mid, *result = NULL;\n@@ -422,1 +419,5 @@\n-    while ( min < max )\n+\n+    min = table->maps;\n+    max = min + table->num_maps - 1;\n+\n+    while ( min <= max )\n@@ -427,0 +428,2 @@\n+      mid = min + ( ( max - min ) >> 1 );\n+\n@@ -438,0 +441,3 @@\n+      if ( min == max )\n+        break;\n+\n@@ -441,6 +447,1 @@\n-        max = mid;\n-\n-      \/* reasonable prediction in a continuous block *\/\n-      mid += unicode - base_glyph;\n-      if ( mid >= max || mid < min )\n-        mid = min + ( ( max - min ) >> 1 );\n+        max = mid - 1;\n@@ -467,1 +468,1 @@\n-      FT_UInt     mid = min + ( ( max - min ) >> 1 );\n+      FT_UInt     mid;\n@@ -474,0 +475,1 @@\n+        mid = min + ( ( max - min ) >> 1 );\n@@ -491,5 +493,0 @@\n-\n-        \/* reasonable prediction in a continuous block *\/\n-        mid += char_code - base_glyph;\n-        if ( mid >= max || mid < min )\n-          mid = min + ( max - min ) \/ 2;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psmodule.c","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psmodule.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psnamerr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2023 by\n+ * Copyright (C) 2005-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/pstables.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2005-2023 by\n+ * Copyright (C) 2005-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftmisc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -2222,2 +2222,2 @@\n-                (double)x1 \/ (double)ras.precision,\n-                (double)x2 \/ (double)ras.precision ));\n+                x1 \/ (double)ras.precision,\n+                x2 \/ (double)ras.precision ));\n@@ -2297,2 +2297,2 @@\n-                (double)x1 \/ (double)ras.precision,\n-                (double)x2 \/ (double)ras.precision ));\n+                x1 \/ (double)ras.precision,\n+                x2 \/ (double)ras.precision ));\n@@ -2480,2 +2480,2 @@\n-                (double)x1 \/ (double)ras.precision,\n-                (double)x2 \/ (double)ras.precision ));\n+                x1 \/ (double)ras.precision,\n+                x2 \/ (double)ras.precision ));\n@@ -2551,2 +2551,2 @@\n-                (double)x1 \/ (double)ras.precision,\n-                (double)x2 \/ (double)ras.precision ));\n+                x1 \/ (double)ras.precision,\n+                x2 \/ (double)ras.precision ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftraster.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftraster.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftrend1.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftrend1.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/rasterrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n@@ -242,1 +242,1 @@\n-      \/* return; (never reached) *\/\n+      return;\n@@ -410,2 +410,1 @@\n-      \/* Shouldn't happen, but ... *\/\n-      FALL_THROUGH;\n+      \/* Shouldn't happen, but fall through. *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/pngshim.c","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2023 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/pngshim.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -381,1 +381,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -384,1 +384,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -391,1 +391,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -395,1 +395,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -398,1 +398,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -401,1 +401,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -408,1 +408,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -412,1 +412,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -415,1 +415,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -418,1 +418,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -425,1 +425,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -429,1 +429,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -432,1 +432,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -435,1 +435,1 @@\n-        FALL_THROUGH;\n+        \/* fall through *\/\n@@ -660,1 +660,1 @@\n-   * Find the shortest decimal representation of a 16.16 fixed-point\n+   * Find the shortest decimal representation of a 16.16 fixed point\n@@ -736,1 +736,1 @@\n-        verified this by iterating over all possible fixed-point numbers.\n+        verified this by iterating over all possible fixed point numbers.\n@@ -744,1 +744,1 @@\n-        also found by testing all possible fixed-point values).\n+        also found by testing all possible fixed point values).\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfdriver.c","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfdriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sferrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -1110,1 +1110,7 @@\n-        flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n+      {\n+        if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &&\n+             tt_face_lookup_table( face, TTAG_gvar ) != 0 )\n+          flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n+        if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )\n+          flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n+      }\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfobjs.c","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -165,1 +165,2 @@\n-    if ( FT_QALLOC( sfnt, 12 ) || FT_NEW( sfnt_stream ) )\n+    if ( FT_QALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||\n+         FT_NEW( sfnt_stream )                          )\n@@ -198,2 +199,2 @@\n-    if ( FT_QNEW_ARRAY( tables, woff.num_tables )  ||\n-         FT_QNEW_ARRAY( indices, woff.num_tables ) )\n+    if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||\n+         FT_NEW_ARRAY( indices, woff.num_tables ) )\n@@ -330,1 +331,3 @@\n-    if ( FT_QREALLOC( sfnt, 12, woff.totalSfntSize ) )\n+    if ( FT_REALLOC( sfnt,\n+                     12 + woff.num_tables * 16UL,\n+                     woff.totalSfntSize ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff.c","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2023 by\n+ * Copyright (C) 2019-2022 by\n@@ -232,3 +232,3 @@\n-      if ( FT_QREALLOC( dst,\n-                        (FT_ULong)( *dst_size ),\n-                        (FT_ULong)( *offset + size ) ) )\n+      if ( FT_REALLOC( dst,\n+                       (FT_ULong)( *dst_size ),\n+                       (FT_ULong)( *offset + size ) ) )\n@@ -787,1 +787,1 @@\n-    if ( FT_QALLOC( loca_buf, loca_buf_size ) )\n+    if ( FT_QNEW_ARRAY( loca_buf, loca_buf_size ) )\n@@ -866,1 +866,1 @@\n-    if ( FT_QNEW_ARRAY( substreams, num_substreams ) )\n+    if ( FT_NEW_ARRAY( substreams, num_substreams ) )\n@@ -929,1 +929,1 @@\n-    if ( FT_QNEW_ARRAY( loca_values, num_glyphs + 1 ) )\n+    if ( FT_NEW_ARRAY( loca_values, num_glyphs + 1 ) )\n@@ -941,1 +941,1 @@\n-    if ( FT_QALLOC( glyph_buf, glyph_buf_size ) )\n+    if ( FT_NEW_ARRAY( glyph_buf, glyph_buf_size ) )\n@@ -944,1 +944,1 @@\n-    if ( FT_QNEW_ARRAY( info->x_mins, num_glyphs ) )\n+    if ( FT_NEW_ARRAY( info->x_mins, num_glyphs ) )\n@@ -1002,1 +1002,1 @@\n-          if ( FT_QREALLOC( glyph_buf, glyph_buf_size, size_needed ) )\n+          if ( FT_RENEW_ARRAY( glyph_buf, glyph_buf_size, size_needed ) )\n@@ -1078,1 +1078,1 @@\n-        if ( FT_QNEW_ARRAY( n_points_arr, n_contours ) )\n+        if ( FT_NEW_ARRAY( n_points_arr, n_contours ) )\n@@ -1115,1 +1115,1 @@\n-        if ( FT_QNEW_ARRAY( points, points_size ) )\n+        if ( FT_NEW_ARRAY( points, points_size ) )\n@@ -1144,1 +1144,1 @@\n-          if ( FT_QREALLOC( glyph_buf, glyph_buf_size, size_needed ) )\n+          if ( FT_RENEW_ARRAY( glyph_buf, glyph_buf_size, size_needed ) )\n@@ -1229,1 +1229,2 @@\n-      info->x_mins[i] = (FT_Short)x_min;\n+      if ( n_contours > 0 )\n+        info->x_mins[i] = (FT_Short)x_min;\n@@ -1346,1 +1347,1 @@\n-    if ( FT_QNEW_ARRAY( info->x_mins, num_glyphs ) )\n+    if ( FT_NEW_ARRAY( info->x_mins, num_glyphs ) )\n@@ -1434,2 +1435,2 @@\n-    if ( FT_QNEW_ARRAY( advance_widths, num_hmetrics ) ||\n-         FT_QNEW_ARRAY( lsbs, num_glyphs )             )\n+    if ( FT_NEW_ARRAY( advance_widths, num_hmetrics ) ||\n+         FT_NEW_ARRAY( lsbs, num_glyphs )             )\n@@ -1486,1 +1487,1 @@\n-    if ( FT_QALLOC( hmtx_table, hmtx_table_size ) )\n+    if ( FT_NEW_ARRAY( hmtx_table, hmtx_table_size ) )\n@@ -1543,4 +1544,4 @@\n-    FT_Error   error      = FT_Err_Ok;\n-    FT_Stream  stream     = NULL;\n-    FT_Byte*   buf_cursor = NULL;\n-    FT_Byte    table_entry[16];\n+    FT_Error   error       = FT_Err_Ok;\n+    FT_Stream  stream      = NULL;\n+    FT_Byte*   buf_cursor  = NULL;\n+    FT_Byte*   table_entry = NULL;\n@@ -1587,0 +1588,4 @@\n+    \/* Create buffer for table entries. *\/\n+    if ( FT_NEW_ARRAY( table_entry, 16 ) )\n+      goto Fail;\n+\n@@ -1749,0 +1754,1 @@\n+    FT_FREE( table_entry );\n@@ -1761,0 +1767,1 @@\n+    FT_FREE( table_entry );\n@@ -1873,2 +1880,2 @@\n-    if ( FT_QNEW_ARRAY( tables, woff2.num_tables )  ||\n-         FT_QNEW_ARRAY( indices, woff2.num_tables ) )\n+    if ( FT_NEW_ARRAY( tables, woff2.num_tables )  ||\n+         FT_NEW_ARRAY( indices, woff2.num_tables ) )\n@@ -1945,1 +1952,0 @@\n-      table->flags      = flags;\n@@ -1949,1 +1955,1 @@\n-      table->dst_offset = 0;\n+      table->flags      = flags;\n@@ -2007,1 +2013,0 @@\n-      \/* pre-zero pointers within in case of failure *\/\n@@ -2021,1 +2026,1 @@\n-        if ( FT_QNEW_ARRAY( ttc_font->table_indices, ttc_font->num_tables ) )\n+        if ( FT_NEW_ARRAY( ttc_font->table_indices, ttc_font->num_tables ) )\n@@ -2300,3 +2305,3 @@\n-      if ( FT_QREALLOC( sfnt,\n-                        (FT_ULong)( sfnt_size ),\n-                        (FT_ULong)( woff2.actual_sfnt_size ) ) )\n+      if ( FT_REALLOC( sfnt,\n+                       (FT_ULong)( sfnt_size ),\n+                       (FT_ULong)( woff2.actual_sfnt_size ) ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff2.c","additions":36,"deletions":31,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2023 by\n+ * Copyright (C) 2019-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff2.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n@@ -3882,1 +3882,1 @@\n-  FT_LOCAL_DEF( FT_Error )\n+  FT_LOCAL( FT_Error )\n@@ -3889,1 +3889,0 @@\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmap.c","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2023 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2009-2023 by\n+ * Copyright (C) 2009-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmapc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2022 by\n@@ -37,3 +37,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-#include <freetype\/internal\/services\/svmm.h>\n-#endif\n@@ -52,1 +49,0 @@\n-#define VAR_IDX_BASE_SIZE                 4U\n@@ -54,11 +50,1 @@\n-\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr#colr-header *\/\n-\/* 3 * uint16 + 2 * Offset32 *\/\n-#define COLRV0_HEADER_SIZE               14U\n-\/* COLRV0_HEADER_SIZE + 5 * Offset32 *\/\n-#define COLRV1_HEADER_SIZE               34U\n-\n-\n-#define ENSURE_READ_BYTES( byte_size )                             \\\n-  if ( p < colr->paints_start_v1                                || \\\n-       p > (FT_Byte*)colr->table + colr->table_size - byte_size )  \\\n-    return 0\n+#define COLR_HEADER_SIZE                 14U\n@@ -69,19 +55,5 @@\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SOLID                = 3,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_LINEAR_GRADIENT      = 5,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_RADIAL_GRADIENT      = 7,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SWEEP_GRADIENT       = 9,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSFORM            = 13,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSLATE            = 15,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE                = 17,\n-    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER             = 18,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER         = 19,\n-    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM            = 20,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM        = 21,\n-    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER     = 22,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER = 23,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE               = 25,\n-    FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER            = 26,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER        = 27,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW                 = 29,\n-    FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER              = 30,\n-    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER          = 31,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER         = 18,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM        = 20,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER = 22,\n+    FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER        = 26,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER          = 30\n@@ -135,6 +107,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-    \/* Item Variation Store for variable 'COLR' v1. *\/\n-    GX_ItemVarStoreRec    var_store;\n-    GX_DeltaSetIdxMapRec  delta_set_idx_map;\n-#endif\n-\n@@ -176,3 +142,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-    FT_ULong  colr_offset_in_stream;\n-#endif\n@@ -189,6 +152,2 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-    colr_offset_in_stream = FT_STREAM_POS();\n-#endif\n-\n-    if ( table_size < COLRV0_HEADER_SIZE )\n-      goto NoColr;\n+    if ( table_size < COLR_HEADER_SIZE )\n+      goto InvalidTable;\n@@ -227,3 +186,0 @@\n-      if ( table_size < COLRV1_HEADER_SIZE )\n-        goto InvalidTable;\n-\n@@ -232,1 +188,1 @@\n-      if ( base_glyphs_offset_v1 + 4 >= table_size )\n+      if ( base_glyphs_offset_v1 >= table_size )\n@@ -252,3 +208,0 @@\n-        if ( layer_offset_v1 + 4 >= table_size )\n-          goto InvalidTable;\n-\n@@ -289,59 +242,0 @@\n-\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      colr->var_store.dataCount     = 0;\n-      colr->var_store.varData       = NULL;\n-      colr->var_store.axisCount     = 0;\n-      colr->var_store.regionCount   = 0;\n-      colr->var_store.varRegionList = 0;\n-\n-      colr->delta_set_idx_map.mapCount   = 0;\n-      colr->delta_set_idx_map.outerIndex = NULL;\n-      colr->delta_set_idx_map.innerIndex = NULL;\n-\n-      if ( face->variation_support & TT_FACE_FLAG_VAR_FVAR )\n-      {\n-        FT_ULong  var_idx_map_offset, var_store_offset;\n-\n-        FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-\n-        var_idx_map_offset = FT_NEXT_ULONG( p );\n-\n-        if ( var_idx_map_offset >= table_size )\n-          goto InvalidTable;\n-\n-        var_store_offset = FT_NEXT_ULONG( p );\n-        if ( var_store_offset >= table_size )\n-          goto InvalidTable;\n-\n-        if ( var_store_offset )\n-        {\n-          \/* If variation info has not been initialized yet, try doing so, *\/\n-          \/* otherwise loading the variation store will fail as it         *\/\n-          \/* requires access to `blend` for checking the number of axes.   *\/\n-          if ( !face->blend )\n-            if ( mm->get_mm_var( FT_FACE( face ), NULL ) )\n-              goto InvalidTable;\n-\n-          \/* Try loading `VarIdxMap` and `VarStore`. *\/\n-          error = mm->load_item_var_store(\n-                    FT_FACE( face ),\n-                    colr_offset_in_stream + var_store_offset,\n-                    &colr->var_store );\n-          if ( error != FT_Err_Ok )\n-            goto InvalidTable;\n-        }\n-\n-        if ( colr->var_store.axisCount && var_idx_map_offset )\n-        {\n-          error = mm->load_delta_set_idx_map(\n-                    FT_FACE( face ),\n-                    colr_offset_in_stream + var_idx_map_offset,\n-                    &colr->delta_set_idx_map,\n-                    &colr->var_store,\n-                    table_size );\n-          if ( error != FT_Err_Ok )\n-            goto InvalidTable;\n-        }\n-      }\n-#endif \/* TT_CONFIG_OPTION_GX_VAR_SUPPORT *\/\n@@ -360,12 +254,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-    {\n-      FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-\n-      mm->done_delta_set_idx_map( FT_FACE( face ),\n-                                  &colr->delta_set_idx_map );\n-      mm->done_item_var_store( FT_FACE( face ),\n-                               &colr->var_store );\n-    }\n-#endif\n-\n@@ -393,11 +275,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      {\n-        FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-\n-        mm->done_delta_set_idx_map( FT_FACE( face ),\n-                                    &colr->delta_set_idx_map );\n-        mm->done_item_var_store( FT_FACE( face ),\n-                                 &colr->var_store );\n-      }\n-#endif\n@@ -486,3 +357,1 @@\n-    if ( iterator->layer >= iterator->num_layers                     ||\n-         iterator->p < colr->layers                                  ||\n-         iterator->p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+    if ( iterator->layer >= iterator->num_layers )\n@@ -506,4 +375,2 @@\n-  read_color_line( Colr*          colr,\n-                   FT_Byte*       color_line_p,\n-                   FT_ColorLine*  colorline,\n-                   FT_Bool        read_variable )\n+  read_color_line( FT_Byte*      color_line_p,\n+                   FT_ColorLine  *colorline )\n@@ -515,2 +382,0 @@\n-    ENSURE_READ_BYTES( 3 );\n-\n@@ -526,1 +391,0 @@\n-    colorline->color_stop_iterator.read_variable      = read_variable;\n@@ -552,4 +416,0 @@\n-    if ( *p < colr->paints_start_v1                            ||\n-         *p > (FT_Byte*)colr->table + colr->table_size - 1 - 3 )\n-      return 0;\n-\n@@ -571,2 +431,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-\n@@ -574,53 +432,1 @@\n-  get_deltas_for_var_index_base ( TT_Face           face,\n-                                  Colr*             colr,\n-                                  FT_ULong          var_index_base,\n-                                  FT_UInt           num_deltas,\n-                                  FT_ItemVarDelta*  deltas )\n-  {\n-    FT_UInt   outer_index    = 0;\n-    FT_UInt   inner_index    = 0;\n-    FT_ULong  loop_var_index = var_index_base;\n-\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n-\n-    FT_UInt  i = 0;\n-\n-\n-    if ( var_index_base == 0xFFFFFFFF )\n-    {\n-      for ( i = 0; i < num_deltas; ++i )\n-        deltas[i] = 0;\n-      return 1;\n-    }\n-\n-    for ( i = 0; i < num_deltas; ++i )\n-    {\n-      loop_var_index = var_index_base + i;\n-\n-      if ( colr->delta_set_idx_map.innerIndex )\n-      {\n-        if ( loop_var_index >= colr->delta_set_idx_map.mapCount )\n-          loop_var_index = colr->delta_set_idx_map.mapCount - 1;\n-\n-        outer_index = colr->delta_set_idx_map.outerIndex[loop_var_index];\n-        inner_index = colr->delta_set_idx_map.innerIndex[loop_var_index];\n-      }\n-      else\n-      {\n-        outer_index = 0;\n-        inner_index = loop_var_index;\n-      }\n-\n-      deltas[i] = mm->get_item_delta( FT_FACE( face ), &colr->var_store,\n-                                      outer_index, inner_index );\n-    }\n-\n-    return 1;\n-  }\n-\n-#endif \/* TT_CONFIG_OPTION_GX_VAR_SUPPORT *\/\n-\n-\n-  static FT_Bool\n-  read_paint( TT_Face         face,\n-              Colr*           colr,\n+  read_paint( Colr*           colr,\n@@ -630,11 +436,2 @@\n-    FT_Byte*  paint_base    = p;\n-    FT_Byte*  child_table_p = NULL;\n-    FT_Bool   do_read_var   = FALSE;\n-\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-    FT_ULong         var_index_base = 0;\n-    \/* Longest varIndexBase offset is 5 in the spec. *\/\n-    FT_ItemVarDelta  item_deltas[6] = { 0, 0, 0, 0, 0, 0 };\n-#else\n-    FT_UNUSED( face );\n-#endif\n+    FT_Byte*  paint_base     = p;\n+    FT_Byte*  child_table_p  = NULL;\n@@ -646,4 +443,2 @@\n-    \/* The last byte of the 'COLR' table is at 'size-1'; subtract 1 of    *\/\n-    \/* that to account for the expected format byte we are going to read. *\/\n-    if ( p < colr->paints_start_v1                        ||\n-         p > (FT_Byte*)colr->table + colr->table_size - 2 )\n+    if ( p < colr->paints_start_v1                         ||\n+         p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n@@ -683,3 +478,1 @@\n-    else if ( apaint->format == FT_COLR_PAINTFORMAT_SOLID ||\n-              (FT_PaintFormat_Internal)apaint->format ==\n-                 FT_COLR_PAINTFORMAT_INTERNAL_VAR_SOLID   )\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SOLID )\n@@ -687,1 +480,0 @@\n-      ENSURE_READ_BYTES( 4 );\n@@ -691,17 +483,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( (FT_PaintFormat_Internal)apaint->format ==\n-              FT_COLR_PAINTFORMAT_INTERNAL_VAR_SOLID )\n-      {\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG( p );\n-\n-        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 1,\n-                                             item_deltas ) )\n-          return 0;\n-\n-        apaint->u.solid.color.alpha += item_deltas[0];\n-      }\n-#endif\n-\n-      apaint->format = FT_COLR_PAINTFORMAT_SOLID;\n-\n@@ -713,1 +488,0 @@\n-      ENSURE_READ_BYTES(2);\n@@ -729,4 +503,1 @@\n-    if ( apaint->format == FT_COLR_PAINTFORMAT_LINEAR_GRADIENT      ||\n-         ( do_read_var =\n-             ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_LINEAR_GRADIENT ) ) )\n+    if ( apaint->format == FT_COLR_PAINTFORMAT_LINEAR_GRADIENT )\n@@ -734,4 +505,2 @@\n-      if ( !read_color_line( colr,\n-                             child_table_p,\n-                             &apaint->u.linear_gradient.colorline,\n-                             do_read_var ) )\n+      if ( !read_color_line( child_table_p,\n+                             &apaint->u.linear_gradient.colorline ) )\n@@ -741,3 +510,2 @@\n-       * In order to support variations expose these as FT_Fixed 16.16\n-       * values so that we can support fractional values after\n-       * interpolation.\n+       * In order to support variations expose these as FT_Fixed 16.16 values so\n+       * that we can support fractional values after interpolation.\n@@ -745,1 +513,0 @@\n-      ENSURE_READ_BYTES( 12 );\n@@ -753,21 +520,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( do_read_var )\n-      {\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG ( p );\n-\n-        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 6,\n-                                             item_deltas ) )\n-          return 0;\n-\n-        apaint->u.linear_gradient.p0.x += INT_TO_FIXED( item_deltas[0] );\n-        apaint->u.linear_gradient.p0.y += INT_TO_FIXED( item_deltas[1] );\n-        apaint->u.linear_gradient.p1.x += INT_TO_FIXED( item_deltas[2] );\n-        apaint->u.linear_gradient.p1.y += INT_TO_FIXED( item_deltas[3] );\n-        apaint->u.linear_gradient.p2.x += INT_TO_FIXED( item_deltas[4] );\n-        apaint->u.linear_gradient.p2.y += INT_TO_FIXED( item_deltas[5] );\n-      }\n-#endif\n-\n-      apaint->format = FT_COLR_PAINTFORMAT_LINEAR_GRADIENT;\n-\n@@ -777,4 +523,1 @@\n-    else if ( apaint->format == FT_COLR_PAINTFORMAT_RADIAL_GRADIENT      ||\n-              ( do_read_var =\n-                  ( (FT_PaintFormat_Internal)apaint->format ==\n-                    FT_COLR_PAINTFORMAT_INTERNAL_VAR_RADIAL_GRADIENT ) ) )\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_RADIAL_GRADIENT )\n@@ -785,4 +528,2 @@\n-      if ( !read_color_line( colr,\n-                             child_table_p,\n-                             &apaint->u.radial_gradient.colorline,\n-                             do_read_var ) )\n+      if ( !read_color_line( child_table_p,\n+                             &apaint->u.radial_gradient.colorline ) )\n@@ -791,1 +532,0 @@\n-\n@@ -797,2 +537,0 @@\n-      ENSURE_READ_BYTES( 12 );\n-\n@@ -811,25 +549,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( do_read_var )\n-      {\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG ( p );\n-\n-        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 6,\n-                                             item_deltas ) )\n-          return 0;\n-\n-        apaint->u.radial_gradient.c0.x += INT_TO_FIXED( item_deltas[0] );\n-        apaint->u.radial_gradient.c0.y += INT_TO_FIXED( item_deltas[1] );\n-\n-        \/\/ TODO: Anything to be done about UFWORD deltas here?\n-        apaint->u.radial_gradient.r0 += INT_TO_FIXED( item_deltas[2] );\n-\n-        apaint->u.radial_gradient.c1.x += INT_TO_FIXED( item_deltas[3] );\n-        apaint->u.radial_gradient.c1.y += INT_TO_FIXED( item_deltas[4] );\n-\n-        apaint->u.radial_gradient.r1 += INT_TO_FIXED( item_deltas[5] );\n-      }\n-#endif\n-\n-      apaint->format = FT_COLR_PAINTFORMAT_RADIAL_GRADIENT;\n-\n@@ -839,4 +552,1 @@\n-    else if ( apaint->format == FT_COLR_PAINTFORMAT_SWEEP_GRADIENT      ||\n-              ( do_read_var =\n-                  ( (FT_PaintFormat_Internal)apaint->format ==\n-                    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SWEEP_GRADIENT ) ) )\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SWEEP_GRADIENT )\n@@ -844,4 +554,2 @@\n-      if ( !read_color_line( colr,\n-                             child_table_p,\n-                             &apaint->u.sweep_gradient.colorline,\n-                             do_read_var) )\n+      if ( !read_color_line( child_table_p,\n+                             &apaint->u.sweep_gradient.colorline ) )\n@@ -850,2 +558,0 @@\n-      ENSURE_READ_BYTES( 8 );\n-\n@@ -862,22 +568,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( do_read_var )\n-      {\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG ( p );\n-\n-        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 4,\n-                                             item_deltas ) )\n-          return 0;\n-\n-        \/\/ TODO: Handle overflow?\n-        apaint->u.sweep_gradient.center.x += INT_TO_FIXED( item_deltas[0] );\n-        apaint->u.sweep_gradient.center.y += INT_TO_FIXED( item_deltas[1] );\n-\n-        apaint->u.sweep_gradient.start_angle +=\n-          F2DOT14_TO_FIXED( item_deltas[2] );\n-        apaint->u.sweep_gradient.end_angle +=\n-          F2DOT14_TO_FIXED( item_deltas[3] );\n-      }\n-#endif\n-      apaint->format = FT_COLR_PAINTFORMAT_SWEEP_GRADIENT;\n-\n@@ -889,1 +573,0 @@\n-      ENSURE_READ_BYTES( 2 );\n@@ -897,3 +580,1 @@\n-    else if ( apaint->format == FT_COLR_PAINTFORMAT_TRANSFORM ||\n-              (FT_PaintFormat_Internal)apaint->format ==\n-                FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSFORM    )\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_TRANSFORM )\n@@ -913,1 +594,0 @@\n-      ENSURE_READ_BYTES( 24 );\n@@ -921,22 +601,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSFORM )\n-      {\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG( p );\n-\n-        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 6,\n-                                             item_deltas ) )\n-          return 0;\n-\n-        apaint->u.transform.affine.xx += (FT_Fixed)item_deltas[0];\n-        apaint->u.transform.affine.yx += (FT_Fixed)item_deltas[1];\n-        apaint->u.transform.affine.xy += (FT_Fixed)item_deltas[2];\n-        apaint->u.transform.affine.yy += (FT_Fixed)item_deltas[3];\n-        apaint->u.transform.affine.dx += (FT_Fixed)item_deltas[4];\n-        apaint->u.transform.affine.dy += (FT_Fixed)item_deltas[5];\n-      }\n-#endif\n-\n-      apaint->format = FT_COLR_PAINTFORMAT_TRANSFORM;\n-\n@@ -946,3 +604,1 @@\n-    else if ( apaint->format == FT_COLR_PAINTFORMAT_TRANSLATE ||\n-              (FT_PaintFormat_Internal)apaint->format ==\n-                FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSLATE    )\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_TRANSLATE )\n@@ -953,1 +609,0 @@\n-      ENSURE_READ_BYTES( 4 );\n@@ -957,18 +612,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSLATE )\n-      {\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG( p );\n-\n-        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 2,\n-                                             item_deltas ) )\n-          return 0;\n-\n-        apaint->u.translate.dx += INT_TO_FIXED( item_deltas[0] );\n-        apaint->u.translate.dy += INT_TO_FIXED( item_deltas[1] );\n-      }\n-#endif\n-\n-      apaint->format = FT_COLR_PAINTFORMAT_TRANSLATE;\n-\n@@ -978,3 +615,8 @@\n-    else if ( apaint->format >= FT_COLR_PAINTFORMAT_SCALE             &&\n-              (FT_PaintFormat_Internal)apaint->format <=\n-                FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER )\n+    else if ( apaint->format ==\n+                FT_COLR_PAINTFORMAT_SCALE                         ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER         ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM        ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER )\n@@ -986,1 +628,0 @@\n-      ENSURE_READ_BYTES( 2 );\n@@ -990,5 +631,2 @@\n-      if ( apaint->format == FT_COLR_PAINTFORMAT_SCALE     ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE        ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER     ||\n+      if ( apaint->format ==\n+             FT_COLR_PAINTFORMAT_SCALE                 ||\n@@ -996,3 +634,1 @@\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER )\n-      {\n-        ENSURE_READ_BYTES( 2 );\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER )\n@@ -1000,1 +636,0 @@\n-      }\n@@ -1007,3 +642,1 @@\n-             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER             ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER         ||\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER         ||\n@@ -1011,3 +644,1 @@\n-             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER     ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER )\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER )\n@@ -1015,1 +646,0 @@\n-        ENSURE_READ_BYTES( 4 );\n@@ -1025,65 +655,0 @@\n-      \/* Base values set, now handle variations. *\/\n-\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE                ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER         ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM        ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER )\n-      {\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG( p );\n-\n-        if ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE )\n-        {\n-          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 2,\n-                                               item_deltas ) )\n-            return 0;\n-\n-          apaint->u.scale.scale_x += F2DOT14_TO_FIXED( item_deltas[0] );\n-          apaint->u.scale.scale_y += F2DOT14_TO_FIXED( item_deltas[1] );\n-        }\n-\n-        if ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER )\n-        {\n-          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 4,\n-                                               item_deltas ) )\n-            return 0;\n-\n-          apaint->u.scale.scale_x  += F2DOT14_TO_FIXED( item_deltas[0] );\n-          apaint->u.scale.scale_y  += F2DOT14_TO_FIXED( item_deltas[1] );\n-          apaint->u.scale.center_x += INT_TO_FIXED( item_deltas[2] );\n-          apaint->u.scale.center_y += INT_TO_FIXED( item_deltas[3] );\n-        }\n-\n-        if ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM )\n-        {\n-          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 1,\n-                                               item_deltas ) )\n-            return 0;\n-\n-          apaint->u.scale.scale_x += F2DOT14_TO_FIXED( item_deltas[0] );\n-          apaint->u.scale.scale_y += F2DOT14_TO_FIXED( item_deltas[0] );\n-        }\n-\n-        if ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER )\n-        {\n-          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 3,\n-                                               item_deltas ) )\n-            return 0;\n-\n-          apaint->u.scale.scale_x  += F2DOT14_TO_FIXED( item_deltas[0] );\n-          apaint->u.scale.scale_y  += F2DOT14_TO_FIXED( item_deltas[0] );\n-          apaint->u.scale.center_x += INT_TO_FIXED( item_deltas[1] );\n-          apaint->u.scale.center_y += INT_TO_FIXED( item_deltas[2] );\n-        }\n-      }\n-#endif\n-\n@@ -1097,3 +662,1 @@\n-    else if ( apaint->format == FT_COLR_PAINTFORMAT_ROTATE     ||\n-              (FT_PaintFormat_Internal)apaint->format ==\n-                FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER     ||\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_ROTATE ||\n@@ -1101,3 +664,1 @@\n-                FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE        ||\n-              (FT_PaintFormat_Internal)apaint->format ==\n-                FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER )\n+                FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER )\n@@ -1108,1 +669,0 @@\n-      ENSURE_READ_BYTES( 2 );\n@@ -1112,3 +672,1 @@\n-             FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER     ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER )\n+           FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER )\n@@ -1116,1 +674,0 @@\n-        ENSURE_READ_BYTES( 4 );\n@@ -1126,36 +683,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE        ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER )\n-      {\n-        FT_UInt  num_deltas = 0;\n-\n-\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG( p );\n-\n-        if ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER )\n-          num_deltas = 3;\n-        if ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE )\n-          num_deltas = 1;\n-\n-        if ( num_deltas > 0 )\n-        {\n-          if ( !get_deltas_for_var_index_base( face, colr, var_index_base,\n-                                               num_deltas, item_deltas ) )\n-            return 0;\n-\n-          apaint->u.rotate.angle += F2DOT14_TO_FIXED( item_deltas[0] );\n-\n-          if ( num_deltas == 3 )\n-          {\n-            apaint->u.rotate.center_x += INT_TO_FIXED( item_deltas[1] );\n-            apaint->u.rotate.center_y += INT_TO_FIXED( item_deltas[2] );\n-          }\n-        }\n-      }\n-#endif\n-\n@@ -1164,1 +685,0 @@\n-\n@@ -1168,5 +688,1 @@\n-    else if ( apaint->format == FT_COLR_PAINTFORMAT_SKEW     ||\n-              (FT_PaintFormat_Internal)apaint->format ==\n-                FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW        ||\n-              (FT_PaintFormat_Internal)apaint->format ==\n-                FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER     ||\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SKEW ||\n@@ -1174,1 +690,1 @@\n-                FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER )\n+                FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER )\n@@ -1179,1 +695,0 @@\n-      ENSURE_READ_BYTES( 4 );\n@@ -1184,3 +699,1 @@\n-             FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER     ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER )\n+           FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER )\n@@ -1188,1 +701,0 @@\n-        ENSURE_READ_BYTES( 4 );\n@@ -1198,36 +710,0 @@\n-\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      if ( (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW        ||\n-           (FT_PaintFormat_Internal)apaint->format ==\n-             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER )\n-      {\n-        ENSURE_READ_BYTES( 4 );\n-        var_index_base = FT_NEXT_ULONG( p );\n-\n-        if ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW )\n-        {\n-          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 2,\n-                                               item_deltas ) )\n-            return 0;\n-\n-          apaint->u.skew.x_skew_angle += F2DOT14_TO_FIXED( item_deltas[0] );\n-          apaint->u.skew.y_skew_angle += F2DOT14_TO_FIXED( item_deltas[1] );\n-        }\n-\n-        if ( (FT_PaintFormat_Internal)apaint->format ==\n-               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER )\n-        {\n-          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 4,\n-                                               item_deltas ) )\n-            return 0;\n-\n-          apaint->u.skew.x_skew_angle += F2DOT14_TO_FIXED( item_deltas[0] );\n-          apaint->u.skew.y_skew_angle += F2DOT14_TO_FIXED( item_deltas[1] );\n-          apaint->u.skew.center_x     += INT_TO_FIXED( item_deltas[2] );\n-          apaint->u.skew.center_y     += INT_TO_FIXED( item_deltas[3] );\n-        }\n-      }\n-#endif\n-\n@@ -1247,1 +723,0 @@\n-      ENSURE_READ_BYTES( 1 );\n@@ -1399,1 +874,1 @@\n-    \/* glyph ids; for now we can expect it to be 1.                    *\/\n+    \/* glyph ids; for now we can expect it to be 0.                    *\/\n@@ -1427,1 +902,1 @@\n-        if ( format > 2 )\n+        if ( format > 1 )\n@@ -1441,1 +916,1 @@\n-                                        face->root.size->metrics.y_scale );\n+                                        face->root.size->metrics.x_scale );\n@@ -1445,30 +920,1 @@\n-                                        face->root.size->metrics.y_scale );\n-\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-        if ( format == 2 )\n-        {\n-          FT_ULong         var_index_base = 0;\n-          \/* varIndexBase offset for clipbox is 3 at most. *\/\n-          FT_ItemVarDelta  item_deltas[4] = { 0, 0, 0, 0 };\n-\n-\n-          \/* Check whether we can extract a 32-bit varIndexBase now. *\/\n-          if ( p1 > limit - 4 )\n-            return 0;\n-\n-          var_index_base = FT_NEXT_ULONG( p1 );\n-\n-          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 4,\n-                                               item_deltas ) )\n-            return 0;\n-\n-          font_clip_box.xMin +=\n-            FT_MulFix( item_deltas[0], face->root.size->metrics.x_scale );\n-          font_clip_box.yMin +=\n-            FT_MulFix( item_deltas[1], face->root.size->metrics.y_scale );\n-          font_clip_box.xMax +=\n-            FT_MulFix( item_deltas[2], face->root.size->metrics.x_scale );\n-          font_clip_box.yMax +=\n-            FT_MulFix( item_deltas[3], face->root.size->metrics.y_scale );\n-        }\n-#endif\n+                                        face->root.size->metrics.x_scale );\n@@ -1542,0 +988,7 @@\n+    \/*\n+     * First ensure that p is within COLRv1.\n+     *\/\n+    if ( p < colr->layers_v1                               ||\n+         p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n@@ -1558,8 +1011,0 @@\n-    \/*\n-     * Before reading, ensure that `p` is within 'COLR' v1 and we can read a\n-     * 4-byte ULONG.\n-     *\/\n-    if ( p < colr->layers_v1                              ||\n-         p > (FT_Byte*)colr->table + colr->table_size - 4 )\n-      return 0;\n-\n@@ -1595,3 +1040,0 @@\n-    FT_ULong  var_index_base;\n-    FT_Byte*  last_entry_p = NULL;\n-    FT_UInt   entry_size   = COLOR_STOP_SIZE;\n@@ -1600,1 +1042,1 @@\n-    if ( !colr || !colr->table || !iterator )\n+    if ( !colr || !colr->table )\n@@ -1606,13 +1048,4 @@\n-    if ( iterator->read_variable )\n-      entry_size += VAR_IDX_BASE_SIZE;\n-\n-    \/* Calculate the start pointer for the last to-be-read (Var)ColorStop *\/\n-    \/* and check whether we can read a full (Var)ColorStop at that        *\/\n-    \/* position by comparing it to the position that is the size of one   *\/\n-    \/* (Var)ColorStop before the end of the 'COLR' table.                 *\/\n-    last_entry_p =\n-      iterator->p + ( iterator->num_color_stops - 1 -\n-                      iterator->current_color_stop ) * entry_size;\n-    if ( iterator->p < colr->paints_start_v1          ||\n-         last_entry_p > (FT_Byte*)colr->table +\n-                        colr->table_size - entry_size )\n+    if ( iterator->p +\n+           ( ( iterator->num_color_stops - iterator->current_color_stop ) *\n+             COLOR_STOP_SIZE ) >\n+         ( (FT_Byte *)colr->table + colr->table_size ) )\n@@ -1624,1 +1057,1 @@\n-    color_stop->stop_offset = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+    color_stop->stop_offset = FT_NEXT_SHORT( p );\n@@ -1630,26 +1063,0 @@\n-    if ( iterator->read_variable )\n-    {\n-      \/* Pointer p needs to be advanced independently of whether we intend *\/\n-      \/* to take variable deltas into account or not.  Otherwise iteration *\/\n-      \/* would fail due to wrong offsets.                                  *\/\n-      var_index_base = FT_NEXT_ULONG( p );\n-\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-      {\n-        FT_Int  item_deltas[2];\n-\n-\n-        if ( !get_deltas_for_var_index_base( face, colr,\n-                                             var_index_base,\n-                                             2,\n-                                             item_deltas ) )\n-          return 0;\n-\n-        color_stop->stop_offset += F2DOT14_TO_FIXED( item_deltas[0] );\n-        color_stop->color.alpha += item_deltas[1];\n-      }\n-#else\n-      FT_UNUSED( var_index_base );\n-#endif\n-    }\n-\n@@ -1735,1 +1142,1 @@\n-    return read_paint( face, colr, opaque_paint.p, paint );\n+    return read_paint( colr, opaque_paint.p, paint );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcolr.c","additions":69,"deletions":662,"binary":false,"changes":731,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcolr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcpal.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2023 by\n+ * Copyright (C) 2018-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcpal.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttkern.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttkern.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -209,1 +209,1 @@\n-                    \" can read only %hu table%s in font (instead of %hu)\\n\",\n+                    \" can read only %d table%s in font (instead of %d)\\n\",\n@@ -219,1 +219,1 @@\n-        FT_TRACE2(( \"check_table_dir: table entry %hu invalid\\n\", nn ));\n+        FT_TRACE2(( \"check_table_dir: table entry %d invalid\\n\", nn ));\n@@ -234,1 +234,1 @@\n-          FT_TRACE2(( \"check_table_dir: table entry %hu invalid\\n\", nn ));\n+          FT_TRACE2(( \"check_table_dir: table entry %d invalid\\n\", nn ));\n@@ -383,1 +383,1 @@\n-    FT_TRACE2(( \"-- Number of tables: %10hu\\n\",   sfnt.num_tables ));\n+    FT_TRACE2(( \"-- Number of tables: %10u\\n\",    sfnt.num_tables ));\n@@ -674,2 +674,2 @@\n-    FT_TRACE3(( \"Units per EM: %4hu\\n\", header->Units_Per_EM ));\n-    FT_TRACE3(( \"IndexToLoc:   %4hd\\n\", header->Index_To_Loc_Format ));\n+    FT_TRACE3(( \"Units per EM: %4u\\n\", header->Units_Per_EM ));\n+    FT_TRACE3(( \"IndexToLoc:   %4d\\n\", header->Index_To_Loc_Format ));\n@@ -805,1 +805,1 @@\n-    FT_TRACE3(( \"numGlyphs: %hu\\n\", maxProfile->numGlyphs ));\n+    FT_TRACE3(( \"numGlyphs: %u\\n\", maxProfile->numGlyphs ));\n@@ -1268,5 +1268,5 @@\n-    FT_TRACE3(( \"sTypoAscender:  %4hd\\n\",   os2->sTypoAscender ));\n-    FT_TRACE3(( \"sTypoDescender: %4hd\\n\",   os2->sTypoDescender ));\n-    FT_TRACE3(( \"usWinAscent:    %4hu\\n\",   os2->usWinAscent ));\n-    FT_TRACE3(( \"usWinDescent:   %4hu\\n\",   os2->usWinDescent ));\n-    FT_TRACE3(( \"fsSelection:    0x%2hx\\n\", os2->fsSelection ));\n+    FT_TRACE3(( \"sTypoAscender:  %4d\\n\",   os2->sTypoAscender ));\n+    FT_TRACE3(( \"sTypoDescender: %4d\\n\",   os2->sTypoDescender ));\n+    FT_TRACE3(( \"usWinAscent:    %4u\\n\",   os2->usWinAscent ));\n+    FT_TRACE3(( \"usWinDescent:   %4u\\n\",   os2->usWinDescent ));\n+    FT_TRACE3(( \"fsSelection:    0x%2x\\n\", os2->fsSelection ));\n@@ -1471,1 +1471,1 @@\n-      FT_TRACE3(( \"gaspRange %hu: rangeMaxPPEM %5hu, rangeGaspBehavior 0x%hx\\n\",\n+      FT_TRACE3(( \"gaspRange %d: rangeMaxPPEM %5d, rangeGaspBehavior 0x%x\\n\",\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttload.c","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n@@ -309,1 +309,1 @@\n-    if ( var && face->blend )\n+    if ( var )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttmtx.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2023 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttmtx.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -61,1 +61,1 @@\n-#else \/* !FT_CONFIG_OPTION_POSTSCRIPT_NAMES *\/\n+#else \/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES *\/\n@@ -155,1 +155,1 @@\n-#endif \/* !FT_CONFIG_OPTION_POSTSCRIPT_NAMES *\/\n+#endif \/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttpost.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttpost.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2023 by\n+ * Copyright (C) 2005-2022 by\n@@ -388,1 +388,2 @@\n-        metrics->x_scale = FT_DivFix( metrics->x_ppem * 64,\n+        metrics->x_scale = FT_MulDiv( metrics->x_ppem,\n+                                      64 * 0x10000,\n@@ -390,1 +391,2 @@\n-        metrics->y_scale = FT_DivFix( metrics->y_ppem * 64,\n+        metrics->y_scale = FT_MulDiv( metrics->y_ppem,\n+                                      64 * 0x10000,\n@@ -400,1 +402,1 @@\n-        FT_UShort       ppem, resolution;\n+        FT_UShort       upem, ppem, resolution;\n@@ -402,1 +404,1 @@\n-        FT_Fixed        scale;\n+        FT_Pos          ppem_; \/* to reduce casts *\/\n@@ -425,0 +427,3 @@\n+        upem = face->header.Units_Per_EM;\n+        hori = &face->horizontal;\n+\n@@ -428,2 +433,1 @@\n-        scale = FT_DivFix( ppem * 64, face->header.Units_Per_EM );\n-        hori  = &face->horizontal;\n+        ppem_ = (FT_Pos)ppem;\n@@ -431,6 +435,9 @@\n-        metrics->ascender    = FT_MulFix( hori->Ascender, scale );\n-        metrics->descender   = FT_MulFix( hori->Descender, scale );\n-        metrics->height      =\n-          FT_MulFix( hori->Ascender - hori->Descender + hori->Line_Gap,\n-                     scale );\n-        metrics->max_advance = FT_MulFix( hori->advance_Width_Max, scale );\n+        metrics->ascender =\n+          FT_MulDiv( hori->Ascender, ppem_ * 64, upem );\n+        metrics->descender =\n+          FT_MulDiv( hori->Descender, ppem_ * 64, upem );\n+        metrics->height =\n+          FT_MulDiv( hori->Ascender - hori->Descender + hori->Line_Gap,\n+                     ppem_ * 64, upem );\n+        metrics->max_advance =\n+          FT_MulDiv( hori->advance_Width_Max, ppem_ * 64, upem );\n@@ -440,2 +447,6 @@\n-        metrics->x_scale = scale;\n-        metrics->y_scale = scale;\n+        metrics->x_scale = FT_MulDiv( metrics->x_ppem,\n+                                      64 * 0x10000,\n+                                      face->header.Units_Per_EM );\n+        metrics->y_scale = FT_MulDiv( metrics->y_ppem,\n+                                      64 * 0x10000,\n+                                      face->header.Units_Per_EM );\n@@ -1196,1 +1207,1 @@\n-        FALL_THROUGH;\n+        \/* fall-through *\/\n@@ -1596,1 +1607,1 @@\n-  FT_LOCAL_DEF( FT_Error )\n+  FT_LOCAL( FT_Error )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttsbit.c","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttsbit.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2023 by\n+ * Copyright (C) 2019-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/woff2tags.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2023 by\n+ * Copyright (C) 2019-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/woff2tags.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n@@ -421,15 +421,15 @@\n-#define FT_GRAY_SET( d, s, count )                   \\\n-  FT_BEGIN_STMNT                                     \\\n-    unsigned char* q = d;                            \\\n-    switch ( count )                                 \\\n-    {                                                \\\n-      case 7: *q++ = (unsigned char)s; FALL_THROUGH; \\\n-      case 6: *q++ = (unsigned char)s; FALL_THROUGH; \\\n-      case 5: *q++ = (unsigned char)s; FALL_THROUGH; \\\n-      case 4: *q++ = (unsigned char)s; FALL_THROUGH; \\\n-      case 3: *q++ = (unsigned char)s; FALL_THROUGH; \\\n-      case 2: *q++ = (unsigned char)s; FALL_THROUGH; \\\n-      case 1: *q   = (unsigned char)s; FALL_THROUGH; \\\n-      case 0: break;                                 \\\n-      default: FT_MEM_SET( d, s, count );            \\\n-    }                                                \\\n+#define FT_GRAY_SET( d, s, count )                          \\\n+  FT_BEGIN_STMNT                                            \\\n+    unsigned char* q = d;                                   \\\n+    switch ( count )                                        \\\n+    {                                                       \\\n+      case 7: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 6: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 5: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 4: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 3: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 2: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 1: *q   = (unsigned char)s; \/* fall through *\/   \\\n+      case 0: break;                                        \\\n+      default: FT_MEM_SET( d, s, count );                   \\\n+    }                                                       \\\n@@ -1912,1 +1912,1 @@\n-  gray_convert_glyph_inner( RAS_ARG_\n+  gray_convert_glyph_inner( RAS_ARG,\n@@ -1915,1 +1915,1 @@\n-    volatile int  error;\n+    int  error;\n@@ -2007,1 +2007,1 @@\n-        error     = gray_convert_glyph_inner( RAS_VAR_ continued );\n+        error     = gray_convert_glyph_inner( RAS_VAR, continued );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftgrays.c","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftgrays.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmerrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2023 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmooth.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmooth.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -510,28 +510,13 @@\n-    (FT_Get_MM_Func)        NULL,                  \/* get_mm                    *\/\n-    (FT_Set_MM_Design_Func) NULL,                  \/* set_mm_design             *\/\n-    (FT_Set_MM_Blend_Func)  TT_Set_MM_Blend,       \/* set_mm_blend              *\/\n-    (FT_Get_MM_Blend_Func)  TT_Get_MM_Blend,       \/* get_mm_blend              *\/\n-    (FT_Get_MM_Var_Func)    TT_Get_MM_Var,         \/* get_mm_var                *\/\n-    (FT_Set_Var_Design_Func)TT_Set_Var_Design,     \/* set_var_design            *\/\n-    (FT_Get_Var_Design_Func)TT_Get_Var_Design,     \/* get_var_design            *\/\n-    (FT_Set_Instance_Func)  TT_Set_Named_Instance, \/* set_instance              *\/\n-    (FT_Set_MM_WeightVector_Func)\n-                            NULL,                  \/* set_mm_weightvector       *\/\n-    (FT_Get_MM_WeightVector_Func)\n-                            NULL,                  \/* get_mm_weightvector       *\/\n-    (FT_Var_Load_Delta_Set_Idx_Map_Func)\n-                            tt_var_load_delta_set_index_mapping,\n-                                                   \/* load_delta_set_idx_map    *\/\n-    (FT_Var_Load_Item_Var_Store_Func)\n-                            tt_var_load_item_variation_store,\n-                                                   \/* load_item_variation_store *\/\n-    (FT_Var_Get_Item_Delta_Func)\n-                            tt_var_get_item_delta, \/* get_item_delta            *\/\n-    (FT_Var_Done_Item_Var_Store_Func)\n-                            tt_var_done_item_variation_store,\n-                                                   \/* done_item_variation_store *\/\n-    (FT_Var_Done_Delta_Set_Idx_Map_Func)\n-                            tt_var_done_delta_set_index_map,\n-                                                   \/* done_delta_set_index_map  *\/\n-    (FT_Get_Var_Blend_Func) tt_get_var_blend,      \/* get_var_blend             *\/\n-    (FT_Done_Blend_Func)    tt_done_blend          \/* done_blend                *\/\n+    (FT_Get_MM_Func)             NULL,                  \/* get_mm              *\/\n+    (FT_Set_MM_Design_Func)      NULL,                  \/* set_mm_design       *\/\n+    (FT_Set_MM_Blend_Func)       TT_Set_MM_Blend,       \/* set_mm_blend        *\/\n+    (FT_Get_MM_Blend_Func)       TT_Get_MM_Blend,       \/* get_mm_blend        *\/\n+    (FT_Get_MM_Var_Func)         TT_Get_MM_Var,         \/* get_mm_var          *\/\n+    (FT_Set_Var_Design_Func)     TT_Set_Var_Design,     \/* set_var_design      *\/\n+    (FT_Get_Var_Design_Func)     TT_Get_Var_Design,     \/* get_var_design      *\/\n+    (FT_Set_Instance_Func)       TT_Set_Named_Instance, \/* set_instance        *\/\n+    (FT_Set_MM_WeightVector_Func)NULL,                  \/* set_mm_weightvector *\/\n+    (FT_Get_MM_WeightVector_Func)NULL,                  \/* get_mm_weightvector *\/\n+\n+    (FT_Get_Var_Blend_Func)      tt_get_var_blend,      \/* get_var_blend       *\/\n+    (FT_Done_Blend_Func)         tt_done_blend          \/* done_blend          *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttdriver.c","additions":14,"deletions":29,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttdriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/tterrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -740,1 +740,1 @@\n-                      (double)subglyph->transform.xx \/ 65536 ));\n+                      subglyph->transform.xx \/ 65536.0 ));\n@@ -743,2 +743,2 @@\n-                      (double)subglyph->transform.xx \/ 65536,\n-                      (double)subglyph->transform.yy \/ 65536 ));\n+                      subglyph->transform.xx \/ 65536.0,\n+                      subglyph->transform.yy \/ 65536.0 ));\n@@ -748,2 +748,2 @@\n-                      (double)subglyph->transform.xx \/ 65536,\n-                      (double)subglyph->transform.yx \/ 65536 ));\n+                      subglyph->transform.xx \/ 65536.0,\n+                      subglyph->transform.yx \/ 65536.0 ));\n@@ -751,2 +751,2 @@\n-                      (double)subglyph->transform.xy \/ 65536,\n-                      (double)subglyph->transform.yy \/ 65536 ));\n+                      subglyph->transform.xy \/ 65536.0,\n+                      subglyph->transform.yy \/ 65536.0 ));\n@@ -804,1 +804,1 @@\n-    zone->n_points    = (FT_UShort)load->outline.n_points + 4 -\n+    zone->n_points    = (FT_UShort)load->outline.n_points -\n@@ -973,0 +973,5 @@\n+    outline->tags[n_points    ] = 0;\n+    outline->tags[n_points + 1] = 0;\n+    outline->tags[n_points + 2] = 0;\n+    outline->tags[n_points + 3] = 0;\n+\n@@ -983,1 +988,2 @@\n-      error = TT_Vary_Apply_Glyph_Deltas( loader,\n+      error = TT_Vary_Apply_Glyph_Deltas( loader->face,\n+                                          loader->glyph_index,\n@@ -985,1 +991,15 @@\n-                                          unrounded );\n+                                          unrounded,\n+                                          (FT_UInt)n_points );\n+\n+      \/* recalculate linear horizontal and vertical advances *\/\n+      \/* if we don't have HVAR and VVAR, respectively        *\/\n+\n+      \/* XXX: change all FreeType modules to store `linear' and `vadvance' *\/\n+      \/*      in 26.6 format before the `base' module scales them to 16.16 *\/\n+      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n+        loader->linear = FT_PIX_ROUND( unrounded[n_points - 3].x -\n+                                       unrounded[n_points - 4].x ) \/ 64;\n+      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n+        loader->vadvance = FT_PIX_ROUND( unrounded[n_points - 1].x -\n+                                         unrounded[n_points - 2].x ) \/ 64;\n+\n@@ -997,1 +1017,1 @@\n-                     loader->zone.n_points );\n+                     loader->zone.n_points + 4 );\n@@ -1139,0 +1159,3 @@\n+    {\n+      loader->zone.n_points += 4;\n+\n@@ -1140,0 +1163,1 @@\n+    }\n@@ -1352,0 +1376,5 @@\n+    outline->tags[outline->n_points    ] = 0;\n+    outline->tags[outline->n_points + 1] = 0;\n+    outline->tags[outline->n_points + 2] = 0;\n+    outline->tags[outline->n_points + 3] = 0;\n+\n@@ -1410,1 +1439,1 @@\n-    for ( i = 0; i < loader->zone.n_points - 4U; i++ )\n+    for ( i = 0; i < loader->zone.n_points; i++ )\n@@ -1413,0 +1442,2 @@\n+    loader->zone.n_points += 4;\n+\n@@ -1733,0 +1764,2 @@\n+        char        tags[4]     = { 1, 1, 1, 1 };\n+        short       contours[4] = { 0, 1, 2, 3 };\n@@ -1739,4 +1772,9 @@\n-        points[0] = loader->pp1;\n-        points[1] = loader->pp2;\n-        points[2] = loader->pp3;\n-        points[3] = loader->pp4;\n+        points[0].x = loader->pp1.x;\n+        points[0].y = loader->pp1.y;\n+        points[1].x = loader->pp2.x;\n+        points[1].y = loader->pp2.y;\n+\n+        points[2].x = loader->pp3.x;\n+        points[2].y = loader->pp3.y;\n+        points[3].x = loader->pp4.x;\n+        points[3].y = loader->pp4.y;\n@@ -1744,2 +1782,2 @@\n-        outline.n_points   = 0;\n-        outline.n_contours = 0;\n+        outline.n_points   = 4;\n+        outline.n_contours = 4;\n@@ -1747,2 +1785,2 @@\n-        outline.tags       = NULL;\n-        outline.contours   = NULL;\n+        outline.tags       = tags;\n+        outline.contours   = contours;\n@@ -1751,1 +1789,2 @@\n-        error = TT_Vary_Apply_Glyph_Deltas( loader,\n+        error = TT_Vary_Apply_Glyph_Deltas( loader->face,\n+                                            glyph_index,\n@@ -1753,1 +1792,2 @@\n-                                            unrounded );\n+                                            unrounded,\n+                                            (FT_UInt)outline.n_points );\n@@ -1756,0 +1796,19 @@\n+\n+        loader->pp1.x = points[0].x;\n+        loader->pp1.y = points[0].y;\n+        loader->pp2.x = points[1].x;\n+        loader->pp2.y = points[1].y;\n+\n+        loader->pp3.x = points[2].x;\n+        loader->pp3.y = points[2].y;\n+        loader->pp4.x = points[3].x;\n+        loader->pp4.y = points[3].y;\n+\n+        \/* recalculate linear horizontal and vertical advances *\/\n+        \/* if we don't have HVAR and VVAR, respectively        *\/\n+        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n+          loader->linear = FT_PIX_ROUND( unrounded[1].x -\n+                                         unrounded[0].x ) \/ 64;\n+        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n+          loader->vadvance = FT_PIX_ROUND( unrounded[3].x -\n+                                           unrounded[2].x ) \/ 64;\n@@ -1903,1 +1962,2 @@\n-        outline.n_contours = outline.n_points = limit;\n+        outline.n_points   = (short)( gloader->current.num_subglyphs + 4 );\n+        outline.n_contours = outline.n_points;\n@@ -1909,4 +1969,4 @@\n-        if ( FT_NEW_ARRAY( points, limit + 4 )    ||\n-             FT_NEW_ARRAY( tags, limit + 4 )      ||\n-             FT_NEW_ARRAY( contours, limit + 4 )  ||\n-             FT_NEW_ARRAY( unrounded, limit + 4 ) )\n+        if ( FT_NEW_ARRAY( points, outline.n_points )    ||\n+             FT_NEW_ARRAY( tags, outline.n_points )      ||\n+             FT_NEW_ARRAY( contours, outline.n_points )  ||\n+             FT_NEW_ARRAY( unrounded, outline.n_points ) )\n@@ -1928,4 +1988,22 @@\n-        points[i++] = loader->pp1;\n-        points[i++] = loader->pp2;\n-        points[i++] = loader->pp3;\n-        points[i  ] = loader->pp4;\n+        points[i].x = loader->pp1.x;\n+        points[i].y = loader->pp1.y;\n+        tags[i]     = 1;\n+        contours[i] = i;\n+\n+        i++;\n+        points[i].x = loader->pp2.x;\n+        points[i].y = loader->pp2.y;\n+        tags[i]     = 1;\n+        contours[i] = i;\n+\n+        i++;\n+        points[i].x = loader->pp3.x;\n+        points[i].y = loader->pp3.y;\n+        tags[i]     = 1;\n+        contours[i] = i;\n+\n+        i++;\n+        points[i].x = loader->pp4.x;\n+        points[i].y = loader->pp4.y;\n+        tags[i]     = 1;\n+        contours[i] = i;\n@@ -1939,3 +2017,6 @@\n-        if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas( loader,\n-                                                       &outline,\n-                                                       unrounded ) ) )\n+        if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(\n+                             face,\n+                             glyph_index,\n+                             &outline,\n+                             unrounded,\n+                             (FT_UInt)outline.n_points ) ) )\n@@ -1955,0 +2036,21 @@\n+        loader->pp1.x = points[i + 0].x;\n+        loader->pp1.y = points[i + 0].y;\n+        loader->pp2.x = points[i + 1].x;\n+        loader->pp2.y = points[i + 1].y;\n+\n+        loader->pp3.x = points[i + 2].x;\n+        loader->pp3.y = points[i + 2].y;\n+        loader->pp4.x = points[i + 3].x;\n+        loader->pp4.y = points[i + 3].y;\n+\n+        \/* recalculate linear horizontal and vertical advances *\/\n+        \/* if we don't have HVAR and VVAR, respectively        *\/\n+        if ( !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n+          loader->linear =\n+            FT_PIX_ROUND( unrounded[outline.n_points - 3].x -\n+                          unrounded[outline.n_points - 4].x ) \/ 64;\n+        if ( !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n+          loader->vadvance =\n+            FT_PIX_ROUND( unrounded[outline.n_points - 1].x -\n+                          unrounded[outline.n_points - 2].x ) \/ 64;\n+\n@@ -2130,3 +2232,2 @@\n-    TT_Face       face  = loader->face;\n-    TT_Size       size  = loader->size;\n-    TT_GlyphSlot  glyph = loader->glyph;\n+    TT_Face    face   = loader->face;\n+\n@@ -2135,0 +2236,2 @@\n+    TT_GlyphSlot  glyph = loader->glyph;\n+    TT_Size       size  = loader->size;\n@@ -2272,3 +2375,3 @@\n-    TT_Face             face   = (TT_Face)glyph->face;\n-    SFNT_Service        sfnt   = (SFNT_Service)face->sfnt;\n-    FT_Stream           stream = face->root.stream;\n+    TT_Face             face;\n+    SFNT_Service        sfnt;\n+    FT_Stream           stream;\n@@ -2279,0 +2382,4 @@\n+    face   = (TT_Face)glyph->face;\n+    sfnt   = (SFNT_Service)face->sfnt;\n+    stream = face->root.stream;\n+\n@@ -2329,2 +2436,2 @@\n-    TT_Face    face   = (TT_Face)glyph->face;\n-    FT_Stream  stream = face->root.stream;\n+    TT_Face    face;\n+    FT_Stream  stream;\n@@ -2337,1 +2444,1 @@\n-    TT_Driver  driver   = (TT_Driver)FT_FACE_DRIVER( glyph->face );\n+    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( (TT_Face)glyph->face );\n@@ -2342,0 +2449,3 @@\n+    face   = (TT_Face)glyph->face;\n+    stream = face->root.stream;\n+\n@@ -2709,1 +2819,0 @@\n-    TT_Face       face = (TT_Face)glyph->face;\n@@ -2734,0 +2843,2 @@\n+          TT_Face  face = (TT_Face)glyph->face;\n+\n@@ -2792,0 +2903,3 @@\n+          TT_Face  face = (TT_Face)glyph->face;\n+\n+\n@@ -2860,1 +2974,1 @@\n-    if ( ( load_flags & FT_LOAD_COLOR ) && face->svg )\n+    if ( ( load_flags & FT_LOAD_COLOR ) && ( (TT_Face)glyph->face )->svg )\n@@ -2862,1 +2976,6 @@\n-      SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n+      SFNT_Service  sfnt;\n+\n+      FT_Short   leftBearing;\n+      FT_Short   topBearing;\n+      FT_UShort  advanceX;\n+      FT_UShort  advanceY;\n@@ -2866,0 +2985,1 @@\n+      sfnt = (SFNT_Service)( (TT_Face)glyph->face )->sfnt;\n@@ -2870,7 +2990,1 @@\n-        FT_Fixed  x_scale = size->root.metrics.x_scale;\n-        FT_Fixed  y_scale = size->root.metrics.y_scale;\n-\n-        FT_Short   leftBearing;\n-        FT_Short   topBearing;\n-        FT_UShort  advanceX;\n-        FT_UShort  advanceY;\n+        TT_Face  face = (TT_Face)glyph->face;\n@@ -2894,2 +3008,6 @@\n-        glyph->linearHoriAdvance = advanceX;\n-        glyph->linearVertAdvance = advanceY;\n+        advanceX = (FT_UShort)FT_MulDiv( advanceX,\n+                                         glyph->face->size->metrics.x_ppem,\n+                                         glyph->face->units_per_EM );\n+        advanceY = (FT_UShort)FT_MulDiv( advanceY,\n+                                         glyph->face->size->metrics.y_ppem,\n+                                         glyph->face->units_per_EM );\n@@ -2897,2 +3015,2 @@\n-        glyph->metrics.horiAdvance = FT_MulFix( advanceX, x_scale );\n-        glyph->metrics.vertAdvance = FT_MulFix( advanceY, y_scale );\n+        glyph->metrics.horiAdvance = advanceX << 6;\n+        glyph->metrics.vertAdvance = advanceY << 6;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgload.c","additions":176,"deletions":58,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n@@ -45,1 +45,0 @@\n-#include <freetype\/internal\/ftcalc.h>\n@@ -357,5 +356,2 @@\n-    FT_Error   error;\n-    FT_Stream  stream = FT_FACE_STREAM( face );\n-    FT_Memory  memory = stream->memory;\n-    FT_Int     i, j;\n-\n+    FT_Stream       stream = FT_FACE_STREAM( face );\n+    FT_Memory       memory = stream->memory;\n@@ -364,11 +360,5 @@\n-    GX_AVarTable    table;\n-\n-    FT_Long   version;\n-    FT_Long   axisCount;\n-    FT_ULong  table_len;\n-\n-#ifndef TT_CONFIG_OPTION_NO_BORING_EXPANSION\n-    FT_ULong  table_offset;\n-    FT_ULong  store_offset;\n-    FT_ULong  axisMap_offset;\n-#endif\n+    FT_Error        error;\n+    FT_Long         version;\n+    FT_Long         axisCount;\n+    FT_Int          i, j;\n+    FT_ULong        table_len;\n@@ -387,4 +377,0 @@\n-#ifndef TT_CONFIG_OPTION_NO_BORING_EXPANSION\n-    table_offset = FT_STREAM_POS();\n-#endif\n-\n@@ -397,5 +383,1 @@\n-    if ( version != 0x00010000L\n-#ifndef TT_CONFIG_OPTION_NO_BORING_EXPANSION\n-         && version != 0x00020000L\n-#endif\n-       )\n+    if ( version != 0x00010000L )\n@@ -417,1 +399,1 @@\n-    if ( FT_NEW( blend->avar_table ) )\n+    if ( FT_QNEW_ARRAY( blend->avar_segment, axisCount ) )\n@@ -419,1 +401,0 @@\n-    table = blend->avar_table;\n@@ -421,4 +402,1 @@\n-    if ( FT_QNEW_ARRAY( table->avar_segment, axisCount ) )\n-      goto Exit;\n-\n-    segment = &table->avar_segment[0];\n+    segment = &blend->avar_segment[0];\n@@ -437,1 +415,1 @@\n-          FT_FREE( table->avar_segment[j].correspondence );\n+          FT_FREE( blend->avar_segment[j].correspondence );\n@@ -439,1 +417,1 @@\n-        FT_FREE( table->avar_segment );\n+        FT_FREE( blend->avar_segment );\n@@ -451,2 +429,2 @@\n-                    (double)segment->correspondence[j].fromCoord \/ 65536,\n-                    (double)segment->correspondence[j].toCoord \/ 65536 ));\n+                    segment->correspondence[j].fromCoord \/ 65536.0,\n+                    segment->correspondence[j].toCoord \/ 65536.0 ));\n@@ -458,31 +436,0 @@\n-#ifndef TT_CONFIG_OPTION_NO_BORING_EXPANSION\n-    if ( version < 0x00020000L )\n-      goto Exit;\n-\n-    axisMap_offset = FT_GET_ULONG();\n-    store_offset   = FT_GET_ULONG();\n-\n-    if ( store_offset )\n-    {\n-      error = tt_var_load_item_variation_store(\n-                face,\n-                table_offset + store_offset,\n-                &table->itemStore );\n-      if ( error )\n-        goto Exit;\n-    }\n-\n-    if ( axisMap_offset )\n-    {\n-      error = tt_var_load_delta_set_index_mapping(\n-                face,\n-                table_offset + axisMap_offset,\n-                &table->axisMap,\n-                &table->itemStore,\n-                table_len );\n-      if ( error )\n-        goto Exit;\n-    }\n-#endif\n-\n-\n@@ -494,2 +441,2 @@\n-  FT_LOCAL_DEF( FT_Error )\n-  tt_var_load_item_variation_store( TT_Face          face,\n+  static FT_Error\n+  ft_var_load_item_variation_store( TT_Face          face,\n@@ -505,0 +452,3 @@\n+    FT_UInt    i, j, k;\n+    FT_UInt    wordDeltaCount;\n+    FT_Bool    long_words;\n@@ -506,6 +456,2 @@\n-    FT_UInt    data_count;\n-    FT_UShort  axis_count;\n-    FT_UInt    region_count;\n-\n-    FT_UInt  i, j, k;\n-    FT_Bool  long_words;\n+    GX_Blend        blend = face->blend;\n+    GX_ItemVarData  varData;\n@@ -513,1 +459,0 @@\n-    GX_Blend   blend           = face->blend;\n@@ -523,1 +468,1 @@\n-      FT_TRACE2(( \"tt_var_load_item_variation_store: bad store format %d\\n\",\n+      FT_TRACE2(( \"ft_var_load_item_variation_store: bad store format %d\\n\",\n@@ -530,2 +475,2 @@\n-    if ( FT_READ_ULONG( region_offset ) ||\n-         FT_READ_USHORT( data_count )   )\n+    if ( FT_READ_ULONG( region_offset )         ||\n+         FT_READ_USHORT( itemStore->dataCount ) )\n@@ -535,1 +480,1 @@\n-    if ( !data_count )\n+    if ( !itemStore->dataCount )\n@@ -537,1 +482,1 @@\n-      FT_TRACE2(( \"tt_var_load_item_variation_store: missing varData\\n\" ));\n+      FT_TRACE2(( \"ft_var_load_item_variation_store: missing varData\\n\" ));\n@@ -544,1 +489,1 @@\n-    if ( FT_QNEW_ARRAY( dataOffsetArray, data_count ) )\n+    if ( FT_QNEW_ARRAY( dataOffsetArray, itemStore->dataCount ) )\n@@ -547,1 +492,1 @@\n-    for ( i = 0; i < data_count; i++ )\n+    for ( i = 0; i < itemStore->dataCount; i++ )\n@@ -557,2 +502,2 @@\n-    if ( FT_READ_USHORT( axis_count )   ||\n-         FT_READ_USHORT( region_count ) )\n+    if ( FT_READ_USHORT( itemStore->axisCount )   ||\n+         FT_READ_USHORT( itemStore->regionCount ) )\n@@ -561,1 +506,1 @@\n-    if ( axis_count != (FT_Long)blend->mmvar->num_axis )\n+    if ( itemStore->axisCount != (FT_Long)blend->mmvar->num_axis )\n@@ -563,1 +508,1 @@\n-      FT_TRACE2(( \"tt_var_load_item_variation_store:\"\n+      FT_TRACE2(( \"ft_var_load_item_variation_store:\"\n@@ -570,1 +515,0 @@\n-    itemStore->axisCount = axis_count;\n@@ -573,1 +517,1 @@\n-    if ( region_count >= 32768U )\n+    if ( itemStore->regionCount >= 32768U )\n@@ -575,1 +519,1 @@\n-      FT_TRACE2(( \"tt_var_load_item_variation_store:\"\n+      FT_TRACE2(( \"ft_var_load_item_variation_store:\"\n@@ -581,1 +525,1 @@\n-    if ( FT_NEW_ARRAY( itemStore->varRegionList, region_count ) )\n+    if ( FT_NEW_ARRAY( itemStore->varRegionList, itemStore->regionCount ) )\n@@ -583,1 +527,0 @@\n-    itemStore->regionCount = region_count;\n@@ -590,1 +533,2 @@\n-      if ( FT_NEW_ARRAY( itemStore->varRegionList[i].axisList, axis_count ) )\n+      if ( FT_NEW_ARRAY( itemStore->varRegionList[i].axisList,\n+                         itemStore->axisCount ) )\n@@ -614,1 +558,1 @@\n-    if ( FT_NEW_ARRAY( itemStore->varData, data_count ) )\n+    if ( FT_NEW_ARRAY( itemStore->varData, itemStore->dataCount ) )\n@@ -616,1 +560,0 @@\n-    itemStore->dataCount = data_count;\n@@ -618,1 +561,1 @@\n-    for ( i = 0; i < data_count; i++ )\n+    for ( i = 0; i < itemStore->dataCount; i++ )\n@@ -620,6 +563,1 @@\n-      GX_ItemVarData  varData = &itemStore->varData[i];\n-\n-      FT_UInt  item_count;\n-      FT_UInt  word_delta_count;\n-      FT_UInt  region_idx_count;\n-\n+      varData = &itemStore->varData[i];\n@@ -630,3 +568,3 @@\n-      if ( FT_READ_USHORT( item_count )       ||\n-           FT_READ_USHORT( word_delta_count ) ||\n-           FT_READ_USHORT( region_idx_count ) )\n+      if ( FT_READ_USHORT( varData->itemCount )      ||\n+           FT_READ_USHORT( wordDeltaCount )          ||\n+           FT_READ_USHORT( varData->regionIdxCount ) )\n@@ -635,2 +573,2 @@\n-      long_words        = !!( word_delta_count & 0x8000 );\n-      word_delta_count &= 0x7FFF;\n+      long_words      = !!( wordDeltaCount & 0x8000 );\n+      wordDeltaCount &= 0x7FFF;\n@@ -639,1 +577,1 @@\n-      if ( word_delta_count > region_idx_count )\n+      if ( wordDeltaCount > varData->regionIdxCount )\n@@ -642,2 +580,2 @@\n-                    word_delta_count,\n-                    region_idx_count ));\n+                    wordDeltaCount,\n+                    varData->regionIdxCount ));\n@@ -648,1 +586,1 @@\n-      if ( region_idx_count > itemStore->regionCount )\n+      if ( varData->regionIdxCount > itemStore->regionCount )\n@@ -651,1 +589,1 @@\n-                    region_idx_count,\n+                    varData->regionIdxCount,\n@@ -658,1 +596,2 @@\n-      if ( FT_NEW_ARRAY( varData->regionIndices, region_idx_count ) )\n+      if ( FT_NEW_ARRAY( varData->regionIndices,\n+                         varData->regionIdxCount ) )\n@@ -660,1 +599,0 @@\n-      varData->regionIdxCount = region_idx_count;\n@@ -676,7 +614,8 @@\n-      \/* Parse delta set.                                                  *\/\n-      \/*                                                                   *\/\n-      \/* On input, deltas are (word_delta_count + region_idx_count) bytes  *\/\n-      \/* each if `long_words` isn't set, and twice as much otherwise.      *\/\n-      \/*                                                                   *\/\n-      \/* On output, deltas are expanded to `region_idx_count` shorts each. *\/\n-      if ( FT_NEW_ARRAY( varData->deltaSet, item_count * region_idx_count ) )\n+      \/* Parse delta set.                                                *\/\n+      \/*                                                                 *\/\n+      \/* On input, deltas are (wordDeltaCount + regionIdxCount) bytes    *\/\n+      \/* each if `long_words` isn't set, and twice as much otherwise.    *\/\n+      \/*                                                                 *\/\n+      \/* On output, deltas are expanded to `regionIdxCount` shorts each. *\/\n+      if ( FT_NEW_ARRAY( varData->deltaSet,\n+                         varData->regionIdxCount * varData->itemCount ) )\n@@ -684,1 +623,0 @@\n-      varData->itemCount = item_count;\n@@ -686,1 +624,2 @@\n-      for ( j = 0; j < item_count * region_idx_count; )\n+      \/* the delta set is stored as a 2-dimensional array of shorts *\/\n+      if ( long_words )\n@@ -688,10 +627,11 @@\n-        if ( long_words )\n-        {\n-          for ( k = 0; k < word_delta_count; k++, j++ )\n-            if ( FT_READ_LONG( varData->deltaSet[j] ) )\n-              goto Exit;\n-          for ( ; k < region_idx_count; k++, j++ )\n-            if ( FT_READ_SHORT( varData->deltaSet[j] ) )\n-              goto Exit;\n-        }\n-        else\n+        \/* new in OpenType 1.9, currently for 'COLR' table only;          *\/\n+        \/* the deltas are interpreted as 16.16 fixed-point scaling values *\/\n+\n+        \/* not supported yet *\/\n+\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+      else\n+      {\n+        for ( j = 0; j < varData->itemCount * varData->regionIdxCount; )\n@@ -699,2 +639,7 @@\n-          for ( k = 0; k < word_delta_count; k++, j++ )\n-            if ( FT_READ_SHORT( varData->deltaSet[j] ) )\n+          for ( k = 0; k < wordDeltaCount; k++, j++ )\n+          {\n+            \/* read the short deltas *\/\n+            FT_Short  delta;\n+\n+\n+            if ( FT_READ_SHORT( delta ) )\n@@ -702,2 +647,11 @@\n-          for ( ; k < region_idx_count; k++, j++ )\n-            if ( FT_READ_CHAR( varData->deltaSet[j] ) )\n+\n+            varData->deltaSet[j] = delta;\n+          }\n+\n+          for ( ; k < varData->regionIdxCount; k++, j++ )\n+          {\n+            \/* read the (signed) byte deltas *\/\n+            FT_Char  delta;\n+\n+\n+            if ( FT_READ_CHAR( delta ) )\n@@ -705,0 +659,3 @@\n+\n+            varData->deltaSet[j] = delta;\n+          }\n@@ -716,2 +673,2 @@\n-  FT_LOCAL_DEF( FT_Error )\n-  tt_var_load_delta_set_index_mapping( TT_Face            face,\n+  static FT_Error\n+  ft_var_load_delta_set_index_mapping( TT_Face            face,\n@@ -774,1 +731,1 @@\n-      FT_TRACE1(( \"tt_var_load_delta_set_index_mapping:\"\n+      FT_TRACE1(( \"ft_var_load_delta_set_index_mapping:\"\n@@ -804,10 +761,0 @@\n-      \/* new in OpenType 1.8.4 *\/\n-      if ( mapData == 0xFFFFFFFFUL )\n-      {\n-        \/* no variation data for this item *\/\n-        map->outerIndex[i] = 0xFFFFU;\n-        map->innerIndex[i] = 0xFFFFU;\n-\n-        continue;\n-      }\n-\n@@ -943,1 +890,1 @@\n-    error = tt_var_load_item_variation_store(\n+    error = ft_var_load_item_variation_store(\n@@ -952,1 +899,1 @@\n-      error = tt_var_load_delta_set_index_mapping(\n+      error = ft_var_load_delta_set_index_mapping(\n@@ -994,2 +941,2 @@\n-  FT_LOCAL_DEF( FT_ItemVarDelta )\n-  tt_var_get_item_delta( TT_Face          face,\n+  static FT_Int\n+  ft_var_get_item_delta( TT_Face          face,\n@@ -1000,6 +947,2 @@\n-    FT_Stream  stream = FT_FACE_STREAM( face );\n-    FT_Memory  memory = stream->memory;\n-    FT_Error   error  = FT_Err_Ok;\n-\n-    GX_ItemVarData    varData;\n-    FT_ItemVarDelta*  deltaSet;\n+    GX_ItemVarData  varData;\n+    FT_Short*       deltaSet;\n@@ -1007,3 +950,4 @@\n-    FT_UInt          master, j;\n-    FT_Fixed*        scalars = NULL;\n-    FT_ItemVarDelta  returnValue;\n+    FT_UInt   master, j;\n+    FT_Fixed  netAdjustment = 0;     \/* accumulated adjustment *\/\n+    FT_Fixed  scaledDelta;\n+    FT_Fixed  delta;\n@@ -1012,8 +956,0 @@\n-    if ( !face->blend || !face->blend->normalizedcoords )\n-      return 0;\n-\n-    \/* OpenType 1.8.4+: No variation data for this item *\/\n-    \/* as indices have special value 0xFFFF.            *\/\n-    if ( outerIndex == 0xFFFF && innerIndex == 0xFFFF )\n-      return 0;\n-\n@@ -1023,3 +959,0 @@\n-    if ( outerIndex >= itemStore->dataCount )\n-      return 0; \/* Out of range. *\/\n-\n@@ -1027,8 +960,1 @@\n-    deltaSet = FT_OFFSET( varData->deltaSet,\n-                          varData->regionIdxCount * innerIndex );\n-\n-    if ( innerIndex >= varData->itemCount )\n-      return 0; \/* Out of range. *\/\n-\n-    if ( FT_QNEW_ARRAY( scalars, varData->regionIdxCount ) )\n-      return 0;\n+    deltaSet = &varData->deltaSet[varData->regionIdxCount * innerIndex];\n@@ -1085,1 +1011,0 @@\n-\n@@ -1088,1 +1013,3 @@\n-      scalars[master] = scalar;\n+      \/* get the scaled delta for this region *\/\n+      delta       = FT_intToFixed( deltaSet[master] );\n+      scaledDelta = FT_MulFix( scalar, delta );\n@@ -1090,1 +1017,2 @@\n-    } \/* per-region loop *\/\n+      \/* accumulate the adjustments from each region *\/\n+      netAdjustment = netAdjustment + scaledDelta;\n@@ -1092,0 +1020,1 @@\n+    } \/* per-region loop *\/\n@@ -1093,19 +1022,1 @@\n-    \/* Compute the scaled delta for this region.\n-     *\n-     * From: https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/otvarcommonformats#item-variation-store-header-and-item-variation-data-subtables:\n-     *\n-     *   `Fixed` is a 32-bit (16.16) type and, in the general case, requires\n-     *   32-bit deltas.  As described above, the `DeltaSet` record can\n-     *   accommodate deltas that are, logically, either 16-bit or 32-bit.\n-     *   When scaled deltas are applied to `Fixed` values, the `Fixed` value\n-     *   is treated like a 32-bit integer.\n-     *\n-     * `FT_MulAddFix` internally uses 64-bit precision; it thus can handle\n-     * deltas ranging from small 8-bit to large 32-bit values that are\n-     * applied to 16.16 `FT_Fixed` \/ OpenType `Fixed` values.\n-     *\/\n-    returnValue = FT_MulAddFix( scalars, deltaSet, varData->regionIdxCount );\n-\n-    FT_FREE( scalars );\n-\n-    return returnValue;\n+    return FT_fixedToInt( netAdjustment );\n@@ -1204,0 +1115,3 @@\n+      GX_ItemVarData  varData;\n+\n+\n@@ -1207,0 +1121,8 @@\n+\n+      varData = &table->itemStore.varData[outerIndex];\n+      if ( gindex >= varData->itemCount )\n+      {\n+        FT_TRACE2(( \"gindex %d out of range\\n\", gindex ));\n+        error = FT_THROW( Invalid_Argument );\n+        goto Exit;\n+      }\n@@ -1209,1 +1131,1 @@\n-    delta = tt_var_get_item_delta( face,\n+    delta = ft_var_get_item_delta( face,\n@@ -1214,11 +1136,8 @@\n-    if ( delta )\n-    {\n-      FT_TRACE5(( \"%s value %d adjusted by %d unit%s (%s)\\n\",\n-                  vertical ? \"vertical height\" : \"horizontal width\",\n-                  *avalue,\n-                  delta,\n-                  delta == 1 ? \"\" : \"s\",\n-                  vertical ? \"VVAR\" : \"HVAR\" ));\n-\n-      *avalue = ADD_INT( *avalue, delta );\n-    }\n+    FT_TRACE5(( \"%s value %d adjusted by %d unit%s (%s)\\n\",\n+                vertical ? \"vertical height\" : \"horizontal width\",\n+                *avalue,\n+                delta,\n+                delta == 1 ? \"\" : \"s\",\n+                vertical ? \"VVAR\" : \"HVAR\" ));\n+\n+    *avalue += delta;\n@@ -1391,1 +1310,1 @@\n-    error = tt_var_load_item_variation_store(\n+    error = ft_var_load_item_variation_store(\n@@ -1407,1 +1326,1 @@\n-    limit     = FT_OFFSET( value, blend->mvar_table->valueCount );\n+    limit     = value + blend->mvar_table->valueCount;\n@@ -1416,7 +1335,0 @@\n-      \/* new in OpenType 1.8.4 *\/\n-      if ( value->outerIndex == 0xFFFFU && value->innerIndex == 0xFFFFU )\n-      {\n-        \/* no variation data for this item *\/\n-        continue;\n-      }\n-\n@@ -1440,1 +1352,1 @@\n-    limit = FT_OFFSET( value, blend->mvar_table->valueCount );\n+    limit = value + blend->mvar_table->valueCount;\n@@ -1505,1 +1417,1 @@\n-    limit = FT_OFFSET( value, blend->mvar_table->valueCount );\n+    limit = value + blend->mvar_table->valueCount;\n@@ -1513,1 +1425,1 @@\n-      delta = tt_var_get_item_delta( face,\n+      delta = ft_var_get_item_delta( face,\n@@ -1518,1 +1430,1 @@\n-      if ( p && delta )\n+      if ( p )\n@@ -1816,1 +1728,1 @@\n-            (double)blend->tuplecoords[i * gvar_head.axisCount + j] \/ 65536 ));\n+            blend->tuplecoords[i * gvar_head.axisCount + j] \/ 65536.0 ));\n@@ -1887,1 +1799,1 @@\n-                  i, (double)blend->normalizedcoords[i] \/ 65536 ));\n+                  i, blend->normalizedcoords[i] \/ 65536.0 ));\n@@ -1910,1 +1822,1 @@\n-                    (double)tuple_coords[i] \/ 65536 ));\n+                    tuple_coords[i] \/ 65536.0 ));\n@@ -1923,1 +1835,1 @@\n-                      (double)tuple_coords[i] \/ 65536 ));\n+                      tuple_coords[i] \/ 65536.0 ));\n@@ -1929,1 +1841,1 @@\n-                    (double)tuple_coords[i] \/ 65536 ));\n+                    tuple_coords[i] \/ 65536.0 ));\n@@ -1943,2 +1855,2 @@\n-                      (double)im_start_coords[i] \/ 65536,\n-                      (double)im_end_coords[i] \/ 65536 ));\n+                      im_start_coords[i] \/ 65536.0,\n+                      im_end_coords[i] \/ 65536.0 ));\n@@ -1950,2 +1862,2 @@\n-                    (double)im_start_coords[i] \/ 65536,\n-                    (double)im_end_coords[i] \/ 65536 ));\n+                    im_start_coords[i] \/ 65536.0,\n+                    im_end_coords[i] \/ 65536.0 ));\n@@ -1963,1 +1875,1 @@\n-    FT_TRACE6(( \"    apply factor is %.5f\\n\", (double)apply \/ 65536 ));\n+    FT_TRACE6(( \"    apply factor is %.5f\\n\", apply \/ 65536.0 ));\n@@ -1977,4 +1889,0 @@\n-    FT_Error   error  = FT_Err_Ok;\n-    FT_Memory  memory = face->root.memory;\n-    FT_UInt    i, j;\n-\n@@ -1983,0 +1891,1 @@\n+    FT_UInt         i, j;\n@@ -1986,3 +1895,0 @@\n-    FT_Fixed*  new_normalized = NULL;\n-    FT_Fixed*  old_normalized;\n-\n@@ -2011,1 +1917,1 @@\n-      FT_TRACE5(( \"    %d: %.5f\\n\", i, (double)coord \/ 65536 ));\n+      FT_TRACE5(( \"    %d: %.5f\\n\", i, coord \/ 65536.0 ));\n@@ -2015,1 +1921,1 @@\n-                    (double)coord \/ 65536 ));\n+                    coord \/ 65536.0 ));\n@@ -2018,2 +1924,2 @@\n-                    (double)a->minimum \/ 65536,\n-                    (double)a->maximum \/ 65536 ));\n+                    a->minimum \/ 65536.0,\n+                    a->maximum \/ 65536.0 ));\n@@ -2039,1 +1945,1 @@\n-    if ( blend->avar_table )\n+    if ( blend->avar_segment )\n@@ -2041,3 +1947,0 @@\n-      GX_AVarTable  table = blend->avar_table;\n-\n-\n@@ -2047,26 +1950,2 @@\n-      if ( table->avar_segment )\n-      {\n-        av = table->avar_segment;\n-\n-        for ( i = 0; i < mmvar->num_axis; i++, av++ )\n-        {\n-          for ( j = 1; j < (FT_UInt)av->pairCount; j++ )\n-          {\n-            if ( normalized[i] < av->correspondence[j].fromCoord )\n-            {\n-              FT_TRACE5(( \"  %.5f\\n\", (double)normalized[i] \/ 65536 ));\n-\n-              normalized[i] =\n-                FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,\n-                           av->correspondence[j].toCoord -\n-                             av->correspondence[j - 1].toCoord,\n-                           av->correspondence[j].fromCoord -\n-                             av->correspondence[j - 1].fromCoord ) +\n-                av->correspondence[j - 1].toCoord;\n-              break;\n-            }\n-          }\n-        }\n-      }\n-\n-      if ( table->itemStore.varData )\n+      av = blend->avar_segment;\n+      for ( i = 0; i < mmvar->num_axis; i++, av++ )\n@@ -2074,9 +1953,1 @@\n-        if ( FT_QNEW_ARRAY( new_normalized, mmvar->num_axis ) )\n-          return;\n-\n-        \/* Install our half-normalized coordinates for the next *\/\n-        \/* Item Variation Store to work with.                   *\/\n-        old_normalized                = face->blend->normalizedcoords;\n-        face->blend->normalizedcoords = normalized;\n-\n-        for ( i = 0; i < mmvar->num_axis; i++ )\n+        for ( j = 1; j < (FT_UInt)av->pairCount; j++ )\n@@ -2084,7 +1955,1 @@\n-          FT_Fixed  v          = normalized[i];\n-          FT_UInt   innerIndex = i;\n-          FT_UInt   outerIndex = 0;\n-          FT_Int    delta;\n-\n-\n-          if ( table->axisMap.innerIndex )\n+          if ( normalized[i] < av->correspondence[j].fromCoord )\n@@ -2092,1 +1957,1 @@\n-            FT_UInt  idx = i;\n+            FT_TRACE5(( \"  %.5f\\n\", normalized[i] \/ 65536.0 ));\n@@ -2094,6 +1959,8 @@\n-\n-            if ( idx >= table->axisMap.mapCount )\n-              idx = table->axisMap.mapCount - 1;\n-\n-            outerIndex = table->axisMap.outerIndex[idx];\n-            innerIndex = table->axisMap.innerIndex[idx];\n+            normalized[i] =\n+              FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,\n+                         av->correspondence[j].toCoord -\n+                           av->correspondence[j - 1].toCoord,\n+                         av->correspondence[j].fromCoord -\n+                           av->correspondence[j - 1].fromCoord ) +\n+              av->correspondence[j - 1].toCoord;\n+            break;\n@@ -2101,18 +1968,0 @@\n-\n-          delta = tt_var_get_item_delta( face,\n-                                         &table->itemStore,\n-                                         outerIndex,\n-                                         innerIndex );\n-\n-      v += delta << 2;\n-\n-      \/* Clamp value range. *\/\n-      v = v >=  0x10000L ?  0x10000 : v;\n-      v = v <= -0x10000L ? -0x10000 : v;\n-\n-          new_normalized[i] = v;\n-        }\n-\n-        for ( i = 0; i < mmvar->num_axis; i++ )\n-        {\n-          normalized[i] = new_normalized[i];\n@@ -2120,4 +1969,0 @@\n-\n-        face->blend->normalizedcoords = old_normalized;\n-\n-        FT_FREE( new_normalized );\n@@ -2161,1 +2006,1 @@\n-    if ( blend->avar_table && blend->avar_table->avar_segment )\n+    if ( blend->avar_segment )\n@@ -2163,1 +2008,1 @@\n-      GX_AVarSegment  av = blend->avar_table->avar_segment;\n+      GX_AVarSegment  av = blend->avar_segment;\n@@ -2183,1 +2028,1 @@\n-            FT_TRACE5(( \"  %.5f\\n\", (double)design[i] \/ 65536 ));\n+            FT_TRACE5(( \"  %.5f\\n\", design[i] \/ 65536.0 ));\n@@ -2328,5 +2173,0 @@\n-    \/* `num_instances` holds the number of all named instances including  *\/\n-    \/* the default instance, which might be missing in the table of named *\/\n-    \/* instances (in 'fvar').  This value is validated in `sfobjs.c` and  *\/\n-    \/* may be reset to 0 if consistency checks fail.                      *\/\n-    num_instances = (FT_UInt)face->root.style_flags >> 16;\n@@ -2343,0 +2183,14 @@\n+      \/* both `fvar' and `gvar' must be present *\/\n+      if ( FT_SET_ERROR( face->goto_table( face, TTAG_gvar,\n+                                           stream, &table_len ) ) )\n+      {\n+        \/* CFF2 is an alternate to gvar here *\/\n+        if ( FT_SET_ERROR( face->goto_table( face, TTAG_CFF2,\n+                                             stream, &table_len ) ) )\n+        {\n+          FT_TRACE1(( \"\\n\" ));\n+          FT_TRACE1(( \"TT_Get_MM_Var: `gvar' or `CFF2' table is missing\\n\" ));\n+          goto Exit;\n+        }\n+      }\n+\n@@ -2357,11 +2211,0 @@\n-      \/* If `num_instances` is larger, synthetization of the default  *\/\n-      \/* instance is required.  If `num_instances` is smaller,        *\/\n-      \/* however, the value has been reset to 0 in `sfnt_init_face`   *\/\n-      \/* (in `sfobjs.c`); in this case we have underallocated `mmvar` *\/\n-      \/* structs.                                                     *\/\n-      if ( num_instances < fvar_head.instanceCount )\n-      {\n-        error = FT_THROW( Invalid_Table );\n-        goto Exit;\n-      }\n-\n@@ -2386,0 +2229,5 @@\n+    \/* `num_instances' holds the number of all named instances, *\/\n+    \/* including the default instance which might be missing    *\/\n+    \/* in fvar's table of named instances                       *\/\n+    num_instances = (FT_UInt)face->root.style_flags >> 16;\n+\n@@ -2513,3 +2361,3 @@\n-                    (double)a->minimum \/ 65536,\n-                    (double)a->def \/ 65536,\n-                    (double)a->maximum \/ 65536,\n+                    a->minimum \/ 65536.0,\n+                    a->def \/ 65536.0,\n+                    a->maximum \/ 65536.0,\n@@ -2716,2 +2564,0 @@\n-        else if ( a->tag == TTAG_ital )\n-          a->name = (char*)\"Italic\";\n@@ -2779,1 +2625,1 @@\n-      FT_TRACE5(( \"    %.5f\\n\", (double)coords[i] \/ 65536 ));\n+      FT_TRACE5(( \"    %.5f\\n\", coords[i] \/ 65536.0 ));\n@@ -2783,1 +2629,1 @@\n-                    (double)coords[i] \/ 65536 ));\n+                    coords[i] \/ 65536.0 ));\n@@ -2793,7 +2639,1 @@\n-    {\n-      \/* While a missing 'gvar' table is acceptable, for example for *\/\n-      \/* fonts that only vary metrics information or 'COLR' v1       *\/\n-      \/* `PaintVar*` tables, an incorrect SFNT table offset or size  *\/\n-      \/* for 'gvar', or an inconsistent 'gvar' table is not.         *\/\n-      error = ft_var_load_gvar( face );\n-      if ( error != FT_Err_Table_Missing && error != FT_Err_Ok )\n+      if ( FT_SET_ERROR( ft_var_load_gvar( face ) ) )\n@@ -2801,2 +2641,0 @@\n-      error = FT_Err_Ok;\n-    }\n@@ -3668,4 +3506,4 @@\n-                        (double)( FT_fdot6ToFixed( face->cvt[j] ) +\n-                                    old_cvt_delta ) \/ 65536,\n-                        (double)( FT_fdot6ToFixed( face->cvt[j] ) +\n-                                    cvt_deltas[j] ) \/ 65536 ));\n+                        ( FT_fdot6ToFixed( face->cvt[j] ) +\n+                          old_cvt_delta ) \/ 65536.0,\n+                        ( FT_fdot6ToFixed( face->cvt[j] ) +\n+                          cvt_deltas[j] ) \/ 65536.0 ));\n@@ -3710,4 +3548,4 @@\n-                        (double)( FT_fdot6ToFixed( face->cvt[pindex] ) +\n-                                    old_cvt_delta ) \/ 65536,\n-                        (double)( FT_fdot6ToFixed( face->cvt[pindex] ) +\n-                                    cvt_deltas[pindex] ) \/ 65536 ));\n+                        ( FT_fdot6ToFixed( face->cvt[pindex] ) +\n+                          old_cvt_delta ) \/ 65536.0,\n+                        ( FT_fdot6ToFixed( face->cvt[pindex] ) +\n+                          cvt_deltas[pindex] ) \/ 65536.0 ));\n@@ -3978,3 +3816,10 @@\n-   * @InOut:\n-   *   loader ::\n-   *     A handle to the loader object.\n+   * @Input:\n+   *   face ::\n+   *     A handle to the target face object.\n+   *\n+   *   glyph_index ::\n+   *     The index of the glyph being modified.\n+   *\n+   *   n_points ::\n+   *     The number of the points in the glyph, including\n+   *     phantom points.\n@@ -3982,0 +3827,1 @@\n+   * @InOut:\n@@ -3983,1 +3829,1 @@\n-   *     The outline to change, with appended phantom points.\n+   *     The outline to change.\n@@ -3994,1 +3840,2 @@\n-  TT_Vary_Apply_Glyph_Deltas( TT_Loader    loader,\n+  TT_Vary_Apply_Glyph_Deltas( TT_Face      face,\n+                              FT_UInt      glyph_index,\n@@ -3996,1 +3843,2 @@\n-                              FT_Vector*   unrounded )\n+                              FT_Vector*   unrounded,\n+                              FT_UInt      n_points )\n@@ -3999,5 +3847,2 @@\n-    TT_Face    face        = loader->face;\n-    FT_Stream  stream      = face->root.stream;\n-    FT_Memory  memory      = stream->memory;\n-    FT_UInt    glyph_index = loader->glyph_index;\n-    FT_UInt    n_points    = (FT_UInt)outline->n_points + 4;\n+    FT_Stream  stream = face->root.stream;\n+    FT_Memory  memory = stream->memory;\n@@ -4221,2 +4066,30 @@\n-          point_deltas_x[j] = old_point_delta_x + point_delta_x;\n-          point_deltas_y[j] = old_point_delta_y + point_delta_y;\n+          if ( j < n_points - 4 )\n+          {\n+            point_deltas_x[j] = old_point_delta_x + point_delta_x;\n+            point_deltas_y[j] = old_point_delta_y + point_delta_y;\n+          }\n+          else\n+          {\n+            \/* To avoid double adjustment of advance width or height, *\/\n+            \/* adjust phantom points only if there is no HVAR or VVAR *\/\n+            \/* support, respectively.                                 *\/\n+            if ( j == ( n_points - 4 )        &&\n+                 !( face->variation_support &\n+                    TT_FACE_FLAG_VAR_LSB    ) )\n+              point_deltas_x[j] = old_point_delta_x + point_delta_x;\n+\n+            else if ( j == ( n_points - 3 )          &&\n+                      !( face->variation_support   &\n+                         TT_FACE_FLAG_VAR_HADVANCE ) )\n+              point_deltas_x[j] = old_point_delta_x + point_delta_x;\n+\n+            else if ( j == ( n_points - 2 )        &&\n+                      !( face->variation_support &\n+                         TT_FACE_FLAG_VAR_TSB    ) )\n+              point_deltas_y[j] = old_point_delta_y + point_delta_y;\n+\n+            else if ( j == ( n_points - 1 )          &&\n+                      !( face->variation_support   &\n+                         TT_FACE_FLAG_VAR_VADVANCE ) )\n+              point_deltas_y[j] = old_point_delta_y + point_delta_y;\n+          }\n@@ -4229,8 +4102,8 @@\n-                        (double)( FT_intToFixed( outline->points[j].x ) +\n-                                    old_point_delta_x ) \/ 65536,\n-                        (double)( FT_intToFixed( outline->points[j].y ) +\n-                                    old_point_delta_y ) \/ 65536,\n-                        (double)( FT_intToFixed( outline->points[j].x ) +\n-                                    point_deltas_x[j] ) \/ 65536,\n-                        (double)( FT_intToFixed( outline->points[j].y ) +\n-                                    point_deltas_y[j] ) \/ 65536 ));\n+                        ( FT_intToFixed( outline->points[j].x ) +\n+                          old_point_delta_x ) \/ 65536.0,\n+                        ( FT_intToFixed( outline->points[j].y ) +\n+                          old_point_delta_y ) \/ 65536.0,\n+                        ( FT_intToFixed( outline->points[j].x ) +\n+                          point_deltas_x[j] ) \/ 65536.0,\n+                        ( FT_intToFixed( outline->points[j].y ) +\n+                          point_deltas_y[j] ) \/ 65536.0 ));\n@@ -4295,2 +4168,30 @@\n-          point_deltas_x[j] = old_point_delta_x + point_delta_x;\n-          point_deltas_y[j] = old_point_delta_y + point_delta_y;\n+          if ( j < n_points - 4 )\n+          {\n+            point_deltas_x[j] = old_point_delta_x + point_delta_x;\n+            point_deltas_y[j] = old_point_delta_y + point_delta_y;\n+          }\n+          else\n+          {\n+            \/* To avoid double adjustment of advance width or height, *\/\n+            \/* adjust phantom points only if there is no HVAR or VVAR *\/\n+            \/* support, respectively.                                 *\/\n+            if ( j == ( n_points - 4 )        &&\n+                 !( face->variation_support &\n+                    TT_FACE_FLAG_VAR_LSB    ) )\n+              point_deltas_x[j] = old_point_delta_x + point_delta_x;\n+\n+            else if ( j == ( n_points - 3 )          &&\n+                      !( face->variation_support   &\n+                         TT_FACE_FLAG_VAR_HADVANCE ) )\n+              point_deltas_x[j] = old_point_delta_x + point_delta_x;\n+\n+            else if ( j == ( n_points - 2 )        &&\n+                      !( face->variation_support &\n+                         TT_FACE_FLAG_VAR_TSB    ) )\n+              point_deltas_y[j] = old_point_delta_y + point_delta_y;\n+\n+            else if ( j == ( n_points - 1 )          &&\n+                      !( face->variation_support   &\n+                         TT_FACE_FLAG_VAR_VADVANCE ) )\n+              point_deltas_y[j] = old_point_delta_y + point_delta_y;\n+          }\n@@ -4303,8 +4204,8 @@\n-                        (double)( FT_intToFixed( outline->points[j].x ) +\n-                                    old_point_delta_x ) \/ 65536,\n-                        (double)( FT_intToFixed( outline->points[j].y ) +\n-                                    old_point_delta_y ) \/ 65536,\n-                        (double)( FT_intToFixed( outline->points[j].x ) +\n-                                    point_deltas_x[j] ) \/ 65536,\n-                        (double)( FT_intToFixed( outline->points[j].y ) +\n-                                    point_deltas_y[j] ) \/ 65536 ));\n+                        ( FT_intToFixed( outline->points[j].x ) +\n+                          old_point_delta_x ) \/ 65536.0,\n+                        ( FT_intToFixed( outline->points[j].y ) +\n+                          old_point_delta_y ) \/ 65536.0,\n+                        ( FT_intToFixed( outline->points[j].x ) +\n+                          point_deltas_x[j] ) \/ 65536.0,\n+                        ( FT_intToFixed( outline->points[j].y ) +\n+                          point_deltas_y[j] ) \/ 65536.0 ));\n@@ -4334,18 +4235,0 @@\n-    \/* To avoid double adjustment of advance width or height, *\/\n-    \/* do not move phantom points if there is HVAR or VVAR    *\/\n-    \/* support, respectively.                                 *\/\n-    if ( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE )\n-    {\n-      point_deltas_x[n_points - 4] = 0;\n-      point_deltas_y[n_points - 4] = 0;\n-      point_deltas_x[n_points - 3] = 0;\n-      point_deltas_y[n_points - 3] = 0;\n-    }\n-    if ( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE )\n-    {\n-      point_deltas_x[n_points - 2] = 0;\n-      point_deltas_y[n_points - 2] = 0;\n-      point_deltas_x[n_points - 1] = 0;\n-      point_deltas_y[n_points - 1] = 0;\n-    }\n-\n@@ -4361,18 +4244,0 @@\n-    \/* To avoid double adjustment of advance width or height, *\/\n-    \/* adjust phantom points only if there is no HVAR or VVAR *\/\n-    \/* support, respectively.                                 *\/\n-    if ( !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n-    {\n-      loader->pp1      = outline->points[n_points - 4];\n-      loader->pp2      = outline->points[n_points - 3];\n-      loader->linear   = FT_PIX_ROUND( unrounded[n_points - 3].x -\n-                                       unrounded[n_points - 4].x ) \/ 64;\n-    }\n-    if ( !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n-    {\n-      loader->pp3      = outline->points[n_points - 2];\n-      loader->pp4      = outline->points[n_points - 1];\n-      loader->vadvance = FT_PIX_ROUND( unrounded[n_points - 1].y -\n-                                       unrounded[n_points - 2].y ) \/ 64;\n-    }\n-\n@@ -4443,2 +4308,2 @@\n-  FT_LOCAL_DEF( void )\n-  tt_var_done_item_variation_store( TT_Face          face,\n+  static void\n+  ft_var_done_item_variation_store( TT_Face          face,\n@@ -4472,12 +4337,0 @@\n-  FT_LOCAL_DEF( void )\n-  tt_var_done_delta_set_index_map( TT_Face            face,\n-                                   GX_DeltaSetIdxMap  deltaSetIdxMap )\n-  {\n-    FT_Memory  memory = FT_FACE_MEMORY( face );\n-\n-\n-    FT_FREE( deltaSetIdxMap->innerIndex );\n-    FT_FREE( deltaSetIdxMap->outerIndex );\n-  }\n-\n-\n@@ -4512,1 +4365,1 @@\n-      if ( blend->avar_table )\n+      if ( blend->avar_segment )\n@@ -4514,14 +4367,3 @@\n-        if ( blend->avar_table->avar_segment )\n-        {\n-          for ( i = 0; i < num_axes; i++ )\n-            FT_FREE( blend->avar_table->avar_segment[i].correspondence );\n-          FT_FREE( blend->avar_table->avar_segment );\n-        }\n-\n-        tt_var_done_item_variation_store( face,\n-                                          &blend->avar_table->itemStore );\n-\n-        tt_var_done_delta_set_index_map( face,\n-                                         &blend->avar_table->axisMap );\n-\n-        FT_FREE( blend->avar_table );\n+        for ( i = 0; i < num_axes; i++ )\n+          FT_FREE( blend->avar_segment[i].correspondence );\n+        FT_FREE( blend->avar_segment );\n@@ -4532,1 +4374,1 @@\n-        tt_var_done_item_variation_store( face,\n+        ft_var_done_item_variation_store( face,\n@@ -4535,2 +4377,2 @@\n-        tt_var_done_delta_set_index_map( face,\n-                                         &blend->hvar_table->widthMap );\n+        FT_FREE( blend->hvar_table->widthMap.innerIndex );\n+        FT_FREE( blend->hvar_table->widthMap.outerIndex );\n@@ -4542,1 +4384,1 @@\n-        tt_var_done_item_variation_store( face,\n+        ft_var_done_item_variation_store( face,\n@@ -4545,2 +4387,2 @@\n-        tt_var_done_delta_set_index_map( face,\n-                                         &blend->vvar_table->widthMap );\n+        FT_FREE( blend->vvar_table->widthMap.innerIndex );\n+        FT_FREE( blend->vvar_table->widthMap.outerIndex );\n@@ -4552,1 +4394,1 @@\n-        tt_var_done_item_variation_store( face,\n+        ft_var_done_item_variation_store( face,\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgxvar.c","additions":314,"deletions":472,"binary":false,"changes":786,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2023 by\n+ * Copyright (C) 2004-2022 by\n@@ -23,1 +23,0 @@\n-#include <freetype\/internal\/ftmmtypes.h>\n@@ -66,9 +65,43 @@\n-  \/**************************************************************************\n-   *\n-   * @Struct:\n-   *   GX_AVarTableRec\n-   *\n-   * @Description:\n-   *   Data from the `avar' table.\n-   *\/\n-  typedef struct  GX_AVarTableRec_\n+  typedef struct  GX_ItemVarDataRec_\n+  {\n+    FT_UInt    itemCount;      \/* number of delta sets per item         *\/\n+    FT_UInt    regionIdxCount; \/* number of region indices in this data *\/\n+    FT_UInt*   regionIndices;  \/* array of `regionCount' indices;       *\/\n+                               \/* these index `varRegionList'           *\/\n+    FT_Short*  deltaSet;       \/* array of `itemCount' deltas           *\/\n+                               \/* use `innerIndex' for this array       *\/\n+\n+  } GX_ItemVarDataRec, *GX_ItemVarData;\n+\n+\n+  \/* contribution of one axis to a region *\/\n+  typedef struct  GX_AxisCoordsRec_\n+  {\n+    FT_Fixed  startCoord;\n+    FT_Fixed  peakCoord;      \/* zero means no effect (factor = 1) *\/\n+    FT_Fixed  endCoord;\n+\n+  } GX_AxisCoordsRec, *GX_AxisCoords;\n+\n+\n+  typedef struct  GX_VarRegionRec_\n+  {\n+    GX_AxisCoords  axisList;               \/* array of axisCount records *\/\n+\n+  } GX_VarRegionRec, *GX_VarRegion;\n+\n+\n+  \/* item variation store *\/\n+  typedef struct  GX_ItemVarStoreRec_\n+  {\n+    FT_UInt         dataCount;\n+    GX_ItemVarData  varData;            \/* array of dataCount records;     *\/\n+                                        \/* use `outerIndex' for this array *\/\n+    FT_UShort     axisCount;\n+    FT_UInt       regionCount;          \/* total number of regions defined *\/\n+    GX_VarRegion  varRegionList;\n+\n+  } GX_ItemVarStoreRec, *GX_ItemVarStore;\n+\n+\n+  typedef struct  GX_DeltaSetIdxMapRec_\n@@ -76,3 +109,3 @@\n-    GX_AVarSegment        avar_segment;   \/* avar_segment[num_axis] *\/\n-    GX_ItemVarStoreRec    itemStore;      \/* Item Variation Store   *\/\n-    GX_DeltaSetIdxMapRec  axisMap;        \/* Axis Mapping           *\/\n+    FT_ULong  mapCount;\n+    FT_UInt*  outerIndex;               \/* indices to item var data *\/\n+    FT_UInt*  innerIndex;               \/* indices to delta set     *\/\n@@ -80,1 +113,1 @@\n-  } GX_AVarTableRec, *GX_AVarTable;\n+  } GX_DeltaSetIdxMapRec, *GX_DeltaSetIdxMap;\n@@ -215,1 +248,1 @@\n-   *   avar_table ::\n+   *   avar_segment ::\n@@ -280,1 +313,1 @@\n-    GX_AVarTable    avar_table;\n+    GX_AVarSegment  avar_segment;                \/* avar_segment[num_axis] *\/\n@@ -346,1 +379,0 @@\n-#define TTAG_ital  FT_MAKE_TAG( 'i', 't', 'a', 'l' )\n@@ -383,1 +415,2 @@\n-  TT_Vary_Apply_Glyph_Deltas( TT_Loader    loader,\n+  TT_Vary_Apply_Glyph_Deltas( TT_Face      face,\n+                              FT_UInt      glyph_index,\n@@ -385,1 +418,2 @@\n-                              FT_Vector*   unrounded );\n+                              FT_Vector*   unrounded,\n+                              FT_UInt      n_points );\n@@ -400,28 +434,0 @@\n-\n-  FT_LOCAL( FT_Error )\n-  tt_var_load_item_variation_store( TT_Face          face,\n-                                    FT_ULong         offset,\n-                                    GX_ItemVarStore  itemStore );\n-\n-  FT_LOCAL( FT_Error )\n-  tt_var_load_delta_set_index_mapping( TT_Face            face,\n-                                       FT_ULong           offset,\n-                                       GX_DeltaSetIdxMap  map,\n-                                       GX_ItemVarStore    itemStore,\n-                                       FT_ULong           table_len );\n-\n-  FT_LOCAL( FT_ItemVarDelta )\n-  tt_var_get_item_delta( TT_Face          face,\n-                         GX_ItemVarStore  itemStore,\n-                         FT_UInt          outerIndex,\n-                         FT_UInt          innerIndex );\n-\n-  FT_LOCAL( void )\n-  tt_var_done_item_variation_store( TT_Face          face,\n-                                    GX_ItemVarStore  itemStore );\n-\n-  FT_LOCAL( void )\n-  tt_var_done_delta_set_index_map( TT_Face            face,\n-                                   GX_DeltaSetIdxMap  deltaSetIdxMap );\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgxvar.h","additions":54,"deletions":48,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -1530,0 +1530,1 @@\n+    \/* TT_RunIns sets origCvt and restores cvt to origCvt when done. *\/\n@@ -1531,1 +1532,1 @@\n-         exc->cvt != exc->glyfCvt            )\n+         exc->cvt == exc->origCvt            )\n@@ -3117,0 +3118,2 @@\n+      \/* TT_RunIns sets origStorage and restores storage to origStorage *\/\n+      \/* when done.                                                     *\/\n@@ -3118,1 +3121,1 @@\n-           exc->storage != exc->glyfStorage    )\n+           exc->storage == exc->origStorage    )\n@@ -6874,1 +6877,1 @@\n-  iup_worker_shift_( IUP_Worker  worker,\n+  _iup_worker_shift( IUP_Worker  worker,\n@@ -6896,1 +6899,1 @@\n-  iup_worker_interpolate_( IUP_Worker  worker,\n+  _iup_worker_interpolate( IUP_Worker  worker,\n@@ -7090,1 +7093,1 @@\n-            iup_worker_interpolate_( &V,\n+            _iup_worker_interpolate( &V,\n@@ -7102,1 +7105,1 @@\n-          iup_worker_shift_( &V, first_point, end_point, cur_touched );\n+          _iup_worker_shift( &V, first_point, end_point, cur_touched );\n@@ -7105,1 +7108,1 @@\n-          iup_worker_interpolate_( &V,\n+          _iup_worker_interpolate( &V,\n@@ -7112,1 +7115,1 @@\n-            iup_worker_interpolate_( &V,\n+            _iup_worker_interpolate( &V,\n@@ -7832,0 +7835,2 @@\n+    exc->origCvt     = exc->cvt;\n+    exc->origStorage = exc->storage;\n@@ -8568,2 +8573,1 @@\n-      if ( ++ins_counter > TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES )\n-      {\n+      if ( ++ins_counter > TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES ) {\n@@ -8592,0 +8596,3 @@\n+    exc->cvt     = exc->origCvt;\n+    exc->storage = exc->origStorage;\n+\n@@ -8601,0 +8608,3 @@\n+    exc->cvt     = exc->origCvt;\n+    exc->storage = exc->origStorage;\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttinterp.c","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -196,0 +196,1 @@\n+    FT_Long*           origCvt;\n@@ -226,0 +227,1 @@\n+    FT_Long*           origStorage;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttinterp.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -1007,1 +1007,1 @@\n-                  i, (double)face->cvt[i] \/ 64, (double)size->cvt[i] \/ 64 ));\n+                  i, face->cvt[i] \/ 64.0, size->cvt[i] \/ 64.0 ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttobjs.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttpload.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttpload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2010-2023 by\n+ * Copyright (C) 2010-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttsubpix.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2010-2023 by\n+ * Copyright (C) 2010-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttsubpix.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -181,0 +181,1 @@\n+    charmap    = NULL;\n@@ -188,1 +189,3 @@\n-        t1_face->charmap = charmap;\n+        error = FT_Set_Charmap( t1_face, charmap );\n+        if ( error )\n+          goto Exit;\n@@ -209,1 +212,4 @@\n-    t1_face->charmap = oldcharmap;\n+    if ( oldcharmap )\n+      error = FT_Set_Charmap( t1_face, oldcharmap );\n+    if ( error )\n+      goto Exit;\n@@ -299,8 +305,3 @@\n-      \/* ascender and descender are optional and could both be zero *\/\n-      \/* check if values are meaningful before overriding defaults  *\/\n-      if ( fi->Ascender > fi->Descender )\n-      {\n-        \/* no `U' suffix here to 0x8000! *\/\n-        t1_face->ascender  = (FT_Short)( ( fi->Ascender  + 0x8000 ) >> 16 );\n-        t1_face->descender = (FT_Short)( ( fi->Descender + 0x8000 ) >> 16 );\n-      }\n+      \/* no `U' suffix here to 0x8000! *\/\n+      t1_face->ascender  = (FT_Short)( ( fi->Ascender  + 0x8000 ) >> 16 );\n+      t1_face->descender = (FT_Short)( ( fi->Descender + 0x8000 ) >> 16 );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1afm.c","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1afm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -124,24 +124,13 @@\n-    (FT_Get_MM_Func)        T1_Get_Multi_Master,    \/* get_mm                    *\/\n-    (FT_Set_MM_Design_Func) T1_Set_MM_Design,       \/* set_mm_design             *\/\n-    (FT_Set_MM_Blend_Func)  T1_Set_MM_Blend,        \/* set_mm_blend              *\/\n-    (FT_Get_MM_Blend_Func)  T1_Get_MM_Blend,        \/* get_mm_blend              *\/\n-    (FT_Get_MM_Var_Func)    T1_Get_MM_Var,          \/* get_mm_var                *\/\n-    (FT_Set_Var_Design_Func)T1_Set_Var_Design,      \/* set_var_design            *\/\n-    (FT_Get_Var_Design_Func)T1_Get_Var_Design,      \/* get_var_design            *\/\n-    (FT_Set_Instance_Func)  T1_Reset_MM_Blend,      \/* set_instance              *\/\n-    (FT_Set_MM_WeightVector_Func)\n-                            T1_Set_MM_WeightVector, \/* set_mm_weightvector       *\/\n-    (FT_Get_MM_WeightVector_Func)\n-                            T1_Get_MM_WeightVector, \/* get_mm_weightvector       *\/\n-    (FT_Var_Load_Delta_Set_Idx_Map_Func)\n-                            NULL,                   \/* load_delta_set_idx_map    *\/\n-    (FT_Var_Load_Item_Var_Store_Func)\n-                            NULL,                   \/* load_item_variation_store *\/\n-    (FT_Var_Get_Item_Delta_Func)\n-                            NULL,                   \/* get_item_delta            *\/\n-    (FT_Var_Done_Item_Var_Store_Func)\n-                            NULL,                   \/* done_item_variation_store *\/\n-    (FT_Var_Done_Delta_Set_Idx_Map_Func)\n-                            NULL,                   \/* done_delta_set_index_map  *\/\n-    (FT_Get_Var_Blend_Func) NULL,                   \/* get_var_blend             *\/\n-    (FT_Done_Blend_Func)    T1_Done_Blend           \/* done_blend                *\/\n+    (FT_Get_MM_Func)             T1_Get_Multi_Master,    \/* get_mm              *\/\n+    (FT_Set_MM_Design_Func)      T1_Set_MM_Design,       \/* set_mm_design       *\/\n+    (FT_Set_MM_Blend_Func)       T1_Set_MM_Blend,        \/* set_mm_blend        *\/\n+    (FT_Get_MM_Blend_Func)       T1_Get_MM_Blend,        \/* get_mm_blend        *\/\n+    (FT_Get_MM_Var_Func)         T1_Get_MM_Var,          \/* get_mm_var          *\/\n+    (FT_Set_Var_Design_Func)     T1_Set_Var_Design,      \/* set_var_design      *\/\n+    (FT_Get_Var_Design_Func)     T1_Get_Var_Design,      \/* get_var_design      *\/\n+    (FT_Set_Instance_Func)       T1_Reset_MM_Blend,      \/* set_instance        *\/\n+    (FT_Set_MM_WeightVector_Func)T1_Set_MM_WeightVector, \/* set_mm_weightvector *\/\n+    (FT_Get_MM_WeightVector_Func)T1_Get_MM_WeightVector, \/* get_mm_weightvector *\/\n+\n+    (FT_Get_Var_Blend_Func)      NULL,                   \/* get_var_blend       *\/\n+    (FT_Done_Blend_Func)         T1_Done_Blend           \/* done_blend          *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1driver.c","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1driver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2023 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1errors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -267,1 +267,1 @@\n-                (double)*max_advance \/ 65536 ));\n+                *max_advance \/ 65536.0 ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1gload.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1gload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -358,4 +358,0 @@\n-      else if ( ft_strcmp( mmvar->axis[i].name, \"Slant\" ) == 0 )\n-        mmvar->axis[i].tag = FT_MAKE_TAG( 's', 'l', 'n', 't' );\n-      else if ( ft_strcmp( mmvar->axis[i].name, \"Italic\" ) == 0 )\n-        mmvar->axis[i].tag = FT_MAKE_TAG( 'i', 't', 'a', 'l' );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1load.c","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1load.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -149,3 +149,1 @@\n-    \/* `slot->internal` might be NULL in out-of-memory situations. *\/\n-    if ( slot->internal )\n-      slot->internal->glyph_hints = NULL;\n+    slot->internal->glyph_hints = NULL;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1objs.c","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1objs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n@@ -333,3 +333,1 @@\n-      \/* First look for the `eexec' keyword. Ensure `eexec' is real -- *\/\n-      \/* it could be in a comment or string (as e.g. in u003043t.gsf   *\/\n-      \/* from ghostscript).                                            *\/\n+      \/* first of all, look at the `eexec' keyword *\/\n@@ -342,0 +340,26 @@\n+    Again:\n+      for (;;)\n+      {\n+        if ( cur[0] == 'e'   &&\n+             cur + 9 < limit )      \/* 9 = 5 letters for `eexec' + *\/\n+                                    \/* whitespace + 4 chars        *\/\n+        {\n+          if ( cur[1] == 'e' &&\n+               cur[2] == 'x' &&\n+               cur[3] == 'e' &&\n+               cur[4] == 'c' )\n+            break;\n+        }\n+        cur++;\n+        if ( cur >= limit )\n+        {\n+          FT_ERROR(( \"T1_Get_Private_Dict:\"\n+                     \" could not find `eexec' keyword\\n\" ));\n+          error = FT_THROW( Invalid_File_Format );\n+          goto Exit;\n+        }\n+      }\n+\n+      \/* check whether `eexec' was real -- it could be in a comment *\/\n+      \/* or string (as e.g. in u003043t.gsf from ghostscript)       *\/\n+\n@@ -343,1 +367,2 @@\n-      parser->root.limit  = parser->base_dict + parser->base_len;\n+      \/* set limit to `eexec' + whitespace + 4 characters *\/\n+      parser->root.limit  = cur + 10;\n@@ -350,2 +375,2 @@\n-        \/* 9 = 5 letters for `eexec' + whitespace + 4 chars *\/\n-        if ( cur[0] == 'e' && cur + 9 < limit )\n+        if ( cur[0] == 'e'   &&\n+             cur + 5 < limit )\n@@ -367,3 +392,15 @@\n-      FT_ERROR(( \"T1_Get_Private_Dict: could not find `eexec' keyword\\n\" ));\n-      error = FT_THROW( Invalid_File_Format );\n-      goto Exit;\n+      \/* we haven't found the correct `eexec'; go back and continue *\/\n+      \/* searching                                                  *\/\n+\n+      cur   = limit;\n+      limit = parser->base_dict + parser->base_len;\n+\n+      if ( cur >= limit )\n+      {\n+        FT_ERROR(( \"T1_Get_Private_Dict:\"\n+                   \" premature end in private dictionary\\n\" ));\n+        error = FT_THROW( Invalid_File_Format );\n+        goto Exit;\n+      }\n+\n+      goto Again;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1parse.c","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1parse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2023 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1tokens.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\n-#if !defined(AIX)\n@@ -49,2 +47,0 @@\n-#endif\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import java.util.Set;\n@@ -233,1 +232,1 @@\n-        static final Pattern FILENAME = Pattern.compile(\"filename\\\\s*=\\\\s*\", CASE_INSENSITIVE);\n+        static final Pattern FILENAME = Pattern.compile(\"filename\\\\s*=\", CASE_INSENSITIVE);\n@@ -237,15 +236,0 @@\n-        \/\/ Characters disallowed in token values\n-\n-        static final Set<Character> NOT_ALLOWED_IN_TOKEN = Set.of(\n-            '(', ')', '<', '>', '@',\n-            ',', ';', ':', '\\\\', '\"',\n-            '\/', '[', ']', '?', '=',\n-            '{', '}', ' ', '\\t');\n-\n-        static boolean allowedInToken(char c) {\n-            if (NOT_ALLOWED_IN_TOKEN.contains(c))\n-                return false;\n-            \/\/ exclude CTL chars <= 31, == 127, or anything >= 128\n-            return isTokenText(c);\n-        }\n-\n@@ -258,89 +242,0 @@\n-        static final UncheckedIOException unchecked(String msg) {\n-            return new UncheckedIOException(new IOException(msg));\n-        }\n-\n-        \/\/ Process a \"filename=\" parameter, which is either a \"token\"\n-        \/\/ or a \"quoted string\". If a token, it is terminated by a\n-        \/\/ semicolon or the end of the string.\n-        \/\/ If a quoted string (surrounded by \"\" chars then the closing \"\n-        \/\/ terminates the name.\n-        \/\/ quoted strings may contain quoted-pairs (eg embedded \" chars)\n-\n-        static String processFilename(String src) throws UncheckedIOException {\n-            if (\"\".equals(src))\n-                return src;\n-            if (src.charAt(0) == '\\\"') {\n-                return processQuotedString(src.substring(1));\n-            } else {\n-                return processToken(src);\n-            }\n-        }\n-\n-        static boolean isTokenText(char c) throws UncheckedIOException {\n-            return c > 31 && c < 127;\n-        }\n-\n-        static boolean isQuotedStringText(char c) throws UncheckedIOException {\n-            return c > 31;\n-        }\n-\n-        static String processQuotedString(String src) throws UncheckedIOException {\n-            boolean inqpair = false;\n-            int len = src.length();\n-            StringBuilder sb = new StringBuilder();\n-\n-            for (int i=0; i<len; i++) {\n-                char c = src.charAt(i);\n-                if (!isQuotedStringText(c)) {\n-                    throw unchecked(\"Illegal character\");\n-                }\n-                if (c == '\\\"') {\n-                    if (!inqpair) {\n-                        return sb.toString();\n-                    } else {\n-                        sb.append(c);\n-                    }\n-                } else if (c == '\\\\') {\n-                    if (!inqpair) {\n-                        inqpair = true;\n-                        continue;\n-                    } else {\n-                        \/\/ the quoted char is '\\'\n-                        sb.append(c);\n-                    }\n-                } else {\n-                    sb.append(c);\n-                }\n-                if (inqpair) {\n-                    inqpair = false;\n-                }\n-            }\n-            \/\/ not terminated by \"\n-            throw unchecked(\"Invalid quoted string\");\n-        }\n-\n-        static String processToken(String src) throws UncheckedIOException {\n-            int end = 0;\n-            int len = src.length();\n-            boolean whitespace = false;\n-\n-            for (int i=0; i<len; i++) {\n-                char c = src.charAt(i);\n-                if (c == ';') {\n-                    break;\n-                }\n-                if (c == ' ' || c == '\\t') {\n-                    \/\/ WS only until ; or end of string\n-                    whitespace = true;\n-                    continue;\n-                }\n-                end++;\n-                if (whitespace || !allowedInToken(c)) {\n-                    String msg = whitespace ? \"whitespace must be followed by a semicolon\"\n-                                            : c + \" is not allowed in a token\";\n-                    throw unchecked(msg);\n-                }\n-            }\n-            return src.substring(0, end);\n-        }\n-\n@@ -364,1 +259,7 @@\n-            String filenameParam = processFilename(dispoHeader.substring(n));\n+            int semi = dispoHeader.substring(n).indexOf(\";\");\n+            String filenameParam;\n+            if (semi < 0) {\n+                filenameParam = dispoHeader.substring(n);\n+            } else {\n+                filenameParam = dispoHeader.substring(n, n + semi);\n+            }\n@@ -378,0 +279,13 @@\n+            if (filenameParam.startsWith(\"\\\"\")) {  \/\/ quoted-string\n+                if (!filenameParam.endsWith(\"\\\"\") || filenameParam.length() == 1) {\n+                    throw unchecked(responseInfo,\n+                            \"Badly quoted Content-Disposition filename parameter\");\n+                }\n+                filenameParam = filenameParam.substring(1, filenameParam.length() -1 );\n+            } else {  \/\/ token,\n+                if (filenameParam.contains(\" \")) {  \/\/ space disallowed\n+                    throw unchecked(responseInfo,\n+                            \"unquoted space in Content-Disposition filename parameter\");\n+                }\n+            }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseBodyHandlers.java","additions":21,"deletions":107,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @LastModified: May 2023\n+ * @LastModified: May 2021\n@@ -33,3209 +33,2407 @@\n-    \/**\n-     * Java class file format Magic number (0xCAFEBABE)\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.1-200-A\"> The ClassFile Structure\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final int JVM_CLASSFILE_MAGIC = 0xCAFEBABE;\n-\n-    \/**\n-     * Major version number of class files for Java 1.1.\n-     *\n-     * @see #MINOR_1_1\n-     *\/\n-    public static final short MAJOR_1_1 = 45;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.1.\n-     *\n-     * @see #MAJOR_1_1\n-     *\/\n-    public static final short MINOR_1_1 = 3;\n-\n-    \/**\n-     * Major version number of class files for Java 1.2.\n-     *\n-     * @see #MINOR_1_2\n-     *\/\n-    public static final short MAJOR_1_2 = 46;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.2.\n-     *\n-     * @see #MAJOR_1_2\n-     *\/\n-    public static final short MINOR_1_2 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.2.\n-     *\n-     * @see #MINOR_1_2\n-     *\/\n-    public static final short MAJOR_1_3 = 47;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.3.\n-     *\n-     * @see #MAJOR_1_3\n-     *\/\n-    public static final short MINOR_1_3 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.3.\n-     *\n-     * @see #MINOR_1_3\n-     *\/\n-    public static final short MAJOR_1_4 = 48;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.4.\n-     *\n-     * @see #MAJOR_1_4\n-     *\/\n-    public static final short MINOR_1_4 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.4.\n-     *\n-     * @see #MINOR_1_4\n-     *\/\n-    public static final short MAJOR_1_5 = 49;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.5.\n-     *\n-     * @see #MAJOR_1_5\n-     *\/\n-    public static final short MINOR_1_5 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.6.\n-     *\n-     * @see #MINOR_1_6\n-     *\/\n-    public static final short MAJOR_1_6 = 50;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.6.\n-     *\n-     * @see #MAJOR_1_6\n-     *\/\n-    public static final short MINOR_1_6 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.7.\n-     *\n-     * @see #MINOR_1_7\n-     *\/\n-    public static final short MAJOR_1_7 = 51;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.7.\n-     *\n-     * @see #MAJOR_1_7\n-     *\/\n-    public static final short MINOR_1_7 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.8.\n-     *\n-     * @see #MINOR_1_8\n-     *\/\n-    public static final short MAJOR_1_8 = 52;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.8.\n-     *\n-     * @see #MAJOR_1_8\n-     *\/\n-    public static final short MINOR_1_8 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 9.\n-     *\n-     * @see #MINOR_9\n-     *\/\n-    public static final short MAJOR_9 = 53;\n-\n-    \/**\n-     * Minor version number of class files for Java 9.\n-     *\n-     * @see #MAJOR_9\n-     *\/\n-    public static final short MINOR_9 = 0;\n-\n-    \/**\n-     * @deprecated Use {@link #MAJOR_9} instead\n-     *\/\n-    @Deprecated\n-    public static final short MAJOR_1_9 = MAJOR_9;\n-\n-    \/**\n-     * @deprecated Use {@link #MINOR_9} instead\n-     *\/\n-    @Deprecated\n-    public static final short MINOR_1_9 = MINOR_9;\n-\n-    \/**\n-     * Major version number of class files for Java 10.\n-     *\n-     * @see #MINOR_10\n-     *\/\n-    public static final short MAJOR_10 = 54;\n-\n-    \/**\n-     * Minor version number of class files for Java 10.\n-     *\n-     * @see #MAJOR_10\n-     *\/\n-    public static final short MINOR_10 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 11.\n-     *\n-     * @see #MINOR_11\n-     *\/\n-    public static final short MAJOR_11 = 55;\n-\n-    \/**\n-     * Minor version number of class files for Java 11.\n-     *\n-     * @see #MAJOR_11\n-     *\/\n-    public static final short MINOR_11 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 12.\n-     *\n-     * @see #MINOR_12\n-     *\/\n-    public static final short MAJOR_12 = 56;\n-\n-    \/**\n-     * Minor version number of class files for Java 12.\n-     *\n-     * @see #MAJOR_12\n-     *\/\n-    public static final short MINOR_12 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 13.\n-     *\n-     * @see #MINOR_13\n-     *\/\n-    public static final short MAJOR_13 = 57;\n-\n-    \/**\n-     * Minor version number of class files for Java 13.\n-     *\n-     * @see #MAJOR_13\n-     *\/\n-    public static final short MINOR_13 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 14.\n-     *\n-     * @see #MAJOR_14\n-     * @since 6.4.0\n-     *\/\n-    public static final short MINOR_14 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 15.\n-     *\n-     * @see #MAJOR_15\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_15 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 16.\n-     *\n-     * @see #MAJOR_16\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_16 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 17.\n-     *\n-     * @see #MAJOR_17\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_17 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 18.\n-     *\n-     * @see #MAJOR_18\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_18 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 19.\n-     *\n-     * @see #MAJOR_19\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_19 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 14.\n-     *\n-     * @see #MINOR_14\n-     * @since 6.4.0\n-     *\/\n-    public static final short MAJOR_14 = 58;\n-\n-    \/**\n-     * Major version number of class files for Java 15.\n-     *\n-     * @see #MINOR_15\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_15 = 59;\n-\n-    \/**\n-     * Major version number of class files for Java 16.\n-     *\n-     * @see #MINOR_16\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_16 = 60;\n-\n-    \/**\n-     * Major version number of class files for Java 17.\n-     *\n-     * @see #MINOR_17\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_17 = 61;\n-\n-    \/**\n-     * Major version number of class files for Java 18.\n-     *\n-     * @see #MINOR_18\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_18 = 62;\n-\n-    \/**\n-     * Major version number of class files for Java 19.\n-     *\n-     * @see #MINOR_19\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_19 = 63;\n-\n-    \/**\n-     * Default major version number. Class file is for Java 1.1.\n-     *\n-     * @see #MAJOR_1_1\n-     *\/\n-    public static final short MAJOR = MAJOR_1_1;\n-\n-    \/**\n-     * Default major version number. Class file is for Java 1.1.\n-     *\n-     * @see #MAJOR_1_1\n-     *\/\n-    public static final short MINOR = MINOR_1_1;\n-\n-    \/**\n-     * Maximum value for an unsigned short.\n-     *\/\n-    public static final int MAX_SHORT = 65535; \/\/ 2^16 - 1\n-\n-    \/**\n-     * Maximum value for an unsigned byte.\n-     *\/\n-    public static final int MAX_BYTE = 255; \/\/ 2^8 - 1\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.1-200-E.1\"> Flag definitions for\n-     *      Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.5\"> Flag definitions for Fields\n-     *      in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.6\"> Flag definitions for Methods\n-     *      in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.7.6-300-D.1-D.1\"> Flag\n-     *      definitions for Inner Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-     *\/\n-    public static final short ACC_PUBLIC = 0x0001;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_PRIVATE = 0x0002;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_PROTECTED = 0x0004;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_STATIC = 0x0008;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_FINAL = 0x0010;\n-\n-    \/**\n-     * One of the access flags for the Module attribute.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_OPEN = 0x0020;\n-\n-    \/**\n-     * One of the access flags for classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_SUPER = 0x0020;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_SYNCHRONIZED = 0x0020;\n-\n-    \/**\n-     * One of the access flags for the Module attribute.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_TRANSITIVE = 0x0020;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_BRIDGE = 0x0040;\n-\n-    \/**\n-     * One of the access flags for the Module attribute.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_STATIC_PHASE = 0x0040;\n-\n-    \/**\n-     * One of the access flags for fields.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_VOLATILE = 0x0040;\n-\n-    \/**\n-     * One of the access flags for fields.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_TRANSIENT = 0x0080;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_VARARGS = 0x0080;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_NATIVE = 0x0100;\n-\n-    \/**\n-     * One of the access flags for classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_INTERFACE = 0x0200;\n-\n-    \/**\n-     * One of the access flags for methods or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_ABSTRACT = 0x0400;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_STRICT = 0x0800;\n-\n-    \/**\n-     * One of the access flags for fields, methods, classes, MethodParameter attribute, or Module attribute.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_SYNTHETIC = 0x1000;\n-\n-    \/**\n-     * One of the access flags for classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_ANNOTATION = 0x2000;\n-\n-    \/**\n-     * One of the access flags for fields or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_ENUM = 0x4000;\n-\n-    \/\/ Applies to classes compiled by new compilers only\n-    \/**\n-     * One of the access flags for MethodParameter or Module attributes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_MANDATED = (short) 0x8000;\n-\n-    \/**\n-     * One of the access flags for classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_MODULE = (short) 0x8000;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     * @deprecated Use {@link #MAX_ACC_FLAG_I}\n-     *\/\n-    @Deprecated\n-    public static final short MAX_ACC_FLAG = ACC_ENUM;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes. ACC_MODULE is negative as a short.\n-     *\n-     * @see #ACC_PUBLIC\n-     * @since 6.4.0\n-     *\/\n-    public static final int MAX_ACC_FLAG_I = 0x8000; \/\/ ACC_MODULE is negative as a short\n-\n-    \/\/ Note that do to overloading:\n-    \/\/ 'synchronized' is for methods, might be 'open' (if Module), 'super' (if class), or 'transitive' (if Module).\n-    \/\/ 'volatile' is for fields, might be 'bridge' (if method) or 'static_phase' (if Module)\n-    \/\/ 'transient' is for fields, might be 'varargs' (if method)\n-    \/\/ 'module' is for classes, might be 'mandated' (if Module or MethodParameters)\n-    \/**\n-     * The names of the access flags.\n-     *\/\n-    private static final String[] ACCESS_NAMES = {\"public\", \"private\", \"protected\", \"static\", \"final\", \"synchronized\", \"volatile\", \"transient\", \"native\",\n-        \"interface\", \"abstract\", \"strictfp\", \"synthetic\", \"annotation\", \"enum\", \"module\"};\n-\n-    \/** @since 6.0 *\/\n-    public static final int ACCESS_NAMES_LENGTH = ACCESS_NAMES.length;\n-\n-    \/**\n-     * Marks a constant pool entry as type UTF-8.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.7\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Utf8 = 1;\n-\n-    \/*\n-     * The description of the constant pool is at: https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4\n-     * References below are to the individual sections\n-     *\/\n-\n-    \/**\n-     * Marks a constant pool entry as type Integer.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Integer = 3;\n-\n-    \/**\n-     * Marks a constant pool entry as type Float.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Float = 4;\n-\n-    \/**\n-     * Marks a constant pool entry as type Long.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Long = 5;\n-\n-    \/**\n-     * Marks a constant pool entry as type Double.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Double = 6;\n-\n-    \/**\n-     * Marks a constant pool entry as a Class\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.1\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Class = 7;\n-\n-    \/**\n-     * Marks a constant pool entry as a Field Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Fieldref = 9;\n-\n-    \/**\n-     * Marks a constant pool entry as type String\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.3\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_String = 8;\n-\n-    \/**\n-     * Marks a constant pool entry as a Method Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Methodref = 10;\n-\n-    \/**\n-     * Marks a constant pool entry as an Interface Method Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_InterfaceMethodref = 11;\n-\n-    \/**\n-     * Marks a constant pool entry as a name and type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.6\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_NameAndType = 12;\n-\n-    \/**\n-     * Marks a constant pool entry as a Method Handle.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.8\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_MethodHandle = 15;\n-\n-    \/**\n-     * Marks a constant pool entry as a Method Type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.9\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_MethodType = 16;\n-\n-    \/**\n-     * Marks a constant pool entry as dynamically computed.\n-     *\n-     * @see <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\"> Change request for JEP\n-     *      309<\/a>\n-     * @since 6.3\n-     *\/\n-    public static final byte CONSTANT_Dynamic = 17;\n-\n-    \/**\n-     * Marks a constant pool entry as an Invoke Dynamic\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_InvokeDynamic = 18;\n-\n-    \/**\n-     * Marks a constant pool entry as a Module Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.11\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     * @since 6.1\n-     *\/\n-    public static final byte CONSTANT_Module = 19;\n-\n-    \/**\n-     * Marks a constant pool entry as a Package Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.12\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     * @since 6.1\n-     *\/\n-    public static final byte CONSTANT_Package = 20;\n-\n-    \/**\n-     * The names of the types of entries in a constant pool. Use getConstantName instead\n-     *\/\n-    private static final String[] CONSTANT_NAMES = {\"\", \"CONSTANT_Utf8\", \"\", \"CONSTANT_Integer\", \"CONSTANT_Float\", \"CONSTANT_Long\", \"CONSTANT_Double\",\n-        \"CONSTANT_Class\", \"CONSTANT_String\", \"CONSTANT_Fieldref\", \"CONSTANT_Methodref\", \"CONSTANT_InterfaceMethodref\", \"CONSTANT_NameAndType\", \"\", \"\",\n-        \"CONSTANT_MethodHandle\", \"CONSTANT_MethodType\", \"CONSTANT_Dynamic\", \"CONSTANT_InvokeDynamic\", \"CONSTANT_Module\", \"CONSTANT_Package\"};\n-\n-    \/**\n-     * The name of the static initializer, also called &quot;class initialization method&quot; or &quot;interface\n-     * initialization method&quot;. This is &quot;&lt;clinit&gt;&quot;.\n-     *\/\n-    public static final String STATIC_INITIALIZER_NAME = \"<clinit>\";\n-\n-    \/**\n-     * The name of every constructor method in a class, also called &quot;instance initialization method&quot;. This is\n-     * &quot;&lt;init&gt;&quot;.\n-     *\/\n-    public static final String CONSTRUCTOR_NAME = \"<init>\";\n-\n-    \/**\n-     * The names of the interfaces implemented by arrays\n-     *\/\n-    private static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = {\"java.lang.Cloneable\", \"java.io.Serializable\"};\n-\n-    \/**\n-     * Maximum Constant Pool entries. One of the limitations of the Java Virtual Machine.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.11-100-A\"> The Java Virtual\n-     *      Machine Specification, Java SE 8 Edition, page 330, chapter 4.11.<\/a>\n-     *\/\n-    public static final int MAX_CP_ENTRIES = 65535;\n-\n-    \/**\n-     * Maximum code size (plus one; the code size must be LESS than this) One of the limitations of the Java Virtual\n-     * Machine. Note vmspec2 page 152 (\"Limitations\") says: \"The amount of code per non-native, non-abstract method is\n-     * limited to 65536 bytes by the sizes of the indices in the exception_table of the Code attribute (4.7.3), in the\n-     * LineNumberTable attribute (4.7.8), and in the LocalVariableTable attribute (4.7.9).\" However this should be taken\n-     * as an upper limit rather than the defined maximum. On page 134 (4.8.1 Static Constants) of the same spec, it says:\n-     * \"The value of the code_length item must be less than 65536.\" The entry in the Limitations section has been removed\n-     * from later versions of the spec; it is not present in the Java SE 8 edition.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.3-300-E\"> The Java Virtual\n-     *      Machine Specification, Java SE 8 Edition, page 104, chapter 4.7.<\/a>\n-     *\/\n-    public static final int MAX_CODE_SIZE = 65536; \/\/ bytes\n-\n-    \/**\n-     * The maximum number of dimensions in an array ({@value}). One of the limitations of the Java Virtual Machine.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3.2-150\"> Field Descriptors in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final int MAX_ARRAY_DIMENSIONS = 255;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.nop\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short NOP = 0;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aconst_null\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ACONST_NULL = 1;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_M1 = 2;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_0 = 3;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_1 = 4;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_2 = 5;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_3 = 6;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_4 = 7;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_5 = 8;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LCONST_0 = 9;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LCONST_1 = 10;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCONST_0 = 11;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCONST_1 = 12;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCONST_2 = 13;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DCONST_0 = 14;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DCONST_1 = 15;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bipush\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short BIPUSH = 16;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sipush\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short SIPUSH = 17;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LDC = 18;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc_w\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LDC_W = 19;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc2_w\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LDC2_W = 20;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD = 21;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD = 22;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD = 23;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD = 24;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD = 25;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD_0 = 26;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD_1 = 27;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD_2 = 28;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD_3 = 29;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD_0 = 30;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD_1 = 31;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD_2 = 32;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD_3 = 33;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD_0 = 34;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD_1 = 35;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD_2 = 36;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD_3 = 37;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD_0 = 38;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD_1 = 39;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD_2 = 40;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD_3 = 41;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD_0 = 42;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD_1 = 43;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD_2 = 44;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD_3 = 45;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iaload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IALOAD = 46;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.laload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LALOAD = 47;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.faload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FALOAD = 48;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.daload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DALOAD = 49;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aaload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short AALOAD = 50;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.baload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short BALOAD = 51;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.caload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short CALOAD = 52;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.saload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short SALOAD = 53;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE = 54;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE = 55;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE = 56;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE = 57;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE = 58;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE_0 = 59;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE_1 = 60;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE_2 = 61;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE_3 = 62;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE_0 = 63;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE_1 = 64;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE_2 = 65;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE_3 = 66;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE_0 = 67;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE_1 = 68;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE_2 = 69;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE_3 = 70;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE_0 = 71;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE_1 = 72;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE_2 = 73;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE_3 = 74;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE_0 = 75;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE_1 = 76;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE_2 = 77;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE_3 = 78;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IASTORE = 79;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LASTORE = 80;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FASTORE = 81;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DASTORE = 82;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short AASTORE = 83;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short BASTORE = 84;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.castore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short CASTORE = 85;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short SASTORE = 86;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short POP = 87;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop2\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short POP2 = 88;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP = 89;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x1\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP_X1 = 90;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x2\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP_X2 = 91;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP2 = 92;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x1\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP2_X1 = 93;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x2\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP2_X2 = 94;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.swap\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short SWAP = 95;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iadd\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IADD = 96;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ladd\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LADD = 97;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fadd\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FADD = 98;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dadd\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DADD = 99;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.isub\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISUB = 100;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lsub\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSUB = 101;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fsub\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSUB = 102;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dsub\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSUB = 103;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.imul\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IMUL = 104;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lmul\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LMUL = 105;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fmul\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FMUL = 106;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dmul\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DMUL = 107;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.idiv\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IDIV = 108;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldiv\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LDIV = 109;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fdiv\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FDIV = 110;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ddiv\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DDIV = 111;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.irem\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IREM = 112;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lrem\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LREM = 113;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.frem\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FREM = 114;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.drem\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DREM = 115;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ineg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INEG = 116;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lneg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LNEG = 117;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fneg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FNEG = 118;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dneg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DNEG = 119;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishl\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISHL = 120;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshl\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSHL = 121;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishr\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISHR = 122;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshr\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSHR = 123;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iushr\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IUSHR = 124;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lushr\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LUSHR = 125;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iand\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IAND = 126;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.land\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LAND = 127;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ior\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IOR = 128;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lor\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LOR = 129;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ixor\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IXOR = 130;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lxor\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LXOR = 131;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iinc\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IINC = 132;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2l\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2L = 133;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2f\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2F = 134;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2d\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2D = 135;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2i\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short L2I = 136;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2f\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short L2F = 137;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2d\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short L2D = 138;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2i\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short F2I = 139;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2l\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short F2L = 140;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2d\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short F2D = 141;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2i\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short D2I = 142;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2l\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short D2L = 143;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2f\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short D2F = 144;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2b\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2B = 145;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INT2BYTE = 145; \/\/ Old notation\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2c\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2C = 146;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INT2CHAR = 146; \/\/ Old notation\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2s\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2S = 147;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INT2SHORT = 147; \/\/ Old notation\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lcmp\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LCMP = 148;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpl\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCMPL = 149;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCMPG = 150;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpl\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DCMPL = 151;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DCMPG = 152;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifeq\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFEQ = 153;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifne\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFNE = 154;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iflt\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFLT = 155;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifge\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFGE = 156;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifgt\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFGT = 157;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifle\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFLE = 158;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPEQ = 159;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPNE = 160;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPLT = 161;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPGE = 162;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPGT = 163;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPLE = 164;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ACMPEQ = 165;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ACMPNE = 166;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short GOTO = 167;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short JSR = 168;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ret\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short RET = 169;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.tableswitch\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short TABLESWITCH = 170;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lookupswitch\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LOOKUPSWITCH = 171;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ireturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IRETURN = 172;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lreturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LRETURN = 173;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.freturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FRETURN = 174;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dreturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DRETURN = 175;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.areturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ARETURN = 176;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.return\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short RETURN = 177;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getstatic\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short GETSTATIC = 178;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putstatic\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short PUTSTATIC = 179;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getfield\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short GETFIELD = 180;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putfield\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short PUTFIELD = 181;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKEVIRTUAL = 182;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKESPECIAL = 183;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKENONVIRTUAL = 183; \/\/ Old name in JDK 1.0\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKESTATIC = 184;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKEINTERFACE = 185;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKEDYNAMIC = 186;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.new\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short NEW = 187;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.newarray\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short NEWARRAY = 188;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.anewarray\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ANEWARRAY = 189;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.arraylength\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ARRAYLENGTH = 190;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.athrow\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ATHROW = 191;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.checkcast\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short CHECKCAST = 192;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.instanceof\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INSTANCEOF = 193;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorenter\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short MONITORENTER = 194;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorexit\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short MONITOREXIT = 195;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.wide\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short WIDE = 196;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.multianewarray\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short MULTIANEWARRAY = 197;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnull\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFNULL = 198;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnonnull\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFNONNULL = 199;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto_w\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short GOTO_W = 200;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr_w\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short JSR_W = 201;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n-     *      Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short BREAKPOINT = 202;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short LDC_QUICK = 203;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short LDC_W_QUICK = 204;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short LDC2_W_QUICK = 205;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETFIELD_QUICK = 206;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTFIELD_QUICK = 207;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETFIELD2_QUICK = 208;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTFIELD2_QUICK = 209;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETSTATIC_QUICK = 210;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTSTATIC_QUICK = 211;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETSTATIC2_QUICK = 212;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTSTATIC2_QUICK = 213;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKEVIRTUAL_QUICK = 214;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKENONVIRTUAL_QUICK = 215;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKESUPER_QUICK = 216;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKESTATIC_QUICK = 217;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKEINTERFACE_QUICK = 218;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKEVIRTUALOBJECT_QUICK = 219;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short NEW_QUICK = 221;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short ANEWARRAY_QUICK = 222;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short MULTIANEWARRAY_QUICK = 223;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short CHECKCAST_QUICK = 224;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INSTANCEOF_QUICK = 225;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKEVIRTUAL_QUICK_W = 226;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETFIELD_QUICK_W = 227;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTFIELD_QUICK_W = 228;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n-     *      Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IMPDEP1 = 254;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n-     *      Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IMPDEP2 = 255;\n-\n-    \/**\n-     * BCEL virtual instruction for pushing an arbitrary data type onto the stack. Will be converted to the appropriate JVM\n-     * opcode when the class is dumped.\n-     *\/\n-    public static final short PUSH = 4711;\n-\n-    \/**\n-     * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH. Will be converted to the appropriate JVM opcode when\n-     * the class is dumped.\n-     *\/\n-    public static final short SWITCH = 4712;\n-\n-    \/** Illegal opcode. *\/\n-    public static final short UNDEFINED = -1;\n-\n-    \/** Illegal opcode. *\/\n-    public static final short UNPREDICTABLE = -2;\n-\n-    \/** Illegal opcode. *\/\n-    public static final short RESERVED = -3;\n-\n-    \/** Mnemonic for an illegal opcode. *\/\n-    public static final String ILLEGAL_OPCODE = \"<illegal opcode>\";\n-\n-    \/** Mnemonic for an illegal type. *\/\n-    public static final String ILLEGAL_TYPE = \"<illegal type>\";\n-\n-    \/**\n-     * Boolean data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_BOOLEAN = 4;\n-\n-    \/**\n-     * Char data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_CHAR = 5;\n-\n-    \/**\n-     * Float data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_FLOAT = 6;\n-\n-    \/**\n-     * Double data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_DOUBLE = 7;\n-\n-    \/**\n-     * Byte data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_BYTE = 8;\n-\n-    \/**\n-     * Short data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_SHORT = 9;\n-\n-    \/**\n-     * Int data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_INT = 10;\n-\n-    \/**\n-     * Long data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_LONG = 11;\n-\n-    \/** Void data type (non-standard). *\/\n-    public static final byte T_VOID = 12; \/\/ Non-standard\n-\n-    \/** Array data type. *\/\n-    public static final byte T_ARRAY = 13;\n-\n-    \/** Object data type. *\/\n-    public static final byte T_OBJECT = 14;\n-\n-    \/** Reference data type (deprecated). *\/\n-    public static final byte T_REFERENCE = 14; \/\/ Deprecated\n-\n-    \/** Unknown data type. *\/\n-    public static final byte T_UNKNOWN = 15;\n-\n-    \/** Address data type. *\/\n-    public static final byte T_ADDRESS = 16;\n-\n-    \/** Empty arrays used to replace references to ArrayUtils *\/\n-    public static final byte[] EMPTY_BYTE_ARRAY = {};\n-    public static final int[] EMPTY_INT_ARRAY = {};\n-    public static final String[] EMPTY_STRING_ARRAY = {};\n-\n-    \/**\n-     * The primitive type names corresponding to the T_XX constants, e.g., TYPE_NAMES[T_INT] = \"int\"\n-     *\/\n-    private static final String[] TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"boolean\", \"char\", \"float\", \"double\", \"byte\", \"short\",\n-        \"int\", \"long\", \"void\", \"array\", \"object\", \"unknown\", \"address\"};\n-\n-    \/**\n-     * The primitive class names corresponding to the T_XX constants, e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n-     *\/\n-    private static final String[] CLASS_TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"java.lang.Boolean\", \"java.lang.Character\",\n-        \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Byte\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Void\", ILLEGAL_TYPE,\n-        ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE};\n-\n-    \/**\n-     * The signature characters corresponding to primitive types, e.g., SHORT_TYPE_NAMES[T_INT] = \"I\"\n-     *\/\n-    private static final String[] SHORT_TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"Z\", \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"J\", \"V\",\n-        ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE};\n-\n-    \/**\n-     * Number of byte code operands for each opcode, i.e., number of bytes after the tag byte itself. Indexed by opcode, so\n-     * NO_OF_OPERANDS[BIPUSH] = the number of operands for a bipush instruction.\n-     *\/\n-    static final short[] NO_OF_OPERANDS = {0\/* nop *\/, 0\/* aconst_null *\/, 0\/* iconst_m1 *\/, 0\/* iconst_0 *\/, 0\/* iconst_1 *\/, 0\/* iconst_2 *\/,\n-        0\/* iconst_3 *\/, 0\/* iconst_4 *\/, 0\/* iconst_5 *\/, 0\/* lconst_0 *\/, 0\/* lconst_1 *\/, 0\/* fconst_0 *\/, 0\/* fconst_1 *\/, 0\/* fconst_2 *\/, 0\/* dconst_0 *\/,\n-        0\/* dconst_1 *\/, 1\/* bipush *\/, 2\/* sipush *\/, 1\/* ldc *\/, 2\/* ldc_w *\/, 2\/* ldc2_w *\/, 1\/* iload *\/, 1\/* lload *\/, 1\/* fload *\/, 1\/* dload *\/,\n-        1\/* aload *\/, 0\/* iload_0 *\/, 0\/* iload_1 *\/, 0\/* iload_2 *\/, 0\/* iload_3 *\/, 0\/* lload_0 *\/, 0\/* lload_1 *\/, 0\/* lload_2 *\/, 0\/* lload_3 *\/,\n-        0\/* fload_0 *\/, 0\/* fload_1 *\/, 0\/* fload_2 *\/, 0\/* fload_3 *\/, 0\/* dload_0 *\/, 0\/* dload_1 *\/, 0\/* dload_2 *\/, 0\/* dload_3 *\/, 0\/* aload_0 *\/,\n-        0\/* aload_1 *\/, 0\/* aload_2 *\/, 0\/* aload_3 *\/, 0\/* iaload *\/, 0\/* laload *\/, 0\/* faload *\/, 0\/* daload *\/, 0\/* aaload *\/, 0\/* baload *\/, 0\/* caload *\/,\n-        0\/* saload *\/, 1\/* istore *\/, 1\/* lstore *\/, 1\/* fstore *\/, 1\/* dstore *\/, 1\/* astore *\/, 0\/* istore_0 *\/, 0\/* istore_1 *\/, 0\/* istore_2 *\/,\n-        0\/* istore_3 *\/, 0\/* lstore_0 *\/, 0\/* lstore_1 *\/, 0\/* lstore_2 *\/, 0\/* lstore_3 *\/, 0\/* fstore_0 *\/, 0\/* fstore_1 *\/, 0\/* fstore_2 *\/, 0\/* fstore_3 *\/,\n-        0\/* dstore_0 *\/, 0\/* dstore_1 *\/, 0\/* dstore_2 *\/, 0\/* dstore_3 *\/, 0\/* astore_0 *\/, 0\/* astore_1 *\/, 0\/* astore_2 *\/, 0\/* astore_3 *\/, 0\/* iastore *\/,\n-        0\/* lastore *\/, 0\/* fastore *\/, 0\/* dastore *\/, 0\/* aastore *\/, 0\/* bastore *\/, 0\/* castore *\/, 0\/* sastore *\/, 0\/* pop *\/, 0\/* pop2 *\/, 0\/* dup *\/,\n-        0\/* dup_x1 *\/, 0\/* dup_x2 *\/, 0\/* dup2 *\/, 0\/* dup2_x1 *\/, 0\/* dup2_x2 *\/, 0\/* swap *\/, 0\/* iadd *\/, 0\/* ladd *\/, 0\/* fadd *\/, 0\/* dadd *\/, 0\/* isub *\/,\n-        0\/* lsub *\/, 0\/* fsub *\/, 0\/* dsub *\/, 0\/* imul *\/, 0\/* lmul *\/, 0\/* fmul *\/, 0\/* dmul *\/, 0\/* idiv *\/, 0\/* ldiv *\/, 0\/* fdiv *\/, 0\/* ddiv *\/,\n-        0\/* irem *\/, 0\/* lrem *\/, 0\/* frem *\/, 0\/* drem *\/, 0\/* ineg *\/, 0\/* lneg *\/, 0\/* fneg *\/, 0\/* dneg *\/, 0\/* ishl *\/, 0\/* lshl *\/, 0\/* ishr *\/,\n-        0\/* lshr *\/, 0\/* iushr *\/, 0\/* lushr *\/, 0\/* iand *\/, 0\/* land *\/, 0\/* ior *\/, 0\/* lor *\/, 0\/* ixor *\/, 0\/* lxor *\/, 2\/* iinc *\/, 0\/* i2l *\/,\n-        0\/* i2f *\/, 0\/* i2d *\/, 0\/* l2i *\/, 0\/* l2f *\/, 0\/* l2d *\/, 0\/* f2i *\/, 0\/* f2l *\/, 0\/* f2d *\/, 0\/* d2i *\/, 0\/* d2l *\/, 0\/* d2f *\/, 0\/* i2b *\/,\n-        0\/* i2c *\/, 0\/* i2s *\/, 0\/* lcmp *\/, 0\/* fcmpl *\/, 0\/* fcmpg *\/, 0\/* dcmpl *\/, 0\/* dcmpg *\/, 2\/* ifeq *\/, 2\/* ifne *\/, 2\/* iflt *\/, 2\/* ifge *\/,\n-        2\/* ifgt *\/, 2\/* ifle *\/, 2\/* if_icmpeq *\/, 2\/* if_icmpne *\/, 2\/* if_icmplt *\/, 2\/* if_icmpge *\/, 2\/* if_icmpgt *\/, 2\/* if_icmple *\/, 2\/* if_acmpeq *\/,\n-        2\/* if_acmpne *\/, 2\/* goto *\/, 2\/* jsr *\/, 1\/* ret *\/, UNPREDICTABLE\/* tableswitch *\/, UNPREDICTABLE\/* lookupswitch *\/, 0\/* ireturn *\/, 0\/* lreturn *\/,\n-        0\/* freturn *\/, 0\/* dreturn *\/, 0\/* areturn *\/, 0\/* return *\/, 2\/* getstatic *\/, 2\/* putstatic *\/, 2\/* getfield *\/, 2\/* putfield *\/,\n-        2\/* invokevirtual *\/, 2\/* invokespecial *\/, 2\/* invokestatic *\/, 4\/* invokeinterface *\/, 4\/* invokedynamic *\/, 2\/* new *\/, 1\/* newarray *\/,\n-        2\/* anewarray *\/, 0\/* arraylength *\/, 0\/* athrow *\/, 2\/* checkcast *\/, 2\/* instanceof *\/, 0\/* monitorenter *\/, 0\/* monitorexit *\/,\n-        UNPREDICTABLE\/* wide *\/, 3\/* multianewarray *\/, 2\/* ifnull *\/, 2\/* ifnonnull *\/, 4\/* goto_w *\/, 4\/* jsr_w *\/, 0\/* breakpoint *\/, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED\/* impdep1 *\/,\n-        RESERVED\/* impdep2 *\/\n-    };\n-\n-    \/**\n-     * How the byte code operands are to be interpreted for each opcode. Indexed by opcode. TYPE_OF_OPERANDS[ILOAD] = an\n-     * array of shorts describing the data types for the instruction.\n-     *\/\n-    static final short[][] TYPE_OF_OPERANDS = {{}\/* nop *\/, {}\/* aconst_null *\/, {}\/* iconst_m1 *\/, {}\/* iconst_0 *\/, {}\/* iconst_1 *\/,\n-        {}\/* iconst_2 *\/, {}\/* iconst_3 *\/, {}\/* iconst_4 *\/, {}\/* iconst_5 *\/, {}\/* lconst_0 *\/, {}\/* lconst_1 *\/, {}\/* fconst_0 *\/, {}\/* fconst_1 *\/,\n-        {}\/* fconst_2 *\/, {}\/* dconst_0 *\/, {}\/* dconst_1 *\/, {T_BYTE}\/* bipush *\/, {T_SHORT}\/* sipush *\/, {T_BYTE}\/* ldc *\/, {T_SHORT}\/* ldc_w *\/,\n-        {T_SHORT}\/* ldc2_w *\/, {T_BYTE}\/* iload *\/, {T_BYTE}\/* lload *\/, {T_BYTE}\/* fload *\/, {T_BYTE}\/* dload *\/, {T_BYTE}\/* aload *\/, {}\/* iload_0 *\/,\n-        {}\/* iload_1 *\/, {}\/* iload_2 *\/, {}\/* iload_3 *\/, {}\/* lload_0 *\/, {}\/* lload_1 *\/, {}\/* lload_2 *\/, {}\/* lload_3 *\/, {}\/* fload_0 *\/, {}\/* fload_1 *\/,\n-        {}\/* fload_2 *\/, {}\/* fload_3 *\/, {}\/* dload_0 *\/, {}\/* dload_1 *\/, {}\/* dload_2 *\/, {}\/* dload_3 *\/, {}\/* aload_0 *\/, {}\/* aload_1 *\/, {}\/* aload_2 *\/,\n-        {}\/* aload_3 *\/, {}\/* iaload *\/, {}\/* laload *\/, {}\/* faload *\/, {}\/* daload *\/, {}\/* aaload *\/, {}\/* baload *\/, {}\/* caload *\/, {}\/* saload *\/,\n-        {T_BYTE}\/* istore *\/, {T_BYTE}\/* lstore *\/, {T_BYTE}\/* fstore *\/, {T_BYTE}\/* dstore *\/, {T_BYTE}\/* astore *\/, {}\/* istore_0 *\/, {}\/* istore_1 *\/,\n-        {}\/* istore_2 *\/, {}\/* istore_3 *\/, {}\/* lstore_0 *\/, {}\/* lstore_1 *\/, {}\/* lstore_2 *\/, {}\/* lstore_3 *\/, {}\/* fstore_0 *\/, {}\/* fstore_1 *\/,\n-        {}\/* fstore_2 *\/, {}\/* fstore_3 *\/, {}\/* dstore_0 *\/, {}\/* dstore_1 *\/, {}\/* dstore_2 *\/, {}\/* dstore_3 *\/, {}\/* astore_0 *\/, {}\/* astore_1 *\/,\n-        {}\/* astore_2 *\/, {}\/* astore_3 *\/, {}\/* iastore *\/, {}\/* lastore *\/, {}\/* fastore *\/, {}\/* dastore *\/, {}\/* aastore *\/, {}\/* bastore *\/,\n-        {}\/* castore *\/, {}\/* sastore *\/, {}\/* pop *\/, {}\/* pop2 *\/, {}\/* dup *\/, {}\/* dup_x1 *\/, {}\/* dup_x2 *\/, {}\/* dup2 *\/, {}\/* dup2_x1 *\/,\n-        {}\/* dup2_x2 *\/, {}\/* swap *\/, {}\/* iadd *\/, {}\/* ladd *\/, {}\/* fadd *\/, {}\/* dadd *\/, {}\/* isub *\/, {}\/* lsub *\/, {}\/* fsub *\/, {}\/* dsub *\/,\n-        {}\/* imul *\/, {}\/* lmul *\/, {}\/* fmul *\/, {}\/* dmul *\/, {}\/* idiv *\/, {}\/* ldiv *\/, {}\/* fdiv *\/, {}\/* ddiv *\/, {}\/* irem *\/, {}\/* lrem *\/,\n-        {}\/* frem *\/, {}\/* drem *\/, {}\/* ineg *\/, {}\/* lneg *\/, {}\/* fneg *\/, {}\/* dneg *\/, {}\/* ishl *\/, {}\/* lshl *\/, {}\/* ishr *\/, {}\/* lshr *\/,\n-        {}\/* iushr *\/, {}\/* lushr *\/, {}\/* iand *\/, {}\/* land *\/, {}\/* ior *\/, {}\/* lor *\/, {}\/* ixor *\/, {}\/* lxor *\/, {T_BYTE, T_BYTE}\/* iinc *\/, {}\/* i2l *\/,\n-        {}\/* i2f *\/, {}\/* i2d *\/, {}\/* l2i *\/, {}\/* l2f *\/, {}\/* l2d *\/, {}\/* f2i *\/, {}\/* f2l *\/, {}\/* f2d *\/, {}\/* d2i *\/, {}\/* d2l *\/, {}\/* d2f *\/,\n-        {}\/* i2b *\/, {}\/* i2c *\/, {}\/* i2s *\/, {}\/* lcmp *\/, {}\/* fcmpl *\/, {}\/* fcmpg *\/, {}\/* dcmpl *\/, {}\/* dcmpg *\/, {T_SHORT}\/* ifeq *\/,\n-        {T_SHORT}\/* ifne *\/, {T_SHORT}\/* iflt *\/, {T_SHORT}\/* ifge *\/, {T_SHORT}\/* ifgt *\/, {T_SHORT}\/* ifle *\/, {T_SHORT}\/* if_icmpeq *\/,\n-        {T_SHORT}\/* if_icmpne *\/, {T_SHORT}\/* if_icmplt *\/, {T_SHORT}\/* if_icmpge *\/, {T_SHORT}\/* if_icmpgt *\/, {T_SHORT}\/* if_icmple *\/,\n-        {T_SHORT}\/* if_acmpeq *\/, {T_SHORT}\/* if_acmpne *\/, {T_SHORT}\/* goto *\/, {T_SHORT}\/* jsr *\/, {T_BYTE}\/* ret *\/, {}\/* tableswitch *\/,\n-        {}\/* lookupswitch *\/, {}\/* ireturn *\/, {}\/* lreturn *\/, {}\/* freturn *\/, {}\/* dreturn *\/, {}\/* areturn *\/, {}\/* return *\/, {T_SHORT}\/* getstatic *\/,\n-        {T_SHORT}\/* putstatic *\/, {T_SHORT}\/* getfield *\/, {T_SHORT}\/* putfield *\/, {T_SHORT}\/* invokevirtual *\/, {T_SHORT}\/* invokespecial *\/,\n-        {T_SHORT}\/* invokestatic *\/, {T_SHORT, T_BYTE, T_BYTE}\/* invokeinterface *\/, {T_SHORT, T_BYTE, T_BYTE}\/* invokedynamic *\/, {T_SHORT}\/* new *\/,\n-        {T_BYTE}\/* newarray *\/, {T_SHORT}\/* anewarray *\/, {}\/* arraylength *\/, {}\/* athrow *\/, {T_SHORT}\/* checkcast *\/, {T_SHORT}\/* instanceof *\/,\n-        {}\/* monitorenter *\/, {}\/* monitorexit *\/, {T_BYTE}\/* wide *\/, {T_SHORT, T_BYTE}\/* multianewarray *\/, {T_SHORT}\/* ifnull *\/, {T_SHORT}\/* ifnonnull *\/,\n-        {T_INT}\/* goto_w *\/, {T_INT}\/* jsr_w *\/, {}\/* breakpoint *\/, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n-        {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}\/* impdep1 *\/, {}\/* impdep2 *\/\n-    };\n-\n-    \/**\n-     * Names of opcodes. Indexed by opcode. OPCODE_NAMES[ALOAD] = \"aload\".\n-     *\/\n-    static final String[] OPCODE_NAMES = {\"nop\", \"aconst_null\", \"iconst_m1\", \"iconst_0\", \"iconst_1\", \"iconst_2\", \"iconst_3\", \"iconst_4\", \"iconst_5\",\n-        \"lconst_0\", \"lconst_1\", \"fconst_0\", \"fconst_1\", \"fconst_2\", \"dconst_0\", \"dconst_1\", \"bipush\", \"sipush\", \"ldc\", \"ldc_w\", \"ldc2_w\", \"iload\", \"lload\",\n-        \"fload\", \"dload\", \"aload\", \"iload_0\", \"iload_1\", \"iload_2\", \"iload_3\", \"lload_0\", \"lload_1\", \"lload_2\", \"lload_3\", \"fload_0\", \"fload_1\", \"fload_2\",\n-        \"fload_3\", \"dload_0\", \"dload_1\", \"dload_2\", \"dload_3\", \"aload_0\", \"aload_1\", \"aload_2\", \"aload_3\", \"iaload\", \"laload\", \"faload\", \"daload\", \"aaload\",\n-        \"baload\", \"caload\", \"saload\", \"istore\", \"lstore\", \"fstore\", \"dstore\", \"astore\", \"istore_0\", \"istore_1\", \"istore_2\", \"istore_3\", \"lstore_0\", \"lstore_1\",\n-        \"lstore_2\", \"lstore_3\", \"fstore_0\", \"fstore_1\", \"fstore_2\", \"fstore_3\", \"dstore_0\", \"dstore_1\", \"dstore_2\", \"dstore_3\", \"astore_0\", \"astore_1\",\n-        \"astore_2\", \"astore_3\", \"iastore\", \"lastore\", \"fastore\", \"dastore\", \"aastore\", \"bastore\", \"castore\", \"sastore\", \"pop\", \"pop2\", \"dup\", \"dup_x1\",\n-        \"dup_x2\", \"dup2\", \"dup2_x1\", \"dup2_x2\", \"swap\", \"iadd\", \"ladd\", \"fadd\", \"dadd\", \"isub\", \"lsub\", \"fsub\", \"dsub\", \"imul\", \"lmul\", \"fmul\", \"dmul\", \"idiv\",\n-        \"ldiv\", \"fdiv\", \"ddiv\", \"irem\", \"lrem\", \"frem\", \"drem\", \"ineg\", \"lneg\", \"fneg\", \"dneg\", \"ishl\", \"lshl\", \"ishr\", \"lshr\", \"iushr\", \"lushr\", \"iand\",\n-        \"land\", \"ior\", \"lor\", \"ixor\", \"lxor\", \"iinc\", \"i2l\", \"i2f\", \"i2d\", \"l2i\", \"l2f\", \"l2d\", \"f2i\", \"f2l\", \"f2d\", \"d2i\", \"d2l\", \"d2f\", \"i2b\", \"i2c\", \"i2s\",\n-        \"lcmp\", \"fcmpl\", \"fcmpg\", \"dcmpl\", \"dcmpg\", \"ifeq\", \"ifne\", \"iflt\", \"ifge\", \"ifgt\", \"ifle\", \"if_icmpeq\", \"if_icmpne\", \"if_icmplt\", \"if_icmpge\",\n-        \"if_icmpgt\", \"if_icmple\", \"if_acmpeq\", \"if_acmpne\", \"goto\", \"jsr\", \"ret\", \"tableswitch\", \"lookupswitch\", \"ireturn\", \"lreturn\", \"freturn\", \"dreturn\",\n-        \"areturn\", \"return\", \"getstatic\", \"putstatic\", \"getfield\", \"putfield\", \"invokevirtual\", \"invokespecial\", \"invokestatic\", \"invokeinterface\",\n-        \"invokedynamic\", \"new\", \"newarray\", \"anewarray\", \"arraylength\", \"athrow\", \"checkcast\", \"instanceof\", \"monitorenter\", \"monitorexit\", \"wide\",\n-        \"multianewarray\", \"ifnull\", \"ifnonnull\", \"goto_w\", \"jsr_w\", \"breakpoint\", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, \"impdep1\", \"impdep2\"};\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static final int OPCODE_NAMES_LENGTH = OPCODE_NAMES.length;\n-\n-    \/**\n-     * Number of words consumed on operand stack by instructions. Indexed by opcode. CONSUME_STACK[FALOAD] = number of words\n-     * consumed from the stack by a faload instruction.\n-     *\/\n-    static final int[] CONSUME_STACK = {0\/* nop *\/, 0\/* aconst_null *\/, 0\/* iconst_m1 *\/, 0\/* iconst_0 *\/, 0\/* iconst_1 *\/, 0\/* iconst_2 *\/,\n-        0\/* iconst_3 *\/, 0\/* iconst_4 *\/, 0\/* iconst_5 *\/, 0\/* lconst_0 *\/, 0\/* lconst_1 *\/, 0\/* fconst_0 *\/, 0\/* fconst_1 *\/, 0\/* fconst_2 *\/, 0\/* dconst_0 *\/,\n-        0\/* dconst_1 *\/, 0\/* bipush *\/, 0\/* sipush *\/, 0\/* ldc *\/, 0\/* ldc_w *\/, 0\/* ldc2_w *\/, 0\/* iload *\/, 0\/* lload *\/, 0\/* fload *\/, 0\/* dload *\/,\n-        0\/* aload *\/, 0\/* iload_0 *\/, 0\/* iload_1 *\/, 0\/* iload_2 *\/, 0\/* iload_3 *\/, 0\/* lload_0 *\/, 0\/* lload_1 *\/, 0\/* lload_2 *\/, 0\/* lload_3 *\/,\n-        0\/* fload_0 *\/, 0\/* fload_1 *\/, 0\/* fload_2 *\/, 0\/* fload_3 *\/, 0\/* dload_0 *\/, 0\/* dload_1 *\/, 0\/* dload_2 *\/, 0\/* dload_3 *\/, 0\/* aload_0 *\/,\n-        0\/* aload_1 *\/, 0\/* aload_2 *\/, 0\/* aload_3 *\/, 2\/* iaload *\/, 2\/* laload *\/, 2\/* faload *\/, 2\/* daload *\/, 2\/* aaload *\/, 2\/* baload *\/, 2\/* caload *\/,\n-        2\/* saload *\/, 1\/* istore *\/, 2\/* lstore *\/, 1\/* fstore *\/, 2\/* dstore *\/, 1\/* astore *\/, 1\/* istore_0 *\/, 1\/* istore_1 *\/, 1\/* istore_2 *\/,\n-        1\/* istore_3 *\/, 2\/* lstore_0 *\/, 2\/* lstore_1 *\/, 2\/* lstore_2 *\/, 2\/* lstore_3 *\/, 1\/* fstore_0 *\/, 1\/* fstore_1 *\/, 1\/* fstore_2 *\/, 1\/* fstore_3 *\/,\n-        2\/* dstore_0 *\/, 2\/* dstore_1 *\/, 2\/* dstore_2 *\/, 2\/* dstore_3 *\/, 1\/* astore_0 *\/, 1\/* astore_1 *\/, 1\/* astore_2 *\/, 1\/* astore_3 *\/, 3\/* iastore *\/,\n-        4\/* lastore *\/, 3\/* fastore *\/, 4\/* dastore *\/, 3\/* aastore *\/, 3\/* bastore *\/, 3\/* castore *\/, 3\/* sastore *\/, 1\/* pop *\/, 2\/* pop2 *\/, 1\/* dup *\/,\n-        2\/* dup_x1 *\/, 3\/* dup_x2 *\/, 2\/* dup2 *\/, 3\/* dup2_x1 *\/, 4\/* dup2_x2 *\/, 2\/* swap *\/, 2\/* iadd *\/, 4\/* ladd *\/, 2\/* fadd *\/, 4\/* dadd *\/, 2\/* isub *\/,\n-        4\/* lsub *\/, 2\/* fsub *\/, 4\/* dsub *\/, 2\/* imul *\/, 4\/* lmul *\/, 2\/* fmul *\/, 4\/* dmul *\/, 2\/* idiv *\/, 4\/* ldiv *\/, 2\/* fdiv *\/, 4\/* ddiv *\/,\n-        2\/* irem *\/, 4\/* lrem *\/, 2\/* frem *\/, 4\/* drem *\/, 1\/* ineg *\/, 2\/* lneg *\/, 1\/* fneg *\/, 2\/* dneg *\/, 2\/* ishl *\/, 3\/* lshl *\/, 2\/* ishr *\/,\n-        3\/* lshr *\/, 2\/* iushr *\/, 3\/* lushr *\/, 2\/* iand *\/, 4\/* land *\/, 2\/* ior *\/, 4\/* lor *\/, 2\/* ixor *\/, 4\/* lxor *\/, 0\/* iinc *\/, 1\/* i2l *\/,\n-        1\/* i2f *\/, 1\/* i2d *\/, 2\/* l2i *\/, 2\/* l2f *\/, 2\/* l2d *\/, 1\/* f2i *\/, 1\/* f2l *\/, 1\/* f2d *\/, 2\/* d2i *\/, 2\/* d2l *\/, 2\/* d2f *\/, 1\/* i2b *\/,\n-        1\/* i2c *\/, 1\/* i2s *\/, 4\/* lcmp *\/, 2\/* fcmpl *\/, 2\/* fcmpg *\/, 4\/* dcmpl *\/, 4\/* dcmpg *\/, 1\/* ifeq *\/, 1\/* ifne *\/, 1\/* iflt *\/, 1\/* ifge *\/,\n-        1\/* ifgt *\/, 1\/* ifle *\/, 2\/* if_icmpeq *\/, 2\/* if_icmpne *\/, 2\/* if_icmplt *\/, 2 \/* if_icmpge *\/, 2\/* if_icmpgt *\/, 2\/* if_icmple *\/, 2\/* if_acmpeq *\/,\n-        2\/* if_acmpne *\/, 0\/* goto *\/, 0\/* jsr *\/, 0\/* ret *\/, 1\/* tableswitch *\/, 1\/* lookupswitch *\/, 1\/* ireturn *\/, 2\/* lreturn *\/, 1\/* freturn *\/,\n-        2\/* dreturn *\/, 1\/* areturn *\/, 0\/* return *\/, 0\/* getstatic *\/, UNPREDICTABLE\/* putstatic *\/, 1\/* getfield *\/, UNPREDICTABLE\/* putfield *\/,\n-        UNPREDICTABLE\/* invokevirtual *\/, UNPREDICTABLE\/* invokespecial *\/, UNPREDICTABLE\/* invokestatic *\/, UNPREDICTABLE\/* invokeinterface *\/,\n-        UNPREDICTABLE\/* invokedynamic *\/, 0\/* new *\/, 1\/* newarray *\/, 1\/* anewarray *\/, 1\/* arraylength *\/, 1\/* athrow *\/, 1\/* checkcast *\/, 1\/* instanceof *\/,\n-        1\/* monitorenter *\/, 1\/* monitorexit *\/, 0\/* wide *\/, UNPREDICTABLE\/* multianewarray *\/, 1\/* ifnull *\/, 1\/* ifnonnull *\/, 0\/* goto_w *\/, 0\/* jsr_w *\/,\n-        0\/* breakpoint *\/, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNPREDICTABLE\/* impdep1 *\/, UNPREDICTABLE\/* impdep2 *\/\n-    };\n-\n-    \/**\n-     * Number of words produced onto operand stack by instructions. Indexed by opcode. CONSUME_STACK[DALOAD] = number of\n-     * words consumed from the stack by a daload instruction.\n-     *\/\n-    static final int[] PRODUCE_STACK = {0\/* nop *\/, 1\/* aconst_null *\/, 1\/* iconst_m1 *\/, 1\/* iconst_0 *\/, 1\/* iconst_1 *\/, 1\/* iconst_2 *\/,\n-        1\/* iconst_3 *\/, 1\/* iconst_4 *\/, 1\/* iconst_5 *\/, 2\/* lconst_0 *\/, 2\/* lconst_1 *\/, 1\/* fconst_0 *\/, 1\/* fconst_1 *\/, 1\/* fconst_2 *\/, 2\/* dconst_0 *\/,\n-        2\/* dconst_1 *\/, 1\/* bipush *\/, 1\/* sipush *\/, 1\/* ldc *\/, 1\/* ldc_w *\/, 2\/* ldc2_w *\/, 1\/* iload *\/, 2\/* lload *\/, 1\/* fload *\/, 2\/* dload *\/,\n-        1\/* aload *\/, 1\/* iload_0 *\/, 1\/* iload_1 *\/, 1\/* iload_2 *\/, 1\/* iload_3 *\/, 2\/* lload_0 *\/, 2\/* lload_1 *\/, 2\/* lload_2 *\/, 2\/* lload_3 *\/,\n-        1\/* fload_0 *\/, 1\/* fload_1 *\/, 1\/* fload_2 *\/, 1\/* fload_3 *\/, 2\/* dload_0 *\/, 2\/* dload_1 *\/, 2\/* dload_2 *\/, 2\/* dload_3 *\/, 1\/* aload_0 *\/,\n-        1\/* aload_1 *\/, 1\/* aload_2 *\/, 1\/* aload_3 *\/, 1\/* iaload *\/, 2\/* laload *\/, 1\/* faload *\/, 2\/* daload *\/, 1\/* aaload *\/, 1\/* baload *\/, 1\/* caload *\/,\n-        1\/* saload *\/, 0\/* istore *\/, 0\/* lstore *\/, 0\/* fstore *\/, 0\/* dstore *\/, 0\/* astore *\/, 0\/* istore_0 *\/, 0\/* istore_1 *\/, 0\/* istore_2 *\/,\n-        0\/* istore_3 *\/, 0\/* lstore_0 *\/, 0\/* lstore_1 *\/, 0\/* lstore_2 *\/, 0\/* lstore_3 *\/, 0\/* fstore_0 *\/, 0\/* fstore_1 *\/, 0\/* fstore_2 *\/, 0\/* fstore_3 *\/,\n-        0\/* dstore_0 *\/, 0\/* dstore_1 *\/, 0\/* dstore_2 *\/, 0\/* dstore_3 *\/, 0\/* astore_0 *\/, 0\/* astore_1 *\/, 0\/* astore_2 *\/, 0\/* astore_3 *\/, 0\/* iastore *\/,\n-        0\/* lastore *\/, 0\/* fastore *\/, 0\/* dastore *\/, 0\/* aastore *\/, 0\/* bastore *\/, 0\/* castore *\/, 0\/* sastore *\/, 0\/* pop *\/, 0\/* pop2 *\/, 2\/* dup *\/,\n-        3\/* dup_x1 *\/, 4\/* dup_x2 *\/, 4\/* dup2 *\/, 5\/* dup2_x1 *\/, 6\/* dup2_x2 *\/, 2\/* swap *\/, 1\/* iadd *\/, 2\/* ladd *\/, 1\/* fadd *\/, 2\/* dadd *\/, 1\/* isub *\/,\n-        2\/* lsub *\/, 1\/* fsub *\/, 2\/* dsub *\/, 1\/* imul *\/, 2\/* lmul *\/, 1\/* fmul *\/, 2\/* dmul *\/, 1\/* idiv *\/, 2\/* ldiv *\/, 1\/* fdiv *\/, 2\/* ddiv *\/,\n-        1\/* irem *\/, 2\/* lrem *\/, 1\/* frem *\/, 2\/* drem *\/, 1\/* ineg *\/, 2\/* lneg *\/, 1\/* fneg *\/, 2\/* dneg *\/, 1\/* ishl *\/, 2\/* lshl *\/, 1\/* ishr *\/,\n-        2\/* lshr *\/, 1\/* iushr *\/, 2\/* lushr *\/, 1\/* iand *\/, 2\/* land *\/, 1\/* ior *\/, 2\/* lor *\/, 1\/* ixor *\/, 2\/* lxor *\/, 0\/* iinc *\/, 2\/* i2l *\/,\n-        1\/* i2f *\/, 2\/* i2d *\/, 1\/* l2i *\/, 1\/* l2f *\/, 2\/* l2d *\/, 1\/* f2i *\/, 2\/* f2l *\/, 2\/* f2d *\/, 1\/* d2i *\/, 2\/* d2l *\/, 1\/* d2f *\/, 1\/* i2b *\/,\n-        1\/* i2c *\/, 1\/* i2s *\/, 1\/* lcmp *\/, 1\/* fcmpl *\/, 1\/* fcmpg *\/, 1\/* dcmpl *\/, 1\/* dcmpg *\/, 0\/* ifeq *\/, 0\/* ifne *\/, 0\/* iflt *\/, 0\/* ifge *\/,\n-        0\/* ifgt *\/, 0\/* ifle *\/, 0\/* if_icmpeq *\/, 0\/* if_icmpne *\/, 0\/* if_icmplt *\/, 0\/* if_icmpge *\/, 0\/* if_icmpgt *\/, 0\/* if_icmple *\/, 0\/* if_acmpeq *\/,\n-        0\/* if_acmpne *\/, 0\/* goto *\/, 1\/* jsr *\/, 0\/* ret *\/, 0\/* tableswitch *\/, 0\/* lookupswitch *\/, 0\/* ireturn *\/, 0\/* lreturn *\/, 0\/* freturn *\/,\n-        0\/* dreturn *\/, 0\/* areturn *\/, 0\/* return *\/, UNPREDICTABLE\/* getstatic *\/, 0\/* putstatic *\/, UNPREDICTABLE\/* getfield *\/, 0\/* putfield *\/,\n-        UNPREDICTABLE\/* invokevirtual *\/, UNPREDICTABLE\/* invokespecial *\/, UNPREDICTABLE\/* invokestatic *\/, UNPREDICTABLE\/* invokeinterface *\/,\n-        UNPREDICTABLE\/* invokedynamic *\/, 1\/* new *\/, 1\/* newarray *\/, 1\/* anewarray *\/, 1\/* arraylength *\/, 1\/* athrow *\/, 1\/* checkcast *\/, 1\/* instanceof *\/,\n-        0\/* monitorenter *\/, 0\/* monitorexit *\/, 0\/* wide *\/, 1\/* multianewarray *\/, 0\/* ifnull *\/, 0\/* ifnonnull *\/, 0\/* goto_w *\/, 1\/* jsr_w *\/,\n-        0\/* breakpoint *\/, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNPREDICTABLE\/* impdep1 *\/, UNPREDICTABLE\/* impdep2 *\/\n-    };\n-\n-    \/**\n-     * Attributes and their corresponding names.\n-     *\/\n-    public static final byte ATTR_UNKNOWN = -1;\n-\n-    public static final byte ATTR_SOURCE_FILE = 0;\n-\n-    public static final byte ATTR_CONSTANT_VALUE = 1;\n-\n-    public static final byte ATTR_CODE = 2;\n-\n-    public static final byte ATTR_EXCEPTIONS = 3;\n-\n-    public static final byte ATTR_LINE_NUMBER_TABLE = 4;\n-\n-    public static final byte ATTR_LOCAL_VARIABLE_TABLE = 5;\n-\n-    public static final byte ATTR_INNER_CLASSES = 6;\n-\n-    public static final byte ATTR_SYNTHETIC = 7;\n-\n-    public static final byte ATTR_DEPRECATED = 8;\n-\n-    public static final byte ATTR_PMG = 9;\n-\n-    public static final byte ATTR_SIGNATURE = 10;\n-\n-    public static final byte ATTR_STACK_MAP = 11;\n-    public static final byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS = 12;\n-    public static final byte ATTR_RUNTIME_INVISIBLE_ANNOTATIONS = 13;\n-    public static final byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = 14;\n-    public static final byte ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = 15;\n-    public static final byte ATTR_ANNOTATION_DEFAULT = 16;\n-    public static final byte ATTR_LOCAL_VARIABLE_TYPE_TABLE = 17;\n-    public static final byte ATTR_ENCLOSING_METHOD = 18;\n-    public static final byte ATTR_STACK_MAP_TABLE = 19;\n-    public static final byte ATTR_BOOTSTRAP_METHODS = 20;\n-    public static final byte ATTR_METHOD_PARAMETERS = 21;\n-    public static final byte ATTR_MODULE = 22;\n-    public static final byte ATTR_MODULE_PACKAGES = 23;\n-    public static final byte ATTR_MODULE_MAIN_CLASS = 24;\n-    public static final byte ATTR_NEST_HOST = 25;\n-    public static final byte ATTR_NEST_MEMBERS = 26;\n-    public static final short KNOWN_ATTRIBUTES = 27; \/\/ count of attributes\n-    private static final String[] ATTRIBUTE_NAMES = {\"SourceFile\", \"ConstantValue\", \"Code\", \"Exceptions\", \"LineNumberTable\", \"LocalVariableTable\",\n-        \"InnerClasses\", \"Synthetic\", \"Deprecated\", \"PMGClass\", \"Signature\", \"StackMap\", \"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\",\n-        \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", \"AnnotationDefault\", \"LocalVariableTypeTable\", \"EnclosingMethod\",\n-        \"StackMapTable\", \"BootstrapMethods\", \"MethodParameters\", \"Module\", \"ModulePackages\", \"ModuleMainClass\", \"NestHost\", \"NestMembers\"};\n-    \/**\n-     * Constants used in the StackMap attribute.\n-     *\/\n-    public static final byte ITEM_Bogus = 0;\n-    public static final byte ITEM_Integer = 1;\n-    public static final byte ITEM_Float = 2;\n-    public static final byte ITEM_Double = 3;\n-    public static final byte ITEM_Long = 4;\n-    public static final byte ITEM_Null = 5;\n-    public static final byte ITEM_InitObject = 6;\n-    public static final byte ITEM_Object = 7;\n-    public static final byte ITEM_NewObject = 8;\n-    private static final String[] ITEM_NAMES = {\"Bogus\", \"Integer\", \"Float\", \"Double\", \"Long\", \"Null\", \"InitObject\", \"Object\", \"NewObject\"};\n-\n-    \/**\n-     * Constants used to identify StackMapEntry types.\n-     *\n-     * For those types which can specify a range, the constant names the lowest value.\n-     *\/\n-    public static final int SAME_FRAME = 0;\n-\n-    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n-\n-    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n-\n-    public static final int CHOP_FRAME = 248;\n-    public static final int SAME_FRAME_EXTENDED = 251;\n-    public static final int APPEND_FRAME = 252;\n-    public static final int FULL_FRAME = 255;\n-    \/**\n-     * Constants that define the maximum value of those constants which store ranges.\n-     *\/\n-\n-    public static final int SAME_FRAME_MAX = 63;\n-    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_MAX = 127;\n-    public static final int CHOP_FRAME_MAX = 250;\n-    public static final int APPEND_FRAME_MAX = 254;\n-    public static final byte REF_getField = 1;\n-\n-    public static final byte REF_getStatic = 2;\n-\n-    public static final byte REF_putField = 3;\n-\n-    public static final byte REF_putStatic = 4;\n-    public static final byte REF_invokeVirtual = 5;\n-    public static final byte REF_invokeStatic = 6;\n-    public static final byte REF_invokeSpecial = 7;\n-    public static final byte REF_newInvokeSpecial = 8;\n-    public static final byte REF_invokeInterface = 9;\n-    \/**\n-     * The names of the reference_kinds of a CONSTANT_MethodHandle_info.\n-     *\/\n-    private static final String[] METHODHANDLE_NAMES = {\"\", \"getField\", \"getStatic\", \"putField\", \"putStatic\", \"invokeVirtual\", \"invokeStatic\", \"invokeSpecial\",\n-        \"newInvokeSpecial\", \"invokeInterface\"};\n-\n-    \/**\n-     * @param index\n-     * @return the ACCESS_NAMES entry at the given index\n-     * @since 6.0\n-     *\/\n-    public static String getAccessName(final int index) {\n-        return ACCESS_NAMES[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the attribute name\n-     * @since 6.0\n-     *\/\n-    public static String getAttributeName(final int index) {\n-        return ATTRIBUTE_NAMES[index];\n-    }\n-\n-    \/**\n-     * The primitive class names corresponding to the T_XX constants, e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n-     *\n-     * @param index\n-     * @return the class name\n-     * @since 6.0\n-     *\/\n-    public static String getClassTypeName(final int index) {\n-        return CLASS_TYPE_NAMES[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the CONSTANT_NAMES entry at the given index\n-     * @since 6.0\n-     *\/\n-    public static String getConstantName(final int index) {\n-        return CONSTANT_NAMES[index];\n-    }\n-\n-    \/\/ Constants defining the behavior of the Method Handles (JVMS 5.4.3.5)\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return Number of words consumed on operand stack\n-     * @since 6.0\n-     *\/\n-    public static int getConsumeStack(final int index) {\n-        return CONSUME_STACK[index];\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static Iterable<String> getInterfacesImplementedByArrays() {\n-        return Collections.unmodifiableList(Arrays.asList(INTERFACES_IMPLEMENTED_BY_ARRAYS));\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the item name\n-     * @since 6.0\n-     *\/\n-    public static String getItemName(final int index) {\n-        return ITEM_NAMES[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the method handle name\n-     * @since 6.0\n-     *\/\n-    public static String getMethodHandleName(final int index) {\n-        return METHODHANDLE_NAMES[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return Number of byte code operands\n-     * @since 6.0\n-     *\/\n-    public static short getNoOfOperands(final int index) {\n-        return NO_OF_OPERANDS[index];\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static String getOpcodeName(final int index) {\n-        return OPCODE_NAMES[index];\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static short getOperandType(final int opcode, final int index) {\n-        return TYPE_OF_OPERANDS[opcode][index];\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static long getOperandTypeCount(final int opcode) {\n-        return TYPE_OF_OPERANDS[opcode].length;\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return Number of words produced onto operand stack\n-     * @since 6.0\n-     *\/\n-    public static int getProduceStack(final int index) {\n-        return PRODUCE_STACK[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the short type name\n-     * @since 6.0\n-     *\/\n-    public static String getShortTypeName(final int index) {\n-        return SHORT_TYPE_NAMES[index];\n-    }\n-\n-    \/**\n-     * The primitive type names corresponding to the T_XX constants, e.g., TYPE_NAMES[T_INT] = \"int\"\n-     *\n-     * @param index\n-     * @return the type name\n-     * @since 6.0\n-     *\/\n-    public static String getTypeName(final int index) {\n-        return TYPE_NAMES[index];\n-    }\n-\n-    private Const() {\n-    } \/\/ not instantiable\n+  \/**\n+   * Java class file format Magic number (0xCAFEBABE)\n+   *\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.1-200-A\">\n+   * The ClassFile Structure in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final int JVM_CLASSFILE_MAGIC = 0xCAFEBABE;\n+\n+  \/** Major version number of class files for Java 1.1.\n+   *  @see #MINOR_1_1\n+   *  *\/\n+  public static final short MAJOR_1_1 = 45;\n+\n+  \/** Minor version number of class files for Java 1.1.\n+   *  @see #MAJOR_1_1\n+   *  *\/\n+  public static final short MINOR_1_1 = 3;\n+\n+  \/** Major version number of class files for Java 1.2.\n+   *  @see #MINOR_1_2\n+   *  *\/\n+  public static final short MAJOR_1_2 = 46;\n+\n+  \/** Minor version number of class files for Java 1.2.\n+   *  @see #MAJOR_1_2\n+   *  *\/\n+  public static final short MINOR_1_2 = 0;\n+\n+  \/** Major version number of class files for Java 1.2.\n+   *  @see #MINOR_1_2\n+   *  *\/\n+  public static final short MAJOR_1_3 = 47;\n+\n+  \/** Minor version number of class files for Java 1.3.\n+   *  @see #MAJOR_1_3\n+   *  *\/\n+  public static final short MINOR_1_3 = 0;\n+\n+  \/** Major version number of class files for Java 1.3.\n+   *  @see #MINOR_1_3\n+   *  *\/\n+  public static final short MAJOR_1_4 = 48;\n+\n+  \/** Minor version number of class files for Java 1.4.\n+   *  @see #MAJOR_1_4\n+   *  *\/\n+  public static final short MINOR_1_4 = 0;\n+\n+  \/** Major version number of class files for Java 1.4.\n+   *  @see #MINOR_1_4\n+   *  *\/\n+  public static final short MAJOR_1_5 = 49;\n+\n+  \/** Minor version number of class files for Java 1.5.\n+   *  @see #MAJOR_1_5\n+   *  *\/\n+  public static final short MINOR_1_5 = 0;\n+\n+  \/** Major version number of class files for Java 1.6.\n+   *  @see #MINOR_1_6\n+   *  *\/\n+  public static final short MAJOR_1_6 = 50;\n+\n+  \/** Minor version number of class files for Java 1.6.\n+   *  @see #MAJOR_1_6\n+   *  *\/\n+  public static final short MINOR_1_6 = 0;\n+\n+  \/** Major version number of class files for Java 1.7.\n+   *  @see #MINOR_1_7\n+   *  *\/\n+  public static final short MAJOR_1_7 = 51;\n+\n+  \/** Minor version number of class files for Java 1.7.\n+   *  @see #MAJOR_1_7\n+   *  *\/\n+  public static final short MINOR_1_7 = 0;\n+\n+  \/** Major version number of class files for Java 1.8.\n+   *  @see #MINOR_1_8\n+   *  *\/\n+  public static final short MAJOR_1_8 = 52;\n+\n+  \/** Minor version number of class files for Java 1.8.\n+   *  @see #MAJOR_1_8\n+   *  *\/\n+  public static final short MINOR_1_8 = 0;\n+\n+  \/** Major version number of class files for Java 9.\n+   *  @see #MINOR_9\n+   *  *\/\n+  public static final short MAJOR_9 = 53;\n+\n+  \/** Minor version number of class files for Java 9.\n+   *  @see #MAJOR_9\n+   *  *\/\n+  public static final short MINOR_9 = 0;\n+\n+  \/**\n+   * @deprecated Use {@link #MAJOR_9} instead\n+   *\/\n+  @Deprecated\n+  public static final short MAJOR_1_9 = MAJOR_9;\n+\n+  \/**\n+   * @deprecated Use {@link #MINOR_9} instead\n+   *\/\n+  @Deprecated\n+  public static final short MINOR_1_9 = MINOR_9;\n+\n+  \/** Major version number of class files for Java 10.\n+   *  @see #MINOR_10\n+   *  *\/\n+  public static final short MAJOR_10 = 54;\n+\n+  \/** Minor version number of class files for Java 10.\n+   *  @see #MAJOR_10\n+   *  *\/\n+  public static final short MINOR_10 = 0;\n+\n+  \/** Major version number of class files for Java 11.\n+   *  @see #MINOR_11\n+   *  *\/\n+  public static final short MAJOR_11 = 55;\n+\n+  \/** Minor version number of class files for Java 11.\n+   *  @see #MAJOR_11\n+   *  *\/\n+  public static final short MINOR_11 = 0;\n+\n+  \/** Major version number of class files for Java 12.\n+   *  @see #MINOR_12\n+   *  *\/\n+  public static final short MAJOR_12 = 56;\n+\n+  \/** Minor version number of class files for Java 12.\n+   *  @see #MAJOR_12\n+   *  *\/\n+  public static final short MINOR_12 = 0;\n+\n+  \/** Major version number of class files for Java 13.\n+   *  @see #MINOR_13\n+   *  *\/\n+  public static final short MAJOR_13 = 57;\n+\n+  \/** Minor version number of class files for Java 13.\n+   *  @see #MAJOR_13\n+   *  *\/\n+  public static final short MINOR_13 = 0;\n+\n+  \/** Major version number of class files for Java 14.\n+   *  @see #MINOR_14\n+   *  @since 6.4.0\n+   *  *\/\n+  public static final short MAJOR_14 = 58;\n+\n+  \/** Minor version number of class files for Java 14.\n+   *  @see #MAJOR_14\n+   *  @since 6.4.0\n+   *  *\/\n+  public static final short MINOR_14 = 0;\n+\n+  \/** Default major version number.  Class file is for Java 1.1.\n+   *  @see #MAJOR_1_1\n+   *  *\/\n+  public static final short MAJOR = MAJOR_1_1;\n+\n+  \/** Default major version number.  Class file is for Java 1.1.\n+   *  @see #MAJOR_1_1\n+   *  *\/\n+  public static final short MINOR     = MINOR_1_1;\n+\n+  \/** Maximum value for an unsigned short.\n+   *\/\n+  public static final int MAX_SHORT = 65535; \/\/ 2^16 - 1\n+\n+  \/** Maximum value for an unsigned byte.\n+   *\/\n+  public static final int MAX_BYTE  = 255; \/\/ 2^8 - 1\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *\n+   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.1-200-E.1\">\n+   *  Flag definitions for Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.5\">\n+   *  Flag definitions for Fields in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.6\">\n+   *  Flag definitions for Methods in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.7.6-300-D.1-D.1\">\n+   *  Flag definitions for Inner Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+   *\/\n+  public static final short ACC_PUBLIC       = 0x0001;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_PRIVATE      = 0x0002;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_PROTECTED    = 0x0004;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_STATIC       = 0x0008;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_FINAL        = 0x0010;\n+\n+  \/** One of the access flags for the Module attribute.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_OPEN         = 0x0020;\n+\n+  \/** One of the access flags for classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_SUPER        = 0x0020;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_SYNCHRONIZED = 0x0020;\n+\n+  \/** One of the access flags for the Module attribute.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_TRANSITIVE   = 0x0020;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_BRIDGE       = 0x0040;\n+\n+  \/** One of the access flags for the Module attribute.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_STATIC_PHASE = 0x0040;\n+\n+  \/** One of the access flags for fields.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_VOLATILE     = 0x0040;\n+\n+  \/** One of the access flags for fields.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_TRANSIENT    = 0x0080;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_VARARGS      = 0x0080;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_NATIVE       = 0x0100;\n+\n+  \/** One of the access flags for classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_INTERFACE    = 0x0200;\n+\n+  \/** One of the access flags for methods or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_ABSTRACT     = 0x0400;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_STRICT       = 0x0800;\n+\n+  \/** One of the access flags for fields, methods, classes, MethodParameter attribute, or Module attribute.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_SYNTHETIC    = 0x1000;\n+\n+  \/** One of the access flags for classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_ANNOTATION   = 0x2000;\n+\n+  \/** One of the access flags for fields or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_ENUM         = 0x4000;\n+\n+  \/\/ Applies to classes compiled by new compilers only\n+  \/** One of the access flags for MethodParameter or Module attributes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_MANDATED     = (short) 0x8000;\n+\n+  \/** One of the access flags for classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_MODULE       = (short) 0x8000;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *  @deprecated Use {@link #MAX_ACC_FLAG_I}\n+   *\/\n+  @Deprecated\n+  public static final short MAX_ACC_FLAG     = ACC_ENUM;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   * ACC_MODULE is negative as a short.\n+   * @see #ACC_PUBLIC\n+   * @since 6.4.0\n+   *\/\n+  public static final int MAX_ACC_FLAG_I = 0x8000; \/\/ ACC_MODULE is negative as a short\n+\n+  \/\/ Note that do to overloading:\n+  \/\/ 'synchronized' is for methods, might be 'open' (if Module), 'super' (if class), or 'transitive' (if Module).\n+  \/\/ 'volatile'     is for fields,  might be 'bridge' (if method) or 'static_phase' (if Module)\n+  \/\/ 'transient'    is for fields,  might be 'varargs' (if method)\n+  \/\/ 'module'       is for classes, might be 'mandated' (if Module or MethodParameters)\n+  \/**\n+   * The names of the access flags.\n+   *\/\n+  private static final String[] ACCESS_NAMES = {\n+    \"public\", \"private\", \"protected\", \"static\", \"final\", \"synchronized\",\n+    \"volatile\", \"transient\", \"native\", \"interface\", \"abstract\", \"strictfp\",\n+    \"synthetic\", \"annotation\", \"enum\", \"module\"\n+  };\n+\n+  \/** @since 6.0 *\/\n+  public static final int ACCESS_NAMES_LENGTH = ACCESS_NAMES.length;\n+\n+  \/**\n+   * @param index\n+   * @return the ACCESS_NAMES entry at the given index\n+   * @since 6.0\n+   *\/\n+  public static String getAccessName(final int index) {\n+      return ACCESS_NAMES[index];\n+  }\n+\n+  \/*\n+   * The description of the constant pool is at:\n+   * http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4\n+   * References below are to the individual sections\n+   *\/\n+\n+  \/**\n+   * Marks a constant pool entry as type UTF-8.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.7\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Utf8               = 1;\n+\n+  \/**\n+   * Marks a constant pool entry as type Integer.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Integer            = 3;\n+\n+  \/**\n+   * Marks a constant pool entry as type Float.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Float              = 4;\n+\n+  \/**\n+   * Marks a constant pool entry as type Long.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Long               = 5;\n+\n+  \/**\n+   * Marks a constant pool entry as type Double.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Double             = 6;\n+\n+  \/**\n+   * Marks a constant pool entry as a Class\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.1\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Class              = 7;\n+\n+  \/**\n+   * Marks a constant pool entry as a Field Reference.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Fieldref           = 9;\n+\n+  \/**\n+   * Marks a constant pool entry as type String\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.3\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_String             = 8;\n+\n+  \/** Marks a constant pool entry as a Method Reference.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a> *\/\n+  public static final byte CONSTANT_Methodref          = 10;\n+\n+  \/**\n+   * Marks a constant pool entry as an Interface Method Reference.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_InterfaceMethodref = 11;\n+\n+  \/** Marks a constant pool entry as a name and type.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.6\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a> *\/\n+  public static final byte CONSTANT_NameAndType        = 12;\n+\n+  \/**\n+   * Marks a constant pool entry as a Method Handle.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.8\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_MethodHandle       = 15;\n+\n+  \/**\n+   * Marks a constant pool entry as a Method Type.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.9\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_MethodType         = 16;\n+\n+  \/**\n+   * Marks a constant pool entry as dynamically computed.\n+   * @see  <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\">\n+   * Change request for JEP 309<\/a>\n+   * @since 6.3\n+   *\/\n+  public static final byte CONSTANT_Dynamic            = 17;\n+\n+  \/**\n+   * Marks a constant pool entry as an Invoke Dynamic\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_InvokeDynamic      = 18;\n+\n+  \/**\n+   * Marks a constant pool entry as a Module Reference.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.11\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   * @since 6.1\n+   *\/\n+  public static final byte CONSTANT_Module             = 19;\n+\n+  \/**\n+   * Marks a constant pool entry as a Package Reference.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.12\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   * @since 6.1\n+   *\/\n+  public static final byte CONSTANT_Package            = 20;\n+\n+  \/**\n+   * The names of the types of entries in a constant pool.\n+   * Use getConstantName instead\n+   *\/\n+  private static final String[] CONSTANT_NAMES = {\n+    \"\", \"CONSTANT_Utf8\", \"\", \"CONSTANT_Integer\",\n+    \"CONSTANT_Float\", \"CONSTANT_Long\", \"CONSTANT_Double\",\n+    \"CONSTANT_Class\", \"CONSTANT_String\", \"CONSTANT_Fieldref\",\n+    \"CONSTANT_Methodref\", \"CONSTANT_InterfaceMethodref\",\n+    \"CONSTANT_NameAndType\", \"\", \"\", \"CONSTANT_MethodHandle\",\n+    \"CONSTANT_MethodType\", \"CONSTANT_Dynamic\", \"CONSTANT_InvokeDynamic\",\n+    \"CONSTANT_Module\", \"CONSTANT_Package\"};\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the CONSTANT_NAMES entry at the given index\n+   * @since 6.0\n+   *\/\n+  public static String getConstantName(final int index) {\n+      return CONSTANT_NAMES[index];\n+  }\n+\n+  \/** The name of the static initializer, also called &quot;class\n+   *  initialization method&quot; or &quot;interface initialization\n+   *   method&quot;. This is &quot;&lt;clinit&gt;&quot;.\n+   *\/\n+  public static final String STATIC_INITIALIZER_NAME = \"<clinit>\";\n+\n+  \/** The name of every constructor method in a class, also called\n+   * &quot;instance initialization method&quot;. This is &quot;&lt;init&gt;&quot;.\n+   *\/\n+  public static final String CONSTRUCTOR_NAME = \"<init>\";\n+\n+  \/**\n+   * The names of the interfaces implemented by arrays\n+   *\/\n+  private static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = {\"java.lang.Cloneable\", \"java.io.Serializable\"};\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static Iterable<String> getInterfacesImplementedByArrays() {\n+      return Collections.unmodifiableList(Arrays.asList(INTERFACES_IMPLEMENTED_BY_ARRAYS));\n+  }\n+\n+  \/**\n+   * Maximum Constant Pool entries.\n+   * One of the limitations of the Java Virtual Machine.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.11-100-A\">\n+   * The Java Virtual Machine Specification, Java SE 8 Edition, page 330, chapter 4.11.<\/a>\n+   *\/\n+  public static final int MAX_CP_ENTRIES     = 65535;\n+\n+  \/**\n+   * Maximum code size (plus one; the code size must be LESS than this)\n+   * One of the limitations of the Java Virtual Machine.\n+   * Note vmspec2 page 152 (\"Limitations\") says:\n+   * \"The amount of code per non-native, non-abstract method is limited to 65536 bytes by\n+   * the sizes of the indices in the exception_table of the Code attribute (4.7.3),\n+   * in the LineNumberTable attribute (4.7.8), and in the LocalVariableTable attribute (4.7.9).\"\n+   * However this should be taken as an upper limit rather than the defined maximum.\n+   * On page 134 (4.8.1 Static Constants) of the same spec, it says:\n+   * \"The value of the code_length item must be less than 65536.\"\n+   * The entry in the Limitations section has been removed from later versions of the spec;\n+   * it is not present in the Java SE 8 edition.\n+   *\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.3-300-E\">\n+   * The Java Virtual Machine Specification, Java SE 8 Edition, page 104, chapter 4.7.<\/a>\n+   *\/\n+  public static final int MAX_CODE_SIZE      = 65536; \/\/bytes\n+\n+  \/**\n+   * The maximum number of dimensions in an array ({@value}).\n+   * One of the limitations of the Java Virtual Machine.\n+   *\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3.2-150\">\n+   * Field Descriptors in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final int MAX_ARRAY_DIMENSIONS = 255;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.nop\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short NOP              = 0;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aconst_null\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ACONST_NULL      = 1;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_M1        = 2;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_0         = 3;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_1         = 4;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_2         = 5;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_3         = 6;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_4         = 7;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_5         = 8;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LCONST_0         = 9;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LCONST_1         = 10;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCONST_0         = 11;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCONST_1         = 12;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCONST_2         = 13;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DCONST_0         = 14;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DCONST_1         = 15;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bipush\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short BIPUSH           = 16;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sipush\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short SIPUSH           = 17;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LDC              = 18;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc_w\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LDC_W            = 19;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc2_w\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LDC2_W           = 20;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD            = 21;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD            = 22;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD            = 23;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD            = 24;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD            = 25;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD_0          = 26;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD_1          = 27;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD_2          = 28;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD_3          = 29;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD_0          = 30;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD_1          = 31;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD_2          = 32;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD_3          = 33;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD_0          = 34;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD_1          = 35;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD_2          = 36;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD_3          = 37;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD_0          = 38;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD_1          = 39;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD_2          = 40;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD_3          = 41;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD_0          = 42;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD_1          = 43;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD_2          = 44;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD_3          = 45;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iaload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IALOAD           = 46;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.laload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LALOAD           = 47;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.faload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FALOAD           = 48;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.daload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DALOAD           = 49;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aaload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short AALOAD           = 50;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.baload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short BALOAD           = 51;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.caload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short CALOAD           = 52;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.saload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short SALOAD           = 53;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE           = 54;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE           = 55;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE           = 56;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE           = 57;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE           = 58;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE_0         = 59;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE_1         = 60;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE_2         = 61;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE_3         = 62;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE_0         = 63;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE_1         = 64;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE_2         = 65;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE_3         = 66;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE_0         = 67;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE_1         = 68;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE_2         = 69;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE_3         = 70;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE_0         = 71;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE_1         = 72;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE_2         = 73;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE_3         = 74;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE_0         = 75;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE_1         = 76;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE_2         = 77;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE_3         = 78;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IASTORE          = 79;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LASTORE          = 80;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FASTORE          = 81;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DASTORE          = 82;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short AASTORE          = 83;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short BASTORE          = 84;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.castore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short CASTORE          = 85;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short SASTORE          = 86;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short POP              = 87;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop2\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short POP2             = 88;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP              = 89;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x1\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP_X1           = 90;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x2\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP_X2           = 91;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP2             = 92;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x1\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP2_X1          = 93;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x2\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP2_X2          = 94;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.swap\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short SWAP             = 95;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iadd\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IADD             = 96;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ladd\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LADD             = 97;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fadd\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FADD             = 98;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dadd\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DADD             = 99;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.isub\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISUB             = 100;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lsub\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSUB             = 101;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fsub\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSUB             = 102;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dsub\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSUB             = 103;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.imul\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IMUL             = 104;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lmul\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LMUL             = 105;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fmul\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FMUL             = 106;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dmul\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DMUL             = 107;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.idiv\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IDIV             = 108;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldiv\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LDIV             = 109;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fdiv\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FDIV             = 110;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ddiv\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DDIV             = 111;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.irem\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IREM             = 112;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lrem\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LREM             = 113;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.frem\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FREM             = 114;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.drem\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DREM             = 115;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ineg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INEG             = 116;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lneg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LNEG             = 117;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fneg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FNEG             = 118;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dneg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DNEG             = 119;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishl\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISHL             = 120;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshl\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSHL             = 121;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISHR             = 122;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSHR             = 123;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iushr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IUSHR            = 124;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lushr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LUSHR            = 125;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iand\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IAND             = 126;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.land\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LAND             = 127;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ior\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IOR              = 128;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lor\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LOR              = 129;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ixor\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IXOR             = 130;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lxor\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LXOR             = 131;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iinc\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IINC             = 132;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2L              = 133;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2F              = 134;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2D              = 135;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short L2I              = 136;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short L2F              = 137;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short L2D              = 138;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short F2I              = 139;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short F2L              = 140;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short F2D              = 141;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short D2I              = 142;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short D2L              = 143;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short D2F              = 144;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2b\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2B              = 145;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INT2BYTE         = 145; \/\/ Old notation\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2c\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2C              = 146;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INT2CHAR         = 146; \/\/ Old notation\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2s\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2S              = 147;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INT2SHORT        = 147; \/\/ Old notation\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lcmp\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LCMP             = 148;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpl\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCMPL            = 149;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCMPG            = 150;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpl\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DCMPL            = 151;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DCMPG            = 152;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifeq\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFEQ             = 153;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifne\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFNE             = 154;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iflt\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFLT             = 155;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifge\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFGE             = 156;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifgt\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFGT             = 157;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifle\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFLE             = 158;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPEQ        = 159;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPNE        = 160;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPLT        = 161;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPGE        = 162;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPGT        = 163;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPLE        = 164;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ACMPEQ        = 165;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ACMPNE        = 166;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short GOTO             = 167;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short JSR              = 168;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ret\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short RET              = 169;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.tableswitch\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short TABLESWITCH      = 170;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lookupswitch\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LOOKUPSWITCH     = 171;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ireturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IRETURN          = 172;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lreturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LRETURN          = 173;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.freturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FRETURN          = 174;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dreturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DRETURN          = 175;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.areturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ARETURN          = 176;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.return\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short RETURN           = 177;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getstatic\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short GETSTATIC        = 178;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putstatic\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short PUTSTATIC        = 179;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getfield\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short GETFIELD         = 180;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putfield\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short PUTFIELD         = 181;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKEVIRTUAL    = 182;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKESPECIAL    = 183;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKENONVIRTUAL = 183; \/\/ Old name in JDK 1.0\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKESTATIC     = 184;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKEINTERFACE  = 185;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKEDYNAMIC    = 186;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.new\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short NEW              = 187;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.newarray\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short NEWARRAY         = 188;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.anewarray\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ANEWARRAY        = 189;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.arraylength\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ARRAYLENGTH      = 190;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.athrow\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ATHROW           = 191;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.checkcast\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short CHECKCAST        = 192;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.instanceof\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INSTANCEOF       = 193;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorenter\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short MONITORENTER     = 194;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorexit\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short MONITOREXIT      = 195;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.wide\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short WIDE             = 196;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.multianewarray\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short MULTIANEWARRAY   = 197;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnull\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFNULL           = 198;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnonnull\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFNONNULL        = 199;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto_w\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short GOTO_W           = 200;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr_w\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short JSR_W            = 201;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n+   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n+  public static final short BREAKPOINT                = 202;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short LDC_QUICK                 = 203;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short LDC_W_QUICK               = 204;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short LDC2_W_QUICK              = 205;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETFIELD_QUICK            = 206;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTFIELD_QUICK            = 207;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETFIELD2_QUICK           = 208;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTFIELD2_QUICK           = 209;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETSTATIC_QUICK           = 210;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTSTATIC_QUICK           = 211;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETSTATIC2_QUICK          = 212;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTSTATIC2_QUICK          = 213;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKEVIRTUAL_QUICK       = 214;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKENONVIRTUAL_QUICK    = 215;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKESUPER_QUICK         = 216;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKESTATIC_QUICK        = 217;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKEINTERFACE_QUICK     = 218;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKEVIRTUALOBJECT_QUICK = 219;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short NEW_QUICK                 = 221;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short ANEWARRAY_QUICK           = 222;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short MULTIANEWARRAY_QUICK      = 223;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short CHECKCAST_QUICK           = 224;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INSTANCEOF_QUICK          = 225;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKEVIRTUAL_QUICK_W     = 226;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETFIELD_QUICK_W          = 227;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTFIELD_QUICK_W          = 228;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n+   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n+  public static final short IMPDEP1                   = 254;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n+   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n+  public static final short IMPDEP2                   = 255;\n+\n+  \/**\n+   * BCEL virtual instruction for pushing an arbitrary data type onto the stack.  Will be converted to the appropriate JVM\n+   * opcode when the class is dumped.\n+   *\/\n+  public static final short PUSH             = 4711;\n+\n+  \/**\n+   * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH.  Will be converted to the appropriate JVM\n+   * opcode when the class is dumped.\n+   *\/\n+  public static final short SWITCH           = 4712;\n+\n+  \/** Illegal opcode. *\/\n+  public static final short  UNDEFINED      = -1;\n+\n+  \/** Illegal opcode. *\/\n+  public static final short  UNPREDICTABLE  = -2;\n+\n+  \/** Illegal opcode. *\/\n+  public static final short  RESERVED       = -3;\n+\n+  \/** Mnemonic for an illegal opcode. *\/\n+  public static final String ILLEGAL_OPCODE = \"<illegal opcode>\";\n+\n+  \/** Mnemonic for an illegal type. *\/\n+  public static final String ILLEGAL_TYPE   = \"<illegal type>\";\n+\n+  \/** Boolean data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_BOOLEAN = 4;\n+\n+  \/** Char data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_CHAR    = 5;\n+\n+  \/** Float data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_FLOAT   = 6;\n+\n+  \/** Double data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_DOUBLE  = 7;\n+\n+  \/** Byte data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_BYTE    = 8;\n+\n+  \/** Short data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_SHORT   = 9;\n+\n+  \/** Int data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_INT     = 10;\n+\n+  \/** Long data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_LONG    = 11;\n+\n+  \/** Void data type (non-standard). *\/\n+  public static final byte T_VOID      = 12; \/\/ Non-standard\n+\n+  \/** Array data type. *\/\n+  public static final byte T_ARRAY     = 13;\n+\n+  \/** Object data type. *\/\n+  public static final byte T_OBJECT    = 14;\n+\n+  \/** Reference data type (deprecated). *\/\n+  public static final byte T_REFERENCE = 14; \/\/ Deprecated\n+\n+  \/** Unknown data type. *\/\n+  public static final byte T_UNKNOWN   = 15;\n+\n+  \/** Address data type. *\/\n+  public static final byte T_ADDRESS   = 16;\n+\n+  \/** The primitive type names corresponding to the T_XX constants,\n+   * e.g., TYPE_NAMES[T_INT] = \"int\"\n+   *\/\n+  private static final String[] TYPE_NAMES = {\n+    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n+    \"boolean\", \"char\", \"float\", \"double\", \"byte\", \"short\", \"int\", \"long\",\n+    \"void\", \"array\", \"object\", \"unknown\", \"address\"\n+  };\n+\n+  \/**\n+   * The primitive type names corresponding to the T_XX constants,\n+   * e.g., TYPE_NAMES[T_INT] = \"int\"\n+   * @param index\n+   * @return the type name\n+   * @since 6.0\n+   *\/\n+  public static String getTypeName(final int index) {\n+      return TYPE_NAMES[index];\n+  }\n+\n+  \/** The primitive class names corresponding to the T_XX constants,\n+   * e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n+   *\/\n+  private static final String[] CLASS_TYPE_NAMES = {\n+    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n+    \"java.lang.Boolean\", \"java.lang.Character\", \"java.lang.Float\",\n+    \"java.lang.Double\", \"java.lang.Byte\", \"java.lang.Short\",\n+    \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Void\",\n+    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE,  ILLEGAL_TYPE\n+  };\n+\n+  \/**\n+   * The primitive class names corresponding to the T_XX constants,\n+   * e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n+   * @param index\n+   * @return the class name\n+   * @since 6.0\n+   *\/\n+  public static String getClassTypeName(final int index) {\n+      return CLASS_TYPE_NAMES[index];\n+  }\n+\n+  \/** The signature characters corresponding to primitive types,\n+   * e.g., SHORT_TYPE_NAMES[T_INT] = \"I\"\n+   *\/\n+  private static final String[] SHORT_TYPE_NAMES = {\n+    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n+    \"Z\", \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"J\",\n+    \"V\", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the short type name\n+   * @since 6.0\n+   *\/\n+  public static String getShortTypeName(final int index) {\n+      return SHORT_TYPE_NAMES[index];\n+  }\n+\n+\n+  \/**\n+   * Number of byte code operands for each opcode, i.e., number of bytes after the tag byte\n+   * itself.  Indexed by opcode, so NO_OF_OPERANDS[BIPUSH] = the number of operands for a bipush\n+   * instruction.\n+   *\/\n+  private static final short[] NO_OF_OPERANDS = {\n+    0\/*nop*\/, 0\/*aconst_null*\/, 0\/*iconst_m1*\/, 0\/*iconst_0*\/,\n+    0\/*iconst_1*\/, 0\/*iconst_2*\/, 0\/*iconst_3*\/, 0\/*iconst_4*\/,\n+    0\/*iconst_5*\/, 0\/*lconst_0*\/, 0\/*lconst_1*\/, 0\/*fconst_0*\/,\n+    0\/*fconst_1*\/, 0\/*fconst_2*\/, 0\/*dconst_0*\/, 0\/*dconst_1*\/,\n+    1\/*bipush*\/, 2\/*sipush*\/, 1\/*ldc*\/, 2\/*ldc_w*\/, 2\/*ldc2_w*\/,\n+    1\/*iload*\/, 1\/*lload*\/, 1\/*fload*\/, 1\/*dload*\/, 1\/*aload*\/,\n+    0\/*iload_0*\/, 0\/*iload_1*\/, 0\/*iload_2*\/, 0\/*iload_3*\/,\n+    0\/*lload_0*\/, 0\/*lload_1*\/, 0\/*lload_2*\/, 0\/*lload_3*\/,\n+    0\/*fload_0*\/, 0\/*fload_1*\/, 0\/*fload_2*\/, 0\/*fload_3*\/,\n+    0\/*dload_0*\/, 0\/*dload_1*\/, 0\/*dload_2*\/, 0\/*dload_3*\/,\n+    0\/*aload_0*\/, 0\/*aload_1*\/, 0\/*aload_2*\/, 0\/*aload_3*\/,\n+    0\/*iaload*\/, 0\/*laload*\/, 0\/*faload*\/, 0\/*daload*\/,\n+    0\/*aaload*\/, 0\/*baload*\/, 0\/*caload*\/, 0\/*saload*\/,\n+    1\/*istore*\/, 1\/*lstore*\/, 1\/*fstore*\/, 1\/*dstore*\/,\n+    1\/*astore*\/, 0\/*istore_0*\/, 0\/*istore_1*\/, 0\/*istore_2*\/,\n+    0\/*istore_3*\/, 0\/*lstore_0*\/, 0\/*lstore_1*\/, 0\/*lstore_2*\/,\n+    0\/*lstore_3*\/, 0\/*fstore_0*\/, 0\/*fstore_1*\/, 0\/*fstore_2*\/,\n+    0\/*fstore_3*\/, 0\/*dstore_0*\/, 0\/*dstore_1*\/, 0\/*dstore_2*\/,\n+    0\/*dstore_3*\/, 0\/*astore_0*\/, 0\/*astore_1*\/, 0\/*astore_2*\/,\n+    0\/*astore_3*\/, 0\/*iastore*\/, 0\/*lastore*\/, 0\/*fastore*\/,\n+    0\/*dastore*\/, 0\/*aastore*\/, 0\/*bastore*\/, 0\/*castore*\/,\n+    0\/*sastore*\/, 0\/*pop*\/, 0\/*pop2*\/, 0\/*dup*\/, 0\/*dup_x1*\/,\n+    0\/*dup_x2*\/, 0\/*dup2*\/, 0\/*dup2_x1*\/, 0\/*dup2_x2*\/, 0\/*swap*\/,\n+    0\/*iadd*\/, 0\/*ladd*\/, 0\/*fadd*\/, 0\/*dadd*\/, 0\/*isub*\/,\n+    0\/*lsub*\/, 0\/*fsub*\/, 0\/*dsub*\/, 0\/*imul*\/, 0\/*lmul*\/,\n+    0\/*fmul*\/, 0\/*dmul*\/, 0\/*idiv*\/, 0\/*ldiv*\/, 0\/*fdiv*\/,\n+    0\/*ddiv*\/, 0\/*irem*\/, 0\/*lrem*\/, 0\/*frem*\/, 0\/*drem*\/,\n+    0\/*ineg*\/, 0\/*lneg*\/, 0\/*fneg*\/, 0\/*dneg*\/, 0\/*ishl*\/,\n+    0\/*lshl*\/, 0\/*ishr*\/, 0\/*lshr*\/, 0\/*iushr*\/, 0\/*lushr*\/,\n+    0\/*iand*\/, 0\/*land*\/, 0\/*ior*\/, 0\/*lor*\/, 0\/*ixor*\/, 0\/*lxor*\/,\n+    2\/*iinc*\/, 0\/*i2l*\/, 0\/*i2f*\/, 0\/*i2d*\/, 0\/*l2i*\/, 0\/*l2f*\/,\n+    0\/*l2d*\/, 0\/*f2i*\/, 0\/*f2l*\/, 0\/*f2d*\/, 0\/*d2i*\/, 0\/*d2l*\/,\n+    0\/*d2f*\/, 0\/*i2b*\/, 0\/*i2c*\/, 0\/*i2s*\/, 0\/*lcmp*\/, 0\/*fcmpl*\/,\n+    0\/*fcmpg*\/, 0\/*dcmpl*\/, 0\/*dcmpg*\/, 2\/*ifeq*\/, 2\/*ifne*\/,\n+    2\/*iflt*\/, 2\/*ifge*\/, 2\/*ifgt*\/, 2\/*ifle*\/, 2\/*if_icmpeq*\/,\n+    2\/*if_icmpne*\/, 2\/*if_icmplt*\/, 2\/*if_icmpge*\/, 2\/*if_icmpgt*\/,\n+    2\/*if_icmple*\/, 2\/*if_acmpeq*\/, 2\/*if_acmpne*\/, 2\/*goto*\/,\n+    2\/*jsr*\/, 1\/*ret*\/, UNPREDICTABLE\/*tableswitch*\/, UNPREDICTABLE\/*lookupswitch*\/,\n+    0\/*ireturn*\/, 0\/*lreturn*\/, 0\/*freturn*\/,\n+    0\/*dreturn*\/, 0\/*areturn*\/, 0\/*return*\/,\n+    2\/*getstatic*\/, 2\/*putstatic*\/, 2\/*getfield*\/,\n+    2\/*putfield*\/, 2\/*invokevirtual*\/, 2\/*invokespecial*\/, 2\/*invokestatic*\/,\n+    4\/*invokeinterface*\/, 4\/*invokedynamic*\/, 2\/*new*\/,\n+    1\/*newarray*\/, 2\/*anewarray*\/,\n+    0\/*arraylength*\/, 0\/*athrow*\/, 2\/*checkcast*\/,\n+    2\/*instanceof*\/, 0\/*monitorenter*\/,\n+    0\/*monitorexit*\/, UNPREDICTABLE\/*wide*\/, 3\/*multianewarray*\/,\n+    2\/*ifnull*\/, 2\/*ifnonnull*\/, 4\/*goto_w*\/,\n+    4\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, RESERVED\/*impdep1*\/, RESERVED\/*impdep2*\/\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return Number of byte code operands\n+   * @since 6.0\n+   *\/\n+  public static short getNoOfOperands(final int index) {\n+      return NO_OF_OPERANDS[index];\n+  }\n+\n+  \/**\n+   * How the byte code operands are to be interpreted for each opcode.\n+   * Indexed by opcode.  TYPE_OF_OPERANDS[ILOAD] = an array of shorts\n+   * describing the data types for the instruction.\n+   *\/\n+  private static final short[][] TYPE_OF_OPERANDS = {\n+    {}\/*nop*\/, {}\/*aconst_null*\/, {}\/*iconst_m1*\/, {}\/*iconst_0*\/,\n+    {}\/*iconst_1*\/, {}\/*iconst_2*\/, {}\/*iconst_3*\/, {}\/*iconst_4*\/,\n+    {}\/*iconst_5*\/, {}\/*lconst_0*\/, {}\/*lconst_1*\/, {}\/*fconst_0*\/,\n+    {}\/*fconst_1*\/, {}\/*fconst_2*\/, {}\/*dconst_0*\/, {}\/*dconst_1*\/,\n+    {T_BYTE}\/*bipush*\/, {T_SHORT}\/*sipush*\/, {T_BYTE}\/*ldc*\/,\n+    {T_SHORT}\/*ldc_w*\/, {T_SHORT}\/*ldc2_w*\/,\n+    {T_BYTE}\/*iload*\/, {T_BYTE}\/*lload*\/, {T_BYTE}\/*fload*\/,\n+    {T_BYTE}\/*dload*\/, {T_BYTE}\/*aload*\/, {}\/*iload_0*\/,\n+    {}\/*iload_1*\/, {}\/*iload_2*\/, {}\/*iload_3*\/, {}\/*lload_0*\/,\n+    {}\/*lload_1*\/, {}\/*lload_2*\/, {}\/*lload_3*\/, {}\/*fload_0*\/,\n+    {}\/*fload_1*\/, {}\/*fload_2*\/, {}\/*fload_3*\/, {}\/*dload_0*\/,\n+    {}\/*dload_1*\/, {}\/*dload_2*\/, {}\/*dload_3*\/, {}\/*aload_0*\/,\n+    {}\/*aload_1*\/, {}\/*aload_2*\/, {}\/*aload_3*\/, {}\/*iaload*\/,\n+    {}\/*laload*\/, {}\/*faload*\/, {}\/*daload*\/, {}\/*aaload*\/,\n+    {}\/*baload*\/, {}\/*caload*\/, {}\/*saload*\/, {T_BYTE}\/*istore*\/,\n+    {T_BYTE}\/*lstore*\/, {T_BYTE}\/*fstore*\/, {T_BYTE}\/*dstore*\/,\n+    {T_BYTE}\/*astore*\/, {}\/*istore_0*\/, {}\/*istore_1*\/,\n+    {}\/*istore_2*\/, {}\/*istore_3*\/, {}\/*lstore_0*\/, {}\/*lstore_1*\/,\n+    {}\/*lstore_2*\/, {}\/*lstore_3*\/, {}\/*fstore_0*\/, {}\/*fstore_1*\/,\n+    {}\/*fstore_2*\/, {}\/*fstore_3*\/, {}\/*dstore_0*\/, {}\/*dstore_1*\/,\n+    {}\/*dstore_2*\/, {}\/*dstore_3*\/, {}\/*astore_0*\/, {}\/*astore_1*\/,\n+    {}\/*astore_2*\/, {}\/*astore_3*\/, {}\/*iastore*\/, {}\/*lastore*\/,\n+    {}\/*fastore*\/, {}\/*dastore*\/, {}\/*aastore*\/, {}\/*bastore*\/,\n+    {}\/*castore*\/, {}\/*sastore*\/, {}\/*pop*\/, {}\/*pop2*\/, {}\/*dup*\/,\n+    {}\/*dup_x1*\/, {}\/*dup_x2*\/, {}\/*dup2*\/, {}\/*dup2_x1*\/,\n+    {}\/*dup2_x2*\/, {}\/*swap*\/, {}\/*iadd*\/, {}\/*ladd*\/, {}\/*fadd*\/,\n+    {}\/*dadd*\/, {}\/*isub*\/, {}\/*lsub*\/, {}\/*fsub*\/, {}\/*dsub*\/,\n+    {}\/*imul*\/, {}\/*lmul*\/, {}\/*fmul*\/, {}\/*dmul*\/, {}\/*idiv*\/,\n+    {}\/*ldiv*\/, {}\/*fdiv*\/, {}\/*ddiv*\/, {}\/*irem*\/, {}\/*lrem*\/,\n+    {}\/*frem*\/, {}\/*drem*\/, {}\/*ineg*\/, {}\/*lneg*\/, {}\/*fneg*\/,\n+    {}\/*dneg*\/, {}\/*ishl*\/, {}\/*lshl*\/, {}\/*ishr*\/, {}\/*lshr*\/,\n+    {}\/*iushr*\/, {}\/*lushr*\/, {}\/*iand*\/, {}\/*land*\/, {}\/*ior*\/,\n+    {}\/*lor*\/, {}\/*ixor*\/, {}\/*lxor*\/, {T_BYTE, T_BYTE}\/*iinc*\/,\n+    {}\/*i2l*\/, {}\/*i2f*\/, {}\/*i2d*\/, {}\/*l2i*\/, {}\/*l2f*\/, {}\/*l2d*\/,\n+    {}\/*f2i*\/, {}\/*f2l*\/, {}\/*f2d*\/, {}\/*d2i*\/, {}\/*d2l*\/, {}\/*d2f*\/,\n+    {}\/*i2b*\/, {}\/*i2c*\/, {}\/*i2s*\/, {}\/*lcmp*\/, {}\/*fcmpl*\/,\n+    {}\/*fcmpg*\/, {}\/*dcmpl*\/, {}\/*dcmpg*\/, {T_SHORT}\/*ifeq*\/,\n+    {T_SHORT}\/*ifne*\/, {T_SHORT}\/*iflt*\/, {T_SHORT}\/*ifge*\/,\n+    {T_SHORT}\/*ifgt*\/, {T_SHORT}\/*ifle*\/, {T_SHORT}\/*if_icmpeq*\/,\n+    {T_SHORT}\/*if_icmpne*\/, {T_SHORT}\/*if_icmplt*\/,\n+    {T_SHORT}\/*if_icmpge*\/, {T_SHORT}\/*if_icmpgt*\/,\n+    {T_SHORT}\/*if_icmple*\/, {T_SHORT}\/*if_acmpeq*\/,\n+    {T_SHORT}\/*if_acmpne*\/, {T_SHORT}\/*goto*\/, {T_SHORT}\/*jsr*\/,\n+    {T_BYTE}\/*ret*\/, {}\/*tableswitch*\/, {}\/*lookupswitch*\/,\n+    {}\/*ireturn*\/, {}\/*lreturn*\/, {}\/*freturn*\/, {}\/*dreturn*\/,\n+    {}\/*areturn*\/, {}\/*return*\/, {T_SHORT}\/*getstatic*\/,\n+    {T_SHORT}\/*putstatic*\/, {T_SHORT}\/*getfield*\/,\n+    {T_SHORT}\/*putfield*\/, {T_SHORT}\/*invokevirtual*\/,\n+    {T_SHORT}\/*invokespecial*\/, {T_SHORT}\/*invokestatic*\/,\n+    {T_SHORT, T_BYTE, T_BYTE}\/*invokeinterface*\/, {T_SHORT, T_BYTE, T_BYTE}\/*invokedynamic*\/,\n+    {T_SHORT}\/*new*\/, {T_BYTE}\/*newarray*\/,\n+    {T_SHORT}\/*anewarray*\/, {}\/*arraylength*\/, {}\/*athrow*\/,\n+    {T_SHORT}\/*checkcast*\/, {T_SHORT}\/*instanceof*\/,\n+    {}\/*monitorenter*\/, {}\/*monitorexit*\/, {T_BYTE}\/*wide*\/,\n+    {T_SHORT, T_BYTE}\/*multianewarray*\/, {T_SHORT}\/*ifnull*\/,\n+    {T_SHORT}\/*ifnonnull*\/, {T_INT}\/*goto_w*\/, {T_INT}\/*jsr_w*\/,\n+    {}\/*breakpoint*\/, {}, {}, {}, {}, {}, {}, {},\n+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n+    {}\/*impdep1*\/, {}\/*impdep2*\/\n+  };\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static short getOperandType(final int opcode, final int index) {\n+      return TYPE_OF_OPERANDS[opcode][index];\n+  }\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static long getOperandTypeCount(final int opcode) {\n+      return TYPE_OF_OPERANDS[opcode].length;\n+  }\n+\n+  \/**\n+   * Names of opcodes.  Indexed by opcode.  OPCODE_NAMES[ALOAD] = \"aload\".\n+   *\/\n+  private static final String[] OPCODE_NAMES = {\n+    \"nop\", \"aconst_null\", \"iconst_m1\", \"iconst_0\", \"iconst_1\",\n+    \"iconst_2\", \"iconst_3\", \"iconst_4\", \"iconst_5\", \"lconst_0\",\n+    \"lconst_1\", \"fconst_0\", \"fconst_1\", \"fconst_2\", \"dconst_0\",\n+    \"dconst_1\", \"bipush\", \"sipush\", \"ldc\", \"ldc_w\", \"ldc2_w\", \"iload\",\n+    \"lload\", \"fload\", \"dload\", \"aload\", \"iload_0\", \"iload_1\", \"iload_2\",\n+    \"iload_3\", \"lload_0\", \"lload_1\", \"lload_2\", \"lload_3\", \"fload_0\",\n+    \"fload_1\", \"fload_2\", \"fload_3\", \"dload_0\", \"dload_1\", \"dload_2\",\n+    \"dload_3\", \"aload_0\", \"aload_1\", \"aload_2\", \"aload_3\", \"iaload\",\n+    \"laload\", \"faload\", \"daload\", \"aaload\", \"baload\", \"caload\", \"saload\",\n+    \"istore\", \"lstore\", \"fstore\", \"dstore\", \"astore\", \"istore_0\",\n+    \"istore_1\", \"istore_2\", \"istore_3\", \"lstore_0\", \"lstore_1\",\n+    \"lstore_2\", \"lstore_3\", \"fstore_0\", \"fstore_1\", \"fstore_2\",\n+    \"fstore_3\", \"dstore_0\", \"dstore_1\", \"dstore_2\", \"dstore_3\",\n+    \"astore_0\", \"astore_1\", \"astore_2\", \"astore_3\", \"iastore\", \"lastore\",\n+    \"fastore\", \"dastore\", \"aastore\", \"bastore\", \"castore\", \"sastore\",\n+    \"pop\", \"pop2\", \"dup\", \"dup_x1\", \"dup_x2\", \"dup2\", \"dup2_x1\",\n+    \"dup2_x2\", \"swap\", \"iadd\", \"ladd\", \"fadd\", \"dadd\", \"isub\", \"lsub\",\n+    \"fsub\", \"dsub\", \"imul\", \"lmul\", \"fmul\", \"dmul\", \"idiv\", \"ldiv\",\n+    \"fdiv\", \"ddiv\", \"irem\", \"lrem\", \"frem\", \"drem\", \"ineg\", \"lneg\",\n+    \"fneg\", \"dneg\", \"ishl\", \"lshl\", \"ishr\", \"lshr\", \"iushr\", \"lushr\",\n+    \"iand\", \"land\", \"ior\", \"lor\", \"ixor\", \"lxor\", \"iinc\", \"i2l\", \"i2f\",\n+    \"i2d\", \"l2i\", \"l2f\", \"l2d\", \"f2i\", \"f2l\", \"f2d\", \"d2i\", \"d2l\", \"d2f\",\n+    \"i2b\", \"i2c\", \"i2s\", \"lcmp\", \"fcmpl\", \"fcmpg\",\n+    \"dcmpl\", \"dcmpg\", \"ifeq\", \"ifne\", \"iflt\", \"ifge\", \"ifgt\", \"ifle\",\n+    \"if_icmpeq\", \"if_icmpne\", \"if_icmplt\", \"if_icmpge\", \"if_icmpgt\",\n+    \"if_icmple\", \"if_acmpeq\", \"if_acmpne\", \"goto\", \"jsr\", \"ret\",\n+    \"tableswitch\", \"lookupswitch\", \"ireturn\", \"lreturn\", \"freturn\",\n+    \"dreturn\", \"areturn\", \"return\", \"getstatic\", \"putstatic\", \"getfield\",\n+    \"putfield\", \"invokevirtual\", \"invokespecial\", \"invokestatic\",\n+    \"invokeinterface\", \"invokedynamic\", \"new\", \"newarray\", \"anewarray\",\n+    \"arraylength\", \"athrow\", \"checkcast\", \"instanceof\", \"monitorenter\",\n+    \"monitorexit\", \"wide\", \"multianewarray\", \"ifnull\", \"ifnonnull\",\n+    \"goto_w\", \"jsr_w\", \"breakpoint\", ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, \"impdep1\", \"impdep2\"\n+  };\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static final int OPCODE_NAMES_LENGTH = OPCODE_NAMES.length;\n+\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static String getOpcodeName(final int index) {\n+      return OPCODE_NAMES[index];\n+  }\n+\n+  \/**\n+   * Number of words consumed on operand stack by instructions.\n+   * Indexed by opcode.  CONSUME_STACK[FALOAD] = number of words\n+   * consumed from the stack by a faload instruction.\n+   *\/\n+  private static final int[] CONSUME_STACK = {\n+    0\/*nop*\/, 0\/*aconst_null*\/, 0\/*iconst_m1*\/, 0\/*iconst_0*\/, 0\/*iconst_1*\/,\n+    0\/*iconst_2*\/, 0\/*iconst_3*\/, 0\/*iconst_4*\/, 0\/*iconst_5*\/, 0\/*lconst_0*\/,\n+    0\/*lconst_1*\/, 0\/*fconst_0*\/, 0\/*fconst_1*\/, 0\/*fconst_2*\/, 0\/*dconst_0*\/,\n+    0\/*dconst_1*\/, 0\/*bipush*\/, 0\/*sipush*\/, 0\/*ldc*\/, 0\/*ldc_w*\/, 0\/*ldc2_w*\/, 0\/*iload*\/,\n+    0\/*lload*\/, 0\/*fload*\/, 0\/*dload*\/, 0\/*aload*\/, 0\/*iload_0*\/, 0\/*iload_1*\/, 0\/*iload_2*\/,\n+    0\/*iload_3*\/, 0\/*lload_0*\/, 0\/*lload_1*\/, 0\/*lload_2*\/, 0\/*lload_3*\/, 0\/*fload_0*\/,\n+    0\/*fload_1*\/, 0\/*fload_2*\/, 0\/*fload_3*\/, 0\/*dload_0*\/, 0\/*dload_1*\/, 0\/*dload_2*\/,\n+    0\/*dload_3*\/, 0\/*aload_0*\/, 0\/*aload_1*\/, 0\/*aload_2*\/, 0\/*aload_3*\/, 2\/*iaload*\/,\n+    2\/*laload*\/, 2\/*faload*\/, 2\/*daload*\/, 2\/*aaload*\/, 2\/*baload*\/, 2\/*caload*\/, 2\/*saload*\/,\n+    1\/*istore*\/, 2\/*lstore*\/, 1\/*fstore*\/, 2\/*dstore*\/, 1\/*astore*\/, 1\/*istore_0*\/,\n+    1\/*istore_1*\/, 1\/*istore_2*\/, 1\/*istore_3*\/, 2\/*lstore_0*\/, 2\/*lstore_1*\/,\n+    2\/*lstore_2*\/, 2\/*lstore_3*\/, 1\/*fstore_0*\/, 1\/*fstore_1*\/, 1\/*fstore_2*\/,\n+    1\/*fstore_3*\/, 2\/*dstore_0*\/, 2\/*dstore_1*\/, 2\/*dstore_2*\/, 2\/*dstore_3*\/,\n+    1\/*astore_0*\/, 1\/*astore_1*\/, 1\/*astore_2*\/, 1\/*astore_3*\/, 3\/*iastore*\/, 4\/*lastore*\/,\n+    3\/*fastore*\/, 4\/*dastore*\/, 3\/*aastore*\/, 3\/*bastore*\/, 3\/*castore*\/, 3\/*sastore*\/,\n+    1\/*pop*\/, 2\/*pop2*\/, 1\/*dup*\/, 2\/*dup_x1*\/, 3\/*dup_x2*\/, 2\/*dup2*\/, 3\/*dup2_x1*\/,\n+    4\/*dup2_x2*\/, 2\/*swap*\/, 2\/*iadd*\/, 4\/*ladd*\/, 2\/*fadd*\/, 4\/*dadd*\/, 2\/*isub*\/, 4\/*lsub*\/,\n+    2\/*fsub*\/, 4\/*dsub*\/, 2\/*imul*\/, 4\/*lmul*\/, 2\/*fmul*\/, 4\/*dmul*\/, 2\/*idiv*\/, 4\/*ldiv*\/,\n+    2\/*fdiv*\/, 4\/*ddiv*\/, 2\/*irem*\/, 4\/*lrem*\/, 2\/*frem*\/, 4\/*drem*\/, 1\/*ineg*\/, 2\/*lneg*\/,\n+    1\/*fneg*\/, 2\/*dneg*\/, 2\/*ishl*\/, 3\/*lshl*\/, 2\/*ishr*\/, 3\/*lshr*\/, 2\/*iushr*\/, 3\/*lushr*\/,\n+    2\/*iand*\/, 4\/*land*\/, 2\/*ior*\/, 4\/*lor*\/, 2\/*ixor*\/, 4\/*lxor*\/, 0\/*iinc*\/,\n+    1\/*i2l*\/, 1\/*i2f*\/, 1\/*i2d*\/, 2\/*l2i*\/, 2\/*l2f*\/, 2\/*l2d*\/, 1\/*f2i*\/, 1\/*f2l*\/,\n+    1\/*f2d*\/, 2\/*d2i*\/, 2\/*d2l*\/, 2\/*d2f*\/, 1\/*i2b*\/, 1\/*i2c*\/, 1\/*i2s*\/,\n+    4\/*lcmp*\/, 2\/*fcmpl*\/, 2\/*fcmpg*\/, 4\/*dcmpl*\/, 4\/*dcmpg*\/, 1\/*ifeq*\/, 1\/*ifne*\/,\n+    1\/*iflt*\/, 1\/*ifge*\/, 1\/*ifgt*\/, 1\/*ifle*\/, 2\/*if_icmpeq*\/, 2\/*if_icmpne*\/, 2\/*if_icmplt*\/,\n+    2 \/*if_icmpge*\/, 2\/*if_icmpgt*\/, 2\/*if_icmple*\/, 2\/*if_acmpeq*\/, 2\/*if_acmpne*\/,\n+    0\/*goto*\/, 0\/*jsr*\/, 0\/*ret*\/, 1\/*tableswitch*\/, 1\/*lookupswitch*\/, 1\/*ireturn*\/,\n+    2\/*lreturn*\/, 1\/*freturn*\/, 2\/*dreturn*\/, 1\/*areturn*\/, 0\/*return*\/, 0\/*getstatic*\/,\n+    UNPREDICTABLE\/*putstatic*\/, 1\/*getfield*\/, UNPREDICTABLE\/*putfield*\/,\n+    UNPREDICTABLE\/*invokevirtual*\/, UNPREDICTABLE\/*invokespecial*\/,\n+    UNPREDICTABLE\/*invokestatic*\/,\n+    UNPREDICTABLE\/*invokeinterface*\/, UNPREDICTABLE\/*invokedynamic*\/, 0\/*new*\/, 1\/*newarray*\/, 1\/*anewarray*\/,\n+    1\/*arraylength*\/, 1\/*athrow*\/, 1\/*checkcast*\/, 1\/*instanceof*\/, 1\/*monitorenter*\/,\n+    1\/*monitorexit*\/, 0\/*wide*\/, UNPREDICTABLE\/*multianewarray*\/, 1\/*ifnull*\/, 1\/*ifnonnull*\/,\n+    0\/*goto_w*\/, 0\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNPREDICTABLE\/*impdep1*\/, UNPREDICTABLE\/*impdep2*\/\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return Number of words consumed on operand stack\n+   * @since 6.0\n+   *\/\n+  public static int getConsumeStack(final int index) {\n+      return CONSUME_STACK[index];\n+  }\n+\n+\n+  \/**\n+   * Number of words produced onto operand stack by instructions.\n+   * Indexed by opcode.  CONSUME_STACK[DALOAD] = number of words\n+   * consumed from the stack by a daload instruction.\n+   *\/\n+  private static final int[] PRODUCE_STACK = {\n+    0\/*nop*\/, 1\/*aconst_null*\/, 1\/*iconst_m1*\/, 1\/*iconst_0*\/, 1\/*iconst_1*\/,\n+    1\/*iconst_2*\/, 1\/*iconst_3*\/, 1\/*iconst_4*\/, 1\/*iconst_5*\/, 2\/*lconst_0*\/,\n+    2\/*lconst_1*\/, 1\/*fconst_0*\/, 1\/*fconst_1*\/, 1\/*fconst_2*\/, 2\/*dconst_0*\/,\n+    2\/*dconst_1*\/, 1\/*bipush*\/, 1\/*sipush*\/, 1\/*ldc*\/, 1\/*ldc_w*\/, 2\/*ldc2_w*\/, 1\/*iload*\/,\n+    2\/*lload*\/, 1\/*fload*\/, 2\/*dload*\/, 1\/*aload*\/, 1\/*iload_0*\/, 1\/*iload_1*\/, 1\/*iload_2*\/,\n+    1\/*iload_3*\/, 2\/*lload_0*\/, 2\/*lload_1*\/, 2\/*lload_2*\/, 2\/*lload_3*\/, 1\/*fload_0*\/,\n+    1\/*fload_1*\/, 1\/*fload_2*\/, 1\/*fload_3*\/, 2\/*dload_0*\/, 2\/*dload_1*\/, 2\/*dload_2*\/,\n+    2\/*dload_3*\/, 1\/*aload_0*\/, 1\/*aload_1*\/, 1\/*aload_2*\/, 1\/*aload_3*\/, 1\/*iaload*\/,\n+    2\/*laload*\/, 1\/*faload*\/, 2\/*daload*\/, 1\/*aaload*\/, 1\/*baload*\/, 1\/*caload*\/, 1\/*saload*\/,\n+    0\/*istore*\/, 0\/*lstore*\/, 0\/*fstore*\/, 0\/*dstore*\/, 0\/*astore*\/, 0\/*istore_0*\/,\n+    0\/*istore_1*\/, 0\/*istore_2*\/, 0\/*istore_3*\/, 0\/*lstore_0*\/, 0\/*lstore_1*\/,\n+    0\/*lstore_2*\/, 0\/*lstore_3*\/, 0\/*fstore_0*\/, 0\/*fstore_1*\/, 0\/*fstore_2*\/,\n+    0\/*fstore_3*\/, 0\/*dstore_0*\/, 0\/*dstore_1*\/, 0\/*dstore_2*\/, 0\/*dstore_3*\/,\n+    0\/*astore_0*\/, 0\/*astore_1*\/, 0\/*astore_2*\/, 0\/*astore_3*\/, 0\/*iastore*\/, 0\/*lastore*\/,\n+    0\/*fastore*\/, 0\/*dastore*\/, 0\/*aastore*\/, 0\/*bastore*\/, 0\/*castore*\/, 0\/*sastore*\/,\n+    0\/*pop*\/, 0\/*pop2*\/, 2\/*dup*\/, 3\/*dup_x1*\/, 4\/*dup_x2*\/, 4\/*dup2*\/, 5\/*dup2_x1*\/,\n+    6\/*dup2_x2*\/, 2\/*swap*\/, 1\/*iadd*\/, 2\/*ladd*\/, 1\/*fadd*\/, 2\/*dadd*\/, 1\/*isub*\/, 2\/*lsub*\/,\n+    1\/*fsub*\/, 2\/*dsub*\/, 1\/*imul*\/, 2\/*lmul*\/, 1\/*fmul*\/, 2\/*dmul*\/, 1\/*idiv*\/, 2\/*ldiv*\/,\n+    1\/*fdiv*\/, 2\/*ddiv*\/, 1\/*irem*\/, 2\/*lrem*\/, 1\/*frem*\/, 2\/*drem*\/, 1\/*ineg*\/, 2\/*lneg*\/,\n+    1\/*fneg*\/, 2\/*dneg*\/, 1\/*ishl*\/, 2\/*lshl*\/, 1\/*ishr*\/, 2\/*lshr*\/, 1\/*iushr*\/, 2\/*lushr*\/,\n+    1\/*iand*\/, 2\/*land*\/, 1\/*ior*\/, 2\/*lor*\/, 1\/*ixor*\/, 2\/*lxor*\/,\n+    0\/*iinc*\/, 2\/*i2l*\/, 1\/*i2f*\/, 2\/*i2d*\/, 1\/*l2i*\/, 1\/*l2f*\/, 2\/*l2d*\/, 1\/*f2i*\/,\n+    2\/*f2l*\/, 2\/*f2d*\/, 1\/*d2i*\/, 2\/*d2l*\/, 1\/*d2f*\/,\n+    1\/*i2b*\/, 1\/*i2c*\/, 1\/*i2s*\/, 1\/*lcmp*\/, 1\/*fcmpl*\/, 1\/*fcmpg*\/,\n+    1\/*dcmpl*\/, 1\/*dcmpg*\/, 0\/*ifeq*\/, 0\/*ifne*\/, 0\/*iflt*\/, 0\/*ifge*\/, 0\/*ifgt*\/, 0\/*ifle*\/,\n+    0\/*if_icmpeq*\/, 0\/*if_icmpne*\/, 0\/*if_icmplt*\/, 0\/*if_icmpge*\/, 0\/*if_icmpgt*\/,\n+    0\/*if_icmple*\/, 0\/*if_acmpeq*\/, 0\/*if_acmpne*\/, 0\/*goto*\/, 1\/*jsr*\/, 0\/*ret*\/,\n+    0\/*tableswitch*\/, 0\/*lookupswitch*\/, 0\/*ireturn*\/, 0\/*lreturn*\/, 0\/*freturn*\/,\n+    0\/*dreturn*\/, 0\/*areturn*\/, 0\/*return*\/, UNPREDICTABLE\/*getstatic*\/, 0\/*putstatic*\/,\n+    UNPREDICTABLE\/*getfield*\/, 0\/*putfield*\/, UNPREDICTABLE\/*invokevirtual*\/,\n+    UNPREDICTABLE\/*invokespecial*\/, UNPREDICTABLE\/*invokestatic*\/,\n+    UNPREDICTABLE\/*invokeinterface*\/, UNPREDICTABLE\/*invokedynamic*\/, 1\/*new*\/, 1\/*newarray*\/, 1\/*anewarray*\/,\n+    1\/*arraylength*\/, 1\/*athrow*\/, 1\/*checkcast*\/, 1\/*instanceof*\/, 0\/*monitorenter*\/,\n+    0\/*monitorexit*\/, 0\/*wide*\/, 1\/*multianewarray*\/, 0\/*ifnull*\/, 0\/*ifnonnull*\/,\n+    0\/*goto_w*\/, 1\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNPREDICTABLE\/*impdep1*\/, UNPREDICTABLE\/*impdep2*\/\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return Number of words produced onto operand stack\n+   * @since 6.0\n+   *\/\n+  public static int getProduceStack(final int index) {\n+      return PRODUCE_STACK[index];\n+  }\n+\n+  \/** Attributes and their corresponding names.\n+   *\/\n+  public static final byte ATTR_UNKNOWN                                 = -1;\n+  public static final byte ATTR_SOURCE_FILE                             = 0;\n+  public static final byte ATTR_CONSTANT_VALUE                          = 1;\n+  public static final byte ATTR_CODE                                    = 2;\n+  public static final byte ATTR_EXCEPTIONS                              = 3;\n+  public static final byte ATTR_LINE_NUMBER_TABLE                       = 4;\n+  public static final byte ATTR_LOCAL_VARIABLE_TABLE                    = 5;\n+  public static final byte ATTR_INNER_CLASSES                           = 6;\n+  public static final byte ATTR_SYNTHETIC                               = 7;\n+  public static final byte ATTR_DEPRECATED                              = 8;\n+  public static final byte ATTR_PMG                                     = 9;\n+  public static final byte ATTR_SIGNATURE                               = 10;\n+  public static final byte ATTR_STACK_MAP                               = 11;\n+  public static final byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS             = 12;\n+  public static final byte ATTR_RUNTIME_INVISIBLE_ANNOTATIONS           = 13;\n+  public static final byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS   = 14;\n+  public static final byte ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = 15;\n+  public static final byte ATTR_ANNOTATION_DEFAULT                      = 16;\n+  public static final byte ATTR_LOCAL_VARIABLE_TYPE_TABLE               = 17;\n+  public static final byte ATTR_ENCLOSING_METHOD                        = 18;\n+  public static final byte ATTR_STACK_MAP_TABLE                         = 19;\n+  public static final byte ATTR_BOOTSTRAP_METHODS                       = 20;\n+  public static final byte ATTR_METHOD_PARAMETERS                       = 21;\n+  public static final byte ATTR_MODULE                                  = 22;\n+  public static final byte ATTR_MODULE_PACKAGES                         = 23;\n+  public static final byte ATTR_MODULE_MAIN_CLASS                       = 24;\n+  public static final byte ATTR_NEST_HOST                               = 25;\n+  public static final byte ATTR_NEST_MEMBERS                            = 26;\n+\n+  public static final short KNOWN_ATTRIBUTES = 27; \/\/ count of attributes\n+\n+  private static final String[] ATTRIBUTE_NAMES = {\n+    \"SourceFile\", \"ConstantValue\", \"Code\", \"Exceptions\",\n+    \"LineNumberTable\", \"LocalVariableTable\",\n+    \"InnerClasses\", \"Synthetic\", \"Deprecated\",\n+    \"PMGClass\", \"Signature\", \"StackMap\",\n+    \"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\",\n+    \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\",\n+    \"AnnotationDefault\", \"LocalVariableTypeTable\", \"EnclosingMethod\", \"StackMapTable\",\n+    \"BootstrapMethods\", \"MethodParameters\", \"Module\", \"ModulePackages\",\n+    \"ModuleMainClass\", \"NestHost\", \"NestMembers\"\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the attribute name\n+   * @since 6.0\n+   *\/\n+  public static String getAttributeName(final int index) {\n+      return ATTRIBUTE_NAMES[index];\n+  }\n+\n+  \/** Constants used in the StackMap attribute.\n+   *\/\n+  public static final byte ITEM_Bogus      = 0;\n+  public static final byte ITEM_Integer    = 1;\n+  public static final byte ITEM_Float      = 2;\n+  public static final byte ITEM_Double     = 3;\n+  public static final byte ITEM_Long       = 4;\n+  public static final byte ITEM_Null       = 5;\n+  public static final byte ITEM_InitObject = 6;\n+  public static final byte ITEM_Object     = 7;\n+  public static final byte ITEM_NewObject  = 8;\n+\n+  private static final String[] ITEM_NAMES = {\n+    \"Bogus\", \"Integer\", \"Float\", \"Double\", \"Long\",\n+    \"Null\", \"InitObject\", \"Object\", \"NewObject\"\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the item name\n+   * @since 6.0\n+   *\/\n+  public static String getItemName(final int index) {\n+      return ITEM_NAMES[index];\n+  }\n+\n+  \/** Constants used to identify StackMapEntry types.\n+   *\n+   * For those types which can specify a range, the\n+   * constant names the lowest value.\n+   *\/\n+  public static final int SAME_FRAME = 0;\n+  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n+  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n+  public static final int CHOP_FRAME = 248;\n+  public static final int SAME_FRAME_EXTENDED = 251;\n+  public static final int APPEND_FRAME = 252;\n+  public static final int FULL_FRAME = 255;\n+\n+  \/** Constants that define the maximum value of\n+   * those constants which store ranges. *\/\n+\n+  public static final int SAME_FRAME_MAX = 63;\n+  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_MAX = 127;\n+  public static final int CHOP_FRAME_MAX = 250;\n+  public static final int APPEND_FRAME_MAX = 254;\n+\n+\n+  \/\/ Constants defining the behavior of the Method Handles (JVMS 5.4.3.5)\n+\n+  public static final byte REF_getField         = 1;\n+  public static final byte REF_getStatic        = 2;\n+  public static final byte REF_putField         = 3;\n+  public static final byte REF_putStatic        = 4;\n+  public static final byte REF_invokeVirtual    = 5;\n+  public static final byte REF_invokeStatic     = 6;\n+  public static final byte REF_invokeSpecial    = 7;\n+  public static final byte REF_newInvokeSpecial = 8;\n+  public static final byte REF_invokeInterface  = 9;\n+\n+  \/**\n+   * The names of the reference_kinds of a CONSTANT_MethodHandle_info.\n+   *\/\n+  private static final String[] METHODHANDLE_NAMES = {\n+      \"\", \"getField\", \"getStatic\", \"putField\", \"putStatic\", \"invokeVirtual\",\n+      \"invokeStatic\", \"invokeSpecial\", \"newInvokeSpecial\", \"invokeInterface\" };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the method handle name\n+   * @since 6.0\n+   *\/\n+  public static String getMethodHandleName(final int index) {\n+      return METHODHANDLE_NAMES[index];\n+  }\n+\n+  private Const() { } \/\/ not instantiable\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/Const.java","additions":2409,"deletions":3211,"binary":false,"changes":5620,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import jdk.xml.internal.Utils;\n-\n@@ -27,1 +25,0 @@\n- *\n@@ -29,1 +26,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -33,8 +30,0 @@\n-    \/**\n-     * Enum corresponding to the various Exception Class arrays, used by\n-     * {@link ExceptionConst#createExceptions(EXCS, Class...)}\n-     *\/\n-    public enum EXCS {\n-        EXCS_CLASS_AND_INTERFACE_RESOLUTION, EXCS_FIELD_AND_METHOD_RESOLUTION, EXCS_INTERFACE_METHOD_RESOLUTION, EXCS_STRING_RESOLUTION, EXCS_ARRAY_EXCEPTION,\n-    }\n-\n@@ -78,1 +67,2 @@\n-    public static final Class<ArrayIndexOutOfBoundsException> ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION = ArrayIndexOutOfBoundsException.class;\n+    public static final Class<ArrayIndexOutOfBoundsException> ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION\n+                                                            = ArrayIndexOutOfBoundsException.class;\n@@ -82,1 +72,0 @@\n-\n@@ -84,7 +73,0 @@\n-    \/**\n-     * Pre-defined exception arrays according to chapters 5.1-5.4 of the Java Virtual Machine Specification\n-     *\/\n-    private static final Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = {NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR,\n-        EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR}; \/\/ Chapter 5.1\n-\n-    private static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = {NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR}; \/\/ Chapter 5.2\n@@ -93,1 +75,2 @@\n-     * Empty array.\n+     * Pre-defined exception arrays according to chapters 5.1-5.4 of the Java Virtual\n+     * Machine Specification\n@@ -95,0 +78,7 @@\n+    private static final Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = {\n+            NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR,\n+            EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR\n+    }; \/\/ Chapter 5.1\n+    private static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = {\n+            NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR\n+    }; \/\/ Chapter 5.2\n@@ -96,0 +86,5 @@\n+    private static final Class<?>[] EXCS_STRING_RESOLUTION = new Class<?>[0];\n+    \/\/ Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)\n+    private static final Class<?>[] EXCS_ARRAY_EXCEPTION = {\n+            NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION\n+    };\n@@ -98,1 +93,2 @@\n-     * Empty array.\n+     * Enum corresponding to the various Exception Class arrays,\n+     * used by {@link ExceptionConst#createExceptions(EXCS, Class...)}\n@@ -100,1 +96,7 @@\n-    private static final Class<?>[] EXCS_STRING_RESOLUTION = new Class<?>[0];\n+    public enum EXCS {\n+        EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+        EXCS_FIELD_AND_METHOD_RESOLUTION,\n+        EXCS_INTERFACE_METHOD_RESOLUTION,\n+        EXCS_STRING_RESOLUTION,\n+        EXCS_ARRAY_EXCEPTION,\n+    }\n@@ -102,2 +104,10 @@\n-    \/\/ Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)\n-    private static final Class<?>[] EXCS_ARRAY_EXCEPTION = {NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION};\n+    \/\/ helper method to merge exception class arrays\n+    private static Class<?>[] mergeExceptions(final Class<?>[] input, final Class<?> ... extraClasses) {\n+        final int extraLen = extraClasses == null ? 0 : extraClasses.length;\n+        final Class<?>[] excs = new Class<?>[input.length + extraLen];\n+        System.arraycopy(input, 0, excs, 0, input.length);\n+        if (extraLen > 0) {\n+            System.arraycopy(extraClasses, 0, excs, input.length, extraLen);\n+        }\n+        return excs;\n+    }\n@@ -107,1 +117,0 @@\n-     *\n@@ -112,1 +121,1 @@\n-    public static Class<?>[] createExceptions(final EXCS type, final Class<?>... extraClasses) {\n+    public static Class<?>[] createExceptions(final EXCS type, final Class<?> ... extraClasses) {\n@@ -129,4 +138,1 @@\n-    \/\/ helper method to merge exception class arrays\n-    private static Class<?>[] mergeExceptions(final Class<?>[] input, final Class<?>... extraClasses) {\n-        return Utils.arraysAppend(input, extraClasses);\n-    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/ExceptionConst.java","additions":39,"deletions":33,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,3 @@\n- * The repository maintains informations about class interdependencies, e.g., whether a class is a sub-class of another.\n- * Delegates actual class loading to SyntheticRepository with current class path by default.\n+ * The repository maintains informations about class interdependencies, e.g.,\n+ * whether a class is a sub-class of another. Delegates actual class loading\n+ * to SyntheticRepository with current class path by default.\n@@ -33,1 +34,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -37,1 +38,3 @@\n-    private static com.sun.org.apache.bcel.internal.util.Repository repository = SyntheticRepository.getInstance();\n+    private static com.sun.org.apache.bcel.internal.util.Repository repository\n+            = SyntheticRepository.getInstance();\n+\n@@ -40,3 +43,1 @@\n-     * Adds clazz to repository if there isn't an equally named class already in there.\n-     *\n-     * @return old entry in repository\n+     * @return currently used repository instance\n@@ -44,4 +45,2 @@\n-    public static JavaClass addClass(final JavaClass clazz) {\n-        final JavaClass old = repository.findClass(clazz.getClassName());\n-        repository.storeClass(clazz);\n-        return old;\n+    public static com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n+        return repository;\n@@ -50,0 +49,1 @@\n+\n@@ -51,1 +51,1 @@\n-     * Clears the repository.\n+     * Sets repository instance to be used for class loading\n@@ -53,2 +53,2 @@\n-    public static void clearCache() {\n-        repository.clear();\n+    public static void setRepository( final com.sun.org.apache.bcel.internal.util.Repository rep ) {\n+        repository = rep;\n@@ -57,0 +57,1 @@\n+\n@@ -58,3 +59,6 @@\n-     * @return all interfaces implemented by class and its super classes and the interfaces that those interfaces extend,\n-     *         and so on. (Some people call this a transitive hull).\n-     * @throws ClassNotFoundException if any of the class's superclasses or superinterfaces can't be found\n+     * Lookups class somewhere found on your CLASSPATH, or whereever the\n+     * repository instance looks for it.\n+     *\n+     * @return class object for given fully qualified class name\n+     * @throws ClassNotFoundException if the class could not be found or\n+     * parsed correctly\n@@ -62,2 +66,2 @@\n-    public static JavaClass[] getInterfaces(final JavaClass clazz) throws ClassNotFoundException {\n-        return clazz.getAllInterfaces();\n+    public static JavaClass lookupClass( final String class_name ) throws ClassNotFoundException {\n+        return repository.loadClass(class_name);\n@@ -66,0 +70,1 @@\n+\n@@ -67,4 +72,6 @@\n-     * @return all interfaces implemented by class and its super classes and the interfaces that extend those interfaces,\n-     *         and so on\n-     * @throws ClassNotFoundException if the named class can't be found, or if any of its superclasses or superinterfaces\n-     *         can't be found\n+     * Tries to find class source using the internal repository instance.\n+     *\n+     * @see Class\n+     * @return JavaClass object for given runtime class\n+     * @throws ClassNotFoundException if the class could not be found or\n+     * parsed correctly\n@@ -72,2 +79,2 @@\n-    public static JavaClass[] getInterfaces(final String className) throws ClassNotFoundException {\n-        return getInterfaces(lookupClass(className));\n+    public static JavaClass lookupClass( final Class<?> clazz ) throws ClassNotFoundException {\n+        return repository.loadClass(clazz);\n@@ -76,0 +83,1 @@\n+\n@@ -77,1 +85,1 @@\n-     * @return currently used repository instance\n+     * Clear the repository.\n@@ -79,2 +87,2 @@\n-    public static com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n-        return repository;\n+    public static void clearCache() {\n+        repository.clear();\n@@ -83,0 +91,1 @@\n+\n@@ -84,2 +93,3 @@\n-     * @return list of super classes of clazz in ascending order, i.e., Object is always the last element\n-     * @throws ClassNotFoundException if any of the superclasses can't be found\n+     * Adds clazz to repository if there isn't an equally named class already in there.\n+     *\n+     * @return old entry in repository\n@@ -87,2 +97,4 @@\n-    public static JavaClass[] getSuperClasses(final JavaClass clazz) throws ClassNotFoundException {\n-        return clazz.getSuperClasses();\n+    public static JavaClass addClass( final JavaClass clazz ) {\n+        final JavaClass old = repository.findClass(clazz.getClassName());\n+        repository.storeClass(clazz);\n+        return old;\n@@ -91,0 +103,1 @@\n+\n@@ -92,2 +105,1 @@\n-     * @return list of super classes of clazz in ascending order, i.e., Object is always the last element.\n-     * @throws ClassNotFoundException if the named class or any of its superclasses can't be found\n+     * Removes class with given (fully qualified) name from repository.\n@@ -95,2 +107,2 @@\n-    public static JavaClass[] getSuperClasses(final String className) throws ClassNotFoundException {\n-        return getSuperClasses(lookupClass(className));\n+    public static void removeClass( final String clazz ) {\n+        repository.removeClass(repository.findClass(clazz));\n@@ -99,0 +111,1 @@\n+\n@@ -100,2 +113,1 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if any superclasses or superinterfaces of clazz can't be found\n+     * Removes given class from repository.\n@@ -103,2 +115,2 @@\n-    public static boolean implementationOf(final JavaClass clazz, final JavaClass inter) throws ClassNotFoundException {\n-        return clazz.implementationOf(inter);\n+    public static void removeClass( final JavaClass clazz ) {\n+        repository.removeClass(clazz);\n@@ -107,0 +119,1 @@\n+\n@@ -108,2 +121,3 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if inter or any superclasses or superinterfaces of clazz can't be found\n+     * @return list of super classes of clazz in ascending order, i.e.,\n+     * Object is always the last element\n+     * @throws ClassNotFoundException if any of the superclasses can't be found\n@@ -111,2 +125,2 @@\n-    public static boolean implementationOf(final JavaClass clazz, final String inter) throws ClassNotFoundException {\n-        return implementationOf(clazz, lookupClass(inter));\n+    public static JavaClass[] getSuperClasses( final JavaClass clazz ) throws ClassNotFoundException {\n+        return clazz.getSuperClasses();\n@@ -115,0 +129,1 @@\n+\n@@ -116,2 +131,4 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if clazz or any superclasses or superinterfaces of clazz can't be found\n+     * @return list of super classes of clazz in ascending order, i.e.,\n+     * Object is always the last element.\n+     * @throws ClassNotFoundException if the named class or any of its\n+     *  superclasses can't be found\n@@ -119,2 +136,3 @@\n-    public static boolean implementationOf(final String clazz, final JavaClass inter) throws ClassNotFoundException {\n-        return implementationOf(lookupClass(clazz), inter);\n+    public static JavaClass[] getSuperClasses( final String class_name ) throws ClassNotFoundException {\n+        final JavaClass jc = lookupClass(class_name);\n+        return getSuperClasses(jc);\n@@ -123,0 +141,1 @@\n+\n@@ -124,2 +143,5 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if clazz, inter, or any superclasses or superinterfaces of clazz can't be found\n+     * @return all interfaces implemented by class and its super\n+     * classes and the interfaces that those interfaces extend, and so on.\n+     * (Some people call this a transitive hull).\n+     * @throws ClassNotFoundException if any of the class's\n+     *  superclasses or superinterfaces can't be found\n@@ -127,2 +149,2 @@\n-    public static boolean implementationOf(final String clazz, final String inter) throws ClassNotFoundException {\n-        return implementationOf(lookupClass(clazz), lookupClass(inter));\n+    public static JavaClass[] getInterfaces( final JavaClass clazz ) throws ClassNotFoundException {\n+        return clazz.getAllInterfaces();\n@@ -131,0 +153,1 @@\n+\n@@ -132,4 +155,4 @@\n-     * Equivalent to runtime \"instanceof\" operator.\n-     *\n-     * @return true, if clazz is an instance of superclass\n-     * @throws ClassNotFoundException if any superclasses or superinterfaces of clazz can't be found\n+     * @return all interfaces implemented by class and its super\n+     * classes and the interfaces that extend those interfaces, and so on\n+     * @throws ClassNotFoundException if the named class can't be found,\n+     *   or if any of its superclasses or superinterfaces can't be found\n@@ -137,2 +160,2 @@\n-    public static boolean instanceOf(final JavaClass clazz, final JavaClass superclass) throws ClassNotFoundException {\n-        return clazz.instanceOf(superclass);\n+    public static JavaClass[] getInterfaces( final String class_name ) throws ClassNotFoundException {\n+        return getInterfaces(lookupClass(class_name));\n@@ -141,0 +164,1 @@\n+\n@@ -142,2 +166,4 @@\n-     * @return true, if clazz is an instance of superclass\n-     * @throws ClassNotFoundException if superclass can't be found\n+     * Equivalent to runtime \"instanceof\" operator.\n+     * @return true, if clazz is an instance of super_class\n+     * @throws ClassNotFoundException if any superclasses or superinterfaces\n+     *   of clazz can't be found\n@@ -145,2 +171,3 @@\n-    public static boolean instanceOf(final JavaClass clazz, final String superclass) throws ClassNotFoundException {\n-        return instanceOf(clazz, lookupClass(superclass));\n+    public static boolean instanceOf( final JavaClass clazz, final JavaClass super_class )\n+            throws ClassNotFoundException {\n+        return clazz.instanceOf(super_class);\n@@ -149,0 +176,1 @@\n+\n@@ -150,2 +178,3 @@\n-     * @return true, if clazz is an instance of superclass\n-     * @throws ClassNotFoundException if clazz can't be found\n+     * @return true, if clazz is an instance of super_class\n+     * @throws ClassNotFoundException if either clazz or super_class\n+     *   can't be found\n@@ -153,2 +182,3 @@\n-    public static boolean instanceOf(final String clazz, final JavaClass superclass) throws ClassNotFoundException {\n-        return instanceOf(lookupClass(clazz), superclass);\n+    public static boolean instanceOf( final String clazz, final String super_class )\n+            throws ClassNotFoundException {\n+        return instanceOf(lookupClass(clazz), lookupClass(super_class));\n@@ -157,0 +187,1 @@\n+\n@@ -158,2 +189,2 @@\n-     * @return true, if clazz is an instance of superclass\n-     * @throws ClassNotFoundException if either clazz or superclass can't be found\n+     * @return true, if clazz is an instance of super_class\n+     * @throws ClassNotFoundException if super_class can't be found\n@@ -161,2 +192,3 @@\n-    public static boolean instanceOf(final String clazz, final String superclass) throws ClassNotFoundException {\n-        return instanceOf(lookupClass(clazz), lookupClass(superclass));\n+    public static boolean instanceOf( final JavaClass clazz, final String super_class )\n+            throws ClassNotFoundException {\n+        return instanceOf(clazz, lookupClass(super_class));\n@@ -165,0 +197,1 @@\n+\n@@ -166,5 +199,2 @@\n-     * Tries to find class source using the internal repository instance.\n-     *\n-     * @see Class\n-     * @return JavaClass object for given runtime class\n-     * @throws ClassNotFoundException if the class could not be found or parsed correctly\n+     * @return true, if clazz is an instance of super_class\n+     * @throws ClassNotFoundException if clazz can't be found\n@@ -172,2 +202,3 @@\n-    public static JavaClass lookupClass(final Class<?> clazz) throws ClassNotFoundException {\n-        return repository.loadClass(clazz);\n+    public static boolean instanceOf( final String clazz, final JavaClass super_class )\n+            throws ClassNotFoundException {\n+        return instanceOf(lookupClass(clazz), super_class);\n@@ -176,0 +207,1 @@\n+\n@@ -177,4 +209,3 @@\n-     * Lookups class somewhere found on your CLASSPATH, or wherever the repository instance looks for it.\n-     *\n-     * @return class object for given fully qualified class name\n-     * @throws ClassNotFoundException if the class could not be found or parsed correctly\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if any superclasses or superinterfaces\n+     *   of clazz can't be found\n@@ -182,2 +213,3 @@\n-    public static JavaClass lookupClass(final String className) throws ClassNotFoundException {\n-        return repository.loadClass(className);\n+    public static boolean implementationOf( final JavaClass clazz, final JavaClass inter )\n+            throws ClassNotFoundException {\n+        return clazz.implementationOf(inter);\n@@ -186,0 +218,1 @@\n+\n@@ -187,1 +220,3 @@\n-     * Removes given class from repository.\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if clazz, inter, or any superclasses\n+     *   or superinterfaces of clazz can't be found\n@@ -189,2 +224,3 @@\n-    public static void removeClass(final JavaClass clazz) {\n-        repository.removeClass(clazz);\n+    public static boolean implementationOf( final String clazz, final String inter )\n+            throws ClassNotFoundException {\n+        return implementationOf(lookupClass(clazz), lookupClass(inter));\n@@ -193,0 +229,1 @@\n+\n@@ -194,1 +231,3 @@\n-     * Removes class with given (fully qualified) name from repository.\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if inter or any superclasses\n+     *   or superinterfaces of clazz can't be found\n@@ -196,2 +235,3 @@\n-    public static void removeClass(final String clazz) {\n-        repository.removeClass(repository.findClass(clazz));\n+    public static boolean implementationOf( final JavaClass clazz, final String inter )\n+            throws ClassNotFoundException {\n+        return implementationOf(clazz, lookupClass(inter));\n@@ -200,0 +240,1 @@\n+\n@@ -201,1 +242,3 @@\n-     * Sets repository instance to be used for class loading\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if clazz or any superclasses or\n+     *   superinterfaces of clazz can't be found\n@@ -203,2 +246,3 @@\n-    public static void setRepository(final com.sun.org.apache.bcel.internal.util.Repository rep) {\n-        repository = rep;\n+    public static boolean implementationOf( final String clazz, final JavaClass inter )\n+            throws ClassNotFoundException {\n+        return implementationOf(lookupClass(clazz), inter);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/Repository.java","additions":137,"deletions":93,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -32,5 +32,1 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int access_flags; \/\/ TODO not used externally at present\n+    private int access_flags;\n@@ -42,1 +38,2 @@\n-     * @param a initial access flags\n+     * @param a\n+     *            inital access flags\n@@ -62,2 +59,8 @@\n-    public final boolean isAbstract() {\n-        return (access_flags & Const.ACC_ABSTRACT) != 0;\n+    \/**\n+     * Set access flags aka \"modifiers\".\n+     *\n+     * @param access_flags\n+     *            Access flags of the object.\n+     *\/\n+    public final void setAccessFlags(final int access_flags) {\n+        this.access_flags = access_flags;\n@@ -66,2 +69,8 @@\n-    public final void isAbstract(final boolean flag) {\n-        setFlag(Const.ACC_ABSTRACT, flag);\n+    \/**\n+     * Set access flags aka \"modifiers\".\n+     *\n+     * @param access_flags\n+     *            Access flags of the object.\n+     *\/\n+    public final void setModifiers(final int access_flags) {\n+        setAccessFlags(access_flags);\n@@ -70,2 +79,10 @@\n-    public final boolean isAnnotation() {\n-        return (access_flags & Const.ACC_ANNOTATION) != 0;\n+    private void setFlag(final int flag, final boolean set) {\n+        if ((access_flags & flag) != 0) { \/\/ Flag is set already\n+            if (!set) {\n+                access_flags ^= flag;\n+            }\n+        } else { \/\/ Flag not set\n+            if (set) {\n+                access_flags |= flag;\n+            }\n+        }\n@@ -74,2 +91,2 @@\n-    public final void isAnnotation(final boolean flag) {\n-        setFlag(Const.ACC_ANNOTATION, flag);\n+    public final void isPublic(final boolean flag) {\n+        setFlag(Const.ACC_PUBLIC, flag);\n@@ -78,2 +95,2 @@\n-    public final boolean isEnum() {\n-        return (access_flags & Const.ACC_ENUM) != 0;\n+    public final boolean isPublic() {\n+        return (access_flags & Const.ACC_PUBLIC) != 0;\n@@ -82,2 +99,2 @@\n-    public final void isEnum(final boolean flag) {\n-        setFlag(Const.ACC_ENUM, flag);\n+    public final void isPrivate(final boolean flag) {\n+        setFlag(Const.ACC_PRIVATE, flag);\n@@ -86,2 +103,2 @@\n-    public final boolean isFinal() {\n-        return (access_flags & Const.ACC_FINAL) != 0;\n+    public final boolean isPrivate() {\n+        return (access_flags & Const.ACC_PRIVATE) != 0;\n@@ -90,2 +107,2 @@\n-    public final void isFinal(final boolean flag) {\n-        setFlag(Const.ACC_FINAL, flag);\n+    public final void isProtected(final boolean flag) {\n+        setFlag(Const.ACC_PROTECTED, flag);\n@@ -94,2 +111,2 @@\n-    public final boolean isInterface() {\n-        return (access_flags & Const.ACC_INTERFACE) != 0;\n+    public final boolean isProtected() {\n+        return (access_flags & Const.ACC_PROTECTED) != 0;\n@@ -98,2 +115,2 @@\n-    public final void isInterface(final boolean flag) {\n-        setFlag(Const.ACC_INTERFACE, flag);\n+    public final void isStatic(final boolean flag) {\n+        setFlag(Const.ACC_STATIC, flag);\n@@ -102,2 +119,2 @@\n-    public final boolean isNative() {\n-        return (access_flags & Const.ACC_NATIVE) != 0;\n+    public final boolean isStatic() {\n+        return (access_flags & Const.ACC_STATIC) != 0;\n@@ -106,2 +123,2 @@\n-    public final void isNative(final boolean flag) {\n-        setFlag(Const.ACC_NATIVE, flag);\n+    public final void isFinal(final boolean flag) {\n+        setFlag(Const.ACC_FINAL, flag);\n@@ -110,2 +127,2 @@\n-    public final boolean isPrivate() {\n-        return (access_flags & Const.ACC_PRIVATE) != 0;\n+    public final boolean isFinal() {\n+        return (access_flags & Const.ACC_FINAL) != 0;\n@@ -114,2 +131,2 @@\n-    public final void isPrivate(final boolean flag) {\n-        setFlag(Const.ACC_PRIVATE, flag);\n+    public final void isSynchronized(final boolean flag) {\n+        setFlag(Const.ACC_SYNCHRONIZED, flag);\n@@ -118,2 +135,2 @@\n-    public final boolean isProtected() {\n-        return (access_flags & Const.ACC_PROTECTED) != 0;\n+    public final boolean isSynchronized() {\n+        return (access_flags & Const.ACC_SYNCHRONIZED) != 0;\n@@ -122,2 +139,2 @@\n-    public final void isProtected(final boolean flag) {\n-        setFlag(Const.ACC_PROTECTED, flag);\n+    public final void isVolatile(final boolean flag) {\n+        setFlag(Const.ACC_VOLATILE, flag);\n@@ -126,2 +143,2 @@\n-    public final boolean isPublic() {\n-        return (access_flags & Const.ACC_PUBLIC) != 0;\n+    public final boolean isVolatile() {\n+        return (access_flags & Const.ACC_VOLATILE) != 0;\n@@ -130,2 +147,2 @@\n-    public final void isPublic(final boolean flag) {\n-        setFlag(Const.ACC_PUBLIC, flag);\n+    public final void isTransient(final boolean flag) {\n+        setFlag(Const.ACC_TRANSIENT, flag);\n@@ -134,2 +151,2 @@\n-    public final boolean isStatic() {\n-        return (access_flags & Const.ACC_STATIC) != 0;\n+    public final boolean isTransient() {\n+        return (access_flags & Const.ACC_TRANSIENT) != 0;\n@@ -138,2 +155,2 @@\n-    public final void isStatic(final boolean flag) {\n-        setFlag(Const.ACC_STATIC, flag);\n+    public final void isNative(final boolean flag) {\n+        setFlag(Const.ACC_NATIVE, flag);\n@@ -142,2 +159,2 @@\n-    public final boolean isStrictfp() {\n-        return (access_flags & Const.ACC_STRICT) != 0;\n+    public final boolean isNative() {\n+        return (access_flags & Const.ACC_NATIVE) != 0;\n@@ -146,2 +163,2 @@\n-    public final void isStrictfp(final boolean flag) {\n-        setFlag(Const.ACC_STRICT, flag);\n+    public final void isInterface(final boolean flag) {\n+        setFlag(Const.ACC_INTERFACE, flag);\n@@ -150,2 +167,2 @@\n-    public final boolean isSynchronized() {\n-        return (access_flags & Const.ACC_SYNCHRONIZED) != 0;\n+    public final boolean isInterface() {\n+        return (access_flags & Const.ACC_INTERFACE) != 0;\n@@ -154,2 +171,2 @@\n-    public final void isSynchronized(final boolean flag) {\n-        setFlag(Const.ACC_SYNCHRONIZED, flag);\n+    public final void isAbstract(final boolean flag) {\n+        setFlag(Const.ACC_ABSTRACT, flag);\n@@ -158,2 +175,2 @@\n-    public final boolean isSynthetic() {\n-        return (access_flags & Const.ACC_SYNTHETIC) != 0;\n+    public final boolean isAbstract() {\n+        return (access_flags & Const.ACC_ABSTRACT) != 0;\n@@ -162,2 +179,2 @@\n-    public final void isSynthetic(final boolean flag) {\n-        setFlag(Const.ACC_SYNTHETIC, flag);\n+    public final void isStrictfp(final boolean flag) {\n+        setFlag(Const.ACC_STRICT, flag);\n@@ -166,2 +183,2 @@\n-    public final boolean isTransient() {\n-        return (access_flags & Const.ACC_TRANSIENT) != 0;\n+    public final boolean isStrictfp() {\n+        return (access_flags & Const.ACC_STRICT) != 0;\n@@ -170,2 +187,2 @@\n-    public final void isTransient(final boolean flag) {\n-        setFlag(Const.ACC_TRANSIENT, flag);\n+    public final void isSynthetic(final boolean flag) {\n+        setFlag(Const.ACC_SYNTHETIC, flag);\n@@ -174,2 +191,2 @@\n-    public final boolean isVarArgs() {\n-        return (access_flags & Const.ACC_VARARGS) != 0;\n+    public final boolean isSynthetic() {\n+        return (access_flags & Const.ACC_SYNTHETIC) != 0;\n@@ -178,2 +195,2 @@\n-    public final void isVarArgs(final boolean flag) {\n-        setFlag(Const.ACC_VARARGS, flag);\n+    public final void isAnnotation(final boolean flag) {\n+        setFlag(Const.ACC_ANNOTATION, flag);\n@@ -182,2 +199,2 @@\n-    public final boolean isVolatile() {\n-        return (access_flags & Const.ACC_VOLATILE) != 0;\n+    public final boolean isAnnotation() {\n+        return (access_flags & Const.ACC_ANNOTATION) != 0;\n@@ -186,2 +203,2 @@\n-    public final void isVolatile(final boolean flag) {\n-        setFlag(Const.ACC_VOLATILE, flag);\n+    public final void isEnum(final boolean flag) {\n+        setFlag(Const.ACC_ENUM, flag);\n@@ -190,7 +207,2 @@\n-    \/**\n-     * Set access flags aka \"modifiers\".\n-     *\n-     * @param accessFlags Access flags of the object.\n-     *\/\n-    public final void setAccessFlags(final int accessFlags) {\n-        this.access_flags = accessFlags;\n+    public final boolean isEnum() {\n+        return (access_flags & Const.ACC_ENUM) != 0;\n@@ -199,8 +211,2 @@\n-    private void setFlag(final int flag, final boolean set) {\n-        if ((access_flags & flag) != 0) { \/\/ Flag is set already\n-            if (!set) {\n-                access_flags ^= flag;\n-            }\n-        } else if (set) {\n-            access_flags |= flag;\n-        }\n+    public final void isVarArgs(final boolean flag) {\n+        setFlag(Const.ACC_VARARGS, flag);\n@@ -209,7 +215,2 @@\n-    \/**\n-     * Set access flags aka \"modifiers\".\n-     *\n-     * @param accessFlags Access flags of the object.\n-     *\/\n-    public final void setModifiers(final int accessFlags) {\n-        setAccessFlags(accessFlags);\n+    public final boolean isVarArgs() {\n+        return (access_flags & Const.ACC_VARARGS) != 0;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AccessFlags.java","additions":93,"deletions":92,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * Represents the default value of a annotation for a method info.\n+ * Represents the default value of a annotation for a method info\n@@ -40,4 +40,4 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n+     * @param name_index    Index pointing to the name <em>Code<\/em>\n+     * @param length        Content length in bytes\n+     * @param input         Input stream\n+     * @param constant_pool Array of constants\n@@ -45,3 +45,3 @@\n-    AnnotationDefault(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (ElementValue) null, constantPool);\n-        defaultValue = ElementValue.readElementValue(input, constantPool);\n+    AnnotationDefault(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (ElementValue) null, constant_pool);\n+        defaultValue = ElementValue.readElementValue(input, constant_pool);\n@@ -51,4 +51,4 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param defaultValue the annotation's default value\n-     * @param constantPool Array of constants\n+     * @param name_index    Index pointing to the name <em>Code<\/em>\n+     * @param length        Content length in bytes\n+     * @param defaultValue  the annotation's default value\n+     * @param constant_pool Array of constants\n@@ -56,2 +56,2 @@\n-    public AnnotationDefault(final int nameIndex, final int length, final ElementValue defaultValue, final ConstantPool constantPool) {\n-        super(Const.ATTR_ANNOTATION_DEFAULT, nameIndex, length, constantPool);\n+    public AnnotationDefault(final int name_index, final int length, final ElementValue defaultValue, final ConstantPool constant_pool) {\n+        super(Const.ATTR_ANNOTATION_DEFAULT, name_index, length, constant_pool);\n@@ -62,2 +62,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -72,9 +73,5 @@\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n-    }\n-\n-    @Override\n-    public final void dump(final DataOutputStream dos) throws IOException {\n-        super.dump(dos);\n-        defaultValue.dump(dos);\n+    \/**\n+     * @param defaultValue the default value of this methodinfo's annotation\n+     *\/\n+    public final void setDefaultValue(final ElementValue defaultValue) {\n+        this.defaultValue = defaultValue;\n@@ -90,5 +87,9 @@\n-    \/**\n-     * @param defaultValue the default value of this methodinfo's annotation\n-     *\/\n-    public final void setDefaultValue(final ElementValue defaultValue) {\n-        this.defaultValue = defaultValue;\n+    @Override\n+    public Attribute copy(final ConstantPool _constant_pool) {\n+        return (Attribute) clone();\n+    }\n+\n+    @Override\n+    public final void dump(final DataOutputStream dos) throws IOException {\n+        super.dump(dos);\n+        defaultValue.dump(dos);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationDefault.java","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,8 +30,38 @@\n-public class AnnotationElementValue extends ElementValue {\n-    \/\/ For annotation element values, this is the annotation\n-    private final AnnotationEntry annotationEntry;\n-\n-    public AnnotationElementValue(final int type, final AnnotationEntry annotationEntry, final ConstantPool cpool) {\n-        super(type, cpool);\n-        if (type != ANNOTATION) {\n-            throw new ClassFormatException(\"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n+public class AnnotationElementValue extends ElementValue\n+{\n+        \/\/ For annotation element values, this is the annotation\n+        private final AnnotationEntry annotationEntry;\n+\n+        public AnnotationElementValue(final int type, final AnnotationEntry annotationEntry,\n+                        final ConstantPool cpool)\n+        {\n+                super(type, cpool);\n+                if (type != ANNOTATION) {\n+                    throw new IllegalArgumentException(\n+                                    \"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n+                }\n+                this.annotationEntry = annotationEntry;\n+        }\n+\n+        @Override\n+        public void dump(final DataOutputStream dos) throws IOException\n+        {\n+                dos.writeByte(super.getType()); \/\/ u1 type of value (ANNOTATION == '@')\n+                annotationEntry.dump(dos);\n+        }\n+\n+        @Override\n+        public String stringifyValue()\n+        {\n+                return annotationEntry.toString();\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+                return stringifyValue();\n+        }\n+\n+        public AnnotationEntry getAnnotationEntry()\n+        {\n+                return annotationEntry;\n@@ -39,22 +69,0 @@\n-        this.annotationEntry = annotationEntry;\n-    }\n-\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getType()); \/\/ u1 type of value (ANNOTATION == '@')\n-        annotationEntry.dump(dos);\n-    }\n-\n-    public AnnotationEntry getAnnotationEntry() {\n-        return annotationEntry;\n-    }\n-\n-    @Override\n-    public String stringifyValue() {\n-        return annotationEntry.toString();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return stringifyValue();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationElementValue.java","additions":38,"deletions":30,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Collections;\n@@ -29,1 +30,2 @@\n-import java.util.stream.Stream;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -32,1 +34,1 @@\n- * Represents one annotation in the annotation table\n+ * represents one annotation in the annotation table\n@@ -38,1 +40,3 @@\n-    public static final AnnotationEntry[] EMPTY_ARRAY = {};\n+    private final int typeIndex;\n+    private final ConstantPool constantPool;\n+    private final boolean isRuntimeVisible;\n@@ -40,5 +44,1 @@\n-    public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attrs) {\n-        \/\/ Find attributes that contain annotation data\n-        return Stream.of(attrs).filter(Annotations.class::isInstance).flatMap(e -> Stream.of(((Annotations) e).getAnnotationEntries()))\n-            .toArray(AnnotationEntry[]::new);\n-    }\n+    private List<ElementValuePair> elementValuePairs;\n@@ -46,1 +46,1 @@\n-    \/**\n+    \/*\n@@ -53,1 +53,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -55,3 +55,4 @@\n-    public static AnnotationEntry read(final DataInput input, final ConstantPool constantPool, final boolean isRuntimeVisible) throws IOException {\n-        final AnnotationEntry annotationEntry = new AnnotationEntry(input.readUnsignedShort(), constantPool, isRuntimeVisible);\n-        final int numElementValuePairs = input.readUnsignedShort();\n+    public static AnnotationEntry read(final DataInput input, final ConstantPool constant_pool, final boolean isRuntimeVisible) throws IOException {\n+\n+        final AnnotationEntry annotationEntry = new AnnotationEntry(input.readUnsignedShort(), constant_pool, isRuntimeVisible);\n+        final int num_element_value_pairs = input.readUnsignedShort();\n@@ -59,3 +60,4 @@\n-        for (int i = 0; i < numElementValuePairs; i++) {\n-            annotationEntry.elementValuePairs\n-                .add(new ElementValuePair(input.readUnsignedShort(), ElementValue.readElementValue(input, constantPool), constantPool));\n+        for (int i = 0; i < num_element_value_pairs; i++) {\n+            annotationEntry.elementValuePairs.add(\n+                    new ElementValuePair(input.readUnsignedShort(), ElementValue.readElementValue(input, constant_pool),\n+                    constant_pool));\n@@ -66,3 +68,5 @@\n-    private final int typeIndex;\n-\n-    private final ConstantPool constantPool;\n+    public AnnotationEntry(final int type_index, final ConstantPool constant_pool, final boolean isRuntimeVisible) {\n+        this.typeIndex = type_index;\n+        this.constantPool = constant_pool;\n+        this.isRuntimeVisible = isRuntimeVisible;\n+    }\n@@ -70,1 +74,3 @@\n-    private final boolean isRuntimeVisible;\n+    public int getTypeIndex() {\n+        return typeIndex;\n+    }\n@@ -72,1 +78,3 @@\n-    private List<ElementValuePair> elementValuePairs;\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n+    }\n@@ -74,4 +82,2 @@\n-    public AnnotationEntry(final int typeIndex, final ConstantPool constantPool, final boolean isRuntimeVisible) {\n-        this.typeIndex = typeIndex;\n-        this.constantPool = constantPool;\n-        this.isRuntimeVisible = isRuntimeVisible;\n+    public boolean isRuntimeVisible() {\n+        return isRuntimeVisible;\n@@ -81,1 +87,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n@@ -91,13 +97,0 @@\n-    public void addElementNameValuePair(final ElementValuePair elementNameValuePair) {\n-        elementValuePairs.add(elementNameValuePair);\n-    }\n-\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n-        dos.writeShort(elementValuePairs.size()); \/\/ u2 element_value pair\n-        \/\/ count\n-        for (final ElementValuePair envp : elementValuePairs) {\n-            envp.dump(dos);\n-        }\n-    }\n-\n@@ -108,1 +101,2 @@\n-        return constantPool.getConstantUtf8(typeIndex).getBytes();\n+        final ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(typeIndex, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -118,2 +112,5 @@\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n+    \/**\n+     * @return the number of element value pairs in this annotation entry\n+     *\/\n+    public final int getNumElementValuePairs() {\n+        return elementValuePairs.size();\n@@ -127,1 +124,1 @@\n-        return elementValuePairs.toArray(ElementValuePair.EMPTY_ARRAY);\n+        return elementValuePairs.toArray(new ElementValuePair[elementValuePairs.size()]);\n@@ -130,9 +127,7 @@\n-    \/**\n-     * @return the number of element value pairs in this annotation entry\n-     *\/\n-    public final int getNumElementValuePairs() {\n-        return elementValuePairs.size();\n-    }\n-\n-    public int getTypeIndex() {\n-        return typeIndex;\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n+        dos.writeShort(elementValuePairs.size()); \/\/ u2 element_value pair\n+        \/\/ count\n+        for (final ElementValuePair envp : elementValuePairs) {\n+            envp.dump(dos);\n+        }\n@@ -141,2 +136,2 @@\n-    public boolean isRuntimeVisible() {\n-        return isRuntimeVisible;\n+    public void addElementNameValuePair(final ElementValuePair elementNameValuePair) {\n+        elementValuePairs.add(elementNameValuePair);\n@@ -154,1 +149,0 @@\n-                result.append(\", \");\n@@ -156,2 +150,0 @@\n-            \/\/ remove last \", \"\n-            result.setLength(result.length() - 2);\n@@ -167,0 +159,12 @@\n+\n+    public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attrs) {\n+        \/\/ Find attributes that contain annotation data\n+        final List<AnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n+        for (final Attribute attribute : attrs) {\n+            if (attribute instanceof Annotations) {\n+                final Annotations runtimeAnnotations = (Annotations) attribute;\n+                Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getAnnotationEntries());\n+            }\n+        }\n+        return accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationEntry.java","additions":61,"deletions":57,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n-\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -37,1 +33,1 @@\n-public abstract class Annotations extends Attribute implements Iterable<AnnotationEntry> {\n+public abstract class Annotations extends Attribute {\n@@ -43,8 +39,22 @@\n-     * Constructs an instance.\n-     *\n-     * @param annotationType   the subclass type of the annotation\n-     * @param nameIndex        Index pointing to the name <em>Code<\/em>\n-     * @param length           Content length in bytes\n-     * @param annotationTable  the actual annotations\n-     * @param constantPool     Array of constants\n-     * @param isRuntimeVisible whether this Annotation visible at runtime\n+     * @param annotation_type the subclass type of the annotation\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     *\/\n+    Annotations(final byte annotation_type, final int name_index, final int length, final DataInput input,\n+            final ConstantPool constant_pool, final boolean isRuntimeVisible) throws IOException {\n+        this(annotation_type, name_index, length, (AnnotationEntry[]) null, constant_pool, isRuntimeVisible);\n+        final int annotation_table_length = input.readUnsignedShort();\n+        annotationTable = new AnnotationEntry[annotation_table_length];\n+        for (int i = 0; i < annotation_table_length; i++) {\n+            annotationTable[i] = AnnotationEntry.read(input, constant_pool, isRuntimeVisible);\n+        }\n+    }\n+\n+    \/**\n+     * @param annotationType the subclass type of the annotation\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param length Content length in bytes\n+     * @param annotationTable the actual annotations\n+     * @param constantPool Array of constants\n@@ -60,24 +70,2 @@\n-     * Constructs an instance.\n-     *\n-     * @param annotationType   the subclass type of the annotation\n-     * @param nameIndex        Index pointing to the name <em>Code<\/em>\n-     * @param length           Content length in bytes\n-     * @param input            Input stream\n-     * @param constantPool     Array of constants\n-     * @param isRuntimeVisible whether this Annotation visible at runtime\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    Annotations(final byte annotationType, final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool,\n-            final boolean isRuntimeVisible) throws IOException {\n-        this(annotationType, nameIndex, length, (AnnotationEntry[]) null, constantPool, isRuntimeVisible);\n-        final int annotationTableLength = input.readUnsignedShort();\n-        annotationTable = new AnnotationEntry[annotationTableLength];\n-        for (int i = 0; i < annotationTableLength; i++) {\n-            annotationTable[i] = AnnotationEntry.read(input, constantPool, isRuntimeVisible);\n-        }\n-    }\n-\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -92,4 +80,5 @@\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        \/\/ TODO Auto-generated method stub\n-        return null;\n+    \/**\n+     * @param annotationTable the entries to set in this annotation\n+     *\/\n+    public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {\n+        this.annotationTable = annotationTable;\n@@ -99,1 +88,1 @@\n-     * Gets the array of annotation entries in this annotation\n+     * returns the array of annotation entries in this annotation\n@@ -106,2 +95,0 @@\n-     * Gets the number of annotation entries in this annotation.\n-     *\n@@ -121,32 +108,0 @@\n-    @Override\n-    public Iterator<AnnotationEntry> iterator() {\n-        return Stream.of(annotationTable).iterator();\n-    }\n-\n-    \/**\n-     * Sets the entries to set in this annotation.\n-     *\n-     * @param annotationTable the entries to set in this annotation\n-     *\/\n-    public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {\n-        this.annotationTable = annotationTable;\n-    }\n-\n-    \/**\n-     * Converts to a String representation.\n-     *\n-     * @return String representation\n-     *\/\n-    @Override\n-    public final String toString() {\n-        final StringBuilder buf = new StringBuilder(Const.getAttributeName(getTag()));\n-        buf.append(\":\\n\");\n-        for (int i = 0; i < annotationTable.length; i++) {\n-            buf.append(\"  \").append(annotationTable[i]);\n-            if (i < annotationTable.length - 1) {\n-                buf.append('\\n');\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n@@ -162,1 +117,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Annotations.java","additions":31,"deletions":77,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-public class ArrayElementValue extends ElementValue {\n+public class ArrayElementValue extends ElementValue\n+{\n@@ -34,1 +35,18 @@\n-    public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {\n+    @Override\n+    public String toString()\n+    {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"{\");\n+        for (int i = 0; i < elementValues.length; i++)\n+        {\n+            sb.append(elementValues[i]);\n+            if ((i + 1) < elementValues.length) {\n+                sb.append(\",\");\n+            }\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool)\n+    {\n@@ -37,1 +55,2 @@\n-            throw new ClassFormatException(\"Only element values of type array can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type array can be built with this ctor - type specified: \" + type);\n@@ -43,1 +62,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -51,8 +71,0 @@\n-    public ElementValue[] getElementValuesArray() {\n-        return elementValues;\n-    }\n-\n-    public int getElementValuesArraySize() {\n-        return elementValues.length;\n-    }\n-\n@@ -60,1 +72,2 @@\n-    public String stringifyValue() {\n+    public String stringifyValue()\n+    {\n@@ -63,1 +76,2 @@\n-        for (int i = 0; i < elementValues.length; i++) {\n+        for (int i = 0; i < elementValues.length; i++)\n+        {\n@@ -65,1 +79,1 @@\n-            if (i + 1 < elementValues.length) {\n+            if ((i + 1) < elementValues.length) {\n@@ -73,12 +87,8 @@\n-    @Override\n-    public String toString() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"{\");\n-        for (int i = 0; i < elementValues.length; i++) {\n-            sb.append(elementValues[i]);\n-            if (i + 1 < elementValues.length) {\n-                sb.append(\",\");\n-            }\n-        }\n-        sb.append(\"}\");\n-        return sb.toString();\n+    public ElementValue[] getElementValuesArray()\n+    {\n+        return elementValues;\n+    }\n+\n+    public int getElementValuesArraySize()\n+    {\n+        return elementValues.length;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ArrayElementValue.java","additions":37,"deletions":27,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -33,11 +32,6 @@\n- * Abstract super class for <em>Attribute<\/em> objects. Currently the <em>ConstantValue<\/em>, <em>SourceFile<\/em>, <em>Code<\/em>, <em>Exceptiontable<\/em>,\n- * <em>LineNumberTable<\/em>, <em>LocalVariableTable<\/em>, <em>InnerClasses<\/em> and <em>Synthetic<\/em> attributes are supported. The <em>Unknown<\/em> attribute\n- * stands for non-standard-attributes.\n- *\n- * <pre>\n- * attribute_info {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u1 info[attribute_length];\n- * }\n- * <\/pre>\n+ * Abstract super class for <em>Attribute<\/em> objects. Currently the\n+ * <em>ConstantValue<\/em>, <em>SourceFile<\/em>, <em>Code<\/em>,\n+ * <em>Exceptiontable<\/em>, <em>LineNumberTable<\/em>,\n+ * <em>LocalVariableTable<\/em>, <em>InnerClasses<\/em> and\n+ * <em>Synthetic<\/em> attributes are supported. The <em>Unknown<\/em>\n+ * attribute stands for non-standard-attributes.\n@@ -56,1 +50,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -60,0 +54,4 @@\n+    private int name_index; \/\/ Points to attribute name in constant pool\n+    private int length; \/\/ Content length of attribute field\n+    private final byte tag; \/\/ Tag to distinguish subclasses\n+    private ConstantPool constant_pool;\n@@ -61,8 +59,1 @@\n-    private static final Map<String, Object> READERS = new HashMap<>();\n-\n-    \/**\n-     * Empty array.\n-     *\n-     * @since 6.6.0\n-     *\/\n-    public static final Attribute[] EMPTY_ARRAY = {};\n+    private static final Map<String, Object> readers = new HashMap<>();\n@@ -71,2 +62,3 @@\n-     * Add an Attribute reader capable of parsing (user-defined) attributes named \"name\". You should not add readers for the\n-     * standard attributes such as \"LineNumberTable\", because those are handled internally.\n+     * Add an Attribute reader capable of parsing (user-defined) attributes\n+     * named \"name\". You should not add readers for the standard attributes such\n+     * as \"LineNumberTable\", because those are handled internally.\n@@ -75,1 +67,1 @@\n-     * @param unknownAttributeReader the reader object\n+     * @param r    the reader object\n@@ -77,2 +69,3 @@\n-    public static void addAttributeReader(final String name, final UnknownAttributeReader unknownAttributeReader) {\n-        READERS.put(name, unknownAttributeReader);\n+    public static void addAttributeReader(final String name, final UnknownAttributeReader r)\n+    {\n+        readers.put(name, r);\n@@ -88,2 +81,3 @@\n-     * Class method reads one attribute from the input data stream. This method must not be accessible from the outside. It\n-     * is called by the Field and Method constructor methods.\n+     * Class method reads one attribute from the input data stream. This method\n+     * must not be accessible from the outside. It is called by the Field and\n+     * Method constructor methods.\n@@ -94,2 +88,2 @@\n-     * @param dataInput Input stream\n-     * @param constantPool Array of constants\n+     * @param file Input stream\n+     * @param constant_pool Array of constants\n@@ -97,1 +91,2 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -100,1 +95,3 @@\n-    public static Attribute readAttribute(final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n+    public static Attribute readAttribute(final DataInput file, final ConstantPool constant_pool)\n+            throws IOException, ClassFormatException\n+    {\n@@ -102,3 +99,4 @@\n-        \/\/ Get class name from constant pool via 'name_index' indirection\n-        final int nameIndex = dataInput.readUnsignedShort();\n-        final String name = constantPool.getConstantUtf8(nameIndex).getBytes();\n+        \/\/ Get class name from constant pool via `name_index' indirection\n+        final int name_index = file.readUnsignedShort();\n+        final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n+        final String name = c.getBytes();\n@@ -107,1 +105,1 @@\n-        final int length = dataInput.readInt();\n+        final int length = file.readInt();\n@@ -110,2 +108,4 @@\n-        for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++) {\n-            if (name.equals(Const.getAttributeName(i))) {\n+        for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++)\n+        {\n+            if (name.equals(Const.getAttributeName(i)))\n+            {\n@@ -117,70 +117,72 @@\n-        \/\/ Call proper constructor, depending on 'tag'\n-        switch (tag) {\n-        case Const.ATTR_UNKNOWN:\n-            final Object r = READERS.get(name);\n-            if (r instanceof UnknownAttributeReader) {\n-                return ((UnknownAttributeReader) r).createAttribute(nameIndex, length, dataInput, constantPool);\n-            }\n-            return new Unknown(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_CONSTANT_VALUE:\n-            return new ConstantValue(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_SOURCE_FILE:\n-            return new SourceFile(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_CODE:\n-            return new Code(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_EXCEPTIONS:\n-            return new ExceptionTable(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_LINE_NUMBER_TABLE:\n-            return new LineNumberTable(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_LOCAL_VARIABLE_TABLE:\n-            return new LocalVariableTable(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_INNER_CLASSES:\n-            return new InnerClasses(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_SYNTHETIC:\n-            return new Synthetic(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_DEPRECATED:\n-            return new Deprecated(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_PMG:\n-            return new PMGClass(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_SIGNATURE:\n-            return new Signature(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_STACK_MAP:\n-            \/\/ old style stack map: unneeded for JDK5 and below;\n-            \/\/ illegal(?) for JDK6 and above. So just delete with a warning.\n-            println(\"Warning: Obsolete StackMap attribute ignored.\");\n-            return new Unknown(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:\n-            return new RuntimeVisibleAnnotations(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:\n-            return new RuntimeInvisibleAnnotations(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:\n-            return new RuntimeVisibleParameterAnnotations(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:\n-            return new RuntimeInvisibleParameterAnnotations(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_ANNOTATION_DEFAULT:\n-            return new AnnotationDefault(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:\n-            return new LocalVariableTypeTable(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_ENCLOSING_METHOD:\n-            return new EnclosingMethod(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_STACK_MAP_TABLE:\n-            \/\/ read new style stack map: StackMapTable. The rest of the code\n-            \/\/ calls this a StackMap for historical reasons.\n-            return new StackMap(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_BOOTSTRAP_METHODS:\n-            return new BootstrapMethods(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_METHOD_PARAMETERS:\n-            return new MethodParameters(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_MODULE:\n-            return new Module(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_MODULE_PACKAGES:\n-            return new ModulePackages(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_MODULE_MAIN_CLASS:\n-            return new ModuleMainClass(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_NEST_HOST:\n-            return new NestHost(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_NEST_MEMBERS:\n-            return new NestMembers(nameIndex, length, dataInput, constantPool);\n-        default:\n-            \/\/ Never reached\n-            throw new IllegalStateException(\"Unrecognized attribute type tag parsed: \" + tag);\n+        \/\/ Call proper constructor, depending on `tag'\n+        switch (tag)\n+        {\n+            case Const.ATTR_UNKNOWN:\n+                final Object r = readers.get(name);\n+                if (r instanceof UnknownAttributeReader)\n+                {\n+                    return ((UnknownAttributeReader) r).createAttribute(name_index, length, file, constant_pool);\n+                }\n+                return new Unknown(name_index, length, file, constant_pool);\n+            case Const.ATTR_CONSTANT_VALUE:\n+                return new ConstantValue(name_index, length, file, constant_pool);\n+            case Const.ATTR_SOURCE_FILE:\n+                return new SourceFile(name_index, length, file, constant_pool);\n+            case Const.ATTR_CODE:\n+                return new Code(name_index, length, file, constant_pool);\n+            case Const.ATTR_EXCEPTIONS:\n+                return new ExceptionTable(name_index, length, file, constant_pool);\n+            case Const.ATTR_LINE_NUMBER_TABLE:\n+                return new LineNumberTable(name_index, length, file, constant_pool);\n+            case Const.ATTR_LOCAL_VARIABLE_TABLE:\n+                return new LocalVariableTable(name_index, length, file, constant_pool);\n+            case Const.ATTR_INNER_CLASSES:\n+                return new InnerClasses(name_index, length, file, constant_pool);\n+            case Const.ATTR_SYNTHETIC:\n+                return new Synthetic(name_index, length, file, constant_pool);\n+            case Const.ATTR_DEPRECATED:\n+                return new Deprecated(name_index, length, file, constant_pool);\n+            case Const.ATTR_PMG:\n+                return new PMGClass(name_index, length, file, constant_pool);\n+            case Const.ATTR_SIGNATURE:\n+                return new Signature(name_index, length, file, constant_pool);\n+            case Const.ATTR_STACK_MAP:\n+                \/\/ old style stack map: unneeded for JDK5 and below;\n+                \/\/ illegal(?) for JDK6 and above.  So just delete with a warning.\n+                println(\"Warning: Obsolete StackMap attribute ignored.\");\n+                return new Unknown(name_index, length, file, constant_pool);\n+            case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:\n+                return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool);\n+            case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:\n+                return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool);\n+            case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:\n+                return new RuntimeVisibleParameterAnnotations(name_index, length, file, constant_pool);\n+            case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:\n+                return new RuntimeInvisibleParameterAnnotations(name_index, length, file, constant_pool);\n+            case Const.ATTR_ANNOTATION_DEFAULT:\n+                return new AnnotationDefault(name_index, length, file, constant_pool);\n+            case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:\n+                return new LocalVariableTypeTable(name_index, length, file, constant_pool);\n+            case Const.ATTR_ENCLOSING_METHOD:\n+                return new EnclosingMethod(name_index, length, file, constant_pool);\n+            case Const.ATTR_STACK_MAP_TABLE:\n+                \/\/ read new style stack map: StackMapTable.  The rest of the code\n+                \/\/ calls this a StackMap for historical reasons.\n+                return new StackMap(name_index, length, file, constant_pool);\n+            case Const.ATTR_BOOTSTRAP_METHODS:\n+                return new BootstrapMethods(name_index, length, file, constant_pool);\n+            case Const.ATTR_METHOD_PARAMETERS:\n+                return new MethodParameters(name_index, length, file, constant_pool);\n+            case Const.ATTR_MODULE:\n+                return new Module(name_index, length, file, constant_pool);\n+            case Const.ATTR_MODULE_PACKAGES:\n+                return new ModulePackages(name_index, length, file, constant_pool);\n+            case Const.ATTR_MODULE_MAIN_CLASS:\n+                return new ModuleMainClass(name_index, length, file, constant_pool);\n+            case Const.ATTR_NEST_HOST:\n+                return new NestHost(name_index, length, file, constant_pool);\n+            case Const.ATTR_NEST_MEMBERS:\n+                return new NestMembers(name_index, length, file, constant_pool);\n+            default:\n+                \/\/ Never reached\n+                throw new IllegalStateException(\"Unrecognized attribute type tag parsed: \" + tag);\n@@ -191,2 +193,3 @@\n-     * Class method reads one attribute from the input data stream. This method must not be accessible from the outside. It\n-     * is called by the Field and Method constructor methods.\n+     * Class method reads one attribute from the input data stream. This method\n+     * must not be accessible from the outside. It is called by the Field and\n+     * Method constructor methods.\n@@ -197,2 +200,2 @@\n-     * @param dataInputStream Input stream\n-     * @param constantPool Array of constants\n+     * @param file Input stream\n+     * @param constant_pool Array of constants\n@@ -200,1 +203,2 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -202,2 +206,4 @@\n-    public static Attribute readAttribute(final DataInputStream dataInputStream, final ConstantPool constantPool) throws IOException {\n-        return readAttribute((DataInput) dataInputStream, constantPool);\n+    public static Attribute readAttribute(final DataInputStream file, final ConstantPool constant_pool)\n+            throws IOException, ClassFormatException\n+    {\n+        return readAttribute((DataInput) file, constant_pool);\n@@ -211,2 +217,3 @@\n-    public static void removeAttributeReader(final String name) {\n-        READERS.remove(name);\n+    public static void removeAttributeReader(final String name)\n+    {\n+        readers.remove(name);\n@@ -215,41 +222,2 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int name_index; \/\/ Points to attribute name in constant pool TODO make private (has getter & setter)\n-\n-    \/**\n-     * @deprecated (since 6.0) (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int length; \/\/ Content length of attribute field TODO make private (has getter & setter)\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected byte tag; \/\/ Tag to distinguish subclasses TODO make private & final; supposed to be immutable\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected ConstantPool constant_pool; \/\/ TODO make private (has getter & setter)\n-\n-    \/**\n-     * Constructs an instance.\n-     *\n-     * <pre>\n-     * attribute_info {\n-     *   u2 attribute_name_index;\n-     *   u4 attribute_length;\n-     *   u1 info[attribute_length];\n-     * }\n-     * <\/pre>\n-     *\n-     * @param tag tag.\n-     * @param nameIndex u2 name index.\n-     * @param length u4 length.\n-     * @param constantPool constant pool.\n-     *\/\n-    protected Attribute(final byte tag, final int nameIndex, final int length, final ConstantPool constantPool) {\n+    protected Attribute(final byte tag, final int name_index, final int length, final ConstantPool constant_pool)\n+    {\n@@ -257,3 +225,3 @@\n-        this.name_index = Args.requireU2(nameIndex, 0, constantPool.getLength(), getClass().getSimpleName() + \" name index\");\n-        this.length = Args.requireU4(length, getClass().getSimpleName() + \" attribute length\");\n-        this.constant_pool = constantPool;\n+        this.name_index = name_index;\n+        this.length = length;\n+        this.constant_pool = constant_pool;\n@@ -263,2 +231,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -266,1 +235,2 @@\n-     * @param v Visitor object\n+     * @param v\n+     *            Visitor object\n@@ -272,1 +242,2 @@\n-     * Use copy() if you want to have a deep copy(), i.e., with all references copied correctly.\n+     * Use copy() if you want to have a deep copy(), i.e., with all references\n+     * copied correctly.\n@@ -277,1 +248,2 @@\n-    public Object clone() {\n+    public Object clone()\n+    {\n@@ -279,1 +251,2 @@\n-        try {\n+        try\n+        {\n@@ -281,1 +254,3 @@\n-        } catch (final CloneNotSupportedException e) {\n+        }\n+        catch (final CloneNotSupportedException e)\n+        {\n@@ -288,2 +263,1 @@\n-     * @param constantPool constant pool to save.\n-     * @return deep copy of this attribute.\n+     * @return deep copy of this attribute\n@@ -291,1 +265,1 @@\n-    public abstract Attribute copy(ConstantPool constantPool);\n+    public abstract Attribute copy(ConstantPool _constant_pool);\n@@ -294,1 +268,1 @@\n-     * Dumps attribute to file stream in binary format.\n+     * Dump attribute to file stream in binary format.\n@@ -296,2 +270,3 @@\n-     * @param file Output file stream\n-     * @throws IOException if an I\/O error occurs.\n+     * @param file\n+     *            Output file stream\n+     * @throws IOException\n@@ -299,1 +274,2 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException\n+    {\n@@ -308,1 +284,2 @@\n-    public final ConstantPool getConstantPool() {\n+    public final ConstantPool getConstantPool()\n+    {\n@@ -315,1 +292,2 @@\n-    public final int getLength() {\n+    public final int getLength()\n+    {\n@@ -323,2 +301,4 @@\n-    public String getName() {\n-        return constant_pool.getConstantUtf8(name_index).getBytes();\n+    public String getName()\n+    {\n+        final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -330,1 +310,2 @@\n-    public final int getNameIndex() {\n+    public final int getNameIndex()\n+    {\n@@ -337,1 +318,2 @@\n-    public final byte getTag() {\n+    public final byte getTag()\n+    {\n@@ -342,1 +324,1 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * @param constant_pool Constant pool to be used for this object.\n@@ -345,2 +327,3 @@\n-    public final void setConstantPool(final ConstantPool constantPool) {\n-        this.constant_pool = constantPool;\n+    public final void setConstantPool(final ConstantPool constant_pool)\n+    {\n+        this.constant_pool = constant_pool;\n@@ -352,1 +335,2 @@\n-    public final void setLength(final int length) {\n+    public final void setLength(final int length)\n+    {\n@@ -357,1 +341,1 @@\n-     * @param nameIndex of attribute.\n+     * @param name_index of attribute.\n@@ -359,2 +343,3 @@\n-    public final void setNameIndex(final int nameIndex) {\n-        this.name_index = nameIndex;\n+    public final void setNameIndex(final int name_index)\n+    {\n+        this.name_index = name_index;\n@@ -367,1 +352,2 @@\n-    public String toString() {\n+    public String toString()\n+    {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Attribute.java","additions":176,"deletions":190,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -25,3 +25,4 @@\n- * Unknown (non-standard) attributes may be read via user-defined factory objects that can be registered with the\n- * Attribute.addAttributeReader method. These factory objects should implement this interface.\n- *\n+ * Unknown (non-standard) attributes may be read via user-defined factory\n+ * objects that can be registered with the Attribute.addAttributeReader\n+ * method. These factory objects should implement this interface.\n+\n@@ -36,17 +37,24 @@\n-     * When this attribute reader is added via the static method Attribute.addAttributeReader, an attribute name is\n-     * associated with it. As the class file parser parses attributes, it will call various AttributeReaders based on the\n-     * name of the attributes it is constructing.\n-     *\n-     * @param nameIndex An index into the constant pool, indexing a ConstantUtf8 that represents the name of the attribute.\n-     *\n-     * @param length The length of the data contained in the attribute. This is written into the constant pool and should\n-     *        agree with what the factory expects the length to be.\n-     *\n-     * @param file This is the data input stream that the factory needs to read its data from.\n-     *\n-     * @param constantPool This is the constant pool associated with the Attribute that we are constructing.\n-     *\n-     * @return The user-defined AttributeReader should take this data and use it to construct an attribute. In the case of\n-     *         errors, a null can be returned which will cause the parsing of the class file to fail.\n-     *\n-     * @see Attribute#addAttributeReader( String, AttributeReader )\n+     When this attribute reader is added via the static method\n+     Attribute.addAttributeReader, an attribute name is associated with it.\n+     As the class file parser parses attributes, it will call various\n+     AttributeReaders based on the name of the attributes it is\n+     constructing.\n+\n+     @param name_index An index into the constant pool, indexing a\n+     ConstantUtf8 that represents the name of the attribute.\n+\n+     @param length The length of the data contained in the attribute.  This\n+     is written into the constant pool and should agree with what the\n+     factory expects the length to be.\n+\n+     @param file This is the data input stream that the factory needs to read\n+     its data from.\n+\n+     @param constant_pool This is the constant pool associated with the\n+     Attribute that we are constructing.\n+\n+     @return The user-defined AttributeReader should take this data and use\n+     it to construct an attribute.  In the case of errors, a null can be\n+     returned which will cause the parsing of the class file to fail.\n+\n+     @see Attribute#addAttributeReader( String, AttributeReader )\n@@ -54,1 +62,1 @@\n-    Attribute createAttribute(int nameIndex, int length, java.io.DataInputStream file, ConstantPool constantPool);\n+    Attribute createAttribute( int name_index, int length, java.io.DataInputStream file, ConstantPool constant_pool );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AttributeReader.java","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * This class represents a bootstrap method attribute, i.e., the bootstrap method ref, the number of bootstrap arguments\n- * and an array of the bootstrap arguments.\n+ * This class represents a bootstrap method attribute, i.e., the bootstrap\n+ * method ref, the number of bootstrap arguments and an array of the\n+ * bootstrap arguments.\n@@ -35,2 +36,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\"> The class File Format :\n- *      The BootstrapMethods Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\">\n+ * The class File Format : The BootstrapMethods Attribute<\/a>\n@@ -47,0 +48,1 @@\n+\n@@ -49,2 +51,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -60,1 +60,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -71,2 +71,2 @@\n-    private BootstrapMethod(final int bootstrapMethodRef, final int numBootstrapArguments) {\n-        this(bootstrapMethodRef, new int[numBootstrapArguments]);\n+    private BootstrapMethod(final int bootstrap_method_ref, final int num_bootstrap_arguments) {\n+        this(bootstrap_method_ref, new int[num_bootstrap_arguments]);\n@@ -85,1 +85,1 @@\n-     * @return deep copy of this object\n+     * @return index into constant_pool of bootstrap_method\n@@ -87,7 +87,2 @@\n-    public BootstrapMethod copy() {\n-        try {\n-            return (BootstrapMethod) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public int getBootstrapMethodRef() {\n+        return bootstrapMethodRef;\n@@ -97,4 +92,1 @@\n-     * Dump object to file stream in binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException if an I\/O error occurs.\n+     * @param bootstrapMethodRef int index into constant_pool of CONSTANT_MethodHandle\n@@ -102,6 +94,2 @@\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        file.writeShort(bootstrapMethodRef);\n-        file.writeShort(bootstrapArguments.length);\n-        for (final int bootstrapArgument : bootstrapArguments) {\n-            file.writeShort(bootstrapArgument);\n-        }\n+    public void setBootstrapMethodRef(final int bootstrapMethodRef) {\n+        this.bootstrapMethodRef = bootstrapMethodRef;\n@@ -117,7 +105,0 @@\n-    \/**\n-     * @return index into constant_pool of bootstrap_method\n-     *\/\n-    public int getBootstrapMethodRef() {\n-        return bootstrapMethodRef;\n-    }\n-\n@@ -138,7 +119,0 @@\n-    \/**\n-     * @param bootstrapMethodRef int index into constant_pool of CONSTANT_MethodHandle\n-     *\/\n-    public void setBootstrapMethodRef(final int bootstrapMethodRef) {\n-        this.bootstrapMethodRef = bootstrapMethodRef;\n-    }\n-\n@@ -150,1 +124,2 @@\n-        return \"BootstrapMethod(\" + bootstrapMethodRef + \", \" + bootstrapArguments.length + \", \" + Arrays.toString(bootstrapArguments) + \")\";\n+        return \"BootstrapMethod(\" + bootstrapMethodRef + \", \" + bootstrapArguments.length + \", \"\n+               + Arrays.toString(bootstrapArguments) + \")\";\n@@ -156,1 +131,1 @@\n-    public final String toString(final ConstantPool constantPool) {\n+    public final String toString( final ConstantPool constantPool ) {\n@@ -158,4 +133,6 @@\n-        final String bootstrapMethodName = constantPool.constantToString(bootstrapMethodRef, Const.CONSTANT_MethodHandle);\n-        buf.append(Utility.compactClassName(bootstrapMethodName, false));\n-        final int bootstrapArgumentsLen = bootstrapArguments.length;\n-        if (bootstrapArgumentsLen > 0) {\n+        String bootstrap_method_name;\n+        bootstrap_method_name = constantPool.constantToString(bootstrapMethodRef,\n+                Const.CONSTANT_MethodHandle);\n+        buf.append(Utility.compactClassName(bootstrap_method_name, false));\n+        final int num_bootstrap_arguments = bootstrapArguments.length;\n+        if (num_bootstrap_arguments > 0) {\n@@ -163,1 +140,1 @@\n-            for (int i = 0; i < bootstrapArgumentsLen; i++) {\n+            for (int i = 0; i < num_bootstrap_arguments; i++) {\n@@ -170,0 +147,26 @@\n+\n+    \/**\n+     * Dump object to file stream in binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException\n+     *\/\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        file.writeShort(bootstrapMethodRef);\n+        file.writeShort(bootstrapArguments.length);\n+        for (final int bootstrap_argument : bootstrapArguments) {\n+            file.writeShort(bootstrap_argument);\n+        }\n+    }\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public BootstrapMethod copy() {\n+        try {\n+            return (BootstrapMethod) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/BootstrapMethod.java","additions":51,"deletions":48,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -35,2 +33,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\"> The class File Format :\n- *      The BootstrapMethods Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\">\n+ * The class File Format : The BootstrapMethods Attribute<\/a>\n@@ -39,1 +37,1 @@\n-public class BootstrapMethods extends Attribute implements Iterable<BootstrapMethod> {\n+public class BootstrapMethods extends Attribute {\n@@ -41,1 +39,1 @@\n-    private BootstrapMethod[] bootstrapMethods; \/\/ TODO this could be made final (setter is not used)\n+    private BootstrapMethod[] bootstrapMethods;  \/\/ TODO this could be made final (setter is not used)\n@@ -44,4 +42,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -53,0 +49,1 @@\n+\n@@ -54,1 +51,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -57,1 +54,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -59,2 +56,2 @@\n-    public BootstrapMethods(final int nameIndex, final int length, final BootstrapMethod[] bootstrapMethods, final ConstantPool constantPool) {\n-        super(Const.ATTR_BOOTSTRAP_METHODS, nameIndex, length, constantPool);\n+    public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrapMethods, final ConstantPool constant_pool) {\n+        super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);\n@@ -67,1 +64,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -70,2 +67,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -73,2 +70,2 @@\n-    BootstrapMethods(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (BootstrapMethod[]) null, constantPool);\n+    BootstrapMethods(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (BootstrapMethod[]) null, constant_pool);\n@@ -76,3 +73,3 @@\n-        final int numBootstrapMethods = input.readUnsignedShort();\n-        bootstrapMethods = new BootstrapMethod[numBootstrapMethods];\n-        for (int i = 0; i < numBootstrapMethods; i++) {\n+        final int num_bootstrap_methods = input.readUnsignedShort();\n+        bootstrapMethods = new BootstrapMethod[num_bootstrap_methods];\n+        for (int i = 0; i < num_bootstrap_methods; i++) {\n@@ -83,0 +80,14 @@\n+    \/**\n+     * @return array of bootstrap method \"records\"\n+     *\/\n+    public final BootstrapMethod[] getBootstrapMethods() {\n+        return bootstrapMethods;\n+    }\n+\n+    \/**\n+     * @param bootstrapMethods the array of bootstrap methods\n+     *\/\n+    public final void setBootstrapMethods(final BootstrapMethod[] bootstrapMethods) {\n+        this.bootstrapMethods = bootstrapMethods;\n+    }\n+\n@@ -95,1 +106,1 @@\n-    public BootstrapMethods copy(final ConstantPool constantPool) {\n+    public BootstrapMethods copy(final ConstantPool _constant_pool) {\n@@ -102,1 +113,1 @@\n-        c.setConstantPool(constantPool);\n+        c.setConstantPool(_constant_pool);\n@@ -110,1 +121,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -117,2 +128,2 @@\n-        for (final BootstrapMethod bootstrapMethod : bootstrapMethods) {\n-            bootstrapMethod.dump(file);\n+        for (final BootstrapMethod bootstrap_method : bootstrapMethods) {\n+            bootstrap_method.dump(file);\n@@ -122,19 +133,0 @@\n-    \/**\n-     * @return array of bootstrap method \"records\"\n-     *\/\n-    public final BootstrapMethod[] getBootstrapMethods() {\n-        return bootstrapMethods;\n-    }\n-\n-    @Override\n-    public Iterator<BootstrapMethod> iterator() {\n-        return Stream.of(bootstrapMethods).iterator();\n-    }\n-\n-    \/**\n-     * @param bootstrapMethods the array of bootstrap methods\n-     *\/\n-    public final void setBootstrapMethods(final BootstrapMethod[] bootstrapMethods) {\n-        this.bootstrapMethods = bootstrapMethods;\n-    }\n-\n@@ -154,2 +146,2 @@\n-            final int indentCount = buf.length() - start;\n-            final String[] lines = bootstrapMethods[i].toString(super.getConstantPool()).split(\"\\\\r?\\\\n\");\n+            final int indent_count = buf.length() - start;\n+            final String[] lines = (bootstrapMethods[i].toString(super.getConstantPool())).split(\"\\\\r?\\\\n\");\n@@ -158,1 +150,1 @@\n-                buf.append(\"\\n\").append(\"          \", 0, indentCount).append(lines[j]);\n+                buf.append(\"\\n\").append(\"          \".substring(0,indent_count)).append(lines[j]);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/BootstrapMethods.java","additions":41,"deletions":49,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -30,1 +32,2 @@\n-public class ClassElementValue extends ElementValue {\n+public class ClassElementValue extends ElementValue\n+{\n@@ -36,1 +39,2 @@\n-    public ClassElementValue(final int type, final int idx, final ConstantPool cpool) {\n+    public ClassElementValue(final int type, final int idx, final ConstantPool cpool)\n+    {\n@@ -41,4 +45,3 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getType()); \/\/ u1 kind of value\n-        dos.writeShort(idx);\n+    public int getIndex()\n+    {\n+        return idx;\n@@ -47,2 +50,5 @@\n-    public String getClassString() {\n-        return super.getConstantPool().getConstantUtf8(idx).getBytes();\n+    public String getClassString()\n+    {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(idx,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -51,2 +57,6 @@\n-    public int getIndex() {\n-        return idx;\n+    @Override\n+    public String stringifyValue()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(idx,\n+                Const.CONSTANT_Utf8);\n+        return cu8.getBytes();\n@@ -56,2 +66,4 @@\n-    public String stringifyValue() {\n-        return super.getConstantPool().getConstantUtf8(idx).getBytes();\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        dos.writeByte(super.getType()); \/\/ u1 kind of value\n+        dos.writeShort(idx);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassElementValue.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -25,1 +25,4 @@\n- * Thrown when the BCEL attempts to read a class file and determines that a class is malformed or otherwise cannot be interpreted as a class file.\n+ * Thrown when the BCEL attempts to read a class file and determines\n+ * that the file is malformed or otherwise cannot be interpreted as a\n+ * class file.\n+ *\n@@ -31,4 +34,0 @@\n-    \/**\n-     * Constructs a new instance with {@code null} as its detail message. The cause is not initialized, and may subsequently be initialized by a call to\n-     * {@link #initCause}.\n-     *\/\n@@ -36,0 +35,1 @@\n+        super();\n@@ -38,8 +38,3 @@\n-    \/**\n-     * Constructs a new instance with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to\n-     * {@link #initCause}.\n-     *\n-     * @param message the detail message. The detail message is saved for later retrieval by the {@link #getMessage()} method.\n-     *\/\n-    public ClassFormatException(final String message) {\n-        super(message);\n+\n+    public ClassFormatException(final String s) {\n+        super(s);\n@@ -49,7 +44,0 @@\n-     * Constructs a new instance with the specified detail message and cause.\n-     * <p>\n-     * Note that the detail message associated with {@code cause} is <i>not<\/i> automatically incorporated in this runtime exception's detail message.\n-     *\n-     * @param message the detail message (which is saved for later retrieval by the {@link #getMessage()} method).\n-     * @param cause   the cause (which is saved for later retrieval by the {@link #getCause()} method). (A {@code null} value is permitted, and indicates that\n-     *                the cause is nonexistent or unknown.)\n@@ -61,12 +49,0 @@\n-\n-    \/**\n-     * Constructs a new instance with the specified cause and a detail message of {@code (cause==null ? null : cause.toString())} (which typically contains the\n-     * class and detail message of {@code cause}). This constructor is useful for runtime exceptions that are little more than wrappers for other throwables.\n-     *\n-     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method). (A {@code null} value is permitted, and indicates that the\n-     *              cause is nonexistent or unknown.)\n-     * @since 6.7.0\n-     *\/\n-    public ClassFormatException(final Throwable cause) {\n-        super(cause);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassFormatException.java","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,3 +35,10 @@\n- * Wrapper class that parses a given Java .class file. The method <a href =\"#parse\">parse<\/a> returns a\n- * <a href =\"JavaClass.html\"> JavaClass<\/a> object on success. When an I\/O error or an inconsistency occurs an\n- * appropriate exception is propagated back to the caller.\n+ * Wrapper class that parses a given Java .class file. The method <A\n+ * href =\"#parse\">parse<\/A> returns a <A href =\"JavaClass.html\">\n+ * JavaClass<\/A> object on success. When an I\/O error or an\n+ * inconsistency occurs an appropiate exception is propagated back to\n+ * the caller.\n+ *\n+ * The structure and the names comply, except for a few conveniences,\n+ * exactly with the <A href=\"http:\/\/docs.oracle.com\/javase\/specs\/\">\n+ * JVM specification 1.0<\/a>. See this paper for\n+ * further details about the structure of a bytecode file.\n@@ -39,3 +46,0 @@\n- * The structure and the names comply, except for a few conveniences, exactly with the\n- * <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/\"> JVM specification 1.0<\/a>. See this paper for further details about\n- * the structure of a bytecode file.\n@@ -45,1 +49,0 @@\n-    private static final int BUFSIZE = 8192;\n@@ -61,0 +64,2 @@\n+    private static final int BUFSIZE = 8192;\n+\n@@ -70,1 +75,1 @@\n-        this.fileOwned = false;\n+        fileOwned = false;\n@@ -72,1 +77,1 @@\n-        this.isZip = clazz.startsWith(\"java.util.zip.\") || clazz.startsWith(\"java.util.jar.\");\n+        isZip = clazz.startsWith(\"java.util.zip.\") || clazz.startsWith(\"java.util.jar.\");\n@@ -80,2 +85,2 @@\n-    \/**\n-     * Parses class from given .class file.\n+\n+    \/** Parses class from given .class file.\n@@ -86,1 +91,1 @@\n-        this.isZip = false;\n+        isZip = false;\n@@ -88,1 +93,1 @@\n-        this.fileOwned = true;\n+        fileOwned = true;\n@@ -91,2 +96,2 @@\n-    \/**\n-     * Parses class from given .class file in a ZIP-archive\n+\n+    \/** Parses class from given .class file in a ZIP-archive\n@@ -98,2 +103,2 @@\n-        this.isZip = true;\n-        this.fileOwned = true;\n+        isZip = true;\n+        fileOwned = true;\n@@ -104,0 +109,1 @@\n+\n@@ -105,3 +111,5 @@\n-     * Parses the given Java class file and return an object that represents the contained data, i.e., constants, methods,\n-     * fields and commands. A <em>ClassFormatException<\/em> is raised, if the file is not a valid .class file. (This does\n-     * not include verification of the byte code as it is performed by the java interpreter).\n+     * Parses the given Java class file and return an object that represents\n+     * the contained data, i.e., constants, methods, fields and commands.\n+     * A <em>ClassFormatException<\/em> is raised, if the file is not a valid\n+     * .class file. (This does not include verification of the byte code as it\n+     * is performed by the java interpreter).\n@@ -110,2 +118,2 @@\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -125,1 +133,2 @@\n-                    dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry), BUFSIZE));\n+                    dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry),\n+                            BUFSIZE));\n@@ -127,1 +136,2 @@\n-                    dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName), BUFSIZE));\n+                    dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(\n+                            fileName), BUFSIZE));\n@@ -150,3 +160,3 @@\n-            \/\/ Unknown[] u = Unknown.getUnknownAttributes();\n-            \/\/ for (int i=0; i < u.length; i++)\n-            \/\/ System.err.println(\"WARNING: \" + u[i]);\n+            \/\/Unknown[] u = Unknown.getUnknownAttributes();\n+            \/\/for (int i=0; i < u.length; i++)\n+            \/\/  System.err.println(\"WARNING: \" + u[i]);\n@@ -154,9 +164,9 @@\n-            \/\/ if(file.available() > 0) {\n-            \/\/ int bytes = file.available();\n-            \/\/ byte[] buf = new byte[bytes];\n-            \/\/ file.read(buf);\n-            \/\/ if(!(isZip && (buf.length == 1))) {\n-            \/\/ System.err.println(\"WARNING: Trailing garbage at end of \" + fileName);\n-            \/\/ System.err.println(bytes + \" extra bytes: \" + Utility.toHexString(buf));\n-            \/\/ }\n-            \/\/ }\n+            \/\/      if(file.available() > 0) {\n+            \/\/        int bytes = file.available();\n+            \/\/        byte[] buf = new byte[bytes];\n+            \/\/        file.read(buf);\n+            \/\/        if(!(isZip && (buf.length == 1))) {\n+            \/\/      System.err.println(\"WARNING: Trailing garbage at end of \" + fileName);\n+            \/\/      System.err.println(bytes + \" extra bytes: \" + Utility.toHexString(buf));\n+            \/\/        }\n+            \/\/      }\n@@ -170,2 +180,2 @@\n-                } catch (final IOException ignored) {\n-                    \/\/ ignore close exceptions\n+                } catch (final IOException ioe) {\n+                    \/\/ignore close exceptions\n@@ -178,2 +188,2 @@\n-            } catch (final IOException ignored) {\n-                \/\/ ignore close exceptions\n+            } catch (final IOException ioe) {\n+                \/\/ignore close exceptions\n@@ -183,2 +193,4 @@\n-        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor, accessFlags, constantPool, interfaces, fields, methods, attributes,\n-            isZip ? JavaClass.ZIP : JavaClass.FILE);\n+        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor,\n+                accessFlags, constantPool, interfaces, fields, methods, attributes, isZip\n+                        ? JavaClass.ZIP\n+                        : JavaClass.FILE);\n@@ -187,0 +199,1 @@\n+\n@@ -189,3 +202,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -194,3 +206,3 @@\n-        final int attributesCount = dataInputStream.readUnsignedShort();\n-        attributes = new Attribute[attributesCount];\n-        for (int i = 0; i < attributesCount; i++) {\n+        final int attributes_count = dataInputStream.readUnsignedShort();\n+        attributes = new Attribute[attributes_count];\n+        for (int i = 0; i < attributes_count; i++) {\n@@ -201,0 +213,1 @@\n+\n@@ -203,3 +216,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -209,2 +221,2 @@\n-        \/*\n-         * Interfaces are implicitly abstract, the flag should be set according to the JVM specification.\n+        \/* Interfaces are implicitely abstract, the flag should be set\n+         * according to the JVM specification.\n@@ -215,1 +227,2 @@\n-        if ((accessFlags & Const.ACC_ABSTRACT) != 0 && (accessFlags & Const.ACC_FINAL) != 0) {\n+        if (((accessFlags & Const.ACC_ABSTRACT) != 0)\n+                && ((accessFlags & Const.ACC_FINAL) != 0)) {\n@@ -222,0 +235,1 @@\n+\n@@ -224,3 +238,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -232,0 +245,1 @@\n+\n@@ -234,3 +248,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -239,3 +252,3 @@\n-        final int fieldsCount = dataInputStream.readUnsignedShort();\n-        fields = new Field[fieldsCount];\n-        for (int i = 0; i < fieldsCount; i++) {\n+        final int fields_count = dataInputStream.readUnsignedShort();\n+        fields = new Field[fields_count];\n+        for (int i = 0; i < fields_count; i++) {\n@@ -246,0 +259,1 @@\n+\n@@ -248,4 +262,4 @@\n-     * Checks whether the header of the file is ok. Of course, this has to be the first action on successive file reads.\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * Checks whether the header of the file is ok.\n+     * Of course, this has to be the first action on successive file reads.\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -259,0 +273,1 @@\n+\n@@ -261,3 +276,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -266,3 +280,3 @@\n-        final int interfacesCount = dataInputStream.readUnsignedShort();\n-        interfaces = new int[interfacesCount];\n-        for (int i = 0; i < interfacesCount; i++) {\n+        final int interfaces_count = dataInputStream.readUnsignedShort();\n+        interfaces = new int[interfaces_count];\n+        for (int i = 0; i < interfaces_count; i++) {\n@@ -273,0 +287,1 @@\n+\n@@ -275,3 +290,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -279,4 +293,4 @@\n-    private void readMethods() throws IOException {\n-        final int methodsCount = dataInputStream.readUnsignedShort();\n-        methods = new Method[methodsCount];\n-        for (int i = 0; i < methodsCount; i++) {\n+    private void readMethods() throws IOException, ClassFormatException {\n+        final int methods_count = dataInputStream.readUnsignedShort();\n+        methods = new Method[methods_count];\n+        for (int i = 0; i < methods_count; i++) {\n@@ -287,0 +301,1 @@\n+\n@@ -289,3 +304,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassParser.java","additions":97,"deletions":83,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -26,1 +27,0 @@\n-import java.util.Arrays;\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,3 +31,6 @@\n- * This class represents a chunk of Java byte code contained in a method. It is instantiated by the\n- * <em>Attribute.readAttribute()<\/em> method. A <em>Code<\/em> attribute contains informations about operand stack, local\n- * variables, byte code and the exceptions handled within this method.\n+ * This class represents a chunk of Java byte code contained in a\n+ * method. It is instantiated by the\n+ * <em>Attribute.readAttribute()<\/em> method. A <em>Code<\/em>\n+ * attribute contains informations about operand stack, local\n+ * variables, byte code and the exceptions handled within this\n+ * method.\n@@ -36,2 +38,3 @@\n- * This attribute has attributes itself, namely <em>LineNumberTable<\/em> which is used for debugging purposes and\n- * <em>LocalVariableTable<\/em> which contains information about the local variables.\n+ * This attribute has attributes itself, namely <em>LineNumberTable<\/em> which\n+ * is used for debugging purposes and <em>LocalVariableTable<\/em> which\n+ * contains information about the local variables.\n@@ -39,22 +42,3 @@\n- * <pre>\n- * Code_attribute {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u2 max_stack;\n- *   u2 max_locals;\n- *   u4 code_length;\n- *   u1 code[code_length];\n- *   u2 exception_table_length;\n- *   {\n- *     u2 start_pc;\n- *     u2 end_pc;\n- *     u2 handler_pc;\n- *     u2 catch_type;\n- *   } exception_table[exception_table_length];\n- *   u2 attributes_count;\n- *   attribute_info attributes[attributes_count];\n- * }\n- * <\/pre>\n- * @see Attribute\n- * @see CodeException\n- * @see LineNumberTable\n+ * @see     Attribute\n+ * @see     CodeException\n+ * @see     LineNumberTable\n@@ -62,1 +46,0 @@\n- * @LastModified: Feb 2023\n@@ -66,2 +49,2 @@\n-    private int maxStack; \/\/ Maximum size of stack used by this method \/\/ TODO this could be made final (setter is not used)\n-    private int maxLocals; \/\/ Number of local variables \/\/ TODO this could be made final (setter is not used)\n+    private int maxStack; \/\/ Maximum size of stack used by this method  \/\/ TODO this could be made final (setter is not used)\n+    private int maxLocals; \/\/ Number of local variables  \/\/ TODO this could be made final (setter is not used)\n@@ -72,0 +55,1 @@\n+\n@@ -73,4 +57,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param code The source Code.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -78,3 +60,3 @@\n-    public Code(final Code code) {\n-        this(code.getNameIndex(), code.getLength(), code.getMaxStack(), code.getMaxLocals(), code.getCode(), code.getExceptionTable(), code.getAttributes(),\n-                code.getConstantPool());\n+    public Code(final Code c) {\n+        this(c.getNameIndex(), c.getLength(), c.getMaxStack(), c.getMaxLocals(), c.getCode(), c\n+                .getExceptionTable(), c.getAttributes(), c.getConstantPool());\n@@ -83,0 +65,1 @@\n+\n@@ -84,1 +67,1 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -87,1 +70,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -89,1 +72,2 @@\n-    Code(final int nameIndex, final int length, final DataInput file, final ConstantPool constantPool) throws IOException {\n+    Code(final int name_index, final int length, final DataInput file, final ConstantPool constant_pool)\n+            throws IOException {\n@@ -91,3 +75,4 @@\n-        this(nameIndex, length, file.readUnsignedShort(), file.readUnsignedShort(), (byte[]) null, (CodeException[]) null, (Attribute[]) null, constantPool);\n-        final int codeLength = Args.requireU4(file.readInt(), 1, \"Code length attribute\");\n-        code = new byte[codeLength]; \/\/ Read byte code\n+        this(name_index, length, file.readUnsignedShort(), file.readUnsignedShort(), (byte[]) null,\n+                (CodeException[]) null, (Attribute[]) null, constant_pool);\n+        final int code_length = file.readInt();\n+        code = new byte[code_length]; \/\/ Read byte code\n@@ -95,3 +80,2 @@\n-        \/*\n-         * Read exception table that contains all regions where an exception handler is active, i.e., a try { ... } catch()\n-         * block.\n+        \/* Read exception table that contains all regions where an exception\n+         * handler is active, i.e., a try { ... } catch() block.\n@@ -99,3 +83,3 @@\n-        final int exceptionTableLength = file.readUnsignedShort();\n-        exceptionTable = new CodeException[exceptionTableLength];\n-        for (int i = 0; i < exceptionTableLength; i++) {\n+        final int exception_table_length = file.readUnsignedShort();\n+        exceptionTable = new CodeException[exception_table_length];\n+        for (int i = 0; i < exception_table_length; i++) {\n@@ -104,2 +88,2 @@\n-        \/*\n-         * Read all attributes, currently 'LineNumberTable' and 'LocalVariableTable'\n+        \/* Read all attributes, currently `LineNumberTable' and\n+         * `LocalVariableTable'\n@@ -107,4 +91,4 @@\n-        final int attributesCount = file.readUnsignedShort();\n-        attributes = new Attribute[attributesCount];\n-        for (int i = 0; i < attributesCount; i++) {\n-            attributes[i] = Attribute.readAttribute(file, constantPool);\n+        final int attributes_count = file.readUnsignedShort();\n+        attributes = new Attribute[attributes_count];\n+        for (int i = 0; i < attributes_count; i++) {\n+            attributes[i] = Attribute.readAttribute(file, constant_pool);\n@@ -112,3 +96,3 @@\n-        \/*\n-         * Adjust length, because of setAttributes in this(), s.b. length is incorrect, because it didn't take the internal\n-         * attributes into account yet! Very subtle bug, fixed in 3.1.1.\n+        \/* Adjust length, because of setAttributes in this(), s.b.  length\n+         * is incorrect, because it didn't take the internal attributes\n+         * into account yet! Very subtle bug, fixed in 3.1.1.\n@@ -119,0 +103,1 @@\n+\n@@ -120,1 +105,1 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -127,1 +112,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -129,9 +114,8 @@\n-    public Code(final int nameIndex, final int length, final int maxStack, final int maxLocals, final byte[] code, final CodeException[] exceptionTable,\n-        final Attribute[] attributes, final ConstantPool constantPool) {\n-        super(Const.ATTR_CODE, nameIndex, length, constantPool);\n-        this.maxStack = Args.requireU2(maxStack, \"maxStack\");\n-        this.maxLocals = Args.requireU2(maxLocals, \"maxLocals\");\n-        this.code = code != null ? code : Const.EMPTY_BYTE_ARRAY;\n-        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_CODE_EXCEPTION_ARRAY;\n-        Args.requireU2(this.exceptionTable.length, \"exceptionTable.length\");\n-        this.attributes = attributes != null ? attributes : EMPTY_ARRAY;\n+    public Code(final int name_index, final int length, final int maxStack, final int maxLocals, final byte[] code,\n+            final CodeException[] exceptionTable, final Attribute[] attributes, final ConstantPool constant_pool) {\n+        super(Const.ATTR_CODE, name_index, length, constant_pool);\n+        this.maxStack = maxStack;\n+        this.maxLocals = maxLocals;\n+        this.code = code != null ? code : new byte[0];\n+        this.exceptionTable = exceptionTable != null ? exceptionTable : new CodeException[0];\n+        this.attributes = attributes != null ? attributes : new Attribute[0];\n@@ -141,0 +125,1 @@\n+\n@@ -142,2 +127,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -148,1 +134,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -152,32 +138,0 @@\n-    \/**\n-     * @return the full size of this code attribute, minus its first 6 bytes, including the size of all its contained\n-     *         attributes\n-     *\/\n-    private int calculateLength() {\n-        int len = 0;\n-        if (attributes != null) {\n-            for (final Attribute attribute : attributes) {\n-                len += attribute.getLength() + 6 \/* attribute header size *\/;\n-            }\n-        }\n-        return len + getInternalLength();\n-    }\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\n-     * @param constantPool the constant pool to duplicate\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Code c = (Code) clone();\n-        if (code != null) {\n-            c.code = code.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        c.exceptionTable = new CodeException[exceptionTable.length];\n-        Arrays.setAll(c.exceptionTable, i -> exceptionTable[i].copy());\n-        c.attributes = new Attribute[attributes.length];\n-        Arrays.setAll(c.attributes, i -> attributes[i].copy(constantPool));\n-        return c;\n-    }\n@@ -189,1 +143,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -192,1 +146,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -208,0 +162,1 @@\n+\n@@ -216,25 +171,0 @@\n-    \/**\n-     * @return Actual byte code of the method.\n-     *\/\n-    public byte[] getCode() {\n-        return code;\n-    }\n-\n-    \/**\n-     * @return Table of handled exceptions.\n-     * @see CodeException\n-     *\/\n-    public CodeException[] getExceptionTable() {\n-        return exceptionTable;\n-    }\n-\n-    \/**\n-     * @return the internal length of this code attribute (minus the first 6 bytes) and excluding all its attributes\n-     *\/\n-    private int getInternalLength() {\n-        return 2 \/* maxStack *\/ + 2 \/* maxLocals *\/ + 4 \/* code length *\/\n-            + code.length \/* byte-code *\/\n-            + 2 \/* exception-table length *\/\n-            + 8 * (exceptionTable == null ? 0 : exceptionTable.length) \/* exception table *\/\n-            + 2 \/* attributes count *\/;\n-    }\n@@ -254,0 +184,1 @@\n+\n@@ -266,0 +197,18 @@\n+\n+    \/**\n+     * @return Actual byte code of the method.\n+     *\/\n+    public byte[] getCode() {\n+        return code;\n+    }\n+\n+\n+    \/**\n+     * @return Table of handled exceptions.\n+     * @see CodeException\n+     *\/\n+    public CodeException[] getExceptionTable() {\n+        return exceptionTable;\n+    }\n+\n+\n@@ -273,0 +222,1 @@\n+\n@@ -280,0 +230,29 @@\n+\n+    \/**\n+     * @return the internal length of this code attribute (minus the first 6 bytes)\n+     * and excluding all its attributes\n+     *\/\n+    private int getInternalLength() {\n+        return 2 \/*maxStack*\/+ 2 \/*maxLocals*\/+ 4 \/*code length*\/\n+                + code.length \/*byte-code*\/\n+                + 2 \/*exception-table length*\/\n+                + 8 * (exceptionTable == null ? 0 : exceptionTable.length) \/* exception table *\/\n+                + 2 \/* attributes count *\/;\n+    }\n+\n+\n+    \/**\n+     * @return the full size of this code attribute, minus its first 6 bytes,\n+     * including the size of all its contained attributes\n+     *\/\n+    private int calculateLength() {\n+        int len = 0;\n+        if (attributes != null) {\n+            for (final Attribute attribute : attributes) {\n+                len += attribute.getLength() + 6 \/*attribute header size*\/;\n+            }\n+        }\n+        return len + getInternalLength();\n+    }\n+\n+\n@@ -283,2 +262,2 @@\n-    public void setAttributes(final Attribute[] attributes) {\n-        this.attributes = attributes != null ? attributes : EMPTY_ARRAY;\n+    public void setAttributes( final Attribute[] attributes ) {\n+        this.attributes = attributes != null ? attributes : new Attribute[0];\n@@ -288,0 +267,1 @@\n+\n@@ -291,2 +271,2 @@\n-    public void setCode(final byte[] code) {\n-        this.code = code != null ? code : Const.EMPTY_BYTE_ARRAY;\n+    public void setCode( final byte[] code ) {\n+        this.code = code != null ? code : new byte[0];\n@@ -296,0 +276,1 @@\n+\n@@ -299,2 +280,2 @@\n-    public void setExceptionTable(final CodeException[] exceptionTable) {\n-        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_CODE_EXCEPTION_ARRAY;\n+    public void setExceptionTable( final CodeException[] exceptionTable ) {\n+        this.exceptionTable = exceptionTable != null ? exceptionTable : new CodeException[0];\n@@ -304,0 +285,1 @@\n+\n@@ -307,1 +289,1 @@\n-    public void setMaxLocals(final int maxLocals) {\n+    public void setMaxLocals( final int maxLocals ) {\n@@ -311,0 +293,1 @@\n+\n@@ -314,1 +297,1 @@\n-    public void setMaxStack(final int maxStack) {\n+    public void setMaxStack( final int maxStack ) {\n@@ -318,7 +301,0 @@\n-    \/**\n-     * @return String representation of code chunk.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return toString(true);\n-    }\n@@ -327,3 +303,0 @@\n-     * Converts this object to a String.\n-     *\n-     * @param verbose Provides verbose output when true.\n@@ -332,1 +305,1 @@\n-    public String toString(final boolean verbose) {\n+    public String toString( final boolean verbose ) {\n@@ -334,2 +307,3 @@\n-        buf.append(\"Code(maxStack = \").append(maxStack).append(\", maxLocals = \").append(maxLocals).append(\", code_length = \").append(code.length).append(\")\\n\")\n-            .append(Utility.codeToString(code, super.getConstantPool(), 0, -1, verbose));\n+        buf.append(\"Code(maxStack = \").append(maxStack).append(\", maxLocals = \").append(\n+                maxLocals).append(\", code_length = \").append(code.length).append(\")\\n\").append(\n+                Utility.codeToString(code, super.getConstantPool(), 0, -1, verbose));\n@@ -351,0 +325,34 @@\n+\n+\n+    \/**\n+     * @return String representation of code chunk.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return toString(true);\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\n+     * @param _constant_pool the constant pool to duplicate\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Code c = (Code) clone();\n+        if (code != null) {\n+            c.code = new byte[code.length];\n+            System.arraycopy(code, 0, c.code, 0, code.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        c.exceptionTable = new CodeException[exceptionTable.length];\n+        for (int i = 0; i < exceptionTable.length; i++) {\n+            c.exceptionTable[i] = exceptionTable[i].copy();\n+        }\n+        c.attributes = new Attribute[attributes.length];\n+        for (int i = 0; i < attributes.length; i++) {\n+            c.attributes[i] = attributes[i].copy(_constant_pool);\n+        }\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Code.java","additions":163,"deletions":155,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,2 +30,3 @@\n- * This class represents an entry in the exception table of the <em>Code<\/em> attribute and is used only there. It\n- * contains a range in which a particular exception handler is active.\n+ * This class represents an entry in the exception table of the <em>Code<\/em>\n+ * attribute and is used only there. It contains a range in which a\n+ * particular exception handler is active.\n@@ -34,22 +34,2 @@\n- * <pre>\n- * Code_attribute {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u2 max_stack;\n- *   u2 max_locals;\n- *   u4 code_length;\n- *   u1 code[code_length];\n- *   u2 exception_table_length;\n- *   {\n- *     u2 start_pc;\n- *     u2 end_pc;\n- *     u2 handler_pc;\n- *     u2 catch_type;\n- *   } exception_table[exception_table_length];\n- *   u2 attributes_count;\n- *   attribute_info attributes[attributes_count];\n- * }\n- * <\/pre>\n- *\n- * @see Code\n- * @LastModified: Feb 2023\n+ * @see     Code\n+ * @LastModified: May 2021\n@@ -59,2 +39,4 @@\n-    \/**\n-     * Empty array.\n+    private int startPc; \/\/ Range in the code the exception handler is\n+    private int endPc; \/\/ active. startPc is inclusive, endPc exclusive\n+    private int handlerPc; \/* Starting address of exception handler, i.e.,\n+     * an offset from start of code.\n@@ -62,10 +44,3 @@\n-    static final CodeException[] EMPTY_CODE_EXCEPTION_ARRAY = {};\n-\n-    \/** Range in the code the exception handler. *\/\n-    private int startPc;\n-\n-    \/** active. startPc is inclusive, endPc exclusive. *\/\n-    private int endPc;\n-\n-    \/**\n-     * Starting address of exception handler, i.e., an offset from start of code.\n+    private int catchType; \/* If this is zero the handler catches any\n+     * exception, otherwise it points to the\n+     * exception class which is to be caught.\n@@ -73,1 +48,0 @@\n-    private int handlerPc;\n@@ -75,4 +49,0 @@\n-    \/*\n-     * If this is zero the handler catches any exception, otherwise it points to the exception class which is to be caught.\n-     *\/\n-    private int catchType;\n@@ -81,3 +51,1 @@\n-     * Constructs a new instance from another instance.\n-     *\n-     * @param c Source for copying.\n+     * Initialize from another object.\n@@ -89,0 +57,1 @@\n+\n@@ -90,2 +59,1 @@\n-     * Constructs a new instance from a DataInput.\n-     *\n+     * Construct object from file stream.\n@@ -93,1 +61,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -96,1 +64,2 @@\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort());\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n+                .readUnsignedShort());\n@@ -99,0 +68,1 @@\n+\n@@ -100,3 +70,2 @@\n-     * Constructs a new instance.\n-     *\n-     * @param startPc Range in the code the exception handler is active, startPc is inclusive while\n+     * @param startPc Range in the code the exception handler is active,\n+     * startPc is inclusive while\n@@ -104,3 +73,5 @@\n-     * @param handlerPc Starting address of exception handler, i.e., an offset from start of code.\n-     * @param catchType If zero the handler catches any exception, otherwise it points to the exception class which is to be\n-     *        caught.\n+     * @param handlerPc Starting address of exception handler, i.e.,\n+     * an offset from start of code.\n+     * @param catchType If zero the handler catches any\n+     * exception, otherwise it points to the exception class which is\n+     * to be caught.\n@@ -109,4 +80,4 @@\n-        this.startPc = Args.requireU2(startPc, \"startPc\");\n-        this.endPc = Args.requireU2(endPc, \"endPc\");\n-        this.handlerPc = Args.requireU2(handlerPc, \"handlerPc\");\n-        this.catchType = Args.requireU2(catchType, \"catchType\");\n+        this.startPc = startPc;\n+        this.endPc = endPc;\n+        this.handlerPc = handlerPc;\n+        this.catchType = catchType;\n@@ -115,0 +86,1 @@\n+\n@@ -116,2 +88,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -122,1 +95,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -126,11 +99,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public CodeException copy() {\n-        try {\n-            return (CodeException) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n@@ -139,1 +101,1 @@\n-     * Dumps code exception to file stream in binary format.\n+     * Dump code exception to file stream in binary format.\n@@ -142,1 +104,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -144,1 +106,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -151,0 +113,1 @@\n+\n@@ -152,1 +115,2 @@\n-     * @return 0, if the handler catches any exception, otherwise it points to the exception class which is to be caught.\n+     * @return 0, if the handler catches any exception, otherwise it points to\n+     * the exception class which is to be caught.\n@@ -158,0 +122,1 @@\n+\n@@ -165,0 +130,1 @@\n+\n@@ -172,0 +138,1 @@\n+\n@@ -179,0 +146,1 @@\n+\n@@ -182,1 +150,1 @@\n-    public void setCatchType(final int catchType) {\n+    public void setCatchType( final int catchType ) {\n@@ -186,0 +154,1 @@\n+\n@@ -189,1 +158,1 @@\n-    public void setEndPC(final int endPc) {\n+    public void setEndPC( final int endPc ) {\n@@ -193,0 +162,1 @@\n+\n@@ -196,1 +166,1 @@\n-    public void setHandlerPC(final int handlerPc) { \/\/ TODO unused\n+    public void setHandlerPC( final int handlerPc ) { \/\/ TODO unused\n@@ -200,0 +170,1 @@\n+\n@@ -203,1 +174,1 @@\n-    public void setStartPC(final int startPc) { \/\/ TODO unused\n+    public void setStartPC( final int startPc ) { \/\/ TODO unused\n@@ -207,0 +178,1 @@\n+\n@@ -212,1 +184,2 @@\n-        return \"CodeException(startPc = \" + startPc + \", endPc = \" + endPc + \", handlerPc = \" + handlerPc + \", catchType = \" + catchType + \")\";\n+        return \"CodeException(startPc = \" + startPc + \", endPc = \" + endPc + \", handlerPc = \"\n+                + handlerPc + \", catchType = \" + catchType + \")\";\n@@ -215,3 +188,0 @@\n-    public String toString(final ConstantPool cp) {\n-        return toString(cp, true);\n-    }\n@@ -220,2 +190,0 @@\n-     * @param cp constant pool source.\n-     * @param verbose Output more if true.\n@@ -224,1 +192,1 @@\n-    public String toString(final ConstantPool cp, final boolean verbose) {\n+    public String toString( final ConstantPool cp, final boolean verbose ) {\n@@ -229,1 +197,2 @@\n-            str = Utility.compactClassName(cp.getConstantString(catchType, Const.CONSTANT_Class), false) + (verbose ? \"(\" + catchType + \")\" : \"\");\n+            str = Utility.compactClassName(cp.getConstantString(catchType, Const.CONSTANT_Class), false)\n+                    + (verbose ? \"(\" + catchType + \")\" : \"\");\n@@ -233,0 +202,18 @@\n+\n+\n+    public String toString( final ConstantPool cp ) {\n+        return toString(cp, true);\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public CodeException copy() {\n+        try {\n+            return (CodeException) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/CodeException.java","additions":77,"deletions":90,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -48,0 +48,1 @@\n+\n@@ -49,1 +50,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -55,0 +56,14 @@\n+    \/* In fact this tag is redundant since we can distinguish different\n+     * `Constant' objects by their type, i.e., via `instanceof'. In some\n+     * places we will use the tag for switch()es anyway.\n+     *\n+     * First, we want match the specification as closely as possible. Second we\n+     * need the tag as an index to select the corresponding class name from the\n+     * `CONSTANT_NAMES' array.\n+     *\/\n+    private byte tag;\n+\n+    Constant(final byte tag) {\n+        this.tag = tag;\n+    }\n+\n@@ -56,1 +71,5 @@\n-     * @return Comparison strategy object\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n@@ -58,2 +77,40 @@\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n+    @Override\n+    public abstract void accept( Visitor v );\n+\n+    public abstract void dump( DataOutputStream file ) throws IOException;\n+\n+    \/**\n+     * @return Tag of constant, i.e., its type. No setTag() method to avoid\n+     * confusion.\n+     *\/\n+    public final byte getTag() {\n+        return tag;\n+    }\n+\n+    \/**\n+     * @return String representation.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return Const.getConstantName(tag) + \"[\" + tag + \"]\";\n+    }\n+\n+    \/**\n+     * @return deep copy of this constant\n+     *\/\n+    public Constant copy() {\n+        try {\n+            return (Constant) super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n@@ -114,28 +171,1 @@\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n-    }\n-\n-    \/*\n-     * In fact this tag is redundant since we can distinguish different 'Constant' objects by their type, i.e., via\n-     * 'instanceof'. In some places we will use the tag for switch()es anyway.\n-     *\n-     * First, we want match the specification as closely as possible. Second we need the tag as an index to select the\n-     * corresponding class name from the 'CONSTANT_NAMES' array.\n-     *\/\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected byte tag; \/\/ TODO should be private & final\n-\n-    Constant(final byte tag) {\n-        this.tag = tag;\n-    }\n-\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n+     * @return Comparison strategy object\n@@ -143,10 +173,2 @@\n-    @Override\n-    public abstract void accept(Visitor v);\n-\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n@@ -156,1 +178,1 @@\n-     * @return deep copy of this constant\n+     * @param comparator Comparison strategy object\n@@ -158,7 +180,2 @@\n-    public Constant copy() {\n-        try {\n-            return (Constant) super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n@@ -167,2 +184,0 @@\n-    public abstract void dump(DataOutputStream file) throws IOException;\n-\n@@ -170,1 +185,2 @@\n-     * Returns value as defined by given BCELComparator strategy. By default two Constant objects are said to be equal when\n+     * Returns value as defined by given BCELComparator strategy.\n+     * By default two Constant objects are said to be equal when\n@@ -173,1 +189,1 @@\n-     * @see Object#equals(Object)\n+     * @see java.lang.Object#equals(java.lang.Object)\n@@ -176,1 +192,1 @@\n-    public boolean equals(final Object obj) {\n+    public boolean equals( final Object obj ) {\n@@ -181,9 +197,2 @@\n-     * @return Tag of constant, i.e., its type. No setTag() method to avoid confusion.\n-     *\/\n-    public final byte getTag() {\n-        return tag;\n-    }\n-\n-    \/**\n-     * Returns value as defined by given BCELComparator strategy. By default return the hashcode of the result of\n-     * toString().\n+     * Returns value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the result of toString().\n@@ -191,1 +200,1 @@\n-     * @see Object#hashCode()\n+     * @see java.lang.Object#hashCode()\n@@ -197,8 +206,0 @@\n-\n-    \/**\n-     * @return String representation.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return Const.getConstantName(tag) + \"[\" + tag + \"]\";\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Constant.java","additions":75,"deletions":74,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n- * Abstract super class for Fieldref, Methodref, InterfaceMethodref and InvokeDynamic constants.\n+ * Abstract super class for Fieldref, Methodref, InterfaceMethodref and\n+ *                          InvokeDynamic constants.\n@@ -44,5 +45,1 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int class_index; \/\/ TODO make private (has getter & setter)\n+    private int class_index;\n@@ -50,0 +47,1 @@\n+    private int name_and_type_index;\n@@ -52,1 +50,1 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     * Initialize from another object.\n@@ -54,2 +52,4 @@\n-    @java.lang.Deprecated\n-    protected int name_and_type_index; \/\/ TODO make private (has getter & setter)\n+    public ConstantCP(final ConstantCP c) {\n+        this(c.getTag(), c.getClassIndex(), c.getNameAndTypeIndex());\n+    }\n+\n@@ -60,1 +60,1 @@\n-     * @param tag Constant type tag\n+     * @param tag  Constant type tag\n@@ -62,1 +62,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -68,0 +68,1 @@\n+\n@@ -69,2 +70,2 @@\n-     * @param classIndex Reference to the class containing the field\n-     * @param nameAndTypeIndex and the field signature\n+     * @param class_index Reference to the class containing the field\n+     * @param name_and_type_index and the field signature\n@@ -72,1 +73,1 @@\n-    protected ConstantCP(final byte tag, final int classIndex, final int nameAndTypeIndex) {\n+    protected ConstantCP(final byte tag, final int class_index, final int name_and_type_index) {\n@@ -74,2 +75,2 @@\n-        this.class_index = classIndex;\n-        this.name_and_type_index = nameAndTypeIndex;\n+        this.class_index = class_index;\n+        this.name_and_type_index = name_and_type_index;\n@@ -78,8 +79,0 @@\n-    \/**\n-     * Initialize from another object.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public ConstantCP(final ConstantCP c) {\n-        this(c.getTag(), c.getClassIndex(), c.getNameAndTypeIndex());\n-    }\n@@ -91,1 +84,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -94,1 +87,1 @@\n-    public final void dump(final DataOutputStream file) throws IOException {\n+    public final void dump( final DataOutputStream file ) throws IOException {\n@@ -100,6 +93,0 @@\n-    \/**\n-     * @return Class this field belongs to.\n-     *\/\n-    public String getClass(final ConstantPool cp) {\n-        return cp.constantToString(class_index, Const.CONSTANT_Class);\n-    }\n@@ -114,0 +101,9 @@\n+\n+    \/**\n+     * @param class_index points to Constant_class\n+     *\/\n+    public final void setClassIndex( final int class_index ) {\n+        this.class_index = class_index;\n+    }\n+\n+\n@@ -121,0 +117,1 @@\n+\n@@ -122,1 +119,1 @@\n-     * @param classIndex points to Constant_class\n+     * @param name_and_type_index points to Constant_NameAndType\n@@ -124,2 +121,2 @@\n-    public final void setClassIndex(final int classIndex) {\n-        this.class_index = classIndex;\n+    public final void setNameAndTypeIndex( final int name_and_type_index ) {\n+        this.name_and_type_index = name_and_type_index;\n@@ -128,0 +125,1 @@\n+\n@@ -129,1 +127,1 @@\n-     * @param nameAndTypeIndex points to Constant_NameAndType\n+     * @return Class this field belongs to.\n@@ -131,2 +129,2 @@\n-    public final void setNameAndTypeIndex(final int nameAndTypeIndex) {\n-        this.name_and_type_index = nameAndTypeIndex;\n+    public String getClass( final ConstantPool cp ) {\n+        return cp.constantToString(class_index, Const.CONSTANT_Class);\n@@ -135,0 +133,1 @@\n+\n@@ -138,1 +137,1 @@\n-     *         not final as ConstantInvokeDynamic needs to modify\n+     * not final as ConstantInvokeDynamic needs to modify\n@@ -142,1 +141,2 @@\n-        return super.toString() + \"(class_index = \" + class_index + \", name_and_type_index = \" + name_and_type_index + \")\";\n+        return super.toString() + \"(class_index = \" + class_index + \", name_and_type_index = \"\n+                + name_and_type_index + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantCP.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a (external) class.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a (external) class.\n@@ -33,1 +34,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -39,0 +40,1 @@\n+\n@@ -41,2 +43,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +48,1 @@\n+\n@@ -58,0 +59,1 @@\n+\n@@ -59,1 +61,2 @@\n-     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n+     * @param nameIndex Name index in constant pool.  Should refer to a\n+     * ConstantUtf8.\n@@ -66,0 +69,1 @@\n+\n@@ -67,2 +71,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +78,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +82,1 @@\n+\n@@ -84,1 +90,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,14 +95,0 @@\n-    \/**\n-     * @return dereferenced string\n-     *\/\n-    public String getBytes(final ConstantPool cp) {\n-        return (String) getConstantValue(cp);\n-    }\n-\n-    \/**\n-     * @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return cp.getConstantUtf8(nameIndex).getBytes();\n-    }\n@@ -111,0 +103,1 @@\n+\n@@ -114,1 +107,1 @@\n-    public void setNameIndex(final int nameIndex) {\n+    public void setNameIndex( final int nameIndex ) {\n@@ -118,0 +111,17 @@\n+\n+    \/** @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n+    }\n+\n+\n+    \/** @return dereferenced string\n+     *\/\n+    public String getBytes( final ConstantPool cp ) {\n+        return (String) getConstantValue(cp);\n+    }\n+\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantClass.java","additions":34,"deletions":24,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a Double object.\n+ * This class is derived from the abstract  {@link Constant}\n+ * and represents a reference to a Double object.\n@@ -39,0 +40,10 @@\n+\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantDouble(final double bytes) {\n+        super(Const.CONSTANT_Double);\n+        this.bytes = bytes;\n+    }\n+\n+\n@@ -41,2 +52,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +57,1 @@\n+\n@@ -52,1 +62,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -58,7 +68,0 @@\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantDouble(final double bytes) {\n-        super(Const.CONSTANT_Double);\n-        this.bytes = bytes;\n-    }\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,0 +94,1 @@\n+\n@@ -96,7 +102,0 @@\n-    \/**\n-     * @return Double object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return Double.valueOf(bytes);\n-    }\n@@ -107,1 +106,1 @@\n-    public void setBytes(final double bytes) {\n+    public void setBytes( final double bytes ) {\n@@ -111,0 +110,1 @@\n+\n@@ -118,0 +118,8 @@\n+\n+\n+    \/** @return Double object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        return bytes;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantDouble.java","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a dynamically computed\n- * constant.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a dynamically computed constant.\n@@ -33,3 +33,3 @@\n- * @see Constant\n- * @see <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\"> Change request for JEP\n- *      309<\/a>\n+ * @see     Constant\n+ * @see  <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\">\n+ * Change request for JEP 309<\/a>\n@@ -42,2 +42,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -54,1 +52,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -61,2 +59,2 @@\n-    public ConstantDynamic(final int bootstrapMethodAttrIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_Dynamic, bootstrapMethodAttrIndex, nameAndTypeIndex);\n+    public ConstantDynamic(final int bootstrap_method_attr_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_Dynamic, bootstrap_method_attr_index, name_and_type_index);\n@@ -67,2 +65,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -80,1 +79,2 @@\n-     *         Note that this method is a functional duplicate of getClassIndex for use by ConstantInvokeDynamic.\n+     * Note that this method is a functional duplicate of getClassIndex\n+     * for use by ConstantInvokeDynamic.\n@@ -84,1 +84,1 @@\n-        return super.getClassIndex(); \/\/ AKA bootstrap_method_attr_index\n+        return super.getClassIndex();  \/\/ AKA bootstrap_method_attr_index\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantDynamic.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -36,2 +37,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -43,0 +42,1 @@\n+\n@@ -47,1 +47,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -53,0 +53,1 @@\n+\n@@ -54,2 +55,2 @@\n-     * @param classIndex Reference to the class containing the Field\n-     * @param nameAndTypeIndex and the Field signature\n+     * @param class_index Reference to the class containing the Field\n+     * @param name_and_type_index and the Field signature\n@@ -57,2 +58,2 @@\n-    public ConstantFieldref(final int classIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_Fieldref, classIndex, nameAndTypeIndex);\n+    public ConstantFieldref(final int class_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_Fieldref, class_index, name_and_type_index);\n@@ -61,0 +62,1 @@\n+\n@@ -62,2 +64,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of Fields, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of Fields,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -68,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantFieldref.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a float object.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a float object.\n@@ -39,0 +40,1 @@\n+\n@@ -40,4 +42,11 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * @param bytes Data\n+     *\/\n+    public ConstantFloat(final float bytes) {\n+        super(Const.CONSTANT_Float);\n+        this.bytes = bytes;\n+    }\n+\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -49,0 +58,1 @@\n+\n@@ -53,1 +63,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -59,7 +69,0 @@\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantFloat(final float bytes) {\n-        super(Const.CONSTANT_Float);\n-        this.bytes = bytes;\n-    }\n@@ -68,2 +71,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -74,1 +78,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -78,0 +82,1 @@\n+\n@@ -82,1 +87,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -85,1 +90,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -90,0 +95,1 @@\n+\n@@ -97,7 +103,0 @@\n-    \/**\n-     * @return Float object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return Float.valueOf(bytes);\n-    }\n@@ -108,1 +107,1 @@\n-    public void setBytes(final float bytes) {\n+    public void setBytes( final float bytes ) {\n@@ -112,0 +111,1 @@\n+\n@@ -119,0 +119,8 @@\n+\n+\n+    \/** @return Float object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        return bytes;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantFloat.java","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to an int object.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to an int object.\n@@ -39,0 +40,10 @@\n+\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantInteger(final int bytes) {\n+        super(Const.CONSTANT_Integer);\n+        this.bytes = bytes;\n+    }\n+\n+\n@@ -41,2 +52,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +57,1 @@\n+\n@@ -52,1 +62,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -58,7 +68,0 @@\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantInteger(final int bytes) {\n-        super(Const.CONSTANT_Integer);\n-        this.bytes = bytes;\n-    }\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,0 +94,1 @@\n+\n@@ -96,7 +102,0 @@\n-    \/**\n-     * @return Integer object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return Integer.valueOf(bytes);\n-    }\n@@ -107,1 +106,1 @@\n-    public void setBytes(final int bytes) {\n+    public void setBytes( final int bytes ) {\n@@ -111,0 +110,1 @@\n+\n@@ -118,0 +118,8 @@\n+\n+\n+    \/** @return Integer object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        return Integer.valueOf(bytes);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInteger.java","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -36,2 +37,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -43,0 +42,1 @@\n+\n@@ -47,1 +47,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -53,0 +53,1 @@\n+\n@@ -54,2 +55,2 @@\n-     * @param classIndex Reference to the class containing the method\n-     * @param nameAndTypeIndex and the method signature\n+     * @param class_index Reference to the class containing the method\n+     * @param name_and_type_index and the method signature\n@@ -57,2 +58,2 @@\n-    public ConstantInterfaceMethodref(final int classIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_InterfaceMethodref, classIndex, nameAndTypeIndex);\n+    public ConstantInterfaceMethodref(final int class_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_InterfaceMethodref, class_index, name_and_type_index);\n@@ -61,0 +62,1 @@\n+\n@@ -62,2 +64,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -68,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInterfaceMethodref.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a invoke dynamic.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a invoke dynamic.\n@@ -32,3 +33,3 @@\n- * @see Constant\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\"> The\n- *      CONSTANT_InvokeDynamic_info Structure in The Java Virtual Machine Specification<\/a>\n+ * @see     Constant\n+ * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\">\n+ * The CONSTANT_InvokeDynamic_info Structure in The Java Virtual Machine Specification<\/a>\n@@ -41,2 +42,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +47,1 @@\n+\n@@ -52,1 +52,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -55,1 +55,1 @@\n-        this(file.readUnsignedShort(), file.readUnsignedShort());\n+        this(file.readShort(), file.readShort());\n@@ -58,2 +58,3 @@\n-    public ConstantInvokeDynamic(final int bootstrapMethodAttrIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_InvokeDynamic, bootstrapMethodAttrIndex, nameAndTypeIndex);\n+\n+    public ConstantInvokeDynamic(final int bootstrap_method_attr_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_InvokeDynamic, bootstrap_method_attr_index, name_and_type_index);\n@@ -62,0 +63,1 @@\n+\n@@ -63,2 +65,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -69,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -76,1 +79,2 @@\n-     *         Note that this method is a functional duplicate of getClassIndex for use by ConstantInvokeDynamic.\n+     * Note that this method is a functional duplicate of getClassIndex\n+     * for use by ConstantInvokeDynamic.\n@@ -80,1 +84,1 @@\n-        return super.getClassIndex(); \/\/ AKA bootstrap_method_attr_index\n+        return super.getClassIndex();  \/\/ AKA bootstrap_method_attr_index\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInvokeDynamic.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a long object.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a long object.\n@@ -39,0 +40,10 @@\n+\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantLong(final long bytes) {\n+        super(Const.CONSTANT_Long);\n+        this.bytes = bytes;\n+    }\n+\n+\n@@ -41,2 +52,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +57,1 @@\n+\n@@ -52,1 +62,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -58,7 +68,0 @@\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantLong(final long bytes) {\n-        super(Const.CONSTANT_Long);\n-        this.bytes = bytes;\n-    }\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,0 +94,1 @@\n+\n@@ -96,7 +102,0 @@\n-    \/**\n-     * @return Long object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return Long.valueOf(bytes);\n-    }\n@@ -107,1 +106,1 @@\n-    public void setBytes(final long bytes) {\n+    public void setBytes( final long bytes ) {\n@@ -111,0 +110,1 @@\n+\n@@ -118,0 +118,8 @@\n+\n+\n+    \/** @return Long object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        return bytes;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantLong.java","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a method handle.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a method handle.\n@@ -33,1 +34,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -41,0 +42,1 @@\n+\n@@ -43,2 +45,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -50,0 +50,1 @@\n+\n@@ -54,1 +55,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -60,1 +61,2 @@\n-    public ConstantMethodHandle(final int referenceKind, final int referenceIndex) {\n+\n+    public ConstantMethodHandle(final int reference_kind, final int reference_index) {\n@@ -62,2 +64,2 @@\n-        this.referenceKind = referenceKind;\n-        this.referenceIndex = referenceIndex;\n+        this.referenceKind = reference_kind;\n+        this.referenceIndex = reference_index;\n@@ -66,0 +68,1 @@\n+\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -90,3 +95,0 @@\n-    public int getReferenceIndex() {\n-        return referenceIndex;\n-    }\n@@ -98,2 +100,8 @@\n-    public void setReferenceIndex(final int referenceIndex) {\n-        this.referenceIndex = referenceIndex;\n+\n+    public void setReferenceKind(final int reference_kind) {\n+        this.referenceKind = reference_kind;\n+    }\n+\n+\n+    public int getReferenceIndex() {\n+        return referenceIndex;\n@@ -102,2 +110,3 @@\n-    public void setReferenceKind(final int referenceKind) {\n-        this.referenceKind = referenceKind;\n+\n+    public void setReferenceIndex(final int reference_index) {\n+        this.referenceIndex = reference_index;\n@@ -106,0 +115,1 @@\n+\n@@ -111,1 +121,2 @@\n-        return super.toString() + \"(referenceKind = \" + referenceKind + \", referenceIndex = \" + referenceIndex + \")\";\n+        return super.toString() + \"(referenceKind = \" + referenceKind +\n+                \", referenceIndex = \" + referenceIndex + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodHandle.java","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a method type.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a method type.\n@@ -33,1 +34,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -40,0 +41,1 @@\n+\n@@ -42,2 +44,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -49,0 +49,1 @@\n+\n@@ -53,1 +54,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -59,1 +60,2 @@\n-    public ConstantMethodType(final int descriptorIndex) {\n+\n+    public ConstantMethodType(final int descriptor_index) {\n@@ -61,1 +63,1 @@\n-        this.descriptorIndex = descriptorIndex;\n+        this.descriptorIndex = descriptor_index;\n@@ -64,0 +66,1 @@\n+\n@@ -65,2 +68,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -71,1 +75,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -75,0 +79,1 @@\n+\n@@ -79,1 +84,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -82,1 +87,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -87,0 +92,1 @@\n+\n@@ -91,2 +97,3 @@\n-    public void setDescriptorIndex(final int descriptorIndex) {\n-        this.descriptorIndex = descriptorIndex;\n+\n+    public void setDescriptorIndex(final int descriptor_index) {\n+        this.descriptorIndex = descriptor_index;\n@@ -95,0 +102,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodType.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -36,2 +37,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -43,0 +42,1 @@\n+\n@@ -47,1 +47,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -53,0 +53,1 @@\n+\n@@ -54,2 +55,2 @@\n-     * @param classIndex Reference to the class containing the method\n-     * @param nameAndTypeIndex and the method signature\n+     * @param class_index Reference to the class containing the method\n+     * @param name_and_type_index and the method signature\n@@ -57,2 +58,2 @@\n-    public ConstantMethodref(final int classIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_Methodref, classIndex, nameAndTypeIndex);\n+    public ConstantMethodref(final int class_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_Methodref, class_index, name_and_type_index);\n@@ -61,0 +62,1 @@\n+\n@@ -62,2 +64,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -68,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodref.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a module.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a module.\n@@ -33,3 +34,1 @@\n- * <p>\n- * Note: Early access Java 9 support- currently subject to change\n- * <\/p>\n+ * <p>Note: Early access Java 9 support- currently subject to change<\/p>\n@@ -37,1 +36,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -44,0 +43,1 @@\n+\n@@ -46,2 +46,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -53,0 +51,1 @@\n+\n@@ -57,1 +56,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -63,0 +62,1 @@\n+\n@@ -64,1 +64,2 @@\n-     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n+     * @param nameIndex Name index in constant pool.  Should refer to a\n+     * ConstantUtf8.\n@@ -71,0 +72,1 @@\n+\n@@ -72,2 +74,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -78,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -82,0 +85,1 @@\n+\n@@ -86,1 +90,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -89,1 +93,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -94,14 +98,0 @@\n-    \/**\n-     * @return dereferenced string\n-     *\/\n-    public String getBytes(final ConstantPool cp) {\n-        return (String) getConstantValue(cp);\n-    }\n-\n-    \/**\n-     * @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return cp.getConstantUtf8(nameIndex).getBytes();\n-    }\n@@ -116,0 +106,1 @@\n+\n@@ -119,1 +110,1 @@\n-    public void setNameIndex(final int nameIndex) {\n+    public void setNameIndex( final int nameIndex ) {\n@@ -123,0 +114,17 @@\n+\n+    \/** @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n+    }\n+\n+\n+    \/** @return dereferenced string\n+     *\/\n+    public String getBytes( final ConstantPool cp ) {\n+        return (String) getConstantValue(cp);\n+    }\n+\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantModule.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to the name and signature of a\n- * field or method.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to the name and signature\n+ * of a field or method.\n@@ -34,1 +35,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -41,0 +42,1 @@\n+\n@@ -43,2 +45,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -50,0 +50,1 @@\n+\n@@ -54,1 +55,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -60,0 +61,1 @@\n+\n@@ -70,0 +72,1 @@\n+\n@@ -71,2 +74,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -81,0 +85,1 @@\n+\n@@ -85,1 +90,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -88,1 +93,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -94,6 +99,0 @@\n-    \/**\n-     * @return name\n-     *\/\n-    public String getName(final ConstantPool cp) {\n-        return cp.constantToString(getNameIndex(), Const.CONSTANT_Utf8);\n-    }\n@@ -108,2 +107,2 @@\n-    \/**\n-     * @return signature\n+\n+    \/** @return name\n@@ -111,2 +110,2 @@\n-    public String getSignature(final ConstantPool cp) {\n-        return cp.constantToString(getSignatureIndex(), Const.CONSTANT_Utf8);\n+    public String getName( final ConstantPool cp ) {\n+        return cp.constantToString(getNameIndex(), Const.CONSTANT_Utf8);\n@@ -115,0 +114,1 @@\n+\n@@ -122,0 +122,8 @@\n+\n+    \/** @return signature\n+     *\/\n+    public String getSignature( final ConstantPool cp ) {\n+        return cp.constantToString(getSignatureIndex(), Const.CONSTANT_Utf8);\n+    }\n+\n+\n@@ -125,1 +133,1 @@\n-    public void setNameIndex(final int nameIndex) {\n+    public void setNameIndex( final int nameIndex ) {\n@@ -129,0 +137,1 @@\n+\n@@ -132,1 +141,1 @@\n-    public void setSignatureIndex(final int signatureIndex) {\n+    public void setSignatureIndex( final int signatureIndex ) {\n@@ -136,0 +145,1 @@\n+\n@@ -141,1 +151,2 @@\n-        return super.toString() + \"(nameIndex = \" + nameIndex + \", signatureIndex = \" + signatureIndex + \")\";\n+        return super.toString() + \"(nameIndex = \" + nameIndex + \", signatureIndex = \"\n+                + signatureIndex + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantNameAndType.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * This interface denotes those constants that have a \"natural\" value, such as ConstantLong, ConstantString, etc..\n+ * This interface denotes those constants that have a \"natural\" value,\n+ * such as ConstantLong, ConstantString, etc..\n@@ -27,1 +28,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -31,2 +32,1 @@\n-    \/**\n-     * @return object representing the constant, e.g., Long for ConstantLong\n+    \/** @return object representing the constant, e.g., Long for ConstantLong\n@@ -34,1 +34,1 @@\n-    Object getConstantValue(ConstantPool cp);\n+    Object getConstantValue( ConstantPool cp );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantObject.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a package.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a package.\n@@ -33,3 +34,1 @@\n- * <p>\n- * Note: Early access Java 9 support- currently subject to change\n- * <\/p>\n+ * <p>Note: Early access Java 9 support- currently subject to change<\/p>\n@@ -37,1 +36,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -44,0 +43,1 @@\n+\n@@ -46,2 +46,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -53,0 +51,1 @@\n+\n@@ -57,1 +56,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -63,0 +62,1 @@\n+\n@@ -64,1 +64,2 @@\n-     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n+     * @param nameIndex Name index in constant pool.  Should refer to a\n+     * ConstantUtf8.\n@@ -71,0 +72,1 @@\n+\n@@ -72,2 +74,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -78,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -82,0 +85,1 @@\n+\n@@ -86,1 +90,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -89,1 +93,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -94,14 +98,0 @@\n-    \/**\n-     * @return dereferenced string\n-     *\/\n-    public String getBytes(final ConstantPool cp) {\n-        return (String) getConstantValue(cp);\n-    }\n-\n-    \/**\n-     * @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return cp.getConstantUtf8(nameIndex).getBytes();\n-    }\n@@ -116,0 +106,1 @@\n+\n@@ -119,1 +110,1 @@\n-    public void setNameIndex(final int nameIndex) {\n+    public void setNameIndex( final int nameIndex ) {\n@@ -123,0 +114,17 @@\n+\n+    \/** @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n+    }\n+\n+\n+    \/** @return dereferenced string\n+     *\/\n+    public String getBytes( final ConstantPool cp ) {\n+        return (String) getConstantValue(cp);\n+    }\n+\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantPackage.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n@@ -30,0 +28,1 @@\n+import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;\n@@ -32,9 +31,6 @@\n- * This class represents the constant pool, i.e., a table of constants, of a parsed classfile. It may contain null references, due to the JVM specification that\n- * skips an entry after an 8-byte constant (double, long) entry. Those interested in generating constant pools programmatically should see\n- * <a href=\"..\/generic\/ConstantPoolGen.html\"> ConstantPoolGen<\/a>.\n- *\n- * @see Constant\n- * @see com.sun.org.apache.bcel.internal.generic.ConstantPoolGen\n- * @LastModified: Feb 2023\n- *\/\n-public class ConstantPool implements Cloneable, Node, Iterable<Constant> {\n+ * This class represents the constant pool, i.e., a table of constants, of\n+ * a parsed classfile. It may contain null references, due to the JVM\n+ * specification that skips an entry after an 8-byte constant (double,\n+ * long) entry.  Those interested in generating constant pools\n+ * programatically should see <a href=\"..\/generic\/ConstantPoolGen.html\">\n+ * ConstantPoolGen<\/a>.\n@@ -42,27 +38,5 @@\n-    private static String escape(final String str) {\n-        final int len = str.length();\n-        final StringBuilder buf = new StringBuilder(len + 5);\n-        final char[] ch = str.toCharArray();\n-        for (int i = 0; i < len; i++) {\n-            switch (ch[i]) {\n-            case '\\n':\n-                buf.append(\"\\\\n\");\n-                break;\n-            case '\\r':\n-                buf.append(\"\\\\r\");\n-                break;\n-            case '\\t':\n-                buf.append(\"\\\\t\");\n-                break;\n-            case '\\b':\n-                buf.append(\"\\\\b\");\n-                break;\n-            case '\"':\n-                buf.append(\"\\\\\\\"\");\n-                break;\n-            default:\n-                buf.append(ch[i]);\n-            }\n-        }\n-        return buf.toString();\n-    }\n+ * @see     Constant\n+ * @see     com.sun.org.apache.bcel.internal.generic.ConstantPoolGen\n+ * @LastModified: June 2022\n+ *\/\n+public class ConstantPool implements Cloneable, Node {\n@@ -83,1 +57,2 @@\n-     * @throws IOException if problem in readUnsignedShort or readConstant\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -85,1 +60,1 @@\n-    public ConstantPool(final DataInput input) throws IOException {\n+    public ConstantPool(final DataInput input) throws IOException, ClassFormatException {\n@@ -87,4 +62,4 @@\n-        final int constantPoolCount = input.readUnsignedShort();\n-        constantPool = new Constant[constantPoolCount];\n-        \/*\n-         * constantPool[0] is unused by the compiler and may be used freely by the implementation.\n+        final int constant_pool_count = input.readUnsignedShort();\n+        constantPool = new Constant[constant_pool_count];\n+        \/* constantPool[0] is unused by the compiler and may be used freely\n+         * by the implementation.\n@@ -92,1 +67,1 @@\n-        for (int i = 1; i < constantPoolCount; i++) {\n+        for (int i = 1; i < constant_pool_count; i++) {\n@@ -94,3 +69,4 @@\n-            \/*\n-             * Quote from the JVM specification: \"All eight byte constants take up two spots in the constant pool. If this is the n'th byte in the constant\n-             * pool, then the next item will be numbered n+2\"\n+            \/* Quote from the JVM specification:\n+             * \"All eight byte constants take up two spots in the constant pool.\n+             * If this is the n'th byte in the constant pool, then the next item\n+             * will be numbered n+2\"\n@@ -101,1 +77,1 @@\n-            if (tag == Const.CONSTANT_Double || tag == Const.CONSTANT_Long) {\n+            if ((tag == Const.CONSTANT_Double) || (tag == Const.CONSTANT_Long)) {\n@@ -108,2 +84,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e., the hierarchy of methods, fields,\n-     * attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -114,1 +91,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -121,1 +98,1 @@\n-     * @param c Constant to be printed\n+     * @param  c Constant to be printed\n@@ -123,1 +100,0 @@\n-     * @throws IllegalArgumentException if c is unknown constant type\n@@ -125,1 +101,1 @@\n-    public String constantToString(Constant c) throws IllegalArgumentException {\n+    public String constantToString( Constant c ) throws ClassFormatException {\n@@ -130,66 +106,68 @@\n-        case Const.CONSTANT_Class:\n-            i = ((ConstantClass) c).getNameIndex();\n-            c = getConstantUtf8(i);\n-            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-            break;\n-        case Const.CONSTANT_String:\n-            i = ((ConstantString) c).getStringIndex();\n-            c = getConstantUtf8(i);\n-            str = \"\\\"\" + escape(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n-            break;\n-        case Const.CONSTANT_Utf8:\n-            str = ((ConstantUtf8) c).getBytes();\n-            break;\n-        case Const.CONSTANT_Double:\n-            str = String.valueOf(((ConstantDouble) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Float:\n-            str = String.valueOf(((ConstantFloat) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Long:\n-            str = String.valueOf(((ConstantLong) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Integer:\n-            str = String.valueOf(((ConstantInteger) c).getBytes());\n-            break;\n-        case Const.CONSTANT_NameAndType:\n-            str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + \" \"\n-                    + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);\n-            break;\n-        case Const.CONSTANT_InterfaceMethodref:\n-        case Const.CONSTANT_Methodref:\n-        case Const.CONSTANT_Fieldref:\n-            str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + \".\"\n-                    + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n-            break;\n-        case Const.CONSTANT_MethodHandle:\n-            \/\/ Note that the ReferenceIndex may point to a Fieldref, Methodref or\n-            \/\/ InterfaceMethodref - so we need to peek ahead to get the actual type.\n-            final ConstantMethodHandle cmh = (ConstantMethodHandle) c;\n-            str = Const.getMethodHandleName(cmh.getReferenceKind()) + \" \"\n-                    + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());\n-            break;\n-        case Const.CONSTANT_MethodType:\n-            final ConstantMethodType cmt = (ConstantMethodType) c;\n-            str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);\n-            break;\n-        case Const.CONSTANT_InvokeDynamic:\n-            final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;\n-            str = cid.getBootstrapMethodAttrIndex() + \":\" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n-            break;\n-        case Const.CONSTANT_Dynamic:\n-            final ConstantDynamic cd = (ConstantDynamic) c;\n-            str = cd.getBootstrapMethodAttrIndex() + \":\" + constantToString(cd.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n-            break;\n-        case Const.CONSTANT_Module:\n-            i = ((ConstantModule) c).getNameIndex();\n-            c = getConstantUtf8(i);\n-            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-            break;\n-        case Const.CONSTANT_Package:\n-            i = ((ConstantPackage) c).getNameIndex();\n-            c = getConstantUtf8(i);\n-            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-            break;\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown constant type \" + tag);\n+            case Const.CONSTANT_Class:\n+                i = ((ConstantClass) c).getNameIndex();\n+                c = getConstant(i, Const.CONSTANT_Utf8);\n+                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+                break;\n+            case Const.CONSTANT_String:\n+                i = ((ConstantString) c).getStringIndex();\n+                c = getConstant(i, Const.CONSTANT_Utf8);\n+                str = \"\\\"\" + escape(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n+                break;\n+            case Const.CONSTANT_Utf8:\n+                str = ((ConstantUtf8) c).getBytes();\n+                break;\n+            case Const.CONSTANT_Double:\n+                str = String.valueOf(((ConstantDouble) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Float:\n+                str = String.valueOf(((ConstantFloat) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Long:\n+                str = String.valueOf(((ConstantLong) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Integer:\n+                str = String.valueOf(((ConstantInteger) c).getBytes());\n+                break;\n+            case Const.CONSTANT_NameAndType:\n+                str = constantToString(((ConstantNameAndType) c).getNameIndex(),\n+                        Const.CONSTANT_Utf8)\n+                        + \" \" + constantToString(((ConstantNameAndType) c).getSignatureIndex(),\n+                        Const.CONSTANT_Utf8);\n+                break;\n+            case Const.CONSTANT_InterfaceMethodref:\n+            case Const.CONSTANT_Methodref:\n+            case Const.CONSTANT_Fieldref:\n+                str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class)\n+                        + \".\" + constantToString(((ConstantCP) c).getNameAndTypeIndex(),\n+                        Const.CONSTANT_NameAndType);\n+                break;\n+            case Const.CONSTANT_MethodHandle:\n+                \/\/ Note that the ReferenceIndex may point to a Fieldref, Methodref or\n+                \/\/ InterfaceMethodref - so we need to peek ahead to get the actual type.\n+                final ConstantMethodHandle cmh = (ConstantMethodHandle) c;\n+                str = Const.getMethodHandleName(cmh.getReferenceKind())\n+                        + \" \" + constantToString(cmh.getReferenceIndex(),\n+                        getConstant(cmh.getReferenceIndex()).getTag());\n+                break;\n+            case Const.CONSTANT_MethodType:\n+                final ConstantMethodType cmt = (ConstantMethodType) c;\n+                str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);\n+                break;\n+            case Const.CONSTANT_InvokeDynamic:\n+                final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;\n+                str = cid.getBootstrapMethodAttrIndex()\n+                        + \":\" + constantToString(cid.getNameAndTypeIndex(),\n+                        Const.CONSTANT_NameAndType);\n+                break;\n+            case Const.CONSTANT_Module:\n+                i = ((ConstantModule) c).getNameIndex();\n+                c = getConstant(i, Const.CONSTANT_Utf8);\n+                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+                break;\n+            case Const.CONSTANT_Package:\n+                i = ((ConstantPackage) c).getNameIndex();\n+                c = getConstant(i, Const.CONSTANT_Utf8);\n+                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+                break;\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown constant type \" + tag);\n@@ -200,9 +178,26 @@\n-    \/**\n-     * Retrieves constant at 'index' from constant pool and resolve it to a string representation.\n-     *\n-     * @param index of constant in constant pool\n-     * @param tag   expected type\n-     * @return String representation\n-     *\/\n-    public String constantToString(final int index, final byte tag) {\n-        return constantToString(getConstant(index, tag));\n+    private static String escape( final String str ) {\n+        final int len = str.length();\n+        final StringBuilder buf = new StringBuilder(len + 5);\n+        final char[] ch = str.toCharArray();\n+        for (int i = 0; i < len; i++) {\n+            switch (ch[i]) {\n+                case '\\n':\n+                    buf.append(\"\\\\n\");\n+                    break;\n+                case '\\r':\n+                    buf.append(\"\\\\r\");\n+                    break;\n+                case '\\t':\n+                    buf.append(\"\\\\t\");\n+                    break;\n+                case '\\b':\n+                    buf.append(\"\\\\b\");\n+                    break;\n+                case '\"':\n+                    buf.append(\"\\\\\\\"\");\n+                    break;\n+                default:\n+                    buf.append(ch[i]);\n+            }\n+        }\n+        return buf.toString();\n@@ -212,1 +207,6 @@\n-     * @return deep copy of this constant pool\n+     * Retrieves constant at `index' from constant pool and resolve it to\n+     * a string representation.\n+     *\n+     * @param  index of constant in constant pool\n+     * @param  tag expected type\n+     * @return String representation\n@@ -214,14 +214,3 @@\n-    public ConstantPool copy() {\n-        ConstantPool c = null;\n-        try {\n-            c = (ConstantPool) clone();\n-            c.constantPool = new Constant[constantPool.length];\n-            for (int i = 1; i < constantPool.length; i++) {\n-                if (constantPool[i] != null) {\n-                    c.constantPool[i] = constantPool[i].copy();\n-                }\n-            }\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return c;\n+    public String constantToString( final int index, final byte tag ) throws ClassFormatException {\n+        final Constant c = getConstant(index, tag);\n+        return constantToString(c);\n@@ -234,1 +223,1 @@\n-     * @throws IOException if problem in writeShort or dump\n+     * @throws IOException\n@@ -236,1 +225,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -241,2 +230,3 @@\n-         *\/\n-        final int size = Math.min(constantPool.length, Const.MAX_CP_ENTRIES);\n+        *\/\n+        int size = constantPool.length < ConstantPoolGen.CONSTANT_POOL_SIZE ?\n+                constantPool.length : ConstantPoolGen.CONSTANT_POOL_SIZE;\n@@ -255,15 +245,1 @@\n-     * @param index Index in constant pool\n-     * @return Constant value\n-     * @see Constant\n-     * @throws ClassFormatException if index is invalid\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public <T extends Constant> T getConstant(final int index) throws ClassFormatException {\n-        return (T) getConstant(index, Constant.class);\n-    }\n-\n-    \/**\n-     * Gets constant from constant pool and check whether it has the expected type.\n-     *\n-     * @param index Index in constant pool\n-     * @param tag   Tag of expected constant, i.e., its type\n+     * @param  index Index in constant pool\n@@ -271,2 +247,1 @@\n-     * @see Constant\n-     * @throws ClassFormatException if constant type does not match tag\n+     * @see    Constant\n@@ -274,19 +249,4 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public <T extends Constant> T getConstant(final int index, final byte tag) throws ClassFormatException {\n-        return (T) getConstant(index, tag, Constant.class);\n-    }\n-\n-    \/**\n-     * Gets constant from constant pool and check whether it has the expected type.\n-     *\n-     * @param index Index in constant pool\n-     * @param tag   Tag of expected constant, i.e., its type\n-     * @return Constant value\n-     * @see Constant\n-     * @throws ClassFormatException if constant type does not match tag\n-     * @since 6.6.0\n-     *\/\n-    public <T extends Constant> T getConstant(final int index, final byte tag, final Class<T> castTo) throws ClassFormatException {\n-        final T c = getConstant(index);\n-        if (c.getTag() != tag) {\n-            throw new ClassFormatException(\"Expected class '\" + Const.getConstantName(tag) + \"' at index \" + index + \" and got \" + c);\n+    public Constant getConstant( final int index ) {\n+        if (index >= constantPool.length || index < 0) {\n+            throw new ClassFormatException(\"Invalid constant pool reference: \" + index\n+                    + \". Constant pool size is: \" + constantPool.length);\n@@ -294,1 +254,1 @@\n-        return c;\n+        return constantPool[index];\n@@ -298,1 +258,2 @@\n-     * Gets constant from constant pool.\n+     * Gets constant from constant pool and check whether it has the\n+     * expected type.\n@@ -300,3 +261,2 @@\n-     * @param <T> A {@link Constant} subclass\n-     * @param index Index in constant pool\n-     * @param castTo The {@link Constant} subclass to cast to.\n+     * @param  index Index in constant pool\n+     * @param  tag Tag of expected constant, i.e., its type\n@@ -304,3 +264,2 @@\n-     * @see Constant\n-     * @throws ClassFormatException if index is invalid\n-     * @since 6.6.0\n+     * @see    Constant\n+     * @throws  ClassFormatException\n@@ -308,7 +267,5 @@\n-    public <T extends Constant> T getConstant(final int index, final Class<T> castTo) throws ClassFormatException {\n-        if (index >= constantPool.length || index < 0) {\n-            throw new ClassFormatException(\"Invalid constant pool reference using index: \" + index + \". Constant pool size is: \" + constantPool.length);\n-        }\n-        if (constantPool[index] != null && !castTo.isAssignableFrom(constantPool[index].getClass())) {\n-            throw new ClassFormatException(\"Invalid constant pool reference at index: \" + index +\n-                    \". Expected \" + castTo + \" but was \" + constantPool[index].getClass());\n+    public Constant getConstant( final int index, final byte tag ) throws ClassFormatException {\n+        Constant c;\n+        c = getConstant(index);\n+        if (c == null) {\n+            throw new ClassFormatException(\"Constant pool at index \" + index + \" is null.\");\n@@ -316,9 +273,3 @@\n-        \/\/ Previous check ensures this won't throw a ClassCastException\n-        final T c = castTo.cast(constantPool[index]);\n-        if (c == null\n-            \/\/ the 0th element is always null\n-            && index != 0) {\n-            final Constant prev = constantPool[index - 1];\n-            if (prev == null || prev.getTag() != Const.CONSTANT_Double && prev.getTag() != Const.CONSTANT_Long) {\n-                throw new ClassFormatException(\"Constant pool at index \" + index + \" is null.\");\n-            }\n+        if (c.getTag() != tag) {\n+            throw new ClassFormatException(\"Expected class `\" + Const.getConstantName(tag)\n+                    + \"' at index \" + index + \" and got \" + c);\n@@ -329,12 +280,0 @@\n-    \/**\n-     * Gets constant from constant pool and check whether it has the expected type.\n-     *\n-     * @param index Index in constant pool\n-     * @return ConstantInteger value\n-     * @see ConstantInteger\n-     * @throws ClassFormatException if constant type does not match tag\n-     *\/\n-    public ConstantInteger getConstantInteger(final int index) {\n-        return getConstant(index, Const.CONSTANT_Integer, ConstantInteger.class);\n-    }\n-\n@@ -343,1 +282,1 @@\n-     * @see Constant\n+     * @see    Constant\n@@ -350,2 +289,4 @@\n-     * Gets string from constant pool and bypass the indirection of 'ConstantClass' and 'ConstantString' objects. I.e. these classes have an index field that\n-     * points to another entry of the constant pool of type 'ConstantUtf8' which contains the real data.\n+     * Gets string from constant pool and bypass the indirection of\n+     * `ConstantClass' and `ConstantString' objects. I.e. these classes have\n+     * an index field that points to another entry of the constant pool of\n+     * type `ConstantUtf8' which contains the real data.\n@@ -353,2 +294,2 @@\n-     * @param index Index in constant pool\n-     * @param tag   Tag of expected constant, either ConstantClass or ConstantString\n+     * @param  index Index in constant pool\n+     * @param  tag Tag of expected constant, either ConstantClass or ConstantString\n@@ -356,3 +297,3 @@\n-     * @see ConstantClass\n-     * @see ConstantString\n-     * @throws IllegalArgumentException if tag is invalid\n+     * @see    ConstantClass\n+     * @see    ConstantString\n+     * @throws  ClassFormatException\n@@ -360,1 +301,2 @@\n-    public String getConstantString(final int index, final byte tag) throws IllegalArgumentException {\n+    public String getConstantString( final int index, final byte tag ) throws ClassFormatException {\n+        Constant c;\n@@ -362,4 +304,7 @@\n-        \/*\n-         * This switch() is not that elegant, since the four classes have the same contents, they just differ in the name of the index field variable. But we\n-         * want to stick to the JVM naming conventions closely though we could have solved these more elegantly by using the same variable name or by\n-         * subclassing.\n+        c = getConstant(index, tag);\n+        \/* This switch() is not that elegant, since the four classes have the\n+         * same contents, they just differ in the name of the index\n+         * field variable.\n+         * But we want to stick to the JVM naming conventions closely though\n+         * we could have solved these more elegantly by using the same\n+         * variable name or by subclassing.\n@@ -368,16 +313,14 @@\n-        case Const.CONSTANT_Class:\n-            i = getConstant(index, ConstantClass.class).getNameIndex();\n-            break;\n-        case Const.CONSTANT_String:\n-            i = getConstant(index, ConstantString.class).getStringIndex();\n-            break;\n-        case Const.CONSTANT_Module:\n-            i = getConstant(index, ConstantModule.class).getNameIndex();\n-            break;\n-        case Const.CONSTANT_Package:\n-            i = getConstant(index, ConstantPackage.class).getNameIndex();\n-            break;\n-        case Const.CONSTANT_Utf8:\n-            return getConstantUtf8(index).getBytes();\n-        default:\n-            throw new IllegalArgumentException(\"getConstantString called with illegal tag \" + tag);\n+            case Const.CONSTANT_Class:\n+                i = ((ConstantClass) c).getNameIndex();\n+                break;\n+            case Const.CONSTANT_String:\n+                i = ((ConstantString) c).getStringIndex();\n+                break;\n+            case Const.CONSTANT_Module:\n+                i = ((ConstantModule) c).getNameIndex();\n+                break;\n+            case Const.CONSTANT_Package:\n+                i = ((ConstantPackage) c).getNameIndex();\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"getConstantString called with illegal tag \" + tag);\n@@ -386,1 +329,2 @@\n-        return getConstantUtf8(i).getBytes();\n+        c = getConstant(i, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n@@ -389,11 +333,0 @@\n-    \/**\n-     * Gets constant from constant pool and check whether it has the expected type.\n-     *\n-     * @param index Index in constant pool\n-     * @return ConstantUtf8 value\n-     * @see ConstantUtf8\n-     * @throws ClassFormatException if constant type does not match tag\n-     *\/\n-    public ConstantUtf8 getConstantUtf8(final int index) throws ClassFormatException {\n-        return getConstant(index, Const.CONSTANT_Utf8, ConstantUtf8.class);\n-    }\n@@ -408,4 +341,0 @@\n-    @Override\n-    public Iterator<Constant> iterator() {\n-        return Arrays.stream(constantPool).iterator();\n-    }\n@@ -416,1 +345,1 @@\n-    public void setConstant(final int index, final Constant constant) {\n+    public void setConstant( final int index, final Constant constant ) {\n@@ -420,0 +349,1 @@\n+\n@@ -423,1 +353,1 @@\n-    public void setConstantPool(final Constant[] constantPool) {\n+    public void setConstantPool( final Constant[] constantPool ) {\n@@ -427,0 +357,1 @@\n+\n@@ -438,0 +369,20 @@\n+\n+\n+    \/**\n+     * @return deep copy of this constant pool\n+     *\/\n+    public ConstantPool copy() {\n+        ConstantPool c = null;\n+        try {\n+            c = (ConstantPool) clone();\n+            c.constantPool = new Constant[constantPool.length];\n+            for (int i = 1; i < constantPool.length; i++) {\n+                if (constantPool[i] != null) {\n+                    c.constantPool[i] = constantPool[i].copy();\n+                }\n+            }\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantPool.java","additions":220,"deletions":269,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a String object.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a String object.\n@@ -33,1 +34,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -39,0 +40,1 @@\n+\n@@ -41,2 +43,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +48,1 @@\n+\n@@ -52,1 +53,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -58,0 +59,1 @@\n+\n@@ -66,0 +68,1 @@\n+\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,14 +94,0 @@\n-    \/**\n-     * @return dereferenced string\n-     *\/\n-    public String getBytes(final ConstantPool cp) {\n-        return (String) getConstantValue(cp);\n-    }\n-\n-    \/**\n-     * @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return cp.getConstantUtf8(stringIndex).getBytes();\n-    }\n@@ -111,0 +102,1 @@\n+\n@@ -114,1 +106,1 @@\n-    public void setStringIndex(final int stringIndex) {\n+    public void setStringIndex( final int stringIndex ) {\n@@ -118,0 +110,1 @@\n+\n@@ -125,0 +118,16 @@\n+\n+\n+    \/** @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(stringIndex, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n+    }\n+\n+\n+    \/** @return dereferenced string\n+     *\/\n+    public String getBytes( final ConstantPool cp ) {\n+        return (String) getConstantValue(cp);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantString.java","additions":34,"deletions":25,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -29,3 +30,0 @@\n-import java.util.Objects;\n-\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -35,24 +33,0 @@\n- * <p>\n- * The following system properties govern caching this class performs.\n- * <\/p>\n- * <ul>\n- * <li>{@value #SYS_PROP_CACHE_MAX_ENTRIES} (since 6.4): The size of the cache, by default 0, meaning caching is\n- * disabled.<\/li>\n- * <li>{@value #SYS_PROP_CACHE_MAX_ENTRY_SIZE} (since 6.0): The maximum size of the values to cache, by default 200, 0\n- * disables caching. Values larger than this are <em>not<\/em> cached.<\/li>\n- * <li>{@value #SYS_PROP_STATISTICS} (since 6.0): Prints statistics on the console when the JVM exits.<\/li>\n- * <\/ul>\n- * <p>\n- * Here is a sample Maven invocation with caching disabled:\n- * <\/p>\n- *\n- * <pre>\n- * mvn test -Dbcel.statistics=true -Dbcel.maxcached.size=0 -Dbcel.maxcached=0\n- * <\/pre>\n- * <p>\n- * Here is a sample Maven invocation with caching enabled:\n- * <\/p>\n- *\n- * <pre>\n- * mvn test -Dbcel.statistics=true -Dbcel.maxcached.size=100000 -Dbcel.maxcached=5000000\n- * <\/pre>\n@@ -61,1 +35,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -71,1 +45,2 @@\n-        private static final HashMap<String, ConstantUtf8> CACHE = new LinkedHashMap<String, ConstantUtf8>(INITIAL_CAPACITY, 0.75f, true) {\n+        private static final HashMap<String, ConstantUtf8> CACHE = new LinkedHashMap<String, ConstantUtf8>(\n+            INITIAL_CAPACITY, 0.75f, true) {\n@@ -90,16 +65,0 @@\n-    \/\/ TODO these should perhaps be AtomicInt?\n-    private static volatile int considered;\n-    private static volatile int created;\n-    private static volatile int hits;\n-    private static volatile int skipped;\n-\n-    private static final String SYS_PROP_CACHE_MAX_ENTRIES = \"bcel.maxcached\";\n-    private static final String SYS_PROP_CACHE_MAX_ENTRY_SIZE = \"bcel.maxcached.size\";\n-    private static final String SYS_PROP_STATISTICS = \"bcel.statistics\";\n-\n-    static {\n-        if (Cache.BCEL_STATISTICS) {\n-            Runtime.getRuntime().addShutdownHook(new Thread(ConstantUtf8::printStats));\n-        }\n-    }\n-\n@@ -115,5 +74,0 @@\n-    \/\/ for access by test code\n-    static synchronized void clearStats() {\n-        hits = considered = skipped = created = 0;\n-    }\n-\n@@ -132,1 +86,0 @@\n-            skipped++;\n@@ -135,1 +88,1 @@\n-        considered++;\n+\n@@ -139,1 +92,0 @@\n-                hits++;\n@@ -177,9 +129,0 @@\n-    \/\/ for access by test code\n-    static void printStats() {\n-        final String prefix = \"[Apache Commons BCEL]\";\n-        System.err.printf(\"%s Cache hit %,d\/%,d, %d skipped.%n\", prefix, hits, considered, skipped);\n-        System.err.printf(\"%s Total of %,d ConstantUtf8 objects created.%n\", prefix, created);\n-        System.err.printf(\"%s Configuration: %s=%,d, %s=%,d.%n\", prefix, SYS_PROP_CACHE_MAX_ENTRIES, Cache.MAX_ENTRIES, SYS_PROP_CACHE_MAX_ENTRY_SIZE,\n-            Cache.MAX_ENTRY_SIZE);\n-    }\n-\n@@ -201,1 +144,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -206,1 +149,0 @@\n-        created++;\n@@ -214,2 +156,4 @@\n-        this.value = Objects.requireNonNull(value, \"value\");\n-        created++;\n+        if (value == null) {\n+            throw new IllegalArgumentException(\"Value must not be null.\");\n+        }\n+        this.value = value;\n@@ -219,1 +163,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n@@ -233,1 +177,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantUtf8.java","additions":13,"deletions":69,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +31,3 @@\n- * This class is derived from <em>Attribute<\/em> and represents a constant value, i.e., a default value for initializing\n- * a class field. This class is instantiated by the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and represents a constant\n+ * value, i.e., a default value for initializing a class field.\n+ * This class is instantiated by the <em>Attribute.readAttribute()<\/em> method.\n@@ -35,8 +35,1 @@\n- * <pre>\n- * ConstantValue_attribute {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u2 constantvalue_index;\n- * }\n- * <\/pre>\n- * @see Attribute\n+ * @see     Attribute\n@@ -48,0 +41,1 @@\n+\n@@ -49,4 +43,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -58,0 +50,1 @@\n+\n@@ -60,2 +53,1 @@\n-     *\n-     * @param nameIndex Name index in constant pool\n+     * @param name_index Name index in constant pool\n@@ -64,2 +56,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -67,2 +59,3 @@\n-    ConstantValue(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n+    ConstantValue(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, input.readUnsignedShort(), constant_pool);\n@@ -71,0 +64,1 @@\n+\n@@ -72,1 +66,1 @@\n-     * @param nameIndex Name index in constant pool\n+     * @param name_index Name index in constant pool\n@@ -75,1 +69,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -77,2 +71,3 @@\n-    public ConstantValue(final int nameIndex, final int length, final int constantValueIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_CONSTANT_VALUE, nameIndex, Args.require(length, 2, \"ConstantValue attribute length\"), constantPool);\n+    public ConstantValue(final int name_index, final int length, final int constantValueIndex,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_CONSTANT_VALUE, name_index, length, constant_pool);\n@@ -82,0 +77,1 @@\n+\n@@ -83,2 +79,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -89,1 +86,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -93,9 +90,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final ConstantValue c = (ConstantValue) clone();\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -107,1 +95,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -110,1 +98,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -115,0 +103,1 @@\n+\n@@ -122,0 +111,1 @@\n+\n@@ -125,1 +115,1 @@\n-    public void setConstantValueIndex(final int constantValueIndex) {\n+    public void setConstantValueIndex( final int constantValueIndex ) {\n@@ -129,0 +119,1 @@\n+\n@@ -139,19 +130,19 @@\n-        case Const.CONSTANT_Long:\n-            buf = String.valueOf(((ConstantLong) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Float:\n-            buf = String.valueOf(((ConstantFloat) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Double:\n-            buf = String.valueOf(((ConstantDouble) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Integer:\n-            buf = String.valueOf(((ConstantInteger) c).getBytes());\n-            break;\n-        case Const.CONSTANT_String:\n-            i = ((ConstantString) c).getStringIndex();\n-            c = super.getConstantPool().getConstantUtf8(i);\n-            buf = \"\\\"\" + Utility.convertString(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n-            break;\n-        default:\n-            throw new IllegalStateException(\"Type of ConstValue invalid: \" + c);\n+            case Const.CONSTANT_Long:\n+                buf = String.valueOf(((ConstantLong) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Float:\n+                buf = String.valueOf(((ConstantFloat) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Double:\n+                buf = String.valueOf(((ConstantDouble) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Integer:\n+                buf = String.valueOf(((ConstantInteger) c).getBytes());\n+                break;\n+            case Const.CONSTANT_String:\n+                i = ((ConstantString) c).getStringIndex();\n+                c = super.getConstantPool().getConstant(i, Const.CONSTANT_Utf8);\n+                buf = \"\\\"\" + Utility.convertString(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Type of ConstValue invalid: \" + c);\n@@ -161,0 +152,11 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final ConstantValue c = (ConstantValue) clone();\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantValue.java","additions":61,"deletions":59,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,2 +30,3 @@\n- * This class is derived from <em>Attribute<\/em> and denotes that this is a deprecated method. It is instantiated from\n- * the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and denotes that this is a\n+ * deprecated method.\n+ * It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n@@ -34,1 +34,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -40,0 +40,1 @@\n+\n@@ -41,4 +42,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -50,0 +49,1 @@\n+\n@@ -51,1 +51,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -54,1 +54,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -56,2 +56,2 @@\n-    public Deprecated(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n-        super(Const.ATTR_DEPRECATED, nameIndex, Args.require0(length, \"Deprecated attribute length\"), constantPool);\n+    public Deprecated(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n+        super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);\n@@ -61,0 +61,1 @@\n+\n@@ -64,1 +65,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -67,2 +68,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -70,2 +71,3 @@\n-    Deprecated(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (byte[]) null, constantPool);\n+    Deprecated(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (byte[]) null, constant_pool);\n@@ -79,0 +81,1 @@\n+\n@@ -80,2 +83,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -86,1 +90,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -90,12 +94,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Deprecated c = (Deprecated) clone();\n-        if (bytes != null) {\n-            c.bytes = bytes.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -107,1 +99,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -110,1 +102,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -117,0 +109,1 @@\n+\n@@ -124,0 +117,1 @@\n+\n@@ -127,1 +121,1 @@\n-    public void setBytes(final byte[] bytes) {\n+    public void setBytes( final byte[] bytes ) {\n@@ -131,0 +125,1 @@\n+\n@@ -136,1 +131,16 @@\n-        return Const.getAttributeName(Const.ATTR_DEPRECATED) + \": true\";\n+        return Const.getAttributeName(Const.ATTR_DEPRECATED);\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Deprecated c = (Deprecated) clone();\n+        if (bytes != null) {\n+            c.bytes = new byte[bytes.length];\n+            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Deprecated.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -22,1 +22,0 @@\n-import java.util.Objects;\n@@ -24,1 +23,0 @@\n-import java.util.stream.Stream;\n@@ -32,1 +30,2 @@\n-public class DescendingVisitor implements Visitor {\n+public class DescendingVisitor implements Visitor\n+{\n@@ -40,2 +39,1 @@\n-     * @param clazz Class to traverse\n-     * @param visitor visitor object to apply to all components\n+     * @return container of current entitity, i.e., predecessor during traversal\n@@ -43,7 +41,3 @@\n-    public DescendingVisitor(final JavaClass clazz, final Visitor visitor) {\n-        this.clazz = clazz;\n-        this.visitor = visitor;\n-    }\n-\n-    private <E extends Node> void accept(final E[] node) {\n-        Stream.of(node).forEach(e -> e.accept(this));\n+    public Object predecessor()\n+    {\n+        return predecessor(0);\n@@ -53,1 +47,3 @@\n-     * @return current object\n+     * @param level\n+     *            nesting level, i.e., 0 returns the direct predecessor\n+     * @return container of current entitity, i.e., predecessor during traversal\n@@ -55,2 +51,8 @@\n-    public Object current() {\n-        return stack.peek();\n+    public Object predecessor(final int level)\n+    {\n+        final int size = stack.size();\n+        if ((size < 2) || (level < 0))\n+        {\n+            return null;\n+        }\n+        return stack.elementAt(size - (level + 2)); \/\/ size - 1 == current\n@@ -60,1 +62,1 @@\n-     * @return container of current entitity, i.e., predecessor during traversal\n+     * @return current object\n@@ -62,2 +64,3 @@\n-    public Object predecessor() {\n-        return predecessor(0);\n+    public Object current()\n+    {\n+        return stack.peek();\n@@ -67,2 +70,4 @@\n-     * @param level nesting level, i.e., 0 returns the direct predecessor\n-     * @return container of current entitity, i.e., predecessor during traversal\n+     * @param clazz\n+     *            Class to traverse\n+     * @param visitor\n+     *            visitor object to apply to all components\n@@ -70,6 +75,4 @@\n-    public Object predecessor(final int level) {\n-        final int size = stack.size();\n-        if (size < 2 || level < 0) {\n-            return null;\n-        }\n-        return stack.elementAt(size - (level + 2)); \/\/ size - 1 == current\n+    public DescendingVisitor(final JavaClass clazz, final Visitor visitor)\n+    {\n+        this.clazz = clazz;\n+        this.visitor = visitor;\n@@ -81,1 +84,2 @@\n-    public void visit() {\n+    public void visit()\n+    {\n@@ -85,3 +89,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -89,4 +90,17 @@\n-    public void visitAnnotation(final Annotations annotation) {\n-        stack.push(annotation);\n-        annotation.accept(visitor);\n-        accept(annotation.getAnnotationEntries());\n+    public void visitJavaClass(final JavaClass _clazz)\n+    {\n+        stack.push(_clazz);\n+        _clazz.accept(visitor);\n+        final Field[] fields = _clazz.getFields();\n+        for (final Field field : fields) {\n+            field.accept(this);\n+        }\n+        final Method[] methods = _clazz.getMethods();\n+        for (final Method method : methods) {\n+            method.accept(this);\n+        }\n+        final Attribute[] attributes = _clazz.getAttributes();\n+        for (final Attribute attribute : attributes) {\n+            attribute.accept(this);\n+        }\n+        _clazz.getConstantPool().accept(this);\n@@ -100,3 +114,8 @@\n-    public void visitAnnotationDefault(final AnnotationDefault obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitAnnotation(final Annotations annotation)\n+    {\n+        stack.push(annotation);\n+        annotation.accept(visitor);\n+        final AnnotationEntry[] entries = annotation.getAnnotationEntries();\n+        for (final AnnotationEntry entrie : entries) {\n+            entrie.accept(this);\n+        }\n@@ -110,1 +129,2 @@\n-    public void visitAnnotationEntry(final AnnotationEntry annotationEntry) {\n+    public void visitAnnotationEntry(final AnnotationEntry annotationEntry)\n+    {\n@@ -116,3 +136,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -120,8 +137,8 @@\n-    public void visitBootstrapMethods(final BootstrapMethods bm) {\n-        stack.push(bm);\n-        bm.accept(visitor);\n-        \/\/ BootstrapMethod[] bms = bm.getBootstrapMethods();\n-        \/\/ for (int i = 0; i < bms.length; i++)\n-        \/\/ {\n-        \/\/ bms[i].accept(this);\n-        \/\/ }\n+    public void visitField(final Field field)\n+    {\n+        stack.push(field);\n+        field.accept(visitor);\n+        final Attribute[] attributes = field.getAttributes();\n+        for (final Attribute attribute : attributes) {\n+            attribute.accept(this);\n+        }\n@@ -132,5 +149,4 @@\n-    public void visitCode(final Code code) {\n-        stack.push(code);\n-        code.accept(visitor);\n-        accept(code.getExceptionTable());\n-        accept(code.getAttributes());\n+    public void visitConstantValue(final ConstantValue cv)\n+    {\n+        stack.push(cv);\n+        cv.accept(visitor);\n@@ -141,3 +157,8 @@\n-    public void visitCodeException(final CodeException ce) {\n-        stack.push(ce);\n-        ce.accept(visitor);\n+    public void visitMethod(final Method method)\n+    {\n+        stack.push(method);\n+        method.accept(visitor);\n+        final Attribute[] attributes = method.getAttributes();\n+        for (final Attribute attribute : attributes) {\n+            attribute.accept(this);\n+        }\n@@ -148,3 +169,4 @@\n-    public void visitConstantClass(final ConstantClass constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitExceptionTable(final ExceptionTable table)\n+    {\n+        stack.push(table);\n+        table.accept(visitor);\n@@ -155,3 +177,12 @@\n-    public void visitConstantDouble(final ConstantDouble constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitCode(final Code code)\n+    {\n+        stack.push(code);\n+        code.accept(visitor);\n+        final CodeException[] table = code.getExceptionTable();\n+        for (final CodeException element : table) {\n+            element.accept(this);\n+        }\n+        final Attribute[] attributes = code.getAttributes();\n+        for (final Attribute attribute : attributes) {\n+            attribute.accept(this);\n+        }\n@@ -161,1 +192,0 @@\n-    \/** @since 6.3 *\/\n@@ -163,3 +193,4 @@\n-    public void visitConstantDynamic(final ConstantDynamic obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitCodeException(final CodeException ce)\n+    {\n+        stack.push(ce);\n+        ce.accept(visitor);\n@@ -170,3 +201,8 @@\n-    public void visitConstantFieldref(final ConstantFieldref constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitLineNumberTable(final LineNumberTable table)\n+    {\n+        stack.push(table);\n+        table.accept(visitor);\n+        final LineNumber[] numbers = table.getLineNumberTable();\n+        for (final LineNumber number : numbers) {\n+            number.accept(this);\n+        }\n@@ -177,3 +213,4 @@\n-    public void visitConstantFloat(final ConstantFloat constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitLineNumber(final LineNumber number)\n+    {\n+        stack.push(number);\n+        number.accept(visitor);\n@@ -184,3 +221,8 @@\n-    public void visitConstantInteger(final ConstantInteger constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitLocalVariableTable(final LocalVariableTable table)\n+    {\n+        stack.push(table);\n+        table.accept(visitor);\n+        final LocalVariable[] vars = table.getLocalVariableTable();\n+        for (final LocalVariable var : vars) {\n+            var.accept(this);\n+        }\n@@ -191,3 +233,8 @@\n-    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitStackMap(final StackMap table)\n+    {\n+        stack.push(table);\n+        table.accept(visitor);\n+        final StackMapEntry[] vars = table.getStackMap();\n+        for (final StackMapEntry var : vars) {\n+            var.accept(this);\n+        }\n@@ -197,3 +244,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -201,3 +245,4 @@\n-    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitStackMapEntry(final StackMapEntry var)\n+    {\n+        stack.push(var);\n+        var.accept(visitor);\n@@ -208,3 +253,4 @@\n-    public void visitConstantLong(final ConstantLong constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitLocalVariable(final LocalVariable var)\n+    {\n+        stack.push(var);\n+        var.accept(visitor);\n@@ -214,1 +260,0 @@\n-    \/** @since 6.0 *\/\n@@ -216,3 +261,12 @@\n-    public void visitConstantMethodHandle(final ConstantMethodHandle obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantPool(final ConstantPool cp)\n+    {\n+        stack.push(cp);\n+        cp.accept(visitor);\n+        final Constant[] constants = cp.getConstantPool();\n+        for (int i = 1; i < constants.length; i++)\n+        {\n+            if (constants[i] != null)\n+            {\n+                constants[i].accept(this);\n+            }\n+        }\n@@ -223,1 +277,2 @@\n-    public void visitConstantMethodref(final ConstantMethodref constant) {\n+    public void visitConstantClass(final ConstantClass constant)\n+    {\n@@ -229,1 +284,0 @@\n-    \/** @since 6.0 *\/\n@@ -231,3 +285,4 @@\n-    public void visitConstantMethodType(final ConstantMethodType obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantDouble(final ConstantDouble constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -237,1 +292,0 @@\n-    \/** @since 6.1 *\/\n@@ -239,3 +293,4 @@\n-    public void visitConstantModule(final ConstantModule obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantFieldref(final ConstantFieldref constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -246,1 +301,2 @@\n-    public void visitConstantNameAndType(final ConstantNameAndType constant) {\n+    public void visitConstantFloat(final ConstantFloat constant)\n+    {\n@@ -252,1 +308,0 @@\n-    \/** @since 6.1 *\/\n@@ -254,3 +309,4 @@\n-    public void visitConstantPackage(final ConstantPackage obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantInteger(final ConstantInteger constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -261,4 +317,5 @@\n-    public void visitConstantPool(final ConstantPool cp) {\n-        stack.push(cp);\n-        cp.accept(visitor);\n-        Stream.of(cp.getConstantPool()).filter(Objects::nonNull).forEach(e -> e.accept(this));\n+    public void visitConstantInterfaceMethodref(\n+            final ConstantInterfaceMethodref constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -268,0 +325,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -269,1 +329,3 @@\n-    public void visitConstantString(final ConstantString constant) {\n+    public void visitConstantInvokeDynamic(\n+            final ConstantInvokeDynamic constant)\n+    {\n@@ -276,1 +338,2 @@\n-    public void visitConstantUtf8(final ConstantUtf8 constant) {\n+    public void visitConstantLong(final ConstantLong constant)\n+    {\n@@ -283,3 +346,4 @@\n-    public void visitConstantValue(final ConstantValue cv) {\n-        stack.push(cv);\n-        cv.accept(visitor);\n+    public void visitConstantMethodref(final ConstantMethodref constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -290,3 +354,4 @@\n-    public void visitDeprecated(final Deprecated attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitConstantNameAndType(final ConstantNameAndType constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -296,3 +361,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -300,3 +362,4 @@\n-    public void visitEnclosingMethod(final EnclosingMethod obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantString(final ConstantString constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -307,3 +370,4 @@\n-    public void visitExceptionTable(final ExceptionTable table) {\n-        stack.push(table);\n-        table.accept(visitor);\n+    public void visitConstantUtf8(final ConstantUtf8 constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -314,4 +378,8 @@\n-    public void visitField(final Field field) {\n-        stack.push(field);\n-        field.accept(visitor);\n-        accept(field.getAttributes());\n+    public void visitInnerClasses(final InnerClasses ic)\n+    {\n+        stack.push(ic);\n+        ic.accept(visitor);\n+        final InnerClass[] ics = ic.getInnerClasses();\n+        for (final InnerClass ic2 : ics) {\n+            ic2.accept(this);\n+        }\n@@ -322,1 +390,2 @@\n-    public void visitInnerClass(final InnerClass inner) {\n+    public void visitInnerClass(final InnerClass inner)\n+    {\n@@ -328,0 +397,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -329,4 +401,9 @@\n-    public void visitInnerClasses(final InnerClasses ic) {\n-        stack.push(ic);\n-        ic.accept(visitor);\n-        accept(ic.getInnerClasses());\n+    public void visitBootstrapMethods(final BootstrapMethods bm)\n+    {\n+        stack.push(bm);\n+        bm.accept(visitor);\n+        \/\/ BootstrapMethod[] bms = bm.getBootstrapMethods();\n+        \/\/ for (int i = 0; i < bms.length; i++)\n+        \/\/ {\n+        \/\/     bms[i].accept(this);\n+        \/\/ }\n@@ -337,7 +414,4 @@\n-    public void visitJavaClass(final JavaClass clazz) {\n-        stack.push(clazz);\n-        clazz.accept(visitor);\n-        accept(clazz.getFields());\n-        accept(clazz.getMethods());\n-        accept(clazz.getAttributes());\n-        clazz.getConstantPool().accept(this);\n+    public void visitDeprecated(final Deprecated attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -348,3 +422,4 @@\n-    public void visitLineNumber(final LineNumber number) {\n-        stack.push(number);\n-        number.accept(visitor);\n+    public void visitSignature(final Signature attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -355,4 +430,4 @@\n-    public void visitLineNumberTable(final LineNumberTable table) {\n-        stack.push(table);\n-        table.accept(visitor);\n-        accept(table.getLineNumberTable());\n+    public void visitSourceFile(final SourceFile attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -363,3 +438,4 @@\n-    public void visitLocalVariable(final LocalVariable var) {\n-        stack.push(var);\n-        var.accept(visitor);\n+    public void visitSynthetic(final Synthetic attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -370,4 +446,4 @@\n-    public void visitLocalVariableTable(final LocalVariableTable table) {\n-        stack.push(table);\n-        table.accept(visitor);\n-        accept(table.getLocalVariableTable());\n+    public void visitUnknown(final Unknown attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -381,1 +457,2 @@\n-    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj) {\n+    public void visitAnnotationDefault(final AnnotationDefault obj)\n+    {\n@@ -387,0 +464,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -388,4 +468,4 @@\n-    public void visitMethod(final Method method) {\n-        stack.push(method);\n-        method.accept(visitor);\n-        accept(method.getAttributes());\n+    public void visitEnclosingMethod(final EnclosingMethod obj)\n+    {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -396,1 +476,1 @@\n-     * @since 6.4.0\n+     * @since 6.0\n@@ -399,1 +479,2 @@\n-    public void visitMethodParameter(final MethodParameter obj) {\n+    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj)\n+    {\n@@ -409,1 +490,2 @@\n-    public void visitMethodParameters(final MethodParameters obj) {\n+    public void visitParameterAnnotation(final ParameterAnnotations obj)\n+    {\n@@ -412,1 +494,0 @@\n-        Stream.of(obj.getParameters()).forEach(e -> e.accept(this));\n@@ -416,1 +497,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -418,1 +501,2 @@\n-    public void visitModule(final Module obj) {\n+    public void visitMethodParameters(final MethodParameters obj)\n+    {\n@@ -421,4 +505,4 @@\n-        accept(obj.getRequiresTable());\n-        accept(obj.getExportsTable());\n-        accept(obj.getOpensTable());\n-        accept(obj.getProvidesTable());\n+        final MethodParameter[] table = obj.getParameters();\n+        for (final MethodParameter element : table) {\n+            element.accept(this);\n+        }\n@@ -428,1 +512,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.4.0\n+     *\/\n@@ -430,1 +516,2 @@\n-    public void visitModuleExports(final ModuleExports obj) {\n+    public void visitMethodParameter(final MethodParameter obj)\n+    {\n@@ -436,1 +523,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.0 *\/\n@@ -438,1 +525,1 @@\n-    public void visitModuleMainClass(final ModuleMainClass obj) {\n+    public void visitConstantMethodType(final ConstantMethodType obj) {\n@@ -444,1 +531,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.0 *\/\n@@ -446,1 +533,1 @@\n-    public void visitModuleOpens(final ModuleOpens obj) {\n+    public void visitConstantMethodHandle(final ConstantMethodHandle obj) {\n@@ -452,1 +539,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.0 *\/\n@@ -454,1 +541,1 @@\n-    public void visitModulePackages(final ModulePackages obj) {\n+    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry obj) {\n@@ -460,1 +547,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.1 *\/\n@@ -462,1 +549,1 @@\n-    public void visitModuleProvides(final ModuleProvides obj) {\n+    public void visitConstantPackage(final ConstantPackage obj) {\n@@ -468,1 +555,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.1 *\/\n@@ -470,1 +557,1 @@\n-    public void visitModuleRequires(final ModuleRequires obj) {\n+    public void visitConstantModule(final ConstantModule obj) {\n@@ -476,1 +563,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.3 *\/\n@@ -478,1 +565,1 @@\n-    public void visitNestHost(final NestHost obj) {\n+    public void visitConstantDynamic(final ConstantDynamic obj) {\n@@ -486,1 +573,1 @@\n-    public void visitNestMembers(final NestMembers obj) {\n+    public void visitModule(final Module obj) {\n@@ -489,0 +576,16 @@\n+        final ModuleRequires[] rtable = obj.getRequiresTable();\n+        for (final ModuleRequires element : rtable) {\n+            element.accept(this);\n+        }\n+        final ModuleExports[] etable = obj.getExportsTable();\n+        for (final ModuleExports element : etable) {\n+            element.accept(this);\n+        }\n+        final ModuleOpens[] otable = obj.getOpensTable();\n+        for (final ModuleOpens element : otable) {\n+            element.accept(this);\n+        }\n+        final ModuleProvides[] ptable = obj.getProvidesTable();\n+        for (final ModuleProvides element : ptable) {\n+            element.accept(this);\n+        }\n@@ -492,3 +595,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -496,1 +597,1 @@\n-    public void visitParameterAnnotation(final ParameterAnnotations obj) {\n+    public void visitModuleRequires(final ModuleRequires obj) {\n@@ -502,1 +603,1 @@\n-    \/** @since 6.0 *\/\n+    \/** @since 6.4.0 *\/\n@@ -504,1 +605,1 @@\n-    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry obj) {\n+    public void visitModuleExports(final ModuleExports obj) {\n@@ -510,0 +611,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -511,3 +613,3 @@\n-    public void visitSignature(final Signature attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitModuleOpens(final ModuleOpens obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -517,0 +619,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -518,3 +621,3 @@\n-    public void visitSourceFile(final SourceFile attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitModuleProvides(final ModuleProvides obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -524,0 +627,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -525,4 +629,3 @@\n-    public void visitStackMap(final StackMap table) {\n-        stack.push(table);\n-        table.accept(visitor);\n-        accept(table.getStackMap());\n+    public void visitModulePackages(final ModulePackages obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -532,0 +635,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -533,3 +637,3 @@\n-    public void visitStackMapEntry(final StackMapEntry var) {\n-        stack.push(var);\n-        var.accept(visitor);\n+    public void visitModuleMainClass(final ModuleMainClass obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -539,0 +643,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -540,3 +645,3 @@\n-    public void visitSynthetic(final Synthetic attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitNestHost(final NestHost obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -546,0 +651,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -547,3 +653,3 @@\n-    public void visitUnknown(final Unknown attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitNestMembers(final NestMembers obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/DescendingVisitor.java","additions":318,"deletions":212,"binary":false,"changes":530,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-\n@@ -30,22 +28,0 @@\n- * The element_value structure is documented at https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se11\/html\/jvms-4.html#jvms-4.7.16.1\n- *\n- * <pre>\n- * element_value {\n- *    u1 tag;\n- *    union {\n- *        u2 const_value_index;\n- *\n- *        {   u2 type_name_index;\n- *            u2 const_name_index;\n- *        } enum_const_value;\n- *\n- *        u2 class_info_index;\n- *\n- *        annotation annotation_value;\n- *\n- *        {   u2            num_values;\n- *            element_value values[num_values];\n- *        } array_value;\n- *    } value;\n- *}\n- *<\/pre>\n@@ -55,15 +31,3 @@\n-public abstract class ElementValue {\n-\n-    public static final byte STRING = 's';\n-    public static final byte ENUM_CONSTANT = 'e';\n-    public static final byte CLASS = 'c';\n-    public static final byte ANNOTATION = '@';\n-    public static final byte ARRAY = '[';\n-    public static final byte PRIMITIVE_INT = 'I';\n-    public static final byte PRIMITIVE_BYTE = 'B';\n-    public static final byte PRIMITIVE_CHAR = 'C';\n-    public static final byte PRIMITIVE_DOUBLE = 'D';\n-    public static final byte PRIMITIVE_FLOAT = 'F';\n-    public static final byte PRIMITIVE_LONG = 'J';\n-    public static final byte PRIMITIVE_SHORT = 'S';\n-    public static final byte PRIMITIVE_BOOLEAN = 'Z';\n+public abstract class ElementValue\n+{\n+    private final int type;\n@@ -71,11 +35,1 @@\n-    \/**\n-     * Reads an {@code element_value} as an {@code ElementValue}.\n-     *\n-     * @param input Raw data input.\n-     * @param cpool Constant pool.\n-     * @return a new ElementValue.\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool) throws IOException {\n-        return readElementValue(input, cpool, 0);\n-    }\n+    private final ConstantPool cpool;\n@@ -83,51 +37,4 @@\n-    \/**\n-     * Reads an {@code element_value} as an {@code ElementValue}.\n-     *\n-     * @param input Raw data input.\n-     * @param cpool Constant pool.\n-     * @param arrayNesting level of current array nesting.\n-     * @return a new ElementValue.\n-     * @throws IOException if an I\/O error occurs.\n-     * @since 6.7.0\n-     *\/\n-    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool, int arrayNesting)\n-            throws IOException {\n-        final byte tag = input.readByte();\n-        switch (tag) {\n-        case PRIMITIVE_BYTE:\n-        case PRIMITIVE_CHAR:\n-        case PRIMITIVE_DOUBLE:\n-        case PRIMITIVE_FLOAT:\n-        case PRIMITIVE_INT:\n-        case PRIMITIVE_LONG:\n-        case PRIMITIVE_SHORT:\n-        case PRIMITIVE_BOOLEAN:\n-        case STRING:\n-            return new SimpleElementValue(tag, input.readUnsignedShort(), cpool);\n-\n-        case ENUM_CONSTANT:\n-            return new EnumElementValue(ENUM_CONSTANT, input.readUnsignedShort(), input.readUnsignedShort(), cpool);\n-\n-        case CLASS:\n-            return new ClassElementValue(CLASS, input.readUnsignedShort(), cpool);\n-\n-        case ANNOTATION:\n-            \/\/ TODO isRuntimeVisible\n-            return new AnnotationElementValue(ANNOTATION, AnnotationEntry.read(input, cpool, false), cpool);\n-\n-        case ARRAY:\n-            arrayNesting++;\n-            if (arrayNesting > Const.MAX_ARRAY_DIMENSIONS) {\n-                \/\/ JVM spec 4.4.1\n-                throw new ClassFormatException(String.format(\"Arrays are only valid if they represent %,d or fewer dimensions.\", Const.MAX_ARRAY_DIMENSIONS));\n-            }\n-            final int numArrayVals = input.readUnsignedShort();\n-            final ElementValue[] evalues = new ElementValue[numArrayVals];\n-            for (int j = 0; j < numArrayVals; j++) {\n-                evalues[j] = ElementValue.readElementValue(input, cpool, arrayNesting);\n-            }\n-            return new ArrayElementValue(ARRAY, evalues, cpool);\n-\n-        default:\n-            throw new ClassFormatException(\"Unexpected element value tag in annotation: \" + tag);\n-        }\n+    @Override\n+    public String toString()\n+    {\n+        return stringifyValue();\n@@ -136,12 +43,2 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int type; \/\/ TODO should be final\n-    \/**\n-     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n-     *\/\n-    @java.lang.Deprecated\n-    protected ConstantPool cpool; \/\/ TODO should be final\n-\n-    protected ElementValue(final int type, final ConstantPool cpool) {\n+    protected ElementValue(final int type, final ConstantPool cpool)\n+    {\n@@ -152,0 +49,7 @@\n+    public int getElementValueType()\n+    {\n+        return type;\n+    }\n+\n+    public abstract String stringifyValue();\n+\n@@ -154,0 +58,54 @@\n+    public static final byte STRING            = 's';\n+    public static final byte ENUM_CONSTANT     = 'e';\n+    public static final byte CLASS             = 'c';\n+    public static final byte ANNOTATION        = '@';\n+    public static final byte ARRAY             = '[';\n+    public static final byte PRIMITIVE_INT     = 'I';\n+    public static final byte PRIMITIVE_BYTE    = 'B';\n+    public static final byte PRIMITIVE_CHAR    = 'C';\n+    public static final byte PRIMITIVE_DOUBLE  = 'D';\n+    public static final byte PRIMITIVE_FLOAT   = 'F';\n+    public static final byte PRIMITIVE_LONG    = 'J';\n+    public static final byte PRIMITIVE_SHORT   = 'S';\n+    public static final byte PRIMITIVE_BOOLEAN = 'Z';\n+\n+    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool) throws IOException\n+    {\n+        final byte type = input.readByte();\n+        switch (type)\n+        {\n+            case PRIMITIVE_BYTE:\n+            case PRIMITIVE_CHAR:\n+            case PRIMITIVE_DOUBLE:\n+            case PRIMITIVE_FLOAT:\n+            case PRIMITIVE_INT:\n+            case PRIMITIVE_LONG:\n+            case PRIMITIVE_SHORT:\n+            case PRIMITIVE_BOOLEAN:\n+            case STRING:\n+                return new SimpleElementValue(type, input.readUnsignedShort(), cpool);\n+\n+            case ENUM_CONSTANT:\n+                return new EnumElementValue(ENUM_CONSTANT, input.readUnsignedShort(), input.readUnsignedShort(), cpool);\n+\n+            case CLASS:\n+                return new ClassElementValue(CLASS, input.readUnsignedShort(), cpool);\n+\n+            case ANNOTATION:\n+                \/\/ TODO isRuntimeVisible\n+                return new AnnotationElementValue(ANNOTATION, AnnotationEntry.read(input, cpool, false), cpool);\n+\n+            case ARRAY:\n+                final int numArrayVals = input.readUnsignedShort();\n+                final ElementValue[] evalues = new ElementValue[numArrayVals];\n+                for (int j = 0; j < numArrayVals; j++)\n+                {\n+                    evalues[j] = ElementValue.readElementValue(input, cpool);\n+                }\n+                return new ArrayElementValue(ARRAY, evalues, cpool);\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unexpected element value kind in annotation: \" + type);\n+        }\n+    }\n+\n@@ -159,4 +117,0 @@\n-    public int getElementValueType() {\n-        return type;\n-    }\n-\n@@ -168,8 +122,2 @@\n-    public abstract String stringifyValue();\n-\n-    public String toShortString() {\n-        return stringifyValue();\n-    }\n-\n-    @Override\n-    public String toString() {\n+    public String toShortString()\n+    {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ElementValue.java","additions":73,"deletions":125,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -28,1 +30,1 @@\n- * An annotation's element value pair.\n+ * an annotation's element value pair\n@@ -32,4 +34,2 @@\n-public class ElementValuePair {\n-\n-    static final ElementValuePair[] EMPTY_ARRAY = {};\n-\n+public class ElementValuePair\n+{\n@@ -42,1 +42,3 @@\n-    public ElementValuePair(final int elementNameIndex, final ElementValue elementValue, final ConstantPool constantPool) {\n+    public ElementValuePair(final int elementNameIndex, final ElementValue elementValue,\n+            final ConstantPool constantPool)\n+    {\n@@ -48,7 +50,5 @@\n-    protected void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(elementNameIndex); \/\/ u2 name of the element\n-        elementValue.dump(dos);\n-    }\n-\n-    public int getNameIndex() {\n-        return elementNameIndex;\n+    public String getNameString()\n+    {\n+        final ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(\n+                elementNameIndex, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -57,2 +57,3 @@\n-    public String getNameString() {\n-        return constantPool.getConstantUtf8(elementNameIndex).getBytes();\n+    public final ElementValue getValue()\n+    {\n+        return elementValue;\n@@ -61,2 +62,3 @@\n-    public final ElementValue getValue() {\n-        return elementValue;\n+    public int getNameIndex()\n+    {\n+        return elementNameIndex;\n@@ -65,1 +67,2 @@\n-    public String toShortString() {\n+    public String toShortString()\n+    {\n@@ -67,1 +70,2 @@\n-        result.append(getNameString()).append(\"=\").append(getValue().toShortString());\n+        result.append(getNameString()).append(\"=\").append(\n+                getValue().toShortString());\n@@ -70,0 +74,5 @@\n+\n+    protected void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(elementNameIndex); \/\/ u2 name of the element\n+        elementValue.dump(dos);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ElementValuePair.java","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Visitor with empty method bodies, can be extended and used in conjunction with the DescendingVisitor class, e.g. By\n- * courtesy of David Spencer.\n+ * Visitor with empty method bodies, can be extended and used in conjunction\n+ * with the DescendingVisitor class, e.g. By courtesy of David Spencer.\n@@ -30,2 +30,4 @@\n-public class EmptyVisitor implements Visitor {\n-    protected EmptyVisitor() {\n+public class EmptyVisitor implements Visitor\n+{\n+    protected EmptyVisitor()\n+    {\n@@ -38,1 +40,2 @@\n-    public void visitAnnotation(final Annotations obj) {\n+    public void visitAnnotation(final Annotations obj)\n+    {\n@@ -45,1 +48,2 @@\n-    public void visitAnnotationDefault(final AnnotationDefault obj) {\n+    public void visitParameterAnnotation(final ParameterAnnotations obj)\n+    {\n@@ -52,1 +56,2 @@\n-    public void visitAnnotationEntry(final AnnotationEntry obj) {\n+    public void visitAnnotationEntry(final AnnotationEntry obj)\n+    {\n@@ -59,1 +64,2 @@\n-    public void visitBootstrapMethods(final BootstrapMethods obj) {\n+    public void visitAnnotationDefault(final AnnotationDefault obj)\n+    {\n@@ -63,1 +69,2 @@\n-    public void visitCode(final Code obj) {\n+    public void visitCode(final Code obj)\n+    {\n@@ -67,1 +74,2 @@\n-    public void visitCodeException(final CodeException obj) {\n+    public void visitCodeException(final CodeException obj)\n+    {\n@@ -71,1 +79,2 @@\n-    public void visitConstantClass(final ConstantClass obj) {\n+    public void visitConstantClass(final ConstantClass obj)\n+    {\n@@ -75,1 +84,2 @@\n-    public void visitConstantDouble(final ConstantDouble obj) {\n+    public void visitConstantDouble(final ConstantDouble obj)\n+    {\n@@ -78,3 +88,0 @@\n-    \/**\n-     * @since 6.3\n-     *\/\n@@ -82,1 +89,2 @@\n-    public void visitConstantDynamic(final ConstantDynamic obj) {\n+    public void visitConstantFieldref(final ConstantFieldref obj)\n+    {\n@@ -86,1 +94,2 @@\n-    public void visitConstantFieldref(final ConstantFieldref obj) {\n+    public void visitConstantFloat(final ConstantFloat obj)\n+    {\n@@ -90,1 +99,2 @@\n-    public void visitConstantFloat(final ConstantFloat obj) {\n+    public void visitConstantInteger(final ConstantInteger obj)\n+    {\n@@ -94,1 +104,2 @@\n-    public void visitConstantInteger(final ConstantInteger obj) {\n+    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj)\n+    {\n@@ -98,1 +109,2 @@\n-    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj) {\n+    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic obj)\n+    {\n@@ -102,1 +114,2 @@\n-    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic obj) {\n+    public void visitConstantLong(final ConstantLong obj)\n+    {\n@@ -106,1 +119,2 @@\n-    public void visitConstantLong(final ConstantLong obj) {\n+    public void visitConstantMethodref(final ConstantMethodref obj)\n+    {\n@@ -109,3 +123,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -113,5 +124,2 @@\n-    public void visitConstantMethodHandle(final ConstantMethodHandle constantMethodHandle) {\n-    }\n-\n-    @Override\n-    public void visitConstantMethodref(final ConstantMethodref obj) {\n+    public void visitConstantNameAndType(final ConstantNameAndType obj)\n+    {\n@@ -120,3 +128,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -124,1 +129,2 @@\n-    public void visitConstantMethodType(final ConstantMethodType obj) {\n+    public void visitConstantPool(final ConstantPool obj)\n+    {\n@@ -127,3 +133,0 @@\n-    \/**\n-     * @since 6.1\n-     *\/\n@@ -131,1 +134,2 @@\n-    public void visitConstantModule(final ConstantModule constantModule) {\n+    public void visitConstantString(final ConstantString obj)\n+    {\n@@ -135,1 +139,2 @@\n-    public void visitConstantNameAndType(final ConstantNameAndType obj) {\n+    public void visitConstantUtf8(final ConstantUtf8 obj)\n+    {\n@@ -138,3 +143,0 @@\n-    \/**\n-     * @since 6.1\n-     *\/\n@@ -142,1 +144,2 @@\n-    public void visitConstantPackage(final ConstantPackage constantPackage) {\n+    public void visitConstantValue(final ConstantValue obj)\n+    {\n@@ -146,1 +149,2 @@\n-    public void visitConstantPool(final ConstantPool obj) {\n+    public void visitDeprecated(final Deprecated obj)\n+    {\n@@ -150,1 +154,2 @@\n-    public void visitConstantString(final ConstantString obj) {\n+    public void visitExceptionTable(final ExceptionTable obj)\n+    {\n@@ -154,1 +159,2 @@\n-    public void visitConstantUtf8(final ConstantUtf8 obj) {\n+    public void visitField(final Field obj)\n+    {\n@@ -158,1 +164,2 @@\n-    public void visitConstantValue(final ConstantValue obj) {\n+    public void visitInnerClass(final InnerClass obj)\n+    {\n@@ -162,1 +169,2 @@\n-    public void visitDeprecated(final Deprecated obj) {\n+    public void visitInnerClasses(final InnerClasses obj)\n+    {\n@@ -169,1 +177,2 @@\n-    public void visitEnclosingMethod(final EnclosingMethod obj) {\n+    public void visitBootstrapMethods(final BootstrapMethods obj)\n+    {\n@@ -173,1 +182,2 @@\n-    public void visitExceptionTable(final ExceptionTable obj) {\n+    public void visitJavaClass(final JavaClass obj)\n+    {\n@@ -177,1 +187,2 @@\n-    public void visitField(final Field obj) {\n+    public void visitLineNumber(final LineNumber obj)\n+    {\n@@ -181,1 +192,2 @@\n-    public void visitInnerClass(final InnerClass obj) {\n+    public void visitLineNumberTable(final LineNumberTable obj)\n+    {\n@@ -185,1 +197,2 @@\n-    public void visitInnerClasses(final InnerClasses obj) {\n+    public void visitLocalVariable(final LocalVariable obj)\n+    {\n@@ -189,1 +202,2 @@\n-    public void visitJavaClass(final JavaClass obj) {\n+    public void visitLocalVariableTable(final LocalVariableTable obj)\n+    {\n@@ -193,1 +207,2 @@\n-    public void visitLineNumber(final LineNumber obj) {\n+    public void visitMethod(final Method obj)\n+    {\n@@ -197,1 +212,2 @@\n-    public void visitLineNumberTable(final LineNumberTable obj) {\n+    public void visitSignature(final Signature obj)\n+    {\n@@ -201,1 +217,2 @@\n-    public void visitLocalVariable(final LocalVariable obj) {\n+    public void visitSourceFile(final SourceFile obj)\n+    {\n@@ -205,1 +222,7 @@\n-    public void visitLocalVariableTable(final LocalVariableTable obj) {\n+    public void visitSynthetic(final Synthetic obj)\n+    {\n+    }\n+\n+    @Override\n+    public void visitUnknown(final Unknown obj)\n+    {\n@@ -208,3 +231,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -212,1 +232,2 @@\n-    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj) {\n+    public void visitStackMap(final StackMap obj)\n+    {\n@@ -216,1 +237,2 @@\n-    public void visitMethod(final Method obj) {\n+    public void visitStackMapEntry(final StackMapEntry obj)\n+    {\n@@ -221,1 +243,4 @@\n-     * @Override public void visitStackMapTable(StackMapTable obj) { }\n+    @Override\n+    public void visitStackMapTable(StackMapTable obj)\n+    {\n+    }\n@@ -226,1 +251,4 @@\n-     * @Override public void visitStackMapTableEntry(StackMapTableEntry obj) { }\n+    @Override\n+    public void visitStackMapTableEntry(StackMapTableEntry obj)\n+    {\n+    }\n@@ -230,1 +258,1 @@\n-     * @since 6.4.0\n+     * @since 6.0\n@@ -233,1 +261,2 @@\n-    public void visitMethodParameter(final MethodParameter obj) {\n+    public void visitEnclosingMethod(final EnclosingMethod obj)\n+    {\n@@ -240,1 +269,2 @@\n-    public void visitMethodParameters(final MethodParameters obj) {\n+    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj)\n+    {\n@@ -243,1 +273,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -245,1 +277,2 @@\n-    public void visitModule(final Module obj) {\n+    public void visitMethodParameters(final MethodParameters obj)\n+    {\n@@ -248,1 +281,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.4.0\n+     *\/\n@@ -250,1 +285,2 @@\n-    public void visitModuleExports(final ModuleExports obj) {\n+    public void visitMethodParameter(final MethodParameter obj)\n+    {\n@@ -253,1 +289,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -255,1 +293,2 @@\n-    public void visitModuleMainClass(final ModuleMainClass obj) {\n+    public void visitConstantMethodType(final ConstantMethodType obj)\n+    {\n@@ -258,1 +297,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -260,1 +301,1 @@\n-    public void visitModuleOpens(final ModuleOpens obj) {\n+    public void visitConstantMethodHandle(final ConstantMethodHandle constantMethodHandle) {\n@@ -263,1 +304,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -265,1 +308,1 @@\n-    public void visitModulePackages(final ModulePackages obj) {\n+    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry parameterAnnotationEntry) {\n@@ -268,1 +311,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.1\n+     *\/\n@@ -270,1 +315,1 @@\n-    public void visitModuleProvides(final ModuleProvides obj) {\n+    public void visitConstantPackage(final ConstantPackage constantPackage) {\n@@ -273,1 +318,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.1\n+     *\/\n@@ -275,1 +322,1 @@\n-    public void visitModuleRequires(final ModuleRequires obj) {\n+    public void visitConstantModule(final ConstantModule constantModule) {\n@@ -278,1 +325,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.3\n+     *\/\n@@ -280,1 +329,1 @@\n-    public void visitNestHost(final NestHost obj) {\n+    public void visitConstantDynamic(final ConstantDynamic obj) {\n@@ -285,1 +334,1 @@\n-    public void visitNestMembers(final NestMembers obj) {\n+    public void visitModule(final Module obj) {\n@@ -288,3 +337,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -292,1 +339,1 @@\n-    public void visitParameterAnnotation(final ParameterAnnotations obj) {\n+    public void visitModuleRequires(final ModuleRequires obj) {\n@@ -295,3 +342,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -299,1 +344,1 @@\n-    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry parameterAnnotationEntry) {\n+    public void visitModuleExports(final ModuleExports obj) {\n@@ -302,0 +347,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -303,1 +349,1 @@\n-    public void visitSignature(final Signature obj) {\n+    public void visitModuleOpens(final ModuleOpens obj) {\n@@ -306,0 +352,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -307,1 +354,1 @@\n-    public void visitSourceFile(final SourceFile obj) {\n+    public void visitModuleProvides(final ModuleProvides obj) {\n@@ -310,0 +357,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -311,1 +359,1 @@\n-    public void visitStackMap(final StackMap obj) {\n+    public void visitModulePackages(final ModulePackages obj) {\n@@ -314,0 +362,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -315,1 +364,1 @@\n-    public void visitStackMapEntry(final StackMapEntry obj) {\n+    public void visitModuleMainClass(final ModuleMainClass obj) {\n@@ -318,0 +367,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -319,1 +369,1 @@\n-    public void visitSynthetic(final Synthetic obj) {\n+    public void visitNestHost(final NestHost obj) {\n@@ -322,0 +372,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -323,1 +374,1 @@\n-    public void visitUnknown(final Unknown obj) {\n+    public void visitNestMembers(final NestMembers obj) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EmptyVisitor.java","additions":150,"deletions":99,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,1 +31,2 @@\n- * This attribute exists for local or anonymous classes and ... there can be only one.\n+ * This attribute exists for local or\n+ * anonymous classes and ... there can be only one.\n@@ -44,1 +44,1 @@\n-    \/\/ Otherwise, the value of the method_index item must point to a\n+    \/\/ Otherwise, the value of the  method_index item must point to a\n@@ -47,1 +47,1 @@\n-    \/\/ to in the class_index. *It is the compiler responsibility* to\n+    \/\/ to in the class_index.  *It is the compiler responsibility* to\n@@ -57,4 +57,4 @@\n-    private EnclosingMethod(final int nameIndex, final int len, final int classIndex, final int methodIndex, final ConstantPool cpool) {\n-        super(Const.ATTR_ENCLOSING_METHOD, nameIndex, Args.require(len, 4, \"EnclosingMethod attribute length\"), cpool);\n-        this.classIndex = Args.requireU2(classIndex, 0, cpool.getLength(), \"EnclosingMethod class index\");\n-        this.methodIndex = Args.requireU2(methodIndex, \"EnclosingMethod method index\");\n+    private EnclosingMethod(final int nameIndex, final int len, final int classIdx,final int methodIdx, final ConstantPool cpool) {\n+        super(Const.ATTR_ENCLOSING_METHOD, nameIndex, len, cpool);\n+        classIndex  = classIdx;\n+        methodIndex = methodIdx;\n@@ -65,1 +65,1 @@\n-        v.visitEnclosingMethod(this);\n+      v.visitEnclosingMethod(this);\n@@ -69,1 +69,1 @@\n-    public Attribute copy(final ConstantPool constantPool) {\n+    public Attribute copy(final ConstantPool constant_pool) {\n@@ -73,11 +73,0 @@\n-    @Override\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        super.dump(file);\n-        file.writeShort(classIndex);\n-        file.writeShort(methodIndex);\n-    }\n-\n-    public final ConstantClass getEnclosingClass() {\n-        return super.getConstantPool().getConstant(classIndex, Const.CONSTANT_Class, ConstantClass.class);\n-    }\n-\n@@ -89,7 +78,0 @@\n-    public final ConstantNameAndType getEnclosingMethod() {\n-        if (methodIndex == 0) {\n-            return null;\n-        }\n-        return super.getConstantPool().getConstant(methodIndex, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n-    }\n-\n@@ -107,0 +89,22 @@\n+\n+    public final ConstantClass getEnclosingClass() {\n+        final ConstantClass c =\n+            (ConstantClass)super.getConstantPool().getConstant(classIndex,Const.CONSTANT_Class);\n+        return c;\n+    }\n+\n+    public final ConstantNameAndType getEnclosingMethod() {\n+        if (methodIndex == 0) {\n+            return null;\n+        }\n+        final ConstantNameAndType nat =\n+            (ConstantNameAndType)super.getConstantPool().getConstant(methodIndex,Const.CONSTANT_NameAndType);\n+        return nat;\n+    }\n+\n+    @Override\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        super.dump(file);\n+        file.writeShort(classIndex);\n+        file.writeShort(methodIndex);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EnclosingMethod.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -30,1 +32,2 @@\n-public class EnumElementValue extends ElementValue {\n+public class EnumElementValue extends ElementValue\n+{\n@@ -36,1 +39,3 @@\n-    public EnumElementValue(final int type, final int typeIdx, final int valueIdx, final ConstantPool cpool) {\n+    public EnumElementValue(final int type, final int typeIdx, final int valueIdx,\n+            final ConstantPool cpool)\n+    {\n@@ -39,1 +44,2 @@\n-            throw new ClassFormatException(\"Only element values of type enum can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type enum can be built with this ctor - type specified: \" + type);\n@@ -46,1 +52,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -52,2 +59,6 @@\n-    public String getEnumTypeString() {\n-        return super.getConstantPool().getConstantUtf8(typeIdx).getBytes();\n+    @Override\n+    public String stringifyValue()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(valueIdx,\n+                Const.CONSTANT_Utf8);\n+        return cu8.getBytes();\n@@ -56,2 +67,5 @@\n-    public String getEnumValueString() {\n-        return super.getConstantPool().getConstantUtf8(valueIdx).getBytes();\n+    public String getEnumTypeString()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(typeIdx,\n+                Const.CONSTANT_Utf8);\n+        return cu8.getBytes();\/\/ Utility.signatureToString(cu8.getBytes());\n@@ -60,2 +74,5 @@\n-    public int getTypeIndex() {\n-        return typeIdx;\n+    public String getEnumValueString()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(valueIdx,\n+                Const.CONSTANT_Utf8);\n+        return cu8.getBytes();\n@@ -64,1 +81,2 @@\n-    public int getValueIndex() {\n+    public int getValueIndex()\n+    {\n@@ -68,3 +86,3 @@\n-    @Override\n-    public String stringifyValue() {\n-        return super.getConstantPool().getConstantUtf8(valueIdx).getBytes();\n+    public int getTypeIndex()\n+    {\n+        return typeIdx;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EnumElementValue.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -26,1 +27,0 @@\n-import java.util.Arrays;\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,4 +31,6 @@\n- * This class represents the table of exceptions that are thrown by a method. This attribute may be used once per\n- * method. The name of this class is <em>ExceptionTable<\/em> for historical reasons; The Java Virtual Machine\n- * Specification, Second Edition defines this attribute using the name <em>Exceptions<\/em> (which is inconsistent with\n- * the other classes).\n+ * This class represents the table of exceptions that are thrown by a\n+ * method. This attribute may be used once per method.  The name of\n+ * this class is <em>ExceptionTable<\/em> for historical reasons; The\n+ * Java Virtual Machine Specification, Second Edition defines this\n+ * attribute using the name <em>Exceptions<\/em> (which is inconsistent\n+ * with the other classes).\n@@ -37,10 +38,1 @@\n- * <pre>\n- * Exceptions_attribute {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u2 number_of_exceptions;\n- *   u2 exception_index_table[number_of_exceptions];\n- * }\n- * <\/pre>\n- * @see Code\n- * @LastModified: Feb 2023\n+ * @see     Code\n@@ -52,0 +44,1 @@\n+\n@@ -53,4 +46,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -62,0 +53,14 @@\n+\n+    \/**\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param exceptionIndexTable Table of indices in constant pool\n+     * @param constant_pool Array of constants\n+     *\/\n+    public ExceptionTable(final int name_index, final int length, final int[] exceptionIndexTable,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_EXCEPTIONS, name_index, length, constant_pool);\n+        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : new int[0];\n+    }\n+\n+\n@@ -64,1 +69,0 @@\n-     *\n@@ -69,1 +73,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -73,3 +77,3 @@\n-        final int exceptionCount = input.readUnsignedShort();\n-        exceptionIndexTable = new int[exceptionCount];\n-        for (int i = 0; i < exceptionCount; i++) {\n+        final int number_of_exceptions = input.readUnsignedShort();\n+        exceptionIndexTable = new int[number_of_exceptions];\n+        for (int i = 0; i < number_of_exceptions; i++) {\n@@ -80,11 +84,0 @@\n-    \/**\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param exceptionIndexTable Table of indices in constant pool\n-     * @param constantPool Array of constants\n-     *\/\n-    public ExceptionTable(final int nameIndex, final int length, final int[] exceptionIndexTable, final ConstantPool constantPool) {\n-        super(Const.ATTR_EXCEPTIONS, nameIndex, length, constantPool);\n-        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : Const.EMPTY_INT_ARRAY;\n-        Args.requireU2(this.exceptionIndexTable.length, \"exceptionIndexTable.length\");\n-    }\n@@ -93,2 +86,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -99,1 +93,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -103,12 +97,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final ExceptionTable c = (ExceptionTable) clone();\n-        if (exceptionIndexTable != null) {\n-            c.exceptionIndexTable = exceptionIndexTable.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -120,1 +102,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -123,1 +105,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -131,0 +113,1 @@\n+\n@@ -138,0 +121,9 @@\n+\n+    \/**\n+     * @return Length of exception table.\n+     *\/\n+    public int getNumberOfExceptions() {\n+        return exceptionIndexTable == null ? 0 : exceptionIndexTable.length;\n+    }\n+\n+\n@@ -143,1 +135,4 @@\n-        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(exceptionIndexTable[i], Const.CONSTANT_Class)));\n+        for (int i = 0; i < exceptionIndexTable.length; i++) {\n+            names[i] = super.getConstantPool().getConstantString(exceptionIndexTable[i],\n+                    Const.CONSTANT_Class).replace('\/', '.');\n+        }\n@@ -147,6 +142,0 @@\n-    \/**\n-     * @return Length of exception table.\n-     *\/\n-    public int getNumberOfExceptions() {\n-        return exceptionIndexTable == null ? 0 : exceptionIndexTable.length;\n-    }\n@@ -155,2 +144,2 @@\n-     * @param exceptionIndexTable the list of exception indexes Also redefines number_of_exceptions according to table\n-     *        length.\n+     * @param exceptionIndexTable the list of exception indexes\n+     * Also redefines number_of_exceptions according to table length.\n@@ -158,2 +147,2 @@\n-    public void setExceptionIndexTable(final int[] exceptionIndexTable) {\n-        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : Const.EMPTY_INT_ARRAY;\n+    public void setExceptionIndexTable( final int[] exceptionIndexTable ) {\n+        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : new int[0];\n@@ -162,0 +151,1 @@\n+\n@@ -179,0 +169,16 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final ExceptionTable c = (ExceptionTable) clone();\n+        if (exceptionIndexTable != null) {\n+            c.exceptionIndexTable = new int[exceptionIndexTable.length];\n+            System.arraycopy(exceptionIndexTable, 0, c.exceptionIndexTable, 0,\n+                    exceptionIndexTable.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ExceptionTable.java","additions":71,"deletions":65,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -33,2 +33,3 @@\n- * This class represents the field info structure, i.e., the representation for a variable in the class. See JVM\n- * specification for details.\n+ * This class represents the field info structure, i.e., the representation\n+ * for a variable in the class. See JVM specification for details.\n+ *\n@@ -38,7 +39,0 @@\n-    \/**\n-     * Empty array constant.\n-     *\n-     * @since 6.6.0\n-     *\/\n-    public static final Field[] EMPTY_ARRAY = {};\n-\n@@ -48,1 +42,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -51,1 +45,2 @@\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName())\n+                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -54,0 +49,1 @@\n+\n@@ -55,1 +51,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -61,4 +57,0 @@\n-    \/**\n-     * Empty array.\n-     *\/\n-    static final Field[] EMPTY_FIELD_ARRAY = {};\n@@ -67,1 +59,2 @@\n-     * @return Comparison strategy object\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -69,2 +62,2 @@\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n+    public Field(final Field c) {\n+        super(c);\n@@ -73,6 +66,0 @@\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n-    }\n@@ -82,1 +69,0 @@\n-     *\n@@ -85,2 +71,3 @@\n-    Field(final DataInput file, final ConstantPool constantPool) throws IOException, ClassFormatException {\n-        super(file, constantPool);\n+    Field(final DataInput file, final ConstantPool constant_pool) throws IOException,\n+            ClassFormatException {\n+        super(file, constant_pool);\n@@ -89,9 +76,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public Field(final Field c) {\n-        super(c);\n-    }\n@@ -100,3 +78,3 @@\n-     * @param accessFlags Access rights of field\n-     * @param nameIndex Points to field name in constant pool\n-     * @param signatureIndex Points to encoded signature\n+     * @param access_flags Access rights of field\n+     * @param name_index Points to field name in constant pool\n+     * @param signature_index Points to encoded signature\n@@ -104,1 +82,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -106,2 +84,3 @@\n-    public Field(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes, final ConstantPool constantPool) {\n-        super(accessFlags, nameIndex, signatureIndex, attributes, constantPool);\n+    public Field(final int access_flags, final int name_index, final int signature_index, final Attribute[] attributes,\n+            final ConstantPool constant_pool) {\n+        super(access_flags, name_index, signature_index, attributes, constant_pool);\n@@ -110,0 +89,1 @@\n+\n@@ -111,2 +91,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -117,1 +98,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -121,17 +102,0 @@\n-    \/**\n-     * @return deep copy of this field\n-     *\/\n-    public Field copy(final ConstantPool constantPool) {\n-        return (Field) copy_(constantPool);\n-    }\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default two Field objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see Object#equals(Object)\n-     *\/\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n-    }\n@@ -151,6 +115,0 @@\n-    \/**\n-     * @return type of field\n-     *\/\n-    public Type getType() {\n-        return Type.getReturnType(getSignature());\n-    }\n@@ -159,12 +117,2 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the field's name XOR\n-     * signature.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    \/**\n-     * Return string representation close to declaration format, 'public static final short MAX = 100', e.g..\n+     * Return string representation close to declaration format,\n+     * `public static final short MAX = 100', e.g..\n@@ -182,1 +130,1 @@\n-        access = access.isEmpty() ? \"\" : access + \" \";\n+        access = access.isEmpty() ? \"\" : (access + \" \");\n@@ -198,0 +146,57 @@\n+\n+\n+    \/**\n+     * @return deep copy of this field\n+     *\/\n+    public Field copy( final ConstantPool _constant_pool ) {\n+        return (Field) copy_(_constant_pool);\n+    }\n+\n+\n+    \/**\n+     * @return type of field\n+     *\/\n+    public Type getType() {\n+        return Type.getReturnType(getSignature());\n+    }\n+\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two Field objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the field's name XOR signature.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Field.java","additions":87,"deletions":82,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-import java.util.Arrays;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -34,24 +35,4 @@\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int name_index; \/\/ Points to field name in constant pool\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int signature_index; \/\/ Points to encoded signature\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected Attribute[] attributes; \/\/ Collection of attributes\n-\n-    \/**\n-     * @deprecated (since 6.0) will be removed (not needed)\n-     *\/\n-    @java.lang.Deprecated\n-    protected int attributes_count; \/\/ No. of attributes\n+    private int name_index; \/\/ Points to field name in constant pool\n+    private int signature_index; \/\/ Points to encoded signature\n+    private Attribute[] attributes; \/\/ Collection of attributes\n+    private int attributes_count; \/\/ No. of attributes\n@@ -62,5 +43,1 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected ConstantPool constant_pool;\n+    private ConstantPool constant_pool;\n@@ -68,2 +45,2 @@\n-    private String signatureAttributeString;\n-    private boolean searchedForSignatureAttribute;\n+    private String signatureAttributeString = null;\n+    private boolean searchedForSignatureAttribute = false;\n@@ -74,0 +51,1 @@\n+\n@@ -75,4 +53,2 @@\n-     * Construct object from file stream.\n-     *\n-     * @param file Input stream\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -80,8 +56,3 @@\n-    protected FieldOrMethod(final DataInput file, final ConstantPool constantPool) throws IOException {\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null, constantPool);\n-        final int attributesCount = file.readUnsignedShort();\n-        attributes = new Attribute[attributesCount];\n-        for (int i = 0; i < attributesCount; i++) {\n-            attributes[i] = Attribute.readAttribute(file, constantPool);\n-        }\n-        this.attributes_count = attributesCount; \/\/ init deprecated field\n+    protected FieldOrMethod(final FieldOrMethod c) {\n+        this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(),\n+                c.getAttributes(), c.getConstantPool());\n@@ -90,0 +61,1 @@\n+\n@@ -94,1 +66,2 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -98,2 +71,4 @@\n-    protected FieldOrMethod(final DataInputStream file, final ConstantPool constantPool) throws IOException {\n-        this((DataInput) file, constantPool);\n+    protected FieldOrMethod(final DataInputStream file, final ConstantPool constant_pool)\n+            throws IOException,\n+            ClassFormatException {\n+        this((DataInput) file, constant_pool);\n@@ -103,4 +78,4 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from file stream.\n+     * @param file Input stream\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -108,2 +83,10 @@\n-    protected FieldOrMethod(final FieldOrMethod c) {\n-        this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(), c.getAttributes(), c.getConstantPool());\n+    protected FieldOrMethod(final DataInput file, final ConstantPool constant_pool)\n+            throws IOException, ClassFormatException {\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null,\n+                constant_pool);\n+        final int attributes_count = file.readUnsignedShort();\n+        attributes = new Attribute[attributes_count];\n+        for (int i = 0; i < attributes_count; i++) {\n+            attributes[i] = Attribute.readAttribute(file, constant_pool);\n+        }\n+        this.attributes_count = attributes_count; \/\/ init deprecated field\n@@ -112,0 +95,1 @@\n+\n@@ -113,3 +97,3 @@\n-     * @param accessFlags Access rights of method\n-     * @param nameIndex Points to field name in constant pool\n-     * @param signatureIndex Points to encoded signature\n+     * @param access_flags Access rights of method\n+     * @param name_index Points to field name in constant pool\n+     * @param signature_index Points to encoded signature\n@@ -117,1 +101,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -119,6 +103,6 @@\n-    protected FieldOrMethod(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes,\n-        final ConstantPool constantPool) {\n-        super(accessFlags);\n-        this.name_index = nameIndex;\n-        this.signature_index = signatureIndex;\n-        this.constant_pool = constantPool;\n+    protected FieldOrMethod(final int access_flags, final int name_index, final int signature_index,\n+            final Attribute[] attributes, final ConstantPool constant_pool) {\n+        super(access_flags);\n+        this.name_index = name_index;\n+        this.signature_index = signature_index;\n+        this.constant_pool = constant_pool;\n@@ -128,15 +112,0 @@\n-    \/**\n-     * @return deep copy of this field\n-     *\/\n-    protected FieldOrMethod copy_(final ConstantPool constantPool) {\n-        try {\n-            final FieldOrMethod c = (FieldOrMethod) clone();\n-            c.constant_pool = constantPool;\n-            c.attributes = new Attribute[attributes.length];\n-            c.attributes_count = attributes_count; \/\/ init deprecated field\n-            Arrays.setAll(c.attributes, i -> attributes[i].copy(constantPool));\n-            return c;\n-        } catch (final CloneNotSupportedException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n@@ -148,1 +117,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -162,11 +131,0 @@\n-    \/**\n-     * @return Annotations on the field or method\n-     * @since 6.0\n-     *\/\n-    public AnnotationEntry[] getAnnotationEntries() {\n-        if (annotationEntries == null) {\n-            annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());\n-        }\n-\n-        return annotationEntries;\n-    }\n@@ -181,0 +139,1 @@\n+\n@@ -182,1 +141,1 @@\n-     * @return Constant pool used by this object.\n+     * @param attributes Collection of object attributes.\n@@ -184,2 +143,3 @@\n-    public final ConstantPool getConstantPool() {\n-        return constant_pool;\n+    public final void setAttributes( final Attribute[] attributes ) {\n+        this.attributes = attributes;\n+        this.attributes_count = attributes != null ? attributes.length : 0; \/\/ init deprecated field\n@@ -188,0 +148,1 @@\n+\n@@ -189,5 +150,1 @@\n-     * Hunts for a signature attribute on the member and returns its contents. So where the 'regular' signature may be\n-     * (Ljava\/util\/Vector;)V the signature attribute may in fact say 'Ljava\/lang\/Vector&lt;Ljava\/lang\/String&gt;;' Coded for\n-     * performance - searches for the attribute only when requested - only searches for it once.\n-     *\n-     * @since 6.0\n+     * @return Constant pool used by this object.\n@@ -195,12 +152,2 @@\n-    public final String getGenericSignature() {\n-        if (!searchedForSignatureAttribute) {\n-            boolean found = false;\n-            for (int i = 0; !found && i < attributes.length; i++) {\n-                if (attributes[i] instanceof Signature) {\n-                    signatureAttributeString = ((Signature) attributes[i]).getSignature();\n-                    found = true;\n-                }\n-            }\n-            searchedForSignatureAttribute = true;\n-        }\n-        return signatureAttributeString;\n+    public final ConstantPool getConstantPool() {\n+        return constant_pool;\n@@ -209,0 +156,1 @@\n+\n@@ -210,1 +158,1 @@\n-     * @return Name of object, i.e., method name or field name\n+     * @param constant_pool Constant pool to be used for this object.\n@@ -212,2 +160,2 @@\n-    public final String getName() {\n-        return constant_pool.getConstantUtf8(name_index).getBytes();\n+    public final void setConstantPool( final ConstantPool constant_pool ) {\n+        this.constant_pool = constant_pool;\n@@ -216,0 +164,1 @@\n+\n@@ -223,0 +172,1 @@\n+\n@@ -224,1 +174,1 @@\n-     * @return String representation of object's type signature (java style)\n+     * @param name_index Index in constant pool of object's name.\n@@ -226,2 +176,2 @@\n-    public final String getSignature() {\n-        return constant_pool.getConstantUtf8(signature_index).getBytes();\n+    public final void setNameIndex( final int name_index ) {\n+        this.name_index = name_index;\n@@ -230,0 +180,1 @@\n+\n@@ -237,0 +188,1 @@\n+\n@@ -238,1 +190,1 @@\n-     * @param attributes Collection of object attributes.\n+     * @param signature_index Index in constant pool of field signature.\n@@ -240,3 +192,2 @@\n-    public final void setAttributes(final Attribute[] attributes) {\n-        this.attributes = attributes;\n-        this.attributes_count = attributes != null ? attributes.length : 0; \/\/ init deprecated field\n+    public final void setSignatureIndex( final int signature_index ) {\n+        this.signature_index = signature_index;\n@@ -245,0 +196,1 @@\n+\n@@ -246,1 +198,1 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * @return Name of object, i.e., method name or field name\n@@ -248,2 +200,4 @@\n-    public final void setConstantPool(final ConstantPool constantPool) {\n-        this.constant_pool = constantPool;\n+    public final String getName() {\n+        ConstantUtf8 c;\n+        c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -252,0 +206,1 @@\n+\n@@ -253,1 +208,1 @@\n-     * @param nameIndex Index in constant pool of object's name.\n+     * @return String representation of object's type signature (java style)\n@@ -255,2 +210,4 @@\n-    public final void setNameIndex(final int nameIndex) {\n-        this.name_index = nameIndex;\n+    public final String getSignature() {\n+        ConstantUtf8 c;\n+        c = (ConstantUtf8) constant_pool.getConstant(signature_index, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -259,0 +216,1 @@\n+\n@@ -260,1 +218,1 @@\n-     * @param signatureIndex Index in constant pool of field signature.\n+     * @return deep copy of this field\n@@ -262,2 +220,59 @@\n-    public final void setSignatureIndex(final int signatureIndex) {\n-        this.signature_index = signatureIndex;\n+    protected FieldOrMethod copy_( final ConstantPool _constant_pool ) {\n+        FieldOrMethod c = null;\n+\n+        try {\n+          c = (FieldOrMethod)clone();\n+        } catch(final CloneNotSupportedException e) {\n+            \/\/ ignored, but will cause NPE ...\n+        }\n+\n+        c.constant_pool    = constant_pool;\n+        c.attributes       = new Attribute[attributes.length];\n+        c.attributes_count = attributes_count; \/\/ init deprecated field\n+\n+        for (int i = 0; i < attributes.length; i++) {\n+            c.attributes[i] = attributes[i].copy(constant_pool);\n+        }\n+\n+        return c;\n+    }\n+\n+    \/**\n+     * @return Annotations on the field or method\n+     * @since 6.0\n+     *\/\n+    public AnnotationEntry[] getAnnotationEntries() {\n+        if (annotationEntries == null) {\n+            annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());\n+        }\n+\n+        return annotationEntries;\n+    }\n+\n+    \/**\n+     * Hunts for a signature attribute on the member and returns its contents.\n+     * So where the 'regular' signature may be (Ljava\/util\/Vector;)V the\n+     * signature attribute may in fact say\n+     * 'Ljava\/lang\/Vector&lt;Ljava\/lang\/String&gt;;' Coded for performance -\n+     * searches for the attribute only when requested - only searches for it\n+     * once.\n+     *\n+     * @since 6.0\n+     *\/\n+    public final String getGenericSignature()\n+    {\n+        if (!searchedForSignatureAttribute)\n+        {\n+            boolean found = false;\n+            for (int i = 0; !found && i < attributes.length; i++)\n+            {\n+                if (attributes[i] instanceof Signature)\n+                {\n+                    signatureAttributeString = ((Signature) attributes[i])\n+                            .getSignature();\n+                    found = true;\n+                }\n+            }\n+            searchedForSignatureAttribute = true;\n+        }\n+        return signatureAttributeString;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/FieldOrMethod.java","additions":144,"deletions":129,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * This class represents a inner class attribute, i.e., the class indices of the inner and outer classes, the name and\n- * the attributes of the inner class.\n+ * This class represents a inner class attribute, i.e., the class\n+ * indices of the inner and outer classes, the name and the attributes\n+ * of the inner class.\n@@ -43,0 +44,1 @@\n+\n@@ -44,4 +46,1 @@\n-     * Construct object from file stream.\n-     *\n-     * @param file Input stream\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object.\n@@ -49,2 +48,3 @@\n-    InnerClass(final DataInput file) throws IOException {\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort());\n+    public InnerClass(final InnerClass c) {\n+        this(c.getInnerClassIndex(), c.getOuterClassIndex(), c.getInnerNameIndex(), c\n+                .getInnerAccessFlags());\n@@ -53,0 +53,1 @@\n+\n@@ -54,3 +55,3 @@\n-     * Initialize from another object.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from file stream.\n+     * @param file Input stream\n+     * @throws IOException\n@@ -58,2 +59,3 @@\n-    public InnerClass(final InnerClass c) {\n-        this(c.getInnerClassIndex(), c.getOuterClassIndex(), c.getInnerNameIndex(), c.getInnerAccessFlags());\n+    InnerClass(final DataInput file) throws IOException {\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n+                .readUnsignedShort());\n@@ -62,0 +64,1 @@\n+\n@@ -65,1 +68,1 @@\n-     * @param innerNameIndex Name index in constant pool of inner class\n+     * @param innerNameIndex  Name index in constant pool of inner class\n@@ -68,1 +71,2 @@\n-    public InnerClass(final int innerClassIndex, final int outerClassIndex, final int innerNameIndex, final int innerAccessFlags) {\n+    public InnerClass(final int innerClassIndex, final int outerClassIndex, final int innerNameIndex,\n+            final int innerAccessFlags) {\n@@ -75,0 +79,1 @@\n+\n@@ -76,2 +81,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -82,1 +88,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -86,11 +92,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public InnerClass copy() {\n-        try {\n-            return (InnerClass) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n@@ -102,1 +97,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -104,1 +99,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -111,0 +106,1 @@\n+\n@@ -118,0 +114,1 @@\n+\n@@ -125,0 +122,1 @@\n+\n@@ -132,0 +130,1 @@\n+\n@@ -139,0 +138,1 @@\n+\n@@ -142,1 +142,1 @@\n-    public void setInnerAccessFlags(final int innerAccessFlags) {\n+    public void setInnerAccessFlags( final int innerAccessFlags ) {\n@@ -146,0 +146,1 @@\n+\n@@ -149,1 +150,1 @@\n-    public void setInnerClassIndex(final int innerClassIndex) {\n+    public void setInnerClassIndex( final int innerClassIndex ) {\n@@ -153,0 +154,1 @@\n+\n@@ -156,1 +158,1 @@\n-    public void setInnerNameIndex(final int innerNameIndex) { \/\/ TODO unused\n+    public void setInnerNameIndex( final int innerNameIndex ) { \/\/ TODO unused\n@@ -160,0 +162,1 @@\n+\n@@ -163,1 +166,1 @@\n-    public void setOuterClassIndex(final int outerClassIndex) { \/\/ TODO unused\n+    public void setOuterClassIndex( final int outerClassIndex ) { \/\/ TODO unused\n@@ -167,0 +170,1 @@\n+\n@@ -172,1 +176,2 @@\n-        return \"InnerClass(\" + innerClassIndex + \", \" + outerClassIndex + \", \" + innerNameIndex + \", \" + innerAccessFlags + \")\";\n+        return \"InnerClass(\" + innerClassIndex + \", \" + outerClassIndex + \", \"\n+                + innerNameIndex + \", \" + innerAccessFlags + \")\";\n@@ -175,0 +180,1 @@\n+\n@@ -178,5 +184,6 @@\n-    public String toString(final ConstantPool constantPool) {\n-        String outerClassName;\n-        String innerName;\n-        String innerClassName = constantPool.getConstantString(innerClassIndex, Const.CONSTANT_Class);\n-        innerClassName = Utility.compactClassName(innerClassName, false);\n+    public String toString( final ConstantPool constantPool ) {\n+        String outer_class_name;\n+        String inner_name;\n+        String inner_class_name = constantPool.getConstantString(innerClassIndex,\n+                Const.CONSTANT_Class);\n+        inner_class_name = Utility.compactClassName(inner_class_name, false);\n@@ -184,2 +191,3 @@\n-            outerClassName = constantPool.getConstantString(outerClassIndex, Const.CONSTANT_Class);\n-            outerClassName = \" of class \" + Utility.compactClassName(outerClassName, false);\n+            outer_class_name = constantPool.getConstantString(outerClassIndex,\n+                    Const.CONSTANT_Class);\n+            outer_class_name = \" of class \" + Utility.compactClassName(outer_class_name, false);\n@@ -187,1 +195,1 @@\n-            outerClassName = \"\";\n+            outer_class_name = \"\";\n@@ -190,1 +198,2 @@\n-            innerName = constantPool.getConstantUtf8(innerNameIndex).getBytes();\n+            inner_name = ((ConstantUtf8) constantPool.getConstant(innerNameIndex,\n+                    Const.CONSTANT_Utf8)).getBytes();\n@@ -192,1 +201,1 @@\n-            innerName = \"(anonymous)\";\n+            inner_name = \"(anonymous)\";\n@@ -195,2 +204,15 @@\n-        access = access.isEmpty() ? \"\" : access + \" \";\n-        return \"  \" + access + innerName + \"=class \" + innerClassName + outerClassName;\n+        access = access.isEmpty() ? \"\" : (access + \" \");\n+        return \"  \" + access + inner_name + \"=class \" + inner_class_name + outer_class_name;\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public InnerClass copy() {\n+        try {\n+            return (InnerClass) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InnerClass.java","additions":70,"deletions":48,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -32,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -35,2 +31,4 @@\n- * This class is derived from <em>Attribute<\/em> and denotes that this class is an Inner class of another. to the source\n- * file of this class. It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and denotes that this class\n+ * is an Inner class of another.\n+ * to the source file of this class.\n+ * It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n@@ -38,1 +36,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -40,6 +38,1 @@\n-public final class InnerClasses extends Attribute implements Iterable<InnerClass> {\n-\n-    \/**\n-     * Empty array.\n-     *\/\n-    private static final InnerClass[] EMPTY_INNER_CLASSE_ARRAY = {};\n+public final class InnerClasses extends Attribute {\n@@ -49,0 +42,1 @@\n+\n@@ -50,4 +44,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -59,0 +51,14 @@\n+\n+    \/**\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param innerClasses array of inner classes attributes\n+     * @param constant_pool Array of constants\n+     *\/\n+    public InnerClasses(final int name_index, final int length, final InnerClass[] innerClasses,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_INNER_CLASSES, name_index, length, constant_pool);\n+        this.innerClasses = innerClasses != null ? innerClasses : new InnerClass[0];\n+    }\n+\n+\n@@ -62,1 +68,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -65,2 +71,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -68,5 +74,6 @@\n-    InnerClasses(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (InnerClass[]) null, constantPool);\n-        final int classCount = input.readUnsignedShort();\n-        innerClasses = new InnerClass[classCount];\n-        for (int i = 0; i < classCount; i++) {\n+    InnerClasses(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (InnerClass[]) null, constant_pool);\n+        final int number_of_classes = input.readUnsignedShort();\n+        innerClasses = new InnerClass[number_of_classes];\n+        for (int i = 0; i < number_of_classes; i++) {\n@@ -77,11 +84,0 @@\n-    \/**\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param innerClasses array of inner classes attributes\n-     * @param constantPool Array of constants\n-     *\/\n-    public InnerClasses(final int nameIndex, final int length, final InnerClass[] innerClasses, final ConstantPool constantPool) {\n-        super(Const.ATTR_INNER_CLASSES, nameIndex, length, constantPool);\n-        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_INNER_CLASSE_ARRAY;\n-        Args.requireU2(this.innerClasses.length, \"innerClasses.length\");\n-    }\n@@ -90,2 +86,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -96,1 +93,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -100,12 +97,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        \/\/ TODO this could be recoded to use a lower level constructor after creating a copy of the inner classes\n-        final InnerClasses c = (InnerClasses) clone();\n-        c.innerClasses = new InnerClass[innerClasses.length];\n-        Arrays.setAll(c.innerClasses, i -> innerClasses[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -117,1 +102,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -120,1 +105,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -123,2 +108,2 @@\n-        for (final InnerClass innerClass : innerClasses) {\n-            innerClass.dump(file);\n+        for (final InnerClass inner_class : innerClasses) {\n+            inner_class.dump(file);\n@@ -128,0 +113,1 @@\n+\n@@ -135,4 +121,0 @@\n-    @Override\n-    public Iterator<InnerClass> iterator() {\n-        return Stream.of(innerClasses).iterator();\n-    }\n@@ -143,2 +125,2 @@\n-    public void setInnerClasses(final InnerClass[] innerClasses) {\n-        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_INNER_CLASSE_ARRAY;\n+    public void setInnerClasses( final InnerClass[] innerClasses ) {\n+        this.innerClasses = innerClasses != null ? innerClasses : new InnerClass[0];\n@@ -147,0 +129,1 @@\n+\n@@ -156,2 +139,2 @@\n-        for (final InnerClass innerClass : innerClasses) {\n-            buf.append(innerClass.toString(super.getConstantPool())).append(\"\\n\");\n+        for (final InnerClass inner_class : innerClasses) {\n+            buf.append(inner_class.toString(super.getConstantPool())).append(\"\\n\");\n@@ -159,1 +142,17 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        \/\/ TODO this could be recoded to use a lower level constructor after creating a copy of the inner classes\n+        final InnerClasses c = (InnerClasses) clone();\n+        c.innerClasses = new InnerClass[innerClasses.length];\n+        for (int i = 0; i < innerClasses.length; i++) {\n+            c.innerClasses[i] = innerClasses[i].copy();\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InnerClasses.java","additions":63,"deletions":64,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n@@ -32,1 +30,0 @@\n-import java.util.Set;\n@@ -34,0 +31,2 @@\n+import java.util.List;\n+import java.util.Set;\n@@ -43,5 +42,7 @@\n- * Represents a Java class, i.e., the data structures, constant pool, fields, methods and commands contained in a Java\n- * .class file. See <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/\">JVM specification<\/a> for details. The intent of\n- * this class is to represent a parsed or otherwise existing class file. Those interested in programmatically generating\n- * classes should see the <a href=\"..\/generic\/ClassGen.html\">ClassGen<\/a> class.\n- *\n+ * Represents a Java class, i.e., the data structures, constant pool,\n+ * fields, methods and commands contained in a Java .class file.\n+ * See <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/\">JVM specification<\/a> for details.\n+ * The intent of this class is to represent a parsed or otherwise existing\n+ * class file.  Those interested in programatically generating classes\n+ * should see the <a href=\"..\/generic\/ClassGen.html\">ClassGen<\/a> class.\n+\n@@ -49,1 +50,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -53,56 +54,0 @@\n-    \/**\n-     * The standard class file extension.\n-     *\n-     * @since 6.7.0\n-     *\/\n-    public static final String EXTENSION = \".class\";\n-\n-    \/**\n-     * Empty array.\n-     *\n-     * @since 6.6.0\n-     *\/\n-    public static final JavaClass[] EMPTY_ARRAY = {};\n-\n-    public static final byte HEAP = 1;\n-    public static final byte FILE = 2;\n-    public static final byte ZIP = 3;\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n-\n-        @Override\n-        public boolean equals(final Object o1, final Object o2) {\n-            final JavaClass THIS = (JavaClass) o1;\n-            final JavaClass THAT = (JavaClass) o2;\n-            return Objects.equals(THIS.getClassName(), THAT.getClassName());\n-        }\n-\n-        @Override\n-        public int hashCode(final Object o) {\n-            final JavaClass THIS = (JavaClass) o;\n-            return THIS.getClassName().hashCode();\n-        }\n-    };\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-    private static String indent(final Object obj) {\n-        final StringTokenizer tokenizer = new StringTokenizer(obj.toString(), \"\\n\");\n-        final StringBuilder buf = new StringBuilder();\n-        while (tokenizer.hasMoreTokens()) {\n-            buf.append(\"\\t\").append(tokenizer.nextToken()).append(\"\\n\");\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n-    }\n-\n@@ -110,1 +55,1 @@\n-    private final String packageName;\n+    private String packageName;\n@@ -124,2 +69,1 @@\n-\n-    private AnnotationEntry[] annotations; \/\/ annotations defined on the class\n+    private AnnotationEntry[] annotations;   \/\/ annotations defined on the class\n@@ -127,0 +71,7 @@\n+    private boolean isAnonymous = false;\n+    private boolean isNested = false;\n+    private boolean computedNestedTypeStatus = false;\n+    public static final byte HEAP = 1;\n+    public static final byte FILE = 2;\n+    public static final byte ZIP = 3;\n+    private static final boolean debug = false;\n@@ -128,1 +79,1 @@\n-    private boolean isAnonymous;\n+    private static BCELComparator bcelComparator = new BCELComparator() {\n@@ -130,1 +81,6 @@\n-    private boolean isNested;\n+        @Override\n+        public boolean equals( final Object o1, final Object o2 ) {\n+            final JavaClass THIS = (JavaClass) o1;\n+            final JavaClass THAT = (JavaClass) o2;\n+            return Objects.equals(THIS.getClassName(), THAT.getClassName());\n+        }\n@@ -132,1 +88,0 @@\n-    private boolean computedNestedTypeStatus;\n@@ -134,0 +89,6 @@\n+        @Override\n+        public int hashCode( final Object o ) {\n+            final JavaClass THIS = (JavaClass) o;\n+            return THIS.getClassName().hashCode();\n+        }\n+    };\n@@ -135,2 +96,3 @@\n-     * In cases where we go ahead and create something, use the default SyntheticRepository, because we don't know any\n-     * better.\n+     * In cases where we go ahead and create something,\n+     * use the default SyntheticRepository, because we\n+     * don't know any better.\n@@ -138,1 +100,2 @@\n-    private transient com.sun.org.apache.bcel.internal.util.Repository repository = SyntheticRepository.getInstance();\n+    private transient com.sun.org.apache.bcel.internal.util.Repository repository\n+            = SyntheticRepository.getInstance();\n@@ -140,19 +103,0 @@\n-    \/**\n-     * Constructor gets all contents as arguments.\n-     *\n-     * @param classNameIndex Class name\n-     * @param superclassNameIndex Superclass name\n-     * @param fileName File name\n-     * @param major Major compiler version\n-     * @param minor Minor compiler version\n-     * @param accessFlags Access rights defined by bit flags\n-     * @param constantPool Array of constants\n-     * @param interfaces Implemented interfaces\n-     * @param fields Class fields\n-     * @param methods Class methods\n-     * @param attributes Class attributes\n-     *\/\n-    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int accessFlags,\n-        final ConstantPool constantPool, final int[] interfaces, final Field[] fields, final Method[] methods, final Attribute[] attributes) {\n-        this(classNameIndex, superclassNameIndex, fileName, major, minor, accessFlags, constantPool, interfaces, fields, methods, attributes, HEAP);\n-    }\n@@ -163,3 +107,4 @@\n-     * @param classNameIndex Index into constant pool referencing a ConstantClass that represents this class.\n-     * @param superclassNameIndex Index into constant pool referencing a ConstantClass that represents this class's\n-     *        superclass.\n+     * @param classNameIndex Index into constant pool referencing a\n+     * ConstantClass that represents this class.\n+     * @param superclassNameIndex Index into constant pool referencing a\n+     * ConstantClass that represents this class's superclass.\n@@ -169,1 +114,1 @@\n-     * @param accessFlags Access rights defined by bit flags\n+     * @param access_flags Access rights defined by bit flags\n@@ -177,3 +122,5 @@\n-    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int accessFlags,\n-        final ConstantPool constantPool, int[] interfaces, Field[] fields, Method[] methods, Attribute[] attributes, final byte source) {\n-        super(accessFlags);\n+    public JavaClass(final int classNameIndex, final int superclassNameIndex,\n+            final String fileName, final int major, final int minor, final int access_flags,\n+            final ConstantPool constantPool, int[] interfaces, Field[] fields,\n+            Method[] methods, Attribute[] attributes, final byte source) {\n+        super(access_flags);\n@@ -181,1 +128,1 @@\n-            interfaces = Const.EMPTY_INT_ARRAY;\n+            interfaces = new int[0];\n@@ -184,1 +131,1 @@\n-            attributes = Attribute.EMPTY_ARRAY;\n+            attributes = new Attribute[0];\n@@ -187,1 +134,1 @@\n-            fields = Field.EMPTY_FIELD_ARRAY;\n+            fields = new Field[0];\n@@ -190,1 +137,1 @@\n-            methods = Method.EMPTY_METHOD_ARRAY;\n+            methods = new Method[0];\n@@ -210,3 +157,3 @@\n-        \/*\n-         * According to the specification the following entries must be of type 'ConstantClass' but we check that anyway via the\n-         * 'ConstPool.getConstant' method.\n+        \/* According to the specification the following entries must be of type\n+         * `ConstantClass' but we check that anyway via the\n+         * `ConstPool.getConstant' method.\n@@ -224,1 +171,2 @@\n-            superclassName = constantPool.getConstantString(superclassNameIndex, Const.CONSTANT_Class);\n+            superclassName = constantPool.getConstantString(superclassNameIndex,\n+                    Const.CONSTANT_Class);\n@@ -236,0 +184,1 @@\n+\n@@ -237,2 +186,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Constructor gets all contents as arguments.\n@@ -240,1 +188,11 @@\n-     * @param v Visitor object\n+     * @param classNameIndex Class name\n+     * @param superclassNameIndex Superclass name\n+     * @param fileName File name\n+     * @param major Major compiler version\n+     * @param minor Minor compiler version\n+     * @param access_flags Access rights defined by bit flags\n+     * @param constantPool Array of constants\n+     * @param interfaces Implemented interfaces\n+     * @param fields Class fields\n+     * @param methods Class methods\n+     * @param attributes Class attributes\n@@ -242,3 +200,6 @@\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitJavaClass(this);\n+    public JavaClass(final int classNameIndex, final int superclassNameIndex,\n+            final String fileName, final int major, final int minor, final int access_flags,\n+            final ConstantPool constantPool, final int[] interfaces, final Field[] fields,\n+            final Method[] methods, final Attribute[] attributes) {\n+        this(classNameIndex, superclassNameIndex, fileName, major, minor, access_flags,\n+                constantPool, interfaces, fields, methods, attributes, HEAP);\n@@ -247,0 +208,1 @@\n+\n@@ -248,1 +210,3 @@\n-     * Return the natural ordering of two JavaClasses. This ordering is based on the class name\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -250,1 +214,1 @@\n-     * @since 6.0\n+     * @param v Visitor object\n@@ -253,2 +217,2 @@\n-    public int compareTo(final JavaClass obj) {\n-        return getClassName().compareTo(obj.getClassName());\n+    public void accept( final Visitor v ) {\n+        v.visitJavaClass(this);\n@@ -257,3 +221,6 @@\n-    private void computeNestedTypeStatus() {\n-        if (computedNestedTypeStatus) {\n-            return;\n+\n+    \/* Print debug information depending on `JavaClass.debug'\n+     *\/\n+    static void Debug( final String str ) {\n+        if (debug) {\n+            System.out.println(str);\n@@ -261,16 +228,17 @@\n-        for (final Attribute attribute : this.attributes) {\n-            if (attribute instanceof InnerClasses) {\n-                ((InnerClasses) attribute).forEach(innerClass ->  {\n-                    boolean innerClassAttributeRefersToMe = false;\n-                    String innerClassName = constantPool.getConstantString(innerClass.getInnerClassIndex(), Const.CONSTANT_Class);\n-                    innerClassName = Utility.compactClassName(innerClassName, false);\n-                    if (innerClassName.equals(getClassName())) {\n-                        innerClassAttributeRefersToMe = true;\n-                    }\n-                    if (innerClassAttributeRefersToMe) {\n-                        this.isNested = true;\n-                        if (innerClass.getInnerNameIndex() == 0) {\n-                            this.isAnonymous = true;\n-                        }\n-                    }\n-                });\n+    }\n+\n+\n+    \/**\n+     * Dump class to a file.\n+     *\n+     * @param file Output file\n+     * @throws IOException\n+     *\/\n+    public void dump(final File file) throws IOException {\n+        final String parent = file.getParent();\n+        if (parent != null) {\n+            final File dir = new File(parent);\n+            if (!dir.mkdirs()) { \/\/ either was not created or already existed\n+                if (!dir.isDirectory()) {\n+                    throw new IOException(\"Could not create the directory \" + dir);\n+                }\n@@ -279,1 +247,3 @@\n-        this.computedNestedTypeStatus = true;\n+        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n+            dump(dos);\n+        }\n@@ -282,0 +252,1 @@\n+\n@@ -283,1 +254,4 @@\n-     * @return deep copy of this class\n+     * Dump class to a file named fileName.\n+     *\n+     * @param _file_name Output file name\n+     * @throws IOException\n@@ -285,1 +259,11 @@\n-    public JavaClass copy() {\n+    public void dump( final String _file_name ) throws IOException {\n+        dump(new File(_file_name));\n+    }\n+\n+\n+    \/**\n+     * @return class in binary format\n+     *\/\n+    public byte[] getBytes() {\n+        final ByteArrayOutputStream s = new ByteArrayOutputStream();\n+        final DataOutputStream ds = new DataOutputStream(s);\n@@ -287,13 +271,9 @@\n-            final JavaClass c = (JavaClass) clone();\n-            c.constantPool = constantPool.copy();\n-            c.interfaces = interfaces.clone();\n-            c.interfaceNames = interfaceNames.clone();\n-            c.fields = new Field[fields.length];\n-            Arrays.setAll(c.fields, i -> fields[i].copy(c.constantPool));\n-            c.methods = new Method[methods.length];\n-            Arrays.setAll(c.methods, i -> methods[i].copy(c.constantPool));\n-            c.attributes = new Attribute[attributes.length];\n-            Arrays.setAll(c.attributes, i -> attributes[i].copy(c.constantPool));\n-            return c;\n-        } catch (final CloneNotSupportedException e) {\n-            return null;\n+            dump(ds);\n+        } catch (final IOException e) {\n+            System.err.println(\"Error dumping class: \" + e.getMessage());\n+        } finally {\n+            try {\n+                ds.close();\n+            } catch (final IOException e2) {\n+                System.err.println(\"Error dumping class: \" + e2.getMessage());\n+            }\n@@ -301,0 +281,1 @@\n+        return s.toByteArray();\n@@ -303,0 +284,12 @@\n+\n+    \/**\n+     * Dump Java class to output stream in binary format.\n+     *\n+     * @param file Output stream\n+     * @throws IOException\n+     *\/\n+    public void dump( final OutputStream file ) throws IOException {\n+        dump(new DataOutputStream(file));\n+    }\n+\n+\n@@ -307,1 +300,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -309,1 +302,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -340,49 +333,0 @@\n-    \/**\n-     * Dump class to a file.\n-     *\n-     * @param file Output file\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    public void dump(final File file) throws IOException {\n-        final String parent = file.getParent();\n-        if (parent != null) {\n-            final File dir = new File(parent);\n-            if (!dir.mkdirs() && !dir.isDirectory()) {\n-                throw new IOException(\"Could not create the directory \" + dir);\n-            }\n-        }\n-        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n-            dump(dos);\n-        }\n-    }\n-\n-    \/**\n-     * Dump Java class to output stream in binary format.\n-     *\n-     * @param file Output stream\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    public void dump(final OutputStream file) throws IOException {\n-        dump(new DataOutputStream(file));\n-    }\n-\n-    \/**\n-     * Dump class to a file named fileName.\n-     *\n-     * @param fileName Output file name\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    public void dump(final String fileName) throws IOException {\n-        dump(new File(fileName));\n-    }\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default two JavaClass objects are said to be equal when\n-     * their class names are equal.\n-     *\n-     * @see Object#equals(Object)\n-     *\/\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n-    }\n@@ -391,3 +335,1 @@\n-     * Get all interfaces implemented by this JavaClass (transitively).\n-     *\n-     * @throws ClassNotFoundException if any of the class's superclasses or interfaces can't be found.\n+     * @return Attributes of the class.\n@@ -395,18 +337,2 @@\n-    public JavaClass[] getAllInterfaces() throws ClassNotFoundException {\n-        final ClassQueue queue = new ClassQueue();\n-        final Set<JavaClass> allInterfaces = new TreeSet<>();\n-        queue.enqueue(this);\n-        while (!queue.empty()) {\n-            final JavaClass clazz = queue.dequeue();\n-            final JavaClass souper = clazz.getSuperClass();\n-            final JavaClass[] interfaces = clazz.getInterfaces();\n-            if (clazz.isInterface()) {\n-                allInterfaces.add(clazz);\n-            } else if (souper != null) {\n-                queue.enqueue(souper);\n-            }\n-            for (final JavaClass iface : interfaces) {\n-                queue.enqueue(iface);\n-            }\n-        }\n-        return allInterfaces.toArray(JavaClass.EMPTY_ARRAY);\n+    public Attribute[] getAttributes() {\n+        return attributes;\n@@ -428,1 +354,1 @@\n-     * @return Attributes of the class.\n+     * @return Class name.\n@@ -430,2 +356,2 @@\n-    public Attribute[] getAttributes() {\n-        return attributes;\n+    public String getClassName() {\n+        return className;\n@@ -434,12 +360,0 @@\n-    \/**\n-     * @return class in binary format\n-     *\/\n-    public byte[] getBytes() {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (DataOutputStream dos = new DataOutputStream(baos)) {\n-            dump(dos);\n-        } catch (final IOException e) {\n-            e.printStackTrace();\n-        }\n-        return baos.toByteArray();\n-    }\n@@ -448,1 +362,1 @@\n-     * @return Class name.\n+     * @return Package name.\n@@ -450,2 +364,2 @@\n-    public String getClassName() {\n-        return className;\n+    public String getPackageName() {\n+        return packageName;\n@@ -454,0 +368,1 @@\n+\n@@ -461,0 +376,1 @@\n+\n@@ -468,0 +384,1 @@\n+\n@@ -469,2 +386,3 @@\n-     * @return Fields, i.e., variables of the class. Like the JVM spec mandates for the classfile format, these fields are\n-     *         those specific to this class, and not those of the superclass or superinterfaces.\n+     * @return Fields, i.e., variables of the class. Like the JVM spec\n+     * mandates for the classfile format, these fields are those specific to\n+     * this class, and not those of the superclass or superinterfaces.\n@@ -476,0 +394,1 @@\n+\n@@ -483,6 +402,0 @@\n-    \/**\n-     * @return Indices in constant pool of implemented interfaces.\n-     *\/\n-    public int[] getInterfaceIndices() {\n-        return interfaces;\n-    }\n@@ -497,0 +410,1 @@\n+\n@@ -498,3 +412,1 @@\n-     * Get interfaces directly implemented by this JavaClass.\n-     *\n-     * @throws ClassNotFoundException if any of the class's interfaces can't be found.\n+     * @return Indices in constant pool of implemented interfaces.\n@@ -502,7 +414,2 @@\n-    public JavaClass[] getInterfaces() throws ClassNotFoundException {\n-        final String[] interfaces = getInterfaceNames();\n-        final JavaClass[] classes = new JavaClass[interfaces.length];\n-        for (int i = 0; i < interfaces.length; i++) {\n-            classes[i] = repository.loadClass(interfaces[i]);\n-        }\n-        return classes;\n+    public int[] getInterfaceIndices() {\n+        return interfaces;\n@@ -511,0 +418,1 @@\n+\n@@ -518,0 +426,1 @@\n+\n@@ -519,13 +428,1 @@\n-     * @return A {@link Method} corresponding to java.lang.reflect.Method if any\n-     *\/\n-    public Method getMethod(final java.lang.reflect.Method m) {\n-        for (final Method method : methods) {\n-            if (m.getName().equals(method.getName()) && m.getModifiers() == method.getModifiers() && Type.getSignature(m).equals(method.getSignature())) {\n-                return method;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * @return Methods of the class.\n+     * @return Methods of the class.\n@@ -537,6 +434,0 @@\n-    \/**\n-     * @return Minor number of class file version.\n-     *\/\n-    public int getMinor() {\n-        return minor;\n-    }\n@@ -545,1 +436,2 @@\n-     * @return Package name.\n+     * @return A {@link Method} corresponding to\n+     * java.lang.reflect.Method if any\n@@ -547,2 +439,8 @@\n-    public String getPackageName() {\n-        return packageName;\n+    public Method getMethod( final java.lang.reflect.Method m ) {\n+        for (final Method method : methods) {\n+            if (m.getName().equals(method.getName()) && (m.getModifiers() == method.getModifiers())\n+                    && Type.getSignature(m).equals(method.getSignature())) {\n+                return method;\n+            }\n+        }\n+        return null;\n@@ -551,7 +449,0 @@\n-    \/**\n-     * Gets the ClassRepository which holds its definition. By default this is the same as\n-     * SyntheticRepository.getInstance();\n-     *\/\n-    public com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n-        return repository;\n-    }\n@@ -560,1 +451,1 @@\n-     * @return returns either HEAP (generated), FILE, or ZIP\n+     * @return Minor number of class file version.\n@@ -562,2 +453,2 @@\n-    public final byte getSource() {\n-        return source;\n+    public int getMinor() {\n+        return minor;\n@@ -566,0 +457,1 @@\n+\n@@ -567,1 +459,1 @@\n-     * @return file name where this class was read from\n+     * @return sbsolute path to file where this class was read from\n@@ -573,39 +465,0 @@\n-    \/**\n-     * Gets the source file path including the package path.\n-     *\n-     * @return path to original source file of parsed class, relative to original source directory.\n-     * @since 6.7.0\n-     *\/\n-    public String getSourceFilePath() {\n-        final StringBuilder outFileName = new StringBuilder();\n-        if (!packageName.isEmpty()) {\n-            outFileName.append(Utility.packageToPath(packageName));\n-            outFileName.append('\/');\n-        }\n-        outFileName.append(sourceFileName);\n-        return outFileName.toString();\n-    }\n-\n-    \/**\n-     * @return the superclass for this JavaClass object, or null if this is java.lang.Object\n-     * @throws ClassNotFoundException if the superclass can't be found\n-     *\/\n-    public JavaClass getSuperClass() throws ClassNotFoundException {\n-        if (\"java.lang.Object\".equals(getClassName())) {\n-            return null;\n-        }\n-        return repository.loadClass(getSuperclassName());\n-    }\n-\n-    \/**\n-     * @return list of super classes of this class in ascending order, i.e., java.lang.Object is always the last element\n-     * @throws ClassNotFoundException if any of the superclasses can't be found\n-     *\/\n-    public JavaClass[] getSuperClasses() throws ClassNotFoundException {\n-        JavaClass clazz = this;\n-        final List<JavaClass> allSuperClasses = new ArrayList<>();\n-        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {\n-            allSuperClasses.add(clazz);\n-        }\n-        return allSuperClasses.toArray(JavaClass.EMPTY_ARRAY);\n-    }\n@@ -614,2 +467,3 @@\n-     * returns the super class name of this class. In the case that this class is java.lang.Object, it will return itself\n-     * (java.lang.Object). This is probably incorrect but isn't fixed at this time to not break existing clients.\n+     * returns the super class name of this class. In the case that this class is\n+     * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect\n+     * but isn't fixed at this time to not break existing clients.\n@@ -623,0 +477,1 @@\n+\n@@ -630,75 +485,0 @@\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the class name.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    \/**\n-     * @return true, if this class is an implementation of interface inter\n-     * @throws ClassNotFoundException if superclasses or superinterfaces of this class can't be found\n-     *\/\n-    public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {\n-        if (!inter.isInterface()) {\n-            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n-        }\n-        if (this.equals(inter)) {\n-            return true;\n-        }\n-        final JavaClass[] superInterfaces = getAllInterfaces();\n-        for (final JavaClass superInterface : superInterfaces) {\n-            if (superInterface.equals(inter)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Equivalent to runtime \"instanceof\" operator.\n-     *\n-     * @return true if this JavaClass is derived from the super class\n-     * @throws ClassNotFoundException if superclasses or superinterfaces of this object can't be found\n-     *\/\n-    public final boolean instanceOf(final JavaClass superclass) throws ClassNotFoundException {\n-        if (this.equals(superclass)) {\n-            return true;\n-        }\n-        for (final JavaClass clazz : getSuperClasses()) {\n-            if (clazz.equals(superclass)) {\n-                return true;\n-            }\n-        }\n-        if (superclass.isInterface()) {\n-            return implementationOf(superclass);\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public final boolean isAnonymous() {\n-        computeNestedTypeStatus();\n-        return this.isAnonymous;\n-    }\n-\n-    public final boolean isClass() {\n-        return (super.getAccessFlags() & Const.ACC_INTERFACE) == 0;\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public final boolean isNested() {\n-        computeNestedTypeStatus();\n-        return this.isNested;\n-    }\n-\n-    public final boolean isSuper() {\n-        return (super.getAccessFlags() & Const.ACC_SUPER) != 0;\n-    }\n-\n@@ -708,1 +488,1 @@\n-    public void setAttributes(final Attribute[] attributes) {\n+    public void setAttributes( final Attribute[] attributes ) {\n@@ -712,0 +492,1 @@\n+\n@@ -715,1 +496,1 @@\n-    public void setClassName(final String className) {\n+    public void setClassName( final String className ) {\n@@ -719,0 +500,1 @@\n+\n@@ -722,1 +504,1 @@\n-    public void setClassNameIndex(final int classNameIndex) {\n+    public void setClassNameIndex( final int classNameIndex ) {\n@@ -726,0 +508,1 @@\n+\n@@ -729,1 +512,1 @@\n-    public void setConstantPool(final ConstantPool constantPool) {\n+    public void setConstantPool( final ConstantPool constantPool ) {\n@@ -733,0 +516,1 @@\n+\n@@ -736,1 +520,1 @@\n-    public void setFields(final Field[] fields) {\n+    public void setFields( final Field[] fields ) {\n@@ -740,0 +524,1 @@\n+\n@@ -743,1 +528,1 @@\n-    public void setFileName(final String fileName) {\n+    public void setFileName( final String fileName ) {\n@@ -747,0 +532,1 @@\n+\n@@ -750,1 +536,1 @@\n-    public void setInterfaceNames(final String[] interfaceNames) {\n+    public void setInterfaceNames( final String[] interfaceNames ) {\n@@ -754,0 +540,1 @@\n+\n@@ -757,1 +544,1 @@\n-    public void setInterfaces(final int[] interfaces) {\n+    public void setInterfaces( final int[] interfaces ) {\n@@ -761,0 +548,1 @@\n+\n@@ -764,1 +552,1 @@\n-    public void setMajor(final int major) {\n+    public void setMajor( final int major ) {\n@@ -768,0 +556,1 @@\n+\n@@ -771,1 +560,1 @@\n-    public void setMethods(final Method[] methods) {\n+    public void setMethods( final Method[] methods ) {\n@@ -775,0 +564,1 @@\n+\n@@ -778,1 +568,1 @@\n-    public void setMinor(final int minor) {\n+    public void setMinor( final int minor ) {\n@@ -782,6 +572,0 @@\n-    \/**\n-     * Sets the ClassRepository which loaded the JavaClass. Should be called immediately after parsing is done.\n-     *\/\n-    public void setRepository(final com.sun.org.apache.bcel.internal.util.Repository repository) { \/\/ TODO make protected?\n-        this.repository = repository;\n-    }\n@@ -792,1 +576,1 @@\n-    public void setSourceFileName(final String sourceFileName) {\n+    public void setSourceFileName( final String sourceFileName ) {\n@@ -796,0 +580,1 @@\n+\n@@ -799,1 +584,1 @@\n-    public void setSuperclassName(final String superclassName) {\n+    public void setSuperclassName( final String superclassName ) {\n@@ -803,0 +588,1 @@\n+\n@@ -806,1 +592,1 @@\n-    public void setSuperclassNameIndex(final int superclassNameIndex) {\n+    public void setSuperclassNameIndex( final int superclassNameIndex ) {\n@@ -810,0 +596,1 @@\n+\n@@ -816,1 +603,1 @@\n-        access = access.isEmpty() ? \"\" : access + \" \";\n+        access = access.isEmpty() ? \"\" : (access + \" \");\n@@ -818,2 +605,3 @@\n-        buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(className).append(\" extends \")\n-            .append(Utility.compactClassName(superclassName, false)).append('\\n');\n+        buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(\n+                className).append(\" extends \").append(\n+                Utility.compactClassName(superclassName, false)).append('\\n');\n@@ -844,1 +632,1 @@\n-        if (annotations != null && annotations.length > 0) {\n+        if (annotations!=null && annotations.length>0) {\n@@ -864,0 +652,282 @@\n+\n+\n+    private static String indent( final Object obj ) {\n+        final StringTokenizer tok = new StringTokenizer(obj.toString(), \"\\n\");\n+        final StringBuilder buf = new StringBuilder();\n+        while (tok.hasMoreTokens()) {\n+            buf.append(\"\\t\").append(tok.nextToken()).append(\"\\n\");\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this class\n+     *\/\n+    public JavaClass copy() {\n+        JavaClass c = null;\n+        try {\n+            c = (JavaClass) clone();\n+            c.constantPool = constantPool.copy();\n+            c.interfaces = interfaces.clone();\n+            c.interfaceNames = interfaceNames.clone();\n+            c.fields = new Field[fields.length];\n+            for (int i = 0; i < fields.length; i++) {\n+                c.fields[i] = fields[i].copy(c.constantPool);\n+            }\n+            c.methods = new Method[methods.length];\n+            for (int i = 0; i < methods.length; i++) {\n+                c.methods[i] = methods[i].copy(c.constantPool);\n+            }\n+            c.attributes = new Attribute[attributes.length];\n+            for (int i = 0; i < attributes.length; i++) {\n+                c.attributes[i] = attributes[i].copy(c.constantPool);\n+            }\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return c;\n+    }\n+\n+\n+    public final boolean isSuper() {\n+        return (super.getAccessFlags() & Const.ACC_SUPER) != 0;\n+    }\n+\n+\n+    public final boolean isClass() {\n+        return (super.getAccessFlags() & Const.ACC_INTERFACE) == 0;\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public final boolean isAnonymous() {\n+        computeNestedTypeStatus();\n+        return this.isAnonymous;\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public final boolean isNested() {\n+        computeNestedTypeStatus();\n+        return this.isNested;\n+    }\n+\n+    private void computeNestedTypeStatus() {\n+        if (computedNestedTypeStatus) {\n+            return;\n+        }\n+        for (final Attribute attribute : this.attributes) {\n+              if (attribute instanceof InnerClasses) {\n+                  final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();\n+                  for (final InnerClass innerClasse : innerClasses) {\n+                      boolean innerClassAttributeRefersToMe = false;\n+                      String inner_class_name = constantPool.getConstantString(innerClasse.getInnerClassIndex(),\n+                                 Const.CONSTANT_Class);\n+                      inner_class_name = Utility.compactClassName(inner_class_name, false);\n+                      if (inner_class_name.equals(getClassName())) {\n+                          innerClassAttributeRefersToMe = true;\n+                      }\n+                      if (innerClassAttributeRefersToMe) {\n+                          this.isNested = true;\n+                          if (innerClasse.getInnerNameIndex() == 0) {\n+                              this.isAnonymous = true;\n+                          }\n+                      }\n+                  }\n+              }\n+        }\n+        this.computedNestedTypeStatus = true;\n+    }\n+\n+\n+    \/** @return returns either HEAP (generated), FILE, or ZIP\n+     *\/\n+    public final byte getSource() {\n+        return source;\n+    }\n+\n+\n+    \/********************* New repository functionality *********************\/\n+    \/**\n+     * Gets the ClassRepository which holds its definition. By default\n+     * this is the same as SyntheticRepository.getInstance();\n+     *\/\n+    public com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n+        return repository;\n+    }\n+\n+\n+    \/**\n+     * Sets the ClassRepository which loaded the JavaClass.\n+     * Should be called immediately after parsing is done.\n+     *\/\n+    public void setRepository( final com.sun.org.apache.bcel.internal.util.Repository repository ) { \/\/ TODO make protected?\n+        this.repository = repository;\n+    }\n+\n+\n+    \/** Equivalent to runtime \"instanceof\" operator.\n+     *\n+     * @return true if this JavaClass is derived from the super class\n+     * @throws ClassNotFoundException if superclasses or superinterfaces\n+     *   of this object can't be found\n+     *\/\n+    public final boolean instanceOf( final JavaClass super_class ) throws ClassNotFoundException {\n+        if (this.equals(super_class)) {\n+            return true;\n+        }\n+        final JavaClass[] super_classes = getSuperClasses();\n+        for (final JavaClass super_classe : super_classes) {\n+            if (super_classe.equals(super_class)) {\n+                return true;\n+            }\n+        }\n+        if (super_class.isInterface()) {\n+            return implementationOf(super_class);\n+        }\n+        return false;\n+    }\n+\n+\n+    \/**\n+     * @return true, if this class is an implementation of interface inter\n+     * @throws ClassNotFoundException if superclasses or superinterfaces\n+     *   of this class can't be found\n+     *\/\n+    public boolean implementationOf( final JavaClass inter ) throws ClassNotFoundException {\n+        if (!inter.isInterface()) {\n+            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n+        }\n+        if (this.equals(inter)) {\n+            return true;\n+        }\n+        final JavaClass[] super_interfaces = getAllInterfaces();\n+        for (final JavaClass super_interface : super_interfaces) {\n+            if (super_interface.equals(inter)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+\n+    \/**\n+     * @return the superclass for this JavaClass object, or null if this\n+     * is java.lang.Object\n+     * @throws ClassNotFoundException if the superclass can't be found\n+     *\/\n+    public JavaClass getSuperClass() throws ClassNotFoundException {\n+        if (\"java.lang.Object\".equals(getClassName())) {\n+            return null;\n+        }\n+        return repository.loadClass(getSuperclassName());\n+    }\n+\n+\n+    \/**\n+     * @return list of super classes of this class in ascending order, i.e.,\n+     * java.lang.Object is always the last element\n+     * @throws ClassNotFoundException if any of the superclasses can't be found\n+     *\/\n+    public JavaClass[] getSuperClasses() throws ClassNotFoundException {\n+        JavaClass clazz = this;\n+        final List<JavaClass> allSuperClasses = new ArrayList<>();\n+        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {\n+            allSuperClasses.add(clazz);\n+        }\n+        return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);\n+    }\n+\n+\n+    \/**\n+     * Get interfaces directly implemented by this JavaClass.\n+     *\/\n+    public JavaClass[] getInterfaces() throws ClassNotFoundException {\n+        final String[] _interfaces = getInterfaceNames();\n+        final JavaClass[] classes = new JavaClass[_interfaces.length];\n+        for (int i = 0; i < _interfaces.length; i++) {\n+            classes[i] = repository.loadClass(_interfaces[i]);\n+        }\n+        return classes;\n+    }\n+\n+\n+    \/**\n+     * Get all interfaces implemented by this JavaClass (transitively).\n+     *\/\n+    public JavaClass[] getAllInterfaces() throws ClassNotFoundException {\n+        final ClassQueue queue = new ClassQueue();\n+        final Set<JavaClass> allInterfaces = new TreeSet<>();\n+        queue.enqueue(this);\n+        while (!queue.empty()) {\n+            final JavaClass clazz = queue.dequeue();\n+            final JavaClass souper = clazz.getSuperClass();\n+            final JavaClass[] _interfaces = clazz.getInterfaces();\n+            if (clazz.isInterface()) {\n+                allInterfaces.add(clazz);\n+            } else {\n+                if (souper != null) {\n+                    queue.enqueue(souper);\n+                }\n+            }\n+            for (final JavaClass _interface : _interfaces) {\n+                queue.enqueue(_interface);\n+            }\n+        }\n+        return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);\n+    }\n+\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two JavaClass objects are said to be equal when\n+     * their class names are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return the natural ordering of two JavaClasses.\n+     * This ordering is based on the class name\n+     * @since 6.0\n+     *\/\n+    @Override\n+    public int compareTo( final JavaClass obj ) {\n+        return getClassName().compareTo(obj.getClassName());\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the class name.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/JavaClass.java","additions":505,"deletions":435,"binary":false,"changes":940,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n-\n@@ -31,2 +29,3 @@\n- * This class represents a (PC offset, line number) pair, i.e., a line number in the source that corresponds to a\n- * relative address in the byte code. This is used for debugging purposes.\n+ * This class represents a (PC offset, line number) pair, i.e., a line number in\n+ * the source that corresponds to a relative address in the byte code. This\n+ * is used for debugging purposes.\n@@ -34,1 +33,1 @@\n- * @see LineNumberTable\n+ * @see     LineNumberTable\n@@ -38,2 +37,0 @@\n-    static final LineNumber[] EMPTY_ARRAY = {};\n-\n@@ -41,1 +38,1 @@\n-    private int startPc;\n+    private short startPc;\n@@ -44,1 +41,11 @@\n-    private int lineNumber;\n+    private short lineNumber;\n+\n+    \/**\n+     * Initialize from another object.\n+     *\n+     * @param c the object to copy\n+     *\/\n+    public LineNumber(final LineNumber c) {\n+        this(c.getStartPC(), c.getLineNumber());\n+    }\n+\n@@ -56,0 +63,1 @@\n+\n@@ -61,2 +69,2 @@\n-        this.startPc = Args.requireU2(startPc, \"startPc\");\n-        this.lineNumber = Args.requireU2(lineNumber, \"lineNumber\");\n+        this.startPc = (short) startPc;\n+        this.lineNumber = (short)lineNumber;\n@@ -65,8 +73,0 @@\n-    \/**\n-     * Initialize from another object.\n-     *\n-     * @param c the object to copy\n-     *\/\n-    public LineNumber(final LineNumber c) {\n-        this(c.getStartPC(), c.getLineNumber());\n-    }\n@@ -75,2 +75,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -81,1 +82,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -85,11 +86,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public LineNumber copy() {\n-        try {\n-            return (LineNumber) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n@@ -103,1 +93,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -108,0 +98,1 @@\n+\n@@ -112,1 +103,1 @@\n-        return lineNumber & 0xffff;\n+        return 0xffff & lineNumber;\n@@ -115,0 +106,1 @@\n+\n@@ -119,1 +111,1 @@\n-        return startPc & 0xffff;\n+        return  0xffff & startPc;\n@@ -122,0 +114,1 @@\n+\n@@ -125,1 +118,1 @@\n-    public void setLineNumber(final int lineNumber) {\n+    public void setLineNumber( final int lineNumber ) {\n@@ -129,0 +122,1 @@\n+\n@@ -132,1 +126,1 @@\n-    public void setStartPC(final int startPc) {\n+    public void setStartPC( final int startPc ) {\n@@ -136,0 +130,1 @@\n+\n@@ -141,1 +136,14 @@\n-        return \"LineNumber(\" + getStartPC() + \", \" + getLineNumber() + \")\";\n+        return \"LineNumber(\" + startPc + \", \" + lineNumber + \")\";\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public LineNumber copy() {\n+        try {\n+            return (LineNumber) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LineNumber.java","additions":47,"deletions":39,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -25,6 +26,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n-\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -34,2 +29,3 @@\n- * This class represents a table of line numbers for debugging purposes. This attribute is used by the <em>Code<\/em>\n- * attribute. It contains pairs of PCs and line numbers.\n+ * This class represents a table of line numbers for debugging\n+ * purposes. This attribute is used by the <em>Code<\/em> attribute. It\n+ * contains pairs of PCs and line numbers.\n@@ -37,1 +33,1 @@\n- * @see Code\n+ * @see     Code\n@@ -41,1 +37,1 @@\n-public final class LineNumberTable extends Attribute implements Iterable<LineNumber> {\n+public final class LineNumberTable extends Attribute {\n@@ -46,8 +42,4 @@\n-    \/**\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index of name\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O Exception occurs in readUnsignedShort\n+\n+    \/*\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -55,7 +47,2 @@\n-    LineNumberTable(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (LineNumber[]) null, constantPool);\n-        final int lineNumberTableLength = input.readUnsignedShort();\n-        lineNumberTable = new LineNumber[lineNumberTableLength];\n-        for (int i = 0; i < lineNumberTableLength; i++) {\n-            lineNumberTable[i] = new LineNumber(input);\n-        }\n+    public LineNumberTable(final LineNumberTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLineNumberTable(), c.getConstantPool());\n@@ -64,0 +51,1 @@\n+\n@@ -65,2 +53,1 @@\n-     * @param nameIndex Index of name\n-     *\n+     * @param name_index Index of name\n@@ -68,1 +55,0 @@\n-     *\n@@ -70,2 +56,1 @@\n-     *\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -73,4 +58,4 @@\n-    public LineNumberTable(final int nameIndex, final int length, final LineNumber[] lineNumberTable, final ConstantPool constantPool) {\n-        super(Const.ATTR_LINE_NUMBER_TABLE, nameIndex, length, constantPool);\n-        this.lineNumberTable = lineNumberTable != null ? lineNumberTable : LineNumber.EMPTY_ARRAY;\n-        Args.requireU2(this.lineNumberTable.length, \"lineNumberTable.length\");\n+    public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);\n+        this.lineNumberTable = line_number_table;\n@@ -79,3 +64,7 @@\n-    \/*\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n+    \/**\n+     * Construct object from input stream.\n+     * @param name_index Index of name\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException if an I\/O Exception occurs in readUnsignedShort\n@@ -83,2 +72,8 @@\n-    public LineNumberTable(final LineNumberTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLineNumberTable(), c.getConstantPool());\n+    LineNumberTable(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (LineNumber[]) null, constant_pool);\n+        final int line_number_table_length = input.readUnsignedShort();\n+        lineNumberTable = new LineNumber[line_number_table_length];\n+        for (int i = 0; i < line_number_table_length; i++) {\n+            lineNumberTable[i] = new LineNumber(input);\n+        }\n@@ -88,2 +83,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -94,1 +90,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -98,14 +94,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        \/\/ TODO could use the lower level constructor and thereby allow\n-        \/\/ lineNumberTable to be made final\n-        final LineNumberTable c = (LineNumberTable) clone();\n-        c.lineNumberTable = new LineNumber[lineNumberTable.length];\n-        Arrays.setAll(c.lineNumberTable, i -> lineNumberTable[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n-\n@@ -119,1 +101,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -134,0 +116,30 @@\n+    \/**\n+     * @param lineNumberTable the line number entries for this table\n+     *\/\n+    public void setLineNumberTable( final LineNumber[] lineNumberTable ) {\n+        this.lineNumberTable = lineNumberTable;\n+    }\n+\n+    \/**\n+     * @return String representation.\n+     *\/\n+    @Override\n+    public String toString() {\n+        final StringBuilder buf = new StringBuilder();\n+        final StringBuilder line = new StringBuilder();\n+\n+        for (int i = 0; i < lineNumberTable.length; i++) {\n+            line.append(lineNumberTable[i].toString());\n+            if (i < lineNumberTable.length - 1) {\n+                line.append(\", \");\n+            }\n+            if ((line.length() > MAX_LINE_LENGTH) && (i < lineNumberTable.length - 1)) {\n+                line.append(SecuritySupport.NEWLINE);\n+                buf.append(line);\n+                line.setLength(0);\n+            }\n+        }\n+        buf.append(line);\n+        return buf.toString();\n+    }\n+\n@@ -140,1 +152,1 @@\n-    public int getSourceLine(final int pos) {\n+    public int getSourceLine( final int pos ) {\n@@ -146,1 +158,1 @@\n-        int minIndex = -1;\n+        int min_index = -1;\n@@ -148,2 +160,1 @@\n-        \/*\n-         * Do a binary search since the array is ordered.\n+        \/* Do a binary search since the array is ordered.\n@@ -152,1 +163,1 @@\n-            final int i = l + r >>> 1;\n+            final int i = (l + r) >>> 1;\n@@ -156,2 +167,1 @@\n-            }\n-            if (pos < j) {\n+            } else if (pos < j) {\n@@ -162,3 +172,3 @@\n-            \/*\n-             * If exact match can't be found (which is the most common case) return the line number that corresponds to the greatest\n-             * index less than pos.\n+            \/* If exact match can't be found (which is the most common case)\n+             * return the line number that corresponds to the greatest index less\n+             * than pos.\n@@ -168,1 +178,1 @@\n-                minIndex = i;\n+                min_index = i;\n@@ -171,2 +181,2 @@\n-        \/*\n-         * It's possible that we did not find any valid entry for the bytecode offset we were looking for.\n+        \/* It's possible that we did not find any valid entry for the bytecode\n+         * offset we were looking for.\n@@ -174,1 +184,1 @@\n-        if (minIndex < 0) {\n+        if (min_index < 0) {\n@@ -177,10 +187,1 @@\n-        return lineNumberTable[minIndex].getLineNumber();\n-    }\n-\n-    public int getTableLength() {\n-        return lineNumberTable == null ? 0 : lineNumberTable.length;\n-    }\n-\n-    @Override\n-    public Iterator<LineNumber> iterator() {\n-        return Stream.of(lineNumberTable).iterator();\n+        return lineNumberTable[min_index].getLineNumber();\n@@ -190,8 +191,1 @@\n-     * @param lineNumberTable the line number entries for this table\n-     *\/\n-    public void setLineNumberTable(final LineNumber[] lineNumberTable) {\n-        this.lineNumberTable = lineNumberTable;\n-    }\n-\n-    \/**\n-     * @return String representation.\n+     * @return deep copy of this attribute\n@@ -200,3 +194,5 @@\n-    public String toString() {\n-        final StringBuilder buf = new StringBuilder();\n-        final StringBuilder line = new StringBuilder();\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        \/\/ TODO could use the lower level constructor and thereby allow\n+        \/\/ lineNumberTable to be made final\n+        final LineNumberTable c = (LineNumberTable) clone();\n+        c.lineNumberTable = new LineNumber[lineNumberTable.length];\n@@ -204,9 +200,1 @@\n-            line.append(lineNumberTable[i].toString());\n-            if (i < lineNumberTable.length - 1) {\n-                line.append(\", \");\n-            }\n-            if (line.length() > MAX_LINE_LENGTH && i < lineNumberTable.length - 1) {\n-                line.append(SecuritySupport.NEWLINE);\n-                buf.append(line);\n-                line.setLength(0);\n-            }\n+            c.lineNumberTable[i] = lineNumberTable[i].copy();\n@@ -214,2 +202,7 @@\n-        buf.append(line);\n-        return buf.toString();\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n+\n+\n+    public int getTableLength() {\n+        return lineNumberTable == null ? 0 : lineNumberTable.length;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LineNumberTable.java","additions":96,"deletions":103,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -30,4 +30,6 @@\n- * This class represents a local variable within a method. It contains its scope, name, signature and index on the\n- * method's frame. It is used both to represent an element of the LocalVariableTable as well as an element of the\n- * LocalVariableTypeTable. The nomenclature used here may be a bit confusing; while the two items have the same layout\n- * in a class file, a LocalVariableTable attribute contains a descriptor_index, not a signatureIndex. The\n+ * This class represents a local variable within a method. It contains its\n+ * scope, name, signature and index on the method's frame.  It is used both\n+ * to represent an element of the LocalVariableTable as well as an element\n+ * of the LocalVariableTypeTable.  The nomenclature used here may be a bit confusing;\n+ * while the two items have the same layout in a class file, a LocalVariableTable\n+ * attribute contains a descriptor_index, not a signatureIndex.  The\n@@ -35,1 +37,0 @@\n- *\n@@ -38,3 +39,3 @@\n- * @see LocalVariableTable\n- * @see LocalVariableTypeTable\n- * @LastModified: Feb 2023\n+ * @see     LocalVariableTable\n+ * @see     LocalVariableTypeTable\n+ * @LastModified: May 2021\n@@ -44,5 +45,1 @@\n-    static final LocalVariable[] EMPTY_ARRAY = {};\n-\n-    \/** Range in which the variable is valid. *\/\n-    private int startPc;\n-\n+    private int startPc; \/\/ Range in which the variable is valid\n@@ -50,0 +47,9 @@\n+    private int nameIndex; \/\/ Index in constant pool of variable name\n+    \/\/ Technically, a decscriptor_index for a local variable table entry\n+    \/\/ and a signatureIndex for a local variable type table entry.\n+    private int signatureIndex; \/\/ Index of variable signature\n+    private int index; \/* Variable is index'th local variable on\n+     * this method's frame.\n+     *\/\n+    private ConstantPool constantPool;\n+    private int origIndex; \/\/ never changes; used to match up with LocalVariableTypeTable entries\n@@ -51,2 +57,0 @@\n-    \/** Index in constant pool of variable name. *\/\n-    private int nameIndex;\n@@ -55,6 +59,4 @@\n-     * Technically, a decscriptor_index for a local variable table entry and a signatureIndex for a local variable type table entry. Index of variable signature\n-     *\/\n-    private int signatureIndex;\n-\n-    \/*\n-     * Variable is index'th local variable on this method's frame.\n+     * Initializes from another LocalVariable. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n+     *\n+     * @param localVariable Another LocalVariable.\n@@ -62,6 +64,5 @@\n-    private int index;\n-\n-    private ConstantPool constantPool;\n-\n-    \/** Never changes; used to match up with LocalVariableTypeTable entries. *\/\n-    private final int origIndex;\n+    public LocalVariable(final LocalVariable localVariable) {\n+        this(localVariable.getStartPC(), localVariable.getLength(), localVariable.getNameIndex(),\n+                localVariable.getSignatureIndex(), localVariable.getIndex(), localVariable.getConstantPool());\n+        this.origIndex = localVariable.getOrigIndex();\n+    }\n@@ -71,1 +72,0 @@\n-     *\n@@ -73,1 +73,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -75,2 +75,3 @@\n-    LocalVariable(final DataInput file, final ConstantPool constantPool) throws IOException {\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), constantPool);\n+    LocalVariable(final DataInput file, final ConstantPool constant_pool) throws IOException {\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n+                .readUnsignedShort(), file.readUnsignedShort(), constant_pool);\n@@ -79,0 +80,1 @@\n+\n@@ -84,1 +86,1 @@\n-     * @param index Variable is 'index'th local variable on the method's frame\n+     * @param index Variable is `index'th local variable on the method's frame\n@@ -87,2 +89,9 @@\n-    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index, final ConstantPool constantPool) {\n-        this(startPc, length, nameIndex, signatureIndex, index, constantPool, index);\n+    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index,\n+            final ConstantPool constantPool) {\n+        this.startPc = startPc;\n+        this.length = length;\n+        this.nameIndex = nameIndex;\n+        this.signatureIndex = signatureIndex;\n+        this.index = index;\n+        this.constantPool = constantPool;\n+        this.origIndex = index;\n@@ -91,0 +100,1 @@\n+\n@@ -96,1 +106,1 @@\n-     * @param index Variable is 'index'th local variable on the method's frame\n+     * @param index Variable is `index'th local variable on the method's frame\n@@ -98,1 +108,1 @@\n-     * @param origIndex Variable is 'index'th local variable on the method's frame prior to any changes\n+     * @param origIndex Variable is `index'th local variable on the method's frame prior to any changes\n@@ -100,8 +110,7 @@\n-    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index, final ConstantPool constantPool,\n-        final int origIndex) {\n-        this.startPc = Args.requireU2(startPc, \"startPc\");\n-        this.length = Args.requireU2(length, \"length\");\n-        this.nameIndex = Args.requireU2(nameIndex, \"nameIndex\");\n-        this.signatureIndex = Args.requireU2(signatureIndex, \"signatureIndex\");\n-        this.index = Args.requireU2(index, \"index\");\n-        this.origIndex = Args.requireU2(origIndex, \"origIndex\");\n+    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index,\n+            final ConstantPool constantPool, final int origIndex) {\n+        this.startPc = startPc;\n+        this.length = length;\n+        this.nameIndex = nameIndex;\n+        this.signatureIndex = signatureIndex;\n+        this.index = index;\n@@ -109,0 +118,1 @@\n+        this.origIndex = origIndex;\n@@ -111,10 +121,0 @@\n-    \/**\n-     * Initializes from another LocalVariable. Note that both objects use the same references (shallow copy). Use copy() for\n-     * a physical copy.\n-     *\n-     * @param localVariable Another LocalVariable.\n-     *\/\n-    public LocalVariable(final LocalVariable localVariable) {\n-        this(localVariable.getStartPC(), localVariable.getLength(), localVariable.getNameIndex(), localVariable.getSignatureIndex(), localVariable.getIndex(),\n-            localVariable.getConstantPool());\n-    }\n@@ -123,2 +123,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -129,1 +130,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -133,11 +134,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public LocalVariable copy() {\n-        try {\n-            return (LocalVariable) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n@@ -149,1 +139,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @exception IOException if an I\/O error occurs.\n@@ -167,6 +157,0 @@\n-    \/**\n-     * @return index of register where variable is stored\n-     *\/\n-    public int getIndex() {\n-        return index;\n-    }\n@@ -181,0 +165,1 @@\n+\n@@ -185,1 +170,3 @@\n-        return constantPool.getConstantUtf8(nameIndex).getBytes();\n+        ConstantUtf8 c;\n+        c = (ConstantUtf8) constantPool.getConstant(nameIndex, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -188,0 +175,1 @@\n+\n@@ -195,6 +183,0 @@\n-    \/**\n-     * @return index of register where variable was originally stored\n-     *\/\n-    public int getOrigIndex() {\n-        return origIndex;\n-    }\n@@ -206,1 +188,3 @@\n-        return constantPool.getConstantUtf8(signatureIndex).getBytes();\n+        ConstantUtf8 c;\n+        c = (ConstantUtf8) constantPool.getConstant(signatureIndex, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -209,0 +193,1 @@\n+\n@@ -216,0 +201,17 @@\n+\n+    \/**\n+     * @return index of register where variable is stored\n+     *\/\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+\n+    \/**\n+     * @return index of register where variable was originally stored\n+     *\/\n+    public int getOrigIndex() {\n+        return origIndex;\n+    }\n+\n+\n@@ -223,2 +225,3 @@\n-    \/**\n-     * @param constantPool Constant pool to be used for this object.\n+\n+    \/*\n+     * Helper method shared with LocalVariableTypeTable\n@@ -226,2 +229,6 @@\n-    public void setConstantPool(final ConstantPool constantPool) {\n-        this.constantPool = constantPool;\n+    String toStringShared( final boolean typeTable ) {\n+        final String name = getName();\n+        final String signature = Utility.signatureToString(getSignature(), false);\n+        final String label = \"LocalVariable\" + (typeTable ? \"Types\" : \"\" );\n+        return label + \"(startPc = \" + startPc + \", length = \" + length + \", index = \"\n+                + index + \":\" + signature + \" \" + name + \")\";\n@@ -230,0 +237,1 @@\n+\n@@ -231,1 +239,1 @@\n-     * @param index the index in the local variable table of this variable\n+     * @param constantPool Constant pool to be used for this object.\n@@ -233,2 +241,2 @@\n-    public void setIndex(final int index) { \/\/ TODO unused\n-        this.index = index;\n+    public void setConstantPool( final ConstantPool constantPool ) {\n+        this.constantPool = constantPool;\n@@ -237,0 +245,1 @@\n+\n@@ -240,1 +249,1 @@\n-    public void setLength(final int length) {\n+    public void setLength( final int length ) {\n@@ -244,0 +253,1 @@\n+\n@@ -247,1 +257,1 @@\n-    public void setNameIndex(final int nameIndex) { \/\/ TODO unused\n+    public void setNameIndex( final int nameIndex ) { \/\/ TODO unused\n@@ -251,0 +261,1 @@\n+\n@@ -254,1 +265,1 @@\n-    public void setSignatureIndex(final int signatureIndex) { \/\/ TODO unused\n+    public void setSignatureIndex( final int signatureIndex ) { \/\/ TODO unused\n@@ -258,0 +269,9 @@\n+\n+    \/**\n+     * @param index the index in the local variable table of this variable\n+     *\/\n+    public void setIndex( final int index ) { \/\/ TODO unused\n+        this.index = index;\n+    }\n+\n+\n@@ -261,1 +281,1 @@\n-    public void setStartPC(final int startPc) { \/\/ TODO unused\n+    public void setStartPC( final int startPc ) { \/\/ TODO unused\n@@ -265,0 +285,1 @@\n+\n@@ -273,2 +294,3 @@\n-    \/*\n-     * Helper method shared with LocalVariableTypeTable\n+\n+    \/**\n+     * @return deep copy of this object\n@@ -276,5 +298,7 @@\n-    String toStringShared(final boolean typeTable) {\n-        final String name = getName();\n-        final String signature = Utility.signatureToString(getSignature(), false);\n-        final String label = \"LocalVariable\" + (typeTable ? \"Types\" : \"\");\n-        return label + \"(startPc = \" + startPc + \", length = \" + length + \", index = \" + index + \":\" + signature + \" \" + name + \")\";\n+    public LocalVariable copy() {\n+        try {\n+            return (LocalVariable) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariable.java","additions":127,"deletions":103,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -32,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -35,2 +31,2 @@\n- * This class represents colection of local variables in a method. This attribute is contained in the <em>Code<\/em>\n- * attribute.\n+ * This class represents colection of local variables in a\n+ * method. This attribute is contained in the <em>Code<\/em> attribute.\n@@ -38,1 +34,1 @@\n- * @see Code\n+ * @see     Code\n@@ -41,1 +37,1 @@\n-public class LocalVariableTable extends Attribute implements Iterable<LocalVariable> {\n+public class LocalVariableTable extends Attribute {\n@@ -45,0 +41,1 @@\n+\n@@ -46,7 +43,2 @@\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -54,7 +46,2 @@\n-    LocalVariableTable(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (LocalVariable[]) null, constantPool);\n-        final int localVariableTableLength = input.readUnsignedShort();\n-        localVariableTable = new LocalVariable[localVariableTableLength];\n-        for (int i = 0; i < localVariableTableLength; i++) {\n-            localVariableTable[i] = new LocalVariable(input, constantPool);\n-        }\n+    public LocalVariableTable(final LocalVariableTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTable(), c.getConstantPool());\n@@ -63,0 +50,1 @@\n+\n@@ -64,1 +52,1 @@\n-     * @param nameIndex Index in constant pool to 'LocalVariableTable'\n+     * @param nameIndex Index in constant pool to `LocalVariableTable'\n@@ -69,1 +57,2 @@\n-    public LocalVariableTable(final int nameIndex, final int length, final LocalVariable[] localVariableTable, final ConstantPool constantPool) {\n+    public LocalVariableTable(final int nameIndex, final int length, final LocalVariable[] localVariableTable,\n+            final ConstantPool constantPool) {\n@@ -71,2 +60,1 @@\n-        this.localVariableTable = localVariableTable != null ? localVariableTable : LocalVariable.EMPTY_ARRAY;\n-        Args.requireU2(this.localVariableTable.length, \"localVariableTable.length\");\n+        this.localVariableTable = localVariableTable;\n@@ -75,0 +63,1 @@\n+\n@@ -76,4 +65,6 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from input stream.\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -81,2 +72,8 @@\n-    public LocalVariableTable(final LocalVariableTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTable(), c.getConstantPool());\n+    LocalVariableTable(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (LocalVariable[]) null, constant_pool);\n+        final int local_variable_table_length = input.readUnsignedShort();\n+        localVariableTable = new LocalVariable[local_variable_table_length];\n+        for (int i = 0; i < local_variable_table_length; i++) {\n+            localVariableTable[i] = new LocalVariable(input, constant_pool);\n+        }\n@@ -85,0 +82,1 @@\n+\n@@ -86,2 +84,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -92,1 +91,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -96,11 +95,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final LocalVariableTable c = (LocalVariableTable) clone();\n-        c.localVariableTable = new LocalVariable[localVariableTable.length];\n-        Arrays.setAll(c.localVariableTable, i -> localVariableTable[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -112,1 +100,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -115,1 +103,1 @@\n-    public final void dump(final DataOutputStream file) throws IOException {\n+    public final void dump( final DataOutputStream file ) throws IOException {\n@@ -123,0 +111,9 @@\n+\n+    \/**\n+     * @return Array of local variables of method.\n+     *\/\n+    public final LocalVariable[] getLocalVariableTable() {\n+        return localVariableTable;\n+    }\n+\n+\n@@ -129,2 +126,2 @@\n-     * @deprecated since 5.2 because multiple variables can share the same slot, use getLocalVariable(int index, int pc)\n-     *             instead.\n+     * @deprecated since 5.2 because multiple variables can share the\n+     *             same slot, use getLocalVariable(int index, int pc) instead.\n@@ -133,1 +130,1 @@\n-    public final LocalVariable getLocalVariable(final int index) {\n+    public final LocalVariable getLocalVariable( final int index ) {\n@@ -142,0 +139,1 @@\n+\n@@ -149,1 +147,1 @@\n-    public final LocalVariable getLocalVariable(final int index, final int pc) {\n+    public final LocalVariable getLocalVariable( final int index, final int pc ) {\n@@ -152,3 +150,3 @@\n-                final int startPc = variable.getStartPC();\n-                final int endPc = startPc + variable.getLength();\n-                if (pc >= startPc && pc <= endPc) {\n+                final int start_pc = variable.getStartPC();\n+                final int end_pc = start_pc + variable.getLength();\n+                if ((pc >= start_pc) && (pc <= end_pc)) {\n@@ -162,10 +160,0 @@\n-    \/**\n-     * @return Array of local variables of method.\n-     *\/\n-    public final LocalVariable[] getLocalVariableTable() {\n-        return localVariableTable;\n-    }\n-\n-    public final int getTableLength() {\n-        return localVariableTable == null ? 0 : localVariableTable.length;\n-    }\n@@ -173,3 +161,2 @@\n-    @Override\n-    public Iterator<LocalVariable> iterator() {\n-        return Stream.of(localVariableTable).iterator();\n+    public final void setLocalVariableTable( final LocalVariable[] local_variable_table ) {\n+        this.localVariableTable = local_variable_table;\n@@ -178,3 +165,0 @@\n-    public final void setLocalVariableTable(final LocalVariable[] localVariableTable) {\n-        this.localVariableTable = localVariableTable;\n-    }\n@@ -196,0 +180,20 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final LocalVariableTable c = (LocalVariableTable) clone();\n+        c.localVariableTable = new LocalVariable[localVariableTable.length];\n+        for (int i = 0; i < localVariableTable.length; i++) {\n+            c.localVariableTable[i] = localVariableTable[i].copy();\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n+\n+\n+    public final int getTableLength() {\n+        return localVariableTable == null ? 0 : localVariableTable.length;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariableTable.java","additions":75,"deletions":71,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -31,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -64,1 +60,1 @@\n-public class LocalVariableTypeTable extends Attribute implements Iterable<LocalVariable> {\n+public class LocalVariableTypeTable extends Attribute {\n@@ -66,1 +62,10 @@\n-    private LocalVariable[] localVariableTypeTable; \/\/ variables\n+    private LocalVariable[] localVariableTypeTable;        \/\/ variables\n+\n+    public LocalVariableTypeTable(final LocalVariableTypeTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTypeTable(), c.getConstantPool());\n+    }\n+\n+    public LocalVariableTypeTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {\n+        super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);\n+        this.localVariableTypeTable = local_variable_table;\n+    }\n@@ -71,2 +76,2 @@\n-        final int localVariableTypeTableLength = input.readUnsignedShort();\n-        localVariableTypeTable = new LocalVariable[localVariableTypeTableLength];\n+        final int local_variable_type_table_length = input.readUnsignedShort();\n+        localVariableTypeTable = new LocalVariable[local_variable_type_table_length];\n@@ -74,1 +79,1 @@\n-        for (int i = 0; i < localVariableTypeTableLength; i++) {\n+        for (int i = 0; i < local_variable_type_table_length; i++) {\n@@ -79,10 +84,0 @@\n-    public LocalVariableTypeTable(final int nameIndex, final int length, final LocalVariable[] localVariableTypeTable, final ConstantPool constantPool) {\n-        super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, nameIndex, length, constantPool);\n-        this.localVariableTypeTable = localVariableTypeTable != null ? localVariableTypeTable : LocalVariable.EMPTY_ARRAY;\n-        Args.requireU2(this.localVariableTypeTable.length, \"localVariableTypeTable.length\");\n-    }\n-\n-    public LocalVariableTypeTable(final LocalVariableTypeTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTypeTable(), c.getConstantPool());\n-    }\n-\n@@ -94,13 +89,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final LocalVariableTypeTable c = (LocalVariableTypeTable) clone();\n-\n-        c.localVariableTypeTable = new LocalVariable[localVariableTypeTable.length];\n-        Arrays.setAll(c.localVariableTypeTable, i -> localVariableTypeTable[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n-\n@@ -116,0 +98,4 @@\n+    public final LocalVariable[] getLocalVariableTypeTable() {\n+        return localVariableTypeTable;\n+    }\n+\n@@ -126,15 +112,2 @@\n-    public final LocalVariable[] getLocalVariableTypeTable() {\n-        return localVariableTypeTable;\n-    }\n-\n-    public final int getTableLength() {\n-        return localVariableTypeTable == null ? 0 : localVariableTypeTable.length;\n-    }\n-\n-    @Override\n-    public Iterator<LocalVariable> iterator() {\n-        return Stream.of(localVariableTypeTable).iterator();\n-    }\n-\n-    public final void setLocalVariableTable(final LocalVariable[] localVariableTable) {\n-        this.localVariableTypeTable = localVariableTable;\n+    public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {\n+        this.localVariableTypeTable = local_variable_table;\n@@ -160,0 +133,20 @@\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constant_pool) {\n+        final LocalVariableTypeTable c = (LocalVariableTypeTable) clone();\n+\n+        c.localVariableTypeTable = new LocalVariable[localVariableTypeTable.length];\n+        for (int i = 0; i < localVariableTypeTable.length; i++) {\n+            c.localVariableTypeTable[i] = localVariableTypeTable[i].copy();\n+        }\n+\n+        c.setConstantPool(constant_pool);\n+        return c;\n+    }\n+\n+    public final int getTableLength() {\n+        return localVariableTypeTable == null ? 0 : localVariableTypeTable.length;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariableTypeTable.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -31,2 +32,4 @@\n- * This class represents the method info structure, i.e., the representation for a method in the class. See JVM\n- * specification for details. A method has access flags, a name, a signature and a number of attributes.\n+ * This class represents the method info structure, i.e., the representation\n+ * for a method in the class. See JVM specification for details.\n+ * A method has access flags, a name, a signature and a number of attributes.\n+ *\n@@ -36,7 +39,0 @@\n-    \/**\n-     * Empty array constant.\n-     *\n-     * @since 6.6.0\n-     *\/\n-    public static final Method[] EMPTY_ARRAY = {};\n-\n@@ -46,1 +42,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -49,1 +45,2 @@\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName())\n+                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -52,0 +49,1 @@\n+\n@@ -53,1 +51,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -59,11 +57,2 @@\n-    \/**\n-     * Empty array.\n-     *\/\n-    static final Method[] EMPTY_METHOD_ARRAY = {};\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n+    \/\/ annotations defined on the parameters of a method\n+    private ParameterAnnotationEntry[] parameterAnnotationEntries;\n@@ -72,1 +61,2 @@\n-     * @param comparator Comparison strategy object\n+     * Empty constructor, all attributes have to be defined via `setXXX'\n+     * methods. Use at your own risk.\n@@ -74,2 +64,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n+    public Method() {\n@@ -78,2 +67,0 @@\n-    \/\/ annotations defined on the parameters of a method\n-    private ParameterAnnotationEntry[] parameterAnnotationEntries;\n@@ -82,1 +69,2 @@\n-     * Empty constructor, all attributes have to be defined via 'setXXX' methods. Use at your own risk.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -84,1 +72,2 @@\n-    public Method() {\n+    public Method(final Method c) {\n+        super(c);\n@@ -87,0 +76,1 @@\n+\n@@ -89,1 +79,0 @@\n-     *\n@@ -91,2 +80,2 @@\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -94,2 +83,3 @@\n-    Method(final DataInput file, final ConstantPool constantPool) throws IOException, ClassFormatException {\n-        super(file, constantPool);\n+    Method(final DataInput file, final ConstantPool constant_pool) throws IOException,\n+            ClassFormatException {\n+        super(file, constant_pool);\n@@ -98,0 +88,1 @@\n+\n@@ -99,3 +90,3 @@\n-     * @param accessFlags Access rights of method\n-     * @param nameIndex Points to field name in constant pool\n-     * @param signatureIndex Points to encoded signature\n+     * @param access_flags Access rights of method\n+     * @param name_index Points to field name in constant pool\n+     * @param signature_index Points to encoded signature\n@@ -103,1 +94,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -105,2 +96,3 @@\n-    public Method(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes, final ConstantPool constantPool) {\n-        super(accessFlags, nameIndex, signatureIndex, attributes, constantPool);\n+    public Method(final int access_flags, final int name_index, final int signature_index, final Attribute[] attributes,\n+            final ConstantPool constant_pool) {\n+        super(access_flags, name_index, signature_index, attributes, constant_pool);\n@@ -109,9 +101,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public Method(final Method c) {\n-        super(c);\n-    }\n@@ -120,2 +103,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -126,1 +110,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -130,24 +114,0 @@\n-    \/**\n-     * @return deep copy of this method\n-     *\/\n-    public Method copy(final ConstantPool constantPool) {\n-        return (Method) copy_(constantPool);\n-    }\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default two method objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see Object#equals(Object)\n-     *\/\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n-    }\n-\n-    \/**\n-     * @return array of method argument types\n-     *\/\n-    public Type[] getArgumentTypes() {\n-        return Type.getArgumentTypes(getSignature());\n-    }\n@@ -167,0 +127,1 @@\n+\n@@ -168,2 +129,2 @@\n-     * @return ExceptionTable attribute of method, if any, i.e., list all exceptions the method may throw not exception\n-     *         handlers!\n+     * @return ExceptionTable attribute of method, if any, i.e., list all\n+     * exceptions the method may throw not exception handlers!\n@@ -180,10 +141,0 @@\n-    \/**\n-     * @return LineNumberTable of code attribute if any, i.e. the call is forwarded to the Code atribute.\n-     *\/\n-    public LineNumberTable getLineNumberTable() {\n-        final Code code = getCode();\n-        if (code == null) {\n-            return null;\n-        }\n-        return code.getLineNumberTable();\n-    }\n@@ -191,2 +142,2 @@\n-    \/**\n-     * @return LocalVariableTable of code attribute if any, i.e. the call is forwarded to the Code atribute.\n+    \/** @return LocalVariableTable of code attribute if any, i.e. the call is forwarded\n+     * to the Code atribute.\n@@ -202,10 +153,0 @@\n-    \/**\n-     * @return Annotations on the parameters of a method\n-     * @since 6.0\n-     *\/\n-    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n-        if (parameterAnnotationEntries == null) {\n-            parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());\n-        }\n-        return parameterAnnotationEntries;\n-    }\n@@ -213,2 +154,2 @@\n-    \/**\n-     * @return return type of method\n+    \/** @return LineNumberTable of code attribute if any, i.e. the call is forwarded\n+     * to the Code atribute.\n@@ -216,2 +157,6 @@\n-    public Type getReturnType() {\n-        return Type.getReturnType(getSignature());\n+    public LineNumberTable getLineNumberTable() {\n+        final Code code = getCode();\n+        if (code == null) {\n+            return null;\n+        }\n+        return code.getLineNumberTable();\n@@ -220,10 +165,0 @@\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the method's name XOR\n-     * signature.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n@@ -232,2 +167,2 @@\n-     * Return string representation close to declaration format, 'public static void main(String[] args) throws\n-     * IOException', e.g.\n+     * Return string representation close to declaration format,\n+     * `public static void main(String[] args) throws IOException', e.g.\n@@ -241,1 +176,1 @@\n-        ConstantUtf8 c = super.getConstantPool().getConstantUtf8(super.getSignatureIndex());\n+        ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(super.getSignatureIndex(), Const.CONSTANT_Utf8);\n@@ -243,1 +178,1 @@\n-        c = super.getConstantPool().getConstantUtf8(super.getNameIndex());\n+        c = (ConstantUtf8) super.getConstantPool().getConstant(super.getNameIndex(), Const.CONSTANT_Utf8);\n@@ -245,1 +180,2 @@\n-        signature = Utility.methodSignatureToString(signature, name, access, true, getLocalVariableTable());\n+        signature = Utility.methodSignatureToString(signature, name, access, true,\n+                getLocalVariableTable());\n@@ -248,1 +184,1 @@\n-            if (!(attribute instanceof Code || attribute instanceof ExceptionTable)) {\n+            if (!((attribute instanceof Code) || (attribute instanceof ExceptionTable))) {\n@@ -261,0 +197,76 @@\n+\n+\n+    \/**\n+     * @return deep copy of this method\n+     *\/\n+    public Method copy( final ConstantPool _constant_pool ) {\n+        return (Method) copy_(_constant_pool);\n+    }\n+\n+\n+    \/**\n+     * @return return type of method\n+     *\/\n+    public Type getReturnType() {\n+        return Type.getReturnType(getSignature());\n+    }\n+\n+\n+    \/**\n+     * @return array of method argument types\n+     *\/\n+    public Type[] getArgumentTypes() {\n+        return Type.getArgumentTypes(getSignature());\n+    }\n+\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two method objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the method's name XOR signature.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n+\n+    \/**\n+     * @return Annotations on the parameters of a method\n+     * @since 6.0\n+     *\/\n+    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n+        if (parameterAnnotationEntries == null) {\n+            parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());\n+        }\n+        return parameterAnnotationEntries;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Method.java","additions":133,"deletions":121,"binary":false,"changes":254,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\"> The class File Format :\n- *      The MethodParameters Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\">\n+ * The class File Format : The MethodParameters Attribute<\/a>\n@@ -37,1 +37,1 @@\n-public class MethodParameter implements Cloneable, Node {\n+public class MethodParameter implements Cloneable {\n@@ -52,2 +52,2 @@\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws java.io.IOException\n+     * @throws ClassFormatException\n@@ -60,3 +60,2 @@\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitMethodParameter(this);\n+    public int getNameIndex() {\n+        return nameIndex;\n@@ -65,10 +64,2 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public MethodParameter copy() {\n-        try {\n-            return (MethodParameter) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public void setNameIndex(final int name_index) {\n+        this.nameIndex = name_index;\n@@ -78,4 +69,1 @@\n-     * Dump object to file stream on binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException if an I\/O error occurs.\n+     * Returns the name of the parameter.\n@@ -83,4 +71,6 @@\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        file.writeShort(nameIndex);\n-        file.writeShort(accessFlags);\n-    }\n+    public String getParameterName(final ConstantPool constant_pool) {\n+        if (nameIndex == 0) {\n+            return null;\n+        }\n+        return ((ConstantUtf8) constant_pool.getConstant(nameIndex, Const.CONSTANT_Utf8)).getBytes();\n+       }\n@@ -92,12 +82,2 @@\n-    public int getNameIndex() {\n-        return nameIndex;\n-    }\n-\n-    \/**\n-     * Returns the name of the parameter.\n-     *\/\n-    public String getParameterName(final ConstantPool constantPool) {\n-        if (nameIndex == 0) {\n-            return null;\n-        }\n-        return constantPool.getConstantUtf8(nameIndex).getBytes();\n+    public void setAccessFlags(final int access_flags) {\n+        this.accessFlags = access_flags;\n@@ -110,0 +90,4 @@\n+    public boolean isSynthetic() {\n+        return (accessFlags & Const.ACC_SYNTHETIC) != 0;\n+    }\n+\n@@ -114,2 +98,2 @@\n-    public boolean isSynthetic() {\n-        return (accessFlags & Const.ACC_SYNTHETIC) != 0;\n+    public void accept(final Visitor v) {\n+        v.visitMethodParameter(this);\n@@ -118,2 +102,9 @@\n-    public void setAccessFlags(final int accessFlags) {\n-        this.accessFlags = accessFlags;\n+    \/**\n+     * Dump object to file stream on binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException\n+     *\/\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        file.writeShort(nameIndex);\n+        file.writeShort(accessFlags);\n@@ -122,2 +113,10 @@\n-    public void setNameIndex(final int nameIndex) {\n-        this.nameIndex = nameIndex;\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public MethodParameter copy() {\n+        try {\n+            return (MethodParameter) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/MethodParameter.java","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -36,2 +33,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\"> The class File Format :\n- *      The MethodParameters Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\">\n+ * The class File Format : The MethodParameters Attribute<\/a>\n@@ -40,1 +37,1 @@\n-public class MethodParameters extends Attribute implements Iterable<MethodParameter> {\n+public class MethodParameters extends Attribute {\n@@ -42,6 +39,1 @@\n-    \/**\n-     * Empty array.\n-     *\/\n-    private static final MethodParameter[] EMPTY_METHOD_PARAMETER_ARRAY = {};\n-\n-    private MethodParameter[] parameters = EMPTY_METHOD_PARAMETER_ARRAY;\n+    private MethodParameter[] parameters = new MethodParameter[0];\n@@ -49,2 +41,2 @@\n-    MethodParameters(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        super(Const.ATTR_METHOD_PARAMETERS, nameIndex, length, constantPool);\n+    MethodParameters(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        super(Const.ATTR_METHOD_PARAMETERS, name_index, length, constant_pool);\n@@ -52,3 +44,3 @@\n-        final int parameterCount = input.readUnsignedByte();\n-        parameters = new MethodParameter[parameterCount];\n-        for (int i = 0; i < parameterCount; i++) {\n+        final int parameters_count = input.readUnsignedByte();\n+        parameters = new MethodParameter[parameters_count];\n+        for (int i = 0; i < parameters_count; i++) {\n@@ -59,0 +51,8 @@\n+    public MethodParameter[] getParameters() {\n+        return parameters;\n+    }\n+\n+    public void setParameters(final MethodParameter[] parameters) {\n+        this.parameters = parameters;\n+    }\n+\n@@ -65,1 +65,1 @@\n-    public Attribute copy(final ConstantPool constantPool) {\n+    public Attribute copy(final ConstantPool _constant_pool) {\n@@ -69,2 +69,4 @@\n-        Arrays.setAll(c.parameters, i -> parameters[i].copy());\n-        c.setConstantPool(constantPool);\n+        for (int i = 0; i < parameters.length; i++) {\n+            c.parameters[i] = parameters[i].copy();\n+        }\n+        c.setConstantPool(_constant_pool);\n@@ -78,1 +80,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -81,3 +83,3 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n-        super.dump(file);\n-        file.writeByte(parameters.length);\n+       public void dump(final DataOutputStream file) throws IOException {\n+           super.dump(file);\n+           file.writeByte(parameters.length);\n@@ -88,13 +90,0 @@\n-\n-    public MethodParameter[] getParameters() {\n-        return parameters;\n-    }\n-\n-    @Override\n-    public Iterator<MethodParameter> iterator() {\n-        return Stream.of(parameters).iterator();\n-    }\n-\n-    public void setParameters(final MethodParameter[] parameters) {\n-        this.parameters = parameters;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/MethodParameters.java","additions":26,"deletions":37,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Arrays;\n@@ -32,2 +31,3 @@\n- * This class is derived from <em>Attribute<\/em> and represents the list of modules required, exported, opened or\n- * provided by a module. There may be at most one Module attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and represents the list of\n+ * modules required, exported, opened or provided by a module.\n+ * There may be at most one Module attribute in a ClassFile structure.\n@@ -35,1 +35,1 @@\n- * @see Attribute\n+ * @see   Attribute\n@@ -40,7 +40,0 @@\n-    \/**\n-     * The module file name extension.\n-     *\n-     * @since 6.7.0\n-     *\/\n-    public static final String EXTENSION = \".jmod\";\n-\n@@ -60,2 +53,1 @@\n-     *\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -64,2 +56,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -67,2 +59,2 @@\n-    Module(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        super(Const.ATTR_MODULE, nameIndex, length, constantPool);\n+    Module(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        super(Const.ATTR_MODULE, name_index, length, constant_pool);\n@@ -74,3 +66,3 @@\n-        final int requiresCount = input.readUnsignedShort();\n-        requiresTable = new ModuleRequires[requiresCount];\n-        for (int i = 0; i < requiresCount; i++) {\n+        final int requires_count = input.readUnsignedShort();\n+        requiresTable = new ModuleRequires[requires_count];\n+        for (int i = 0; i < requires_count; i++) {\n@@ -80,3 +72,3 @@\n-        final int exportsCount = input.readUnsignedShort();\n-        exportsTable = new ModuleExports[exportsCount];\n-        for (int i = 0; i < exportsCount; i++) {\n+        final int exports_count = input.readUnsignedShort();\n+        exportsTable = new ModuleExports[exports_count];\n+        for (int i = 0; i < exports_count; i++) {\n@@ -86,3 +78,3 @@\n-        final int opensCount = input.readUnsignedShort();\n-        opensTable = new ModuleOpens[opensCount];\n-        for (int i = 0; i < opensCount; i++) {\n+        final int opens_count = input.readUnsignedShort();\n+        opensTable = new ModuleOpens[opens_count];\n+        for (int i = 0; i < opens_count; i++) {\n@@ -98,3 +90,3 @@\n-        final int providesCount = input.readUnsignedShort();\n-        providesTable = new ModuleProvides[providesCount];\n-        for (int i = 0; i < providesCount; i++) {\n+        final int provides_count = input.readUnsignedShort();\n+        providesTable = new ModuleProvides[provides_count];\n+        for (int i = 0; i < provides_count; i++) {\n@@ -105,0 +97,1 @@\n+\n@@ -106,2 +99,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -112,1 +106,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -119,1 +113,2 @@\n-     * @return deep copy of this attribute\n+     * @return table of required modules\n+     * @see ModuleRequires\n@@ -121,3 +116,3 @@\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Module c = (Module) clone();\n+    public ModuleRequires[] getRequiresTable() {\n+        return requiresTable;\n+    }\n@@ -125,2 +120,0 @@\n-        c.requiresTable = new ModuleRequires[requiresTable.length];\n-        Arrays.setAll(c.requiresTable, i -> requiresTable[i].copy());\n@@ -128,2 +121,7 @@\n-        c.exportsTable = new ModuleExports[exportsTable.length];\n-        Arrays.setAll(c.exportsTable, i -> exportsTable[i].copy());\n+    \/**\n+     * @return table of exported interfaces\n+     * @see ModuleExports\n+     *\/\n+    public ModuleExports[] getExportsTable() {\n+        return exportsTable;\n+    }\n@@ -131,2 +129,0 @@\n-        c.opensTable = new ModuleOpens[opensTable.length];\n-        Arrays.setAll(c.opensTable, i -> opensTable[i].copy());\n@@ -134,2 +130,7 @@\n-        c.providesTable = new ModuleProvides[providesTable.length];\n-        Arrays.setAll(c.providesTable, i -> providesTable[i].copy());\n+    \/**\n+     * @return table of provided interfaces\n+     * @see ModuleOpens\n+     *\/\n+    public ModuleOpens[] getOpensTable() {\n+        return opensTable;\n+    }\n@@ -137,2 +138,7 @@\n-        c.setConstantPool(constantPool);\n-        return c;\n+\n+    \/**\n+     * @return table of provided interfaces\n+     * @see ModuleProvides\n+     *\/\n+    public ModuleProvides[] getProvidesTable() {\n+        return providesTable;\n@@ -141,0 +147,1 @@\n+\n@@ -145,1 +152,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -148,1 +155,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -181,31 +188,0 @@\n-    \/**\n-     * @return table of exported interfaces\n-     * @see ModuleExports\n-     *\/\n-    public ModuleExports[] getExportsTable() {\n-        return exportsTable;\n-    }\n-\n-    \/**\n-     * @return table of provided interfaces\n-     * @see ModuleOpens\n-     *\/\n-    public ModuleOpens[] getOpensTable() {\n-        return opensTable;\n-    }\n-\n-    \/**\n-     * @return table of provided interfaces\n-     * @see ModuleProvides\n-     *\/\n-    public ModuleProvides[] getProvidesTable() {\n-        return providesTable;\n-    }\n-\n-    \/**\n-     * @return table of required modules\n-     * @see ModuleRequires\n-     *\/\n-    public ModuleRequires[] getRequiresTable() {\n-        return requiresTable;\n-    }\n@@ -221,2 +197,2 @@\n-        buf.append(\"  name:    \").append(Utility.pathToPackage(cp.getConstantString(moduleNameIndex, Const.CONSTANT_Module))).append(\"\\n\");\n-        buf.append(\"  flags:   \").append(String.format(\"%04x\", moduleFlags)).append(\"\\n\");\n+        buf.append(\"  name:    \") .append(cp.getConstantString(moduleNameIndex, Const.CONSTANT_Module).replace('\/', '.')).append(\"\\n\");\n+        buf.append(\"  flags:   \") .append(String.format(\"%04x\", moduleFlags)).append(\"\\n\");\n@@ -224,1 +200,1 @@\n-        buf.append(\"  version: \").append(version).append(\"\\n\");\n+        buf.append(\"  version: \") .append(version).append(\"\\n\");\n@@ -243,2 +219,2 @@\n-            final String className = cp.getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"    \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n+            final String class_name = cp.getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"    \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n@@ -252,1 +228,33 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Module c = (Module) clone();\n+\n+        c.requiresTable = new ModuleRequires[requiresTable.length];\n+        for (int i = 0; i < requiresTable.length; i++) {\n+            c.requiresTable[i] = requiresTable[i].copy();\n+        }\n+\n+        c.exportsTable = new ModuleExports[exportsTable.length];\n+        for (int i = 0; i < exportsTable.length; i++) {\n+            c.exportsTable[i] = exportsTable[i].copy();\n+        }\n+\n+        c.opensTable = new ModuleOpens[opensTable.length];\n+        for (int i = 0; i < opensTable.length; i++) {\n+            c.opensTable[i] = opensTable[i].copy();\n+        }\n+\n+        c.providesTable = new ModuleProvides[providesTable.length];\n+        for (int i = 0; i < providesTable.length; i++) {\n+            c.providesTable[i] = providesTable[i].copy();\n+        }\n+\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Module.java","additions":93,"deletions":85,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the exports table of the Module attribute. Each entry describes a package which may\n- * open the parent module.\n+ * This class represents an entry in the exports table of the Module attribute.\n+ * Each entry describes a package which may open the parent module.\n@@ -34,1 +34,1 @@\n- * @see Module\n+ * @see   Module\n@@ -39,1 +39,1 @@\n-    private final int exportsIndex; \/\/ points to CONSTANT_Package_info\n+    private final int exportsIndex;  \/\/ points to CONSTANT_Package_info\n@@ -42,1 +42,2 @@\n-    private final int[] exportsToIndex; \/\/ points to CONSTANT_Module_info\n+    private final int[] exportsToIndex;  \/\/ points to CONSTANT_Module_info\n+\n@@ -60,0 +61,1 @@\n+\n@@ -61,2 +63,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -67,1 +70,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -73,12 +76,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleExports copy() {\n-        try {\n-            return (ModuleExports) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n@@ -91,1 +82,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -100,0 +91,1 @@\n+\n@@ -108,0 +100,1 @@\n+\n@@ -111,1 +104,1 @@\n-    public String toString(final ConstantPool constantPool) {\n+    public String toString( final ConstantPool constant_pool ) {\n@@ -113,2 +106,2 @@\n-        final String packageName = constantPool.constantToString(exportsIndex, Const.CONSTANT_Package);\n-        buf.append(Utility.compactClassName(packageName, false));\n+        final String package_name = constant_pool.constantToString(exportsIndex, Const.CONSTANT_Package);\n+        buf.append(Utility.compactClassName(package_name, false));\n@@ -118,2 +111,15 @@\n-            final String moduleName = constantPool.getConstantString(index, Const.CONSTANT_Module);\n-            buf.append(\"      \").append(Utility.compactClassName(moduleName, false)).append(\"\\n\");\n+            final String module_name = constant_pool.getConstantString(index, Const.CONSTANT_Module);\n+            buf.append(\"      \").append(Utility.compactClassName(module_name, false)).append(\"\\n\");\n+        }\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleExports copy() {\n+        try {\n+            return (ModuleExports) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n@@ -121,1 +127,1 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleExports.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +31,2 @@\n- * This class is derived from <em>Attribute<\/em> and indicates the main class of a module. There may be at most one\n- * ModuleMainClass attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and indicates the main class of a module.\n+ * There may be at most one ModuleMainClass attribute in a ClassFile structure.\n@@ -35,1 +34,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -41,0 +40,1 @@\n+\n@@ -42,7 +42,2 @@\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -50,3 +45,2 @@\n-    ModuleMainClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, 0, constantPool);\n-        mainClassIndex = input.readUnsignedShort();\n+    public ModuleMainClass(final ModuleMainClass c) {\n+        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n@@ -55,0 +49,1 @@\n+\n@@ -56,1 +51,1 @@\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -61,3 +56,4 @@\n-    public ModuleMainClass(final int nameIndex, final int length, final int mainClassIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_NEST_MEMBERS, nameIndex, length, constantPool);\n-        this.mainClassIndex = Args.requireU2(mainClassIndex, \"mainClassIndex\");\n+    public ModuleMainClass(final int name_index, final int length, final int mainClassIndex,\n+            final ConstantPool constantPool) {\n+        super(Const.ATTR_NEST_MEMBERS, name_index, length, constantPool);\n+        this.mainClassIndex = mainClassIndex;\n@@ -66,0 +62,1 @@\n+\n@@ -67,4 +64,6 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from input stream.\n+     * @param nameIndex Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException\n@@ -72,2 +71,3 @@\n-    public ModuleMainClass(final ModuleMainClass c) {\n-        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n+    ModuleMainClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, 0, constantPool);\n+        mainClassIndex = input.readUnsignedShort();\n@@ -76,0 +76,1 @@\n+\n@@ -77,2 +78,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -83,1 +85,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -87,9 +89,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final ModuleMainClass c = (ModuleMainClass) clone();\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -104,1 +97,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -109,0 +102,1 @@\n+\n@@ -116,0 +110,1 @@\n+\n@@ -119,1 +114,1 @@\n-    public void setHostClassIndex(final int mainClassIndex) {\n+    public void setHostClassIndex( final int mainClassIndex ) {\n@@ -123,0 +118,1 @@\n+\n@@ -130,2 +126,2 @@\n-        final String className = super.getConstantPool().getConstantString(mainClassIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(className, false));\n+        final String class_name = super.getConstantPool().getConstantString(mainClassIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(class_name, false));\n@@ -134,0 +130,11 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final ModuleMainClass c = (ModuleMainClass) clone();\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleMainClass.java","additions":47,"deletions":40,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the opens table of the Module attribute. Each entry describes a package which the\n- * parent module opens.\n+ * This class represents an entry in the opens table of the Module attribute.\n+ * Each entry describes a package which the parent module opens.\n@@ -34,1 +34,1 @@\n- * @see Module\n+ * @see   Module\n@@ -39,1 +39,1 @@\n-    private final int opensIndex; \/\/ points to CONSTANT_Package_info\n+    private final int opensIndex;  \/\/ points to CONSTANT_Package_info\n@@ -42,1 +42,2 @@\n-    private final int[] opensToIndex; \/\/ points to CONSTANT_Module_info\n+    private final int[] opensToIndex;  \/\/ points to CONSTANT_Module_info\n+\n@@ -60,0 +61,1 @@\n+\n@@ -61,2 +63,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -67,1 +70,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -73,12 +76,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleOpens copy() {\n-        try {\n-            return (ModuleOpens) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n@@ -91,1 +82,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -100,0 +91,1 @@\n+\n@@ -108,0 +100,1 @@\n+\n@@ -111,1 +104,1 @@\n-    public String toString(final ConstantPool constantPool) {\n+    public String toString( final ConstantPool constant_pool ) {\n@@ -113,2 +106,2 @@\n-        final String packageName = constantPool.constantToString(opensIndex, Const.CONSTANT_Package);\n-        buf.append(Utility.compactClassName(packageName, false));\n+        final String package_name = constant_pool.constantToString(opensIndex, Const.CONSTANT_Package);\n+        buf.append(Utility.compactClassName(package_name, false));\n@@ -118,2 +111,15 @@\n-            final String moduleName = constantPool.getConstantString(index, Const.CONSTANT_Module);\n-            buf.append(\"      \").append(Utility.compactClassName(moduleName, false)).append(\"\\n\");\n+            final String module_name = constant_pool.getConstantString(index, Const.CONSTANT_Module);\n+            buf.append(\"      \").append(Utility.compactClassName(module_name, false)).append(\"\\n\");\n+        }\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleOpens copy() {\n+        try {\n+            return (ModuleOpens) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n@@ -121,1 +127,1 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleOpens.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -26,1 +27,0 @@\n-import java.util.Arrays;\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +31,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents the list of packages that are exported or opened by the\n- * Module attribute. There may be at most one ModulePackages attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and represents the list of packages that are exported or opened by the Module attribute.\n+ * There may be at most one ModulePackages attribute in a ClassFile structure.\n@@ -35,2 +34,1 @@\n- * @see Attribute\n- * @LastModified: Feb 2023\n+ * @see     Attribute\n@@ -42,0 +40,1 @@\n+\n@@ -43,7 +42,2 @@\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -51,7 +45,2 @@\n-    ModulePackages(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (int[]) null, constantPool);\n-        final int packageCount = input.readUnsignedShort();\n-        packageIndexTable = new int[packageCount];\n-        for (int i = 0; i < packageCount; i++) {\n-            packageIndexTable[i] = input.readUnsignedShort();\n-        }\n+    public ModulePackages(final ModulePackages c) {\n+        this(c.getNameIndex(), c.getLength(), c.getPackageIndexTable(), c.getConstantPool());\n@@ -60,0 +49,1 @@\n+\n@@ -66,1 +56,2 @@\n-    public ModulePackages(final int nameIndex, final int length, final int[] packageIndexTable, final ConstantPool constantPool) {\n+    public ModulePackages(final int nameIndex, final int length, final int[] packageIndexTable,\n+            final ConstantPool constantPool) {\n@@ -68,2 +59,1 @@\n-        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : Const.EMPTY_INT_ARRAY;\n-        Args.requireU2(this.packageIndexTable.length, \"packageIndexTable.length\");\n+        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : new int[0];\n@@ -72,0 +62,1 @@\n+\n@@ -73,4 +64,6 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from input stream.\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -78,2 +71,7 @@\n-    public ModulePackages(final ModulePackages c) {\n-        this(c.getNameIndex(), c.getLength(), c.getPackageIndexTable(), c.getConstantPool());\n+    ModulePackages(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (int[]) null, constant_pool);\n+        final int number_of_packages = input.readUnsignedShort();\n+        packageIndexTable = new int[number_of_packages];\n+        for (int i = 0; i < number_of_packages; i++) {\n+            packageIndexTable[i] = input.readUnsignedShort();\n+        }\n@@ -82,0 +80,1 @@\n+\n@@ -83,2 +82,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -89,1 +89,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -93,12 +93,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final ModulePackages c = (ModulePackages) clone();\n-        if (packageIndexTable != null) {\n-            c.packageIndexTable = packageIndexTable.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -110,1 +98,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -113,1 +101,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -121,6 +109,0 @@\n-    \/**\n-     * @return Length of package table.\n-     *\/\n-    public int getNumberOfPackages() {\n-        return packageIndexTable == null ? 0 : packageIndexTable.length;\n-    }\n@@ -135,0 +117,9 @@\n+\n+    \/**\n+     * @return Length of package table.\n+     *\/\n+    public int getNumberOfPackages() {\n+        return packageIndexTable == null ? 0 : packageIndexTable.length;\n+    }\n+\n+\n@@ -140,1 +131,4 @@\n-        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(packageIndexTable[i], Const.CONSTANT_Package)));\n+        for (int i = 0; i < packageIndexTable.length; i++) {\n+            names[i] = super.getConstantPool().getConstantString(packageIndexTable[i],\n+                    Const.CONSTANT_Package).replace('\/', '.');\n+        }\n@@ -144,0 +138,1 @@\n+\n@@ -145,1 +140,2 @@\n-     * @param packageIndexTable the list of package indexes Also redefines number_of_packages according to table length.\n+     * @param packageIndexTable the list of package indexes\n+     * Also redefines number_of_packages according to table length.\n@@ -147,2 +143,2 @@\n-    public void setPackageIndexTable(final int[] packageIndexTable) {\n-        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : Const.EMPTY_INT_ARRAY;\n+    public void setPackageIndexTable( final int[] packageIndexTable ) {\n+        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : new int[0];\n@@ -151,0 +147,1 @@\n+\n@@ -161,2 +158,2 @@\n-            final String packageName = super.getConstantPool().getConstantString(index, Const.CONSTANT_Package);\n-            buf.append(\"  \").append(Utility.compactClassName(packageName, false)).append(\"\\n\");\n+            final String package_name = super.getConstantPool().getConstantString(index, Const.CONSTANT_Package);\n+            buf.append(\"  \").append(Utility.compactClassName(package_name, false)).append(\"\\n\");\n@@ -164,1 +161,17 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final ModulePackages c = (ModulePackages) clone();\n+        if (packageIndexTable != null) {\n+            c.packageIndexTable = new int[packageIndexTable.length];\n+            System.arraycopy(packageIndexTable, 0, c.packageIndexTable, 0,\n+                    packageIndexTable.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModulePackages.java","additions":73,"deletions":60,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the provides table of the Module attribute. Each entry describes a service\n- * implementation that the parent module provides.\n+ * This class represents an entry in the provides table of the Module attribute.\n+ * Each entry describes a service implementation that the parent module provides.\n@@ -34,1 +34,1 @@\n- * @see Module\n+ * @see   Module\n@@ -39,1 +39,1 @@\n-    private final int providesIndex; \/\/ points to CONSTANT_Class_info\n+    private final int providesIndex;  \/\/ points to CONSTANT_Class_info\n@@ -41,1 +41,2 @@\n-    private final int[] providesWithIndex; \/\/ points to CONSTANT_Class_info\n+    private final int[] providesWithIndex;  \/\/ points to CONSTANT_Class_info\n+\n@@ -58,0 +59,1 @@\n+\n@@ -59,2 +61,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -65,1 +68,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -71,12 +74,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleProvides copy() {\n-        try {\n-            return (ModuleProvides) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n@@ -89,1 +80,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -97,0 +88,1 @@\n+\n@@ -105,0 +97,1 @@\n+\n@@ -108,1 +101,1 @@\n-    public String toString(final ConstantPool constantPool) {\n+    public String toString( final ConstantPool constant_pool ) {\n@@ -110,2 +103,2 @@\n-        final String interfaceName = constantPool.constantToString(providesIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(interfaceName, false));\n+        final String interface_name = constant_pool.constantToString(providesIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(interface_name, false));\n@@ -114,2 +107,15 @@\n-            final String className = constantPool.getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"      \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n+            final String class_name = constant_pool.getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"      \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n+        }\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleProvides copy() {\n+        try {\n+            return (ModuleProvides) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n@@ -117,1 +123,1 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleProvides.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the requires table of the Module attribute. Each entry describes a module on which\n- * the parent module depends.\n+ * This class represents an entry in the requires table of the Module attribute.\n+ * Each entry describes a module on which the parent module depends.\n@@ -34,1 +34,1 @@\n- * @see Module\n+ * @see   Module\n@@ -39,1 +39,1 @@\n-    private final int requiresIndex; \/\/ points to CONSTANT_Module_info\n+    private final int requiresIndex;  \/\/ points to CONSTANT_Module_info\n@@ -41,1 +41,2 @@\n-    private final int requiresVersionIndex; \/\/ either 0 or points to CONSTANT_Utf8_info\n+    private final int requiresVersionIndex;  \/\/ either 0 or points to CONSTANT_Utf8_info\n+\n@@ -55,0 +56,1 @@\n+\n@@ -56,2 +58,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -62,1 +65,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -68,12 +71,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleRequires copy() {\n-        try {\n-            return (ModuleRequires) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n@@ -86,1 +77,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -92,0 +83,1 @@\n+\n@@ -100,0 +92,1 @@\n+\n@@ -103,1 +96,1 @@\n-    public String toString(final ConstantPool constantPool) {\n+    public String toString( final ConstantPool constant_pool ) {\n@@ -105,2 +98,2 @@\n-        final String moduleName = constantPool.constantToString(requiresIndex, Const.CONSTANT_Module);\n-        buf.append(Utility.compactClassName(moduleName, false));\n+        final String module_name = constant_pool.constantToString(requiresIndex, Const.CONSTANT_Module);\n+        buf.append(Utility.compactClassName(module_name, false));\n@@ -108,1 +101,1 @@\n-        final String version = requiresVersionIndex == 0 ? \"0\" : constantPool.getConstantString(requiresVersionIndex, Const.CONSTANT_Utf8);\n+        final String version = requiresVersionIndex == 0 ? \"0\" : constant_pool.getConstantString(requiresVersionIndex, Const.CONSTANT_Utf8);\n@@ -112,0 +105,13 @@\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleRequires copy() {\n+        try {\n+            return (ModuleRequires) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleRequires.java","additions":31,"deletions":25,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +31,3 @@\n- * This class is derived from <em>Attribute<\/em> and records the nest host of the nest to which the current class or\n- * interface claims to belong. There may be at most one NestHost attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and records the nest host of the nest\n+ * to which the current class or interface claims to belong.\n+ * There may be at most one NestHost attribute in a ClassFile structure.\n@@ -35,1 +35,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -41,0 +41,1 @@\n+\n@@ -42,7 +43,2 @@\n-     * Constructs object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initializes from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -50,3 +46,2 @@\n-    NestHost(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, 0, constantPool);\n-        hostClassIndex = input.readUnsignedShort();\n+    public NestHost(final NestHost c) {\n+        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n@@ -55,0 +50,1 @@\n+\n@@ -61,1 +57,2 @@\n-    public NestHost(final int nameIndex, final int length, final int hostClassIndex, final ConstantPool constantPool) {\n+    public NestHost(final int nameIndex, final int length, final int hostClassIndex,\n+            final ConstantPool constantPool) {\n@@ -63,1 +60,1 @@\n-        this.hostClassIndex = Args.requireU2(hostClassIndex, \"hostClassIndex\");\n+        this.hostClassIndex = hostClassIndex;\n@@ -66,0 +63,1 @@\n+\n@@ -67,4 +65,6 @@\n-     * Initializes from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Constructs object from input stream.\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -72,2 +72,3 @@\n-    public NestHost(final NestHost c) {\n-        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n+    NestHost(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, 0, constant_pool);\n+        hostClassIndex = input.readUnsignedShort();\n@@ -76,0 +77,1 @@\n+\n@@ -77,2 +79,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -83,1 +86,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -87,9 +90,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final NestHost c = (NestHost) clone();\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -104,1 +98,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -109,0 +103,1 @@\n+\n@@ -116,0 +111,1 @@\n+\n@@ -119,1 +115,1 @@\n-    public void setHostClassIndex(final int hostClassIndex) {\n+    public void setHostClassIndex( final int hostClassIndex ) {\n@@ -123,0 +119,1 @@\n+\n@@ -130,2 +127,2 @@\n-        final String className = super.getConstantPool().getConstantString(hostClassIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(className, false));\n+        final String class_name = super.getConstantPool().getConstantString(hostClassIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(class_name, false));\n@@ -134,0 +131,11 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final NestHost c = (NestHost) clone();\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/NestHost.java","additions":46,"deletions":38,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -26,1 +27,0 @@\n-import java.util.Arrays;\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,3 +31,3 @@\n- * This class is derived from <em>Attribute<\/em> and records the classes and interfaces that are authorized to claim\n- * membership in the nest hosted by the current class or interface. There may be at most one NestMembers attribute in a\n- * ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and records the classes and interfaces that\n+ * are authorized to claim membership in the nest hosted by the current class or interface.\n+ * There may be at most one NestMembers attribute in a ClassFile structure.\n@@ -36,2 +35,1 @@\n- * @see Attribute\n- * @LastModified: Feb 2023\n+ * @see     Attribute\n@@ -43,0 +41,1 @@\n+\n@@ -44,7 +43,2 @@\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -52,7 +46,2 @@\n-    NestMembers(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (int[]) null, constantPool);\n-        final int classCount = input.readUnsignedShort();\n-        classes = new int[classCount];\n-        for (int i = 0; i < classCount; i++) {\n-            classes[i] = input.readUnsignedShort();\n-        }\n+    public NestMembers(final NestMembers c) {\n+        this(c.getNameIndex(), c.getLength(), c.getClasses(), c.getConstantPool());\n@@ -61,0 +50,1 @@\n+\n@@ -62,1 +52,1 @@\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -65,1 +55,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -67,4 +57,4 @@\n-    public NestMembers(final int nameIndex, final int length, final int[] classes, final ConstantPool constantPool) {\n-        super(Const.ATTR_NEST_MEMBERS, nameIndex, length, constantPool);\n-        this.classes = classes != null ? classes : Const.EMPTY_INT_ARRAY;\n-        Args.requireU2(this.classes.length, \"classes.length\");\n+    public NestMembers(final int name_index, final int length, final int[] classes,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_NEST_MEMBERS, name_index, length, constant_pool);\n+        this.classes = classes != null ? classes : new int[0];\n@@ -73,0 +63,1 @@\n+\n@@ -74,4 +65,6 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from input stream.\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -79,2 +72,7 @@\n-    public NestMembers(final NestMembers c) {\n-        this(c.getNameIndex(), c.getLength(), c.getClasses(), c.getConstantPool());\n+    NestMembers(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (int[]) null, constant_pool);\n+        final int number_of_classes = input.readUnsignedShort();\n+        classes = new int[number_of_classes];\n+        for (int i = 0; i < number_of_classes; i++) {\n+            classes[i] = input.readUnsignedShort();\n+        }\n@@ -83,0 +81,1 @@\n+\n@@ -84,2 +83,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -90,1 +90,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -94,12 +94,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final NestMembers c = (NestMembers) clone();\n-        if (classes.length > 0) {\n-            c.classes = classes.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -111,1 +99,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -114,1 +102,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -122,0 +110,1 @@\n+\n@@ -129,0 +118,9 @@\n+\n+    \/**\n+     * @return Length of classes table.\n+     *\/\n+    public int getNumberClasses() {\n+        return classes == null ? 0 : classes.length;\n+    }\n+\n+\n@@ -134,1 +132,4 @@\n-        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(classes[i], Const.CONSTANT_Class)));\n+        for (int i = 0; i < classes.length; i++) {\n+            names[i] = super.getConstantPool().getConstantString(classes[i],\n+                    Const.CONSTANT_Class).replace('\/', '.');\n+        }\n@@ -138,6 +139,0 @@\n-    \/**\n-     * @return Length of classes table.\n-     *\/\n-    public int getNumberClasses() {\n-        return classes.length;\n-    }\n@@ -146,1 +141,2 @@\n-     * @param classes the list of class indexes Also redefines number_of_classes according to table length.\n+     * @param classes the list of class indexes\n+     * Also redefines number_of_classes according to table length.\n@@ -148,2 +144,2 @@\n-    public void setClasses(final int[] classes) {\n-        this.classes = classes != null ? classes : Const.EMPTY_INT_ARRAY;\n+    public void setClasses( final int[] classes ) {\n+        this.classes = classes != null ? classes : new int[0];\n@@ -152,0 +148,1 @@\n+\n@@ -162,2 +159,2 @@\n-            final String className = super.getConstantPool().getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"  \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n+            final String class_name = super.getConstantPool().getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"  \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n@@ -165,1 +162,17 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final NestMembers c = (NestMembers) clone();\n+        if (classes != null) {\n+            c.classes = new int[classes.length];\n+            System.arraycopy(classes, 0, c.classes, 0,\n+                    classes.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/NestMembers.java","additions":77,"deletions":64,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -29,1 +30,1 @@\n-    void accept(Visitor obj);\n+    void accept( Visitor obj );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Node.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference to a PMG attribute.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference\n+ * to a PMG attribute.\n@@ -33,1 +34,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -40,0 +41,11 @@\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n+     *\/\n+    public PMGClass(final PMGClass pgmClass) {\n+        this(pgmClass.getNameIndex(), pgmClass.getLength(), pgmClass.getPMGIndex(), pgmClass.getPMGClassIndex(),\n+            pgmClass.getConstantPool());\n+    }\n+\n+\n@@ -42,2 +54,1 @@\n-     *\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -46,2 +57,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -49,2 +60,3 @@\n-    PMGClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, input.readUnsignedShort(), input.readUnsignedShort(), constantPool);\n+    PMGClass(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, input.readUnsignedShort(), input.readUnsignedShort(), constant_pool);\n@@ -53,0 +65,1 @@\n+\n@@ -54,1 +67,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -60,2 +73,3 @@\n-    public PMGClass(final int nameIndex, final int length, final int pmgIndex, final int pmgClassIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_PMG, nameIndex, length, constantPool);\n+    public PMGClass(final int name_index, final int length, final int pmgIndex, final int pmgClassIndex,\n+            final ConstantPool constantPool) {\n+        super(Const.ATTR_PMG, name_index, length, constantPool);\n@@ -66,9 +80,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param pgmClass Source to copy.\n-     *\/\n-    public PMGClass(final PMGClass pgmClass) {\n-        this(pgmClass.getNameIndex(), pgmClass.getLength(), pgmClass.getPMGIndex(), pgmClass.getPMGClassIndex(), pgmClass.getConstantPool());\n-    }\n@@ -77,2 +82,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -83,1 +89,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -87,7 +93,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n-    }\n@@ -99,1 +98,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -102,1 +101,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -108,0 +107,1 @@\n+\n@@ -115,0 +115,1 @@\n+\n@@ -116,1 +117,1 @@\n-     * @return PMG class name.\n+     * @param pmgClassIndex\n@@ -118,2 +119,2 @@\n-    public String getPMGClassName() {\n-        return super.getConstantPool().getConstantUtf8(pmgClassIndex).getBytes();\n+    public void setPMGClassIndex( final int pmgClassIndex ) {\n+        this.pmgClassIndex = pmgClassIndex;\n@@ -122,0 +123,1 @@\n+\n@@ -129,0 +131,1 @@\n+\n@@ -130,1 +133,1 @@\n-     * @return PMG name.\n+     * @param pmgIndex\n@@ -132,2 +135,2 @@\n-    public String getPMGName() {\n-        return super.getConstantPool().getConstantUtf8(pmgIndex).getBytes();\n+    public void setPMGIndex( final int pmgIndex ) {\n+        this.pmgIndex = pmgIndex;\n@@ -136,0 +139,1 @@\n+\n@@ -137,1 +141,1 @@\n-     * @param pmgClassIndex\n+     * @return PMG name.\n@@ -139,2 +143,4 @@\n-    public void setPMGClassIndex(final int pmgClassIndex) {\n-        this.pmgClassIndex = pmgClassIndex;\n+    public String getPMGName() {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(pmgIndex,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -143,0 +149,1 @@\n+\n@@ -144,1 +151,1 @@\n-     * @param pmgIndex\n+     * @return PMG class name.\n@@ -146,2 +153,4 @@\n-    public void setPMGIndex(final int pmgIndex) {\n-        this.pmgIndex = pmgIndex;\n+    public String getPMGClassName() {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(pmgClassIndex,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -150,0 +159,1 @@\n+\n@@ -157,0 +167,9 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        return (Attribute) clone();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/PMGClass.java","additions":63,"deletions":44,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -38,14 +38,0 @@\n-    static final ParameterAnnotationEntry[] EMPTY_ARRAY = {};\n-\n-    public static ParameterAnnotationEntry[] createParameterAnnotationEntries(final Attribute[] attrs) {\n-        \/\/ Find attributes that contain parameter annotation data\n-        final List<ParameterAnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n-        for (final Attribute attribute : attrs) {\n-            if (attribute instanceof ParameterAnnotations) {\n-                final ParameterAnnotations runtimeAnnotations = (ParameterAnnotations) attribute;\n-                Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getParameterAnnotationEntries());\n-            }\n-        }\n-        return accumulatedAnnotations.toArray(ParameterAnnotationEntry.EMPTY_ARRAY);\n-    }\n-\n@@ -54,0 +40,1 @@\n+\n@@ -58,1 +45,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -60,4 +47,4 @@\n-    ParameterAnnotationEntry(final DataInput input, final ConstantPool constantPool) throws IOException {\n-        final int annotationTableLength = input.readUnsignedShort();\n-        annotationTable = new AnnotationEntry[annotationTableLength];\n-        for (int i = 0; i < annotationTableLength; i++) {\n+    ParameterAnnotationEntry(final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        final int annotation_table_length = input.readUnsignedShort();\n+        annotationTable = new AnnotationEntry[annotation_table_length];\n+        for (int i = 0; i < annotation_table_length; i++) {\n@@ -65,1 +52,1 @@\n-            annotationTable[i] = AnnotationEntry.read(input, constantPool, false);\n+            annotationTable[i] = AnnotationEntry.read(input, constant_pool, false);\n@@ -69,0 +56,1 @@\n+\n@@ -70,2 +58,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -76,1 +65,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -80,0 +69,7 @@\n+    \/**\n+     * returns the array of annotation entries in this annotation\n+     *\/\n+    public AnnotationEntry[] getAnnotationEntries() {\n+        return annotationTable;\n+    }\n+\n@@ -87,6 +83,11 @@\n-    \/**\n-     * returns the array of annotation entries in this annotation\n-     *\/\n-    public AnnotationEntry[] getAnnotationEntries() {\n-        return annotationTable;\n-    }\n+  public static ParameterAnnotationEntry[] createParameterAnnotationEntries(final Attribute[] attrs) {\n+      \/\/ Find attributes that contain parameter annotation data\n+      final List<ParameterAnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n+      for (final Attribute attribute : attrs) {\n+          if (attribute instanceof ParameterAnnotations) {\n+              final ParameterAnnotations runtimeAnnotations = (ParameterAnnotations)attribute;\n+              Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getParameterAnnotationEntries());\n+          }\n+      }\n+      return accumulatedAnnotations.toArray(new ParameterAnnotationEntry[accumulatedAnnotations.size()]);\n+  }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ParameterAnnotationEntry.java","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -35,1 +33,1 @@\n-public abstract class ParameterAnnotations extends Attribute implements Iterable<ParameterAnnotationEntry> {\n+public abstract class ParameterAnnotations extends Attribute {\n@@ -41,2 +39,2 @@\n-     * @param parameterAnnotationType the subclass type of the parameter annotation\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param parameter_annotation_type the subclass type of the parameter annotation\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -45,1 +43,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -47,7 +45,8 @@\n-    ParameterAnnotations(final byte parameterAnnotationType, final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n-        throws IOException {\n-        this(parameterAnnotationType, nameIndex, length, (ParameterAnnotationEntry[]) null, constantPool);\n-        final int numParameters = input.readUnsignedByte();\n-        parameterAnnotationTable = new ParameterAnnotationEntry[numParameters];\n-        for (int i = 0; i < numParameters; i++) {\n-            parameterAnnotationTable[i] = new ParameterAnnotationEntry(input, constantPool);\n+    ParameterAnnotations(final byte parameter_annotation_type, final int name_index, final int length,\n+            final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(parameter_annotation_type, name_index, length, (ParameterAnnotationEntry[]) null,\n+                constant_pool);\n+        final int num_parameters = input.readUnsignedByte();\n+        parameterAnnotationTable = new ParameterAnnotationEntry[num_parameters];\n+        for (int i = 0; i < num_parameters; i++) {\n+            parameterAnnotationTable[i] = new ParameterAnnotationEntry(input, constant_pool);\n@@ -57,0 +56,1 @@\n+\n@@ -65,1 +65,1 @@\n-        final ParameterAnnotationEntry[] parameterAnnotationTable, final ConstantPool constantPool) {\n+            final ParameterAnnotationEntry[] parameterAnnotationTable, final ConstantPool constantPool) {\n@@ -70,0 +70,1 @@\n+\n@@ -71,2 +72,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +79,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -81,0 +83,1 @@\n+\n@@ -82,1 +85,1 @@\n-     * @return deep copy of this attribute\n+     * @param parameterAnnotationTable the entries to set in this parameter annotation\n@@ -84,3 +87,2 @@\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n+    public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameterAnnotationTable ) {\n+        this.parameterAnnotationTable = parameterAnnotationTable;\n@@ -89,10 +91,0 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        super.dump(dos);\n-        dos.writeByte(parameterAnnotationTable.length);\n-\n-        for (final ParameterAnnotationEntry element : parameterAnnotationTable) {\n-            element.dump(dos);\n-        }\n-\n-    }\n@@ -101,1 +93,1 @@\n-     * returns the array of parameter annotation entries in this parameter annotation\n+     * @return the parameter annotation entry table\n@@ -103,1 +95,1 @@\n-    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n+    public final ParameterAnnotationEntry[] getParameterAnnotationTable() {\n@@ -107,0 +99,1 @@\n+\n@@ -108,1 +101,1 @@\n-     * @return the parameter annotation entry table\n+     * returns the array of parameter annotation entries in this parameter annotation\n@@ -110,1 +103,1 @@\n-    public final ParameterAnnotationEntry[] getParameterAnnotationTable() {\n+    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n@@ -115,2 +108,9 @@\n-    public Iterator<ParameterAnnotationEntry> iterator() {\n-        return Stream.of(parameterAnnotationTable).iterator();\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        super.dump(dos);\n+        dos.writeByte(parameterAnnotationTable.length);\n+\n+        for (final ParameterAnnotationEntry element : parameterAnnotationTable) {\n+            element.dump(dos);\n+        }\n+\n@@ -120,1 +120,1 @@\n-     * @param parameterAnnotationTable the entries to set in this parameter annotation\n+     * @return deep copy of this attribute\n@@ -122,2 +122,3 @@\n-    public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameterAnnotationTable) {\n-        this.parameterAnnotationTable = parameterAnnotationTable;\n+    @Override\n+    public Attribute copy( final ConstantPool constant_pool ) {\n+        return (Attribute) clone();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ParameterAnnotations.java","additions":41,"deletions":40,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * represents an annotation that is represented in the class file but is not provided to the JVM.\n+ * represents an annotation that is represented in the class file but is not\n+ * provided to the JVM.\n@@ -35,2 +36,2 @@\n-public class RuntimeInvisibleAnnotations extends Annotations {\n-\n+public class RuntimeInvisibleAnnotations extends Annotations\n+{\n@@ -38,5 +39,8 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param name_index\n+     *            Index pointing to the name <em>Code<\/em>\n+     * @param length\n+     *            Content length in bytes\n+     * @param input\n+     *            Input stream\n+     * @param constant_pool\n+     *            Array of constants\n@@ -44,2 +48,4 @@\n-    public RuntimeInvisibleAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        super(Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS, nameIndex, length, input, constantPool, false);\n+    public RuntimeInvisibleAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException\n+    {\n+        super(Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS, name_index, length, input, constant_pool, false);\n@@ -52,1 +58,2 @@\n-    public Attribute copy(final ConstantPool constantPool) {\n+    public Attribute copy(final ConstantPool constant_pool)\n+    {\n@@ -57,1 +64,2 @@\n-    public final void dump(final DataOutputStream dos) throws IOException {\n+    public final void dump(final DataOutputStream dos) throws IOException\n+    {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeInvisibleAnnotations.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * Represents a parameter annotation that is represented in the class file but is not provided to the JVM.\n+ * Represents a parameter annotation that is represented in the class file\n+ * but is not provided to the JVM.\n@@ -37,1 +38,1 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -40,2 +41,1 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param constant_pool Array of constants\n@@ -43,3 +43,3 @@\n-    public RuntimeInvisibleParameterAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n-        throws IOException {\n-        super(Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, nameIndex, length, input, constantPool);\n+    public RuntimeInvisibleParameterAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        super(Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, name_index, length, input, constant_pool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeInvisibleParameterAnnotations.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * represents an annotation that is represented in the class file and is provided to the JVM.\n+ * represents an annotation that is represented in the class file and is\n+ * provided to the JVM.\n@@ -35,2 +36,2 @@\n-public class RuntimeVisibleAnnotations extends Annotations {\n-\n+public class RuntimeVisibleAnnotations extends Annotations\n+{\n@@ -38,5 +39,8 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param name_index\n+     *            Index pointing to the name <em>Code<\/em>\n+     * @param length\n+     *            Content length in bytes\n+     * @param input\n+     *            Input stream\n+     * @param constant_pool\n+     *            Array of constants\n@@ -44,2 +48,3 @@\n-    public RuntimeVisibleAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        super(Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, nameIndex, length, input, constantPool, true);\n+    public RuntimeVisibleAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException\n+    {\n+        super(Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, name_index, length, input, constant_pool, true);\n@@ -52,1 +57,2 @@\n-    public Attribute copy(final ConstantPool constantPool) {\n+    public Attribute copy(final ConstantPool constant_pool)\n+    {\n@@ -57,1 +63,2 @@\n-    public final void dump(final DataOutputStream dos) throws IOException {\n+    public final void dump(final DataOutputStream dos) throws IOException\n+    {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeVisibleAnnotations.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * Represents a parameter annotation that is represented in the class file and is provided to the JVM.\n+ * Represents a parameter annotation that is represented in the class file\n+ * and is provided to the JVM.\n@@ -37,1 +38,1 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -40,2 +41,1 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param constant_pool Array of constants\n@@ -43,3 +43,3 @@\n-    public RuntimeVisibleParameterAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n-        throws IOException {\n-        super(Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, nameIndex, length, input, constantPool);\n+    public RuntimeVisibleParameterAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        super(Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, name_index, length, input, constant_pool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeVisibleParameterAnnotations.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.nio.charset.StandardCharsets;\n-import java.util.Objects;\n@@ -32,1 +30,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -35,1 +32,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference to a GJ attribute.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference\n+ * to a GJ attribute.\n@@ -37,1 +35,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -41,0 +39,90 @@\n+    private int signatureIndex;\n+\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n+     *\/\n+    public Signature(final Signature c) {\n+        this(c.getNameIndex(), c.getLength(), c.getSignatureIndex(), c.getConstantPool());\n+    }\n+\n+\n+    \/**\n+     * Construct object from file stream.\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n+     *\/\n+    Signature(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, input.readUnsignedShort(), constant_pool);\n+    }\n+\n+\n+    \/**\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param signatureIndex Index in constant pool to CONSTANT_Utf8\n+     * @param constant_pool Array of constants\n+     *\/\n+    public Signature(final int name_index, final int length, final int signatureIndex, final ConstantPool constant_pool) {\n+        super(Const.ATTR_SIGNATURE, name_index, length, constant_pool);\n+        this.signatureIndex = signatureIndex;\n+    }\n+\n+\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        \/\/System.err.println(\"Visiting non-standard Signature object\");\n+        v.visitSignature(this);\n+    }\n+\n+\n+    \/**\n+     * Dump source file attribute to file stream in binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream file ) throws IOException {\n+        super.dump(file);\n+        file.writeShort(signatureIndex);\n+    }\n+\n+\n+    \/**\n+     * @return Index in constant pool of source file name.\n+     *\/\n+    public int getSignatureIndex() {\n+        return signatureIndex;\n+    }\n+\n+\n+    \/**\n+     * @param signatureIndex the index info the constant pool of this signature\n+     *\/\n+    public void setSignatureIndex( final int signatureIndex ) {\n+        this.signatureIndex = signatureIndex;\n+    }\n+\n+\n+    \/**\n+     * @return GJ signature.\n+     *\/\n+    public String getSignature() {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(signatureIndex,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n+    }\n+\n@@ -47,1 +135,1 @@\n-            super(data.getBytes(StandardCharsets.UTF_8));\n+            super(data.getBytes());\n@@ -50,0 +138,1 @@\n+\n@@ -51,1 +140,1 @@\n-            return new String(buf, StandardCharsets.UTF_8);\n+            return new String(buf);\n@@ -54,0 +143,1 @@\n+\n@@ -61,3 +151,0 @@\n-    private static boolean identStart(final int ch) {\n-        return ch == 'T' || ch == 'L';\n-    }\n@@ -65,8 +152,2 @@\n-    \/\/ @since 6.0 is no longer final\n-    public static boolean isActualParameterList(final String s) {\n-        return s.startsWith(\"L\") && s.endsWith(\">;\");\n-    }\n-\n-    \/\/ @since 6.0 is no longer final\n-    public static boolean isFormalParameterList(final String s) {\n-        return s.startsWith(\"<\") && s.indexOf(':') > 0;\n+    private static boolean identStart( final int ch ) {\n+        return ch == 'T' || ch == 'L';\n@@ -75,32 +156,0 @@\n-    private static void matchGJIdent(final MyByteArrayInputStream in, final StringBuilder buf) {\n-        int ch;\n-        matchIdent(in, buf);\n-        ch = in.read();\n-        if (ch == '<' || ch == '(') { \/\/ Parameterized or method\n-            \/\/ System.out.println(\"Enter <\");\n-            buf.append((char) ch);\n-            matchGJIdent(in, buf);\n-            while ((ch = in.read()) != '>' && ch != ')') { \/\/ List of parameters\n-                if (ch == -1) {\n-                    throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" reaching EOF\");\n-                }\n-                \/\/ System.out.println(\"Still no >\");\n-                buf.append(\", \");\n-                in.unread();\n-                matchGJIdent(in, buf); \/\/ Recursive call\n-            }\n-            \/\/ System.out.println(\"Exit >\");\n-            buf.append((char) ch);\n-        } else {\n-            in.unread();\n-        }\n-        ch = in.read();\n-        if (identStart(ch)) {\n-            in.unread();\n-            matchGJIdent(in, buf);\n-        } else if (ch == ')') {\n-            in.unread();\n-        } else if (ch != ';') {\n-            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" read \" + (char) ch);\n-        }\n-    }\n@@ -108,1 +157,1 @@\n-    private static void matchIdent(final MyByteArrayInputStream in, final StringBuilder buf) {\n+    private static void matchIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {\n@@ -111,1 +160,2 @@\n-            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" no ident, reaching EOF\");\n+            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData()\n+                    + \" no ident, reaching EOF\");\n@@ -113,1 +163,1 @@\n-        \/\/ System.out.println(\"return from ident:\" + (char)ch);\n+        \/\/System.out.println(\"return from ident:\" + (char)ch);\n@@ -123,5 +173,1 @@\n-                final int skipExpected = \"Ljava\/lang\/Object\".length();\n-                final long skipActual = in.skip(skipExpected);\n-                if (skipActual != skipExpected) {\n-                    throw new IllegalStateException(String.format(\"Unexpected skip: expected=%,d, actual=%,d\", skipExpected, skipActual));\n-                }\n+                in.skip(\"Ljava\/lang\/Object\".length());\n@@ -131,1 +177,1 @@\n-                \/\/ System.out.println(\"so far:\" + buf2 + \":next:\" +(char)ch);\n+                \/\/System.out.println(\"so far:\" + buf2 + \":next:\" +(char)ch);\n@@ -144,4 +190,4 @@\n-            \/\/ System.out.println(\"within ident:\"+ (char)ch);\n-        } while (ch != -1 && (Character.isJavaIdentifierPart((char) ch) || ch == '\/'));\n-        buf.append(Utility.pathToPackage(buf2.toString()));\n-        \/\/ System.out.println(\"regular return ident:\"+ (char)ch + \":\" + buf2);\n+            \/\/System.out.println(\"within ident:\"+ (char)ch);\n+        } while ((ch != -1) && (Character.isJavaIdentifierPart((char) ch) || (ch == '\/')));\n+        buf.append(buf2.toString().replace('\/', '.'));\n+        \/\/System.out.println(\"regular return ident:\"+ (char)ch + \":\" + buf2);\n@@ -153,2 +199,39 @@\n-    public static String translate(final String s) {\n-        \/\/ System.out.println(\"Sig:\" + s);\n+\n+    private static void matchGJIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {\n+        int ch;\n+        matchIdent(in, buf);\n+        ch = in.read();\n+        if ((ch == '<') || ch == '(') { \/\/ Parameterized or method\n+            \/\/System.out.println(\"Enter <\");\n+            buf.append((char) ch);\n+            matchGJIdent(in, buf);\n+            while (((ch = in.read()) != '>') && (ch != ')')) { \/\/ List of parameters\n+                if (ch == -1) {\n+                    throw new IllegalArgumentException(\"Illegal signature: \" + in.getData()\n+                            + \" reaching EOF\");\n+                }\n+                \/\/System.out.println(\"Still no >\");\n+                buf.append(\", \");\n+                in.unread();\n+                matchGJIdent(in, buf); \/\/ Recursive call\n+            }\n+            \/\/System.out.println(\"Exit >\");\n+            buf.append((char) ch);\n+        } else {\n+            in.unread();\n+        }\n+        ch = in.read();\n+        if (identStart(ch)) {\n+            in.unread();\n+            matchGJIdent(in, buf);\n+        } else if (ch == ')') {\n+            in.unread();\n+            return;\n+        } else if (ch != ';') {\n+            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" read \" + (char) ch);\n+        }\n+    }\n+\n+\n+    public static String translate( final String s ) {\n+        \/\/System.out.println(\"Sig:\" + s);\n@@ -160,14 +243,0 @@\n-    private int signatureIndex;\n-\n-    \/**\n-     * Construct object from file stream.\n-     *\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    Signature(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n-    }\n@@ -175,11 +244,3 @@\n-    \/**\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param signatureIndex Index in constant pool to CONSTANT_Utf8\n-     * @param constantPool Array of constants\n-     *\/\n-    public Signature(final int nameIndex, final int length, final int signatureIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_SIGNATURE, nameIndex, Args.require(length, 2, \"Signature length attribute\"), constantPool);\n-        this.signatureIndex = signatureIndex;\n-        \/\/ validate:\n-        Objects.requireNonNull(constantPool.getConstantUtf8(signatureIndex), \"constantPool.getConstantUtf8(signatureIndex)\");\n+    \/\/ @since 6.0 is no longer final\n+    public static boolean isFormalParameterList( final String s ) {\n+        return s.startsWith(\"<\") && (s.indexOf(':') > 0);\n@@ -188,9 +249,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public Signature(final Signature c) {\n-        this(c.getNameIndex(), c.getLength(), c.getSignatureIndex(), c.getConstantPool());\n-    }\n@@ -198,10 +250,3 @@\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        \/\/ System.err.println(\"Visiting non-standard Signature object\");\n-        v.visitSignature(this);\n+    \/\/ @since 6.0 is no longer final\n+    public static boolean isActualParameterList( final String s ) {\n+        return s.startsWith(\"L\") && s.endsWith(\">;\");\n@@ -210,7 +255,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n-    }\n@@ -219,4 +257,1 @@\n-     * Dump source file attribute to file stream in binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException if an I\/O error occurs.\n+     * @return String representation\n@@ -225,17 +260,3 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n-        super.dump(file);\n-        file.writeShort(signatureIndex);\n-    }\n-\n-    \/**\n-     * @return GJ signature.\n-     *\/\n-    public String getSignature() {\n-        return super.getConstantPool().getConstantUtf8(signatureIndex).getBytes();\n-    }\n-\n-    \/**\n-     * @return Index in constant pool of source file name.\n-     *\/\n-    public int getSignatureIndex() {\n-        return signatureIndex;\n+    public String toString() {\n+        final String s = getSignature();\n+        return \"Signature: \" + s;\n@@ -244,6 +265,0 @@\n-    \/**\n-     * @param signatureIndex the index info the constant pool of this signature\n-     *\/\n-    public void setSignatureIndex(final int signatureIndex) {\n-        this.signatureIndex = signatureIndex;\n-    }\n@@ -252,1 +267,1 @@\n-     * @return String representation\n+     * @return deep copy of this attribute\n@@ -255,2 +270,2 @@\n-    public String toString() {\n-        return \"Signature: \" + getSignature();\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        return (Attribute) clone();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Signature.java","additions":161,"deletions":146,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-public class SimpleElementValue extends ElementValue {\n+public class SimpleElementValue extends ElementValue\n+{\n@@ -35,1 +36,2 @@\n-    public SimpleElementValue(final int type, final int index, final ConstantPool cpool) {\n+    public SimpleElementValue(final int type, final int index, final ConstantPool cpool)\n+    {\n@@ -40,21 +42,0 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        final int type = super.getType();\n-        dos.writeByte(type); \/\/ u1 kind of value\n-        switch (type) {\n-        case PRIMITIVE_INT:\n-        case PRIMITIVE_BYTE:\n-        case PRIMITIVE_CHAR:\n-        case PRIMITIVE_FLOAT:\n-        case PRIMITIVE_LONG:\n-        case PRIMITIVE_BOOLEAN:\n-        case PRIMITIVE_SHORT:\n-        case PRIMITIVE_DOUBLE:\n-        case STRING:\n-            dos.writeShort(getIndex());\n-            break;\n-        default:\n-            throw new ClassFormatException(\"SimpleElementValue doesnt know how to write out type \" + type);\n-        }\n-    }\n-\n@@ -64,1 +45,2 @@\n-    public int getIndex() {\n+    public int getIndex()\n+    {\n@@ -68,3 +50,10 @@\n-    public boolean getValueBoolean() {\n-        if (super.getType() != PRIMITIVE_BOOLEAN) {\n-            throw new IllegalStateException(\"Dont call getValueBoolean() on a non BOOLEAN ElementValue\");\n+    public void setIndex(final int index)\n+    {\n+        this.index = index;\n+    }\n+\n+    public String getValueString()\n+    {\n+        if (super.getType() != STRING) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueString() on a non STRING ElementValue\");\n@@ -72,2 +61,14 @@\n-        final ConstantInteger bo = (ConstantInteger) super.getConstantPool().getConstant(getIndex());\n-        return bo.getBytes() != 0;\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(getIndex(),\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n+    }\n+\n+    public int getValueInt()\n+    {\n+        if (super.getType() != PRIMITIVE_INT) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueString() on a non STRING ElementValue\");\n+        }\n+        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n+                Const.CONSTANT_Integer);\n+        return c.getBytes();\n@@ -76,1 +77,2 @@\n-    public byte getValueByte() {\n+    public byte getValueByte()\n+    {\n@@ -78,1 +80,2 @@\n-            throw new IllegalStateException(\"Dont call getValueByte() on a non BYTE ElementValue\");\n+            throw new IllegalStateException(\n+                    \"Dont call getValueByte() on a non BYTE ElementValue\");\n@@ -80,1 +83,3 @@\n-        return (byte) super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n+        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n+                Const.CONSTANT_Integer);\n+        return (byte) c.getBytes();\n@@ -83,1 +88,2 @@\n-    public char getValueChar() {\n+    public char getValueChar()\n+    {\n@@ -85,1 +91,2 @@\n-            throw new IllegalStateException(\"Dont call getValueChar() on a non CHAR ElementValue\");\n+            throw new IllegalStateException(\n+                    \"Dont call getValueChar() on a non CHAR ElementValue\");\n@@ -87,1 +94,3 @@\n-        return (char) super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n+        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n+                Const.CONSTANT_Integer);\n+        return (char) c.getBytes();\n@@ -90,3 +99,5 @@\n-    public double getValueDouble() {\n-        if (super.getType() != PRIMITIVE_DOUBLE) {\n-            throw new IllegalStateException(\"Dont call getValueDouble() on a non DOUBLE ElementValue\");\n+    public long getValueLong()\n+    {\n+        if (super.getType() != PRIMITIVE_LONG) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueLong() on a non LONG ElementValue\");\n@@ -94,2 +105,2 @@\n-        final ConstantDouble d = (ConstantDouble) super.getConstantPool().getConstant(getIndex());\n-        return d.getBytes();\n+        final ConstantLong j = (ConstantLong) super.getConstantPool().getConstant(getIndex());\n+        return j.getBytes();\n@@ -98,1 +109,2 @@\n-    public float getValueFloat() {\n+    public float getValueFloat()\n+    {\n@@ -100,1 +112,2 @@\n-            throw new IllegalStateException(\"Dont call getValueFloat() on a non FLOAT ElementValue\");\n+            throw new IllegalStateException(\n+                    \"Dont call getValueFloat() on a non FLOAT ElementValue\");\n@@ -106,3 +119,5 @@\n-    public int getValueInt() {\n-        if (super.getType() != PRIMITIVE_INT) {\n-            throw new IllegalStateException(\"Dont call getValueInt() on a non INT ElementValue\");\n+    public double getValueDouble()\n+    {\n+        if (super.getType() != PRIMITIVE_DOUBLE) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueDouble() on a non DOUBLE ElementValue\");\n@@ -110,1 +125,2 @@\n-        return super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n+        final ConstantDouble d = (ConstantDouble) super.getConstantPool().getConstant(getIndex());\n+        return d.getBytes();\n@@ -113,3 +129,5 @@\n-    public long getValueLong() {\n-        if (super.getType() != PRIMITIVE_LONG) {\n-            throw new IllegalStateException(\"Dont call getValueLong() on a non LONG ElementValue\");\n+    public boolean getValueBoolean()\n+    {\n+        if (super.getType() != PRIMITIVE_BOOLEAN) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueBoolean() on a non BOOLEAN ElementValue\");\n@@ -117,2 +135,2 @@\n-        final ConstantLong j = (ConstantLong) super.getConstantPool().getConstant(getIndex());\n-        return j.getBytes();\n+        final ConstantInteger bo = (ConstantInteger) super.getConstantPool().getConstant(getIndex());\n+        return bo.getBytes() != 0;\n@@ -121,1 +139,2 @@\n-    public short getValueShort() {\n+    public short getValueShort()\n+    {\n@@ -123,1 +142,2 @@\n-            throw new IllegalStateException(\"Dont call getValueShort() on a non SHORT ElementValue\");\n+            throw new IllegalStateException(\n+                    \"Dont call getValueShort() on a non SHORT ElementValue\");\n@@ -129,9 +149,4 @@\n-    public String getValueString() {\n-        if (super.getType() != STRING) {\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n-        }\n-        return super.getConstantPool().getConstantUtf8(getIndex()).getBytes();\n-    }\n-\n-    public void setIndex(final int index) {\n-        this.index = index;\n+    @Override\n+    public String toString()\n+    {\n+        return stringifyValue();\n@@ -142,1 +157,2 @@\n-    public String stringifyValue() {\n+    public String stringifyValue()\n+    {\n@@ -144,2 +160,3 @@\n-        final int type = super.getType();\n-        switch (type) {\n+        final int _type = super.getType();\n+        switch (_type)\n+        {\n@@ -147,1 +164,3 @@\n-            return Integer.toString(cpool.getConstantInteger(getIndex()).getBytes());\n+            final ConstantInteger c = (ConstantInteger) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Integer);\n+            return Integer.toString(c.getBytes());\n@@ -149,1 +168,2 @@\n-            final ConstantLong j = cpool.getConstant(getIndex(), Const.CONSTANT_Long, ConstantLong.class);\n+            final ConstantLong j = (ConstantLong) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Long);\n@@ -152,1 +172,2 @@\n-            final ConstantDouble d = cpool.getConstant(getIndex(), Const.CONSTANT_Double, ConstantDouble.class);\n+            final ConstantDouble d = (ConstantDouble) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Double);\n@@ -155,1 +176,2 @@\n-            final ConstantFloat f = cpool.getConstant(getIndex(), Const.CONSTANT_Float, ConstantFloat.class);\n+            final ConstantFloat f = (ConstantFloat) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Float);\n@@ -158,1 +180,2 @@\n-            final ConstantInteger s = cpool.getConstantInteger(getIndex());\n+            final ConstantInteger s = (ConstantInteger) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Integer);\n@@ -161,1 +184,2 @@\n-            final ConstantInteger b = cpool.getConstantInteger(getIndex());\n+            final ConstantInteger b = (ConstantInteger) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Integer);\n@@ -164,2 +188,3 @@\n-            final ConstantInteger ch = cpool.getConstantInteger(getIndex());\n-            return String.valueOf((char) ch.getBytes());\n+            final ConstantInteger ch = (ConstantInteger) cpool.getConstant(\n+                    getIndex(), Const.CONSTANT_Integer);\n+            return String.valueOf((char)ch.getBytes());\n@@ -167,1 +192,2 @@\n-            final ConstantInteger bo = cpool.getConstantInteger(getIndex());\n+            final ConstantInteger bo = (ConstantInteger) cpool.getConstant(\n+                    getIndex(), Const.CONSTANT_Integer);\n@@ -173,1 +199,3 @@\n-            return cpool.getConstantUtf8(getIndex()).getBytes();\n+            final ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Utf8);\n+            return cu8.getBytes();\n@@ -175,1 +203,1 @@\n-            throw new IllegalStateException(\"SimpleElementValue class does not know how to stringify type \" + type);\n+            throw new IllegalStateException(\"SimpleElementValue class does not know how to stringify type \" + _type);\n@@ -180,2 +208,20 @@\n-    public String toString() {\n-        return stringifyValue();\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        final int _type = super.getType();\n+        dos.writeByte(_type); \/\/ u1 kind of value\n+        switch (_type)\n+        {\n+        case PRIMITIVE_INT:\n+        case PRIMITIVE_BYTE:\n+        case PRIMITIVE_CHAR:\n+        case PRIMITIVE_FLOAT:\n+        case PRIMITIVE_LONG:\n+        case PRIMITIVE_BOOLEAN:\n+        case PRIMITIVE_SHORT:\n+        case PRIMITIVE_DOUBLE:\n+        case STRING:\n+            dos.writeShort(getIndex());\n+            break;\n+        default:\n+            throw new IllegalStateException(\"SimpleElementValue doesnt know how to write out type \" + _type);\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/SimpleElementValue.java","additions":124,"deletions":78,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,3 +31,4 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference to the source file of this class. At most\n- * one SourceFile attribute should appear per classfile. The intention of this class is that it is instantiated from the\n- * <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference\n+ * to the source file of this class.  At most one SourceFile attribute\n+ * should appear per classfile.  The intention of this class is that it is\n+ * instantiated from the <em>Attribute.readAttribute()<\/em> method.\n@@ -36,1 +36,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -42,0 +42,10 @@\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n+     *\/\n+    public SourceFile(final SourceFile c) {\n+        this(c.getNameIndex(), c.getLength(), c.getSourceFileIndex(), c.getConstantPool());\n+    }\n+\n+\n@@ -44,2 +54,1 @@\n-     *\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -48,2 +57,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -51,2 +60,3 @@\n-    SourceFile(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n+    SourceFile(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, input.readUnsignedShort(), constant_pool);\n@@ -55,0 +65,1 @@\n+\n@@ -56,1 +67,2 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8, which should represent the string \"SourceFile\".\n+     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n+     * should represent the string \"SourceFile\".\n@@ -58,5 +70,8 @@\n-     * @param constantPool The constant pool that this attribute is associated with.\n-     * @param sourceFileIndex Index in constant pool to CONSTANT_Utf8. This string will be interpreted as the name of the\n-     *        file from which this class was compiled. It will not be interpreted as indicating the name of the directory\n-     *        contqining the file or an absolute path; this information has to be supplied the consumer of this attribute -\n-     *        in many cases, the JVM.\n+     * @param constantPool The constant pool that this attribute is\n+     * associated with.\n+     * @param sourceFileIndex Index in constant pool to CONSTANT_Utf8.  This\n+     * string will be interpreted as the name of the file from which this\n+     * class was compiled.  It will not be interpreted as indicating the name\n+     * of the directory contqining the file or an absolute path; this\n+     * information has to be supplied the consumer of this attribute - in\n+     * many cases, the JVM.\n@@ -64,3 +79,3 @@\n-    public SourceFile(final int nameIndex, final int length, final int sourceFileIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_SOURCE_FILE, nameIndex, Args.require(length, 2, \"SourceFile length attribute\"), constantPool);\n-        this.sourceFileIndex = Args.requireU2(sourceFileIndex, 0, constantPool.getLength(), \"SourceFile source file index\");\n+    public SourceFile(final int name_index, final int length, final int sourceFileIndex, final ConstantPool constantPool) {\n+        super(Const.ATTR_SOURCE_FILE, name_index, length, constantPool);\n+        this.sourceFileIndex = sourceFileIndex;\n@@ -69,9 +84,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public SourceFile(final SourceFile c) {\n-        this(c.getNameIndex(), c.getLength(), c.getSourceFileIndex(), c.getConstantPool());\n-    }\n@@ -80,2 +86,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -86,1 +93,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -90,7 +97,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n-    }\n@@ -102,1 +102,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -105,1 +105,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -110,0 +110,1 @@\n+\n@@ -117,0 +118,1 @@\n+\n@@ -118,1 +120,1 @@\n-     * @return Source file name.\n+     * @param sourceFileIndex\n@@ -120,2 +122,2 @@\n-    public String getSourceFileName() {\n-        return super.getConstantPool().getConstantUtf8(sourceFileIndex).getBytes();\n+    public void setSourceFileIndex( final int sourceFileIndex ) {\n+        this.sourceFileIndex = sourceFileIndex;\n@@ -124,0 +126,1 @@\n+\n@@ -125,1 +128,1 @@\n-     * @param sourceFileIndex\n+     * @return Source file name.\n@@ -127,2 +130,4 @@\n-    public void setSourceFileIndex(final int sourceFileIndex) {\n-        this.sourceFileIndex = sourceFileIndex;\n+    public String getSourceFileName() {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(sourceFileIndex,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -131,0 +136,1 @@\n+\n@@ -138,0 +144,9 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        return (Attribute) clone();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/SourceFile.java","additions":62,"deletions":47,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.util.Arrays;\n@@ -29,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,4 +30,7 @@\n- * This class represents a stack map attribute used for preverification of Java classes for the\n- * <a href=\"http:\/\/java.sun.com\/j2me\/\"> Java 2 Micro Edition<\/a> (J2ME). This attribute is used by the\n- * <a href=\"http:\/\/java.sun.com\/products\/cldc\/\">KVM<\/a> and contained within the Code attribute of a method. See CLDC\n- * specification 5.3.1.2\n+ * This class represents a stack map attribute used for\n+ * preverification of Java classes for the <a\n+ * href=\"https:\/\/www.oracle.com\/java\/technologies\/javameoverview.html\">Java Platform, Micro Edition<\/a>\n+ * (Java ME). This attribute is used by the <a\n+ * href=\"https:\/\/www.oracle.com\/technetwork\/java\/embedded\/javame\/java-mobile\/kvmwp-150240.pdf\">KVM<\/a>\n+ * and contained within the Code attribute of a method. See CLDC specification\n+ * 5.3.1.2\n@@ -37,12 +38,3 @@\n- * <pre>\n- * StackMapTable_attribute {\n- *   u2              attribute_name_index;\n- *   u4              attribute_length;\n- *   u2              number_of_entries;\n- *   stack_map_frame entries[number_of_entries];\n- * }\n- * <\/pre>\n- *\n- * @see Code\n- * @see StackMapEntry\n- * @see StackMapType\n+ * @see     Code\n+ * @see     StackMapEntry\n+ * @see     StackMapType\n@@ -53,1 +45,1 @@\n-    private StackMapEntry[] table; \/\/ Table of stack map entries\n+    private StackMapEntry[] map; \/\/ Table of stack map entries\n@@ -55,17 +47,0 @@\n-    \/**\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index of name\n-     * @param length Content length in bytes\n-     * @param dataInput Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    StackMap(final int nameIndex, final int length, final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (StackMapEntry[]) null, constantPool);\n-        final int mapLength = dataInput.readUnsignedShort();\n-        table = new StackMapEntry[mapLength];\n-        for (int i = 0; i < mapLength; i++) {\n-            table[i] = new StackMapEntry(dataInput, constantPool);\n-        }\n-    }\n@@ -74,2 +49,1 @@\n-     * @param nameIndex Index of name\n-     *\n+     * @param name_index Index of name\n@@ -77,1 +51,0 @@\n-     *\n@@ -79,2 +52,1 @@\n-     *\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -82,4 +54,3 @@\n-    public StackMap(final int nameIndex, final int length, final StackMapEntry[] table, final ConstantPool constantPool) {\n-        super(Const.ATTR_STACK_MAP, nameIndex, length, constantPool);\n-        this.table = table != null ? table : StackMapEntry.EMPTY_ARRAY;\n-        Args.requireU2(this.table.length, \"table.length\");\n+    public StackMap(final int name_index, final int length, final StackMapEntry[] map, final ConstantPool constant_pool) {\n+        super(Const.ATTR_STACK_MAP, name_index, length, constant_pool);\n+        this.map = map;\n@@ -88,0 +59,1 @@\n+\n@@ -89,2 +61,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Construct object from input stream.\n@@ -92,1 +63,5 @@\n-     * @param v Visitor object\n+     * @param name_index Index of name\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -94,3 +69,7 @@\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackMap(this);\n+    StackMap(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (StackMapEntry[]) null, constant_pool);\n+        final int map_length = input.readUnsignedShort();\n+        map = new StackMapEntry[map_length];\n+        for (int i = 0; i < map_length; i++) {\n+            map[i] = new StackMapEntry(input, constant_pool);\n+        }\n@@ -99,11 +78,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final StackMap c = (StackMap) clone();\n-        c.table = new StackMapEntry[table.length];\n-        Arrays.setAll(c.table, i -> table[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -115,1 +83,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -118,1 +86,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -120,2 +88,2 @@\n-        file.writeShort(table.length);\n-        for (final StackMapEntry entry : table) {\n+        file.writeShort(map.length);\n+        for (final StackMapEntry entry : map) {\n@@ -126,3 +94,0 @@\n-    public int getMapLength() {\n-        return table.length;\n-    }\n@@ -134,1 +99,1 @@\n-        return table;\n+        return map;\n@@ -137,0 +102,1 @@\n+\n@@ -138,1 +104,1 @@\n-     * @param table Array of stack map entries\n+     * @param map Array of stack map entries\n@@ -140,2 +106,2 @@\n-    public void setStackMap(final StackMapEntry[] table) {\n-        this.table = table != null ? table : StackMapEntry.EMPTY_ARRAY;\n+    public void setStackMap( final StackMapEntry[] map ) {\n+        this.map = map;\n@@ -143,1 +109,1 @@\n-        for (final StackMapEntry element : this.table) {\n+        for (final StackMapEntry element : map) {\n@@ -149,0 +115,1 @@\n+\n@@ -155,5 +122,3 @@\n-        int runningOffset = -1; \/\/ no +1 on first entry\n-        for (int i = 0; i < table.length; i++) {\n-            runningOffset = table[i].getByteCodeOffset() + runningOffset + 1;\n-            buf.append(String.format(\"%n@%03d %s\", runningOffset, table[i]));\n-            if (i < table.length - 1) {\n+        for (int i = 0; i < map.length; i++) {\n+            buf.append(map[i]);\n+            if (i < map.length - 1) {\n@@ -166,0 +131,33 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final StackMap c = (StackMap) clone();\n+        c.map = new StackMapEntry[map.length];\n+        for (int i = 0; i < map.length; i++) {\n+            c.map[i] = map[i].copy();\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n+\n+\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackMap(this);\n+    }\n+\n+\n+    public int getMapLength() {\n+        return map == null ? 0 : map.length;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMap.java","additions":77,"deletions":79,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Arrays;\n-\n@@ -32,4 +30,3 @@\n- * This class represents a stack map entry recording the types of local variables and the of stack items at a given\n- * byte code offset. See CLDC specification 5.3.1.2.\n- *\n- * See also https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.4\n+ * This class represents a stack map entry recording the types of\n+ * local variables and the the of stack items at a given byte code offset.\n+ * See CLDC specification 5.3.1.2\n@@ -37,13 +34,2 @@\n- * <pre>\n- * union stack_map_frame {\n- *   same_frame;\n- *   same_locals_1_stack_item_frame;\n- *   same_locals_1_stack_item_frame_extended;\n- *   chop_frame;\n- *   same_frame_extended;\n- *   append_frame;\n- *   full_frame;\n- * }\n- * <\/pre>\n- * @see StackMap\n- * @see StackMapType\n+ * @see     StackMap\n+ * @see     StackMapType\n@@ -51,3 +37,2 @@\n-public final class StackMapEntry implements Node, Cloneable {\n-\n-    static final StackMapEntry[] EMPTY_ARRAY = {};\n+public final class StackMapEntry implements Node, Cloneable\n+{\n@@ -61,0 +46,1 @@\n+\n@@ -64,2 +50,2 @@\n-     * @param dataInput Input stream\n-     * @throws IOException if an I\/O error occurs.\n+     * @param input Input stream\n+     * @throws IOException\n@@ -67,2 +53,2 @@\n-    StackMapEntry(final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n-        this(dataInput.readByte() & 0xFF, -1, null, null, constantPool);\n+    StackMapEntry(final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(input.readByte() & 0xFF, -1, null, null, constantPool);\n@@ -72,1 +58,2 @@\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -74,1 +61,2 @@\n-            typesOfStackItems = new StackMapType[] { new StackMapType(dataInput, constantPool) };\n+            typesOfStackItems = new StackMapType[1];\n+            typesOfStackItems[0] = new StackMapType(input, constantPool);\n@@ -76,2 +64,3 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n-            typesOfStackItems = new StackMapType[] { new StackMapType(dataInput, constantPool) };\n+            byteCodeOffset = input.readShort();\n+            typesOfStackItems = new StackMapType[1];\n+            typesOfStackItems[0] = new StackMapType(input, constantPool);\n@@ -79,1 +68,1 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n+            byteCodeOffset = input.readShort();\n@@ -81,1 +70,1 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n+            byteCodeOffset = input.readShort();\n@@ -83,5 +72,5 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n-            final int numberOfLocals = frameType - 251;\n-            typesOfLocals = new StackMapType[numberOfLocals];\n-            for (int i = 0; i < numberOfLocals; i++) {\n-                typesOfLocals[i] = new StackMapType(dataInput, constantPool);\n+            byteCodeOffset = input.readShort();\n+            final int number_of_locals = frameType - 251;\n+            typesOfLocals = new StackMapType[number_of_locals];\n+            for (int i = 0; i < number_of_locals; i++) {\n+                typesOfLocals[i] = new StackMapType(input, constantPool);\n@@ -90,5 +79,5 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n-            final int numberOfLocals = dataInput.readUnsignedShort();\n-            typesOfLocals = new StackMapType[numberOfLocals];\n-            for (int i = 0; i < numberOfLocals; i++) {\n-                typesOfLocals[i] = new StackMapType(dataInput, constantPool);\n+            byteCodeOffset = input.readShort();\n+            final int number_of_locals = input.readShort();\n+            typesOfLocals = new StackMapType[number_of_locals];\n+            for (int i = 0; i < number_of_locals; i++) {\n+                typesOfLocals[i] = new StackMapType(input, constantPool);\n@@ -96,4 +85,4 @@\n-            final int numberOfStackItems = dataInput.readUnsignedShort();\n-            typesOfStackItems = new StackMapType[numberOfStackItems];\n-            for (int i = 0; i < numberOfStackItems; i++) {\n-                typesOfStackItems[i] = new StackMapType(dataInput, constantPool);\n+            final int number_of_stack_items = input.readShort();\n+            typesOfStackItems = new StackMapType[number_of_stack_items];\n+            for (int i = 0; i < number_of_stack_items; i++) {\n+                typesOfStackItems[i] = new StackMapType(input, constantPool);\n@@ -103,1 +92,1 @@\n-            throw new ClassFormatException(\"Invalid frame type found while parsing stack map table: \" + frameType);\n+            throw new ClassFormatException (\"Invalid frame type found while parsing stack map table: \" + frameType);\n@@ -116,1 +105,2 @@\n-     * @deprecated Since 6.0, use {@link #StackMapEntry(int, int, StackMapType[], StackMapType[], ConstantPool)} instead\n+     * @deprecated Since 6.0, use {@link #StackMapEntry(int, int, StackMapType[], StackMapType[], ConstantPool)}\n+     * instead\n@@ -119,2 +109,3 @@\n-    public StackMapEntry(final int byteCodeOffset, final int numberOfLocals, final StackMapType[] typesOfLocals, final int numberOfStackItems,\n-        final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n+    public StackMapEntry(final int byteCodeOffset, final int numberOfLocals,\n+            final StackMapType[] typesOfLocals, final int numberOfStackItems,\n+            final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n@@ -122,2 +113,2 @@\n-        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : StackMapType.EMPTY_ARRAY;\n-        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : StackMapType.EMPTY_ARRAY;\n+        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : new StackMapType[0];\n+        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : new StackMapType[0];\n@@ -125,6 +116,0 @@\n-        if (numberOfLocals < 0) {\n-            throw new IllegalArgumentException(\"numberOfLocals < 0\");\n-        }\n-        if (numberOfStackItems < 0) {\n-            throw new IllegalArgumentException(\"numberOfStackItems < 0\");\n-        }\n@@ -142,2 +127,3 @@\n-    public StackMapEntry(final int tag, final int byteCodeOffset, final StackMapType[] typesOfLocals, final StackMapType[] typesOfStackItems,\n-        final ConstantPool constantPool) {\n+    public StackMapEntry(final int tag, final int byteCodeOffset,\n+            final StackMapType[] typesOfLocals,\n+            final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n@@ -146,2 +132,2 @@\n-        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : StackMapType.EMPTY_ARRAY;\n-        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : StackMapType.EMPTY_ARRAY;\n+        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : new StackMapType[0];\n+        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : new StackMapType[0];\n@@ -151,28 +137,0 @@\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackMapEntry(this);\n-    }\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public StackMapEntry copy() {\n-        StackMapEntry e;\n-        try {\n-            e = (StackMapEntry) clone();\n-        } catch (final CloneNotSupportedException ex) {\n-            throw new Error(\"Clone Not Supported\");\n-        }\n-\n-        e.typesOfLocals = new StackMapType[typesOfLocals.length];\n-        Arrays.setAll(e.typesOfLocals, i -> typesOfLocals[i].copy());\n-        e.typesOfStackItems = new StackMapType[typesOfStackItems.length];\n-        Arrays.setAll(e.typesOfStackItems, i -> typesOfStackItems[i].copy());\n-        return e;\n-    }\n@@ -184,1 +142,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -186,1 +144,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -188,1 +146,4 @@\n-        if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n+            \/\/ nothing to be done\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -212,1 +173,1 @@\n-        } else if (!(frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX)) {\n+        } else {\n@@ -214,1 +175,1 @@\n-            throw new ClassFormatException(\"Invalid Stack map table tag: \" + frameType);\n+            throw new ClassFormatException (\"Invalid Stack map table tag: \" + frameType);\n@@ -218,3 +179,0 @@\n-    public int getByteCodeOffset() {\n-        return byteCodeOffset;\n-    }\n@@ -223,1 +181,1 @@\n-     * @return Constant pool used by this object.\n+     * @return String representation.\n@@ -225,2 +183,45 @@\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n+    @Override\n+    public String toString() {\n+        final StringBuilder buf = new StringBuilder(64);\n+        buf.append(\"(\");\n+        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n+            buf.append(\"SAME\");\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                  frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            buf.append(\"SAME_LOCALS_1_STACK\");\n+        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n+            buf.append(\"SAME_LOCALS_1_STACK_EXTENDED\");\n+        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n+            buf.append(\"CHOP \").append(String.valueOf(251-frameType));\n+        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n+            buf.append(\"SAME_EXTENDED\");\n+        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n+            buf.append(\"APPEND \").append(String.valueOf(frameType-251));\n+        } else if (frameType == Const.FULL_FRAME) {\n+            buf.append(\"FULL\");\n+        } else {\n+            buf.append(\"UNKNOWN (\").append(frameType).append(\")\");\n+        }\n+        buf.append(\", offset delta=\").append(byteCodeOffset);\n+        if (typesOfLocals.length > 0) {\n+            buf.append(\", locals={\");\n+            for (int i = 0; i < typesOfLocals.length; i++) {\n+                buf.append(typesOfLocals[i]);\n+                if (i < typesOfLocals.length - 1) {\n+                    buf.append(\", \");\n+                }\n+            }\n+            buf.append(\"}\");\n+        }\n+        if (typesOfStackItems.length > 0) {\n+            buf.append(\", stack items={\");\n+            for (int i = 0; i < typesOfStackItems.length; i++) {\n+                buf.append(typesOfStackItems[i]);\n+                if (i < typesOfStackItems.length - 1) {\n+                    buf.append(\", \");\n+                }\n+            }\n+            buf.append(\"}\");\n+        }\n+        buf.append(\")\");\n+        return buf.toString();\n@@ -229,3 +230,0 @@\n-    public int getFrameType() {\n-        return frameType;\n-    }\n@@ -240,2 +238,2 @@\n-        }\n-        if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -243,2 +241,1 @@\n-        }\n-        if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n+        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n@@ -246,2 +243,1 @@\n-        }\n-        if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX || frameType == Const.SAME_FRAME_EXTENDED) {\n+        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n@@ -249,2 +245,3 @@\n-        }\n-        if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n+        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n+            return 3;\n+        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n@@ -252,2 +249,2 @@\n-            for (final StackMapType typesOfLocal : typesOfLocals) {\n-                len += typesOfLocal.hasIndex() ? 3 : 1;\n+            for (final StackMapType types_of_local : typesOfLocals) {\n+                len += types_of_local.hasIndex() ? 3 : 1;\n@@ -256,2 +253,10 @@\n-        }\n-        if (frameType != Const.FULL_FRAME) {\n+        } else if (frameType == Const.FULL_FRAME) {\n+            int len = 7;\n+            for (final StackMapType types_of_local : typesOfLocals) {\n+                len += types_of_local.hasIndex() ? 3 : 1;\n+            }\n+            for (final StackMapType types_of_stack_item : typesOfStackItems) {\n+                len += types_of_stack_item.hasIndex() ? 3 : 1;\n+            }\n+            return len;\n+        } else {\n@@ -260,8 +265,0 @@\n-        int len = 7;\n-        for (final StackMapType typesOfLocal : typesOfLocals) {\n-            len += typesOfLocal.hasIndex() ? 3 : 1;\n-        }\n-        for (final StackMapType typesOfStackItem : typesOfStackItems) {\n-            len += typesOfStackItem.hasIndex() ? 3 : 1;\n-        }\n-        return len;\n@@ -270,3 +267,0 @@\n-    public int getNumberOfLocals() {\n-        return typesOfLocals.length;\n-    }\n@@ -274,2 +268,15 @@\n-    public int getNumberOfStackItems() {\n-        return typesOfStackItems.length;\n+    public void setFrameType( final int f ) {\n+        if (f >= Const.SAME_FRAME && f <= Const.SAME_FRAME_MAX) {\n+            byteCodeOffset = f - Const.SAME_FRAME;\n+        } else if (f >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   f <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            byteCodeOffset = f - Const.SAME_LOCALS_1_STACK_ITEM_FRAME;\n+        } else if (f == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (f >= Const.CHOP_FRAME && f <= Const.CHOP_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (f == Const.SAME_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (f >= Const.APPEND_FRAME && f <= Const.APPEND_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (f == Const.FULL_FRAME) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid StackMap frameType\");\n+        }\n+        frameType = f;\n@@ -278,3 +285,0 @@\n-    public StackMapType[] getTypesOfLocals() {\n-        return typesOfLocals;\n-    }\n@@ -282,2 +286,2 @@\n-    public StackMapType[] getTypesOfStackItems() {\n-        return typesOfStackItems;\n+    public int getFrameType() {\n+        return frameType;\n@@ -286,9 +290,0 @@\n-    private boolean invalidFrameType(final int f) {\n-        \/\/ @formatter:off\n-        return f != Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED\n-            && !(f >= Const.CHOP_FRAME && f <= Const.CHOP_FRAME_MAX)\n-            && f != Const.SAME_FRAME_EXTENDED\n-            && !(f >= Const.APPEND_FRAME && f <= Const.APPEND_FRAME_MAX)\n-            && f != Const.FULL_FRAME;\n-        \/\/ @formatter:on\n-    }\n@@ -296,3 +291,3 @@\n-    public void setByteCodeOffset(final int newOffset) {\n-        if (newOffset < 0 || newOffset > 32767) {\n-            throw new IllegalArgumentException(\"Invalid StackMap offset: \" + newOffset);\n+    public void setByteCodeOffset( final int new_offset ) {\n+        if (new_offset < 0 || new_offset > 32767) {\n+            throw new IllegalArgumentException(\"Invalid StackMap offset: \" + new_offset);\n@@ -301,2 +296,3 @@\n-        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n-            if (newOffset > Const.SAME_FRAME_MAX) {\n+        if (frameType >= Const.SAME_FRAME &&\n+            frameType <= Const.SAME_FRAME_MAX) {\n+            if (new_offset > Const.SAME_FRAME_MAX) {\n@@ -305,1 +301,1 @@\n-                frameType = newOffset;\n+                frameType = new_offset;\n@@ -307,2 +303,3 @@\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            if (newOffset > Const.SAME_FRAME_MAX) {\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            if (new_offset > Const.SAME_FRAME_MAX) {\n@@ -311,1 +308,1 @@\n-                frameType = Const.SAME_LOCALS_1_STACK_ITEM_FRAME + newOffset;\n+                frameType = Const.SAME_LOCALS_1_STACK_ITEM_FRAME + new_offset;\n@@ -313,1 +310,8 @@\n-        } else if (invalidFrameType(frameType)) {\n+        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (frameType >= Const.CHOP_FRAME &&\n+                   frameType <= Const.CHOP_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (frameType == Const.SAME_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (frameType >= Const.APPEND_FRAME &&\n+                   frameType <= Const.APPEND_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (frameType == Const.FULL_FRAME) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else {\n@@ -316,1 +320,1 @@\n-        byteCodeOffset = newOffset;\n+        byteCodeOffset = new_offset;\n@@ -319,0 +323,1 @@\n+\n@@ -320,1 +325,5 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * Update the distance (as an offset delta) from this StackMap\n+     * entry to the next.  Note that this might cause the the\n+     * frame type to change.  Note also that delta may be negative.\n+     *\n+     * @param delta offset delta\n@@ -322,2 +331,2 @@\n-    public void setConstantPool(final ConstantPool constantPool) {\n-        this.constantPool = constantPool;\n+    public void updateByteCodeOffset(final int delta) {\n+        setByteCodeOffset(byteCodeOffset + delta);\n@@ -326,9 +335,3 @@\n-    public void setFrameType(final int ft) {\n-        if (ft >= Const.SAME_FRAME && ft <= Const.SAME_FRAME_MAX) {\n-            byteCodeOffset = ft - Const.SAME_FRAME;\n-        } else if (ft >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && ft <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            byteCodeOffset = ft - Const.SAME_LOCALS_1_STACK_ITEM_FRAME;\n-        } else if (invalidFrameType(ft)) {\n-            throw new IllegalArgumentException(\"Invalid StackMap frameType\");\n-        }\n-        frameType = ft;\n+\n+    public int getByteCodeOffset() {\n+        return byteCodeOffset;\n@@ -337,0 +340,1 @@\n+\n@@ -342,1 +346,6 @@\n-    public void setNumberOfLocals(final int n) { \/\/ TODO unused\n+    public void setNumberOfLocals( final int n ) { \/\/ TODO unused\n+    }\n+\n+\n+    public int getNumberOfLocals() {\n+        return typesOfLocals.length;\n@@ -345,0 +354,11 @@\n+\n+    public void setTypesOfLocals( final StackMapType[] types ) {\n+        typesOfLocals = types != null ? types : new StackMapType[0];\n+    }\n+\n+\n+    public StackMapType[] getTypesOfLocals() {\n+        return typesOfLocals;\n+    }\n+\n+\n@@ -350,1 +370,6 @@\n-    public void setNumberOfStackItems(final int n) { \/\/ TODO unused\n+    public void setNumberOfStackItems( final int n ) { \/\/ TODO unused\n+    }\n+\n+\n+    public int getNumberOfStackItems() {\n+        return typesOfStackItems.length;\n@@ -353,2 +378,3 @@\n-    public void setTypesOfLocals(final StackMapType[] types) {\n-        typesOfLocals = types != null ? types : StackMapType.EMPTY_ARRAY;\n+\n+    public void setTypesOfStackItems( final StackMapType[] types ) {\n+        typesOfStackItems = types != null ? types : new StackMapType[0];\n@@ -357,2 +383,3 @@\n-    public void setTypesOfStackItems(final StackMapType[] types) {\n-        typesOfStackItems = types != null ? types : StackMapType.EMPTY_ARRAY;\n+\n+    public StackMapType[] getTypesOfStackItems() {\n+        return typesOfStackItems;\n@@ -361,0 +388,1 @@\n+\n@@ -362,1 +390,1 @@\n-     * @return String representation.\n+     * @return deep copy of this object\n@@ -364,20 +392,6 @@\n-    @Override\n-    public String toString() {\n-        final StringBuilder buf = new StringBuilder(64);\n-        buf.append(\"(\");\n-        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n-            buf.append(\"SAME\");\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            buf.append(\"SAME_LOCALS_1_STACK\");\n-        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n-            buf.append(\"SAME_LOCALS_1_STACK_EXTENDED\");\n-        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n-            buf.append(\"CHOP \").append(String.valueOf(251 - frameType));\n-        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n-            buf.append(\"SAME_EXTENDED\");\n-        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n-            buf.append(\"APPEND \").append(String.valueOf(frameType - 251));\n-        } else if (frameType == Const.FULL_FRAME) {\n-            buf.append(\"FULL\");\n-        } else {\n-            buf.append(\"UNKNOWN (\").append(frameType).append(\")\");\n+    public StackMapEntry copy() {\n+        StackMapEntry e;\n+        try {\n+            e = (StackMapEntry) clone();\n+        } catch (final CloneNotSupportedException ex) {\n+            throw new Error(\"Clone Not Supported\");\n@@ -385,10 +399,4 @@\n-        buf.append(\", offset delta=\").append(byteCodeOffset);\n-        if (typesOfLocals.length > 0) {\n-            buf.append(\", locals={\");\n-            for (int i = 0; i < typesOfLocals.length; i++) {\n-                buf.append(typesOfLocals[i]);\n-                if (i < typesOfLocals.length - 1) {\n-                    buf.append(\", \");\n-                }\n-            }\n-            buf.append(\"}\");\n+\n+        e.typesOfLocals = new StackMapType[typesOfLocals.length];\n+        for (int i = 0; i < typesOfLocals.length; i++) {\n+            e.typesOfLocals[i] = typesOfLocals[i].copy();\n@@ -396,9 +404,3 @@\n-        if (typesOfStackItems.length > 0) {\n-            buf.append(\", stack items={\");\n-            for (int i = 0; i < typesOfStackItems.length; i++) {\n-                buf.append(typesOfStackItems[i]);\n-                if (i < typesOfStackItems.length - 1) {\n-                    buf.append(\", \");\n-                }\n-            }\n-            buf.append(\"}\");\n+        e.typesOfStackItems = new StackMapType[typesOfStackItems.length];\n+        for (int i = 0; i < typesOfStackItems.length; i++) {\n+            e.typesOfStackItems[i] = typesOfStackItems[i].copy();\n@@ -406,2 +408,1 @@\n-        buf.append(\")\");\n-        return buf.toString();\n+        return e;\n@@ -410,0 +411,1 @@\n+\n@@ -411,2 +413,3 @@\n-     * Update the distance (as an offset delta) from this StackMap entry to the next. Note that this might cause the\n-     * frame type to change. Note also that delta may be negative.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -414,1 +417,1 @@\n-     * @param delta offset delta\n+     * @param v Visitor object\n@@ -416,2 +419,19 @@\n-    public void updateByteCodeOffset(final int delta) {\n-        setByteCodeOffset(byteCodeOffset + delta);\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackMapEntry(this);\n+    }\n+\n+\n+    \/**\n+     * @return Constant pool used by this object.\n+     *\/\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n+    }\n+\n+\n+    \/**\n+     * @param constantPool Constant pool to be used for this object.\n+     *\/\n+    public void setConstantPool( final ConstantPool constantPool ) {\n+        this.constantPool = constantPool;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMapEntry.java","additions":239,"deletions":219,"binary":false,"changes":458,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class represents the type of a local variable or item on stack used in the StackMap entries.\n+ * This class represents the type of a local variable or item on stack\n+ * used in the StackMap entries.\n@@ -33,3 +34,3 @@\n- * @see StackMapEntry\n- * @see StackMap\n- * @see Const\n+ * @see     StackMapEntry\n+ * @see     StackMap\n+ * @see     Const\n@@ -39,2 +40,0 @@\n-    public static final StackMapType[] EMPTY_ARRAY = {}; \/\/ must be public because BCELifier code generator writes calls to it\n-\n@@ -45,9 +44,0 @@\n-    \/**\n-     * @param type type tag as defined in the Constants interface\n-     * @param index index to constant pool, or byte code offset\n-     *\/\n-    public StackMapType(final byte type, final int index, final ConstantPool constantPool) {\n-        this.type = checkType(type);\n-        this.index = index;\n-        this.constantPool = constantPool;\n-    }\n@@ -57,1 +47,0 @@\n-     *\n@@ -59,1 +48,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -61,2 +50,2 @@\n-    StackMapType(final DataInput file, final ConstantPool constantPool) throws IOException {\n-        this(file.readByte(), -1, constantPool);\n+    StackMapType(final DataInput file, final ConstantPool constant_pool) throws IOException {\n+        this(file.readByte(), -1, constant_pool);\n@@ -64,1 +53,1 @@\n-            this.index = file.readUnsignedShort();\n+            this.index = file.readShort();\n@@ -66,1 +55,1 @@\n-        this.constantPool = constantPool;\n+        this.constantPool = constant_pool;\n@@ -69,3 +58,8 @@\n-    private byte checkType(final byte type) {\n-        if (type < Const.ITEM_Bogus || type > Const.ITEM_NewObject) {\n-            throw new ClassFormatException(\"Illegal type for StackMapType: \" + type);\n+\n+    \/**\n+     * @param type type tag as defined in the Constants interface\n+     * @param index index to constant pool, or byte code offset\n+     *\/\n+    public StackMapType(final byte type, final int index, final ConstantPool constant_pool) {\n+        if ((type < Const.ITEM_Bogus) || (type > Const.ITEM_NewObject)) {\n+            throw new IllegalArgumentException(\"Illegal type for StackMapType: \" + type);\n@@ -73,0 +67,15 @@\n+        this.type = type;\n+        this.index = index;\n+        this.constantPool = constant_pool;\n+    }\n+\n+\n+    public void setType( final byte t ) {\n+        if ((t < Const.ITEM_Bogus) || (t > Const.ITEM_NewObject)) {\n+            throw new IllegalArgumentException(\"Illegal type for StackMapType: \" + t);\n+        }\n+        type = t;\n+    }\n+\n+\n+    public byte getType() {\n@@ -76,2 +85,8 @@\n-    \/**\n-     * @return deep copy of this object\n+\n+    public void setIndex( final int t ) {\n+        index = t;\n+    }\n+\n+\n+    \/** @return index to constant pool if type == ITEM_Object, or offset\n+     * in byte code, if type == ITEM_NewObject, and -1 otherwise\n@@ -79,7 +94,2 @@\n-    public StackMapType copy() {\n-        try {\n-            return (StackMapType) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public int getIndex() {\n+        return index;\n@@ -88,0 +98,1 @@\n+\n@@ -92,1 +103,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -94,1 +105,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -101,6 +112,0 @@\n-    \/**\n-     * @return Constant pool used by this object.\n-     *\/\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n-    }\n@@ -108,14 +113,1 @@\n-    \/**\n-     * @return index to constant pool if type == ITEM_Object, or offset in byte code, if type == ITEM_NewObject, and -1\n-     *         otherwise\n-     *\/\n-    public int getIndex() {\n-        return index;\n-    }\n-\n-    public byte getType() {\n-        return type;\n-    }\n-\n-    \/**\n-     * @return true, if type is either ITEM_Object or ITEM_NewObject\n+    \/** @return true, if type is either ITEM_Object or ITEM_NewObject\n@@ -127,0 +119,1 @@\n+\n@@ -133,2 +126,1 @@\n-        }\n-        if (type == Const.ITEM_NewObject) {\n+        } else if (type == Const.ITEM_NewObject) {\n@@ -136,0 +128,2 @@\n+        } else {\n+            return \"\";\n@@ -137,1 +131,0 @@\n-        return \"\";\n@@ -140,0 +133,1 @@\n+\n@@ -141,1 +135,1 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * @return String representation\n@@ -143,2 +137,3 @@\n-    public void setConstantPool(final ConstantPool constantPool) {\n-        this.constantPool = constantPool;\n+    @Override\n+    public String toString() {\n+        return \"(type=\" + Const.getItemName(type) + printIndex() + \")\";\n@@ -147,2 +142,11 @@\n-    public void setIndex(final int index) {\n-        this.index = index;\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public StackMapType copy() {\n+        try {\n+            return (StackMapType) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n@@ -151,2 +155,6 @@\n-    public void setType(final byte type) {\n-        this.type = checkType(type);\n+\n+    \/**\n+     * @return Constant pool used by this object.\n+     *\/\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n@@ -155,0 +163,1 @@\n+\n@@ -156,1 +165,1 @@\n-     * @return String representation\n+     * @param constantPool Constant pool to be used for this object.\n@@ -158,3 +167,2 @@\n-    @Override\n-    public String toString() {\n-        return \"(type=\" + Const.getItemName(type) + printIndex() + \")\";\n+    public void setConstantPool( final ConstantPool constantPool ) {\n+        this.constantPool = constantPool;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMapType.java","additions":77,"deletions":69,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,4 +31,7 @@\n- * This class is derived from <em>Attribute<\/em> and declares this class as 'synthetic', i.e., it needs special\n- * handling. The JVM specification states \"A class member that does not appear in the source code must be marked using a\n- * Synthetic attribute.\" It may appear in the ClassFile attribute table, a field_info table or a method_info table. This\n- * class is intended to be instantiated from the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and declares this class as\n+ * `synthetic', i.e., it needs special handling.  The JVM specification\n+ * states \"A class member that does not appear in the source code must be\n+ * marked using a Synthetic attribute.\"  It may appear in the ClassFile\n+ * attribute table, a field_info table or a method_info table.  This class\n+ * is intended to be instantiated from the\n+ * <em>Attribute.readAttribute()<\/em> method.\n@@ -37,1 +39,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -43,0 +45,10 @@\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n+     *\/\n+    public Synthetic(final Synthetic c) {\n+        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n+    }\n+\n+\n@@ -44,1 +56,2 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8, which should represent the string \"Synthetic\".\n+     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n+     * should represent the string \"Synthetic\".\n@@ -47,1 +60,2 @@\n-     * @param constantPool The constant pool this attribute is associated with.\n+     * @param constant_pool The constant pool this attribute is associated\n+     * with.\n@@ -49,2 +63,2 @@\n-    public Synthetic(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n-        super(Const.ATTR_SYNTHETIC, nameIndex, Args.require0(length, \"Synthetic attribute length\"), constantPool);\n+    public Synthetic(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n+        super(Const.ATTR_SYNTHETIC, name_index, length, constant_pool);\n@@ -54,0 +68,1 @@\n+\n@@ -57,1 +72,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -60,2 +75,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -63,2 +78,3 @@\n-    Synthetic(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (byte[]) null, constantPool);\n+    Synthetic(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (byte[]) null, constant_pool);\n@@ -72,9 +88,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public Synthetic(final Synthetic c) {\n-        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n-    }\n@@ -83,2 +90,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -89,1 +97,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -93,12 +101,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Synthetic c = (Synthetic) clone();\n-        if (bytes != null) {\n-            c.bytes = bytes.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -110,1 +106,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -113,1 +109,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -120,0 +116,1 @@\n+\n@@ -127,0 +124,1 @@\n+\n@@ -130,1 +128,1 @@\n-    public void setBytes(final byte[] bytes) {\n+    public void setBytes( final byte[] bytes ) {\n@@ -134,0 +132,1 @@\n+\n@@ -145,0 +144,15 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Synthetic c = (Synthetic) clone();\n+        if (bytes != null) {\n+            c.bytes = new byte[bytes.length];\n+            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Synthetic.java","additions":56,"deletions":42,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -32,3 +33,5 @@\n- * This class represents a reference to an unknown (i.e., application-specific) attribute of a class. It is instantiated\n- * from the {@link Attribute#readAttribute(java.io.DataInput, ConstantPool)} method. Applications that need to read in\n- * application-specific attributes should create an {@link UnknownAttributeReader} implementation and attach it via\n+ * This class represents a reference to an unknown (i.e.,\n+ * application-specific) attribute of a class.  It is instantiated from the\n+ * {@link Attribute#readAttribute(java.io.DataInput, ConstantPool)} method.\n+ * Applications that need to read in application-specific attributes should create an\n+ * {@link UnknownAttributeReader} implementation and attach it via\n@@ -36,0 +39,1 @@\n+\n@@ -43,1 +47,0 @@\n-\n@@ -45,0 +48,12 @@\n+    private static final Map<String, Unknown> unknownAttributes = new HashMap<>();\n+\n+\n+    \/** @return array of unknown attributes, but just one for each kind.\n+     *\/\n+    static Unknown[] getUnknownAttributes() {\n+        final Unknown[] unknowns = new Unknown[unknownAttributes.size()];\n+        unknownAttributes.values().toArray(unknowns);\n+        unknownAttributes.clear();\n+        return unknowns;\n+    }\n+\n@@ -47,1 +62,10 @@\n-     * Constructs a new instance for a non-standard attribute.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n+     *\/\n+    public Unknown(final Unknown c) {\n+        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n+    }\n+\n+\n+    \/**\n+     * Create a non-standard attribute.\n@@ -49,1 +73,1 @@\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -52,1 +76,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -54,2 +78,2 @@\n-    public Unknown(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n-        super(Const.ATTR_UNKNOWN, nameIndex, length, constantPool);\n+    public Unknown(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n+        super(Const.ATTR_UNKNOWN, name_index, length, constant_pool);\n@@ -57,1 +81,3 @@\n-        this.name = constantPool.getConstantUtf8(nameIndex).getBytes();\n+        name = ((ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8))\n+                .getBytes();\n+        unknownAttributes.put(name, this);\n@@ -60,0 +86,1 @@\n+\n@@ -61,1 +88,1 @@\n-     * Constructs a new instance from an input stream.\n+     * Construct object from input stream.\n@@ -63,1 +90,1 @@\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -66,2 +93,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -69,2 +96,3 @@\n-    Unknown(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (byte[]) null, constantPool);\n+    Unknown(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (byte[]) null, constant_pool);\n@@ -77,8 +105,0 @@\n-    \/**\n-     * Constructs a new instance from another instance. Note that both objects use the same references (shallow copy). Use clone() for a physical copy.\n-     *\n-     * @param unknown Source.\n-     *\/\n-    public Unknown(final Unknown unknown) {\n-        this(unknown.getNameIndex(), unknown.getLength(), unknown.getBytes(), unknown.getConstantPool());\n-    }\n@@ -87,2 +107,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -93,1 +114,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -97,12 +118,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Unknown c = (Unknown) clone();\n-        if (bytes != null) {\n-            c.bytes = bytes.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -111,1 +120,1 @@\n-     * Dumps unknown bytes to file stream.\n+     * Dump unknown bytes to file stream.\n@@ -114,1 +123,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -117,1 +126,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -124,0 +133,1 @@\n+\n@@ -131,0 +141,1 @@\n+\n@@ -139,0 +150,1 @@\n+\n@@ -142,1 +154,1 @@\n-    public void setBytes(final byte[] bytes) {\n+    public void setBytes( final byte[] bytes ) {\n@@ -146,0 +158,1 @@\n+\n@@ -155,3 +168,3 @@\n-        final int limit = 10;\n-        if (super.getLength() > limit) {\n-            final byte[] tmp = Arrays.copyOf(bytes, limit);\n+        if (super.getLength() > 10) {\n+            final byte[] tmp = new byte[10];\n+            System.arraycopy(bytes, 0, tmp, 0, 10);\n@@ -164,0 +177,15 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Unknown c = (Unknown) clone();\n+        if (bytes != null) {\n+            c.bytes = new byte[bytes.length];\n+            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Unknown.java","additions":75,"deletions":47,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Unknown (non-standard) attributes may be read via user-defined factory objects that can be registered with the\n- * Attribute.addAttributeReader method. These factory objects should implement this interface.\n+ * Unknown (non-standard) attributes may be read via user-defined factory\n+ * objects that can be registered with the Attribute.addAttributeReader\n+ * method. These factory objects should implement this interface.\n@@ -34,3 +35,3 @@\n-     * When this attribute reader is added via the static method Attribute.addAttributeReader, an attribute name is\n-     * associated with it. As the class file parser parses attributes, it will call various AttributeReaders based on the\n-     * name of the attributes it is constructing.\n+     * When this attribute reader is added via the static method Attribute.addAttributeReader,\n+     * an attribute name is associated with it. As the class file parser parses attributes,\n+     * it will call various AttributeReaders based on the name of the attributes it is constructing.\n@@ -38,5 +39,6 @@\n-     * @param nameIndex An index into the constant pool, indexing a ConstantUtf8 that represents the name of the attribute.\n-     * @param length The length of the data contained in the attribute. This is written into the constant pool and should\n-     *        agree with what the factory expects the length to be.\n-     * @param file This is the data input that the factory needs to read its data from.\n-     * @param constantPool This is the constant pool associated with the Attribute that we are constructing.\n+     * @param name_index    An index into the constant pool, indexing a ConstantUtf8\n+     *                      that represents the name of the attribute.\n+     * @param length        The length of the data contained in the attribute. This is written\n+     *                      into the constant pool and should agree with what the factory expects the length to be.\n+     * @param file          This is the data input that the factory needs to read its data from.\n+     * @param constant_pool This is the constant pool associated with the Attribute that we are constructing.\n@@ -44,2 +46,3 @@\n-     * @return The user-defined AttributeReader should take this data and use it to construct an attribute. In the case of\n-     *         errors, a null can be returned which will cause the parsing of the class file to fail.\n+     * @return The user-defined AttributeReader should take this data and use\n+     * it to construct an attribute.  In the case of errors, a null can be\n+     * returned which will cause the parsing of the class file to fail.\n@@ -49,1 +52,1 @@\n-    Attribute createAttribute(int nameIndex, int length, java.io.DataInput file, ConstantPool constantPool);\n+    Attribute createAttribute( int name_index, int length, java.io.DataInput file, ConstantPool constant_pool );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/UnknownAttributeReader.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.util.Arrays;\n@@ -46,1 +45,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: June 2021\n@@ -51,29 +50,3 @@\n-    \/**\n-     * Decode characters into bytes. Used by <a href=\"Utility.html#decode(java.lang.String, boolean)\">decode()<\/a>\n-     *\/\n-    private static class JavaReader extends FilterReader {\n-\n-        public JavaReader(final Reader in) {\n-            super(in);\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            final int b = in.read();\n-            if (b != ESCAPE_CHAR) {\n-                return b;\n-            }\n-            final int i = in.read();\n-            if (i < 0) {\n-                return -1;\n-            }\n-            if (i >= '0' && i <= '9' || i >= 'a' && i <= 'f') { \/\/ Normal escape\n-                final int j = in.read();\n-                if (j < 0) {\n-                    return -1;\n-                }\n-                final char[] tmp = {(char) i, (char) j};\n-                return Integer.parseInt(new String(tmp), 16);\n-            }\n-            return MAP_CHAR[i];\n-        }\n+    private static int unwrap( final ThreadLocal<Integer> tl ) {\n+        return tl.get();\n+    }\n@@ -81,7 +54,2 @@\n-        @Override\n-        public int read(final char[] cbuf, final int off, final int len) throws IOException {\n-            for (int i = 0; i < len; i++) {\n-                cbuf[off + i] = (char) read();\n-            }\n-            return len;\n-        }\n+    private static void wrap( final ThreadLocal<Integer> tl, final int value ) {\n+        tl.set(value);\n@@ -90,3 +58,4 @@\n-    \/**\n-     * Encode bytes into valid java identifier characters. Used by\n-     * <a href=\"Utility.html#encode(byte[], boolean)\">encode()<\/a>\n+    \/* How many chars have been consumed\n+     * during parsing in typeSignatureToString().\n+     * Read by methodSignatureToString().\n+     * Set by side effect, but only internally.\n@@ -94,35 +63,1 @@\n-    private static class JavaWriter extends FilterWriter {\n-\n-        public JavaWriter(final Writer out) {\n-            super(out);\n-        }\n-\n-        @Override\n-        public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-            for (int i = 0; i < len; i++) {\n-                write(cbuf[off + i]);\n-            }\n-        }\n-\n-        @Override\n-        public void write(final int b) throws IOException {\n-            if (isJavaIdentifierPart((char) b) && b != ESCAPE_CHAR) {\n-                out.write(b);\n-            } else {\n-                out.write(ESCAPE_CHAR); \/\/ Escape character\n-                \/\/ Special escape\n-                if (b >= 0 && b < FREE_CHARS) {\n-                    out.write(CHAR_MAP[b]);\n-                } else { \/\/ Normal escape\n-                    final char[] tmp = Integer.toHexString(b).toCharArray();\n-                    if (tmp.length == 1) {\n-                        out.write('0');\n-                        out.write(tmp[0]);\n-                    } else {\n-                        out.write(tmp[0]);\n-                        out.write(tmp[1]);\n-                    }\n-                }\n-            }\n-        }\n-\n+    private static ThreadLocal<Integer> consumed_chars = new ThreadLocal<Integer>() {\n@@ -130,2 +65,2 @@\n-        public void write(final String str, final int off, final int len) throws IOException {\n-            write(str.toCharArray(), off, len);\n+        protected Integer initialValue() {\n+            return 0;\n@@ -133,12 +68,10 @@\n-    }\n-\n-    \/*\n-     * How many chars have been consumed during parsing in typeSignatureToString(). Read by methodSignatureToString(). Set\n-     * by side effect, but only internally.\n-     *\/\n-    private static final ThreadLocal<Integer> CONSUMER_CHARS = ThreadLocal.withInitial(() -> Integer.valueOf(0));\n-\n-    \/*\n-     * The 'WIDE' instruction is used in the byte code to allow 16-bit wide indices for local variables. This opcode\n-     * precedes an 'ILOAD', e.g.. The opcode immediately following takes an extra byte which is combined with the following\n-     * byte to form a 16-bit value.\n+    };\n+\n+    \/* The `WIDE' instruction is used in the\n+     * byte code to allow 16-bit wide indices\n+     * for local variables. This opcode\n+     * precedes an `ILOAD', e.g.. The opcode\n+     * immediately following takes an extra\n+     * byte which is combined with the\n+     * following byte to form a\n+     * 16-bit value.\n@@ -146,1 +79,1 @@\n-    private static boolean wide;\n+    private static boolean wide = false;\n@@ -148,27 +81,0 @@\n-    \/\/ A-Z, g-z, _, $\n-    private static final int FREE_CHARS = 48;\n-\n-    private static final int[] CHAR_MAP = new int[FREE_CHARS];\n-\n-    private static final int[] MAP_CHAR = new int[256]; \/\/ Reverse map\n-\n-    private static final char ESCAPE_CHAR = '$';\n-\n-    static {\n-        int j = 0;\n-        for (int i = 'A'; i <= 'Z'; i++) {\n-            CHAR_MAP[j] = i;\n-            MAP_CHAR[i] = j;\n-            j++;\n-        }\n-        for (int i = 'g'; i <= 'z'; i++) {\n-            CHAR_MAP[j] = i;\n-            MAP_CHAR[i] = j;\n-            j++;\n-        }\n-        CHAR_MAP[j] = '$';\n-        MAP_CHAR['$'] = j;\n-        j++;\n-        CHAR_MAP[j] = '_';\n-        MAP_CHAR['_'] = j;\n-    }\n@@ -177,1 +83,1 @@\n-     * Convert bit field of flags into string such as 'static final'.\n+     * Convert bit field of flags into string such as `static final'.\n@@ -179,1 +85,1 @@\n-     * @param accessFlags Access flags\n+     * @param  access_flags Access flags\n@@ -182,2 +88,2 @@\n-    public static String accessToString(final int accessFlags) {\n-        return accessToString(accessFlags, false);\n+    public static String accessToString( final int access_flags ) {\n+        return accessToString(access_flags, false);\n@@ -186,0 +92,1 @@\n+\n@@ -187,1 +94,1 @@\n-     * Convert bit field of flags into string such as 'static final'.\n+     * Convert bit field of flags into string such as `static final'.\n@@ -189,2 +96,4 @@\n-     * Special case: Classes compiled with new compilers and with the 'ACC_SUPER' flag would be said to be \"synchronized\".\n-     * This is because SUN used the same value for the flags 'ACC_SUPER' and 'ACC_SYNCHRONIZED'.\n+     * Special case: Classes compiled with new compilers and with the\n+     * `ACC_SUPER' flag would be said to be \"synchronized\". This is\n+     * because SUN used the same value for the flags `ACC_SUPER' and\n+     * `ACC_SYNCHRONIZED'.\n@@ -192,2 +101,2 @@\n-     * @param accessFlags Access flags\n-     * @param forClass access flags are for class qualifiers ?\n+     * @param  access_flags Access flags\n+     * @param  for_class access flags are for class qualifiers ?\n@@ -196,1 +105,1 @@\n-    public static String accessToString(final int accessFlags, final boolean forClass) {\n+    public static String accessToString( final int access_flags, final boolean for_class ) {\n@@ -201,4 +110,5 @@\n-            if ((accessFlags & p) != 0) {\n-                \/*\n-                 * Special case: Classes compiled with new compilers and with the 'ACC_SUPER' flag would be said to be \"synchronized\".\n-                 * This is because SUN used the same value for the flags 'ACC_SUPER' and 'ACC_SYNCHRONIZED'.\n+            if ((access_flags & p) != 0) {\n+                \/* Special case: Classes compiled with new compilers and with the\n+                 * `ACC_SUPER' flag would be said to be \"synchronized\". This is\n+                 * because SUN used the same value for the flags `ACC_SUPER' and\n+                 * `ACC_SYNCHRONIZED'.\n@@ -206,1 +116,1 @@\n-                if (forClass && (p == Const.ACC_SUPER || p == Const.ACC_INTERFACE)) {\n+                if (for_class && ((p == Const.ACC_SUPER) || (p == Const.ACC_INTERFACE))) {\n@@ -215,6 +125,0 @@\n-    \/**\n-     * Convert (signed) byte to (unsigned) short value, i.e., all negative values become positive.\n-     *\/\n-    private static short byteToShort(final byte b) {\n-        return b < 0 ? (short) (256 + b) : (short) b;\n-    }\n@@ -223,1 +127,1 @@\n-     * @param accessFlags the class flags\n+     * @param access_flags the class flags\n@@ -227,10 +131,2 @@\n-    public static String classOrInterface(final int accessFlags) {\n-        return (accessFlags & Const.ACC_INTERFACE) != 0 ? \"interface\" : \"class\";\n-    }\n-\n-    \/**\n-     * @return 'flag' with bit 'i' set to 0\n-     *\/\n-    public static int clearBit(final int flag, final int i) {\n-        final int bit = pow2(i);\n-        return (flag & bit) == 0 ? flag : flag ^ bit;\n+    public static String classOrInterface( final int access_flags ) {\n+        return ((access_flags & Const.ACC_INTERFACE) != 0) ? \"interface\" : \"class\";\n@@ -239,3 +135,0 @@\n-    public static String codeToString(final byte[] code, final ConstantPool constantPool, final int index, final int length) {\n-        return codeToString(code, constantPool, index, length, true);\n-    }\n@@ -244,2 +137,4 @@\n-     * Disassemble a byte array of JVM byte codes starting from code line 'index' and return the disassembled string\n-     * representation. Decode only 'num' opcodes (including their operands), use -1 if you want to decompile everything.\n+     * Disassemble a byte array of JVM byte codes starting from code line\n+     * `index' and return the disassembled string representation. Decode only\n+     * `num' opcodes (including their operands), use -1 if you want to\n+     * decompile everything.\n@@ -247,5 +142,6 @@\n-     * @param code byte code array\n-     * @param constantPool Array of constants\n-     * @param index offset in 'code' array <EM>(number of opcodes, not bytes!)<\/EM>\n-     * @param length number of opcodes to decompile, -1 for all\n-     * @param verbose be verbose, e.g. print constant pool index\n+     * @param  code byte code array\n+     * @param  constant_pool Array of constants\n+     * @param  index offset in `code' array\n+     * <EM>(number of opcodes, not bytes!)<\/EM>\n+     * @param  length number of opcodes to decompile, -1 for all\n+     * @param  verbose be verbose, e.g. print constant pool index\n@@ -254,1 +150,2 @@\n-    public static String codeToString(final byte[] code, final ConstantPool constantPool, final int index, final int length, final boolean verbose) {\n+    public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index,\n+            final int length, final boolean verbose ) {\n@@ -258,1 +155,1 @@\n-                codeToString(stream, constantPool, verbose);\n+                codeToString(stream, constant_pool, verbose);\n@@ -261,1 +158,1 @@\n-                if (length < 0 || i < length) {\n+                if ((length < 0) || (i < length)) {\n@@ -263,1 +160,1 @@\n-                    buf.append(indices).append(codeToString(stream, constantPool, verbose)).append('\\n');\n+                    buf.append(indices).append(codeToString(stream, constant_pool, verbose)).append('\\n');\n@@ -272,2 +169,3 @@\n-    public static String codeToString(final ByteSequence bytes, final ConstantPool constantPool) throws IOException {\n-        return codeToString(bytes, constantPool, true);\n+\n+    public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index, final int length ) {\n+        return codeToString(code, constant_pool, index, length, true);\n@@ -276,0 +174,1 @@\n+\n@@ -277,1 +176,2 @@\n-     * Disassemble a stream of byte codes and return the string representation.\n+     * Disassemble a stream of byte codes and return the\n+     * string representation.\n@@ -279,3 +179,3 @@\n-     * @param bytes stream of bytes\n-     * @param constantPool Array of constants\n-     * @param verbose be verbose, e.g. print constant pool index\n+     * @param  bytes stream of bytes\n+     * @param  constant_pool Array of constants\n+     * @param  verbose be verbose, e.g. print constant pool index\n@@ -287,1 +187,1 @@\n-    public static String codeToString(final ByteSequence bytes, final ConstantPool constantPool,\n+    public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool,\n@@ -290,1 +190,1 @@\n-        int defaultOffset = 0;\n+        int default_offset = 0;\n@@ -298,2 +198,2 @@\n-        int[] jumpTable;\n-        int noPadBytes = 0;\n+        int[] jump_table;\n+        int no_pad_bytes = 0;\n@@ -302,2 +202,2 @@\n-        \/*\n-         * Special case: Skip (0-3) padding bytes, i.e., the following bytes are 4-byte-aligned\n+        \/* Special case: Skip (0-3) padding bytes, i.e., the\n+         * following bytes are 4-byte-aligned\n@@ -305,1 +205,1 @@\n-        if (opcode == Const.TABLESWITCH || opcode == Const.LOOKUPSWITCH) {\n+        if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {\n@@ -307,2 +207,2 @@\n-            noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n-            for (int i = 0; i < noPadBytes; i++) {\n+            no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n+            for (int i = 0; i < no_pad_bytes; i++) {\n@@ -311,1 +211,2 @@\n-                    System.err.println(\"Warning: Padding byte != 0 in \" + Const.getOpcodeName(opcode) + \":\" + b);\n+                    System.err.println(\"Warning: Padding byte != 0 in \"\n+                            + Const.getOpcodeName(opcode) + \":\" + b);\n@@ -315,1 +216,1 @@\n-            defaultOffset = bytes.readInt();\n+            default_offset = bytes.readInt();\n@@ -318,15 +219,16 @@\n-        \/*\n-         * Table switch has variable length arguments.\n-         *\/\n-        case Const.TABLESWITCH:\n-            low = bytes.readInt();\n-            high = bytes.readInt();\n-            offset = bytes.getIndex() - 12 - noPadBytes - 1;\n-            defaultOffset += offset;\n-            buf.append(\"\\tdefault = \").append(defaultOffset).append(\", low = \").append(low).append(\", high = \").append(high).append(\"(\");\n-            jumpTable = new int[high - low + 1];\n-            for (int i = 0; i < jumpTable.length; i++) {\n-                jumpTable[i] = offset + bytes.readInt();\n-                buf.append(jumpTable[i]);\n-                if (i < jumpTable.length - 1) {\n-                    buf.append(\", \");\n+            \/* Table switch has variable length arguments.\n+             *\/\n+            case Const.TABLESWITCH:\n+                low = bytes.readInt();\n+                high = bytes.readInt();\n+                offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n+                default_offset += offset;\n+                buf.append(\"\\tdefault = \").append(default_offset).append(\", low = \").append(low)\n+                        .append(\", high = \").append(high).append(\"(\");\n+                jump_table = new int[high - low + 1];\n+                for (int i = 0; i < jump_table.length; i++) {\n+                    jump_table[i] = offset + bytes.readInt();\n+                    buf.append(jump_table[i]);\n+                    if (i < jump_table.length - 1) {\n+                        buf.append(\", \");\n+                    }\n@@ -334,19 +236,19 @@\n-            }\n-            buf.append(\")\");\n-            break;\n-        \/*\n-         * Lookup switch has variable length arguments.\n-         *\/\n-        case Const.LOOKUPSWITCH: {\n-            npairs = bytes.readInt();\n-            offset = bytes.getIndex() - 8 - noPadBytes - 1;\n-            match = new int[npairs];\n-            jumpTable = new int[npairs];\n-            defaultOffset += offset;\n-            buf.append(\"\\tdefault = \").append(defaultOffset).append(\", npairs = \").append(npairs).append(\" (\");\n-            for (int i = 0; i < npairs; i++) {\n-                match[i] = bytes.readInt();\n-                jumpTable[i] = offset + bytes.readInt();\n-                buf.append(\"(\").append(match[i]).append(\", \").append(jumpTable[i]).append(\")\");\n-                if (i < npairs - 1) {\n-                    buf.append(\", \");\n+                buf.append(\")\");\n+                break;\n+            \/* Lookup switch has variable length arguments.\n+             *\/\n+            case Const.LOOKUPSWITCH: {\n+                npairs = bytes.readInt();\n+                offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n+                match = new int[npairs];\n+                jump_table = new int[npairs];\n+                default_offset += offset;\n+                buf.append(\"\\tdefault = \").append(default_offset).append(\", npairs = \").append(\n+                        npairs).append(\" (\");\n+                for (int i = 0; i < npairs; i++) {\n+                    match[i] = bytes.readInt();\n+                    jump_table[i] = offset + bytes.readInt();\n+                    buf.append(\"(\").append(match[i]).append(\", \").append(jump_table[i]).append(\")\");\n+                    if (i < npairs - 1) {\n+                        buf.append(\", \");\n+                    }\n@@ -354,0 +256,1 @@\n+                buf.append(\")\");\n@@ -355,160 +258,157 @@\n-            buf.append(\")\");\n-        }\n-            break;\n-        \/*\n-         * Two address bytes + offset from start of byte stream form the jump target\n-         *\/\n-        case Const.GOTO:\n-        case Const.IFEQ:\n-        case Const.IFGE:\n-        case Const.IFGT:\n-        case Const.IFLE:\n-        case Const.IFLT:\n-        case Const.JSR:\n-        case Const.IFNE:\n-        case Const.IFNONNULL:\n-        case Const.IFNULL:\n-        case Const.IF_ACMPEQ:\n-        case Const.IF_ACMPNE:\n-        case Const.IF_ICMPEQ:\n-        case Const.IF_ICMPGE:\n-        case Const.IF_ICMPGT:\n-        case Const.IF_ICMPLE:\n-        case Const.IF_ICMPLT:\n-        case Const.IF_ICMPNE:\n-            buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readShort());\n-            break;\n-        \/*\n-         * 32-bit wide jumps\n-         *\/\n-        case Const.GOTO_W:\n-        case Const.JSR_W:\n-            buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readInt());\n-            break;\n-        \/*\n-         * Index byte references local variable (register)\n-         *\/\n-        case Const.ALOAD:\n-        case Const.ASTORE:\n-        case Const.DLOAD:\n-        case Const.DSTORE:\n-        case Const.FLOAD:\n-        case Const.FSTORE:\n-        case Const.ILOAD:\n-        case Const.ISTORE:\n-        case Const.LLOAD:\n-        case Const.LSTORE:\n-        case Const.RET:\n-            if (wide) {\n-                vindex = bytes.readUnsignedShort();\n-                wide = false; \/\/ Clear flag\n-            } else {\n-                vindex = bytes.readUnsignedByte();\n-            }\n-            buf.append(\"\\t\\t%\").append(vindex);\n-            break;\n-        \/*\n-         * Remember wide byte which is used to form a 16-bit address in the following instruction. Relies on that the method is\n-         * called again with the following opcode.\n-         *\/\n-        case Const.WIDE:\n-            wide = true;\n-            buf.append(\"\\t(wide)\");\n-            break;\n-        \/*\n-         * Array of basic type.\n-         *\/\n-        case Const.NEWARRAY:\n-            buf.append(\"\\t\\t<\").append(Const.getTypeName(bytes.readByte())).append(\">\");\n-            break;\n-        \/*\n-         * Access object\/class fields.\n-         *\/\n-        case Const.GETFIELD:\n-        case Const.GETSTATIC:\n-        case Const.PUTFIELD:\n-        case Const.PUTSTATIC:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        \/*\n-         * Operands are references to classes in constant pool\n-         *\/\n-        case Const.NEW:\n-        case Const.CHECKCAST:\n-            buf.append(\"\\t\");\n-            \/\/$FALL-THROUGH$\n-        case Const.INSTANCEOF:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t<\").append(constantPool.constantToString(index, Const.CONSTANT_Class)).append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        \/*\n-         * Operands are references to methods in constant pool\n-         *\/\n-        case Const.INVOKESPECIAL:\n-        case Const.INVOKESTATIC:\n-            index = bytes.readUnsignedShort();\n-            final Constant c = constantPool.getConstant(index);\n-            \/\/ With Java8 operand may be either a CONSTANT_Methodref\n-            \/\/ or a CONSTANT_InterfaceMethodref. (markro)\n-            buf.append(\"\\t\").append(constantPool.constantToString(index, c.getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        case Const.INVOKEVIRTUAL:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        case Const.INVOKEINTERFACE:\n-            index = bytes.readUnsignedShort();\n-            final int nargs = bytes.readUnsignedByte(); \/\/ historical, redundant\n-            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? \" (\" + index + \")\\t\" : \"\")\n-                .append(nargs).append(\"\\t\").append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n-            break;\n-        case Const.INVOKEDYNAMIC:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? \" (\" + index + \")\\t\" : \"\")\n-                .append(bytes.readUnsignedByte()) \/\/ Thrid byte is a reserved space\n-                .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n-            break;\n-        \/*\n-         * Operands are references to items in constant pool\n-         *\/\n-        case Const.LDC_W:\n-        case Const.LDC2_W:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))\n-                .append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        case Const.LDC:\n-            index = bytes.readUnsignedByte();\n-            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))\n-                .append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        \/*\n-         * Array of references.\n-         *\/\n-        case Const.ANEWARRAY:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\\t<\").append(compactClassName(constantPool.getConstantString(index, Const.CONSTANT_Class), false)).append(\">\")\n-                .append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        \/*\n-         * Multidimensional array of references.\n-         *\/\n-        case Const.MULTIANEWARRAY: {\n-            index = bytes.readUnsignedShort();\n-            final int dimensions = bytes.readUnsignedByte();\n-            buf.append(\"\\t<\").append(compactClassName(constantPool.getConstantString(index, Const.CONSTANT_Class), false)).append(\">\\t\").append(dimensions)\n-                .append(verbose ? \" (\" + index + \")\" : \"\");\n-        }\n-            break;\n-        \/*\n-         * Increment local variable.\n-         *\/\n-        case Const.IINC:\n-            if (wide) {\n-                vindex = bytes.readUnsignedShort();\n-                constant = bytes.readShort();\n-                wide = false;\n-            } else {\n-                vindex = bytes.readUnsignedByte();\n-                constant = bytes.readByte();\n+                break;\n+            \/* Two address bytes + offset from start of byte stream form the\n+             * jump target\n+             *\/\n+            case Const.GOTO:\n+            case Const.IFEQ:\n+            case Const.IFGE:\n+            case Const.IFGT:\n+            case Const.IFLE:\n+            case Const.IFLT:\n+            case Const.JSR:\n+            case Const.IFNE:\n+            case Const.IFNONNULL:\n+            case Const.IFNULL:\n+            case Const.IF_ACMPEQ:\n+            case Const.IF_ACMPNE:\n+            case Const.IF_ICMPEQ:\n+            case Const.IF_ICMPGE:\n+            case Const.IF_ICMPGT:\n+            case Const.IF_ICMPLE:\n+            case Const.IF_ICMPLT:\n+            case Const.IF_ICMPNE:\n+                buf.append(\"\\t\\t#\").append((bytes.getIndex() - 1) + bytes.readShort());\n+                break;\n+            \/* 32-bit wide jumps\n+             *\/\n+            case Const.GOTO_W:\n+            case Const.JSR_W:\n+                buf.append(\"\\t\\t#\").append((bytes.getIndex() - 1) + bytes.readInt());\n+                break;\n+            \/* Index byte references local variable (register)\n+             *\/\n+            case Const.ALOAD:\n+            case Const.ASTORE:\n+            case Const.DLOAD:\n+            case Const.DSTORE:\n+            case Const.FLOAD:\n+            case Const.FSTORE:\n+            case Const.ILOAD:\n+            case Const.ISTORE:\n+            case Const.LLOAD:\n+            case Const.LSTORE:\n+            case Const.RET:\n+                if (wide) {\n+                    vindex = bytes.readUnsignedShort();\n+                    wide = false; \/\/ Clear flag\n+                } else {\n+                    vindex = bytes.readUnsignedByte();\n+                }\n+                buf.append(\"\\t\\t%\").append(vindex);\n+                break;\n+            \/*\n+             * Remember wide byte which is used to form a 16-bit address in the\n+             * following instruction. Relies on that the method is called again with\n+             * the following opcode.\n+             *\/\n+            case Const.WIDE:\n+                wide = true;\n+                buf.append(\"\\t(wide)\");\n+                break;\n+            \/* Array of basic type.\n+             *\/\n+            case Const.NEWARRAY:\n+                buf.append(\"\\t\\t<\").append(Const.getTypeName(bytes.readByte())).append(\">\");\n+                break;\n+            \/* Access object\/class fields.\n+             *\/\n+            case Const.GETFIELD:\n+            case Const.GETSTATIC:\n+            case Const.PUTFIELD:\n+            case Const.PUTSTATIC:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\\t\").append(\n+                        constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(\n+                        verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            \/* Operands are references to classes in constant pool\n+             *\/\n+            case Const.NEW:\n+            case Const.CHECKCAST:\n+                buf.append(\"\\t\");\n+                \/\/$FALL-THROUGH$\n+            case Const.INSTANCEOF:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t<\").append(\n+                        constant_pool.constantToString(index, Const.CONSTANT_Class))\n+                        .append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            \/* Operands are references to methods in constant pool\n+             *\/\n+            case Const.INVOKESPECIAL:\n+            case Const.INVOKESTATIC:\n+                index = bytes.readUnsignedShort();\n+                final Constant c = constant_pool.getConstant(index);\n+                \/\/ With Java8 operand may be either a CONSTANT_Methodref\n+                \/\/ or a CONSTANT_InterfaceMethodref.   (markro)\n+                buf.append(\"\\t\").append(\n+                        constant_pool.constantToString(index, c.getTag()))\n+                        .append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            case Const.INVOKEVIRTUAL:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\").append(\n+                        constant_pool.constantToString(index, Const.CONSTANT_Methodref))\n+                        .append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            case Const.INVOKEINTERFACE:\n+                index = bytes.readUnsignedShort();\n+                final int nargs = bytes.readUnsignedByte(); \/\/ historical, redundant\n+                buf.append(\"\\t\").append(\n+                        constant_pool\n+                                .constantToString(index, Const.CONSTANT_InterfaceMethodref))\n+                        .append(verbose ? \" (\" + index + \")\\t\" : \"\").append(nargs).append(\"\\t\")\n+                        .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n+                break;\n+            case Const.INVOKEDYNAMIC:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\").append(\n+                        constant_pool\n+                                .constantToString(index, Const.CONSTANT_InvokeDynamic))\n+                        .append(verbose ? \" (\" + index + \")\\t\" : \"\")\n+                        .append(bytes.readUnsignedByte())  \/\/ Thrid byte is a reserved space\n+                        .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n+                break;\n+            \/* Operands are references to items in constant pool\n+             *\/\n+            case Const.LDC_W:\n+            case Const.LDC2_W:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\\t\").append(\n+                        constant_pool.constantToString(index, constant_pool.getConstant(index)\n+                                .getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            case Const.LDC:\n+                index = bytes.readUnsignedByte();\n+                buf.append(\"\\t\\t\").append(\n+                        constant_pool.constantToString(index, constant_pool.getConstant(index)\n+                                .getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            \/* Array of references.\n+             *\/\n+            case Const.ANEWARRAY:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\\t<\").append(\n+                        compactClassName(constant_pool.getConstantString(index,\n+                                Const.CONSTANT_Class), false)).append(\">\").append(\n+                        verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            \/* Multidimensional array of references.\n+             *\/\n+            case Const.MULTIANEWARRAY: {\n+                index = bytes.readUnsignedShort();\n+                final int dimensions = bytes.readUnsignedByte();\n+                buf.append(\"\\t<\").append(\n+                        compactClassName(constant_pool.getConstantString(index,\n+                                Const.CONSTANT_Class), false)).append(\">\\t\").append(dimensions)\n+                        .append(verbose ? \" (\" + index + \")\" : \"\");\n@@ -516,18 +416,31 @@\n-            buf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\n-            break;\n-        default:\n-            if (Const.getNoOfOperands(opcode) > 0) {\n-                for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n-                    buf.append(\"\\t\\t\");\n-                    switch (Const.getOperandType(opcode, i)) {\n-                    case Const.T_BYTE:\n-                        buf.append(bytes.readByte());\n-                        break;\n-                    case Const.T_SHORT:\n-                        buf.append(bytes.readShort());\n-                        break;\n-                    case Const.T_INT:\n-                        buf.append(bytes.readInt());\n-                        break;\n-                    default: \/\/ Never reached\n-                        throw new IllegalStateException(\"Unreachable default case reached!\");\n+                break;\n+            \/* Increment local variable.\n+             *\/\n+            case Const.IINC:\n+                if (wide) {\n+                    vindex = bytes.readUnsignedShort();\n+                    constant = bytes.readShort();\n+                    wide = false;\n+                } else {\n+                    vindex = bytes.readUnsignedByte();\n+                    constant = bytes.readByte();\n+                }\n+                buf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\n+                break;\n+            default:\n+                if (Const.getNoOfOperands(opcode) > 0) {\n+                    for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n+                        buf.append(\"\\t\\t\");\n+                        switch (Const.getOperandType(opcode, i)) {\n+                            case Const.T_BYTE:\n+                                buf.append(bytes.readByte());\n+                                break;\n+                            case Const.T_SHORT:\n+                                buf.append(bytes.readShort());\n+                                break;\n+                            case Const.T_INT:\n+                                buf.append(bytes.readInt());\n+                                break;\n+                            default: \/\/ Never reached\n+                                throw new IllegalStateException(\"Unreachable default case reached!\");\n+                        }\n@@ -536,1 +449,0 @@\n-            }\n@@ -541,0 +453,7 @@\n+\n+    public static String codeToString( final ByteSequence bytes, final ConstantPool constant_pool )\n+            throws IOException {\n+        return codeToString(bytes, constant_pool, true);\n+    }\n+\n+\n@@ -542,1 +461,2 @@\n-     * Shorten long class names, <em>java\/lang\/String<\/em> becomes <em>String<\/em>.\n+     * Shorten long class names, <em>java\/lang\/String<\/em> becomes\n+     * <em>String<\/em>.\n@@ -547,1 +467,1 @@\n-    public static String compactClassName(final String str) {\n+    public static String compactClassName( final String str ) {\n@@ -551,0 +471,1 @@\n+\n@@ -552,2 +473,4 @@\n-     * Shorten long class names, <em>java\/lang\/String<\/em> becomes <em>java.lang.String<\/em>, e.g.. If <em>chopit<\/em> is\n-     * <em>true<\/em> the prefix <em>java.lang<\/em> is also removed.\n+     * Shorten long class names, <em>java\/lang\/String<\/em> becomes\n+     * <em>java.lang.String<\/em>,\n+     * e.g.. If <em>chopit<\/em> is <em>true<\/em> the prefix <em>java.lang<\/em>\n+     * is also removed.\n@@ -559,1 +482,1 @@\n-    public static String compactClassName(final String str, final boolean chopit) {\n+    public static String compactClassName( final String str, final boolean chopit ) {\n@@ -563,0 +486,1 @@\n+\n@@ -564,2 +488,4 @@\n-     * Shorten long class name <em>str<\/em>, i.e., chop off the <em>prefix<\/em>, if the class name starts with this string\n-     * and the flag <em>chopit<\/em> is true. Slashes <em>\/<\/em> are converted to dots <em>.<\/em>.\n+     * Shorten long class name <em>str<\/em>, i.e., chop off the <em>prefix<\/em>,\n+     * if the\n+     * class name starts with this string and the flag <em>chopit<\/em> is true.\n+     * Slashes <em>\/<\/em> are converted to dots <em>.<\/em>.\n@@ -572,1 +498,1 @@\n-    public static String compactClassName(String str, final String prefix, final boolean chopit) {\n+    public static String compactClassName( String str, final String prefix, final boolean chopit ) {\n@@ -574,4 +500,6 @@\n-        str = pathToPackage(str); \/\/ Is '\/' on all systems, even DOS\n-        \/\/ If string starts with 'prefix' and contains no further dots\n-        if (chopit && str.startsWith(prefix) && str.substring(len).indexOf('.') == -1) {\n-            str = str.substring(len);\n+        str = str.replace('\/', '.'); \/\/ Is `\/' on all systems, even DOS\n+        if (chopit) {\n+            \/\/ If string starts with `prefix' and contains no further dots\n+            if (str.startsWith(prefix) && (str.substring(len).indexOf('.') == -1)) {\n+                str = str.substring(len);\n+            }\n@@ -582,0 +510,1 @@\n+\n@@ -583,1 +512,1 @@\n-     * Escape all occurrences of newline chars '\\n', quotes \\\", etc.\n+     * @return `flag' with bit `i' set to 1\n@@ -585,26 +514,2 @@\n-    public static String convertString(final String label) {\n-        final char[] ch = label.toCharArray();\n-        final StringBuilder buf = new StringBuilder();\n-        for (final char element : ch) {\n-            switch (element) {\n-            case '\\n':\n-                buf.append(\"\\\\n\");\n-                break;\n-            case '\\r':\n-                buf.append(\"\\\\r\");\n-                break;\n-            case '\\\"':\n-                buf.append(\"\\\\\\\"\");\n-                break;\n-            case '\\'':\n-                buf.append(\"\\\\'\");\n-                break;\n-            case '\\\\':\n-                buf.append(\"\\\\\\\\\");\n-                break;\n-            default:\n-                buf.append(element);\n-                break;\n-            }\n-        }\n-        return buf.toString();\n+    public static int setBit( final int flag, final int i ) {\n+        return flag | pow2(i);\n@@ -613,28 +518,7 @@\n-    private static int countBrackets(final String brackets) {\n-        final char[] chars = brackets.toCharArray();\n-        int count = 0;\n-        boolean open = false;\n-        for (final char c : chars) {\n-            switch (c) {\n-            case '[':\n-                if (open) {\n-                    throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-                }\n-                open = true;\n-                break;\n-            case ']':\n-                if (!open) {\n-                    throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-                }\n-                open = false;\n-                count++;\n-                break;\n-            default:\n-                \/\/ Don't care\n-                break;\n-            }\n-        }\n-        if (open) {\n-            throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-        }\n-        return count;\n+\n+    \/**\n+     * @return `flag' with bit `i' set to 0\n+     *\/\n+    public static int clearBit( final int flag, final int i ) {\n+        final int bit = pow2(i);\n+        return (flag & bit) == 0 ? flag : flag ^ bit;\n@@ -643,0 +527,1 @@\n+\n@@ -644,1 +529,10 @@\n-     * Decode a string back to a byte array.\n+     * @return true, if bit `i' in `flag' is set\n+     *\/\n+    public static boolean isSet( final int flag, final int i ) {\n+        return (flag & pow2(i)) != 0;\n+    }\n+\n+\n+    \/**\n+     * Converts string containing the method return and argument types\n+     * to a byte code method signature.\n@@ -646,2 +540,3 @@\n-     * @param s the string to convert\n-     * @param uncompress use gzip to uncompress the stream of bytes\n+     * @param  ret Return type of method\n+     * @param  argv Types of method arguments\n+     * @return Byte code representation of method signature\n@@ -649,1 +544,1 @@\n-     * @throws IOException if there's a gzip exception\n+     * @throws ClassFormatException if the signature is for Void\n@@ -651,16 +546,11 @@\n-    public static byte[] decode(final String s, final boolean uncompress) throws IOException {\n-        byte[] bytes;\n-        try (JavaReader jr = new JavaReader(new CharArrayReader(s.toCharArray())); ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n-            int ch;\n-            while ((ch = jr.read()) >= 0) {\n-                bos.write(ch);\n-            }\n-            bytes = bos.toByteArray();\n-        }\n-        if (uncompress) {\n-            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n-            final byte[] tmp = new byte[bytes.length * 3]; \/\/ Rough estimate\n-            int count = 0;\n-            int b;\n-            while ((b = gis.read()) >= 0) {\n-                tmp[count++] = (byte) b;\n+    public static String methodTypeToSignature( final String ret, final String[] argv )\n+            throws ClassFormatException {\n+        final StringBuilder buf = new StringBuilder(\"(\");\n+        String str;\n+        if (argv != null) {\n+            for (final String element : argv) {\n+                str = getSignature(element);\n+                if (str.endsWith(\"V\")) {\n+                    throw new ClassFormatException(\"Invalid type: \" + element);\n+                }\n+                buf.append(str);\n@@ -668,1 +558,0 @@\n-            bytes = Arrays.copyOf(tmp, count);\n@@ -670,1 +559,3 @@\n-        return bytes;\n+        str = getSignature(ret);\n+        buf.append(\")\").append(str);\n+        return buf.toString();\n@@ -673,0 +564,1 @@\n+\n@@ -674,15 +566,1 @@\n-     * Encode byte array it into Java identifier string, i.e., a string that only contains the following characters: (a, ...\n-     * z, A, ... Z, 0, ... 9, _, $). The encoding algorithm itself is not too clever: if the current byte's ASCII value\n-     * already is a valid Java identifier part, leave it as it is. Otherwise it writes the escape character($) followed by:\n-     *\n-     * <ul>\n-     * <li>the ASCII value as a hexadecimal string, if the value is not in the range 200..247<\/li>\n-     * <li>a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247<\/li>\n-     * <\/ul>\n-     *\n-     * <p>\n-     * This operation inflates the original byte array by roughly 40-50%\n-     * <\/p>\n-     *\n-     * @param bytes the byte array to convert\n-     * @param compress use gzip to minimize string\n+     * Converts argument list portion of method signature to string with all class names compacted.\n@@ -690,1 +568,3 @@\n-     * @throws IOException if there's a gzip exception\n+     * @param  signature    Method signature\n+     * @return String Array of argument types\n+     * @throws ClassFormatException\n@@ -692,157 +572,2 @@\n-    public static String encode(byte[] bytes, final boolean compress) throws IOException {\n-        if (compress) {\n-            try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n-                gos.write(bytes, 0, bytes.length);\n-                gos.finish();\n-                bytes = baos.toByteArray();\n-            }\n-        }\n-        final CharArrayWriter caw = new CharArrayWriter();\n-        try (JavaWriter jw = new JavaWriter(caw)) {\n-            for (final byte b : bytes) {\n-                final int in = b & 0x000000ff; \/\/ Normalize to unsigned\n-                jw.write(in);\n-            }\n-        }\n-        return caw.toString();\n-    }\n-\n-    \/**\n-     * Fillup char with up to length characters with char 'fill' and justify it left or right.\n-     *\n-     * @param str string to format\n-     * @param length length of desired string\n-     * @param leftJustify format left or right\n-     * @param fill fill character\n-     * @return formatted string\n-     *\/\n-    public static String fillup(final String str, final int length, final boolean leftJustify, final char fill) {\n-        final int len = length - str.length();\n-        final char[] buf = new char[Math.max(len, 0)];\n-        Arrays.fill(buf, fill);\n-        if (leftJustify) {\n-            return str + new String(buf);\n-        }\n-        return new String(buf) + str;\n-    }\n-\n-    \/**\n-     * Return a string for an integer justified left or right and filled up with 'fill' characters if necessary.\n-     *\n-     * @param i integer to format\n-     * @param length length of desired string\n-     * @param leftJustify format left or right\n-     * @param fill fill character\n-     * @return formatted int\n-     *\/\n-    public static String format(final int i, final int length, final boolean leftJustify, final char fill) {\n-        return fillup(Integer.toString(i), length, leftJustify, fill);\n-    }\n-\n-    \/**\n-     * WARNING:\n-     *\n-     * There is some nomenclature confusion through much of the BCEL code base with respect to the terms Descriptor and\n-     * Signature. For the offical definitions see:\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3\"> Descriptors in The Java\n-     *      Virtual Machine Specification<\/a>\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.9.1\"> Signatures in The Java\n-     *      Virtual Machine Specification<\/a>\n-     *\n-     *      In brief, a descriptor is a string representing the type of a field or method. Signatures are similar, but more\n-     *      complex. Signatures are used to encode declarations written in the Java programming language that use types\n-     *      outside the type system of the Java Virtual Machine. They are used to describe the type of any class, interface,\n-     *      constructor, method or field whose declaration uses type variables or parameterized types.\n-     *\n-     *      To parse a descriptor, call typeSignatureToString. To parse a signature, call signatureToString.\n-     *\n-     *      Note that if the signature string is a single, non-generic item, the call to signatureToString reduces to a call\n-     *      to typeSignatureToString. Also note, that if you only wish to parse the first item in a longer signature string,\n-     *      you should call typeSignatureToString directly.\n-     *\/\n-\n-    \/**\n-     * Parse Java type such as \"char\", or \"java.lang.String[]\" and return the signature in byte code format, e.g. \"C\" or\n-     * \"[Ljava\/lang\/String;\" respectively.\n-     *\n-     * @param type Java type\n-     * @return byte code signature\n-     *\/\n-    public static String getSignature(String type) {\n-        final StringBuilder buf = new StringBuilder();\n-        final char[] chars = type.toCharArray();\n-        boolean charFound = false;\n-        boolean delim = false;\n-        int index = -1;\n-        loop: for (int i = 0; i < chars.length; i++) {\n-            switch (chars[i]) {\n-            case ' ':\n-            case '\\t':\n-            case '\\n':\n-            case '\\r':\n-            case '\\f':\n-                if (charFound) {\n-                    delim = true;\n-                }\n-                break;\n-            case '[':\n-                if (!charFound) {\n-                    throw new IllegalArgumentException(\"Illegal type: \" + type);\n-                }\n-                index = i;\n-                break loop;\n-            default:\n-                charFound = true;\n-                if (!delim) {\n-                    buf.append(chars[i]);\n-                }\n-            }\n-        }\n-        int brackets = 0;\n-        if (index > 0) {\n-            brackets = countBrackets(type.substring(index));\n-        }\n-        type = buf.toString();\n-        buf.setLength(0);\n-        for (int i = 0; i < brackets; i++) {\n-            buf.append('[');\n-        }\n-        boolean found = false;\n-        for (int i = Const.T_BOOLEAN; i <= Const.T_VOID && !found; i++) {\n-            if (Const.getTypeName(i).equals(type)) {\n-                found = true;\n-                buf.append(Const.getShortTypeName(i));\n-            }\n-        }\n-        if (!found) {\n-            buf.append('L').append(packageToPath(type)).append(';');\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * @param ch the character to test if it's part of an identifier\n-     *\n-     * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)\n-     *\/\n-    public static boolean isJavaIdentifierPart(final char ch) {\n-        return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch == '_';\n-    }\n-\n-    \/**\n-     * @return true, if bit 'i' in 'flag' is set\n-     *\/\n-    public static boolean isSet(final int flag, final int i) {\n-        return (flag & pow2(i)) != 0;\n-    }\n-\n-    \/**\n-     * Converts argument list portion of method signature to string with all class names compacted.\n-     *\n-     * @param signature Method signature\n-     * @return String Array of argument types\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n-     *\/\n-    public static String[] methodSignatureArgumentTypes(final String signature) throws ClassFormatException {\n+    public static String[] methodSignatureArgumentTypes( final String signature )\n+            throws ClassFormatException {\n@@ -852,0 +577,1 @@\n+\n@@ -855,2 +581,2 @@\n-     * @param signature Method signature\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature    Method signature\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -858,1 +584,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -860,1 +586,2 @@\n-    public static String[] methodSignatureArgumentTypes(final String signature, final boolean chopit) throws ClassFormatException {\n+    public static String[] methodSignatureArgumentTypes( final String signature, final boolean chopit )\n+            throws ClassFormatException {\n@@ -864,1 +591,1 @@\n-            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n+            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n@@ -871,2 +598,2 @@\n-                \/\/ corrected concurrent private static field acess\n-                index += unwrap(CONSUMER_CHARS); \/\/ update position\n+                \/\/corrected concurrent private static field acess\n+                index += unwrap(consumed_chars); \/\/ update position\n@@ -877,1 +604,1 @@\n-        return vec.toArray(Const.EMPTY_STRING_ARRAY);\n+        return vec.toArray(new String[vec.size()]);\n@@ -880,0 +607,1 @@\n+\n@@ -883,1 +611,1 @@\n-     * @param signature Method signature\n+     * @param  signature    Method signature\n@@ -885,1 +613,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -887,1 +615,1 @@\n-    public static String methodSignatureReturnType(final String signature) throws ClassFormatException {\n+    public static String methodSignatureReturnType( final String signature ) throws ClassFormatException {\n@@ -891,0 +619,1 @@\n+\n@@ -894,2 +623,2 @@\n-     * @param signature Method signature\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature    Method signature\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -897,1 +626,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -899,1 +628,1 @@\n-    public static String methodSignatureReturnType(final String signature, final boolean chopit) throws ClassFormatException {\n+    public static String methodSignatureReturnType( final String signature, final boolean chopit ) throws ClassFormatException {\n@@ -903,1 +632,1 @@\n-            \/\/ Read return type after ')'\n+            \/\/ Read return type after `)'\n@@ -915,0 +644,1 @@\n+\n@@ -918,3 +648,3 @@\n-     * @param signature to convert\n-     * @param name of method\n-     * @param access flags of method\n+     * @param  signature to convert\n+     * @param  name of method\n+     * @param  access flags of method\n@@ -923,1 +653,1 @@\n-    public static String methodSignatureToString(final String signature, final String name, final String access) {\n+    public static String methodSignatureToString( final String signature, final String name, final String access ) {\n@@ -927,0 +657,1 @@\n+\n@@ -930,4 +661,4 @@\n-     * @param signature to convert\n-     * @param name of method\n-     * @param access flags of method\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature to convert\n+     * @param  name of method\n+     * @param  access flags of method\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -936,1 +667,1 @@\n-    public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit) {\n+    public static String methodSignatureToString( final String signature, final String name, final String access, final boolean chopit ) {\n@@ -940,0 +671,1 @@\n+\n@@ -941,2 +673,3 @@\n-     * This method converts a method signature string into a Java type declaration like 'void main(String[])' and throws a\n-     * 'ClassFormatException' when the parsed type is invalid.\n+     * This method converts a method signature string into a Java type declaration like\n+     * `void main(String[])' and throws a `ClassFormatException' when the parsed\n+     * type is invalid.\n@@ -944,5 +677,5 @@\n-     * @param signature Method signature\n-     * @param name Method name\n-     * @param access Method access rights\n-     * @param chopit flag that determines whether chopping is executed or not\n-     * @param vars the LocalVariableTable for the method\n+     * @param  signature    Method signature\n+     * @param  name         Method name\n+     * @param  access       Method access rights\n+     * @param  chopit flag that determines whether chopping is executed or not\n+     * @param  vars the LocalVariableTable for the method\n@@ -950,1 +683,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -952,2 +685,2 @@\n-    public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit,\n-        final LocalVariableTable vars) throws ClassFormatException {\n+    public static String methodSignatureToString( final String signature, final String name,\n+            final String access, final boolean chopit, final LocalVariableTable vars ) throws ClassFormatException {\n@@ -957,1 +690,1 @@\n-        int varIndex = access.contains(\"static\") ? 0 : 1;\n+        int var_index = access.contains(\"static\") ? 0 : 1;\n@@ -959,1 +692,1 @@\n-            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n+            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n@@ -965,2 +698,2 @@\n-                final String paramType = typeSignatureToString(signature.substring(index), chopit);\n-                buf.append(paramType);\n+                final String param_type = typeSignatureToString(signature.substring(index), chopit);\n+                buf.append(param_type);\n@@ -968,1 +701,1 @@\n-                    final LocalVariable l = vars.getLocalVariable(varIndex, 0);\n+                    final LocalVariable l = vars.getLocalVariable(var_index, 0);\n@@ -973,1 +706,1 @@\n-                    buf.append(\" arg\").append(varIndex);\n+                    buf.append(\" arg\").append(var_index);\n@@ -975,2 +708,2 @@\n-                if (\"double\".equals(paramType) || \"long\".equals(paramType)) {\n-                    varIndex += 2;\n+                if (\"double\".equals(param_type) || \"long\".equals(param_type)) {\n+                    var_index += 2;\n@@ -978,1 +711,1 @@\n-                    varIndex++;\n+                    var_index++;\n@@ -981,2 +714,2 @@\n-                \/\/ corrected concurrent private static field acess\n-                index += unwrap(CONSUMER_CHARS); \/\/ update position\n+                \/\/corrected concurrent private static field acess\n+                index += unwrap(consumed_chars); \/\/ update position\n@@ -985,1 +718,1 @@\n-            \/\/ Read return type after ')'\n+            \/\/ Read return type after `)'\n@@ -995,39 +728,2 @@\n-        return access + (!access.isEmpty() ? \" \" : \"\") + \/\/ May be an empty string\n-            type + \" \" + name + buf.toString();\n-    }\n-\n-    \/**\n-     * Converts string containing the method return and argument types to a byte code method signature.\n-     *\n-     * @param ret Return type of method\n-     * @param argv Types of method arguments\n-     * @return Byte code representation of method signature\n-     *\n-     * @throws ClassFormatException if the signature is for Void\n-     *\/\n-    public static String methodTypeToSignature(final String ret, final String[] argv) throws ClassFormatException {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        String str;\n-        if (argv != null) {\n-            for (final String element : argv) {\n-                str = getSignature(element);\n-                if (str.endsWith(\"V\")) {\n-                    throw new ClassFormatException(\"Invalid type: \" + element);\n-                }\n-                buf.append(str);\n-            }\n-        }\n-        str = getSignature(ret);\n-        buf.append(\")\").append(str);\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Converts '.'s to '\/'s.\n-     *\n-     * @param name Source\n-     * @return converted value\n-     * @since 6.7.0\n-     *\/\n-    public static String packageToPath(final String name) {\n-        return name.replace('.', '\/');\n+        return access + ((access.length() > 0) ? \" \" : \"\") + \/\/ May be an empty string\n+                type + \" \" + name + buf.toString();\n@@ -1036,10 +732,0 @@\n-    \/**\n-     * Converts a path to a package name.\n-     *\n-     * @param str the source path.\n-     * @return a package name.\n-     * @since 6.6.0\n-     *\/\n-    public static String pathToPackage(final String str) {\n-        return str.replace('\/', '.');\n-    }\n@@ -1047,1 +733,1 @@\n-    private static int pow2(final int n) {\n+    private static int pow2( final int n ) {\n@@ -1051,39 +737,0 @@\n-    public static String printArray(final Object[] obj) {\n-        return printArray(obj, true);\n-    }\n-\n-    public static String printArray(final Object[] obj, final boolean braces) {\n-        return printArray(obj, braces, false);\n-    }\n-\n-    public static String printArray(final Object[] obj, final boolean braces, final boolean quote) {\n-        if (obj == null) {\n-            return null;\n-        }\n-        final StringBuilder buf = new StringBuilder();\n-        if (braces) {\n-            buf.append('{');\n-        }\n-        for (int i = 0; i < obj.length; i++) {\n-            if (obj[i] != null) {\n-                buf.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n-            } else {\n-                buf.append(\"null\");\n-            }\n-            if (i < obj.length - 1) {\n-                buf.append(\", \");\n-            }\n-        }\n-        if (braces) {\n-            buf.append('}');\n-        }\n-        return buf.toString();\n-    }\n-\n-    public static void printArray(final PrintStream out, final Object[] obj) {\n-        out.println(printArray(obj, true));\n-    }\n-\n-    public static void printArray(final PrintWriter out, final Object[] obj) {\n-        out.println(printArray(obj, true));\n-    }\n@@ -1099,1 +746,1 @@\n-    public static String replace(String str, final String old, final String new_) {\n+    public static String replace( String str, final String old, final String new_ ) {\n@@ -1101,1 +748,1 @@\n-        int oldIndex;\n+        int old_index;\n@@ -1103,1 +750,1 @@\n-            if (str.contains(old)) { \/\/ 'old' found in str\n+            if (str.contains(old)) { \/\/ `old' found in str\n@@ -1105,1 +752,1 @@\n-                oldIndex = 0; \/\/ String start offset\n+                old_index = 0; \/\/ String start offset\n@@ -1107,2 +754,2 @@\n-                while ((index = str.indexOf(old, oldIndex)) != -1) {\n-                    buf.append(str, oldIndex, index); \/\/ append prefix\n+                while ((index = str.indexOf(old, old_index)) != -1) {\n+                    buf.append(str.substring(old_index, index)); \/\/ append prefix\n@@ -1110,1 +757,1 @@\n-                    oldIndex = index + old.length(); \/\/ Skip 'old'.length chars\n+                    old_index = index + old.length(); \/\/ Skip `old'.length chars\n@@ -1112,1 +759,1 @@\n-                buf.append(str.substring(oldIndex)); \/\/ append rest of string\n+                buf.append(str.substring(old_index)); \/\/ append rest of string\n@@ -1121,12 +768,0 @@\n-    \/**\n-     * Map opcode names to opcode numbers. E.g., return Constants.ALOAD for \"aload\"\n-     *\/\n-    public static short searchOpcode(String name) {\n-        name = name.toLowerCase(Locale.ENGLISH);\n-        for (short i = 0; i < Const.OPCODE_NAMES_LENGTH; i++) {\n-            if (Const.getOpcodeName(i).equals(name)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n@@ -1135,1 +770,24 @@\n-     * @return 'flag' with bit 'i' set to 1\n+     * WARNING:\n+     *\n+     * There is some nomenclature confusion through much of the BCEL code base with\n+     * respect to the terms Descriptor and Signature.  For the offical definitions see:\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3\">\n+     * Descriptors in The Java Virtual Machine Specification<\/a>\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.9.1\">\n+     * Signatures in The Java Virtual Machine Specification<\/a>\n+     *\n+     * In brief, a descriptor is a string representing the type of a field or method.\n+     * Signatures are similar, but more complex.  Signatures are used to encode declarations\n+     * written in the Java programming language that use types outside the type system of the\n+     * Java Virtual Machine.  They are used to describe the type of any class, interface,\n+     * constructor, method or field whose declaration uses type variables or parameterized types.\n+     *\n+     * To parse a descriptor, call typeSignatureToString.\n+     * To parse a signature, call signatureToString.\n+     *\n+     * Note that if the signature string is a single, non-generic item, the call to\n+     * signatureToString reduces to a call to typeSignatureToString.\n+     * Also note, that if you only wish to parse the first item in a longer signature\n+     * string, you should call typeSignatureToString directly.\n@@ -1137,3 +795,1 @@\n-    public static int setBit(final int flag, final int i) {\n-        return flag | pow2(i);\n-    }\n+\n@@ -1142,1 +798,2 @@\n-     * Converts a signature to a string with all class names compacted. Class, Method and Type signatures are supported.\n+     * Converts a signature to a string with all class names compacted.\n+     * Class, Method and Type signatures are supported.\n@@ -1145,1 +802,1 @@\n-     * @param signature signature to convert\n+     * @param  signature signature to convert\n@@ -1148,1 +805,1 @@\n-    public static String signatureToString(final String signature) {\n+    public static String signatureToString( final String signature ) {\n@@ -1152,0 +809,1 @@\n+\n@@ -1153,2 +811,3 @@\n-     * Converts a signature to a string. Class, Method and Type signatures are supported. Enum and Interface signatures are\n-     * not supported.\n+     * Converts a signature to a string.\n+     * Class, Method and Type signatures are supported.\n+     * Enum and Interface signatures are not supported.\n@@ -1156,2 +815,2 @@\n-     * @param signature signature to convert\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature signature to convert\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -1160,1 +819,1 @@\n-    public static String signatureToString(final String signature, final boolean chopit) {\n+    public static String signatureToString( final String signature, final boolean chopit ) {\n@@ -1167,1 +826,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1173,1 +832,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1176,1 +835,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1182,2 +841,2 @@\n-        index += unwrap(CONSUMER_CHARS); \/\/ update position\n-        if (typeParams.isEmpty() && index == signature.length()) {\n+        index += unwrap(consumed_chars); \/\/ update position\n+        if ((typeParams.length() == 0) && (index == signature.length())) {\n@@ -1194,1 +853,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1199,1 +858,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1204,91 +863,0 @@\n-    \/**\n-     * Convert bytes into hexadecimal string\n-     *\n-     * @param bytes an array of bytes to convert to hexadecimal\n-     *\n-     * @return bytes as hexadecimal string, e.g. 00 fa 12 ...\n-     *\/\n-    public static String toHexString(final byte[] bytes) {\n-        final StringBuilder buf = new StringBuilder();\n-        for (int i = 0; i < bytes.length; i++) {\n-            final short b = byteToShort(bytes[i]);\n-            final String hex = Integer.toHexString(b);\n-            if (b < 0x10) {\n-                buf.append('0');\n-            }\n-            buf.append(hex);\n-            if (i < bytes.length - 1) {\n-                buf.append(' ');\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Return type of method signature as a byte value as defined in <em>Constants<\/em>\n-     *\n-     * @param signature in format described above\n-     * @return type of method signature\n-     * @see Const\n-     *\n-     * @throws ClassFormatException if signature is not a method signature\n-     *\/\n-    public static byte typeOfMethodSignature(final String signature) throws ClassFormatException {\n-        int index;\n-        try {\n-            if (signature.charAt(0) != '(') {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            index = signature.lastIndexOf(')') + 1;\n-            return typeOfSignature(signature.substring(index));\n-        } catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n-        }\n-    }\n-\n-    \/**\n-     * Return type of signature as a byte value as defined in <em>Constants<\/em>\n-     *\n-     * @param signature in format described above\n-     * @return type of signature\n-     * @see Const\n-     *\n-     * @throws ClassFormatException if signature isn't a known type\n-     *\/\n-    public static byte typeOfSignature(final String signature) throws ClassFormatException {\n-        try {\n-            switch (signature.charAt(0)) {\n-            case 'B':\n-                return Const.T_BYTE;\n-            case 'C':\n-                return Const.T_CHAR;\n-            case 'D':\n-                return Const.T_DOUBLE;\n-            case 'F':\n-                return Const.T_FLOAT;\n-            case 'I':\n-                return Const.T_INT;\n-            case 'J':\n-                return Const.T_LONG;\n-            case 'L':\n-            case 'T':\n-                return Const.T_REFERENCE;\n-            case '[':\n-                return Const.T_ARRAY;\n-            case 'V':\n-                return Const.T_VOID;\n-            case 'Z':\n-                return Const.T_BOOLEAN;\n-            case 'S':\n-                return Const.T_SHORT;\n-            case '!':\n-            case '+':\n-            case '*':\n-                return typeOfSignature(signature.substring(1));\n-            default:\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n-        }\n-    }\n@@ -1299,2 +867,2 @@\n-     * @param signature signature to convert\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature signature to convert\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -1303,1 +871,1 @@\n-    private static String typeParamTypesToString(final String signature, final boolean chopit) {\n+    private static String typeParamTypesToString( final String signature, final boolean chopit ) {\n@@ -1306,1 +874,1 @@\n-        int index = 1; \/\/ skip the '<'\n+        int index = 1;  \/\/ skip the '<'\n@@ -1309,1 +877,1 @@\n-        index += unwrap(CONSUMER_CHARS); \/\/ update position\n+        index += unwrap(consumed_chars); \/\/ update position\n@@ -1314,1 +882,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1316,1 +884,1 @@\n-        wrap(CONSUMER_CHARS, index + 1); \/\/ account for the '>' char\n+        wrap(consumed_chars, index + 1); \/\/ account for the '>' char\n@@ -1320,0 +888,1 @@\n+\n@@ -1323,2 +892,2 @@\n-     * @param signature signature to convert\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature signature to convert\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -1327,1 +896,1 @@\n-    private static String typeParamTypeToString(final String signature, final boolean chopit) {\n+    private static String typeParamTypeToString( final String signature, final boolean chopit ) {\n@@ -1334,1 +903,1 @@\n-        index++; \/\/ account for the ':'\n+        index++;  \/\/ account for the ':'\n@@ -1339,1 +908,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1343,1 +912,1 @@\n-            index++; \/\/ skip over the ':'\n+            index++;  \/\/ skip over the ':'\n@@ -1346,1 +915,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1348,1 +917,1 @@\n-        wrap(CONSUMER_CHARS, index);\n+        wrap(consumed_chars, index);\n@@ -1352,0 +921,1 @@\n+\n@@ -1355,3 +925,3 @@\n-     * @param signature signature to convert\n-     * @param chopit flag that determines whether chopping is executed or not\n-     * @param term character indicating the end of the list\n+     * @param  signature signature to convert\n+     * @param  chopit flag that determines whether chopping is executed or not\n+     * @param  term character indicating the end of the list\n@@ -1360,1 +930,1 @@\n-    private static String typeSignaturesToString(final String signature, final boolean chopit, final char term) {\n+    private static String typeSignaturesToString( final String signature, final boolean chopit, final char term ) {\n@@ -1363,1 +933,1 @@\n-        int index = 1; \/\/ skip the 'open' character\n+        int index = 1;  \/\/ skip the 'open' character\n@@ -1367,1 +937,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1373,1 +943,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1375,1 +945,1 @@\n-        wrap(CONSUMER_CHARS, index + 1); \/\/ account for the term char\n+        wrap(consumed_chars, index + 1); \/\/ account for the term char\n@@ -1379,0 +949,1 @@\n+\n@@ -1381,2 +952,2 @@\n-     * This method converts a type signature string into a Java type declaration such as 'String[]' and throws a\n-     * 'ClassFormatException' when the parsed type is invalid.\n+     * This method converts a type signature string into a Java type declaration such as\n+     * `String[]' and throws a `ClassFormatException' when the parsed type is invalid.\n@@ -1384,2 +955,2 @@\n-     * @param signature type signature\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature type signature\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -1387,1 +958,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -1390,3 +961,3 @@\n-    public static String typeSignatureToString(final String signature, final boolean chopit) throws ClassFormatException {\n-        \/\/ corrected concurrent private static field acess\n-        wrap(CONSUMER_CHARS, 1); \/\/ This is the default, read just one char like 'B'\n+    public static String typeSignatureToString( final String signature, final boolean chopit ) throws ClassFormatException {\n+        \/\/corrected concurrent private static field acess\n+        wrap(consumed_chars, 1); \/\/ This is the default, read just one char like `B'\n@@ -1395,16 +966,20 @@\n-            case 'B':\n-                return \"byte\";\n-            case 'C':\n-                return \"char\";\n-            case 'D':\n-                return \"double\";\n-            case 'F':\n-                return \"float\";\n-            case 'I':\n-                return \"int\";\n-            case 'J':\n-                return \"long\";\n-            case 'T': { \/\/ TypeVariableSignature\n-                final int index = signature.indexOf(';'); \/\/ Look for closing ';'\n-                if (index < 0) {\n-                    throw new ClassFormatException(\"Invalid type variable signature: \" + signature);\n+                case 'B':\n+                    return \"byte\";\n+                case 'C':\n+                    return \"char\";\n+                case 'D':\n+                    return \"double\";\n+                case 'F':\n+                    return \"float\";\n+                case 'I':\n+                    return \"int\";\n+                case 'J':\n+                    return \"long\";\n+                case 'T': { \/\/ TypeVariableSignature\n+                    final int index = signature.indexOf(';'); \/\/ Look for closing `;'\n+                    if (index < 0) {\n+                        throw new ClassFormatException(\"Invalid type variable signature: \" + signature);\n+                    }\n+                    \/\/corrected concurrent private static field acess\n+                    wrap(consumed_chars, index + 1); \/\/ \"Tblabla;\" `T' and `;' are removed\n+                    return compactClassName(signature.substring(1, index), chopit);\n@@ -1412,12 +987,4 @@\n-                \/\/ corrected concurrent private static field acess\n-                wrap(CONSUMER_CHARS, index + 1); \/\/ \"Tblabla;\" 'T' and ';' are removed\n-                return compactClassName(signature.substring(1, index), chopit);\n-            }\n-            case 'L': { \/\/ Full class name\n-                \/\/ should this be a while loop? can there be more than\n-                \/\/ one generic clause? (markro)\n-                int fromIndex = signature.indexOf('<'); \/\/ generic type?\n-                if (fromIndex < 0) {\n-                    fromIndex = 0;\n-                } else {\n-                    fromIndex = signature.indexOf('>', fromIndex);\n+                case 'L': { \/\/ Full class name\n+                    \/\/ should this be a while loop? can there be more than\n+                    \/\/ one generic clause?  (markro)\n+                    int fromIndex = signature.indexOf('<'); \/\/ generic type?\n@@ -1425,0 +992,9 @@\n+                        fromIndex = 0;\n+                    } else {\n+                        fromIndex = signature.indexOf('>', fromIndex);\n+                        if (fromIndex < 0) {\n+                            throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                        }\n+                    }\n+                    final int index = signature.indexOf(';', fromIndex); \/\/ Look for closing `;'\n+                    if (index < 0) {\n@@ -1427,5 +1003,0 @@\n-                }\n-                final int index = signature.indexOf(';', fromIndex); \/\/ Look for closing ';'\n-                if (index < 0) {\n-                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                }\n@@ -1433,31 +1004,17 @@\n-                \/\/ check to see if there are any TypeArguments\n-                final int bracketIndex = signature.substring(0, index).indexOf('<');\n-                if (bracketIndex < 0) {\n-                    \/\/ just a class identifier\n-                    wrap(CONSUMER_CHARS, index + 1); \/\/ \"Lblabla;\" 'L' and ';' are removed\n-                    return compactClassName(signature.substring(1, index), chopit);\n-                }\n-                \/\/ but make sure we are not looking past the end of the current item\n-                fromIndex = signature.indexOf(';');\n-                if (fromIndex < 0) {\n-                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                }\n-                if (fromIndex < bracketIndex) {\n-                    \/\/ just a class identifier\n-                    wrap(CONSUMER_CHARS, fromIndex + 1); \/\/ \"Lblabla;\" 'L' and ';' are removed\n-                    return compactClassName(signature.substring(1, fromIndex), chopit);\n-                }\n-\n-                \/\/ we have TypeArguments; build up partial result\n-                \/\/ as we recurse for each TypeArgument\n-                final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(\"<\");\n-                int consumedChars = bracketIndex + 1; \/\/ Shadows global var\n-\n-                \/\/ check for wildcards\n-                if (signature.charAt(consumedChars) == '+') {\n-                    type.append(\"? extends \");\n-                    consumedChars++;\n-                } else if (signature.charAt(consumedChars) == '-') {\n-                    type.append(\"? super \");\n-                    consumedChars++;\n-                }\n+                    \/\/ check to see if there are any TypeArguments\n+                    final int bracketIndex = signature.substring(0, index).indexOf('<');\n+                    if (bracketIndex < 0) {\n+                        \/\/ just a class identifier\n+                        wrap(consumed_chars, index + 1); \/\/ \"Lblabla;\" `L' and `;' are removed\n+                        return compactClassName(signature.substring(1, index), chopit);\n+                    }\n+                    \/\/ but make sure we are not looking past the end of the current item\n+                    fromIndex = signature.indexOf(';');\n+                    if (fromIndex < 0) {\n+                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                    }\n+                    if (fromIndex < bracketIndex) {\n+                        \/\/ just a class identifier\n+                        wrap(consumed_chars, fromIndex + 1); \/\/ \"Lblabla;\" `L' and `;' are removed\n+                        return compactClassName(signature.substring(1, fromIndex), chopit);\n+                    }\n@@ -1465,10 +1022,4 @@\n-                \/\/ get the first TypeArgument\n-                if (signature.charAt(consumedChars) == '*') {\n-                    type.append(\"?\");\n-                    consumedChars++;\n-                } else {\n-                    type.append(typeSignatureToString(signature.substring(consumedChars), chopit));\n-                    \/\/ update our consumed count by the number of characters the for type argument\n-                    consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                    wrap(Utility.CONSUMER_CHARS, consumedChars);\n-                }\n+                    \/\/ we have TypeArguments; build up partial result\n+                    \/\/ as we recurse for each TypeArgument\n+                    final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(\"<\");\n+                    int consumed_chars = bracketIndex + 1; \/\/ Shadows global var\n@@ -1476,3 +1027,0 @@\n-                \/\/ are there more TypeArguments?\n-                while (signature.charAt(consumedChars) != '>') {\n-                    type.append(\", \");\n@@ -1480,1 +1028,1 @@\n-                    if (signature.charAt(consumedChars) == '+') {\n+                    if (signature.charAt(consumed_chars) == '+') {\n@@ -1482,2 +1030,2 @@\n-                        consumedChars++;\n-                    } else if (signature.charAt(consumedChars) == '-') {\n+                        consumed_chars++;\n+                    } else if (signature.charAt(consumed_chars) == '-') {\n@@ -1485,1 +1033,1 @@\n-                        consumedChars++;\n+                        consumed_chars++;\n@@ -1487,1 +1035,3 @@\n-                    if (signature.charAt(consumedChars) == '*') {\n+\n+                    \/\/ get the first TypeArgument\n+                    if (signature.charAt(consumed_chars) == '*') {\n@@ -1489,1 +1039,1 @@\n-                        consumedChars++;\n+                        consumed_chars++;\n@@ -1491,1 +1041,1 @@\n-                        type.append(typeSignatureToString(signature.substring(consumedChars), chopit));\n+                        type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));\n@@ -1493,2 +1043,24 @@\n-                        consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                        wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                        consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n+                        wrap(Utility.consumed_chars, consumed_chars);\n+                    }\n+\n+                    \/\/ are there more TypeArguments?\n+                    while (signature.charAt(consumed_chars) != '>') {\n+                        type.append(\", \");\n+                        \/\/ check for wildcards\n+                        if (signature.charAt(consumed_chars) == '+') {\n+                            type.append(\"? extends \");\n+                            consumed_chars++;\n+                        } else if (signature.charAt(consumed_chars) == '-') {\n+                            type.append(\"? super \");\n+                            consumed_chars++;\n+                        }\n+                        if (signature.charAt(consumed_chars) == '*') {\n+                            type.append(\"?\");\n+                            consumed_chars++;\n+                        } else {\n+                            type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));\n+                            \/\/ update our consumed count by the number of characters the for type argument\n+                            consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n+                            wrap(Utility.consumed_chars, consumed_chars);\n+                        }\n@@ -1496,1 +1068,0 @@\n-                }\n@@ -1498,15 +1069,21 @@\n-                \/\/ process the closing \">\"\n-                consumedChars++;\n-                type.append(\">\");\n-\n-                if (signature.charAt(consumedChars) == '.') {\n-                    \/\/ we have a ClassTypeSignatureSuffix\n-                    type.append(\".\");\n-                    \/\/ convert SimpleClassTypeSignature to fake ClassTypeSignature\n-                    \/\/ and then recurse to parse it\n-                    type.append(typeSignatureToString(\"L\" + signature.substring(consumedChars + 1), chopit));\n-                    \/\/ update our consumed count by the number of characters the for type argument\n-                    \/\/ note that this count includes the \"L\" we added, but that is ok\n-                    \/\/ as it accounts for the \".\" we didn't consume\n-                    consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                    wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                    \/\/ process the closing \">\"\n+                    consumed_chars++;\n+                    type.append(\">\");\n+\n+                    if (signature.charAt(consumed_chars) == '.') {\n+                        \/\/ we have a ClassTypeSignatureSuffix\n+                        type.append(\".\");\n+                        \/\/ convert SimpleClassTypeSignature to fake ClassTypeSignature\n+                        \/\/ and then recurse to parse it\n+                        type.append(typeSignatureToString(\"L\" + signature.substring(consumed_chars+1), chopit));\n+                        \/\/ update our consumed count by the number of characters the for type argument\n+                        \/\/ note that this count includes the \"L\" we added, but that is ok\n+                        \/\/ as it accounts for the \".\" we didn't consume\n+                        consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n+                        wrap(Utility.consumed_chars, consumed_chars);\n+                        return type.toString();\n+                    }\n+                    if (signature.charAt(consumed_chars) != ';') {\n+                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                    }\n+                    wrap(Utility.consumed_chars, consumed_chars + 1); \/\/ remove final \";\"\n@@ -1515,2 +1092,22 @@\n-                if (signature.charAt(consumedChars) != ';') {\n-                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                case 'S':\n+                    return \"short\";\n+                case 'Z':\n+                    return \"boolean\";\n+                case '[': { \/\/ Array declaration\n+                    int n;\n+                    StringBuilder brackets;\n+                    String type;\n+                    int consumed_chars; \/\/ Shadows global var\n+                    brackets = new StringBuilder(); \/\/ Accumulate []'s\n+                    \/\/ Count opening brackets and look for optional size argument\n+                    for (n = 0; signature.charAt(n) == '['; n++) {\n+                        brackets.append(\"[]\");\n+                    }\n+                    consumed_chars = n; \/\/ Remember value\n+                    \/\/ The rest of the string denotes a `<field_type>'\n+                    type = typeSignatureToString(signature.substring(n), chopit);\n+                    \/\/corrected concurrent private static field acess\n+                    \/\/Utility.consumed_chars += consumed_chars; is replaced by:\n+                    final int _temp = unwrap(Utility.consumed_chars) + consumed_chars;\n+                    wrap(Utility.consumed_chars, _temp);\n+                    return type + brackets.toString();\n@@ -1518,2 +1115,4 @@\n-                wrap(Utility.CONSUMER_CHARS, consumedChars + 1); \/\/ remove final \";\"\n-                return type.toString();\n+                case 'V':\n+                    return \"void\";\n+                default:\n+                    throw new ClassFormatException(\"Invalid signature: `\" + signature + \"'\");\n@@ -1521,13 +1120,440 @@\n-            case 'S':\n-                return \"short\";\n-            case 'Z':\n-                return \"boolean\";\n-            case '[': { \/\/ Array declaration\n-                int n;\n-                StringBuilder brackets;\n-                String type;\n-                int consumedChars; \/\/ Shadows global var\n-                brackets = new StringBuilder(); \/\/ Accumulate []'s\n-                \/\/ Count opening brackets and look for optional size argument\n-                for (n = 0; signature.charAt(n) == '['; n++) {\n-                    brackets.append(\"[]\");\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid signature: \" + signature, e);\n+        }\n+    }\n+\n+\n+    \/** Parse Java type such as \"char\", or \"java.lang.String[]\" and return the\n+     * signature in byte code format, e.g. \"C\" or \"[Ljava\/lang\/String;\" respectively.\n+     *\n+     * @param  type Java type\n+     * @return byte code signature\n+     *\/\n+    public static String getSignature( String type ) {\n+        final StringBuilder buf = new StringBuilder();\n+        final char[] chars = type.toCharArray();\n+        boolean char_found = false;\n+        boolean delim = false;\n+        int index = -1;\n+        loop: for (int i = 0; i < chars.length; i++) {\n+            switch (chars[i]) {\n+                case ' ':\n+                case '\\t':\n+                case '\\n':\n+                case '\\r':\n+                case '\\f':\n+                    if (char_found) {\n+                        delim = true;\n+                    }\n+                    break;\n+                case '[':\n+                    if (!char_found) {\n+                        throw new IllegalArgumentException(\"Illegal type: \" + type);\n+                    }\n+                    index = i;\n+                    break loop;\n+                default:\n+                    char_found = true;\n+                    if (!delim) {\n+                        buf.append(chars[i]);\n+                    }\n+            }\n+        }\n+        int brackets = 0;\n+        if (index > 0) {\n+            brackets = countBrackets(type.substring(index));\n+        }\n+        type = buf.toString();\n+        buf.setLength(0);\n+        for (int i = 0; i < brackets; i++) {\n+            buf.append('[');\n+        }\n+        boolean found = false;\n+        for (int i = Const.T_BOOLEAN; (i <= Const.T_VOID) && !found; i++) {\n+            if (Const.getTypeName(i).equals(type)) {\n+                found = true;\n+                buf.append(Const.getShortTypeName(i));\n+            }\n+        }\n+        if (!found) {\n+            buf.append('L').append(type.replace('.', '\/')).append(';');\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    private static int countBrackets( final String brackets ) {\n+        final char[] chars = brackets.toCharArray();\n+        int count = 0;\n+        boolean open = false;\n+        for (final char c : chars) {\n+            switch (c) {\n+                case '[':\n+                    if (open) {\n+                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+                    }\n+                    open = true;\n+                    break;\n+                case ']':\n+                    if (!open) {\n+                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+                    }\n+                    open = false;\n+                    count++;\n+                    break;\n+                default:\n+                    \/\/ Don't care\n+                    break;\n+            }\n+        }\n+        if (open) {\n+            throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+        }\n+        return count;\n+    }\n+\n+\n+    \/**\n+     * Return type of method signature as a byte value as defined in <em>Constants<\/em>\n+     *\n+     * @param  signature in format described above\n+     * @return type of method signature\n+     * @see    Const\n+     *\n+     * @throws ClassFormatException if signature is not a method signature\n+     *\/\n+    public static byte typeOfMethodSignature( final String signature ) throws ClassFormatException {\n+        int index;\n+        try {\n+            if (signature.charAt(0) != '(') {\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+            index = signature.lastIndexOf(')') + 1;\n+            return typeOfSignature(signature.substring(index));\n+        } catch (final StringIndexOutOfBoundsException e) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Return type of signature as a byte value as defined in <em>Constants<\/em>\n+     *\n+     * @param  signature in format described above\n+     * @return type of signature\n+     * @see    Const\n+     *\n+     * @throws ClassFormatException if signature isn't a known type\n+     *\/\n+    public static byte typeOfSignature( final String signature ) throws ClassFormatException {\n+        try {\n+            switch (signature.charAt(0)) {\n+                case 'B':\n+                    return Const.T_BYTE;\n+                case 'C':\n+                    return Const.T_CHAR;\n+                case 'D':\n+                    return Const.T_DOUBLE;\n+                case 'F':\n+                    return Const.T_FLOAT;\n+                case 'I':\n+                    return Const.T_INT;\n+                case 'J':\n+                    return Const.T_LONG;\n+                case 'L':\n+                case 'T':\n+                    return Const.T_REFERENCE;\n+                case '[':\n+                    return Const.T_ARRAY;\n+                case 'V':\n+                    return Const.T_VOID;\n+                case 'Z':\n+                    return Const.T_BOOLEAN;\n+                case 'S':\n+                    return Const.T_SHORT;\n+                case '!':\n+                case '+':\n+                case '*':\n+                    return typeOfSignature(signature.substring(1));\n+                default:\n+                    throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+        }\n+    }\n+\n+\n+    \/** Map opcode names to opcode numbers. E.g., return Constants.ALOAD for \"aload\"\n+     *\/\n+    public static short searchOpcode( String name ) {\n+        name = name.toLowerCase(Locale.ENGLISH);\n+        for (short i = 0; i < Const.OPCODE_NAMES_LENGTH; i++) {\n+            if (Const.getOpcodeName(i).equals(name)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+\n+    \/**\n+     * Convert (signed) byte to (unsigned) short value, i.e., all negative\n+     * values become positive.\n+     *\/\n+    private static short byteToShort( final byte b ) {\n+        return (b < 0) ? (short) (256 + b) : (short) b;\n+    }\n+\n+\n+    \/** Convert bytes into hexadecimal string\n+     *\n+     * @param bytes an array of bytes to convert to hexadecimal\n+     *\n+     * @return bytes as hexadecimal string, e.g. 00 fa 12 ...\n+     *\/\n+    public static String toHexString( final byte[] bytes ) {\n+        final StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < bytes.length; i++) {\n+            final short b = byteToShort(bytes[i]);\n+            final String hex = Integer.toHexString(b);\n+            if (b < 0x10) {\n+                buf.append('0');\n+            }\n+            buf.append(hex);\n+            if (i < bytes.length - 1) {\n+                buf.append(' ');\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    \/**\n+     * Return a string for an integer justified left or right and filled up with\n+     * `fill' characters if necessary.\n+     *\n+     * @param i integer to format\n+     * @param length length of desired string\n+     * @param left_justify format left or right\n+     * @param fill fill character\n+     * @return formatted int\n+     *\/\n+    public static String format( final int i, final int length, final boolean left_justify, final char fill ) {\n+        return fillup(Integer.toString(i), length, left_justify, fill);\n+    }\n+\n+\n+    \/**\n+     * Fillup char with up to length characters with char `fill' and justify it left or right.\n+     *\n+     * @param str string to format\n+     * @param length length of desired string\n+     * @param left_justify format left or right\n+     * @param fill fill character\n+     * @return formatted string\n+     *\/\n+    public static String fillup( final String str, final int length, final boolean left_justify, final char fill ) {\n+        final int len = length - str.length();\n+        final char[] buf = new char[(len < 0) ? 0 : len];\n+        for (int j = 0; j < buf.length; j++) {\n+            buf[j] = fill;\n+        }\n+        if (left_justify) {\n+            return str + new String(buf);\n+        }\n+        return new String(buf) + str;\n+    }\n+\n+\n+    static boolean equals( final byte[] a, final byte[] b ) {\n+        int size;\n+        if ((size = a.length) != b.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < size; i++) {\n+            if (a[i] != b[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    public static void printArray( final PrintStream out, final Object[] obj ) {\n+        out.println(printArray(obj, true));\n+    }\n+\n+\n+    public static void printArray( final PrintWriter out, final Object[] obj ) {\n+        out.println(printArray(obj, true));\n+    }\n+\n+\n+    public static String printArray( final Object[] obj ) {\n+        return printArray(obj, true);\n+    }\n+\n+\n+    public static String printArray( final Object[] obj, final boolean braces ) {\n+        return printArray(obj, braces, false);\n+    }\n+\n+\n+    public static String printArray( final Object[] obj, final boolean braces, final boolean quote ) {\n+        if (obj == null) {\n+            return null;\n+        }\n+        final StringBuilder buf = new StringBuilder();\n+        if (braces) {\n+            buf.append('{');\n+        }\n+        for (int i = 0; i < obj.length; i++) {\n+            if (obj[i] != null) {\n+                buf.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n+            } else {\n+                buf.append(\"null\");\n+            }\n+            if (i < obj.length - 1) {\n+                buf.append(\", \");\n+            }\n+        }\n+        if (braces) {\n+            buf.append('}');\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    \/**\n+     * @param ch the character to test if it's part of an identifier\n+     *\n+     * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)\n+     *\/\n+    public static boolean isJavaIdentifierPart( final char ch ) {\n+        return ((ch >= 'a') && (ch <= 'z')) || ((ch >= 'A') && (ch <= 'Z'))\n+                || ((ch >= '0') && (ch <= '9')) || (ch == '_');\n+    }\n+\n+\n+    \/**\n+     * Encode byte array it into Java identifier string, i.e., a string\n+     * that only contains the following characters: (a, ... z, A, ... Z,\n+     * 0, ... 9, _, $).  The encoding algorithm itself is not too\n+     * clever: if the current byte's ASCII value already is a valid Java\n+     * identifier part, leave it as it is. Otherwise it writes the\n+     * escape character($) followed by:\n+     *\n+     * <ul>\n+     *   <li> the ASCII value as a hexadecimal string, if the value is not in the range 200..247<\/li>\n+     *   <li>a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247<\/li>\n+     * <\/ul>\n+     *\n+     * <p>This operation inflates the original byte array by roughly 40-50%<\/p>\n+     *\n+     * @param bytes the byte array to convert\n+     * @param compress use gzip to minimize string\n+     *\n+     * @throws IOException if there's a gzip exception\n+     *\/\n+    public static String encode(byte[] bytes, final boolean compress) throws IOException {\n+        if (compress) {\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                    GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n+                gos.write(bytes, 0, bytes.length);\n+                gos.finish();\n+                bytes = baos.toByteArray();\n+            }\n+        }\n+        final CharArrayWriter caw = new CharArrayWriter();\n+        try (JavaWriter jw = new JavaWriter(caw)) {\n+            for (final byte b : bytes) {\n+                final int in = b & 0x000000ff; \/\/ Normalize to unsigned\n+                jw.write(in);\n+            }\n+        }\n+        return caw.toString();\n+    }\n+\n+\n+    \/**\n+     * Decode a string back to a byte array.\n+     *\n+     * @param s the string to convert\n+     * @param uncompress use gzip to uncompress the stream of bytes\n+     *\n+     * @throws IOException if there's a gzip exception\n+     *\/\n+    public static byte[] decode(final String s, final boolean uncompress) throws IOException {\n+        byte[] bytes;\n+        try (JavaReader jr = new JavaReader(new CharArrayReader(s.toCharArray()));\n+                ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n+            int ch;\n+            while ((ch = jr.read()) >= 0) {\n+                bos.write(ch);\n+            }\n+            bytes = bos.toByteArray();\n+        }\n+        if (uncompress) {\n+            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n+            final byte[] tmp = new byte[bytes.length * 3]; \/\/ Rough estimate\n+            int count = 0;\n+            int b;\n+            while ((b = gis.read()) >= 0) {\n+                tmp[count++] = (byte) b;\n+            }\n+            bytes = new byte[count];\n+            System.arraycopy(tmp, 0, bytes, 0, count);\n+        }\n+        return bytes;\n+    }\n+\n+    \/\/ A-Z, g-z, _, $\n+    private static final int FREE_CHARS = 48;\n+    private static int[] CHAR_MAP = new int[FREE_CHARS];\n+    private static int[] MAP_CHAR = new int[256]; \/\/ Reverse map\n+    private static final char ESCAPE_CHAR = '$';\n+    static {\n+        int j = 0;\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            CHAR_MAP[j] = i;\n+            MAP_CHAR[i] = j;\n+            j++;\n+        }\n+        for (int i = 'g'; i <= 'z'; i++) {\n+            CHAR_MAP[j] = i;\n+            MAP_CHAR[i] = j;\n+            j++;\n+        }\n+        CHAR_MAP[j] = '$';\n+        MAP_CHAR['$'] = j;\n+        j++;\n+        CHAR_MAP[j] = '_';\n+        MAP_CHAR['_'] = j;\n+    }\n+\n+    \/**\n+     * Decode characters into bytes.\n+     * Used by <a href=\"Utility.html#decode(java.lang.String, boolean)\">decode()<\/a>\n+     *\/\n+    private static class JavaReader extends FilterReader {\n+\n+        public JavaReader(final Reader in) {\n+            super(in);\n+        }\n+\n+\n+        @Override\n+        public int read() throws IOException {\n+            final int b = in.read();\n+            if (b != ESCAPE_CHAR) {\n+                return b;\n+            }\n+            final int i = in.read();\n+            if (i < 0) {\n+                return -1;\n+            }\n+            if (((i >= '0') && (i <= '9')) || ((i >= 'a') && (i <= 'f'))) { \/\/ Normal escape\n+                final int j = in.read();\n+                if (j < 0) {\n+                    return -1;\n@@ -1535,8 +1561,5 @@\n-                consumedChars = n; \/\/ Remember value\n-                \/\/ The rest of the string denotes a '<field_type>'\n-                type = typeSignatureToString(signature.substring(n), chopit);\n-                \/\/ corrected concurrent private static field acess\n-                \/\/ Utility.consumed_chars += consumed_chars; is replaced by:\n-                final int temp = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                wrap(Utility.CONSUMER_CHARS, temp);\n-                return type + brackets.toString();\n+                final char[] tmp = {\n+                        (char) i, (char) j\n+                };\n+                final int s = Integer.parseInt(new String(tmp), 16);\n+                return s;\n@@ -1544,4 +1567,8 @@\n-            case 'V':\n-                return \"void\";\n-            default:\n-                throw new ClassFormatException(\"Invalid signature: '\" + signature + \"'\");\n+            return MAP_CHAR[i];\n+        }\n+\n+\n+        @Override\n+        public int read( final char[] cbuf, final int off, final int len ) throws IOException {\n+            for (int i = 0; i < len; i++) {\n+                cbuf[off + i] = (char) read();\n@@ -1549,2 +1576,1 @@\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid signature: \" + signature, e);\n+            return len;\n@@ -1554,2 +1580,46 @@\n-    private static int unwrap(final ThreadLocal<Integer> tl) {\n-        return tl.get();\n+    \/**\n+     * Encode bytes into valid java identifier characters.\n+     * Used by <a href=\"Utility.html#encode(byte[], boolean)\">encode()<\/a>\n+     *\/\n+    private static class JavaWriter extends FilterWriter {\n+\n+        public JavaWriter(final Writer out) {\n+            super(out);\n+        }\n+\n+\n+        @Override\n+        public void write( final int b ) throws IOException {\n+            if (isJavaIdentifierPart((char) b) && (b != ESCAPE_CHAR)) {\n+                out.write(b);\n+            } else {\n+                out.write(ESCAPE_CHAR); \/\/ Escape character\n+                \/\/ Special escape\n+                if (b >= 0 && b < FREE_CHARS) {\n+                    out.write(CHAR_MAP[b]);\n+                } else { \/\/ Normal escape\n+                    final char[] tmp = Integer.toHexString(b).toCharArray();\n+                    if (tmp.length == 1) {\n+                        out.write('0');\n+                        out.write(tmp[0]);\n+                    } else {\n+                        out.write(tmp[0]);\n+                        out.write(tmp[1]);\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+        @Override\n+        public void write( final char[] cbuf, final int off, final int len ) throws IOException {\n+            for (int i = 0; i < len; i++) {\n+                write(cbuf[off + i]);\n+            }\n+        }\n+\n+\n+        @Override\n+        public void write( final String str, final int off, final int len ) throws IOException {\n+            write(str.toCharArray(), off, len);\n+        }\n@@ -1558,2 +1628,30 @@\n-    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n-        tl.set(value);\n+\n+    \/**\n+     * Escape all occurences of newline chars '\\n', quotes \\\", etc.\n+     *\/\n+    public static String convertString( final String label ) {\n+        final char[] ch = label.toCharArray();\n+        final StringBuilder buf = new StringBuilder();\n+        for (final char element : ch) {\n+            switch (element) {\n+                case '\\n':\n+                    buf.append(\"\\\\n\");\n+                    break;\n+                case '\\r':\n+                    buf.append(\"\\\\r\");\n+                    break;\n+                case '\\\"':\n+                    buf.append(\"\\\\\\\"\");\n+                    break;\n+                case '\\'':\n+                    buf.append(\"\\\\'\");\n+                    break;\n+                case '\\\\':\n+                    buf.append(\"\\\\\\\\\");\n+                    break;\n+                default:\n+                    buf.append(element);\n+                    break;\n+            }\n+        }\n+        return buf.toString();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Utility.java","additions":1189,"deletions":1091,"binary":false,"changes":2280,"status":"modified"},{"patch":"@@ -25,2 +25,4 @@\n- * Interface to make use of the Visitor pattern programming style. I.e. a class that implements this interface can\n- * traverse the contents of a Java class just by calling the 'accept' method which all classes have.\n+ * Interface to make use of the Visitor pattern programming style. I.e. a class\n+ * that implements this interface can traverse the contents of a Java class just\n+ * by calling the `accept' method which all classes have.\n+ *\n@@ -28,21 +30,2 @@\n-public interface Visitor {\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotation(Annotations obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotationDefault(AnnotationDefault obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotationEntry(AnnotationEntry obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitBootstrapMethods(BootstrapMethods obj);\n-\n+public interface Visitor\n+{\n@@ -57,7 +40,0 @@\n-    \/**\n-     * @since 6.3\n-     *\/\n-    default void visitConstantDynamic(final ConstantDynamic constantDynamic) {\n-        \/\/ empty\n-    }\n-\n@@ -76,5 +52,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitConstantMethodHandle(ConstantMethodHandle obj);\n-\n@@ -83,10 +54,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitConstantMethodType(ConstantMethodType obj);\n-\n-    \/**\n-     * @since 6.1\n-     *\/\n-    void visitConstantModule(ConstantModule constantModule);\n-\n@@ -95,5 +56,0 @@\n-    \/**\n-     * @since 6.1\n-     *\/\n-    void visitConstantPackage(ConstantPackage constantPackage);\n-\n@@ -110,5 +66,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitEnclosingMethod(EnclosingMethod obj);\n-\n@@ -133,0 +84,34 @@\n+    void visitMethod(Method obj);\n+\n+    void visitSignature(Signature obj);\n+\n+    void visitSourceFile(SourceFile obj);\n+\n+    void visitSynthetic(Synthetic obj);\n+\n+    void visitUnknown(Unknown obj);\n+\n+    void visitStackMap(StackMap obj);\n+\n+    void visitStackMapEntry(StackMapEntry obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotation(Annotations obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitParameterAnnotation(ParameterAnnotations obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotationEntry(AnnotationEntry obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotationDefault(AnnotationDefault obj);\n+\n@@ -138,1 +123,14 @@\n-    void visitMethod(Method obj);\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitEnclosingMethod(EnclosingMethod obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitBootstrapMethods(BootstrapMethods obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitMethodParameters(MethodParameters obj);\n@@ -150,1 +148,28 @@\n-    void visitMethodParameters(MethodParameters obj);\n+    void visitConstantMethodType(ConstantMethodType obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitConstantMethodHandle(ConstantMethodHandle obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitParameterAnnotationEntry(ParameterAnnotationEntry obj);\n+\n+    \/**\n+     * @since 6.1\n+     *\/\n+    void visitConstantPackage(ConstantPackage constantPackage);\n+\n+    \/**\n+     * @since 6.1\n+     *\/\n+    void visitConstantModule(ConstantModule constantModule);\n+\n+    \/**\n+     * @since 6.3\n+     *\/\n+    default void visitConstantDynamic(final ConstantDynamic constantDynamic) {\n+        \/\/ empty\n+    }\n@@ -162,1 +187,1 @@\n-    default void visitModuleExports(final ModuleExports constantModule) {\n+    default void visitModuleRequires(final ModuleRequires constantModule) {\n@@ -169,1 +194,1 @@\n-    default void visitModuleMainClass(final ModuleMainClass obj) {\n+    default void visitModuleExports(final ModuleExports constantModule) {\n@@ -183,1 +208,1 @@\n-    default void visitModulePackages(final ModulePackages constantModule) {\n+    default void visitModuleProvides(final ModuleProvides constantModule) {\n@@ -190,1 +215,1 @@\n-    default void visitModuleProvides(final ModuleProvides constantModule) {\n+    default void visitModulePackages(final ModulePackages constantModule) {\n@@ -197,1 +222,1 @@\n-    default void visitModuleRequires(final ModuleRequires constantModule) {\n+    default void visitModuleMainClass(final ModuleMainClass obj) {\n@@ -214,22 +239,0 @@\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitParameterAnnotation(ParameterAnnotations obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitParameterAnnotationEntry(ParameterAnnotationEntry obj);\n-\n-    void visitSignature(Signature obj);\n-\n-    void visitSourceFile(SourceFile obj);\n-\n-    void visitStackMap(StackMap obj);\n-\n-    void visitStackMapEntry(StackMapEntry obj);\n-\n-    void visitSynthetic(Synthetic obj);\n-\n-    void visitUnknown(Unknown obj);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Visitor.java","additions":87,"deletions":84,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; value\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load reference from array\n+    \/** Load reference from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * AASTORE - Store into reference array\n+ * AASTORE -  Store into reference array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store into reference array\n+    \/** Store into reference array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ... -&gt; ..., null<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., null\n- * <\/PRE>\n@@ -40,0 +38,9 @@\n+\n+    \/** @return Type.NULL\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.NULL;\n+    }\n+\n+\n@@ -41,2 +48,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +56,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -53,8 +62,0 @@\n-\n-    \/**\n-     * @return Type.NULL\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.NULL;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ACONST_NULL.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -23,0 +23,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -25,0 +27,1 @@\n+ * <PRE>Stack: ... -&gt; ..., objectref<\/PRE>\n@@ -26,3 +29,0 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., objectref\n- * <\/PRE>\n@@ -34,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,1 +38,1 @@\n-        super(com.sun.org.apache.bcel.internal.Const.ALOAD, com.sun.org.apache.bcel.internal.Const.ALOAD_0);\n+        super(Const.ALOAD, Const.ALOAD_0);\n@@ -40,3 +41,2 @@\n-    \/**\n-     * Load reference from local variable\n-     *\n+\n+    \/** Load reference from local variable\n@@ -46,1 +46,1 @@\n-        super(com.sun.org.apache.bcel.internal.Const.ALOAD, com.sun.org.apache.bcel.internal.Const.ALOAD_0, n);\n+        super(Const.ALOAD, Const.ALOAD_0, n);\n@@ -49,0 +49,1 @@\n+\n@@ -50,2 +51,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +59,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ALOAD.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * ANEWARRAY - Create new array of references\n+ * ANEWARRAY -  Create new array of references\n+ * <PRE>Stack: ..., count -&gt; ..., arrayref<\/PRE>\n@@ -29,3 +30,0 @@\n- * <PRE>\n- * Stack: ..., count -&gt; ..., arrayref\n- * <\/PRE>\n@@ -33,1 +31,2 @@\n-public class ANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower, StackConsumer, StackProducer {\n+public class ANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction,\n+        ExceptionThrower, StackConsumer, StackProducer {\n@@ -36,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -41,0 +41,1 @@\n+\n@@ -45,0 +46,8 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+            ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION);\n+    }\n+\n+\n@@ -46,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -52,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -62,4 +73,0 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION);\n-    }\n@@ -68,1 +75,1 @@\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n@@ -73,1 +80,1 @@\n-        return t instanceof ObjectType ? (ObjectType) t : null;\n+        return (t instanceof ObjectType) ? (ObjectType) t : null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ANEWARRAY.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * ARETURN - Return reference from method\n+ * ARETURN -  Return reference from method\n+ * <PRE>Stack: ..., objectref -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -40,0 +38,1 @@\n+\n@@ -41,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ARETURN.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * ARRAYLENGTH - Get length of array\n+ * ARRAYLENGTH -  Get length of array\n+ * <PRE>Stack: ..., arrayref -&gt; ..., length<\/PRE>\n@@ -28,4 +29,1 @@\n- * <PRE>\n- * Stack: ..., arrayref -&gt; ..., length\n- * <\/PRE>\n- * @LastModified: Feb 2023\n+ * @LastModified: Jun 2019\n@@ -33,1 +31,2 @@\n-public class ARRAYLENGTH extends Instruction implements ExceptionThrower, StackProducer, StackConsumer \/* since 6.0 *\/ {\n+public class ARRAYLENGTH extends Instruction\n+    implements ExceptionThrower, StackProducer, StackConsumer \/* since 6.0 *\/ {\n@@ -35,2 +34,1 @@\n-    \/**\n-     * Get length of array\n+    \/** Get length of array\n@@ -42,0 +40,11 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.NULL_POINTER_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -43,2 +52,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +60,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -54,8 +65,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ARRAYLENGTH.java","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -22,0 +22,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -24,0 +26,1 @@\n+ * <PRE>Stack ..., objectref -&gt; ... <\/PRE>\n@@ -25,3 +28,0 @@\n- * <PRE>\n- * Stack ..., objectref -&gt; ...\n- * <\/PRE>\n@@ -33,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -36,1 +37,1 @@\n-        super(com.sun.org.apache.bcel.internal.Const.ASTORE, com.sun.org.apache.bcel.internal.Const.ASTORE_0);\n+        super(Const.ASTORE, Const.ASTORE_0);\n@@ -39,3 +40,2 @@\n-    \/**\n-     * Store reference into local variable\n-     *\n+\n+    \/** Store reference into local variable\n@@ -45,1 +45,1 @@\n-        super(com.sun.org.apache.bcel.internal.Const.ASTORE, com.sun.org.apache.bcel.internal.Const.ASTORE_0, n);\n+        super(Const.ASTORE, Const.ASTORE_0, n);\n@@ -48,0 +48,1 @@\n+\n@@ -49,2 +50,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -55,1 +58,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ASTORE.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * ATHROW - Throw exception\n+ * ATHROW -  Throw exception\n+ * <PRE>Stack: ..., objectref -&gt; objectref<\/PRE>\n@@ -28,3 +29,1 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; objectref\n- * <\/PRE>\n+ * @LastModified: Jan 2020\n@@ -35,1 +34,1 @@\n-     * Throw exception\n+     *  Throw exception\n@@ -41,0 +40,11 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.THROWABLE\n+        };\n+    }\n+\n+\n@@ -42,2 +52,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +60,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -53,8 +65,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.THROWABLE};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ATHROW.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AllocationInstruction.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-public class AnnotationElementValueGen extends ElementValueGen {\n+public class AnnotationElementValueGen extends ElementValueGen\n+{\n@@ -37,6 +38,2 @@\n-    public AnnotationElementValueGen(final AnnotationElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        super(ANNOTATION, cpool);\n-        a = new AnnotationEntryGen(value.getAnnotationEntry(), cpool, copyPoolEntries);\n-    }\n-\n-    public AnnotationElementValueGen(final AnnotationEntryGen a, final ConstantPoolGen cpool) {\n+    public AnnotationElementValueGen(final AnnotationEntryGen a, final ConstantPoolGen cpool)\n+    {\n@@ -47,1 +44,3 @@\n-    public AnnotationElementValueGen(final int type, final AnnotationEntryGen annotation, final ConstantPoolGen cpool) {\n+    public AnnotationElementValueGen(final int type, final AnnotationEntryGen annotation,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -50,1 +49,2 @@\n-            throw new IllegalArgumentException(\"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n@@ -55,0 +55,7 @@\n+    public AnnotationElementValueGen(final AnnotationElementValue value,\n+            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n+    {\n+        super(ANNOTATION, cpool);\n+        a = new AnnotationEntryGen(value.getAnnotationEntry(), cpool, copyPoolEntries);\n+    }\n+\n@@ -56,1 +63,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -61,2 +69,4 @@\n-    public AnnotationEntryGen getAnnotation() {\n-        return a;\n+    @Override\n+    public String stringifyValue()\n+    {\n+        throw new UnsupportedOperationException(\"Not implemented yet\");\n@@ -69,2 +79,5 @@\n-    public ElementValue getElementValue() {\n-        return new AnnotationElementValue(super.getElementValueType(), a.getAnnotation(), getConstantPool().getConstantPool());\n+    public ElementValue getElementValue()\n+    {\n+        return new AnnotationElementValue(super.getElementValueType(),\n+                a.getAnnotation(),\n+                getConstantPool().getConstantPool());\n@@ -73,3 +86,3 @@\n-    @Override\n-    public String stringifyValue() {\n-        throw new UnsupportedOperationException(\"Not implemented yet\");\n+    public AnnotationEntryGen getAnnotation()\n+    {\n+        return a;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AnnotationElementValueGen.java","additions":30,"deletions":17,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -46,0 +46,90 @@\n+    private int typeIndex;\n+\n+    private List<ElementValuePairGen> evs;\n+\n+    private final ConstantPoolGen cpool;\n+\n+    private boolean isRuntimeVisible = false;\n+\n+    \/**\n+     * Here we are taking a fixed annotation of type Annotation and building a\n+     * modifiable AnnotationGen object. If the pool passed in is for a different\n+     * class file, then copyPoolEntries should have been passed as true as that\n+     * will force us to do a deep copy of the annotation and move the cpool\n+     * entries across. We need to copy the type and the element name value pairs\n+     * and the visibility.\n+     *\/\n+    public AnnotationEntryGen(final AnnotationEntry a, final ConstantPoolGen cpool,\n+                              final boolean copyPoolEntries) {\n+        this.cpool = cpool;\n+        if (copyPoolEntries) {\n+            typeIndex = cpool.addUtf8(a.getAnnotationType());\n+        } else {\n+            typeIndex = a.getAnnotationTypeIndex();\n+        }\n+        isRuntimeVisible = a.isRuntimeVisible();\n+        evs = copyValues(a.getElementValuePairs(), cpool, copyPoolEntries);\n+    }\n+\n+    private List<ElementValuePairGen> copyValues(final ElementValuePair[] in, final ConstantPoolGen cpool,\n+                                                 final boolean copyPoolEntries) {\n+        final List<ElementValuePairGen> out = new ArrayList<>();\n+        for (final ElementValuePair nvp : in) {\n+            out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));\n+        }\n+        return out;\n+    }\n+\n+    private AnnotationEntryGen(final ConstantPoolGen cpool) {\n+        this.cpool = cpool;\n+    }\n+\n+    \/**\n+     * Retrieve an immutable version of this AnnotationGen\n+     *\/\n+    public AnnotationEntry getAnnotation() {\n+        final AnnotationEntry a = new AnnotationEntry(typeIndex, cpool.getConstantPool(),\n+                isRuntimeVisible);\n+        for (final ElementValuePairGen element : evs) {\n+            a.addElementNameValuePair(element.getElementNameValuePair());\n+        }\n+        return a;\n+    }\n+\n+    public AnnotationEntryGen(final ObjectType type,\n+                              final List<ElementValuePairGen> elements, final boolean vis,\n+                              final ConstantPoolGen cpool) {\n+        this.cpool = cpool;\n+        this.typeIndex = cpool.addUtf8(type.getSignature());\n+        evs = elements;\n+        isRuntimeVisible = vis;\n+    }\n+\n+    public static AnnotationEntryGen read(final DataInput dis,\n+                                          final ConstantPoolGen cpool, final boolean b) throws IOException {\n+        final AnnotationEntryGen a = new AnnotationEntryGen(cpool);\n+        a.typeIndex = dis.readUnsignedShort();\n+        final int elemValuePairCount = dis.readUnsignedShort();\n+        for (int i = 0; i < elemValuePairCount; i++) {\n+            final int nidx = dis.readUnsignedShort();\n+            a.addElementNameValuePair(new ElementValuePairGen(nidx,\n+                    ElementValueGen.readElementValue(dis, cpool), cpool));\n+        }\n+        a.isRuntimeVisible(b);\n+        return a;\n+    }\n+\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n+        dos.writeShort(evs.size()); \/\/ u2 element_value pair count\n+        for (final ElementValuePairGen envp : evs) {\n+            envp.dump(dos);\n+        }\n+    }\n+\n+    public void addElementNameValuePair(final ElementValuePairGen evp) {\n+        if (evs == null) {\n+            evs = new ArrayList<>();\n+        }\n+        evs.add(evp);\n+    }\n@@ -47,1 +137,15 @@\n-    static final AnnotationEntryGen[] EMPTY_ARRAY = {};\n+    public int getTypeIndex() {\n+        return typeIndex;\n+    }\n+\n+    public final String getTypeSignature() {\n+        \/\/ ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);\n+        final ConstantUtf8 utf8 = (ConstantUtf8) cpool\n+                .getConstant(typeIndex\/* c.getNameIndex() *\/);\n+        return utf8.getBytes();\n+    }\n+\n+    public final String getTypeName() {\n+        return getTypeSignature();\/\/ BCELBUG: Should I use this instead?\n+        \/\/ Utility.signatureToString(getTypeSignature());\n+    }\n@@ -50,1 +154,45 @@\n-     * Converts a list of AnnotationGen objects into a set of attributes that can be attached to the class file.\n+     * Returns list of ElementNameValuePair objects\n+     *\/\n+    public List<ElementValuePairGen> getValues() {\n+        return evs;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder s = new StringBuilder(32); \/\/ CHECKSTYLE IGNORE MagicNumber\n+        s.append(\"AnnotationGen:[\").append(getTypeName()).append(\" #\").append(evs.size()).append(\" {\");\n+        for (int i = 0; i < evs.size(); i++) {\n+            s.append(evs.get(i));\n+            if (i + 1 < evs.size()) {\n+                s.append(\",\");\n+            }\n+        }\n+        s.append(\"}]\");\n+        return s.toString();\n+    }\n+\n+    public String toShortString() {\n+        final StringBuilder s = new StringBuilder();\n+        s.append(\"@\").append(getTypeName()).append(\"(\");\n+        for (int i = 0; i < evs.size(); i++) {\n+            s.append(evs.get(i));\n+            if (i + 1 < evs.size()) {\n+                s.append(\",\");\n+            }\n+        }\n+        s.append(\")\");\n+        return s.toString();\n+    }\n+\n+    private void isRuntimeVisible(final boolean b) {\n+        isRuntimeVisible = b;\n+    }\n+\n+    public boolean isRuntimeVisible() {\n+        return isRuntimeVisible;\n+    }\n+\n+\n+    \/**\n+     * Converts a list of AnnotationGen objects into a set of attributes\n+     * that can be attached to the class file.\n@@ -52,1 +200,1 @@\n-     * @param cp The constant pool gen where we can create the necessary name refs\n+     * @param cp  The constant pool gen where we can create the necessary name refs\n@@ -57,1 +205,1 @@\n-            return Attribute.EMPTY_ARRAY;\n+            return new Attribute[0];\n@@ -64,1 +212,1 @@\n-            \/\/ put the annotations in the right output stream\n+            \/\/  put the annotations in the right output stream\n@@ -75,1 +223,2 @@\n-            try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes); DataOutputStream riaDos = new DataOutputStream(riaBytes)) {\n+            try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes);\n+                    DataOutputStream riaDos = new DataOutputStream(riaBytes)) {\n@@ -105,2 +254,3 @@\n-                newAttributes\n-                    .add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));\n+                newAttributes.add(\n+                        new RuntimeVisibleAnnotations(rvaIndex, rvaData.length,\n+                            new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));\n@@ -110,1 +260,2 @@\n-                    new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));\n+                        new RuntimeInvisibleAnnotations(riaIndex, riaData.length,\n+                            new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));\n@@ -113,1 +264,1 @@\n-            return newAttributes.toArray(Attribute.EMPTY_ARRAY);\n+            return newAttributes.toArray(new Attribute[newAttributes.size()]);\n@@ -121,0 +272,1 @@\n+\n@@ -122,2 +274,3 @@\n-     * Annotations against a class are stored in one of four attribute kinds: - RuntimeVisibleParameterAnnotations -\n-     * RuntimeInvisibleParameterAnnotations\n+     * Annotations against a class are stored in one of four attribute kinds:\n+     * - RuntimeVisibleParameterAnnotations\n+     * - RuntimeInvisibleParameterAnnotations\n@@ -125,2 +278,3 @@\n-    static Attribute[] getParameterAnnotationAttributes(final ConstantPoolGen cp,\n-        final List<AnnotationEntryGen>[] \/* Array of lists, array size depends on #params *\/ vec) {\n+    static Attribute[] getParameterAnnotationAttributes(\n+            final ConstantPoolGen cp,\n+            final List<AnnotationEntryGen>[] \/*Array of lists, array size depends on #params *\/vec) {\n@@ -187,2 +341,5 @@\n-                newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)),\n-                    cp.getConstantPool()));\n+                newAttributes\n+                        .add(new RuntimeVisibleParameterAnnotations(rvaIndex,\n+                                rvaData.length,\n+                                new DataInputStream(new ByteArrayInputStream(rvaData)),\n+                                    cp.getConstantPool()));\n@@ -191,2 +348,5 @@\n-                newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)),\n-                    cp.getConstantPool()));\n+                newAttributes\n+                        .add(new RuntimeInvisibleParameterAnnotations(riaIndex,\n+                                riaData.length,\n+                                new DataInputStream(new ByteArrayInputStream(riaData)),\n+                                    cp.getConstantPool()));\n@@ -194,1 +354,1 @@\n-            return newAttributes.toArray(Attribute.EMPTY_ARRAY);\n+            return newAttributes.toArray(new Attribute[newAttributes.size()]);\n@@ -196,2 +356,2 @@\n-            System.err.println(\"IOException whilst processing parameter annotations\");\n-            e.printStackTrace();\n+            System.err.println(\"IOException whilst processing parameter annotations.\" +\n+                    e.getMessage());\n@@ -202,139 +362,0 @@\n-    public static AnnotationEntryGen read(final DataInput dis, final ConstantPoolGen cpool, final boolean b) throws IOException {\n-        final AnnotationEntryGen a = new AnnotationEntryGen(cpool);\n-        a.typeIndex = dis.readUnsignedShort();\n-        final int elemValuePairCount = dis.readUnsignedShort();\n-        for (int i = 0; i < elemValuePairCount; i++) {\n-            final int nidx = dis.readUnsignedShort();\n-            a.addElementNameValuePair(new ElementValuePairGen(nidx, ElementValueGen.readElementValue(dis, cpool), cpool));\n-        }\n-        a.isRuntimeVisible(b);\n-        return a;\n-    }\n-\n-    private int typeIndex;\n-\n-    private List<ElementValuePairGen> evs;\n-\n-    private final ConstantPoolGen cpool;\n-\n-    private boolean isRuntimeVisible;\n-\n-    \/**\n-     * Here we are taking a fixed annotation of type Annotation and building a modifiable AnnotationGen object. If the pool\n-     * passed in is for a different class file, then copyPoolEntries should have been passed as true as that will force us\n-     * to do a deep copy of the annotation and move the cpool entries across. We need to copy the type and the element name\n-     * value pairs and the visibility.\n-     *\/\n-    public AnnotationEntryGen(final AnnotationEntry a, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        this.cpool = cpool;\n-        if (copyPoolEntries) {\n-            typeIndex = cpool.addUtf8(a.getAnnotationType());\n-        } else {\n-            typeIndex = a.getAnnotationTypeIndex();\n-        }\n-        isRuntimeVisible = a.isRuntimeVisible();\n-        evs = copyValues(a.getElementValuePairs(), cpool, copyPoolEntries);\n-    }\n-\n-    private AnnotationEntryGen(final ConstantPoolGen cpool) {\n-        this.cpool = cpool;\n-    }\n-\n-    public AnnotationEntryGen(final ObjectType type, final List<ElementValuePairGen> elements, final boolean vis, final ConstantPoolGen cpool) {\n-        this.cpool = cpool;\n-        this.typeIndex = cpool.addUtf8(type.getSignature());\n-        evs = elements;\n-        isRuntimeVisible = vis;\n-    }\n-\n-    public void addElementNameValuePair(final ElementValuePairGen evp) {\n-        if (evs == null) {\n-            evs = new ArrayList<>();\n-        }\n-        evs.add(evp);\n-    }\n-\n-    private List<ElementValuePairGen> copyValues(final ElementValuePair[] in, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        final List<ElementValuePairGen> out = new ArrayList<>();\n-        for (final ElementValuePair nvp : in) {\n-            out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));\n-        }\n-        return out;\n-    }\n-\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n-        dos.writeShort(evs.size()); \/\/ u2 element_value pair count\n-        for (final ElementValuePairGen envp : evs) {\n-            envp.dump(dos);\n-        }\n-    }\n-\n-    \/**\n-     * Retrieve an immutable version of this AnnotationGen\n-     *\/\n-    public AnnotationEntry getAnnotation() {\n-        final AnnotationEntry a = new AnnotationEntry(typeIndex, cpool.getConstantPool(), isRuntimeVisible);\n-        for (final ElementValuePairGen element : evs) {\n-            a.addElementNameValuePair(element.getElementNameValuePair());\n-        }\n-        return a;\n-    }\n-\n-    public int getTypeIndex() {\n-        return typeIndex;\n-    }\n-\n-    public final String getTypeName() {\n-        return getTypeSignature();\/\/ BCELBUG: Should I use this instead?\n-        \/\/ Utility.signatureToString(getTypeSignature());\n-    }\n-\n-    public final String getTypeSignature() {\n-        \/\/ ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);\n-        final ConstantUtf8 utf8 = (ConstantUtf8) cpool.getConstant(typeIndex\/* c.getNameIndex() *\/);\n-        return utf8.getBytes();\n-    }\n-\n-    \/**\n-     * Returns list of ElementNameValuePair objects\n-     *\/\n-    public List<ElementValuePairGen> getValues() {\n-        return evs;\n-    }\n-\n-    public boolean isRuntimeVisible() {\n-        return isRuntimeVisible;\n-    }\n-\n-    private void isRuntimeVisible(final boolean b) {\n-        isRuntimeVisible = b;\n-    }\n-\n-    public String toShortString() {\n-        final StringBuilder s = new StringBuilder();\n-        s.append(\"@\").append(getTypeName()).append(\"(\");\n-        for (int i = 0; i < evs.size(); i++) {\n-            s.append(evs.get(i));\n-            if (i + 1 < evs.size()) {\n-                s.append(\",\");\n-            }\n-        }\n-        s.append(\")\");\n-        return s.toString();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final StringBuilder s = new StringBuilder(32); \/\/ CHECKSTYLE IGNORE MagicNumber\n-        s.append(\"AnnotationGen:[\").append(getTypeName()).append(\" #\").append(evs.size()).append(\" {\");\n-        for (int i = 0; i < evs.size(); i++) {\n-            s.append(evs.get(i));\n-            if (i + 1 < evs.size()) {\n-                s.append(\",\");\n-            }\n-        }\n-        s.append(\"}]\");\n-        return s.toString();\n-    }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AnnotationEntryGen.java","additions":181,"deletions":160,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -29,1 +30,2 @@\n-public abstract class ArithmeticInstruction extends Instruction implements TypedInstruction, StackProducer, StackConsumer {\n+public abstract class ArithmeticInstruction extends Instruction implements TypedInstruction,\n+        StackProducer, StackConsumer {\n@@ -32,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,0 +40,1 @@\n+\n@@ -44,2 +48,2 @@\n-    \/**\n-     * @return type associated with the instruction\n+\n+    \/** @return type associated with the instruction\n@@ -48,45 +52,45 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        final short opcode = super.getOpcode();\n-        switch (opcode) {\n-        case Const.DADD:\n-        case Const.DDIV:\n-        case Const.DMUL:\n-        case Const.DNEG:\n-        case Const.DREM:\n-        case Const.DSUB:\n-            return Type.DOUBLE;\n-        case Const.FADD:\n-        case Const.FDIV:\n-        case Const.FMUL:\n-        case Const.FNEG:\n-        case Const.FREM:\n-        case Const.FSUB:\n-            return Type.FLOAT;\n-        case Const.IADD:\n-        case Const.IAND:\n-        case Const.IDIV:\n-        case Const.IMUL:\n-        case Const.INEG:\n-        case Const.IOR:\n-        case Const.IREM:\n-        case Const.ISHL:\n-        case Const.ISHR:\n-        case Const.ISUB:\n-        case Const.IUSHR:\n-        case Const.IXOR:\n-            return Type.INT;\n-        case Const.LADD:\n-        case Const.LAND:\n-        case Const.LDIV:\n-        case Const.LMUL:\n-        case Const.LNEG:\n-        case Const.LOR:\n-        case Const.LREM:\n-        case Const.LSHL:\n-        case Const.LSHR:\n-        case Const.LSUB:\n-        case Const.LUSHR:\n-        case Const.LXOR:\n-            return Type.LONG;\n-        default: \/\/ Never reached\n-            throw new ClassGenException(\"Unknown type \" + opcode);\n+    public Type getType( final ConstantPoolGen cp ) {\n+        final short _opcode = super.getOpcode();\n+        switch (_opcode) {\n+            case Const.DADD:\n+            case Const.DDIV:\n+            case Const.DMUL:\n+            case Const.DNEG:\n+            case Const.DREM:\n+            case Const.DSUB:\n+                return Type.DOUBLE;\n+            case Const.FADD:\n+            case Const.FDIV:\n+            case Const.FMUL:\n+            case Const.FNEG:\n+            case Const.FREM:\n+            case Const.FSUB:\n+                return Type.FLOAT;\n+            case Const.IADD:\n+            case Const.IAND:\n+            case Const.IDIV:\n+            case Const.IMUL:\n+            case Const.INEG:\n+            case Const.IOR:\n+            case Const.IREM:\n+            case Const.ISHL:\n+            case Const.ISHR:\n+            case Const.ISUB:\n+            case Const.IUSHR:\n+            case Const.IXOR:\n+                return Type.INT;\n+            case Const.LADD:\n+            case Const.LAND:\n+            case Const.LDIV:\n+            case Const.LMUL:\n+            case Const.LNEG:\n+            case Const.LOR:\n+            case Const.LREM:\n+            case Const.LSHL:\n+            case Const.LSHR:\n+            case Const.LSUB:\n+            case Const.LUSHR:\n+            case Const.LXOR:\n+                return Type.LONG;\n+            default: \/\/ Never reached\n+                throw new ClassGenException(\"Unknown type \" + _opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArithmeticInstruction.java","additions":53,"deletions":49,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-public class ArrayElementValueGen extends ElementValueGen {\n+public class ArrayElementValueGen extends ElementValueGen\n+{\n@@ -40,14 +41,2 @@\n-    \/**\n-     * @param value\n-     * @param cpool\n-     *\/\n-    public ArrayElementValueGen(final ArrayElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        super(ARRAY, cpool);\n-        evalues = new ArrayList<>();\n-        final ElementValue[] in = value.getElementValuesArray();\n-        for (final ElementValue element : in) {\n-            evalues.add(ElementValueGen.copy(element, cpool, copyPoolEntries));\n-        }\n-    }\n-\n-    public ArrayElementValueGen(final ConstantPoolGen cp) {\n+    public ArrayElementValueGen(final ConstantPoolGen cp)\n+    {\n@@ -58,1 +47,3 @@\n-    public ArrayElementValueGen(final int type, final ElementValue[] datums, final ConstantPoolGen cpool) {\n+    public ArrayElementValueGen(final int type, final ElementValue[] datums,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -61,1 +52,2 @@\n-            throw new IllegalArgumentException(\"Only element values of type array can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type array can be built with this ctor - type specified: \" + type);\n@@ -69,13 +61,0 @@\n-    public void addElement(final ElementValueGen gen) {\n-        evalues.add(gen);\n-    }\n-\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 type of value (ARRAY == '[')\n-        dos.writeShort(evalues.size());\n-        for (final ElementValueGen element : evalues) {\n-            element.dump(dos);\n-        }\n-    }\n-\n@@ -86,1 +65,2 @@\n-    public ElementValue getElementValue() {\n+    public ElementValue getElementValue()\n+    {\n@@ -92,1 +72,3 @@\n-        return new ArrayElementValue(super.getElementValueType(), immutableData, getConstantPool().getConstantPool());\n+        return new ArrayElementValue(super.getElementValueType(),\n+                immutableData,\n+                getConstantPool().getConstantPool());\n@@ -95,2 +77,13 @@\n-    public List<ElementValueGen> getElementValues() {\n-        return evalues;\n+    \/**\n+     * @param value\n+     * @param cpool\n+     *\/\n+    public ArrayElementValueGen(final ArrayElementValue value, final ConstantPoolGen cpool,\n+            final boolean copyPoolEntries)\n+    {\n+        super(ARRAY, cpool);\n+        evalues = new ArrayList<>();\n+        final ElementValue[] in = value.getElementValuesArray();\n+        for (final ElementValue element : in) {\n+            evalues.add(ElementValueGen.copy(element, cpool, copyPoolEntries));\n+        }\n@@ -99,2 +92,8 @@\n-    public int getElementValuesSize() {\n-        return evalues.size();\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 type of value (ARRAY == '[')\n+        dos.writeShort(evalues.size());\n+        for (final ElementValueGen element : evalues) {\n+            element.dump(dos);\n+        }\n@@ -104,1 +103,2 @@\n-    public String stringifyValue() {\n+    public String stringifyValue()\n+    {\n@@ -116,0 +116,15 @@\n+\n+    public List<ElementValueGen> getElementValues()\n+    {\n+        return evalues;\n+    }\n+\n+    public int getElementValuesSize()\n+    {\n+        return evalues.size();\n+    }\n+\n+    public void addElement(final ElementValueGen gen)\n+    {\n+        evalues.add(gen);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayElementValueGen.java","additions":52,"deletions":37,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -29,1 +30,2 @@\n-public abstract class ArrayInstruction extends Instruction implements ExceptionThrower, TypedInstruction {\n+public abstract class ArrayInstruction extends Instruction implements ExceptionThrower,\n+        TypedInstruction {\n@@ -32,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,0 +40,1 @@\n+\n@@ -44,0 +48,1 @@\n+\n@@ -49,2 +54,2 @@\n-    \/**\n-     * @return type associated with the instruction\n+\n+    \/** @return type associated with the instruction\n@@ -53,29 +58,29 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        final short opcode = super.getOpcode();\n-        switch (opcode) {\n-        case com.sun.org.apache.bcel.internal.Const.IALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.IASTORE:\n-            return Type.INT;\n-        case com.sun.org.apache.bcel.internal.Const.CALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.CASTORE:\n-            return Type.CHAR;\n-        case com.sun.org.apache.bcel.internal.Const.BALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.BASTORE:\n-            return Type.BYTE;\n-        case com.sun.org.apache.bcel.internal.Const.SALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.SASTORE:\n-            return Type.SHORT;\n-        case com.sun.org.apache.bcel.internal.Const.LALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.LASTORE:\n-            return Type.LONG;\n-        case com.sun.org.apache.bcel.internal.Const.DALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.DASTORE:\n-            return Type.DOUBLE;\n-        case com.sun.org.apache.bcel.internal.Const.FALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.FASTORE:\n-            return Type.FLOAT;\n-        case com.sun.org.apache.bcel.internal.Const.AALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.AASTORE:\n-            return Type.OBJECT;\n-        default:\n-            throw new ClassGenException(\"Unknown case in switch\" + opcode);\n+    public Type getType( final ConstantPoolGen cp ) {\n+        final short _opcode = super.getOpcode();\n+        switch (_opcode) {\n+            case com.sun.org.apache.bcel.internal.Const.IALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.IASTORE:\n+                return Type.INT;\n+            case com.sun.org.apache.bcel.internal.Const.CALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.CASTORE:\n+                return Type.CHAR;\n+            case com.sun.org.apache.bcel.internal.Const.BALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.BASTORE:\n+                return Type.BYTE;\n+            case com.sun.org.apache.bcel.internal.Const.SALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.SASTORE:\n+                return Type.SHORT;\n+            case com.sun.org.apache.bcel.internal.Const.LALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.LASTORE:\n+                return Type.LONG;\n+            case com.sun.org.apache.bcel.internal.Const.DALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.DASTORE:\n+                return Type.DOUBLE;\n+            case com.sun.org.apache.bcel.internal.Const.FALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.FASTORE:\n+                return Type.FLOAT;\n+            case com.sun.org.apache.bcel.internal.Const.AALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.AASTORE:\n+                return Type.OBJECT;\n+            default:\n+                throw new ClassGenException(\"Unknown case in switch\" + _opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayInstruction.java","additions":38,"deletions":33,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ *\n@@ -30,2 +31,3 @@\n-    private final int dimensions;\n-    private final Type basicType;\n+    private int dimensions;\n+    private Type basicType;\n+\n@@ -37,1 +39,0 @@\n-     * @param dimensions array dimensions\n@@ -43,0 +44,1 @@\n+\n@@ -46,2 +48,1 @@\n-     * @param className complete name of class (java.lang.String, e.g.)\n-     * @param dimensions array dimensions\n+     * @param class_name complete name of class (java.lang.String, e.g.)\n@@ -49,2 +50,2 @@\n-    public ArrayType(final String className, final int dimensions) {\n-        this(ObjectType.getInstance(className), dimensions);\n+    public ArrayType(final String class_name, final int dimensions) {\n+        this(ObjectType.getInstance(class_name), dimensions);\n@@ -53,0 +54,1 @@\n+\n@@ -57,1 +59,0 @@\n-     * @param dimensions array dimensions\n@@ -61,1 +62,1 @@\n-        if (dimensions < 1 || dimensions > Const.MAX_BYTE) {\n+        if ((dimensions < 1) || (dimensions > Const.MAX_BYTE)) {\n@@ -65,11 +66,11 @@\n-        case Const.T_ARRAY:\n-            final ArrayType array = (ArrayType) type;\n-            this.dimensions = dimensions + array.dimensions;\n-            basicType = array.basicType;\n-            break;\n-        case Const.T_VOID:\n-            throw new ClassGenException(\"Invalid type: void[]\");\n-        default: \/\/ Basic type or reference\n-            this.dimensions = dimensions;\n-            basicType = type;\n-            break;\n+            case Const.T_ARRAY:\n+                final ArrayType array = (ArrayType) type;\n+                this.dimensions = dimensions + array.dimensions;\n+                basicType = array.basicType;\n+                break;\n+            case Const.T_VOID:\n+                throw new ClassGenException(\"Invalid type: void[]\");\n+            default: \/\/ Basic type or reference\n+                this.dimensions = dimensions;\n+                basicType = type;\n+                break;\n@@ -85,11 +86,0 @@\n-    \/**\n-     * @return true if both type objects refer to the same array type.\n-     *\/\n-    @Override\n-    public boolean equals(final Object type) {\n-        if (type instanceof ArrayType) {\n-            final ArrayType array = (ArrayType) type;\n-            return array.dimensions == dimensions && array.basicType.equals(basicType);\n-        }\n-        return false;\n-    }\n@@ -104,18 +94,0 @@\n-    \/**\n-     * Gets the name of referenced class.\n-     *\n-     * @return name of referenced class.\n-     * @since 6.7.0\n-     *\/\n-    @Override\n-    @Deprecated\n-    public String getClassName() {\n-        return signature;\n-    }\n-\n-    \/**\n-     * @return number of dimensions of array\n-     *\/\n-    public int getDimensions() {\n-        return dimensions;\n-    }\n@@ -133,2 +105,9 @@\n-    \/**\n-     * @return a hash code value for the object.\n+\n+    \/** @return number of dimensions of array\n+     *\/\n+    public int getDimensions() {\n+        return dimensions;\n+    }\n+\n+\n+    \/** @return a hash code value for the object.\n@@ -140,0 +119,12 @@\n+\n+\n+    \/** @return true if both type objects refer to the same array type.\n+     *\/\n+    @Override\n+    public boolean equals( final Object _type ) {\n+        if (_type instanceof ArrayType) {\n+            final ArrayType array = (ArrayType) _type;\n+            return (array.dimensions == dimensions) && array.basicType.equals(basicType);\n+        }\n+        return false;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayType.java","additions":42,"deletions":51,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -26,3 +27,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -32,2 +30,1 @@\n-    \/**\n-     * Load byte or boolean from array\n+    \/** Load byte or boolean from array\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n- * BASTORE - Store into byte or boolean array\n+ * BASTORE -  Store into byte or boolean array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -26,3 +27,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -32,2 +30,1 @@\n-    \/**\n-     * Store byte or boolean into array\n+    \/** Store byte or boolean into array\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,3 +30,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., value\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., value<\/PRE>\n+ *\n@@ -38,0 +37,1 @@\n+\n@@ -39,1 +39,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -44,2 +45,2 @@\n-    \/**\n-     * Push byte on stack\n+\n+    \/** Push byte on stack\n@@ -52,0 +53,1 @@\n+\n@@ -53,4 +55,1 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * Dump instruction as byte code to stream out.\n@@ -59,6 +58,3 @@\n-    public void accept(final Visitor v) {\n-        v.visitPushInstruction(this);\n-        v.visitStackProducer(this);\n-        v.visitTypedInstruction(this);\n-        v.visitConstantPushInstruction(this);\n-        v.visitBIPUSH(this);\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        super.dump(out);\n+        out.writeByte(b);\n@@ -67,0 +63,1 @@\n+\n@@ -68,1 +65,1 @@\n-     * Dump instruction as byte code to stream out.\n+     * @return mnemonic for instruction\n@@ -71,3 +68,2 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        super.dump(out);\n-        out.writeByte(b);\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + b;\n@@ -76,0 +72,1 @@\n+\n@@ -77,1 +74,1 @@\n-     * @return Type.BYTE\n+     * Read needed data (e.g. index) from file.\n@@ -80,2 +77,3 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.BYTE;\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.setLength(2);\n+        b = bytes.readByte();\n@@ -84,0 +82,1 @@\n+\n@@ -89,2 +88,2 @@\n-    \/**\n-     * Read needed data (e.g. index) from file.\n+\n+    \/** @return Type.BYTE\n@@ -93,3 +92,2 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.setLength(2);\n-        b = bytes.readByte();\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.BYTE;\n@@ -98,0 +96,1 @@\n+\n@@ -99,1 +98,6 @@\n-     * @return mnemonic for instruction\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -102,2 +106,6 @@\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + b;\n+    public void accept( final Visitor v ) {\n+        v.visitPushInstruction(this);\n+        v.visitStackProducer(this);\n+        v.visitTypedInstruction(this);\n+        v.visitConstantPushInstruction(this);\n+        v.visitBIPUSH(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BIPUSH.java","additions":39,"deletions":31,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ *\n@@ -32,0 +33,1 @@\n+\n@@ -33,2 +35,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -39,1 +43,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BREAKPOINT.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ *\n@@ -30,26 +31,0 @@\n-    \/\/ @since 6.0 no longer final\n-    public static BasicType getType(final byte type) {\n-        switch (type) {\n-        case Const.T_VOID:\n-            return VOID;\n-        case Const.T_BOOLEAN:\n-            return BOOLEAN;\n-        case Const.T_BYTE:\n-            return BYTE;\n-        case Const.T_SHORT:\n-            return SHORT;\n-        case Const.T_CHAR:\n-            return CHAR;\n-        case Const.T_INT:\n-            return INT;\n-        case Const.T_LONG:\n-            return LONG;\n-        case Const.T_DOUBLE:\n-            return DOUBLE;\n-        case Const.T_FLOAT:\n-            return FLOAT;\n-        default:\n-            throw new ClassGenException(\"Invalid type: \" + type);\n-        }\n-    }\n-\n@@ -57,1 +32,1 @@\n-     * Constructor for basic types such as int, long, 'void'\n+     * Constructor for basic types such as int, long, `void'\n@@ -64,1 +39,1 @@\n-        if (type < Const.T_BOOLEAN || type > Const.T_VOID) {\n+        if ((type < Const.T_BOOLEAN) || (type > Const.T_VOID)) {\n@@ -69,6 +44,25 @@\n-    \/**\n-     * @return true if both type objects refer to the same type\n-     *\/\n-    @Override\n-    public boolean equals(final Object type) {\n-        return type instanceof BasicType && ((BasicType) type).getType() == this.getType();\n+\n+    \/\/ @since 6.0 no longer final\n+    public static BasicType getType( final byte type ) {\n+        switch (type) {\n+            case Const.T_VOID:\n+                return VOID;\n+            case Const.T_BOOLEAN:\n+                return BOOLEAN;\n+            case Const.T_BYTE:\n+                return BYTE;\n+            case Const.T_SHORT:\n+                return SHORT;\n+            case Const.T_CHAR:\n+                return CHAR;\n+            case Const.T_INT:\n+                return INT;\n+            case Const.T_LONG:\n+                return LONG;\n+            case Const.T_DOUBLE:\n+                return DOUBLE;\n+            case Const.T_FLOAT:\n+                return FLOAT;\n+            default:\n+                throw new ClassGenException(\"Invalid type: \" + type);\n+        }\n@@ -77,2 +71,2 @@\n-    \/**\n-     * @return a hash code value for the object.\n+\n+    \/** @return a hash code value for the object.\n@@ -84,0 +78,8 @@\n+\n+\n+    \/** @return true if both type objects refer to the same type\n+     *\/\n+    @Override\n+    public boolean equals( final Object _type ) {\n+        return (_type instanceof BasicType) ? ((BasicType) _type).getType() == this.getType() : false;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BasicType.java","additions":38,"deletions":36,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -24,2 +24,4 @@\n- * BranchHandle is returned by specialized InstructionList.append() whenever a BranchInstruction is appended. This is\n- * useful when the target of this instruction is not known at time of creation and must be set later via setTarget().\n+ * BranchHandle is returned by specialized InstructionList.append() whenever a\n+ * BranchInstruction is appended. This is useful when the target of this\n+ * instruction is not known at time of creation and must be set later\n+ * via setTarget().\n@@ -33,7 +35,0 @@\n-    \/**\n-     * Factory method.\n-     *\/\n-    static BranchHandle getBranchHandle(final BranchInstruction i) {\n-        return new BranchHandle(i);\n-    }\n-\n@@ -44,0 +39,1 @@\n+\n@@ -49,3 +45,1 @@\n-    \/*\n-     * Override InstructionHandle methods: delegate to branch instruction. Through this overriding all access to the private\n-     * i_position field should be prevented.\n+    \/** Factory method.\n@@ -53,3 +47,2 @@\n-    @Override\n-    public int getPosition() {\n-        return bi.getPosition();\n+    static BranchHandle getBranchHandle( final BranchInstruction i ) {\n+        return new BranchHandle(i);\n@@ -58,6 +51,0 @@\n-    \/**\n-     * @return target of instruction.\n-     *\/\n-    public InstructionHandle getTarget() {\n-        return bi.getTarget();\n-    }\n@@ -65,2 +52,3 @@\n-    \/**\n-     * Set new contents. Old instruction is disposed and may not be used anymore.\n+    \/* Override InstructionHandle methods: delegate to branch instruction.\n+     * Through this overriding all access to the private i_position field should\n+     * be prevented.\n@@ -68,7 +56,3 @@\n-    @Override \/\/ This is only done in order to apply the additional type check; could be merged with super impl.\n-    public void setInstruction(final Instruction i) { \/\/ TODO could be package-protected?\n-        super.setInstruction(i);\n-        if (!(i instanceof BranchInstruction)) {\n-            throw new ClassGenException(\"Assigning \" + i + \" to branch handle which is not a branch instruction\");\n-        }\n-        bi = (BranchInstruction) i;\n+    @Override\n+    public int getPosition() {\n+        return bi.getPosition();\n@@ -77,0 +61,1 @@\n+\n@@ -78,1 +63,1 @@\n-    void setPosition(final int pos) {\n+    void setPosition( final int pos ) {\n@@ -84,0 +69,9 @@\n+\n+    @Override\n+    protected int updatePosition( final int offset, final int max_offset ) {\n+        final int x = bi.updatePosition(offset, max_offset);\n+        super.setPosition(bi.getPosition());\n+        return x;\n+    }\n+\n+\n@@ -87,1 +81,1 @@\n-    public void setTarget(final InstructionHandle ih) {\n+    public void setTarget( final InstructionHandle ih ) {\n@@ -91,6 +85,0 @@\n-    @Override\n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        final int x = bi.updatePosition(offset, maxOffset);\n-        super.setPosition(bi.getPosition());\n-        return x;\n-    }\n@@ -101,2 +89,24 @@\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        bi.updateTarget(oldIh, newIh);\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        bi.updateTarget(old_ih, new_ih);\n+    }\n+\n+\n+    \/**\n+     * @return target of instruction.\n+     *\/\n+    public InstructionHandle getTarget() {\n+        return bi.getTarget();\n+    }\n+\n+\n+    \/**\n+     * Set new contents. Old instruction is disposed and may not be used anymore.\n+     *\/\n+    @Override \/\/ This is only done in order to apply the additional type check; could be merged with super impl.\n+    public void setInstruction( final Instruction i ) { \/\/ TODO could be package-protected?\n+        super.setInstruction(i);\n+        if (!(i instanceof BranchInstruction)) {\n+            throw new ClassGenException(\"Assigning \" + i\n+                    + \" to branch handle which is not a branch instruction\");\n+        }\n+        bi = (BranchInstruction) i;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BranchHandle.java","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,3 @@\n- * Abstract super class for branching instructions like GOTO, IFEQ, etc.. Branch instructions may have a variable\n- * length, namely GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n+ * Abstract super class for branching instructions like GOTO, IFEQ, etc..\n+ * Branch instructions may have a variable length, namely GOTO, JSR,\n+ * LOOKUPSWITCH and TABLESWITCH.\n@@ -32,1 +33,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: July 2020\n@@ -36,0 +37,4 @@\n+    private int index; \/\/ Branch target relative to this instruction\n+    private InstructionHandle target; \/\/ Target object in instruction list\n+    private int position; \/\/ Byte code offset\n+\n@@ -37,1 +42,2 @@\n-     * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen\n+     * Empty constructor needed for the Class.newInstance() statement in\n+     * Instruction.readInstruction(). Not to be used otherwise.\n@@ -39,7 +45,1 @@\n-    static void notifyTarget(final InstructionHandle oldIh, final InstructionHandle newIh, final InstructionTargeter t) {\n-        if (oldIh != null) {\n-            oldIh.removeTargeter(t);\n-        }\n-        if (newIh != null) {\n-            newIh.addTargeter(t);\n-        }\n+    BranchInstruction() {\n@@ -48,5 +48,0 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int index; \/\/ Branch target relative to this instruction\n@@ -54,2 +49,3 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+    \/** Common super constructor\n+     * @param opcode Instruction opcode\n+     * @param target instruction to branch to\n@@ -57,2 +53,5 @@\n-    @Deprecated\n-    protected InstructionHandle target; \/\/ Target object in instruction list\n+    protected BranchInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, (short) 3);\n+        setTarget(target);\n+    }\n+\n@@ -61,1 +60,2 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n@@ -63,2 +63,10 @@\n-    @Deprecated\n-    protected int position; \/\/ Byte code offset\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        index = getTargetOffset();\n+        if (!isValidShort(index)) {\n+            throw new ClassGenException(\"Branch target offset too large for short: \" + index);\n+        }\n+        out.writeShort(index); \/\/ May be negative, i.e., point backwards\n+    }\n+\n@@ -67,1 +75,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * @param _target branch target\n+     * @return the offset to  `target' relative to this instruction\n@@ -69,1 +78,11 @@\n-    BranchInstruction() {\n+    protected int getTargetOffset( final InstructionHandle _target ) {\n+        if (_target == null) {\n+            throw new ClassGenException(\"Target of \" + super.toString(true)\n+                    + \" is invalid null handle\");\n+        }\n+        final int t = _target.getPosition();\n+        if (t < 0) {\n+            throw new ClassGenException(\"Invalid branch target position offset for \"\n+                    + super.toString(true) + \":\" + t + \":\" + _target);\n+        }\n+        return t - position;\n@@ -72,0 +91,1 @@\n+\n@@ -73,4 +93,1 @@\n-     * Common super constructor\n-     *\n-     * @param opcode Instruction opcode\n-     * @param target instruction to branch to\n+     * @return the offset to this instruction's target\n@@ -78,3 +95,2 @@\n-    protected BranchInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, (short) 3);\n-        setTarget(target);\n+    protected int getTargetOffset() {\n+        return getTargetOffset(target);\n@@ -83,0 +99,1 @@\n+\n@@ -84,1 +101,8 @@\n-     * @return true, if ih is target of this instruction\n+     * Called by InstructionList.setPositions when setting the position for every\n+     * instruction. In the presence of variable length instructions `setPositions'\n+     * performs multiple passes over the instruction list to calculate the\n+     * correct (byte) positions and offsets by calling this function.\n+     *\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param max_offset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n@@ -86,3 +110,3 @@\n-    @Override\n-    public boolean containsTarget(final InstructionHandle ih) {\n-        return target == ih;\n+    protected int updatePosition( final int offset, final int max_offset ) {\n+        position += offset;\n+        return 0;\n@@ -91,0 +115,1 @@\n+\n@@ -92,1 +117,9 @@\n-     * Inform target that it's not targeted anymore.\n+     * Long output format:\n+     *\n+     * &lt;position in byte code&gt;\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n+     * \"(\"&lt;length of instruction&gt;\")\"\n+     * \"&lt;\"&lt;target instruction&gt;\"&gt;\" \"@\"&lt;branch target offset&gt;\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -95,4 +128,25 @@\n-    void dispose() {\n-        setTarget(null);\n-        index = -1;\n-        position = -1;\n+    public String toString( final boolean verbose ) {\n+        final String s = super.toString(verbose);\n+        String t = \"null\";\n+        if (verbose) {\n+            if (target != null) {\n+                if (target.getInstruction() == this) {\n+                    t = \"<points to itself>\";\n+                } else if (target.getInstruction() == null) {\n+                    t = \"<null instruction!!!?>\";\n+                } else {\n+                    \/\/ I'm more interested in the address of the target then\n+                    \/\/ the instruction located there.\n+                    \/\/t = target.getInstruction().toString(false); \/\/ Avoid circles\n+                    t = \"\" + target.getPosition();\n+                }\n+            }\n+        } else {\n+            if (target != null) {\n+                index = target.getPosition();\n+                \/\/ index = getTargetOffset();  crashes if positions haven't been set\n+                \/\/ t = \"\" + (index + position);\n+                t = \"\" + index;\n+            }\n+        }\n+        return s + \" -> \" + t;\n@@ -101,0 +155,1 @@\n+\n@@ -102,1 +157,2 @@\n-     * Dump instruction as byte code to stream out.\n+     * Read needed data (e.g. index) from file. Conversion to a InstructionHandle\n+     * is done in InstructionList(byte[]).\n@@ -104,1 +160,3 @@\n-     * @param out Output stream\n+     * @param bytes input stream\n+     * @param wide wide prefix?\n+     * @see InstructionList\n@@ -107,7 +165,3 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        index = getTargetOffset();\n-        if (!isValidShort(index)) {\n-            throw new ClassGenException(\"Branch target offset too large for short: \" + index);\n-        }\n-        out.writeShort(index); \/\/ May be negative, i.e., point backwards\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.setLength(3);\n+        index = bytes.readShort();\n@@ -116,0 +170,1 @@\n+\n@@ -123,7 +178,0 @@\n-    \/**\n-     * @return the position\n-     * @since 6.0\n-     *\/\n-    protected int getPosition() {\n-        return position;\n-    }\n@@ -138,0 +186,1 @@\n+\n@@ -139,1 +188,2 @@\n-     * @return the offset to this instruction's target\n+     * Set branch target\n+     * @param target branch target\n@@ -141,2 +191,3 @@\n-    protected int getTargetOffset() {\n-        return getTargetOffset(target);\n+    public void setTarget( final InstructionHandle target ) {\n+        notifyTarget(this.target, target, this);\n+        this.target = target;\n@@ -145,0 +196,1 @@\n+\n@@ -146,2 +198,1 @@\n-     * @param target branch target\n-     * @return the offset to 'target' relative to this instruction\n+     * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen\n@@ -149,3 +200,4 @@\n-    protected int getTargetOffset(final InstructionHandle target) {\n-        if (target == null) {\n-            throw new ClassGenException(\"Target of \" + super.toString(true) + \" is invalid null handle\");\n+    static void notifyTarget( final InstructionHandle old_ih, final InstructionHandle new_ih,\n+            final InstructionTargeter t ) {\n+        if (old_ih != null) {\n+            old_ih.removeTargeter(t);\n@@ -153,3 +205,2 @@\n-        final int t = target.getPosition();\n-        if (t < 0) {\n-            throw new ClassGenException(\"Invalid branch target position offset for \" + super.toString(true) + \":\" + t + \":\" + target);\n+        if (new_ih != null) {\n+            new_ih.addTargeter(t);\n@@ -157,1 +208,0 @@\n-        return t - position;\n@@ -160,0 +210,1 @@\n+\n@@ -161,5 +212,2 @@\n-     * Read needed data (e.g. index) from file. Conversion to a InstructionHandle is done in InstructionList(byte[]).\n-     *\n-     * @param bytes input stream\n-     * @param wide wide prefix?\n-     * @see InstructionList\n+     * @param old_ih old target\n+     * @param new_ih new target\n@@ -168,3 +216,6 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.setLength(3);\n-        index = bytes.readShort();\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        if (target == old_ih) {\n+            setTarget(new_ih);\n+        } else {\n+            throw new ClassGenException(\"Not targeting \" + old_ih + \", but \" + target);\n+        }\n@@ -173,7 +224,0 @@\n-    \/**\n-     * @param index the index to set\n-     * @since 6.0\n-     *\/\n-    protected void setIndex(final int index) {\n-        this.index = index;\n-    }\n@@ -182,2 +226,1 @@\n-     * @param position the position to set\n-     * @since 6.0\n+     * @return true, if ih is target of this instruction\n@@ -185,2 +228,3 @@\n-    protected void setPosition(final int position) {\n-        this.position = position;\n+    @Override\n+    public boolean containsTarget( final InstructionHandle ih ) {\n+        return target == ih;\n@@ -208,3 +252,1 @@\n-     * Set branch target\n-     *\n-     * @param target branch target\n+     * Inform target that it's not targeted anymore.\n@@ -212,3 +254,5 @@\n-    public void setTarget(final InstructionHandle target) {\n-        notifyTarget(this.target, target, this);\n-        this.target = target;\n+    @Override\n+    void dispose() {\n+        setTarget(null);\n+        index = -1;\n+        position = -1;\n@@ -217,0 +261,1 @@\n+\n@@ -218,7 +263,2 @@\n-     * Long output format:\n-     *\n-     * &lt;position in byte code&gt; &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\"\n-     * \"&lt;\"&lt;target instruction&gt;\"&gt;\" \"@\"&lt;branch target offset&gt;\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * @return the position\n+     * @since 6.0\n@@ -226,24 +266,2 @@\n-    @Override\n-    public String toString(final boolean verbose) {\n-        final String s = super.toString(verbose);\n-        String t = \"null\";\n-        if (target != null) {\n-            if (verbose) {\n-                if (target.getInstruction() == this) {\n-                    t = \"<points to itself>\";\n-                } else if (target.getInstruction() == null) {\n-                    t = \"<null instruction!!!?>\";\n-                } else {\n-                    \/\/ I'm more interested in the address of the target then\n-                    \/\/ the instruction located there.\n-                    \/\/ t = target.getInstruction().toString(false); \/\/ Avoid circles\n-                    t = \"\" + target.getPosition();\n-                }\n-            } else {\n-                index = target.getPosition();\n-                \/\/ index = getTargetOffset(); crashes if positions haven't been set\n-                \/\/ t = \"\" + (index + position);\n-                t = \"\" + index;\n-            }\n-        }\n-        return s + \" -> \" + t;\n+    protected int getPosition() {\n+        return position;\n@@ -252,0 +270,1 @@\n+\n@@ -253,7 +272,2 @@\n-     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n-     * length instructions 'setPositions' performs multiple passes over the instruction list to calculate the correct (byte)\n-     * positions and offsets by calling this function.\n-     *\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param maxOffset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n+     * @param position the position to set\n+     * @since 6.0\n@@ -261,3 +275,2 @@\n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        position += offset;\n-        return 0;\n+    protected void setPosition(final int position) {\n+        this.position = position;\n@@ -266,0 +279,1 @@\n+\n@@ -267,2 +281,2 @@\n-     * @param oldIh old target\n-     * @param newIh new target\n+     * @param index the index to set\n+     * @since 6.0\n@@ -270,6 +284,2 @@\n-    @Override\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        if (target != oldIh) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh + \", but \" + target);\n-        }\n-        setTarget(newIh);\n+    protected void setIndex(final int index) {\n+        this.index = index;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BranchInstruction.java","additions":154,"deletions":144,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load char from array\n+    \/** Load char from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * CASTORE - Store into char array\n+ * CASTORE -  Store into char array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store char into array\n+    \/** Store char into array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ..., objectref<\/PRE>\n@@ -29,3 +30,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ..., objectref\n- * <\/PRE>\n@@ -33,1 +31,2 @@\n-public class CHECKCAST extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer, StackConsumer {\n+public class CHECKCAST extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer,\n+        StackConsumer {\n@@ -36,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -41,3 +41,2 @@\n-    \/**\n-     * Check whether object is of given type\n-     *\n+\n+    \/** Check whether object is of given type\n@@ -50,0 +49,20 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+            ExceptionConst.CLASS_CAST_EXCEPTION);\n+    }\n+\n+\n+    @Override\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n+        Type t = getType(cpg);\n+        if (t instanceof ArrayType) {\n+            t = ((ArrayType) t).getBasicType();\n+        }\n+        return (t instanceof ObjectType) ? (ObjectType) t : null;\n+    }\n+\n+\n@@ -51,2 +70,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +78,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -66,17 +87,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.CLASS_CAST_EXCEPTION);\n-    }\n-\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        Type t = getType(cpg);\n-        if (t instanceof ArrayType) {\n-            t = ((ArrayType) t).getBasicType();\n-        }\n-        return t instanceof ObjectType ? (ObjectType) t : null;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CHECKCAST.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -32,1 +31,2 @@\n- * Abstract super class for instructions that use an index into the constant pool such as LDC, INVOKEVIRTUAL, etc.\n+ * Abstract super class for instructions that use an index into the\n+ * constant pool such as LDC, INVOKEVIRTUAL, etc.\n@@ -40,1 +40,4 @@\n-public abstract class CPInstruction extends Instruction implements TypedInstruction, IndexedInstruction {\n+public abstract class CPInstruction extends Instruction implements TypedInstruction,\n+        IndexedInstruction {\n+\n+    private int index; \/\/ index to constant pool\n@@ -42,5 +45,0 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int index; \/\/ index to constant pool\n@@ -49,1 +47,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -54,0 +53,1 @@\n+\n@@ -62,0 +62,1 @@\n+\n@@ -64,1 +65,0 @@\n-     *\n@@ -68,1 +68,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -73,0 +73,1 @@\n+\n@@ -74,1 +75,7 @@\n-     * @return index in constant pool referred by this instruction.\n+     * Long output format:\n+     *\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n+     * \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; constant pool index&gt;\"&gt;\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -77,2 +84,2 @@\n-    public final int getIndex() {\n-        return index;\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + index;\n@@ -81,0 +88,1 @@\n+\n@@ -82,1 +90,1 @@\n-     * @return type related with this instruction.\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -85,5 +93,5 @@\n-    public Type getType(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        String name = cp.getConstantString(index, com.sun.org.apache.bcel.internal.Const.CONSTANT_Class);\n-        if (!name.startsWith(\"[\")) {\n-            name = \"L\" + name + \";\";\n+    public String toString( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(index);\n+        String str = cp.constantToString(c);\n+        if (c instanceof ConstantClass) {\n+            str = str.replace('.', '\/');\n@@ -91,1 +99,1 @@\n-        return Type.getType(name);\n+        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + str;\n@@ -94,0 +102,1 @@\n+\n@@ -96,1 +105,0 @@\n-     *\n@@ -101,1 +109,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -106,0 +114,10 @@\n+\n+    \/**\n+     * @return index in constant pool referred by this instruction.\n+     *\/\n+    @Override\n+    public final int getIndex() {\n+        return index;\n+    }\n+\n+\n@@ -108,2 +126,1 @@\n-     *\n-     * @param index in constant pool.\n+     * @param index in  constant pool.\n@@ -112,1 +129,1 @@\n-    public void setIndex(final int index) { \/\/ TODO could be package-protected?\n+    public void setIndex( final int index ) { \/\/ TODO could be package-protected?\n@@ -119,13 +136,0 @@\n-    \/**\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; constant pool\n-     * index&gt;\"&gt;\"\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n-     *\/\n-    @Override\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + index;\n-    }\n@@ -133,2 +137,1 @@\n-    \/**\n-     * @return mnemonic for instruction with symbolic references resolved\n+    \/** @return type related with this instruction.\n@@ -137,5 +140,5 @@\n-    public String toString(final ConstantPool cp) {\n-        final Constant c = cp.getConstant(index);\n-        String str = cp.constantToString(c);\n-        if (c instanceof ConstantClass) {\n-            str = Utility.packageToPath(str);\n+    public Type getType( final ConstantPoolGen cpg ) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        String name = cp.getConstantString(index, com.sun.org.apache.bcel.internal.Const.CONSTANT_Class);\n+        if (!name.startsWith(\"[\")) {\n+            name = \"L\" + name + \";\";\n@@ -143,1 +146,1 @@\n-        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + str;\n+        return Type.getType(name);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CPInstruction.java","additions":50,"deletions":47,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-public class ClassElementValueGen extends ElementValueGen {\n+public class ClassElementValueGen extends ElementValueGen\n+{\n@@ -38,1 +39,1 @@\n-    private final int idx;\n+    private int idx;\n@@ -40,11 +41,2 @@\n-    public ClassElementValueGen(final ClassElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        super(CLASS, cpool);\n-        if (copyPoolEntries) {\n-            \/\/ idx = cpool.addClass(value.getClassString());\n-            idx = cpool.addUtf8(value.getClassString());\n-        } else {\n-            idx = value.getIndex();\n-        }\n-    }\n-\n-    protected ClassElementValueGen(final int typeIdx, final ConstantPoolGen cpool) {\n+    protected ClassElementValueGen(final int typeIdx, final ConstantPoolGen cpool)\n+    {\n@@ -55,1 +47,2 @@\n-    public ClassElementValueGen(final ObjectType t, final ConstantPoolGen cpool) {\n+    public ClassElementValueGen(final ObjectType t, final ConstantPoolGen cpool)\n+    {\n@@ -61,0 +54,3 @@\n+    \/**\n+     * Return immutable variant of this ClassElementValueGen\n+     *\/\n@@ -62,3 +58,5 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n-        dos.writeShort(idx);\n+    public ElementValue getElementValue()\n+    {\n+        return new ClassElementValue(super.getElementValueType(),\n+                idx,\n+                getConstantPool().getConstantPool());\n@@ -67,1 +65,22 @@\n-    public String getClassString() {\n+    public ClassElementValueGen(final ClassElementValue value, final ConstantPoolGen cpool,\n+            final boolean copyPoolEntries)\n+    {\n+        super(CLASS, cpool);\n+        if (copyPoolEntries)\n+        {\n+            \/\/ idx = cpool.addClass(value.getClassString());\n+            idx = cpool.addUtf8(value.getClassString());\n+        }\n+        else\n+        {\n+            idx = value.getIndex();\n+        }\n+    }\n+\n+    public int getIndex()\n+    {\n+        return idx;\n+    }\n+\n+    public String getClassString()\n+    {\n@@ -76,3 +95,0 @@\n-    \/**\n-     * Return immutable variant of this ClassElementValueGen\n-     *\/\n@@ -80,6 +96,3 @@\n-    public ElementValue getElementValue() {\n-        return new ClassElementValue(super.getElementValueType(), idx, getConstantPool().getConstantPool());\n-    }\n-\n-    public int getIndex() {\n-        return idx;\n+    public String stringifyValue()\n+    {\n+        return getClassString();\n@@ -89,2 +102,4 @@\n-    public String stringifyValue() {\n-        return getClassString();\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n+        dos.writeShort(idx);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassElementValueGen.java","additions":44,"deletions":29,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import java.util.Arrays;\n-import java.util.Collections;\n@@ -30,0 +28,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;\n@@ -39,1 +38,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -43,1 +41,2 @@\n- * Template class for building up a java class. May be initialized with an existing java class (file).\n+ * Template class for building up a java class. May be initialized with an\n+ * existing java class (file).\n@@ -46,1 +45,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -50,0 +49,17 @@\n+    \/* Corresponds to the fields found in a JavaClass object.\n+     *\/\n+    private String className;\n+    private String superClassName;\n+    private final String fileName;\n+    private int classNameIndex = -1;\n+    private int superclass_name_index = -1;\n+    private int major = Const.MAJOR_1_1;\n+    private int minor = Const.MINOR_1_1;\n+    private ConstantPoolGen cp; \/\/ Template for building up constant pool\n+    \/\/ ArrayLists instead of arrays to gather fields, methods, etc.\n+    private final List<Field> fieldList = new ArrayList<>();\n+    private final List<Method> methodList = new ArrayList<>();\n+    private final List<Attribute> attributeList = new ArrayList<>();\n+    private final List<String> interfaceList = new ArrayList<>();\n+    private final List<AnnotationEntryGen> annotationList = new ArrayList<>();\n+\n@@ -53,1 +69,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -59,0 +75,1 @@\n+\n@@ -60,1 +77,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -66,6 +83,0 @@\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n@@ -73,2 +84,8 @@\n-    \/**\n-     * @param comparator Comparison strategy object\n+    \/** Convenience constructor to set up some important values initially.\n+     *\n+     * @param className fully qualified class name\n+     * @param superClassName fully qualified superclass name\n+     * @param fileName source file name\n+     * @param accessFlags access qualifiers\n+     * @param interfaces implemented interfaces\n+     * @param cp constant pool to use\n@@ -76,2 +93,19 @@\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n+    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags,\n+            final String[] interfaces, final ConstantPoolGen cp) {\n+        super(accessFlags);\n+        this.className = className;\n+        this.superClassName = superClassName;\n+        this.fileName = fileName;\n+        this.cp = cp;\n+        \/\/ Put everything needed by default into the constant pool and the vectors\n+        if (fileName != null) {\n+            addAttribute(new SourceFile(cp.addUtf8(\"SourceFile\"), 2, cp.addUtf8(fileName), cp\n+                    .getConstantPool()));\n+        }\n+        classNameIndex = cp.addClass(className);\n+        superclass_name_index = cp.addClass(superClassName);\n+        if (interfaces != null) {\n+            for (final String interface1 : interfaces) {\n+                addInterface(interface1);\n+            }\n+        }\n@@ -80,14 +114,0 @@\n-    \/*\n-     * Corresponds to the fields found in a JavaClass object.\n-     *\/\n-    private String className;\n-    private String superClassName;\n-    private final String fileName;\n-    private int classNameIndex = -1;\n-    private int superclassNameIndex = -1;\n-    private int major = Const.MAJOR_1_1;\n-    private int minor = Const.MINOR_1_1;\n-    private ConstantPoolGen cp; \/\/ Template for building up constant pool\n-    \/\/ ArrayLists instead of arrays to gather fields, methods, etc.\n-    private final List<Field> fieldList = new ArrayList<>();\n-    private final List<Method> methodList = new ArrayList<>();\n@@ -95,5 +115,13 @@\n-    private final List<Attribute> attributeList = new ArrayList<>();\n-\n-    private final List<String> interfaceList = new ArrayList<>();\n-\n-    private final List<AnnotationEntryGen> annotationList = new ArrayList<>();\n+    \/** Convenience constructor to set up some important values initially.\n+     *\n+     * @param className fully qualified class name\n+     * @param superClassName fully qualified superclass name\n+     * @param fileName source file name\n+     * @param accessFlags access qualifiers\n+     * @param interfaces implemented interfaces\n+     *\/\n+    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags,\n+            final String[] interfaces) {\n+        this(className, superClassName, fileName, accessFlags, interfaces,\n+                new ConstantPoolGen());\n+    }\n@@ -101,1 +129,0 @@\n-    private List<ClassObserver> observers;\n@@ -105,1 +132,0 @@\n-     *\n@@ -111,1 +137,1 @@\n-        superclassNameIndex = clazz.getSuperclassNameIndex();\n+        superclass_name_index = clazz.getSuperclassNameIndex();\n@@ -121,1 +147,6 @@\n-        Collections.addAll(interfaceList, clazz.getInterfaceNames());\n+        final Method[] methods = clazz.getMethods();\n+        final Field[] fields = clazz.getFields();\n+        final String[] interfaces = clazz.getInterfaceNames();\n+        for (final String interface1 : interfaces) {\n+            addInterface(interface1);\n+        }\n@@ -127,3 +158,9 @@\n-        Collections.addAll(annotationList, annotations);\n-        Collections.addAll(methodList, clazz.getMethods());\n-        Collections.addAll(fieldList, clazz.getFields());\n+        for (final AnnotationEntryGen annotation : annotations) {\n+            addAnnotationEntry(annotation);\n+        }\n+        for (final Method method : methods) {\n+            addMethod(method);\n+        }\n+        for (final Field field : fields) {\n+            addField(field);\n+        }\n@@ -133,7 +170,1 @@\n-     * Convenience constructor to set up some important values initially.\n-     *\n-     * @param className fully qualified class name\n-     * @param superClassName fully qualified superclass name\n-     * @param fileName source file name\n-     * @param accessFlags access qualifiers\n-     * @param interfaces implemented interfaces\n+     * Look for attributes representing annotations and unpack them.\n@@ -141,2 +172,25 @@\n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces) {\n-        this(className, superClassName, fileName, accessFlags, interfaces, new ConstantPoolGen());\n+    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs)\n+    {\n+        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<>();\n+        for (final Attribute attr : attrs) {\n+            if (attr instanceof RuntimeVisibleAnnotations)\n+            {\n+                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;\n+                final AnnotationEntry[] annos = rva.getAnnotationEntries();\n+                for (final AnnotationEntry a : annos) {\n+                    annotationGenObjs.add(new AnnotationEntryGen(a,\n+                            getConstantPool(), false));\n+                }\n+            }\n+            else\n+                if (attr instanceof RuntimeInvisibleAnnotations)\n+                {\n+                    final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;\n+                    final AnnotationEntry[] annos = ria.getAnnotationEntries();\n+                    for (final AnnotationEntry a : annos) {\n+                        annotationGenObjs.add(new AnnotationEntryGen(a,\n+                                getConstantPool(), false));\n+                    }\n+                }\n+        }\n+        return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);\n@@ -145,0 +199,1 @@\n+\n@@ -146,8 +201,1 @@\n-     * Convenience constructor to set up some important values initially.\n-     *\n-     * @param className fully qualified class name\n-     * @param superClassName fully qualified superclass name\n-     * @param fileName source file name\n-     * @param accessFlags access qualifiers\n-     * @param interfaces implemented interfaces\n-     * @param cp constant pool to use\n+     * @return the (finally) built up Java class object.\n@@ -155,15 +203,13 @@\n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces,\n-        final ConstantPoolGen cp) {\n-        super(accessFlags);\n-        this.className = className;\n-        this.superClassName = superClassName;\n-        this.fileName = fileName;\n-        this.cp = cp;\n-        \/\/ Put everything needed by default into the constant pool and the vectors\n-        if (fileName != null) {\n-            addAttribute(new SourceFile(cp.addUtf8(\"SourceFile\"), 2, cp.addUtf8(fileName), cp.getConstantPool()));\n-        }\n-        classNameIndex = cp.addClass(className);\n-        superclassNameIndex = cp.addClass(superClassName);\n-        if (interfaces != null) {\n-            Collections.addAll(interfaceList, interfaces);\n+    public JavaClass getJavaClass() {\n+        final int[] interfaces = getInterfaces();\n+        final Field[] fields = getFields();\n+        final Method[] methods = getMethods();\n+        Attribute[] attributes = null;\n+        if (annotationList.isEmpty()) {\n+            attributes = getAttributes();\n+        } else {\n+            \/\/ TODO: Sometime later, trash any attributes called 'RuntimeVisibleAnnotations' or 'RuntimeInvisibleAnnotations'\n+            final Attribute[] annAttributes  = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());\n+            attributes = new Attribute[attributeList.size()+annAttributes.length];\n+            attributeList.toArray(attributes);\n+            System.arraycopy(annAttributes,0,attributes,attributeList.size(),annAttributes.length);\n@@ -171,0 +217,4 @@\n+        \/\/ Must be last since the above calls may still add something to it\n+        final ConstantPool _cp = this.cp.getFinalConstantPool();\n+        return new JavaClass(classNameIndex, superclass_name_index, fileName, major, minor,\n+                super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);\n@@ -173,2 +223,7 @@\n-    public void addAnnotationEntry(final AnnotationEntryGen a) {\n-        annotationList.add(a);\n+\n+    \/**\n+     * Add an interface to this class, i.e., this class has to implement it.\n+     * @param name interface to implement (fully qualified class name)\n+     *\/\n+    public void addInterface( final String name ) {\n+        interfaceList.add(name);\n@@ -177,0 +232,1 @@\n+\n@@ -178,3 +234,2 @@\n-     * Add an attribute to this class.\n-     *\n-     * @param a attribute to add\n+     * Remove an interface from this class.\n+     * @param name interface to remove (fully qualified name)\n@@ -182,2 +237,2 @@\n-    public void addAttribute(final Attribute a) {\n-        attributeList.add(a);\n+    public void removeInterface( final String name ) {\n+        interfaceList.remove(name);\n@@ -186,0 +241,1 @@\n+\n@@ -187,5 +243,1 @@\n-     * Convenience method.\n-     *\n-     * Add an empty constructor to this class that does nothing but calling super().\n-     *\n-     * @param accessFlags rights for constructor\n+     * @return major version number of class file\n@@ -193,8 +245,18 @@\n-    public void addEmptyConstructor(final int accessFlags) {\n-        final InstructionList il = new InstructionList();\n-        il.append(InstructionConst.THIS); \/\/ Push 'this'\n-        il.append(new INVOKESPECIAL(cp.addMethodref(superClassName, Const.CONSTRUCTOR_NAME, \"()V\")));\n-        il.append(InstructionConst.RETURN);\n-        final MethodGen mg = new MethodGen(accessFlags, Type.VOID, Type.NO_ARGS, null, Const.CONSTRUCTOR_NAME, className, il, cp);\n-        mg.setMaxStack(1);\n-        addMethod(mg.getMethod());\n+    public int getMajor() {\n+        return major;\n+    }\n+\n+\n+    \/** Set major version number of class file, default value is 45 (JDK 1.1)\n+     * @param major major version number\n+     *\/\n+    public void setMajor( final int major ) { \/\/ TODO could be package-protected - only called by test code\n+        this.major = major;\n+    }\n+\n+\n+    \/** Set minor version number of class file, default value is 3 (JDK 1.1)\n+     * @param minor minor version number\n+     *\/\n+    public void setMinor( final int minor ) {  \/\/ TODO could be package-protected - only called by test code\n+        this.minor = minor;\n@@ -204,3 +266,1 @@\n-     * Add a field to this class.\n-     *\n-     * @param f field to add\n+     * @return minor version number of class file\n@@ -208,2 +268,2 @@\n-    public void addField(final Field f) {\n-        fieldList.add(f);\n+    public int getMinor() {\n+        return minor;\n@@ -212,0 +272,1 @@\n+\n@@ -213,3 +274,2 @@\n-     * Add an interface to this class, i.e., this class has to implement it.\n-     *\n-     * @param name interface to implement (fully qualified class name)\n+     * Add an attribute to this class.\n+     * @param a attribute to add\n@@ -217,2 +277,6 @@\n-    public void addInterface(final String name) {\n-        interfaceList.add(name);\n+    public void addAttribute( final Attribute a ) {\n+        attributeList.add(a);\n+    }\n+\n+    public void addAnnotationEntry(final AnnotationEntryGen a) {\n+        annotationList.add(a);\n@@ -221,0 +285,1 @@\n+\n@@ -223,1 +288,0 @@\n-     *\n@@ -226,1 +290,1 @@\n-    public void addMethod(final Method m) {\n+    public void addMethod( final Method m ) {\n@@ -230,0 +294,1 @@\n+\n@@ -231,1 +296,4 @@\n-     * Add observer for this object.\n+     * Convenience method.\n+     *\n+     * Add an empty constructor to this class that does nothing but calling super().\n+     * @param access_flags rights for constructor\n@@ -233,5 +301,9 @@\n-    public void addObserver(final ClassObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n-        }\n-        observers.add(o);\n+    public void addEmptyConstructor( final int access_flags ) {\n+        final InstructionList il = new InstructionList();\n+        il.append(InstructionConst.THIS); \/\/ Push `this'\n+        il.append(new INVOKESPECIAL(cp.addMethodref(superClassName, \"<init>\", \"()V\")));\n+        il.append(InstructionConst.RETURN);\n+        final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, \"<init>\",\n+                className, il, cp);\n+        mg.setMaxStack(1);\n+        addMethod(mg.getMethod());\n@@ -240,7 +312,7 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n+\n+    \/**\n+     * Add a field to this class.\n+     * @param f field to add\n+     *\/\n+    public void addField( final Field f ) {\n+        fieldList.add(f);\n@@ -249,1 +321,2 @@\n-    public boolean containsField(final Field f) {\n+\n+    public boolean containsField( final Field f ) {\n@@ -253,2 +326,2 @@\n-    \/**\n-     * @return field object with given name, or null\n+\n+    \/** @return field object with given name, or null\n@@ -256,1 +329,1 @@\n-    public Field containsField(final String name) {\n+    public Field containsField( final String name ) {\n@@ -265,2 +338,2 @@\n-    \/**\n-     * @return method object with given name and signature, or null\n+\n+    \/** @return method object with given name and signature, or null\n@@ -268,1 +341,1 @@\n-    public Method containsMethod(final String name, final String signature) {\n+    public Method containsMethod( final String name, final String signature ) {\n@@ -277,0 +350,1 @@\n+\n@@ -278,4 +352,2 @@\n-     * Return value as defined by given BCELComparator strategy. By default two ClassGen objects are said to be equal when\n-     * their class names are equal.\n-     *\n-     * @see Object#equals(Object)\n+     * Remove an attribute from this class.\n+     * @param a attribute to remove\n@@ -283,3 +355,2 @@\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n+    public void removeAttribute( final Attribute a ) {\n+        attributeList.remove(a);\n@@ -288,3 +359,7 @@\n-    \/\/ J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?\n-    public AnnotationEntryGen[] getAnnotationEntries() {\n-        return annotationList.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n+\n+    \/**\n+     * Remove a method from this class.\n+     * @param m method to remove\n+     *\/\n+    public void removeMethod( final Method m ) {\n+        methodList.remove(m);\n@@ -293,2 +368,14 @@\n-    public Attribute[] getAttributes() {\n-        return attributeList.toArray(Attribute.EMPTY_ARRAY);\n+\n+    \/** Replace given method with new one. If the old one does not exist\n+     * add the new_ method to the class anyway.\n+     *\/\n+    public void replaceMethod( final Method old, final Method new_ ) {\n+        if (new_ == null) {\n+            throw new ClassGenException(\"Replacement method must not be null\");\n+        }\n+        final int i = methodList.indexOf(old);\n+        if (i < 0) {\n+            methodList.add(new_);\n+        } else {\n+            methodList.set(i, new_);\n+        }\n@@ -297,2 +384,14 @@\n-    public String getClassName() {\n-        return className;\n+\n+    \/** Replace given field with new one. If the old one does not exist\n+     * add the new_ field to the class anyway.\n+     *\/\n+    public void replaceField( final Field old, final Field new_ ) {\n+        if (new_ == null) {\n+            throw new ClassGenException(\"Replacement method must not be null\");\n+        }\n+        final int i = fieldList.indexOf(old);\n+        if (i < 0) {\n+            fieldList.add(new_);\n+        } else {\n+            fieldList.set(i, new_);\n+        }\n@@ -301,2 +400,7 @@\n-    public int getClassNameIndex() {\n-        return classNameIndex;\n+\n+    \/**\n+     * Remove a field to this class.\n+     * @param f field to remove\n+     *\/\n+    public void removeField( final Field f ) {\n+        fieldList.remove(f);\n@@ -305,2 +409,3 @@\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n+\n+    public String getClassName() {\n+        return className;\n@@ -309,2 +414,3 @@\n-    public Field[] getFields() {\n-        return fieldList.toArray(Field.EMPTY_ARRAY);\n+\n+    public String getSuperclassName() {\n+        return superClassName;\n@@ -313,0 +419,1 @@\n+\n@@ -317,0 +424,36 @@\n+\n+    public void setClassName( final String name ) {\n+        className = name.replace('\/', '.');\n+        classNameIndex = cp.addClass(name);\n+    }\n+\n+\n+    public void setSuperclassName( final String name ) {\n+        superClassName = name.replace('\/', '.');\n+        superclass_name_index = cp.addClass(name);\n+    }\n+\n+\n+    public Method[] getMethods() {\n+        return methodList.toArray(new Method[methodList.size()]);\n+    }\n+\n+\n+    public void setMethods( final Method[] methods ) {\n+        methodList.clear();\n+        for (final Method method : methods) {\n+            addMethod(method);\n+        }\n+    }\n+\n+\n+    public void setMethodAt( final Method method, final int pos ) {\n+        methodList.set(pos, method);\n+    }\n+\n+\n+    public Method getMethodAt( final int pos ) {\n+        return methodList.get(pos);\n+    }\n+\n+\n@@ -318,1 +461,4 @@\n-        return interfaceList.toArray(Const.EMPTY_STRING_ARRAY);\n+        final int size = interfaceList.size();\n+        final String[] interfaces = new String[size];\n+        interfaceList.toArray(interfaces);\n+        return interfaces;\n@@ -321,0 +467,1 @@\n+\n@@ -324,1 +471,3 @@\n-        Arrays.setAll(interfaces, i -> cp.addClass(interfaceList.get(i)));\n+        for (int i = 0; i < size; i++) {\n+            interfaces[i] = cp.addClass(interfaceList.get(i));\n+        }\n@@ -328,22 +477,0 @@\n-    \/**\n-     * @return the (finally) built up Java class object.\n-     *\/\n-    public JavaClass getJavaClass() {\n-        final int[] interfaces = getInterfaces();\n-        final Field[] fields = getFields();\n-        final Method[] methods = getMethods();\n-        Attribute[] attributes = null;\n-        if (annotationList.isEmpty()) {\n-            attributes = getAttributes();\n-        } else {\n-            \/\/ TODO: Sometime later, trash any attributes called 'RuntimeVisibleAnnotations' or 'RuntimeInvisibleAnnotations'\n-            final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());\n-            attributes = new Attribute[attributeList.size() + annAttributes.length];\n-            attributeList.toArray(attributes);\n-            System.arraycopy(annAttributes, 0, attributes, attributeList.size(), annAttributes.length);\n-        }\n-        \/\/ Must be last since the above calls may still add something to it\n-        final ConstantPool cp = this.cp.getFinalConstantPool();\n-        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor, super.getAccessFlags(), cp, interfaces, fields, methods,\n-            attributes);\n-    }\n@@ -351,5 +478,2 @@\n-    \/**\n-     * @return major version number of class file\n-     *\/\n-    public int getMajor() {\n-        return major;\n+    public Field[] getFields() {\n+        return fieldList.toArray(new Field[fieldList.size()]);\n@@ -358,3 +482,0 @@\n-    public Method getMethodAt(final int pos) {\n-        return methodList.get(pos);\n-    }\n@@ -362,2 +483,2 @@\n-    public Method[] getMethods() {\n-        return methodList.toArray(Method.EMPTY_ARRAY);\n+    public Attribute[] getAttributes() {\n+        return attributeList.toArray(new Attribute[attributeList.size()]);\n@@ -366,5 +487,3 @@\n-    \/**\n-     * @return minor version number of class file\n-     *\/\n-    public int getMinor() {\n-        return minor;\n+    \/\/  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?\n+    public AnnotationEntryGen[] getAnnotationEntries() {\n+        return annotationList.toArray(new AnnotationEntryGen[annotationList.size()]);\n@@ -373,2 +492,3 @@\n-    public String getSuperclassName() {\n-        return superClassName;\n+\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n@@ -377,2 +497,3 @@\n-    public int getSuperclassNameIndex() {\n-        return superclassNameIndex;\n+\n+    public void setConstantPool( final ConstantPoolGen constant_pool ) {\n+        cp = constant_pool;\n@@ -381,8 +502,5 @@\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the class name.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n+\n+    public void setClassNameIndex( final int class_name_index ) {\n+        this.classNameIndex = class_name_index;\n+        className = cp.getConstantPool().getConstantString(class_name_index,\n+                Const.CONSTANT_Class).replace('\/', '.');\n@@ -391,7 +509,5 @@\n-    \/**\n-     * Remove an attribute from this class.\n-     *\n-     * @param a attribute to remove\n-     *\/\n-    public void removeAttribute(final Attribute a) {\n-        attributeList.remove(a);\n+\n+    public void setSuperclassNameIndex( final int superclass_name_index ) {\n+        this.superclass_name_index = superclass_name_index;\n+        superClassName = cp.getConstantPool().getConstantString(superclass_name_index,\n+                Const.CONSTANT_Class).replace('\/', '.');\n@@ -400,7 +516,3 @@\n-    \/**\n-     * Remove a field to this class.\n-     *\n-     * @param f field to remove\n-     *\/\n-    public void removeField(final Field f) {\n-        fieldList.remove(f);\n+\n+    public int getSuperclassNameIndex() {\n+        return superclass_name_index;\n@@ -409,7 +521,3 @@\n-    \/**\n-     * Remove an interface from this class.\n-     *\n-     * @param name interface to remove (fully qualified name)\n-     *\/\n-    public void removeInterface(final String name) {\n-        interfaceList.remove(name);\n+\n+    public int getClassNameIndex() {\n+        return classNameIndex;\n@@ -418,4 +526,4 @@\n-    \/**\n-     * Remove a method from this class.\n-     *\n-     * @param m method to remove\n+    private List<ClassObserver> observers;\n+\n+\n+    \/** Add observer for this object.\n@@ -423,2 +531,5 @@\n-    public void removeMethod(final Method m) {\n-        methodList.remove(m);\n+    public void addObserver( final ClassObserver o ) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n+        }\n+        observers.add(o);\n@@ -427,2 +538,2 @@\n-    \/**\n-     * Remove observer for this object.\n+\n+    \/** Remove observer for this object.\n@@ -430,1 +541,1 @@\n-    public void removeObserver(final ClassObserver o) {\n+    public void removeObserver( final ClassObserver o ) {\n@@ -436,14 +547,0 @@\n-    \/**\n-     * Replace given field with new one. If the old one does not exist add the new_ field to the class anyway.\n-     *\/\n-    public void replaceField(final Field old, final Field newField) {\n-        if (newField == null) {\n-            throw new ClassGenException(\"Replacement method must not be null\");\n-        }\n-        final int i = fieldList.indexOf(old);\n-        if (i < 0) {\n-            fieldList.add(newField);\n-        } else {\n-            fieldList.set(i, newField);\n-        }\n-    }\n@@ -451,2 +548,3 @@\n-    \/**\n-     * Replace given method with new one. If the old one does not exist add the newMethod method to the class anyway.\n+    \/** Call notify() method on all observers. This method is not called\n+     * automatically whenever the state has changed, but has to be\n+     * called by the user after he has finished editing the object.\n@@ -454,9 +552,5 @@\n-    public void replaceMethod(final Method old, final Method newMethod) {\n-        if (newMethod == null) {\n-            throw new ClassGenException(\"Replacement method must not be null\");\n-        }\n-        final int i = methodList.indexOf(old);\n-        if (i < 0) {\n-            methodList.add(newMethod);\n-        } else {\n-            methodList.set(i, newMethod);\n+    public void update() {\n+        if (observers != null) {\n+            for (final ClassObserver observer : observers) {\n+                observer.notify(this);\n+            }\n@@ -466,4 +560,0 @@\n-    public void setClassName(final String name) {\n-        className = Utility.pathToPackage(name);\n-        classNameIndex = cp.addClass(name);\n-    }\n@@ -471,3 +561,7 @@\n-    public void setClassNameIndex(final int classNameIndex) {\n-        this.classNameIndex = classNameIndex;\n-        this.className = Utility.pathToPackage(cp.getConstantPool().getConstantString(classNameIndex, Const.CONSTANT_Class));\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n@@ -476,3 +570,0 @@\n-    public void setConstantPool(final ConstantPoolGen constantPool) {\n-        cp = constantPool;\n-    }\n@@ -481,3 +572,1 @@\n-     * Set major version number of class file, default value is 45 (JDK 1.1)\n-     *\n-     * @param major major version number\n+     * @return Comparison strategy object\n@@ -485,6 +574,2 @@\n-    public void setMajor(final int major) { \/\/ TODO could be package-protected - only called by test code\n-        this.major = major;\n-    }\n-\n-    public void setMethodAt(final Method method, final int pos) {\n-        methodList.set(pos, method);\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n@@ -493,4 +578,0 @@\n-    public void setMethods(final Method[] methods) {\n-        methodList.clear();\n-        Collections.addAll(methodList, methods);\n-    }\n@@ -499,3 +580,1 @@\n-     * Set minor version number of class file, default value is 3 (JDK 1.1)\n-     *\n-     * @param minor minor version number\n+     * @param comparator Comparison strategy object\n@@ -503,7 +582,2 @@\n-    public void setMinor(final int minor) { \/\/ TODO could be package-protected - only called by test code\n-        this.minor = minor;\n-    }\n-\n-    public void setSuperclassName(final String name) {\n-        superClassName = Utility.pathToPackage(name);\n-        superclassNameIndex = cp.addClass(name);\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n@@ -512,4 +586,0 @@\n-    public void setSuperclassNameIndex(final int superclassNameIndex) {\n-        this.superclassNameIndex = superclassNameIndex;\n-        superClassName = Utility.pathToPackage(cp.getConstantPool().getConstantString(superclassNameIndex, Const.CONSTANT_Class));\n-    }\n@@ -518,1 +588,5 @@\n-     * Look for attributes representing annotations and unpack them.\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two ClassGen objects are said to be equal when\n+     * their class names are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n@@ -520,12 +594,3 @@\n-    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {\n-        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<>();\n-        for (final Attribute attr : attrs) {\n-            if (attr instanceof RuntimeVisibleAnnotations) {\n-                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;\n-                rva.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n-            } else if (attr instanceof RuntimeInvisibleAnnotations) {\n-                final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;\n-                ria.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n-            }\n-        }\n-        return annotationGenObjs.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n@@ -534,0 +599,1 @@\n+\n@@ -535,2 +601,4 @@\n-     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n-     * has to be called by the user after they have finished editing the object.\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the class name.\n+     *\n+     * @see java.lang.Object#hashCode()\n@@ -538,6 +606,3 @@\n-    public void update() {\n-        if (observers != null) {\n-            for (final ClassObserver observer : observers) {\n-                observer.notify(this);\n-            }\n-        }\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassGen.java","additions":377,"deletions":312,"binary":false,"changes":689,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Thrown on internal exceptions.\n+ * Thrown on internal errors. Extends RuntimeException so it hasn't to be declared\n+ * in the throws clause every time.\n+ *\n@@ -32,0 +34,1 @@\n+        super();\n@@ -34,0 +37,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassGenException.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Implement this interface if you're interested in changes to a ClassGen object and register yourself with\n- * addObserver().\n+ * Implement this interface if you're interested in changes to a ClassGen object\n+ * and register yourself with addObserver().\n+ *\n@@ -30,1 +31,1 @@\n-    void notify(ClassGen clazz);\n+    void notify( ClassGen clazz );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassObserver.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,4 +26,6 @@\n- * This class represents an exception handler, i.e., specifies the region where a handler is active and an instruction\n- * where the actual handling is done. pool as parameters. Opposed to the JVM specification the end of the handled region\n- * is set to be inclusive, i.e. all instructions between start and end are protected including the start and end\n- * instructions (handles) themselves. The end of the region is automatically mapped to be exclusive when calling\n+ * This class represents an exception handler, i.e., specifies the  region where\n+ * a handler is active and an instruction where the actual handling is done.\n+ * pool as parameters. Opposed to the JVM specification the end of the handled\n+ * region is set to be inclusive, i.e. all instructions between start and end\n+ * are protected including the start and end instructions (handles) themselves.\n+ * The end of the region is automatically mapped to be exclusive when calling\n@@ -32,3 +34,3 @@\n- * @see MethodGen\n- * @see CodeException\n- * @see InstructionHandle\n+ * @see     MethodGen\n+ * @see     CodeException\n+ * @see     InstructionHandle\n@@ -38,2 +40,0 @@\n-    static final CodeExceptionGen[] EMPTY_ARRAY = {};\n-\n@@ -45,0 +45,1 @@\n+\n@@ -46,2 +47,2 @@\n-     * Add an exception handler, i.e., specify region where a handler is active and an instruction where the actual handling\n-     * is done.\n+     * Add an exception handler, i.e., specify region where a handler is active and an\n+     * instruction where the actual handling is done.\n@@ -54,1 +55,2 @@\n-    public CodeExceptionGen(final InstructionHandle startPc, final InstructionHandle endPc, final InstructionHandle handlerPc, final ObjectType catchType) {\n+    public CodeExceptionGen(final InstructionHandle startPc, final InstructionHandle endPc,\n+            final InstructionHandle handlerPc, final ObjectType catchType) {\n@@ -61,8 +63,0 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n-    }\n@@ -71,1 +65,7 @@\n-     * @return true, if ih is target of this handler\n+     * Get CodeException object.<BR>\n+     *\n+     * This relies on that the instruction list has already been dumped\n+     * to byte code or or that the `setPositions' methods has been\n+     * called for the instruction list.\n+     *\n+     * @param cp constant pool\n@@ -73,3 +73,4 @@\n-    @Override\n-    public boolean containsTarget(final InstructionHandle ih) {\n-        return startPc == ih || endPc == ih || handlerPc == ih;\n+    public CodeException getCodeException( final ConstantPoolGen cp ) {\n+        return new CodeException(startPc.getPosition(), endPc.getPosition()\n+                + endPc.getInstruction().getLength(), handlerPc.getPosition(),\n+                (catchType == null) ? 0 : cp.addClass(catchType));\n@@ -78,3 +79,7 @@\n-    \/** Gets the type of the Exception to catch, 'null' for ANY. *\/\n-    public ObjectType getCatchType() {\n-        return catchType;\n+\n+    \/* Set start of handler\n+     * @param startPc Start of handled region (inclusive)\n+     *\/\n+    public void setStartPC( final InstructionHandle start_pc ) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.startPc, start_pc, this);\n+        this.startPc = start_pc;\n@@ -83,7 +88,3 @@\n-    \/**\n-     * Get CodeException object.<BR>\n-     *\n-     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n-     * has been called for the instruction list.\n-     *\n-     * @param cp constant pool\n+\n+    \/* Set end of handler\n+     * @param endPc End of handled region (inclusive)\n@@ -91,3 +92,3 @@\n-    public CodeException getCodeException(final ConstantPoolGen cp) {\n-        return new CodeException(startPc.getPosition(), endPc.getPosition() + endPc.getInstruction().getLength(), handlerPc.getPosition(),\n-            catchType == null ? 0 : cp.addClass(catchType));\n+    public void setEndPC( final InstructionHandle end_pc ) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.endPc, end_pc, this);\n+        this.endPc = end_pc;\n@@ -96,2 +97,3 @@\n-    \/**\n-     * @return end of handled region (inclusive)\n+\n+    \/* Set handler code\n+     * @param handlerPc Start of handler\n@@ -99,2 +101,3 @@\n-    public InstructionHandle getEndPC() {\n-        return endPc;\n+    public void setHandlerPC( final InstructionHandle handler_pc ) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.handlerPc, handler_pc, this);\n+        this.handlerPc = handler_pc;\n@@ -103,0 +106,1 @@\n+\n@@ -104,1 +108,2 @@\n-     * @return start of handler\n+     * @param old_ih old target, either start or end\n+     * @param new_ih new target\n@@ -106,2 +111,19 @@\n-    public InstructionHandle getHandlerPC() {\n-        return handlerPc;\n+    @Override\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        boolean targeted = false;\n+        if (startPc == old_ih) {\n+            targeted = true;\n+            setStartPC(new_ih);\n+        }\n+        if (endPc == old_ih) {\n+            targeted = true;\n+            setEndPC(new_ih);\n+        }\n+        if (handlerPc == old_ih) {\n+            targeted = true;\n+            setHandlerPC(new_ih);\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + old_ih + \", but {\" + startPc + \", \"\n+                    + endPc + \", \" + handlerPc + \"}\");\n+        }\n@@ -110,0 +132,1 @@\n+\n@@ -111,1 +134,1 @@\n-     * @return start of handled region (inclusive)\n+     * @return true, if ih is target of this handler\n@@ -113,2 +136,3 @@\n-    public InstructionHandle getStartPC() {\n-        return startPc;\n+    @Override\n+    public boolean containsTarget( final InstructionHandle ih ) {\n+        return (startPc == ih) || (endPc == ih) || (handlerPc == ih);\n@@ -117,0 +141,1 @@\n+\n@@ -118,1 +143,1 @@\n-    public void setCatchType(final ObjectType catchType) {\n+    public void setCatchType( final ObjectType catchType ) {\n@@ -122,4 +147,8 @@\n-    \/*\n-     * Set end of handler\n-     *\n-     * @param endPc End of handled region (inclusive)\n+\n+    \/** Gets the type of the Exception to catch, 'null' for ANY. *\/\n+    public ObjectType getCatchType() {\n+        return catchType;\n+    }\n+\n+\n+    \/** @return start of handled region (inclusive)\n@@ -127,3 +156,2 @@\n-    public void setEndPC(final InstructionHandle endPc) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.endPc, endPc, this);\n-        this.endPc = endPc;\n+    public InstructionHandle getStartPC() {\n+        return startPc;\n@@ -132,4 +160,2 @@\n-    \/*\n-     * Set handler code\n-     *\n-     * @param handlerPc Start of handler\n+\n+    \/** @return end of handled region (inclusive)\n@@ -137,3 +163,2 @@\n-    public void setHandlerPC(final InstructionHandle handlerPc) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.handlerPc, handlerPc, this);\n-        this.handlerPc = handlerPc;\n+    public InstructionHandle getEndPC() {\n+        return endPc;\n@@ -142,4 +167,2 @@\n-    \/*\n-     * Set start of handler\n-     *\n-     * @param startPc Start of handled region (inclusive)\n+\n+    \/** @return start of handler\n@@ -147,3 +170,2 @@\n-    public void setStartPC(final InstructionHandle startPc) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.startPc, startPc, this);\n-        this.startPc = startPc;\n+    public InstructionHandle getHandlerPC() {\n+        return handlerPc;\n@@ -152,0 +174,1 @@\n+\n@@ -157,4 +180,1 @@\n-    \/**\n-     * @param oldIh old target, either start or end\n-     * @param newIh new target\n-     *\/\n+\n@@ -162,16 +182,5 @@\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        boolean targeted = false;\n-        if (startPc == oldIh) {\n-            targeted = true;\n-            setStartPC(newIh);\n-        }\n-        if (endPc == oldIh) {\n-            targeted = true;\n-            setEndPC(newIh);\n-        }\n-        if (handlerPc == oldIh) {\n-            targeted = true;\n-            setHandlerPC(newIh);\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh + \", but {\" + startPc + \", \" + endPc + \", \" + handlerPc + \"}\");\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CodeExceptionGen.java","additions":98,"deletions":89,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -25,4 +25,6 @@\n- * Wrapper class for 'compound' operations, virtual instructions that don't exist as byte code, but give a useful\n- * meaning. For example, the (virtual) PUSH instruction takes an arbitrary argument and produces the appropriate code at\n- * dump time (ICONST, LDC, BIPUSH, ...). Also you can use the SWITCH instruction as a useful template for either\n- * LOOKUPSWITCH or TABLESWITCH.\n+ * Wrapper class for `compound' operations, virtual instructions that\n+ * don't exist as byte code, but give a useful meaning. For example,\n+ * the (virtual) PUSH instruction takes an arbitray argument and produces the\n+ * appropiate code at dump time (ICONST, LDC, BIPUSH, ...). Also you can use the\n+ * SWITCH instruction as a useful template for either LOOKUPSWITCH or\n+ * TABLESWITCH.\n@@ -30,1 +32,2 @@\n- * The interface provides the possibility for the user to write 'templates' or 'macros' for such reusable code patterns.\n+ * The interface provides the possibilty for the user to write\n+ * `templates' or `macros' for such reuseable code patterns.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CompoundInstruction.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n-import java.util.Arrays;\n@@ -31,1 +30,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.ConstantDynamic;\n@@ -43,1 +41,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -46,5 +43,8 @@\n- * This class is used to build up a constant pool. The user adds constants via 'addXXX' methods, 'addString',\n- * 'addClass', etc.. These methods return an index into the constant pool. Finally, 'getFinalConstantPool()' returns the\n- * constant pool built up. Intermediate versions of the constant pool can be obtained with 'getConstantPool()'. A\n- * constant pool has capacity for Constants.MAX_SHORT entries. Note that the first (0) is used by the JVM and that\n- * Double and Long constants need two slots.\n+ * This class is used to build up a constant pool. The user adds\n+ * constants via `addXXX' methods, `addString', `addClass',\n+ * etc.. These methods return an index into the constant\n+ * pool. Finally, `getFinalConstantPool()' returns the constant pool\n+ * built up. Intermediate versions of the constant pool can be\n+ * obtained with `getConstantPool()'. A constant pool has capacity for\n+ * Constants.MAX_SHORT entries. Note that the first (0) is used by the\n+ * JVM and that Double and Long constants need two slots.\n@@ -53,1 +53,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: June 2022\n@@ -56,1 +56,1 @@\n-\n+    public static final int CONSTANT_POOL_SIZE = 65535;\n@@ -58,0 +58,3 @@\n+    private int size;\n+    private Constant[] constants;\n+    private int index = 1; \/\/ First entry (0) used by JVM\n@@ -60,1 +63,0 @@\n-\n@@ -62,1 +64,0 @@\n-\n@@ -64,1 +65,0 @@\n-\n@@ -67,23 +67,1 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int size;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected Constant[] constants;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getSize()\n-     *\/\n-    @Deprecated\n-    protected int index = 1; \/\/ First entry (0) used by JVM\n-\n-    private final Map<String, Integer> stringTable = new HashMap<>();\n-\n-    private final Map<String, Integer> classTable = new HashMap<>();\n-\n-    private final Map<String, Integer> utf8Table = new HashMap<>();\n+    private static class Index {\n@@ -91,1 +69,1 @@\n-    private final Map<String, Integer> natTable = new HashMap<>();\n+        final int index;\n@@ -93,1 +71,0 @@\n-    private final Map<String, Integer> cpTable = new HashMap<>();\n@@ -95,6 +72,3 @@\n-    \/**\n-     * Constructs a new empty constant pool.\n-     *\/\n-    public ConstantPoolGen() {\n-        size = DEFAULT_BUFFER_SIZE;\n-        constants = new Constant[size];\n+        Index(final int i) {\n+            index = i;\n+        }\n@@ -103,0 +77,1 @@\n+\n@@ -104,1 +79,1 @@\n-     * Constructs a new instance with the given array of constants.\n+     * Initialize with given array of constants.\n@@ -116,2 +91,2 @@\n-        if (cs.length > Const.MAX_CP_ENTRIES) {\n-            throw new IllegalStateException(\"The number of constants \" + cs.length\n+        if (cs.length > CONSTANT_POOL_SIZE) {\n+            throw new RuntimeException(\"The number of constants \" + cs.length\n@@ -119,1 +94,1 @@\n-                    + Const.MAX_CP_ENTRIES);\n+                    + CONSTANT_POOL_SIZE);\n@@ -124,1 +99,1 @@\n-        size = Math.min(Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64), Const.MAX_CP_ENTRIES);\n+        size = Math.min(Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64), CONSTANT_POOL_SIZE);\n@@ -132,0 +107,1 @@\n+\n@@ -139,1 +115,1 @@\n-                    stringTable.put(key, Integer.valueOf(i));\n+                    stringTable.put(key, new Index(i));\n@@ -146,1 +122,1 @@\n-                    classTable.put(key, Integer.valueOf(i));\n+                    classTable.put(key, new Index(i));\n@@ -150,2 +126,2 @@\n-                final ConstantUtf8 u8NameIdx = (ConstantUtf8) constants[n.getNameIndex()];\n-                final ConstantUtf8 u8SigIdx = (ConstantUtf8) constants[n.getSignatureIndex()];\n+                final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n+                final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n@@ -153,1 +129,1 @@\n-                sb.append(u8NameIdx.getBytes());\n+                sb.append(u8.getBytes());\n@@ -155,1 +131,1 @@\n-                sb.append(u8SigIdx.getBytes());\n+                sb.append(u8_2.getBytes());\n@@ -160,1 +136,1 @@\n-                    natTable.put(key, Integer.valueOf(i));\n+                    natTable.put(key, new Index(i));\n@@ -166,1 +142,1 @@\n-                    utf8Table.put(key, Integer.valueOf(i));\n+                    utf8Table.put(key, new Index(i));\n@@ -170,1 +146,1 @@\n-                String className;\n+                String class_name;\n@@ -174,3 +150,3 @@\n-                    className = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());\n-                } else if (c instanceof ConstantDynamic) {\n-                    className = Integer.toString(((ConstantDynamic) m).getBootstrapMethodAttrIndex());\n+                    class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());\n+                    \/\/ since name can't begin with digit, can  use\n+                    \/\/ METHODREF_DELIM with out fear of duplicates.\n@@ -178,1 +154,1 @@\n-                    final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n+                final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n@@ -180,1 +156,1 @@\n-                    className = Utility.pathToPackage(u8.getBytes());\n+                    class_name = u8.getBytes().replace('\/', '.');\n@@ -185,1 +161,1 @@\n-                final String methodName = u8.getBytes();\n+                final String method_name = u8.getBytes();\n@@ -189,1 +165,0 @@\n-                \/\/ Since name cannot begin with digit, we can use METHODREF_DELIM without fear of duplicates\n@@ -197,1 +172,1 @@\n-                sb.append(className);\n+                sb.append(class_name);\n@@ -199,1 +174,1 @@\n-                sb.append(methodName);\n+                sb.append(method_name);\n@@ -206,1 +181,1 @@\n-                    cpTable.put(key, Integer.valueOf(i));\n+                    cpTable.put(key, new Index(i));\n@@ -208,0 +183,20 @@\n+            } else if (c == null) { \/\/ entries may be null\n+                \/\/ nothing to do\n+            } else if (c instanceof ConstantInteger) {\n+                \/\/ nothing to do\n+            } else if (c instanceof ConstantLong) {\n+                \/\/ nothing to do\n+            } else if (c instanceof ConstantFloat) {\n+                \/\/ nothing to do\n+            } else if (c instanceof ConstantDouble) {\n+                \/\/ nothing to do\n+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {\n+                \/\/ TODO should this be handled somehow?\n+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {\n+                \/\/ TODO should this be handled somehow?\n+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {\n+                \/\/ TODO should this be handled somehow?\n+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {\n+                \/\/ TODO should this be handled somehow?\n+            } else {\n+                assert false : \"Unexpected constant type: \" + c.getClass().getName();\n@@ -209,22 +204,0 @@\n-\/\/            else if (c == null) { \/\/ entries may be null\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof ConstantInteger) {\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof ConstantLong) {\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof ConstantFloat) {\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof ConstantDouble) {\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {\n-\/\/                \/\/ TODO should this be handled somehow?\n-\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {\n-\/\/                \/\/ TODO should this be handled somehow?\n-\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {\n-\/\/                \/\/ TODO should this be handled somehow?\n-\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {\n-\/\/                \/\/ TODO should this be handled somehow?\n-\/\/            } else {\n-\/\/                \/\/ Not helpful, should throw an exception.\n-\/\/                assert false : \"Unexpected constant type: \" + c.getClass().getName();\n-\/\/            }\n@@ -234,0 +207,1 @@\n+\n@@ -235,3 +209,1 @@\n-     * Constructs a new instance with the given constant pool.\n-     *\n-     * @param cp the constant pool.\n+     * Initialize with given constant pool.\n@@ -243,0 +215,1 @@\n+\n@@ -244,2 +217,33 @@\n-     * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY instruction, e.g. to the\n-     * ConstantPool.\n+     * Create empty constant pool.\n+     *\/\n+    public ConstantPoolGen() {\n+        size = DEFAULT_BUFFER_SIZE;\n+        constants = new Constant[size];\n+    }\n+\n+\n+    \/** Resize internal array of constants.\n+     *\/\n+    protected void adjustSize() {\n+        \/\/ 3 extra spaces are needed as some entries may take 3 slots\n+        if (index + 3 >= CONSTANT_POOL_SIZE) {\n+            throw new RuntimeException(\"The number of constants \" + (index + 3)\n+                    + \" is over the size limit of the constant pool: \"\n+                    + CONSTANT_POOL_SIZE);\n+        }\n+\n+        if (index + 3 >= size) {\n+            final Constant[] cs = constants;\n+            size *= 2;\n+            \/\/ the constant array shall not exceed the size of the constant pool\n+            size = Math.min(size, CONSTANT_POOL_SIZE);\n+            constants = new Constant[size];\n+            System.arraycopy(cs, 0, constants, 0, index);\n+        }\n+    }\n+\n+    private final Map<String, Index> stringTable = new HashMap<>();\n+\n+\n+    \/**\n+     * Look for ConstantString in ConstantPool containing String `str'.\n@@ -247,2 +251,2 @@\n-     * @param type type of array class\n-     * @return index of entry\n+     * @param str String to search for\n+     * @return index on success, -1 otherwise\n@@ -250,2 +254,3 @@\n-    public int addArrayClass(final ArrayType type) {\n-        return addClass_(type.getSignature());\n+    public int lookupString( final String str ) {\n+        final Index index = stringTable.get(str);\n+        return (index != null) ? index.index : -1;\n@@ -254,0 +259,1 @@\n+\n@@ -255,1 +261,1 @@\n-     * Add a new Class reference to the ConstantPool for a given type.\n+     * Add a new String constant to the ConstantPool, if it is not already in there.\n@@ -257,1 +263,1 @@\n-     * @param type Class to add\n+     * @param str String to add\n@@ -260,2 +266,14 @@\n-    public int addClass(final ObjectType type) {\n-        return addClass(type.getClassName());\n+    public int addString( final String str ) {\n+        int ret;\n+        if ((ret = lookupString(str)) != -1) {\n+            return ret; \/\/ Already in CP\n+        }\n+        final int utf8 = addUtf8(str);\n+        adjustSize();\n+        final ConstantString s = new ConstantString(utf8);\n+        ret = index;\n+        constants[index++] = s;\n+        if (!stringTable.containsKey(str)) {\n+            stringTable.put(str, new Index(ret));\n+        }\n+        return ret;\n@@ -264,0 +282,3 @@\n+    private final Map<String, Index> classTable = new HashMap<>();\n+\n+\n@@ -265,1 +286,1 @@\n-     * Add a new Class reference to the ConstantPool, if it is not already in there.\n+     * Look for ConstantClass in ConstantPool named `str'.\n@@ -267,2 +288,2 @@\n-     * @param str Class to add\n-     * @return index of entry\n+     * @param str String to search for\n+     * @return index on success, -1 otherwise\n@@ -270,2 +291,3 @@\n-    public int addClass(final String str) {\n-        return addClass_(Utility.packageToPath(str));\n+    public int lookupClass( final String str ) {\n+        final Index index = classTable.get(str.replace('.', '\/'));\n+        return (index != null) ? index.index : -1;\n@@ -274,4 +296,5 @@\n-    private int addClass_(final String clazz) {\n-        final int cpRet;\n-        if ((cpRet = lookupClass(clazz)) != -1) {\n-            return cpRet; \/\/ Already in CP\n+\n+    private int addClass_( final String clazz ) {\n+        int ret;\n+        if ((ret = lookupClass(clazz)) != -1) {\n+            return ret; \/\/ Already in CP\n@@ -281,1 +304,1 @@\n-        final int ret = index;\n+        ret = index;\n@@ -283,1 +306,4 @@\n-        return computeIfAbsent(classTable, clazz, ret);\n+        if (!classTable.containsKey(clazz)) {\n+            classTable.put(clazz, new Index(ret));\n+        }\n+        return ret;\n@@ -286,0 +312,1 @@\n+\n@@ -287,1 +314,1 @@\n-     * Adds a constant from another ConstantPool and returns the new index.\n+     * Add a new Class reference to the ConstantPool, if it is not already in there.\n@@ -289,2 +316,1 @@\n-     * @param constant The constant to add.\n-     * @param cpGen Source pool.\n+     * @param str Class to add\n@@ -293,50 +319,41 @@\n-    public int addConstant(final Constant constant, final ConstantPoolGen cpGen) {\n-        final Constant[] constants = cpGen.getConstantPool().getConstantPool();\n-        switch (constant.getTag()) {\n-        case Const.CONSTANT_String: {\n-            final ConstantString s = (ConstantString) constant;\n-            final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];\n-            return addString(u8.getBytes());\n-        }\n-        case Const.CONSTANT_Class: {\n-            final ConstantClass s = (ConstantClass) constant;\n-            final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];\n-            return addClass(u8.getBytes());\n-        }\n-        case Const.CONSTANT_NameAndType: {\n-            final ConstantNameAndType n = (ConstantNameAndType) constant;\n-            final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n-            final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n-            return addNameAndType(u8.getBytes(), u8_2.getBytes());\n-        }\n-        case Const.CONSTANT_Utf8:\n-            return addUtf8(((ConstantUtf8) constant).getBytes());\n-        case Const.CONSTANT_Double:\n-            return addDouble(((ConstantDouble) constant).getBytes());\n-        case Const.CONSTANT_Float:\n-            return addFloat(((ConstantFloat) constant).getBytes());\n-        case Const.CONSTANT_Long:\n-            return addLong(((ConstantLong) constant).getBytes());\n-        case Const.CONSTANT_Integer:\n-            return addInteger(((ConstantInteger) constant).getBytes());\n-        case Const.CONSTANT_InterfaceMethodref:\n-        case Const.CONSTANT_Methodref:\n-        case Const.CONSTANT_Fieldref: {\n-            final ConstantCP m = (ConstantCP) constant;\n-            final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n-            final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];\n-            ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];\n-            final String className = Utility.pathToPackage(u8.getBytes());\n-            u8 = (ConstantUtf8) constants[n.getNameIndex()];\n-            final String name = u8.getBytes();\n-            u8 = (ConstantUtf8) constants[n.getSignatureIndex()];\n-            final String signature = u8.getBytes();\n-            switch (constant.getTag()) {\n-            case Const.CONSTANT_InterfaceMethodref:\n-                return addInterfaceMethodref(className, name, signature);\n-            case Const.CONSTANT_Methodref:\n-                return addMethodref(className, name, signature);\n-            case Const.CONSTANT_Fieldref:\n-                return addFieldref(className, name, signature);\n-            default: \/\/ Never reached\n-                throw new IllegalArgumentException(\"Unknown constant type \" + constant);\n+    public int addClass( final String str ) {\n+        return addClass_(str.replace('.', '\/'));\n+    }\n+\n+\n+    \/**\n+     * Add a new Class reference to the ConstantPool for a given type.\n+     *\n+     * @param type Class to add\n+     * @return index of entry\n+     *\/\n+    public int addClass( final ObjectType type ) {\n+        return addClass(type.getClassName());\n+    }\n+\n+\n+    \/**\n+     * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY\n+     * instruction, e.g. to the ConstantPool.\n+     *\n+     * @param type type of array class\n+     * @return index of entry\n+     *\/\n+    public int addArrayClass( final ArrayType type ) {\n+        return addClass_(type.getSignature());\n+    }\n+\n+\n+    \/**\n+     * Look for ConstantInteger in ConstantPool.\n+     *\n+     * @param n integer number to look for\n+     * @return index on success, -1 otherwise\n+     *\/\n+    public int lookupInteger( final int n ) {\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantInteger) {\n+                final ConstantInteger c = (ConstantInteger) constants[i];\n+                if (c.getBytes() == n) {\n+                    return i;\n+                }\n@@ -345,3 +362,1 @@\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown constant type \" + constant);\n-        }\n+        return -1;\n@@ -350,0 +365,1 @@\n+\n@@ -351,1 +367,1 @@\n-     * Add a new double constant to the ConstantPool, if it is not already in there.\n+     * Add a new Integer constant to the ConstantPool, if it is not already in there.\n@@ -353,1 +369,1 @@\n-     * @param n Double number to add\n+     * @param n integer number to add\n@@ -356,1 +372,1 @@\n-    public int addDouble(final double n) {\n+    public int addInteger( final int n ) {\n@@ -358,1 +374,1 @@\n-        if ((ret = lookupDouble(n)) != -1) {\n+        if ((ret = lookupInteger(n)) != -1) {\n@@ -363,2 +379,1 @@\n-        constants[index] = new ConstantDouble(n);\n-        index += 2; \/\/ Wastes one entry according to spec\n+        constants[index++] = new ConstantInteger(n);\n@@ -368,0 +383,1 @@\n+\n@@ -369,1 +385,1 @@\n-     * Add a new Fieldref constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantFloat in ConstantPool.\n@@ -371,4 +387,2 @@\n-     * @param className class name string to add\n-     * @param fieldName field name string to add\n-     * @param signature signature string to add\n-     * @return index of entry\n+     * @param n Float number to look for\n+     * @return index on success, -1 otherwise\n@@ -376,4 +390,9 @@\n-    public int addFieldref(final String className, final String fieldName, final String signature) {\n-        final int cpRet;\n-        if ((cpRet = lookupFieldref(className, fieldName, signature)) != -1) {\n-            return cpRet; \/\/ Already in CP\n+    public int lookupFloat( final float n ) {\n+        final int bits = Float.floatToIntBits(n);\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantFloat) {\n+                final ConstantFloat c = (ConstantFloat) constants[i];\n+                if (Float.floatToIntBits(c.getBytes()) == bits) {\n+                    return i;\n+                }\n+            }\n@@ -381,6 +400,1 @@\n-        adjustSize();\n-        final int classIndex = addClass(className);\n-        final int nameAndTypeIndex = addNameAndType(fieldName, signature);\n-        final int ret = index;\n-        constants[index++] = new ConstantFieldref(classIndex, nameAndTypeIndex);\n-        return computeIfAbsent(cpTable, className + FIELDREF_DELIM + fieldName + FIELDREF_DELIM + signature, ret);\n+        return -1;\n@@ -389,0 +403,1 @@\n+\n@@ -395,1 +410,1 @@\n-    public int addFloat(final float n) {\n+    public int addFloat( final float n ) {\n@@ -406,0 +421,3 @@\n+    private final Map<String, Index> utf8Table = new HashMap<>();\n+\n+\n@@ -407,1 +425,1 @@\n-     * Add a new Integer constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantUtf8 in ConstantPool.\n@@ -409,1 +427,13 @@\n-     * @param n integer number to add\n+     * @param n Utf8 string to look for\n+     * @return index on success, -1 otherwise\n+     *\/\n+    public int lookupUtf8( final String n ) {\n+        final Index index = utf8Table.get(n);\n+        return (index != null) ? index.index : -1;\n+    }\n+\n+\n+    \/**\n+     * Add a new Utf8 constant to the ConstantPool, if it is not already in there.\n+     *\n+     * @param n Utf8 string to add\n@@ -412,1 +442,1 @@\n-    public int addInteger(final int n) {\n+    public int addUtf8( final String n ) {\n@@ -414,1 +444,1 @@\n-        if ((ret = lookupInteger(n)) != -1) {\n+        if ((ret = lookupUtf8(n)) != -1) {\n@@ -419,1 +449,4 @@\n-        constants[index++] = new ConstantInteger(n);\n+        constants[index++] = new ConstantUtf8(n);\n+        if (!utf8Table.containsKey(n)) {\n+            utf8Table.put(n, new Index(ret));\n+        }\n@@ -423,3 +456,0 @@\n-    public int addInterfaceMethodref(final MethodGen method) {\n-        return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n-    }\n@@ -428,1 +458,1 @@\n-     * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantLong in ConstantPool.\n@@ -430,4 +460,2 @@\n-     * @param className class name string to add\n-     * @param methodName method name string to add\n-     * @param signature signature string to add\n-     * @return index of entry\n+     * @param n Long number to look for\n+     * @return index on success, -1 otherwise\n@@ -435,4 +463,8 @@\n-    public int addInterfaceMethodref(final String className, final String methodName, final String signature) {\n-        final int cpRet;\n-        if ((cpRet = lookupInterfaceMethodref(className, methodName, signature)) != -1) {\n-            return cpRet; \/\/ Already in CP\n+    public int lookupLong( final long n ) {\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantLong) {\n+                final ConstantLong c = (ConstantLong) constants[i];\n+                if (c.getBytes() == n) {\n+                    return i;\n+                }\n+            }\n@@ -440,6 +472,1 @@\n-        adjustSize();\n-        final int classIndex = addClass(className);\n-        final int nameAndTypeIndex = addNameAndType(methodName, signature);\n-        final int ret = index;\n-        constants[index++] = new ConstantInterfaceMethodref(classIndex, nameAndTypeIndex);\n-        return computeIfAbsent(cpTable, className + IMETHODREF_DELIM + methodName + IMETHODREF_DELIM + signature, ret);\n+        return -1;\n@@ -448,0 +475,1 @@\n+\n@@ -454,1 +482,1 @@\n-    public int addLong(final long n) {\n+    public int addLong( final long n ) {\n@@ -465,3 +493,1 @@\n-    public int addMethodref(final MethodGen method) {\n-        return addMethodref(method.getClassName(), method.getName(), method.getSignature());\n-    }\n+\n@@ -470,1 +496,1 @@\n-     * Add a new Methodref constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantDouble in ConstantPool.\n@@ -472,4 +498,2 @@\n-     * @param className class name string to add\n-     * @param methodName method name string to add\n-     * @param signature method signature string to add\n-     * @return index of entry\n+     * @param n Double number to look for\n+     * @return index on success, -1 otherwise\n@@ -477,4 +501,9 @@\n-    public int addMethodref(final String className, final String methodName, final String signature) {\n-        final int cpRet;\n-        if ((cpRet = lookupMethodref(className, methodName, signature)) != -1) {\n-            return cpRet; \/\/ Already in CP\n+    public int lookupDouble( final double n ) {\n+        final long bits = Double.doubleToLongBits(n);\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantDouble) {\n+                final ConstantDouble c = (ConstantDouble) constants[i];\n+                if (Double.doubleToLongBits(c.getBytes()) == bits) {\n+                    return i;\n+                }\n+            }\n@@ -482,6 +511,1 @@\n-        adjustSize();\n-        final int nameAndTypeIndex = addNameAndType(methodName, signature);\n-        final int classIndex = addClass(className);\n-        final int ret = index;\n-        constants[index++] = new ConstantMethodref(classIndex, nameAndTypeIndex);\n-        return computeIfAbsent(cpTable, className + METHODREF_DELIM + methodName + METHODREF_DELIM + signature, ret);\n+        return -1;\n@@ -490,0 +514,1 @@\n+\n@@ -491,1 +516,1 @@\n-     * Add a new NameAndType constant to the ConstantPool if it is not already in there.\n+     * Add a new double constant to the ConstantPool, if it is not already in there.\n@@ -493,2 +518,1 @@\n-     * @param name Name string to add\n-     * @param signature signature string to add\n+     * @param n Double number to add\n@@ -497,1 +521,1 @@\n-    public int addNameAndType(final String name, final String signature) {\n+    public int addDouble( final double n ) {\n@@ -499,1 +523,1 @@\n-        if ((ret = lookupNameAndType(name, signature)) != -1) {\n+        if ((ret = lookupDouble(n)) != -1) {\n@@ -503,2 +527,0 @@\n-        final int nameIndex = addUtf8(name);\n-        final int signatureIndex = addUtf8(signature);\n@@ -506,2 +528,3 @@\n-        constants[index++] = new ConstantNameAndType(nameIndex, signatureIndex);\n-        return computeIfAbsent(natTable, name + NAT_DELIM + signature, ret);\n+        constants[index] = new ConstantDouble(n);\n+        index += 2; \/\/ Wastes one entry according to spec\n+        return ret;\n@@ -510,0 +533,3 @@\n+    private final Map<String, Index> natTable = new HashMap<>();\n+\n+\n@@ -511,1 +537,1 @@\n-     * Add a new String constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantNameAndType in ConstantPool.\n@@ -513,2 +539,3 @@\n-     * @param str String to add\n-     * @return index of entry\n+     * @param name of variable\/method\n+     * @param signature of variable\/method\n+     * @return index on success, -1 otherwise\n@@ -516,11 +543,3 @@\n-    public int addString(final String str) {\n-        int ret;\n-        if ((ret = lookupString(str)) != -1) {\n-            return ret; \/\/ Already in CP\n-        }\n-        final int utf8 = addUtf8(str);\n-        adjustSize();\n-        final ConstantString s = new ConstantString(utf8);\n-        ret = index;\n-        constants[index++] = s;\n-        return computeIfAbsent(stringTable, str, ret);\n+    public int lookupNameAndType( final String name, final String signature ) {\n+        final Index _index = natTable.get(name + NAT_DELIM + signature);\n+        return (_index != null) ? _index.index : -1;\n@@ -529,0 +548,1 @@\n+\n@@ -530,1 +550,2 @@\n-     * Add a new Utf8 constant to the ConstantPool, if it is not already in there.\n+     * Add a new NameAndType constant to the ConstantPool if it is not already\n+     * in there.\n@@ -532,1 +553,2 @@\n-     * @param n Utf8 string to add\n+     * @param name Name string to add\n+     * @param signature signature string to add\n@@ -535,1 +557,1 @@\n-    public int addUtf8(final String n) {\n+    public int addNameAndType( final String name, final String signature ) {\n@@ -537,1 +559,3 @@\n-        if ((ret = lookupUtf8(n)) != -1) {\n+        int name_index;\n+        int signature_index;\n+        if ((ret = lookupNameAndType(name, signature)) != -1) {\n@@ -541,0 +565,2 @@\n+        name_index = addUtf8(name);\n+        signature_index = addUtf8(signature);\n@@ -542,22 +568,4 @@\n-        constants[index++] = new ConstantUtf8(n);\n-        return computeIfAbsent(utf8Table, n, ret);\n-    }\n-\n-    \/**\n-     * Resize internal array of constants.\n-     *\/\n-    protected void adjustSize() {\n-        \/\/ 3 extra spaces are needed as some entries may take 3 slots\n-        if (index + 3 >= Const.MAX_CP_ENTRIES) {\n-            throw new IllegalStateException(\"The number of constants \" + (index + 3)\n-                    + \" is over the size limit of the constant pool: \"\n-                    + Const.MAX_CP_ENTRIES);\n-        }\n-\n-        if (index + 3 >= size) {\n-            final Constant[] cs = constants;\n-            size *= 2;\n-            \/\/ the constant array shall not exceed the size of the constant pool\n-            size = Math.min(size, Const.MAX_CP_ENTRIES);\n-            constants = new Constant[size];\n-            System.arraycopy(cs, 0, constants, 0, index);\n+        constants[index++] = new ConstantNameAndType(name_index, signature_index);\n+        final String key = name + NAT_DELIM + signature;\n+        if (!natTable.containsKey(key)) {\n+            natTable.put(key, new Index(ret));\n@@ -565,0 +573,1 @@\n+        return ret;\n@@ -567,3 +576,1 @@\n-    private int computeIfAbsent(final Map<String, Integer> map, final String key, final int value) {\n-        return map.computeIfAbsent(key, k -> Integer.valueOf(value));\n-    }\n+    private final Map<String, Index> cpTable = new HashMap<>();\n@@ -571,7 +578,0 @@\n-    \/**\n-     * @param i index in constant pool\n-     * @return constant pool entry at index i\n-     *\/\n-    public Constant getConstant(final int i) {\n-        return constants[i];\n-    }\n@@ -580,1 +580,6 @@\n-     * @return intermediate constant pool\n+     * Look for ConstantMethodref in ConstantPool.\n+     *\n+     * @param class_name Where to find method\n+     * @param method_name Guess what\n+     * @param signature return and argument types\n+     * @return index on success, -1 otherwise\n@@ -582,2 +587,4 @@\n-    public ConstantPool getConstantPool() {\n-        return new ConstantPool(constants);\n+    public int lookupMethodref( final String class_name, final String method_name, final String signature ) {\n+        final Index index = cpTable.get(class_name + METHODREF_DELIM + method_name\n+                + METHODREF_DELIM + signature);\n+        return (index != null) ? index.index : -1;\n@@ -586,6 +593,0 @@\n-    \/**\n-     * @return constant pool with proper length\n-     *\/\n-    public ConstantPool getFinalConstantPool() {\n-        return new ConstantPool(Arrays.copyOf(constants, index));\n-    }\n@@ -593,2 +594,2 @@\n-    private int getIndex(final Map<String, Integer> map, final String key) {\n-        return toIndex(map.get(key));\n+    public int lookupMethodref( final MethodGen method ) {\n+        return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());\n@@ -597,6 +598,0 @@\n-    \/**\n-     * @return current size of constant pool\n-     *\/\n-    public int getSize() {\n-        return index;\n-    }\n@@ -605,1 +600,2 @@\n-     * Look for ConstantClass in ConstantPool named 'str'.\n+     * Add a new Methodref constant to the ConstantPool, if it is not already\n+     * in there.\n@@ -607,2 +603,4 @@\n-     * @param str String to search for\n-     * @return index on success, -1 otherwise\n+     * @param class_name class name string to add\n+     * @param method_name method name string to add\n+     * @param signature method signature string to add\n+     * @return index of entry\n@@ -610,2 +608,17 @@\n-    public int lookupClass(final String str) {\n-        return getIndex(classTable, Utility.packageToPath(str));\n+    public int addMethodref( final String class_name, final String method_name, final String signature ) {\n+        int ret;\n+        int class_index;\n+        int name_and_type_index;\n+        if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {\n+            return ret; \/\/ Already in CP\n+        }\n+        adjustSize();\n+        name_and_type_index = addNameAndType(method_name, signature);\n+        class_index = addClass(class_name);\n+        ret = index;\n+        constants[index++] = new ConstantMethodref(class_index, name_and_type_index);\n+        final String key = class_name + METHODREF_DELIM + method_name + METHODREF_DELIM + signature;\n+        if (!cpTable.containsKey(key)) {\n+            cpTable.put(key, new Index(ret));\n+        }\n+        return ret;\n@@ -614,17 +627,3 @@\n-    \/**\n-     * Look for ConstantDouble in ConstantPool.\n-     *\n-     * @param n Double number to look for\n-     * @return index on success, -1 otherwise\n-     *\/\n-    public int lookupDouble(final double n) {\n-        final long bits = Double.doubleToLongBits(n);\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantDouble) {\n-                final ConstantDouble c = (ConstantDouble) constants[i];\n-                if (Double.doubleToLongBits(c.getBytes()) == bits) {\n-                    return i;\n-                }\n-            }\n-        }\n-        return -1;\n+\n+    public int addMethodref( final MethodGen method ) {\n+        return addMethodref(method.getClassName(), method.getName(), method.getSignature());\n@@ -633,0 +632,1 @@\n+\n@@ -634,1 +634,1 @@\n-     * Look for ConstantFieldref in ConstantPool.\n+     * Look for ConstantInterfaceMethodref in ConstantPool.\n@@ -636,2 +636,2 @@\n-     * @param className Where to find method\n-     * @param fieldName Guess what\n+     * @param class_name Where to find method\n+     * @param method_name Guess what\n@@ -641,2 +641,4 @@\n-    public int lookupFieldref(final String className, final String fieldName, final String signature) {\n-        return getIndex(cpTable, className + FIELDREF_DELIM + fieldName + FIELDREF_DELIM + signature);\n+    public int lookupInterfaceMethodref( final String class_name, final String method_name, final String signature ) {\n+        final Index index = cpTable.get(class_name + IMETHODREF_DELIM + method_name\n+                + IMETHODREF_DELIM + signature);\n+        return (index != null) ? index.index : -1;\n@@ -645,17 +647,4 @@\n-    \/**\n-     * Look for ConstantFloat in ConstantPool.\n-     *\n-     * @param n Float number to look for\n-     * @return index on success, -1 otherwise\n-     *\/\n-    public int lookupFloat(final float n) {\n-        final int bits = Float.floatToIntBits(n);\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantFloat) {\n-                final ConstantFloat c = (ConstantFloat) constants[i];\n-                if (Float.floatToIntBits(c.getBytes()) == bits) {\n-                    return i;\n-                }\n-            }\n-        }\n-        return -1;\n+\n+    public int lookupInterfaceMethodref( final MethodGen method ) {\n+        return lookupInterfaceMethodref(method.getClassName(), method.getName(), method\n+                .getSignature());\n@@ -664,0 +653,1 @@\n+\n@@ -665,1 +655,2 @@\n-     * Look for ConstantInteger in ConstantPool.\n+     * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already\n+     * in there.\n@@ -667,2 +658,4 @@\n-     * @param n integer number to look for\n-     * @return index on success, -1 otherwise\n+     * @param class_name class name string to add\n+     * @param method_name method name string to add\n+     * @param signature signature string to add\n+     * @return index of entry\n@@ -670,8 +663,6 @@\n-    public int lookupInteger(final int n) {\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantInteger) {\n-                final ConstantInteger c = (ConstantInteger) constants[i];\n-                if (c.getBytes() == n) {\n-                    return i;\n-                }\n-            }\n+    public int addInterfaceMethodref( final String class_name, final String method_name, final String signature ) {\n+        int ret;\n+        int class_index;\n+        int name_and_type_index;\n+        if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {\n+            return ret; \/\/ Already in CP\n@@ -679,1 +670,10 @@\n-        return -1;\n+        adjustSize();\n+        class_index = addClass(class_name);\n+        name_and_type_index = addNameAndType(method_name, signature);\n+        ret = index;\n+        constants[index++] = new ConstantInterfaceMethodref(class_index, name_and_type_index);\n+        final String key = class_name + IMETHODREF_DELIM + method_name + IMETHODREF_DELIM + signature;\n+        if (!cpTable.containsKey(key)) {\n+            cpTable.put(key, new Index(ret));\n+        }\n+        return ret;\n@@ -682,2 +682,3 @@\n-    public int lookupInterfaceMethodref(final MethodGen method) {\n-        return lookupInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n+\n+    public int addInterfaceMethodref( final MethodGen method ) {\n+        return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n@@ -686,0 +687,1 @@\n+\n@@ -687,1 +689,1 @@\n-     * Look for ConstantInterfaceMethodref in ConstantPool.\n+     * Look for ConstantFieldref in ConstantPool.\n@@ -689,2 +691,2 @@\n-     * @param className Where to find method\n-     * @param methodName Guess what\n+     * @param class_name Where to find method\n+     * @param field_name Guess what\n@@ -694,2 +696,4 @@\n-    public int lookupInterfaceMethodref(final String className, final String methodName, final String signature) {\n-        return getIndex(cpTable, className + IMETHODREF_DELIM + methodName + IMETHODREF_DELIM + signature);\n+    public int lookupFieldref( final String class_name, final String field_name, final String signature ) {\n+        final Index index = cpTable.get(class_name + FIELDREF_DELIM + field_name\n+                + FIELDREF_DELIM + signature);\n+        return (index != null) ? index.index : -1;\n@@ -698,0 +702,1 @@\n+\n@@ -699,1 +704,2 @@\n-     * Look for ConstantLong in ConstantPool.\n+     * Add a new Fieldref constant to the ConstantPool, if it is not already\n+     * in there.\n@@ -701,2 +707,4 @@\n-     * @param n Long number to look for\n-     * @return index on success, -1 otherwise\n+     * @param class_name class name string to add\n+     * @param field_name field name string to add\n+     * @param signature signature string to add\n+     * @return index of entry\n@@ -704,8 +712,6 @@\n-    public int lookupLong(final long n) {\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantLong) {\n-                final ConstantLong c = (ConstantLong) constants[i];\n-                if (c.getBytes() == n) {\n-                    return i;\n-                }\n-            }\n+    public int addFieldref( final String class_name, final String field_name, final String signature ) {\n+        int ret;\n+        int class_index;\n+        int name_and_type_index;\n+        if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {\n+            return ret; \/\/ Already in CP\n@@ -713,1 +719,10 @@\n-        return -1;\n+        adjustSize();\n+        class_index = addClass(class_name);\n+        name_and_type_index = addNameAndType(field_name, signature);\n+        ret = index;\n+        constants[index++] = new ConstantFieldref(class_index, name_and_type_index);\n+        final String key = class_name + FIELDREF_DELIM + field_name + FIELDREF_DELIM + signature;\n+        if (!cpTable.containsKey(key)) {\n+            cpTable.put(key, new Index(ret));\n+        }\n+        return ret;\n@@ -716,3 +731,0 @@\n-    public int lookupMethodref(final MethodGen method) {\n-        return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());\n-    }\n@@ -721,6 +733,2 @@\n-     * Look for ConstantMethodref in ConstantPool.\n-     *\n-     * @param className Where to find method\n-     * @param methodName Guess what\n-     * @param signature return and argument types\n-     * @return index on success, -1 otherwise\n+     * @param i index in constant pool\n+     * @return constant pool entry at index i\n@@ -728,2 +736,2 @@\n-    public int lookupMethodref(final String className, final String methodName, final String signature) {\n-        return getIndex(cpTable, className + METHODREF_DELIM + methodName + METHODREF_DELIM + signature);\n+    public Constant getConstant( final int i ) {\n+        return constants[i];\n@@ -732,0 +740,1 @@\n+\n@@ -733,1 +742,1 @@\n-     * Look for ConstantNameAndType in ConstantPool.\n+     * Use with care!\n@@ -735,3 +744,2 @@\n-     * @param name of variable\/method\n-     * @param signature of variable\/method\n-     * @return index on success, -1 otherwise\n+     * @param i index in constant pool\n+     * @param c new constant pool entry at index i\n@@ -739,2 +747,2 @@\n-    public int lookupNameAndType(final String name, final String signature) {\n-        return getIndex(natTable, name + NAT_DELIM + signature);\n+    public void setConstant( final int i, final Constant c ) {\n+        constants[i] = c;\n@@ -743,0 +751,1 @@\n+\n@@ -744,4 +753,1 @@\n-     * Look for ConstantString in ConstantPool containing String 'str'.\n-     *\n-     * @param str String to search for\n-     * @return index on success, -1 otherwise\n+     * @return intermediate constant pool\n@@ -749,2 +755,2 @@\n-    public int lookupString(final String str) {\n-        return getIndex(stringTable, str);\n+    public ConstantPool getConstantPool() {\n+        return new ConstantPool(constants);\n@@ -753,0 +759,1 @@\n+\n@@ -754,4 +761,1 @@\n-     * Look for ConstantUtf8 in ConstantPool.\n-     *\n-     * @param n Utf8 string to look for\n-     * @return index on success, -1 otherwise\n+     * @return current size of constant pool\n@@ -759,2 +763,2 @@\n-    public int lookupUtf8(final String n) {\n-        return getIndex(utf8Table, n);\n+    public int getSize() {\n+        return index;\n@@ -763,0 +767,1 @@\n+\n@@ -764,4 +769,1 @@\n-     * Use with care!\n-     *\n-     * @param i index in constant pool\n-     * @param c new constant pool entry at index i\n+     * @return constant pool with proper length\n@@ -769,2 +771,4 @@\n-    public void setConstant(final int i, final Constant c) {\n-        constants[i] = c;\n+    public ConstantPool getFinalConstantPool() {\n+        final Constant[] cs = new Constant[index];\n+        System.arraycopy(constants, 0, cs, 0, index);\n+        return new ConstantPool(cs);\n@@ -773,3 +777,0 @@\n-    private int toIndex(final Integer index) {\n-        return index != null ? index.intValue() : -1;\n-    }\n@@ -788,0 +789,60 @@\n+\n+\n+    \/** Import constant from another ConstantPool and return new index.\n+     *\/\n+    public int addConstant( final Constant c, final ConstantPoolGen cp ) {\n+        final Constant[] constants = cp.getConstantPool().getConstantPool();\n+        switch (c.getTag()) {\n+            case Const.CONSTANT_String: {\n+                final ConstantString s = (ConstantString) c;\n+                final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];\n+                return addString(u8.getBytes());\n+            }\n+            case Const.CONSTANT_Class: {\n+                final ConstantClass s = (ConstantClass) c;\n+                final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];\n+                return addClass(u8.getBytes());\n+            }\n+            case Const.CONSTANT_NameAndType: {\n+                final ConstantNameAndType n = (ConstantNameAndType) c;\n+                final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n+                final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n+                return addNameAndType(u8.getBytes(), u8_2.getBytes());\n+            }\n+            case Const.CONSTANT_Utf8:\n+                return addUtf8(((ConstantUtf8) c).getBytes());\n+            case Const.CONSTANT_Double:\n+                return addDouble(((ConstantDouble) c).getBytes());\n+            case Const.CONSTANT_Float:\n+                return addFloat(((ConstantFloat) c).getBytes());\n+            case Const.CONSTANT_Long:\n+                return addLong(((ConstantLong) c).getBytes());\n+            case Const.CONSTANT_Integer:\n+                return addInteger(((ConstantInteger) c).getBytes());\n+            case Const.CONSTANT_InterfaceMethodref:\n+            case Const.CONSTANT_Methodref:\n+            case Const.CONSTANT_Fieldref: {\n+                final ConstantCP m = (ConstantCP) c;\n+                final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n+                final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];\n+                ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];\n+                final String class_name = u8.getBytes().replace('\/', '.');\n+                u8 = (ConstantUtf8) constants[n.getNameIndex()];\n+                final String name = u8.getBytes();\n+                u8 = (ConstantUtf8) constants[n.getSignatureIndex()];\n+                final String signature = u8.getBytes();\n+                switch (c.getTag()) {\n+                    case Const.CONSTANT_InterfaceMethodref:\n+                        return addInterfaceMethodref(class_name, name, signature);\n+                    case Const.CONSTANT_Methodref:\n+                        return addMethodref(class_name, name, signature);\n+                    case Const.CONSTANT_Fieldref:\n+                        return addFieldref(class_name, name, signature);\n+                    default: \/\/ Never reached\n+                        throw new IllegalArgumentException(\"Unknown constant type \" + c);\n+                }\n+            }\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown constant type \" + c);\n+        }\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConstantPoolGen.java","additions":485,"deletions":424,"binary":false,"changes":909,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Denotes a push instruction that produces a literal on the stack such as SIPUSH, BIPUSH, ICONST, etc.\n- *\n+ * Denotes a push instruction that produces a literal on the stack\n+ * such as  SIPUSH, BIPUSH, ICONST, etc.\n@@ -28,0 +28,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConstantPushInstruction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -29,1 +30,2 @@\n-public abstract class ConversionInstruction extends Instruction implements TypedInstruction, StackProducer, StackConsumer {\n+public abstract class ConversionInstruction extends Instruction implements TypedInstruction,\n+        StackProducer, StackConsumer {\n@@ -32,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,0 +40,1 @@\n+\n@@ -44,2 +48,2 @@\n-    \/**\n-     * @return type associated with the instruction\n+\n+    \/** @return type associated with the instruction\n@@ -48,27 +52,27 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        final short opcode = super.getOpcode();\n-        switch (opcode) {\n-        case Const.D2I:\n-        case Const.F2I:\n-        case Const.L2I:\n-            return Type.INT;\n-        case Const.D2F:\n-        case Const.I2F:\n-        case Const.L2F:\n-            return Type.FLOAT;\n-        case Const.D2L:\n-        case Const.F2L:\n-        case Const.I2L:\n-            return Type.LONG;\n-        case Const.F2D:\n-        case Const.I2D:\n-        case Const.L2D:\n-            return Type.DOUBLE;\n-        case Const.I2B:\n-            return Type.BYTE;\n-        case Const.I2C:\n-            return Type.CHAR;\n-        case Const.I2S:\n-            return Type.SHORT;\n-        default: \/\/ Never reached\n-            throw new ClassGenException(\"Unknown type \" + opcode);\n+    public Type getType( final ConstantPoolGen cp ) {\n+        final short _opcode = super.getOpcode();\n+        switch (_opcode) {\n+            case Const.D2I:\n+            case Const.F2I:\n+            case Const.L2I:\n+                return Type.INT;\n+            case Const.D2F:\n+            case Const.I2F:\n+            case Const.L2F:\n+                return Type.FLOAT;\n+            case Const.D2L:\n+            case Const.F2L:\n+            case Const.I2L:\n+                return Type.LONG;\n+            case Const.F2D:\n+            case Const.I2D:\n+            case Const.L2D:\n+                return Type.DOUBLE;\n+            case Const.I2B:\n+                return Type.BYTE;\n+            case Const.I2C:\n+                return Type.CHAR;\n+            case Const.I2S:\n+                return Type.SHORT;\n+            default: \/\/ Never reached\n+                throw new ClassGenException(\"Unknown type \" + _opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConversionInstruction.java","additions":35,"deletions":31,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert double to float\n+    \/** Convert double to float\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2F.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert double to int\n+    \/** Convert double to int\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2I.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert double to long\n+    \/** Convert double to long\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result1.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result1.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Add doubles\n+    \/** Add doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DADD.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load double from array\n+    \/** Load double from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * DASTORE - Store into double array\n+ * DASTORE -  Store into double array\n+ * <PRE>Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store double into array\n+    \/** Store double into array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,7 @@\n+    \/** @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.DOUBLE;\n+    }\n+\n@@ -38,2 +43,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +51,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -50,8 +57,0 @@\n-\n-    \/**\n-     * @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.DOUBLE;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCMPG.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,7 @@\n+    \/** @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.DOUBLE;\n+    }\n+\n@@ -38,2 +43,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +51,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -50,8 +57,0 @@\n-\n-    \/**\n-     * @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.DOUBLE;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCMPL.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,3 +26,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ...,\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., <\/PRE>\n+ *\n@@ -33,1 +32,2 @@\n-    private final double value;\n+    private double value;\n+\n@@ -36,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,1 +40,0 @@\n-        this(0);\n@@ -42,0 +42,1 @@\n+\n@@ -54,0 +55,15 @@\n+\n+    @Override\n+    public Number getValue() {\n+        return value;\n+    }\n+\n+\n+    \/** @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.DOUBLE;\n+    }\n+\n+\n@@ -55,2 +71,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -61,1 +79,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -68,13 +86,0 @@\n-\n-    \/**\n-     * @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.DOUBLE;\n-    }\n-\n-    @Override\n-    public Number getValue() {\n-        return Double.valueOf(value);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCONST.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * DDIV - Divide doubles\n+ * DDIV -  Divide doubles\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Divide doubles\n+    \/** Divide doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DDIV.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack ... -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack ... -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Load double from local variable\n-     *\n+\n+    \/** Load double from local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DLOAD.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Multiply doubles\n+    \/** Multiply doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DMUL.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DNEG.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Remainder of doubles\n+    \/** Remainder of doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DREM.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * DRETURN - Return double from method\n+ * DRETURN -  Return double from method\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Return double from method\n+    \/** Return double from method\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <pre>Stack: ..., value.word1, value.word2 -&gt; ... <\/PRE>\n@@ -27,3 +28,0 @@\n- * <pre>\n- * Stack: ..., value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Store double into local variable\n-     *\n+\n+    \/** Store double into local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DSTORE.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Substract doubles\n+    \/** Substract doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DSUB.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word -&gt; ..., word, word<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word -&gt; ..., word, word\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word2, word1 -&gt; ..., word2, word1, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word2, word1 -&gt; ..., word2, word1, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word3, word2, word1 -&gt; ..., word2, word1, word3, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word3, word2, word1 -&gt; ..., word2, word1, word3, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2_X1.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word4, word3, word2, word1 -&gt; ..., word2, word1, word4, word3, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word4, word3, word2, word1 -&gt; ..., word2, word1, word4, word3, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2_X2.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word2, word1 -&gt; ..., word1, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word2, word1 -&gt; ..., word1, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP_X1.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word3, word2, word1 -&gt; ..., word1, word3, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word3, word2, word1 -&gt; ..., word1, word3, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP_X2.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,25 @@\n-public abstract class ElementValueGen {\n+public abstract class ElementValueGen\n+{\n+    private final int type;\n+    private final ConstantPoolGen cpGen;\n+\n+    protected ElementValueGen(final int type, final ConstantPoolGen cpGen)\n+    {\n+        this.type = type;\n+        this.cpGen = cpGen;\n+    }\n+\n+    \/**\n+     * Subtypes return an immutable variant of the ElementValueGen\n+     *\/\n+    public abstract ElementValue getElementValue();\n+\n+    public int getElementValueType()\n+    {\n+        return type;\n+    }\n+\n+    public abstract String stringifyValue();\n+\n+    public abstract void dump(DataOutputStream dos) throws IOException;\n+\n@@ -66,29 +90,3 @@\n-    \/**\n-     * Creates an (modifiable) ElementValueGen copy of an (immutable) ElementValue - constant pool is assumed correct.\n-     *\/\n-    public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        switch (value.getElementValueType()) {\n-        case 'B': \/\/ byte\n-        case 'C': \/\/ char\n-        case 'D': \/\/ double\n-        case 'F': \/\/ float\n-        case 'I': \/\/ int\n-        case 'J': \/\/ long\n-        case 'S': \/\/ short\n-        case 'Z': \/\/ boolean\n-        case 's': \/\/ String\n-            return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);\n-        case 'e': \/\/ Enum constant\n-            return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);\n-        case '@': \/\/ Annotation\n-            return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);\n-        case '[': \/\/ Array\n-            return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);\n-        case 'c': \/\/ Class\n-            return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);\n-        default:\n-            throw new UnsupportedOperationException(\"Not implemented yet! (\" + value.getElementValueType() + \")\");\n-        }\n-    }\n-\n-    public static ElementValueGen readElementValue(final DataInput dis, final ConstantPoolGen cpGen) throws IOException {\n+    public static ElementValueGen readElementValue(final DataInput dis,\n+            final ConstantPoolGen cpGen) throws IOException\n+    {\n@@ -96,1 +94,2 @@\n-        switch (type) {\n+        switch (type)\n+        {\n@@ -98,1 +97,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_BYTE, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_BYTE, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -100,1 +100,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_CHAR, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_CHAR, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -102,1 +103,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_DOUBLE, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_DOUBLE, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -104,1 +106,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_FLOAT, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_FLOAT, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -106,1 +109,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_INT, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_INT, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -108,1 +112,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_LONG, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_LONG, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -110,1 +115,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_SHORT, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_SHORT, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -112,1 +118,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_BOOLEAN, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_BOOLEAN, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -114,1 +121,2 @@\n-            return new SimpleElementValueGen(STRING, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(STRING, dis.readUnsignedShort(),\n+                    cpGen);\n@@ -116,1 +124,2 @@\n-            return new EnumElementValueGen(dis.readUnsignedShort(), dis.readUnsignedShort(), cpGen);\n+            return new EnumElementValueGen(dis.readUnsignedShort(), dis\n+                    .readUnsignedShort(), cpGen);\n@@ -122,2 +131,3 @@\n-            return new AnnotationElementValueGen(ANNOTATION, new AnnotationEntryGen(AnnotationEntry.read(dis, cpGen.getConstantPool(), true), cpGen, false),\n-                cpGen);\n+            return new AnnotationElementValueGen(ANNOTATION,\n+                    new AnnotationEntryGen(AnnotationEntry.read(dis, cpGen\n+                            .getConstantPool(), true), cpGen, false), cpGen);\n@@ -127,2 +137,4 @@\n-            for (int j = 0; j < numArrayVals; j++) {\n-                evalues[j] = ElementValue.readElementValue(dis, cpGen.getConstantPool());\n+            for (int j = 0; j < numArrayVals; j++)\n+            {\n+                evalues[j] = ElementValue.readElementValue(dis, cpGen\n+                        .getConstantPool());\n@@ -136,20 +148,2 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n-     *\/\n-    @Deprecated\n-    protected int type;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n-     *\/\n-    @Deprecated\n-    protected ConstantPoolGen cpGen;\n-\n-    protected ElementValueGen(final int type, final ConstantPoolGen cpGen) {\n-        this.type = type;\n-        this.cpGen = cpGen;\n-    }\n-\n-    public abstract void dump(DataOutputStream dos) throws IOException;\n-\n-    protected ConstantPoolGen getConstantPool() {\n+    protected ConstantPoolGen getConstantPool()\n+    {\n@@ -160,1 +154,2 @@\n-     * Subtypes return an immutable variant of the ElementValueGen\n+     * Creates an (modifiable) ElementValueGen copy of an (immutable)\n+     * ElementValue - constant pool is assumed correct.\n@@ -162,4 +157,31 @@\n-    public abstract ElementValue getElementValue();\n-\n-    public int getElementValueType() {\n-        return type;\n+    public static ElementValueGen copy(final ElementValue value,\n+            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n+    {\n+        switch (value.getElementValueType())\n+        {\n+        case 'B': \/\/ byte\n+        case 'C': \/\/ char\n+        case 'D': \/\/ double\n+        case 'F': \/\/ float\n+        case 'I': \/\/ int\n+        case 'J': \/\/ long\n+        case 'S': \/\/ short\n+        case 'Z': \/\/ boolean\n+        case 's': \/\/ String\n+            return new SimpleElementValueGen((SimpleElementValue) value, cpool,\n+                    copyPoolEntries);\n+        case 'e': \/\/ Enum constant\n+            return new EnumElementValueGen((EnumElementValue) value, cpool,\n+                    copyPoolEntries);\n+        case '@': \/\/ Annotation\n+            return new AnnotationElementValueGen(\n+                    (AnnotationElementValue) value, cpool, copyPoolEntries);\n+        case '[': \/\/ Array\n+            return new ArrayElementValueGen((ArrayElementValue) value, cpool,\n+                    copyPoolEntries);\n+        case 'c': \/\/ Class\n+            return new ClassElementValueGen((ClassElementValue) value, cpool,\n+                    copyPoolEntries);\n+        default:\n+            throw new UnsupportedOperationException(\"Not implemented yet! (\" + value.getElementValueType() + \")\");\n+        }\n@@ -167,2 +189,0 @@\n-\n-    public abstract String stringifyValue();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ElementValueGen.java","additions":92,"deletions":72,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -34,2 +34,3 @@\n-public class ElementValuePairGen {\n-    private final int nameIdx;\n+public class ElementValuePairGen\n+{\n+    private int nameIdx;\n@@ -41,1 +42,3 @@\n-    public ElementValuePairGen(final ElementValuePair nvp, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+    public ElementValuePairGen(final ElementValuePair nvp, final ConstantPoolGen cpool,\n+            final boolean copyPoolEntries)\n+    {\n@@ -51,1 +54,2 @@\n-        if (copyPoolEntries) {\n+        if (copyPoolEntries)\n+        {\n@@ -53,1 +57,3 @@\n-        } else {\n+        }\n+        else\n+        {\n@@ -59,1 +65,13 @@\n-    protected ElementValuePairGen(final int idx, final ElementValueGen value, final ConstantPoolGen cpool) {\n+    \/**\n+     * Retrieve an immutable version of this ElementNameValuePairGen\n+     *\/\n+    public ElementValuePair getElementNameValuePair()\n+    {\n+        final ElementValue immutableValue = value.getElementValue();\n+        return new ElementValuePair(nameIdx, immutableValue, constantPoolGen\n+                .getConstantPool());\n+    }\n+\n+    protected ElementValuePairGen(final int idx, final ElementValueGen value,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -65,1 +83,3 @@\n-    public ElementValuePairGen(final String name, final ElementValueGen value, final ConstantPoolGen cpool) {\n+    public ElementValuePairGen(final String name, final ElementValueGen value,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -71,1 +91,2 @@\n-    protected void dump(final DataOutputStream dos) throws IOException {\n+    protected void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -76,9 +97,2 @@\n-    \/**\n-     * Retrieve an immutable version of this ElementNameValuePairGen\n-     *\/\n-    public ElementValuePair getElementNameValuePair() {\n-        final ElementValue immutableValue = value.getElementValue();\n-        return new ElementValuePair(nameIdx, immutableValue, constantPoolGen.getConstantPool());\n-    }\n-\n-    public int getNameIndex() {\n+    public int getNameIndex()\n+    {\n@@ -88,1 +102,2 @@\n-    public final String getNameString() {\n+    public final String getNameString()\n+    {\n@@ -93,1 +108,2 @@\n-    public final ElementValueGen getValue() {\n+    public final ElementValueGen getValue()\n+    {\n@@ -98,2 +114,4 @@\n-    public String toString() {\n-        return \"ElementValuePair:[\" + getNameString() + \"=\" + value.stringifyValue() + \"]\";\n+    public String toString()\n+    {\n+        return \"ElementValuePair:[\" + getNameString() + \"=\"\n+                + value.stringifyValue() + \"]\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ElementValuePairGen.java","additions":39,"deletions":21,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -30,1 +31,1 @@\n-    public void visitAALOAD(final AALOAD obj) {\n+    public void visitStackInstruction( final StackInstruction obj ) {\n@@ -33,0 +34,1 @@\n+\n@@ -34,1 +36,1 @@\n-    public void visitAASTORE(final AASTORE obj) {\n+    public void visitLocalVariableInstruction( final LocalVariableInstruction obj ) {\n@@ -37,0 +39,1 @@\n+\n@@ -38,1 +41,1 @@\n-    public void visitACONST_NULL(final ACONST_NULL obj) {\n+    public void visitBranchInstruction( final BranchInstruction obj ) {\n@@ -41,0 +44,1 @@\n+\n@@ -42,1 +46,1 @@\n-    public void visitAllocationInstruction(final AllocationInstruction obj) {\n+    public void visitLoadClass( final LoadClass obj ) {\n@@ -45,0 +49,1 @@\n+\n@@ -46,1 +51,1 @@\n-    public void visitALOAD(final ALOAD obj) {\n+    public void visitFieldInstruction( final FieldInstruction obj ) {\n@@ -49,0 +54,1 @@\n+\n@@ -50,1 +56,1 @@\n-    public void visitANEWARRAY(final ANEWARRAY obj) {\n+    public void visitIfInstruction( final IfInstruction obj ) {\n@@ -53,0 +59,1 @@\n+\n@@ -54,1 +61,1 @@\n-    public void visitARETURN(final ARETURN obj) {\n+    public void visitConversionInstruction( final ConversionInstruction obj ) {\n@@ -57,0 +64,1 @@\n+\n@@ -58,1 +66,1 @@\n-    public void visitArithmeticInstruction(final ArithmeticInstruction obj) {\n+    public void visitPopInstruction( final PopInstruction obj ) {\n@@ -61,0 +69,1 @@\n+\n@@ -62,1 +71,1 @@\n-    public void visitArrayInstruction(final ArrayInstruction obj) {\n+    public void visitJsrInstruction( final JsrInstruction obj ) {\n@@ -65,0 +74,1 @@\n+\n@@ -66,1 +76,1 @@\n-    public void visitARRAYLENGTH(final ARRAYLENGTH obj) {\n+    public void visitGotoInstruction( final GotoInstruction obj ) {\n@@ -69,0 +79,1 @@\n+\n@@ -70,1 +81,1 @@\n-    public void visitASTORE(final ASTORE obj) {\n+    public void visitStoreInstruction( final StoreInstruction obj ) {\n@@ -73,0 +84,1 @@\n+\n@@ -74,1 +86,1 @@\n-    public void visitATHROW(final ATHROW obj) {\n+    public void visitTypedInstruction( final TypedInstruction obj ) {\n@@ -77,0 +89,1 @@\n+\n@@ -78,1 +91,1 @@\n-    public void visitBALOAD(final BALOAD obj) {\n+    public void visitSelect( final Select obj ) {\n@@ -81,0 +94,1 @@\n+\n@@ -82,1 +96,1 @@\n-    public void visitBASTORE(final BASTORE obj) {\n+    public void visitUnconditionalBranch( final UnconditionalBranch obj ) {\n@@ -85,0 +99,1 @@\n+\n@@ -86,1 +101,1 @@\n-    public void visitBIPUSH(final BIPUSH obj) {\n+    public void visitPushInstruction( final PushInstruction obj ) {\n@@ -89,0 +104,1 @@\n+\n@@ -90,1 +106,1 @@\n-    public void visitBranchInstruction(final BranchInstruction obj) {\n+    public void visitArithmeticInstruction( final ArithmeticInstruction obj ) {\n@@ -93,0 +109,1 @@\n+\n@@ -94,1 +111,1 @@\n-    public void visitBREAKPOINT(final BREAKPOINT obj) {\n+    public void visitCPInstruction( final CPInstruction obj ) {\n@@ -97,0 +114,1 @@\n+\n@@ -98,1 +116,1 @@\n-    public void visitCALOAD(final CALOAD obj) {\n+    public void visitInvokeInstruction( final InvokeInstruction obj ) {\n@@ -101,0 +119,1 @@\n+\n@@ -102,1 +121,1 @@\n-    public void visitCASTORE(final CASTORE obj) {\n+    public void visitArrayInstruction( final ArrayInstruction obj ) {\n@@ -105,0 +124,1 @@\n+\n@@ -106,1 +126,1 @@\n-    public void visitCHECKCAST(final CHECKCAST obj) {\n+    public void visitAllocationInstruction( final AllocationInstruction obj ) {\n@@ -109,0 +129,1 @@\n+\n@@ -110,1 +131,1 @@\n-    public void visitConstantPushInstruction(final ConstantPushInstruction obj) {\n+    public void visitReturnInstruction( final ReturnInstruction obj ) {\n@@ -113,0 +134,1 @@\n+\n@@ -114,1 +136,1 @@\n-    public void visitConversionInstruction(final ConversionInstruction obj) {\n+    public void visitFieldOrMethod( final FieldOrMethod obj ) {\n@@ -117,0 +139,1 @@\n+\n@@ -118,1 +141,1 @@\n-    public void visitCPInstruction(final CPInstruction obj) {\n+    public void visitConstantPushInstruction( final ConstantPushInstruction obj ) {\n@@ -121,0 +144,1 @@\n+\n@@ -122,1 +146,1 @@\n-    public void visitD2F(final D2F obj) {\n+    public void visitExceptionThrower( final ExceptionThrower obj ) {\n@@ -125,0 +149,1 @@\n+\n@@ -126,1 +151,1 @@\n-    public void visitD2I(final D2I obj) {\n+    public void visitLoadInstruction( final LoadInstruction obj ) {\n@@ -129,0 +154,1 @@\n+\n@@ -130,1 +156,1 @@\n-    public void visitD2L(final D2L obj) {\n+    public void visitVariableLengthInstruction( final VariableLengthInstruction obj ) {\n@@ -133,0 +159,1 @@\n+\n@@ -134,1 +161,1 @@\n-    public void visitDADD(final DADD obj) {\n+    public void visitStackProducer( final StackProducer obj ) {\n@@ -137,0 +164,1 @@\n+\n@@ -138,1 +166,1 @@\n-    public void visitDALOAD(final DALOAD obj) {\n+    public void visitStackConsumer( final StackConsumer obj ) {\n@@ -141,0 +169,1 @@\n+\n@@ -142,1 +171,1 @@\n-    public void visitDASTORE(final DASTORE obj) {\n+    public void visitACONST_NULL( final ACONST_NULL obj ) {\n@@ -145,0 +174,1 @@\n+\n@@ -146,1 +176,1 @@\n-    public void visitDCMPG(final DCMPG obj) {\n+    public void visitGETSTATIC( final GETSTATIC obj ) {\n@@ -149,0 +179,1 @@\n+\n@@ -150,1 +181,1 @@\n-    public void visitDCMPL(final DCMPL obj) {\n+    public void visitIF_ICMPLT( final IF_ICMPLT obj ) {\n@@ -153,0 +184,1 @@\n+\n@@ -154,1 +186,1 @@\n-    public void visitDCONST(final DCONST obj) {\n+    public void visitMONITOREXIT( final MONITOREXIT obj ) {\n@@ -157,0 +189,1 @@\n+\n@@ -158,1 +191,1 @@\n-    public void visitDDIV(final DDIV obj) {\n+    public void visitIFLT( final IFLT obj ) {\n@@ -161,0 +194,1 @@\n+\n@@ -162,1 +196,1 @@\n-    public void visitDLOAD(final DLOAD obj) {\n+    public void visitLSTORE( final LSTORE obj ) {\n@@ -165,0 +199,1 @@\n+\n@@ -166,1 +201,1 @@\n-    public void visitDMUL(final DMUL obj) {\n+    public void visitPOP2( final POP2 obj ) {\n@@ -169,0 +204,1 @@\n+\n@@ -170,1 +206,1 @@\n-    public void visitDNEG(final DNEG obj) {\n+    public void visitBASTORE( final BASTORE obj ) {\n@@ -173,0 +209,1 @@\n+\n@@ -174,1 +211,1 @@\n-    public void visitDREM(final DREM obj) {\n+    public void visitISTORE( final ISTORE obj ) {\n@@ -177,0 +214,1 @@\n+\n@@ -178,1 +216,1 @@\n-    public void visitDRETURN(final DRETURN obj) {\n+    public void visitCHECKCAST( final CHECKCAST obj ) {\n@@ -181,0 +219,1 @@\n+\n@@ -182,1 +221,1 @@\n-    public void visitDSTORE(final DSTORE obj) {\n+    public void visitFCMPG( final FCMPG obj ) {\n@@ -185,0 +224,1 @@\n+\n@@ -186,1 +226,1 @@\n-    public void visitDSUB(final DSUB obj) {\n+    public void visitI2F( final I2F obj ) {\n@@ -189,0 +229,1 @@\n+\n@@ -190,1 +231,1 @@\n-    public void visitDUP(final DUP obj) {\n+    public void visitATHROW( final ATHROW obj ) {\n@@ -193,0 +234,1 @@\n+\n@@ -194,1 +236,1 @@\n-    public void visitDUP_X1(final DUP_X1 obj) {\n+    public void visitDCMPL( final DCMPL obj ) {\n@@ -197,0 +239,1 @@\n+\n@@ -198,1 +241,1 @@\n-    public void visitDUP_X2(final DUP_X2 obj) {\n+    public void visitARRAYLENGTH( final ARRAYLENGTH obj ) {\n@@ -201,0 +244,1 @@\n+\n@@ -202,1 +246,1 @@\n-    public void visitDUP2(final DUP2 obj) {\n+    public void visitDUP( final DUP obj ) {\n@@ -205,0 +249,1 @@\n+\n@@ -206,1 +251,1 @@\n-    public void visitDUP2_X1(final DUP2_X1 obj) {\n+    public void visitINVOKESTATIC( final INVOKESTATIC obj ) {\n@@ -209,0 +254,1 @@\n+\n@@ -210,1 +256,1 @@\n-    public void visitDUP2_X2(final DUP2_X2 obj) {\n+    public void visitLCONST( final LCONST obj ) {\n@@ -213,0 +259,1 @@\n+\n@@ -214,1 +261,1 @@\n-    public void visitExceptionThrower(final ExceptionThrower obj) {\n+    public void visitDREM( final DREM obj ) {\n@@ -217,0 +264,1 @@\n+\n@@ -218,1 +266,1 @@\n-    public void visitF2D(final F2D obj) {\n+    public void visitIFGE( final IFGE obj ) {\n@@ -221,0 +269,1 @@\n+\n@@ -222,1 +271,1 @@\n-    public void visitF2I(final F2I obj) {\n+    public void visitCALOAD( final CALOAD obj ) {\n@@ -225,0 +274,1 @@\n+\n@@ -226,1 +276,1 @@\n-    public void visitF2L(final F2L obj) {\n+    public void visitLASTORE( final LASTORE obj ) {\n@@ -229,0 +279,1 @@\n+\n@@ -230,1 +281,1 @@\n-    public void visitFADD(final FADD obj) {\n+    public void visitI2D( final I2D obj ) {\n@@ -233,0 +284,1 @@\n+\n@@ -234,1 +286,1 @@\n-    public void visitFALOAD(final FALOAD obj) {\n+    public void visitDADD( final DADD obj ) {\n@@ -237,0 +289,1 @@\n+\n@@ -238,1 +291,1 @@\n-    public void visitFASTORE(final FASTORE obj) {\n+    public void visitINVOKESPECIAL( final INVOKESPECIAL obj ) {\n@@ -241,0 +294,1 @@\n+\n@@ -242,1 +296,1 @@\n-    public void visitFCMPG(final FCMPG obj) {\n+    public void visitIAND( final IAND obj ) {\n@@ -245,0 +299,1 @@\n+\n@@ -246,1 +301,1 @@\n-    public void visitFCMPL(final FCMPL obj) {\n+    public void visitPUTFIELD( final PUTFIELD obj ) {\n@@ -249,0 +304,1 @@\n+\n@@ -250,1 +306,1 @@\n-    public void visitFCONST(final FCONST obj) {\n+    public void visitILOAD( final ILOAD obj ) {\n@@ -253,0 +309,1 @@\n+\n@@ -254,1 +311,1 @@\n-    public void visitFDIV(final FDIV obj) {\n+    public void visitDLOAD( final DLOAD obj ) {\n@@ -257,0 +314,1 @@\n+\n@@ -258,1 +316,1 @@\n-    public void visitFieldInstruction(final FieldInstruction obj) {\n+    public void visitDCONST( final DCONST obj ) {\n@@ -261,0 +319,1 @@\n+\n@@ -262,1 +321,1 @@\n-    public void visitFieldOrMethod(final FieldOrMethod obj) {\n+    public void visitNEW( final NEW obj ) {\n@@ -265,0 +324,1 @@\n+\n@@ -266,1 +326,1 @@\n-    public void visitFLOAD(final FLOAD obj) {\n+    public void visitIFNULL( final IFNULL obj ) {\n@@ -269,0 +329,1 @@\n+\n@@ -270,1 +331,1 @@\n-    public void visitFMUL(final FMUL obj) {\n+    public void visitLSUB( final LSUB obj ) {\n@@ -273,0 +334,1 @@\n+\n@@ -274,1 +336,1 @@\n-    public void visitFNEG(final FNEG obj) {\n+    public void visitL2I( final L2I obj ) {\n@@ -277,0 +339,1 @@\n+\n@@ -278,1 +341,1 @@\n-    public void visitFREM(final FREM obj) {\n+    public void visitISHR( final ISHR obj ) {\n@@ -281,0 +344,1 @@\n+\n@@ -282,1 +346,1 @@\n-    public void visitFRETURN(final FRETURN obj) {\n+    public void visitTABLESWITCH( final TABLESWITCH obj ) {\n@@ -285,0 +349,1 @@\n+\n@@ -286,1 +351,1 @@\n-    public void visitFSTORE(final FSTORE obj) {\n+    public void visitIINC( final IINC obj ) {\n@@ -289,0 +354,1 @@\n+\n@@ -290,1 +356,1 @@\n-    public void visitFSUB(final FSUB obj) {\n+    public void visitDRETURN( final DRETURN obj ) {\n@@ -293,0 +359,1 @@\n+\n@@ -294,1 +361,1 @@\n-    public void visitGETFIELD(final GETFIELD obj) {\n+    public void visitFSTORE( final FSTORE obj ) {\n@@ -297,0 +364,1 @@\n+\n@@ -298,1 +366,1 @@\n-    public void visitGETSTATIC(final GETSTATIC obj) {\n+    public void visitDASTORE( final DASTORE obj ) {\n@@ -301,0 +369,1 @@\n+\n@@ -302,1 +371,1 @@\n-    public void visitGOTO(final GOTO obj) {\n+    public void visitIALOAD( final IALOAD obj ) {\n@@ -305,0 +374,1 @@\n+\n@@ -306,1 +376,1 @@\n-    public void visitGOTO_W(final GOTO_W obj) {\n+    public void visitDDIV( final DDIV obj ) {\n@@ -309,0 +379,1 @@\n+\n@@ -310,1 +381,1 @@\n-    public void visitGotoInstruction(final GotoInstruction obj) {\n+    public void visitIF_ICMPGE( final IF_ICMPGE obj ) {\n@@ -313,0 +384,1 @@\n+\n@@ -314,1 +386,1 @@\n-    public void visitI2B(final I2B obj) {\n+    public void visitLAND( final LAND obj ) {\n@@ -317,0 +389,1 @@\n+\n@@ -318,1 +391,1 @@\n-    public void visitI2C(final I2C obj) {\n+    public void visitIDIV( final IDIV obj ) {\n@@ -321,0 +394,1 @@\n+\n@@ -322,1 +396,1 @@\n-    public void visitI2D(final I2D obj) {\n+    public void visitLOR( final LOR obj ) {\n@@ -325,0 +399,1 @@\n+\n@@ -326,1 +401,1 @@\n-    public void visitI2F(final I2F obj) {\n+    public void visitCASTORE( final CASTORE obj ) {\n@@ -329,0 +404,1 @@\n+\n@@ -330,1 +406,1 @@\n-    public void visitI2L(final I2L obj) {\n+    public void visitFREM( final FREM obj ) {\n@@ -333,0 +409,1 @@\n+\n@@ -334,1 +411,1 @@\n-    public void visitI2S(final I2S obj) {\n+    public void visitLDC( final LDC obj ) {\n@@ -337,0 +414,1 @@\n+\n@@ -338,1 +416,1 @@\n-    public void visitIADD(final IADD obj) {\n+    public void visitBIPUSH( final BIPUSH obj ) {\n@@ -341,0 +419,1 @@\n+\n@@ -342,1 +421,1 @@\n-    public void visitIALOAD(final IALOAD obj) {\n+    public void visitDSTORE( final DSTORE obj ) {\n@@ -345,0 +424,1 @@\n+\n@@ -346,1 +426,1 @@\n-    public void visitIAND(final IAND obj) {\n+    public void visitF2L( final F2L obj ) {\n@@ -349,0 +429,1 @@\n+\n@@ -350,1 +431,1 @@\n-    public void visitIASTORE(final IASTORE obj) {\n+    public void visitFMUL( final FMUL obj ) {\n@@ -353,0 +434,1 @@\n+\n@@ -354,1 +436,1 @@\n-    public void visitICONST(final ICONST obj) {\n+    public void visitLLOAD( final LLOAD obj ) {\n@@ -357,0 +439,1 @@\n+\n@@ -358,1 +441,1 @@\n-    public void visitIDIV(final IDIV obj) {\n+    public void visitJSR( final JSR obj ) {\n@@ -361,0 +444,1 @@\n+\n@@ -362,1 +446,1 @@\n-    public void visitIF_ACMPEQ(final IF_ACMPEQ obj) {\n+    public void visitFSUB( final FSUB obj ) {\n@@ -365,0 +449,1 @@\n+\n@@ -366,1 +451,1 @@\n-    public void visitIF_ACMPNE(final IF_ACMPNE obj) {\n+    public void visitSASTORE( final SASTORE obj ) {\n@@ -369,0 +454,1 @@\n+\n@@ -370,1 +456,1 @@\n-    public void visitIF_ICMPEQ(final IF_ICMPEQ obj) {\n+    public void visitALOAD( final ALOAD obj ) {\n@@ -373,0 +459,1 @@\n+\n@@ -374,1 +461,1 @@\n-    public void visitIF_ICMPGE(final IF_ICMPGE obj) {\n+    public void visitDUP2_X2( final DUP2_X2 obj ) {\n@@ -377,0 +464,1 @@\n+\n@@ -378,1 +466,1 @@\n-    public void visitIF_ICMPGT(final IF_ICMPGT obj) {\n+    public void visitRETURN( final RETURN obj ) {\n@@ -381,0 +469,1 @@\n+\n@@ -382,1 +471,1 @@\n-    public void visitIF_ICMPLE(final IF_ICMPLE obj) {\n+    public void visitDALOAD( final DALOAD obj ) {\n@@ -385,0 +474,1 @@\n+\n@@ -386,1 +476,1 @@\n-    public void visitIF_ICMPLT(final IF_ICMPLT obj) {\n+    public void visitSIPUSH( final SIPUSH obj ) {\n@@ -389,0 +479,1 @@\n+\n@@ -390,1 +481,1 @@\n-    public void visitIF_ICMPNE(final IF_ICMPNE obj) {\n+    public void visitDSUB( final DSUB obj ) {\n@@ -393,0 +484,1 @@\n+\n@@ -394,1 +486,1 @@\n-    public void visitIFEQ(final IFEQ obj) {\n+    public void visitL2F( final L2F obj ) {\n@@ -397,0 +489,1 @@\n+\n@@ -398,1 +491,1 @@\n-    public void visitIFGE(final IFGE obj) {\n+    public void visitIF_ICMPGT( final IF_ICMPGT obj ) {\n@@ -401,0 +494,1 @@\n+\n@@ -402,1 +496,1 @@\n-    public void visitIFGT(final IFGT obj) {\n+    public void visitF2D( final F2D obj ) {\n@@ -405,0 +499,1 @@\n+\n@@ -406,1 +501,1 @@\n-    public void visitIfInstruction(final IfInstruction obj) {\n+    public void visitI2L( final I2L obj ) {\n@@ -409,0 +504,1 @@\n+\n@@ -410,1 +506,1 @@\n-    public void visitIFLE(final IFLE obj) {\n+    public void visitIF_ACMPNE( final IF_ACMPNE obj ) {\n@@ -413,0 +509,1 @@\n+\n@@ -414,1 +511,1 @@\n-    public void visitIFLT(final IFLT obj) {\n+    public void visitPOP( final POP obj ) {\n@@ -417,0 +514,1 @@\n+\n@@ -418,1 +516,1 @@\n-    public void visitIFNE(final IFNE obj) {\n+    public void visitI2S( final I2S obj ) {\n@@ -421,0 +519,1 @@\n+\n@@ -422,1 +521,1 @@\n-    public void visitIFNONNULL(final IFNONNULL obj) {\n+    public void visitIFEQ( final IFEQ obj ) {\n@@ -425,0 +524,1 @@\n+\n@@ -426,1 +526,1 @@\n-    public void visitIFNULL(final IFNULL obj) {\n+    public void visitSWAP( final SWAP obj ) {\n@@ -429,0 +529,1 @@\n+\n@@ -430,1 +531,1 @@\n-    public void visitIINC(final IINC obj) {\n+    public void visitIOR( final IOR obj ) {\n@@ -433,0 +534,1 @@\n+\n@@ -434,1 +536,1 @@\n-    public void visitILOAD(final ILOAD obj) {\n+    public void visitIREM( final IREM obj ) {\n@@ -437,0 +539,1 @@\n+\n@@ -438,1 +541,1 @@\n-    public void visitIMPDEP1(final IMPDEP1 obj) {\n+    public void visitIASTORE( final IASTORE obj ) {\n@@ -441,0 +544,1 @@\n+\n@@ -442,1 +546,1 @@\n-    public void visitIMPDEP2(final IMPDEP2 obj) {\n+    public void visitNEWARRAY( final NEWARRAY obj ) {\n@@ -445,0 +549,1 @@\n+\n@@ -446,1 +551,1 @@\n-    public void visitIMUL(final IMUL obj) {\n+    public void visitINVOKEINTERFACE( final INVOKEINTERFACE obj ) {\n@@ -449,0 +554,1 @@\n+\n@@ -450,1 +556,1 @@\n-    public void visitINEG(final INEG obj) {\n+    public void visitINEG( final INEG obj ) {\n@@ -453,0 +559,1 @@\n+\n@@ -454,1 +561,1 @@\n-    public void visitINSTANCEOF(final INSTANCEOF obj) {\n+    public void visitLCMP( final LCMP obj ) {\n@@ -457,3 +564,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+\n@@ -461,1 +566,1 @@\n-    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC obj) {\n+    public void visitJSR_W( final JSR_W obj ) {\n@@ -464,0 +569,1 @@\n+\n@@ -465,1 +571,1 @@\n-    public void visitInvokeInstruction(final InvokeInstruction obj) {\n+    public void visitMULTIANEWARRAY( final MULTIANEWARRAY obj ) {\n@@ -468,0 +574,1 @@\n+\n@@ -469,1 +576,1 @@\n-    public void visitINVOKEINTERFACE(final INVOKEINTERFACE obj) {\n+    public void visitDUP_X2( final DUP_X2 obj ) {\n@@ -472,0 +579,1 @@\n+\n@@ -473,1 +581,1 @@\n-    public void visitINVOKESPECIAL(final INVOKESPECIAL obj) {\n+    public void visitSALOAD( final SALOAD obj ) {\n@@ -476,0 +584,1 @@\n+\n@@ -477,1 +586,1 @@\n-    public void visitINVOKESTATIC(final INVOKESTATIC obj) {\n+    public void visitIFNONNULL( final IFNONNULL obj ) {\n@@ -480,0 +589,1 @@\n+\n@@ -481,1 +591,1 @@\n-    public void visitINVOKEVIRTUAL(final INVOKEVIRTUAL obj) {\n+    public void visitDMUL( final DMUL obj ) {\n@@ -484,0 +594,1 @@\n+\n@@ -485,1 +596,1 @@\n-    public void visitIOR(final IOR obj) {\n+    public void visitIFNE( final IFNE obj ) {\n@@ -488,0 +599,1 @@\n+\n@@ -489,1 +601,1 @@\n-    public void visitIREM(final IREM obj) {\n+    public void visitIF_ICMPLE( final IF_ICMPLE obj ) {\n@@ -492,0 +604,1 @@\n+\n@@ -493,1 +606,1 @@\n-    public void visitIRETURN(final IRETURN obj) {\n+    public void visitLDC2_W( final LDC2_W obj ) {\n@@ -496,0 +609,1 @@\n+\n@@ -497,1 +611,1 @@\n-    public void visitISHL(final ISHL obj) {\n+    public void visitGETFIELD( final GETFIELD obj ) {\n@@ -500,0 +614,1 @@\n+\n@@ -501,1 +616,1 @@\n-    public void visitISHR(final ISHR obj) {\n+    public void visitLADD( final LADD obj ) {\n@@ -504,0 +619,1 @@\n+\n@@ -505,1 +621,1 @@\n-    public void visitISTORE(final ISTORE obj) {\n+    public void visitNOP( final NOP obj ) {\n@@ -508,0 +624,1 @@\n+\n@@ -509,1 +626,1 @@\n-    public void visitISUB(final ISUB obj) {\n+    public void visitFALOAD( final FALOAD obj ) {\n@@ -512,0 +629,1 @@\n+\n@@ -513,1 +631,1 @@\n-    public void visitIUSHR(final IUSHR obj) {\n+    public void visitINSTANCEOF( final INSTANCEOF obj ) {\n@@ -516,0 +634,1 @@\n+\n@@ -517,1 +636,1 @@\n-    public void visitIXOR(final IXOR obj) {\n+    public void visitIFLE( final IFLE obj ) {\n@@ -520,0 +639,1 @@\n+\n@@ -521,1 +641,1 @@\n-    public void visitJSR(final JSR obj) {\n+    public void visitLXOR( final LXOR obj ) {\n@@ -524,0 +644,1 @@\n+\n@@ -525,1 +646,1 @@\n-    public void visitJSR_W(final JSR_W obj) {\n+    public void visitLRETURN( final LRETURN obj ) {\n@@ -528,0 +649,1 @@\n+\n@@ -529,1 +651,1 @@\n-    public void visitJsrInstruction(final JsrInstruction obj) {\n+    public void visitFCONST( final FCONST obj ) {\n@@ -532,0 +654,1 @@\n+\n@@ -533,1 +656,1 @@\n-    public void visitL2D(final L2D obj) {\n+    public void visitIUSHR( final IUSHR obj ) {\n@@ -536,0 +659,1 @@\n+\n@@ -537,1 +661,1 @@\n-    public void visitL2F(final L2F obj) {\n+    public void visitBALOAD( final BALOAD obj ) {\n@@ -540,0 +664,1 @@\n+\n@@ -541,1 +666,1 @@\n-    public void visitL2I(final L2I obj) {\n+    public void visitDUP2( final DUP2 obj ) {\n@@ -544,0 +669,1 @@\n+\n@@ -545,1 +671,1 @@\n-    public void visitLADD(final LADD obj) {\n+    public void visitIF_ACMPEQ( final IF_ACMPEQ obj ) {\n@@ -548,0 +674,1 @@\n+\n@@ -549,1 +676,1 @@\n-    public void visitLALOAD(final LALOAD obj) {\n+    public void visitIMPDEP1( final IMPDEP1 obj ) {\n@@ -552,0 +679,1 @@\n+\n@@ -553,1 +681,1 @@\n-    public void visitLAND(final LAND obj) {\n+    public void visitMONITORENTER( final MONITORENTER obj ) {\n@@ -556,0 +684,1 @@\n+\n@@ -557,1 +686,1 @@\n-    public void visitLASTORE(final LASTORE obj) {\n+    public void visitLSHL( final LSHL obj ) {\n@@ -560,0 +689,1 @@\n+\n@@ -561,1 +691,1 @@\n-    public void visitLCMP(final LCMP obj) {\n+    public void visitDCMPG( final DCMPG obj ) {\n@@ -564,0 +694,1 @@\n+\n@@ -565,1 +696,1 @@\n-    public void visitLCONST(final LCONST obj) {\n+    public void visitD2L( final D2L obj ) {\n@@ -568,0 +699,1 @@\n+\n@@ -569,1 +701,1 @@\n-    public void visitLDC(final LDC obj) {\n+    public void visitIMPDEP2( final IMPDEP2 obj ) {\n@@ -572,0 +704,1 @@\n+\n@@ -573,1 +706,1 @@\n-    public void visitLDC2_W(final LDC2_W obj) {\n+    public void visitL2D( final L2D obj ) {\n@@ -576,0 +709,1 @@\n+\n@@ -577,1 +711,1 @@\n-    public void visitLDIV(final LDIV obj) {\n+    public void visitRET( final RET obj ) {\n@@ -580,0 +714,1 @@\n+\n@@ -581,1 +716,1 @@\n-    public void visitLLOAD(final LLOAD obj) {\n+    public void visitIFGT( final IFGT obj ) {\n@@ -584,0 +719,1 @@\n+\n@@ -585,1 +721,1 @@\n-    public void visitLMUL(final LMUL obj) {\n+    public void visitIXOR( final IXOR obj ) {\n@@ -588,0 +724,1 @@\n+\n@@ -589,1 +726,1 @@\n-    public void visitLNEG(final LNEG obj) {\n+    public void visitINVOKEVIRTUAL( final INVOKEVIRTUAL obj ) {\n@@ -592,0 +729,1 @@\n+\n@@ -593,1 +731,1 @@\n-    public void visitLoadClass(final LoadClass obj) {\n+    public void visitFASTORE( final FASTORE obj ) {\n@@ -596,0 +734,1 @@\n+\n@@ -597,1 +736,1 @@\n-    public void visitLoadInstruction(final LoadInstruction obj) {\n+    public void visitIRETURN( final IRETURN obj ) {\n@@ -600,0 +739,1 @@\n+\n@@ -601,1 +741,1 @@\n-    public void visitLocalVariableInstruction(final LocalVariableInstruction obj) {\n+    public void visitIF_ICMPNE( final IF_ICMPNE obj ) {\n@@ -604,0 +744,1 @@\n+\n@@ -605,1 +746,1 @@\n-    public void visitLOOKUPSWITCH(final LOOKUPSWITCH obj) {\n+    public void visitFLOAD( final FLOAD obj ) {\n@@ -608,0 +749,1 @@\n+\n@@ -609,1 +751,1 @@\n-    public void visitLOR(final LOR obj) {\n+    public void visitLDIV( final LDIV obj ) {\n@@ -612,0 +754,1 @@\n+\n@@ -613,1 +756,1 @@\n-    public void visitLREM(final LREM obj) {\n+    public void visitPUTSTATIC( final PUTSTATIC obj ) {\n@@ -616,0 +759,1 @@\n+\n@@ -617,1 +761,1 @@\n-    public void visitLRETURN(final LRETURN obj) {\n+    public void visitAALOAD( final AALOAD obj ) {\n@@ -620,0 +764,1 @@\n+\n@@ -621,1 +766,1 @@\n-    public void visitLSHL(final LSHL obj) {\n+    public void visitD2I( final D2I obj ) {\n@@ -624,0 +769,1 @@\n+\n@@ -625,1 +771,1 @@\n-    public void visitLSHR(final LSHR obj) {\n+    public void visitIF_ICMPEQ( final IF_ICMPEQ obj ) {\n@@ -628,0 +774,1 @@\n+\n@@ -629,1 +776,1 @@\n-    public void visitLSTORE(final LSTORE obj) {\n+    public void visitAASTORE( final AASTORE obj ) {\n@@ -632,0 +779,1 @@\n+\n@@ -633,1 +781,1 @@\n-    public void visitLSUB(final LSUB obj) {\n+    public void visitARETURN( final ARETURN obj ) {\n@@ -636,0 +784,1 @@\n+\n@@ -637,1 +786,1 @@\n-    public void visitLUSHR(final LUSHR obj) {\n+    public void visitDUP2_X1( final DUP2_X1 obj ) {\n@@ -640,0 +789,1 @@\n+\n@@ -641,1 +791,1 @@\n-    public void visitLXOR(final LXOR obj) {\n+    public void visitFNEG( final FNEG obj ) {\n@@ -644,0 +794,1 @@\n+\n@@ -645,1 +796,1 @@\n-    public void visitMONITORENTER(final MONITORENTER obj) {\n+    public void visitGOTO_W( final GOTO_W obj ) {\n@@ -648,0 +799,1 @@\n+\n@@ -649,1 +801,1 @@\n-    public void visitMONITOREXIT(final MONITOREXIT obj) {\n+    public void visitD2F( final D2F obj ) {\n@@ -652,0 +804,1 @@\n+\n@@ -653,1 +806,1 @@\n-    public void visitMULTIANEWARRAY(final MULTIANEWARRAY obj) {\n+    public void visitGOTO( final GOTO obj ) {\n@@ -656,0 +809,1 @@\n+\n@@ -657,1 +811,1 @@\n-    public void visitNEW(final NEW obj) {\n+    public void visitISUB( final ISUB obj ) {\n@@ -660,0 +814,1 @@\n+\n@@ -661,1 +816,1 @@\n-    public void visitNEWARRAY(final NEWARRAY obj) {\n+    public void visitF2I( final F2I obj ) {\n@@ -664,0 +819,1 @@\n+\n@@ -665,1 +821,1 @@\n-    public void visitNOP(final NOP obj) {\n+    public void visitDNEG( final DNEG obj ) {\n@@ -668,0 +824,1 @@\n+\n@@ -669,1 +826,1 @@\n-    public void visitPOP(final POP obj) {\n+    public void visitICONST( final ICONST obj ) {\n@@ -672,0 +829,1 @@\n+\n@@ -673,1 +831,1 @@\n-    public void visitPOP2(final POP2 obj) {\n+    public void visitFDIV( final FDIV obj ) {\n@@ -676,0 +834,1 @@\n+\n@@ -677,1 +836,1 @@\n-    public void visitPopInstruction(final PopInstruction obj) {\n+    public void visitI2B( final I2B obj ) {\n@@ -680,0 +839,1 @@\n+\n@@ -681,1 +841,1 @@\n-    public void visitPushInstruction(final PushInstruction obj) {\n+    public void visitLNEG( final LNEG obj ) {\n@@ -684,0 +844,1 @@\n+\n@@ -685,1 +846,1 @@\n-    public void visitPUTFIELD(final PUTFIELD obj) {\n+    public void visitLREM( final LREM obj ) {\n@@ -688,0 +849,1 @@\n+\n@@ -689,1 +851,1 @@\n-    public void visitPUTSTATIC(final PUTSTATIC obj) {\n+    public void visitIMUL( final IMUL obj ) {\n@@ -692,0 +854,1 @@\n+\n@@ -693,1 +856,1 @@\n-    public void visitRET(final RET obj) {\n+    public void visitIADD( final IADD obj ) {\n@@ -696,0 +859,1 @@\n+\n@@ -697,1 +861,1 @@\n-    public void visitRETURN(final RETURN obj) {\n+    public void visitLSHR( final LSHR obj ) {\n@@ -700,0 +864,1 @@\n+\n@@ -701,1 +866,1 @@\n-    public void visitReturnInstruction(final ReturnInstruction obj) {\n+    public void visitLOOKUPSWITCH( final LOOKUPSWITCH obj ) {\n@@ -704,0 +869,1 @@\n+\n@@ -705,1 +871,1 @@\n-    public void visitSALOAD(final SALOAD obj) {\n+    public void visitDUP_X1( final DUP_X1 obj ) {\n@@ -708,0 +874,1 @@\n+\n@@ -709,1 +876,1 @@\n-    public void visitSASTORE(final SASTORE obj) {\n+    public void visitFCMPL( final FCMPL obj ) {\n@@ -712,0 +879,1 @@\n+\n@@ -713,1 +881,1 @@\n-    public void visitSelect(final Select obj) {\n+    public void visitI2C( final I2C obj ) {\n@@ -716,0 +884,1 @@\n+\n@@ -717,1 +886,1 @@\n-    public void visitSIPUSH(final SIPUSH obj) {\n+    public void visitLMUL( final LMUL obj ) {\n@@ -720,0 +889,1 @@\n+\n@@ -721,1 +891,1 @@\n-    public void visitStackConsumer(final StackConsumer obj) {\n+    public void visitLUSHR( final LUSHR obj ) {\n@@ -724,0 +894,1 @@\n+\n@@ -725,1 +896,1 @@\n-    public void visitStackInstruction(final StackInstruction obj) {\n+    public void visitISHL( final ISHL obj ) {\n@@ -728,0 +899,1 @@\n+\n@@ -729,1 +901,1 @@\n-    public void visitStackProducer(final StackProducer obj) {\n+    public void visitLALOAD( final LALOAD obj ) {\n@@ -732,0 +904,1 @@\n+\n@@ -733,1 +906,1 @@\n-    public void visitStoreInstruction(final StoreInstruction obj) {\n+    public void visitASTORE( final ASTORE obj ) {\n@@ -736,0 +909,1 @@\n+\n@@ -737,1 +911,1 @@\n-    public void visitSWAP(final SWAP obj) {\n+    public void visitANEWARRAY( final ANEWARRAY obj ) {\n@@ -740,0 +914,1 @@\n+\n@@ -741,1 +916,1 @@\n-    public void visitTABLESWITCH(final TABLESWITCH obj) {\n+    public void visitFRETURN( final FRETURN obj ) {\n@@ -744,0 +919,1 @@\n+\n@@ -745,1 +921,1 @@\n-    public void visitTypedInstruction(final TypedInstruction obj) {\n+    public void visitFADD( final FADD obj ) {\n@@ -748,0 +924,1 @@\n+\n@@ -749,1 +926,1 @@\n-    public void visitUnconditionalBranch(final UnconditionalBranch obj) {\n+    public void visitBREAKPOINT( final BREAKPOINT obj ) {\n@@ -752,0 +929,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -753,1 +933,1 @@\n-    public void visitVariableLengthInstruction(final VariableLengthInstruction obj) {\n+    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC obj) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/EmptyVisitor.java","additions":364,"deletions":184,"binary":false,"changes":548,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-public class EnumElementValueGen extends ElementValueGen {\n+public class EnumElementValueGen extends ElementValueGen\n+{\n@@ -36,1 +37,1 @@\n-    private final int typeIdx;\n+    private int typeIdx;\n@@ -38,14 +39,1 @@\n-    private final int valueIdx;\n-\n-    public EnumElementValueGen(final EnumElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        super(ENUM_CONSTANT, cpool);\n-        if (copyPoolEntries) {\n-            typeIdx = cpool.addUtf8(value.getEnumTypeString());\/\/ was\n-                                                               \/\/ addClass(value.getEnumTypeString());\n-            valueIdx = cpool.addUtf8(value.getEnumValueString()); \/\/ was\n-                                                                  \/\/ addString(value.getEnumValueString());\n-        } else {\n-            typeIdx = value.getTypeIndex();\n-            valueIdx = value.getValueIndex();\n-        }\n-    }\n+    private int valueIdx;\n@@ -54,2 +42,3 @@\n-     * This ctor assumes the constant pool already contains the right type and value - as indicated by typeIdx and valueIdx.\n-     * This ctor is used for deserialization\n+     * This ctor assumes the constant pool already contains the right type and\n+     * value - as indicated by typeIdx and valueIdx. This ctor is used for\n+     * deserialization\n@@ -57,1 +46,3 @@\n-    protected EnumElementValueGen(final int typeIdx, final int valueIdx, final ConstantPoolGen cpool) {\n+    protected EnumElementValueGen(final int typeIdx, final int valueIdx,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -60,1 +51,3 @@\n-            throw new IllegalArgumentException(\"Only element values of type enum can be built with this ctor - type specified: \" + super.getElementValueType());\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type enum can be built with this ctor - type specified: \"\n+                            + super.getElementValueType());\n@@ -66,1 +59,14 @@\n-    public EnumElementValueGen(final ObjectType t, final String value, final ConstantPoolGen cpool) {\n+    \/**\n+     * Return immutable variant of this EnumElementValue\n+     *\/\n+    @Override\n+    public ElementValue getElementValue()\n+    {\n+        System.err.println(\"Duplicating value: \" + getEnumTypeString() + \":\"\n+                + getEnumValueString());\n+        return new EnumElementValue(super.getElementValueType(), typeIdx, valueIdx,\n+                getConstantPool().getConstantPool());\n+    }\n+\n+    public EnumElementValueGen(final ObjectType t, final String value, final ConstantPoolGen cpool)\n+    {\n@@ -72,0 +78,18 @@\n+    public EnumElementValueGen(final EnumElementValue value, final ConstantPoolGen cpool,\n+            final boolean copyPoolEntries)\n+    {\n+        super(ENUM_CONSTANT, cpool);\n+        if (copyPoolEntries)\n+        {\n+            typeIdx = cpool.addUtf8(value.getEnumTypeString());\/\/ was\n+                                                                \/\/ addClass(value.getEnumTypeString());\n+            valueIdx = cpool.addUtf8(value.getEnumValueString()); \/\/ was\n+                                                                    \/\/ addString(value.getEnumValueString());\n+        }\n+        else\n+        {\n+            typeIdx = value.getTypeIndex();\n+            valueIdx = value.getValueIndex();\n+        }\n+    }\n+\n@@ -73,1 +97,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -79,3 +104,0 @@\n-    \/**\n-     * Return immutable variant of this EnumElementValue\n-     *\/\n@@ -83,3 +105,8 @@\n-    public ElementValue getElementValue() {\n-        System.err.println(\"Duplicating value: \" + getEnumTypeString() + \":\" + getEnumValueString());\n-        return new EnumElementValue(super.getElementValueType(), typeIdx, valueIdx, getConstantPool().getConstantPool());\n+    public String stringifyValue()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(valueIdx);\n+        return cu8.getBytes();\n+        \/\/ ConstantString cu8 =\n+        \/\/ (ConstantString)getConstantPool().getConstant(valueIdx);\n+        \/\/ return\n+        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n@@ -90,1 +117,2 @@\n-    public String getEnumTypeString() {\n+    public String getEnumTypeString()\n+    {\n@@ -96,1 +124,2 @@\n-        return ((ConstantUtf8) getConstantPool().getConstant(typeIdx)).getBytes();\n+        return ((ConstantUtf8) getConstantPool().getConstant(typeIdx))\n+                .getBytes();\n@@ -100,1 +129,2 @@\n-    public String getEnumValueString() {\n+    public String getEnumValueString()\n+    {\n@@ -108,5 +138,2 @@\n-    public int getTypeIndex() {\n-        return typeIdx;\n-    }\n-\n-    public int getValueIndex() {\n+    public int getValueIndex()\n+    {\n@@ -116,8 +143,3 @@\n-    @Override\n-    public String stringifyValue() {\n-        final ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(valueIdx);\n-        return cu8.getBytes();\n-        \/\/ ConstantString cu8 =\n-        \/\/ (ConstantString)getConstantPool().getConstant(valueIdx);\n-        \/\/ return\n-        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n+    public int getTypeIndex()\n+    {\n+        return typeIdx;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/EnumElementValueGen.java","additions":66,"deletions":44,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -25,2 +25,4 @@\n- * Denote an instruction that may throw a run-time or a linking exception (or both) during execution. This is not quite\n- * the truth as such; because all instructions may throw an java.lang.VirtualMachineError. These exceptions are omitted.\n+ * Denote an instruction that may throw a run-time or a linking\n+ * exception (or both) during execution.  This is not quite the truth\n+ * as such; because all instructions may throw an\n+ * java.lang.VirtualMachineError. These exceptions are omitted.\n@@ -28,3 +30,10 @@\n- * The Lava Language Specification specifies exactly which <i>RUN-TIME<\/i> and which <i>LINKING<\/i> exceptions each\n- * instruction may throw which is reflected by the implementers. Due to the structure of the JVM specification, it may\n- * be possible that an Instruction implementing this interface returns a Class[] of size 0.\n+ * The Lava Language Specification specifies exactly which\n+ * <i>RUN-TIME<\/i> and which <i>LINKING<\/i> exceptions each\n+ * instruction may throw which is reflected by the implementers.  Due\n+ * to the structure of the JVM specification, it may be possible that\n+ * an Instruction implementing this interface returns a Class[] of\n+ * size 0.\n+ *\n+ * Please note that we speak of an \"exception\" here when we mean any\n+ * \"Throwable\" object; so this term is equally used for \"Exception\"\n+ * and \"Error\" objects.\n@@ -32,2 +41,0 @@\n- * Please note that we speak of an \"exception\" here when we mean any \"Throwable\" object; so this term is equally used\n- * for \"Exception\" and \"Error\" objects.\n@@ -37,1 +44,1 @@\n-    Class<?>[] getExceptions();\n+    java.lang.Class<?>[] getExceptions();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ExceptionThrower.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert float to double\n+    \/** Convert float to double\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2D.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert float to int\n+    \/** Convert float to int\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2I.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert float to long\n+    \/** Convert float to long\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Add floats\n+    \/** Add floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load float from array\n+    \/** Load float from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * FASTORE - Store into float array\n+ * FASTORE -  Store into float array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store float into array\n+    \/** Store float into array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,9 @@\n+\n+    \/** @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.FLOAT;\n+    }\n+\n+\n@@ -38,2 +45,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +53,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -50,8 +59,0 @@\n-\n-    \/**\n-     * @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.FLOAT;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCMPG.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,9 @@\n+\n+    \/** @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.FLOAT;\n+    }\n+\n+\n@@ -38,2 +45,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +53,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -50,8 +59,0 @@\n-\n-    \/**\n-     * @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.FLOAT;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCMPL.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,3 +26,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ...,\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., <\/PRE>\n+ *\n@@ -33,1 +32,2 @@\n-    private final float value;\n+    private float value;\n+\n@@ -36,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,1 +40,0 @@\n-        this(0);\n@@ -42,0 +42,1 @@\n+\n@@ -56,0 +57,15 @@\n+\n+    @Override\n+    public Number getValue() {\n+        return value;\n+    }\n+\n+\n+    \/** @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.FLOAT;\n+    }\n+\n+\n@@ -57,2 +73,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,13 +88,0 @@\n-\n-    \/**\n-     * @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.FLOAT;\n-    }\n-\n-    @Override\n-    public Number getValue() {\n-        return Float.valueOf(value);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCONST.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Divide floats\n+    \/** Divide floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FDIV.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack ... -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack ... -&gt; ..., result\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Load float from local variable\n-     *\n+\n+    \/** Load float from local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FLOAD.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Multiply floats\n+    \/** Multiply floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FNEG.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Remainder of floats\n+    \/** Remainder of floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FREM.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * FRETURN - Return float from method\n+ * FRETURN -  Return float from method\n+ * <PRE>Stack: ..., value -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Return float from method\n+    \/** Return float from method\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ... <\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Store float into local variable\n-     *\n+\n+    \/** Store float into local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FSTORE.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Substract floats\n+    \/** Substract floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FSUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.util.stream.Stream;\n@@ -28,0 +27,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;\n@@ -39,2 +39,3 @@\n- * Template class for building up a field. The only extraordinary thing one can do is to add a constant value attribute\n- * to a field (which must of course be compatible with to the declared type).\n+ * Template class for building up a field.  The only extraordinary thing\n+ * one can do is to add a constant value attribute to a field (which must of\n+ * course be compatible with to the declared type).\n@@ -47,0 +48,1 @@\n+    private Object value = null;\n@@ -50,1 +52,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -53,1 +55,2 @@\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName())\n+                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -56,0 +59,1 @@\n+\n@@ -57,1 +61,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -63,6 +67,0 @@\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n@@ -71,1 +69,8 @@\n-     * @param comparator Comparison strategy object\n+     * Declare a field. If it is static (isStatic() == true) and has a\n+     * basic type like int or String it may have an initial value\n+     * associated with it as defined by setInitValue().\n+     *\n+     * @param access_flags access qualifiers\n+     * @param type  field type\n+     * @param name field name\n+     * @param cp constant pool\n@@ -73,2 +78,5 @@\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n+    public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {\n+        super(access_flags);\n+        setType(type);\n+        setName(name);\n+        setConstantPool(cp);\n@@ -77,3 +85,0 @@\n-    private Object value;\n-\n-    private List<FieldObserver> observers;\n@@ -94,2 +99,5 @@\n-                final Annotations runtimeAnnotations = (Annotations) attr;\n-                runtimeAnnotations.forEach(element -> addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n+                final Annotations runtimeAnnotations = (Annotations)attr;\n+                final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();\n+                for (final AnnotationEntry element : annotationEntries) {\n+                    addAnnotationEntry(new AnnotationEntryGen(element,cp,false));\n+                }\n@@ -102,0 +110,8 @@\n+\n+    private void setValue( final int index ) {\n+        final ConstantPool cp = super.getConstantPool().getConstantPool();\n+        final Constant c = cp.getConstant(index);\n+        value = ((ConstantObject) c).getConstantValue(cp);\n+    }\n+\n+\n@@ -103,7 +119,2 @@\n-     * Declare a field. If it is static (isStatic() == true) and has a basic type like int or String it may have an initial\n-     * value associated with it as defined by setInitValue().\n-     *\n-     * @param accessFlags access qualifiers\n-     * @param type field type\n-     * @param name field name\n-     * @param cp constant pool\n+     * Set (optional) initial value of field, otherwise it will be set to null\/0\/false\n+     * by the JVM automatically.\n@@ -111,5 +122,5 @@\n-    public FieldGen(final int accessFlags, final Type type, final String name, final ConstantPoolGen cp) {\n-        super(accessFlags);\n-        setType(type);\n-        setName(name);\n-        setConstantPool(cp);\n+    public void setInitValue( final String str ) {\n+        checkType(  ObjectType.getInstance(\"java.lang.String\"));\n+        if (str != null) {\n+            value = str;\n+        }\n@@ -118,2 +129,6 @@\n-    private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        Stream.of(AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries())).forEach(this::addAttribute);\n+\n+    public void setInitValue( final long l ) {\n+        checkType(Type.LONG);\n+        if (l != 0L) {\n+            value = Long.valueOf(l);\n+        }\n@@ -122,18 +137,5 @@\n-    private int addConstant() {\n-        switch (super.getType().getType()) { \/\/ sic\n-        case Const.T_INT:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-        case Const.T_BOOLEAN:\n-        case Const.T_SHORT:\n-            return super.getConstantPool().addInteger(((Integer) value).intValue());\n-        case Const.T_FLOAT:\n-            return super.getConstantPool().addFloat(((Float) value).floatValue());\n-        case Const.T_DOUBLE:\n-            return super.getConstantPool().addDouble(((Double) value).doubleValue());\n-        case Const.T_LONG:\n-            return super.getConstantPool().addLong(((Long) value).longValue());\n-        case Const.T_REFERENCE:\n-            return super.getConstantPool().addString((String) value);\n-        default:\n-            throw new IllegalStateException(\"Unhandled : \" + super.getType().getType()); \/\/ sic\n+\n+    public void setInitValue( final int i ) {\n+        checkType(Type.INT);\n+        if (i != 0) {\n+            value = Integer.valueOf(i);\n@@ -143,6 +145,5 @@\n-    \/**\n-     * Add observer for this object.\n-     *\/\n-    public void addObserver(final FieldObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n+\n+    public void setInitValue( final short s ) {\n+        checkType(Type.SHORT);\n+        if (s != 0) {\n+            value = Integer.valueOf(s);\n@@ -150,1 +151,0 @@\n-        observers.add(o);\n@@ -153,2 +153,42 @@\n-    \/**\n-     * Remove any initial value.\n+\n+    public void setInitValue( final char c ) {\n+        checkType(Type.CHAR);\n+        if (c != 0) {\n+            value = Integer.valueOf(c);\n+        }\n+    }\n+\n+\n+    public void setInitValue( final byte b ) {\n+        checkType(Type.BYTE);\n+        if (b != 0) {\n+            value = Integer.valueOf(b);\n+        }\n+    }\n+\n+\n+    public void setInitValue( final boolean b ) {\n+        checkType(Type.BOOLEAN);\n+        if (b) {\n+            value = Integer.valueOf(1);\n+        }\n+    }\n+\n+\n+    public void setInitValue( final float f ) {\n+        checkType(Type.FLOAT);\n+        if (f != 0.0) {\n+            value = f;\n+        }\n+    }\n+\n+\n+    public void setInitValue( final double d ) {\n+        checkType(Type.DOUBLE);\n+        if (d != 0.0) {\n+            value = d;\n+        }\n+    }\n+\n+\n+    \/** Remove any initial value.\n@@ -160,1 +200,2 @@\n-    private void checkType(final Type atype) {\n+\n+    private void checkType( final Type atype ) {\n@@ -173,19 +214,0 @@\n-    \/**\n-     * @return deep copy of this field\n-     *\/\n-    public FieldGen copy(final ConstantPoolGen cp) {\n-        final FieldGen fg = (FieldGen) clone();\n-        fg.setConstantPool(cp);\n-        return fg;\n-    }\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default two FieldGen objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see Object#equals(Object)\n-     *\/\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n-    }\n@@ -198,2 +220,2 @@\n-        final int nameIndex = super.getConstantPool().addUtf8(super.getName());\n-        final int signatureIndex = super.getConstantPool().addUtf8(signature);\n+        final int name_index = super.getConstantPool().addUtf8(super.getName());\n+        final int signature_index = super.getConstantPool().addUtf8(signature);\n@@ -203,1 +225,2 @@\n-            addAttribute(new ConstantValue(super.getConstantPool().addUtf8(\"ConstantValue\"), 2, index, super.getConstantPool().getConstantPool())); \/\/ sic\n+            addAttribute(new ConstantValue(super.getConstantPool().addUtf8(\"ConstantValue\"), 2, index,\n+                    super.getConstantPool().getConstantPool())); \/\/ sic\n@@ -206,1 +229,2 @@\n-        return new Field(super.getAccessFlags(), nameIndex, signatureIndex, getAttributes(), super.getConstantPool().getConstantPool()); \/\/ sic\n+        return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),\n+                super.getConstantPool().getConstantPool()); \/\/ sic\n@@ -209,3 +233,26 @@\n-    public String getInitValue() {\n-        if (value != null) {\n-            return value.toString();\n+    private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+          final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n+        for (final Attribute attr : attrs) {\n+            addAttribute(attr);\n+        }\n+      }\n+\n+\n+    private int addConstant() {\n+        switch (super.getType().getType()) { \/\/ sic\n+            case Const.T_INT:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+            case Const.T_BOOLEAN:\n+            case Const.T_SHORT:\n+                return super.getConstantPool().addInteger(((Integer) value));\n+            case Const.T_FLOAT:\n+                return super.getConstantPool().addFloat(((Float) value));\n+            case Const.T_DOUBLE:\n+                return super.getConstantPool().addDouble(((Double) value));\n+            case Const.T_LONG:\n+                return super.getConstantPool().addLong(((Long) value));\n+            case Const.T_REFERENCE:\n+                return super.getConstantPool().addString((String) value);\n+            default:\n+                throw new IllegalStateException(\"Unhandled : \" + super.getType().getType()); \/\/ sic\n@@ -213,1 +260,0 @@\n-        return null;\n@@ -216,0 +262,1 @@\n+\n@@ -221,26 +268,1 @@\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the field's name XOR\n-     * signature.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    \/**\n-     * Remove observer for this object.\n-     *\/\n-    public void removeObserver(final FieldObserver o) {\n-        if (observers != null) {\n-            observers.remove(o);\n-        }\n-    }\n-\n-    public void setInitValue(final boolean b) {\n-        checkType(Type.BOOLEAN);\n-        if (b) {\n-            value = Integer.valueOf(1);\n-        }\n-    }\n+    private List<FieldObserver> observers;\n@@ -248,6 +270,0 @@\n-    public void setInitValue(final byte b) {\n-        checkType(Type.BYTE);\n-        if (b != 0) {\n-            value = Integer.valueOf(b);\n-        }\n-    }\n@@ -255,4 +271,5 @@\n-    public void setInitValue(final char c) {\n-        checkType(Type.CHAR);\n-        if (c != 0) {\n-            value = Integer.valueOf(c);\n+    \/** Add observer for this object.\n+     *\/\n+    public void addObserver( final FieldObserver o ) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n@@ -260,0 +277,1 @@\n+        observers.add(o);\n@@ -262,6 +280,0 @@\n-    public void setInitValue(final double d) {\n-        checkType(Type.DOUBLE);\n-        if (d != 0.0) {\n-            value = Double.valueOf(d);\n-        }\n-    }\n@@ -269,4 +281,5 @@\n-    public void setInitValue(final float f) {\n-        checkType(Type.FLOAT);\n-        if (f != 0.0) {\n-            value = Float.valueOf(f);\n+    \/** Remove observer for this object.\n+     *\/\n+    public void removeObserver( final FieldObserver o ) {\n+        if (observers != null) {\n+            observers.remove(o);\n@@ -276,6 +289,0 @@\n-    public void setInitValue(final int i) {\n-        checkType(Type.INT);\n-        if (i != 0) {\n-            value = Integer.valueOf(i);\n-        }\n-    }\n@@ -283,4 +290,9 @@\n-    public void setInitValue(final long l) {\n-        checkType(Type.LONG);\n-        if (l != 0L) {\n-            value = Long.valueOf(l);\n+    \/** Call notify() method on all observers. This method is not called\n+     * automatically whenever the state has changed, but has to be\n+     * called by the user after he has finished editing the object.\n+     *\/\n+    public void update() {\n+        if (observers != null) {\n+            for (final FieldObserver observer : observers ) {\n+                observer.notify(this);\n+            }\n@@ -290,6 +302,0 @@\n-    public void setInitValue(final short s) {\n-        checkType(Type.SHORT);\n-        if (s != 0) {\n-            value = Integer.valueOf(s);\n-        }\n-    }\n@@ -297,7 +303,3 @@\n-    \/**\n-     * Set (optional) initial value of field, otherwise it will be set to null\/0\/false by the JVM automatically.\n-     *\/\n-    public void setInitValue(final String str) {\n-        checkType(ObjectType.getInstance(\"java.lang.String\"));\n-        if (str != null) {\n-            value = str;\n+    public String getInitValue() {\n+        if (value != null) {\n+            return value.toString();\n@@ -305,0 +307,1 @@\n+        return null;\n@@ -307,5 +310,0 @@\n-    private void setValue(final int index) {\n-        final ConstantPool cp = super.getConstantPool().getConstantPool();\n-        final Constant c = cp.getConstant(index);\n-        value = ((ConstantObject) c).getConstantValue(cp);\n-    }\n@@ -314,1 +312,2 @@\n-     * Return string representation close to declaration format, 'public static final short MAX = 100', e.g..\n+     * Return string representation close to declaration format,\n+     * `public static final short MAX = 100', e.g..\n@@ -324,1 +323,1 @@\n-        access = access.isEmpty() ? \"\" : access + \" \";\n+        access = access.isEmpty() ? \"\" : (access + \" \");\n@@ -336,0 +335,10 @@\n+\n+    \/** @return deep copy of this field\n+     *\/\n+    public FieldGen copy( final ConstantPoolGen cp ) {\n+        final FieldGen fg = (FieldGen) clone();\n+        fg.setConstantPool(cp);\n+        return fg;\n+    }\n+\n+\n@@ -337,2 +346,1 @@\n-     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n-     * has to be called by the user after they have finished editing the object.\n+     * @return Comparison strategy object\n@@ -340,6 +348,35 @@\n-    public void update() {\n-        if (observers != null) {\n-            for (final FieldObserver observer : observers) {\n-                observer.notify(this);\n-            }\n-        }\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two FieldGen objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the field's name XOR signature.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldGen.java","additions":210,"deletions":173,"binary":false,"changes":383,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-import java.util.Collections;\n@@ -31,1 +30,2 @@\n- * Super class for FieldGen and MethodGen objects, since they have some methods in common!\n+ * Super class for FieldGen and MethodGen objects, since they have\n+ * some methods in common!\n@@ -37,17 +37,3 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected String name;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected Type type;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected ConstantPoolGen cp;\n+    private String name;\n+    private Type type;\n+    private ConstantPoolGen cp;\n@@ -60,2 +46,0 @@\n-    protected FieldGenOrMethodGen() {\n-    }\n@@ -63,5 +47,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    protected FieldGenOrMethodGen(final int accessFlags) { \/\/ TODO could this be package protected?\n-        super(accessFlags);\n+    protected FieldGenOrMethodGen() {\n@@ -70,3 +50,0 @@\n-    protected void addAll(final Attribute[] attrs) {\n-        Collections.addAll(attributeList, attrs);\n-    }\n@@ -77,12 +54,2 @@\n-    public void addAnnotationEntry(final AnnotationEntryGen ag) {\n-        annotationList.add(ag);\n-    }\n-\n-    \/**\n-     * Add an attribute to this method. Currently, the JVM knows about the 'Code', 'ConstantValue', 'Synthetic' and\n-     * 'Exceptions' attributes. Other attributes will be ignored by the JVM but do no harm.\n-     *\n-     * @param a attribute to be added\n-     *\/\n-    public void addAttribute(final Attribute a) {\n-        attributeList.add(a);\n+    protected FieldGenOrMethodGen(final int access_flags) { \/\/ TODO could this be package protected?\n+        super(access_flags);\n@@ -92,5 +59,3 @@\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+    public void setType( final Type type ) { \/\/ TODO could be package-protected?\n+        if (type.getType() == Const.T_ADDRESS) {\n+            throw new IllegalArgumentException(\"Type can not be \" + type);\n@@ -98,0 +63,1 @@\n+        this.type = type;\n@@ -100,3 +66,0 @@\n-    public AnnotationEntryGen[] getAnnotationEntries() {\n-        return annotationList.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n-    }\n@@ -104,5 +67,3 @@\n-    \/**\n-     * @return all attributes of this method.\n-     *\/\n-    public Attribute[] getAttributes() {\n-        return attributeList.toArray(Attribute.EMPTY_ARRAY);\n+    @Override\n+    public Type getType() {\n+        return type;\n@@ -111,3 +72,0 @@\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n-    }\n@@ -115,2 +73,1 @@\n-    \/**\n-     * @return name of method\/field.\n+    \/** @return name of method\/field.\n@@ -123,4 +80,0 @@\n-    \/**\n-     * @return signature of method\/field.\n-     *\/\n-    public abstract String getSignature();\n@@ -129,2 +82,7 @@\n-    public Type getType() {\n-        return type;\n+    public void setName( final String name ) { \/\/ TODO could be package-protected?\n+        this.name = name;\n+    }\n+\n+\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n@@ -133,0 +91,6 @@\n+\n+    public void setConstantPool( final ConstantPoolGen cp ) { \/\/ TODO could be package-protected?\n+        this.cp = cp;\n+    }\n+\n+\n@@ -134,1 +98,6 @@\n-     * @since 6.0\n+     * Add an attribute to this method. Currently, the JVM knows about\n+     * the `Code', `ConstantValue', `Synthetic' and `Exceptions'\n+     * attributes. Other attributes will be ignored by the JVM but do no\n+     * harm.\n+     *\n+     * @param a attribute to be added\n@@ -136,2 +105,2 @@\n-    public void removeAnnotationEntries() {\n-        annotationList.clear();\n+    public void addAttribute( final Attribute a ) {\n+        attributeList.add(a);\n@@ -143,2 +112,3 @@\n-    public void removeAnnotationEntry(final AnnotationEntryGen ag) {\n-        annotationList.remove(ag);\n+    public void addAnnotationEntry(final AnnotationEntryGen ag)\n+    {\n+        annotationList.add(ag);\n@@ -147,0 +117,1 @@\n+\n@@ -150,1 +121,1 @@\n-    public void removeAttribute(final Attribute a) {\n+    public void removeAttribute( final Attribute a ) {\n@@ -154,0 +125,9 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void removeAnnotationEntry(final AnnotationEntryGen ag)\n+    {\n+        annotationList.remove(ag);\n+    }\n+\n+\n@@ -161,2 +141,6 @@\n-    public void setConstantPool(final ConstantPoolGen cp) { \/\/ TODO could be package-protected?\n-        this.cp = cp;\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void removeAnnotationEntries()\n+    {\n+        annotationList.clear();\n@@ -165,3 +149,6 @@\n-    @Override\n-    public void setName(final String name) { \/\/ TODO could be package-protected?\n-        this.name = name;\n+\n+    \/**\n+     * @return all attributes of this method.\n+     *\/\n+    public Attribute[] getAttributes() {\n+        return attributeList.toArray(new Attribute[0]);\n@@ -170,0 +157,10 @@\n+    public AnnotationEntryGen[] getAnnotationEntries() {\n+        return annotationList.toArray(new AnnotationEntryGen[0]);\n+      }\n+\n+\n+    \/** @return signature of method\/field.\n+     *\/\n+    public abstract String getSignature();\n+\n+\n@@ -171,3 +168,5 @@\n-    public void setType(final Type type) { \/\/ TODO could be package-protected?\n-        if (type.getType() == Const.T_ADDRESS) {\n-            throw new IllegalArgumentException(\"Type can not be \" + type);\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n@@ -175,1 +174,0 @@\n-        this.type = type;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldGenOrMethodGen.java","additions":78,"deletions":80,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -32,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,0 +39,1 @@\n+\n@@ -44,0 +47,1 @@\n+\n@@ -45,1 +49,1 @@\n-     * @return name of referenced field.\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -47,2 +51,4 @@\n-    public String getFieldName(final ConstantPoolGen cpg) {\n-        return getName(cpg);\n+    @Override\n+    public String toString( final ConstantPool cp ) {\n+        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \"\n+                + cp.constantToString(super.getIndex(), com.sun.org.apache.bcel.internal.Const.CONSTANT_Fieldref);\n@@ -51,2 +57,2 @@\n-    \/**\n-     * @return size of field (1 or 2)\n+\n+    \/** @return size of field (1 or 2)\n@@ -54,1 +60,1 @@\n-    protected int getFieldSize(final ConstantPoolGen cpg) {\n+    protected int getFieldSize( final ConstantPoolGen cpg ) {\n@@ -58,6 +64,0 @@\n-    \/**\n-     * @return type of field\n-     *\/\n-    public Type getFieldType(final ConstantPoolGen cpg) {\n-        return Type.getType(getSignature(cpg));\n-    }\n@@ -65,2 +65,1 @@\n-    \/**\n-     * @return return type of referenced field\n+    \/** @return return type of referenced field\n@@ -69,1 +68,1 @@\n-    public Type getType(final ConstantPoolGen cpg) {\n+    public Type getType( final ConstantPoolGen cpg ) {\n@@ -73,2 +72,2 @@\n-    \/**\n-     * @return mnemonic for instruction with symbolic references resolved\n+\n+    \/** @return type of field\n@@ -76,3 +75,9 @@\n-    @Override\n-    public String toString(final ConstantPool cp) {\n-        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + cp.constantToString(super.getIndex(), com.sun.org.apache.bcel.internal.Const.CONSTANT_Fieldref);\n+    public Type getFieldType( final ConstantPoolGen cpg ) {\n+        return Type.getType(getSignature(cpg));\n+    }\n+\n+\n+    \/** @return name of referenced field.\n+     *\/\n+    public String getFieldName( final ConstantPoolGen cpg ) {\n+        return getName(cpg);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldInstruction.java","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Imnplement this interface if you're interested in changes to a FieldGen object and register yourself with\n- * addObserver().\n+ * Imnplement this interface if you're interested in changes to a FieldGen object\n+ * and register yourself with addObserver().\n+ *\n@@ -30,1 +31,1 @@\n-    void notify(FieldGen field);\n+    void notify( FieldGen field );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldObserver.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -32,1 +31,3 @@\n- * Super class for InvokeInstruction and FieldInstruction, since they have some methods in common!\n+ * Super class for InvokeInstruction and FieldInstruction, since they have\n+ * some methods in common!\n+ *\n@@ -37,1 +38,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -43,0 +45,1 @@\n+\n@@ -50,0 +53,21 @@\n+\n+    \/** @return signature of referenced method\/field.\n+     *\/\n+    public String getSignature(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n+        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return ((ConstantUtf8) cp.getConstant(cnat.getSignatureIndex())).getBytes();\n+    }\n+\n+\n+    \/** @return name of referenced method\/field.\n+     *\/\n+    public String getName(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n+        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n+    }\n+\n+\n@@ -52,4 +76,7 @@\n-     * @deprecated If the instruction references an array class, this method will return \"java.lang.Object\". For code\n-     *             generated by Java 1.5, this answer is sometimes wrong (e.g., if the \"clone()\" method is called on an\n-     *             array). A better idea is to use the {@link #getReferenceType(ConstantPoolGen)} method, which correctly\n-     *             distinguishes between class types and array types.\n+     * @deprecated If the instruction references an array class,\n+     *    this method will return \"java.lang.Object\".\n+     *    For code generated by Java 1.5, this answer is\n+     *    sometimes wrong (e.g., if the \"clone()\" method is\n+     *    called on an array).  A better idea is to use\n+     *    the {@link #getReferenceType(ConstantPoolGen)} method, which correctly distinguishes\n+     *    between class types and array types.\n@@ -67,1 +94,1 @@\n-        return Utility.pathToPackage(className);\n+        return className.replace('\/', '.');\n@@ -70,4 +97,5 @@\n-    \/**\n-     * @return type of the referenced class\/interface\n-     * @deprecated If the instruction references an array class, the ObjectType returned will be invalid. Use\n-     *             getReferenceType() instead.\n+\n+    \/** @return type of the referenced class\/interface\n+     * @deprecated If the instruction references an array class,\n+     *    the ObjectType returned will be invalid.  Use\n+     *    getReferenceType() instead.\n@@ -80,24 +108,0 @@\n-    \/**\n-     * Gets the ObjectType of the method return or field.\n-     *\n-     * @return type of the referenced class\/interface\n-     * @throws ClassGenException when the field is (or method returns) an array,\n-     *\/\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        final ReferenceType rt = getReferenceType(cpg);\n-        if (rt instanceof ObjectType) {\n-            return (ObjectType) rt;\n-        }\n-        throw new ClassGenException(rt.getClass().getCanonicalName() + \" \" + rt.getSignature() + \" does not represent an ObjectType\");\n-    }\n-\n-    \/**\n-     * @return name of referenced method\/field.\n-     *\/\n-    public String getName(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n-        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n-        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n-    }\n@@ -106,2 +110,2 @@\n-     * Gets the reference type representing the class, interface, or array class referenced by the instruction.\n-     *\n+     * Gets the reference type representing the class, interface,\n+     * or array class referenced by the instruction.\n@@ -109,2 +113,3 @@\n-     * @return an ObjectType (if the referenced class type is a class or interface), or an ArrayType (if the referenced\n-     *         class type is an array class)\n+     * @return an ObjectType (if the referenced class type is a class\n+     *   or interface), or an ArrayType (if the referenced class\n+     *   type is an array class)\n@@ -119,1 +124,1 @@\n-        className = Utility.pathToPackage(className);\n+        className = className.replace('\/', '.');\n@@ -123,0 +128,1 @@\n+\n@@ -124,1 +130,4 @@\n-     * @return signature of referenced method\/field.\n+     * Gets the ObjectType of the method return or field.\n+     *\n+     * @return type of the referenced class\/interface\n+     * @throws ClassGenException when the field is (or method returns) an array,\n@@ -126,5 +135,8 @@\n-    public String getSignature(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n-        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n-        return ((ConstantUtf8) cp.getConstant(cnat.getSignatureIndex())).getBytes();\n+    @Override\n+    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+        final ReferenceType rt = getReferenceType(cpg);\n+        if (rt instanceof ObjectType) {\n+            return (ObjectType) rt;\n+        }\n+        throw new ClassGenException(rt.getClass().getCanonicalName() + \" \" +\n+                rt.getSignature() + \" does not represent an ObjectType\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldOrMethod.java","additions":59,"deletions":47,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n- *\n- * <PRE>\n- * Stack: ..., objectref -&gt; ..., value\n- * <\/PRE>\n- *\n+ * <PRE>Stack: ..., objectref -&gt; ..., value<\/PRE>\n@@ -34,0 +30,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ..., value.word1, value.word2<\/PRE>\n@@ -35,3 +32,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ..., value.word1, value.word2\n- * <\/PRE>\n@@ -39,1 +33,2 @@\n-public class GETFIELD extends FieldInstruction implements ExceptionThrower, StackConsumer, StackProducer {\n+public class GETFIELD extends FieldInstruction implements ExceptionThrower, StackConsumer,\n+        StackProducer {\n@@ -42,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -47,0 +43,1 @@\n+\n@@ -51,0 +48,15 @@\n+\n+    @Override\n+    public int produceStack( final ConstantPoolGen cpg ) {\n+        return getFieldSize(cpg);\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -52,2 +64,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -58,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -69,11 +83,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-    @Override\n-    public int produceStack(final ConstantPoolGen cpg) {\n-        return getFieldSize(cpg);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GETFIELD.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -29,5 +29,1 @@\n- *\n- * <PRE>\n- * Stack: ..., -&gt; ..., value\n- * <\/PRE>\n- *\n+ * <PRE>Stack: ..., -&gt; ..., value<\/PRE>\n@@ -35,0 +31,1 @@\n+ * <PRE>Stack: ..., -&gt; ..., value.word1, value.word2<\/PRE>\n@@ -36,3 +33,0 @@\n- * <PRE>\n- * Stack: ..., -&gt; ..., value.word1, value.word2\n- * <\/PRE>\n@@ -43,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +43,1 @@\n+\n@@ -52,0 +48,14 @@\n+\n+    @Override\n+    public int produceStack( final ConstantPoolGen cpg ) {\n+        return getFieldSize(cpg);\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -53,2 +63,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,10 +82,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-    @Override\n-    public int produceStack(final ConstantPoolGen cpg) {\n-        return getFieldSize(cpg);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GETSTATIC.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *\n@@ -33,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -38,0 +40,1 @@\n+\n@@ -42,14 +45,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitUnconditionalBranch(this);\n-        v.visitBranchInstruction(this);\n-        v.visitGotoInstruction(this);\n-        v.visitGOTO(this);\n-    }\n@@ -59,1 +48,0 @@\n-     *\n@@ -63,1 +51,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -65,2 +53,2 @@\n-        final short opcode = getOpcode();\n-        if (opcode == com.sun.org.apache.bcel.internal.Const.GOTO) {\n+        final short _opcode = getOpcode();\n+        if (_opcode == com.sun.org.apache.bcel.internal.Const.GOTO) {\n@@ -70,1 +58,1 @@\n-            out.writeByte(opcode);\n+            out.writeByte(_opcode);\n@@ -75,0 +63,1 @@\n+\n@@ -76,2 +65,2 @@\n-     * Called in pass 2 of InstructionList.setPositions() in order to update the branch target, that may shift due to\n-     * variable length instructions.\n+     * Called in pass 2 of InstructionList.setPositions() in order to update\n+     * the branch target, that may shift due to variable length instructions.\n@@ -80,1 +69,1 @@\n-     * @param maxOffset the maximum offset that may be caused by these instructions\n+     * @param max_offset the maximum offset that may be caused by these instructions\n@@ -84,1 +73,1 @@\n-    protected int updatePosition(final int offset, final int maxOffset) {\n+    protected int updatePosition( final int offset, final int max_offset ) {\n@@ -87,1 +76,1 @@\n-        if (Math.abs(i) >= Short.MAX_VALUE - maxOffset) { \/\/ to large for short (estimate)\n+        if (Math.abs(i) >= (Short.MAX_VALUE - max_offset)) { \/\/ to large for short (estimate)\n@@ -89,1 +78,1 @@\n-            final short oldLength = (short) super.getLength();\n+            final short old_length = (short) super.getLength();\n@@ -91,1 +80,1 @@\n-            return super.getLength() - oldLength;\n+            return super.getLength() - old_length;\n@@ -95,0 +84,18 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitUnconditionalBranch(this);\n+        v.visitBranchInstruction(this);\n+        v.visitGotoInstruction(this);\n+        v.visitGOTO(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GOTO.java","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -35,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,0 +42,1 @@\n+\n@@ -45,13 +48,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitUnconditionalBranch(this);\n-        v.visitBranchInstruction(this);\n-        v.visitGotoInstruction(this);\n-        v.visitGOTO_W(this);\n-    }\n@@ -61,1 +51,0 @@\n-     *\n@@ -65,1 +54,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -71,0 +60,1 @@\n+\n@@ -75,1 +65,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -79,0 +69,17 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitUnconditionalBranch(this);\n+        v.visitBranchInstruction(this);\n+        v.visitGotoInstruction(this);\n+        v.visitGOTO_W(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GOTO_W.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -29,0 +30,5 @@\n+    GotoInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, target);\n+    }\n+\n+\n@@ -30,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -34,4 +41,0 @@\n-\n-    GotoInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, target);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GotoInstruction.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to byte\n+    \/** Convert int to byte\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2B.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to char\n+    \/** Convert int to char\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2C.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to double\n+    \/** Convert int to double\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2D.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to float\n+    \/** Convert int to float\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2F.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to long\n+    \/** Convert int to long\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2S.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Add ints\n+    \/** Add ints\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -40,0 +38,1 @@\n+\n@@ -41,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IALOAD.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IAND.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * IASTORE - Store into int array\n+ * IASTORE -  Store into int array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -40,0 +38,1 @@\n+\n@@ -41,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IASTORE.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * <PRE>\n- * Stack: ... -&gt; ...,\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., <\/PRE>\n@@ -32,1 +30,2 @@\n-    private final int value;\n+    private int value;\n+\n@@ -35,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -38,1 +38,0 @@\n-        this(0);\n@@ -41,0 +40,1 @@\n+\n@@ -43,1 +43,3 @@\n-        if (i < -1 || i > 5) {\n+        if ((i >= -1) && (i <= 5)) {\n+            super.setOpcode((short) (com.sun.org.apache.bcel.internal.Const.ICONST_0 + i)); \/\/ Even works for i == -1\n+        } else {\n@@ -46,1 +48,0 @@\n-        super.setOpcode((short) (com.sun.org.apache.bcel.internal.Const.ICONST_0 + i)); \/\/ Even works for i == -1\n@@ -50,0 +51,15 @@\n+\n+    @Override\n+    public Number getValue() {\n+        return Integer.valueOf(value);\n+    }\n+\n+\n+    \/** @return Type.INT\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.INT;\n+    }\n+\n+\n@@ -51,2 +67,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +75,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -64,13 +82,0 @@\n-\n-    \/**\n-     * @return Type.INT\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.INT;\n-    }\n-\n-    @Override\n-    public Number getValue() {\n-        return Integer.valueOf(value);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ICONST.java","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -35,2 +33,1 @@\n-    \/**\n-     * Divide ints\n+    \/** Divide ints\n@@ -42,0 +39,11 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ARITHMETIC_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -43,2 +51,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +59,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -57,8 +67,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IDIV.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction, e.g. IFEQ.negate() == IFNE\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction, e.g. IFEQ.negate() == IFNE\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFEQ.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFLT(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFLT(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFGE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFLE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFLE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFGT.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFGT(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFGT(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFLE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFGE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFGE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFLT.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFEQ(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFEQ(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., reference -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., reference -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNULL(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNULL(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNONNULL.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., reference -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., reference -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNONNULL(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNONNULL(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNULL.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ACMPNE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ACMPNE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ACMPEQ.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ACMPEQ(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ACMPEQ(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ACMPNE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPNE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPNE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPEQ.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPLT(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPLT(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPGE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPLE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPLE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPGT.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPGT(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPGT(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPLE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPGE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPGE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPLT.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPEQ(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPEQ(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPNE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -32,0 +31,1 @@\n+ *\n@@ -38,0 +38,1 @@\n+\n@@ -39,1 +40,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -44,0 +46,1 @@\n+\n@@ -49,2 +52,2 @@\n-        \/\/ Default behavior of LocalVariableInstruction causes error\n-        super.setOpcode(Const.IINC);\n+        super(); \/\/ Default behavior of LocalVariableInstruction causes error\n+        super.setOpcode(com.sun.org.apache.bcel.internal.Const.IINC);\n@@ -56,11 +59,0 @@\n-    \/**\n-     * Calls corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitLocalVariableInstruction(this);\n-        v.visitIINC(this);\n-    }\n@@ -69,2 +61,1 @@\n-     * Dumps instruction as byte code to stream out.\n-     *\n+     * Dump instruction as byte code to stream out.\n@@ -74,1 +65,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -76,1 +67,1 @@\n-            out.writeByte(Const.WIDE);\n+            out.writeByte(com.sun.org.apache.bcel.internal.Const.WIDE);\n@@ -88,6 +79,0 @@\n-    \/**\n-     * @return increment factor\n-     *\/\n-    public final int getIncrement() {\n-        return c;\n-    }\n@@ -95,6 +80,12 @@\n-    \/**\n-     * @return int type\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.INT;\n+    private void setWide() {\n+        wide = super.getIndex() > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n+        if (c > 0) {\n+            wide = wide || (c > Byte.MAX_VALUE);\n+        } else {\n+            wide = wide || (c < Byte.MIN_VALUE);\n+        }\n+        if (wide) {\n+            super.setLength(6); \/\/ wide byte included\n+        } else {\n+            super.setLength(3);\n+        }\n@@ -103,0 +94,1 @@\n+\n@@ -104,1 +96,1 @@\n-     * Reads needed data (e.g. index) from file.\n+     * Read needed data (e.g. index) from file.\n@@ -107,1 +99,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -120,0 +112,1 @@\n+\n@@ -121,1 +114,1 @@\n-     * Sets increment factor.\n+     * @return mnemonic for instruction\n@@ -123,3 +116,3 @@\n-    public final void setIncrement(final int c) {\n-        this.c = c;\n-        setWide();\n+    @Override\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + c;\n@@ -128,0 +121,1 @@\n+\n@@ -129,1 +123,1 @@\n-     * Sets index of local variable.\n+     * Set index of local variable.\n@@ -132,1 +126,1 @@\n-    public final void setIndex(final int n) {\n+    public final void setIndex( final int n ) {\n@@ -140,12 +134,6 @@\n-    private void setWide() {\n-        wide = super.getIndex() > Const.MAX_BYTE;\n-        if (c > 0) {\n-            wide = wide || c > Byte.MAX_VALUE;\n-        } else {\n-            wide = wide || c < Byte.MIN_VALUE;\n-        }\n-        if (wide) {\n-            super.setLength(6); \/\/ wide byte included\n-        } else {\n-            super.setLength(3);\n-        }\n+\n+    \/**\n+     * @return increment factor\n+     *\/\n+    public final int getIncrement() {\n+        return c;\n@@ -154,0 +142,1 @@\n+\n@@ -155,1 +144,21 @@\n-     * Returns mnemonic for instruction.\n+     * Set increment factor.\n+     *\/\n+    public final void setIncrement( final int c ) {\n+        this.c = c;\n+        setWide();\n+    }\n+\n+\n+    \/** @return int type\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.INT;\n+    }\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -157,1 +166,1 @@\n-     * @return mnemonic for instruction.\n+     * @param v Visitor object\n@@ -160,2 +169,3 @@\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + c;\n+    public void accept( final Visitor v ) {\n+        v.visitLocalVariableInstruction(this);\n+        v.visitIINC(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IINC.java","additions":65,"deletions":55,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ... -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., result\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Load int from local variable\n-     *\n+\n+    \/** Load int from local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ILOAD.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -33,0 +34,1 @@\n+\n@@ -34,2 +36,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -40,1 +44,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMPDEP1.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -33,0 +34,1 @@\n+\n@@ -34,2 +36,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -40,1 +44,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMPDEP2.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Multiply ints\n+    \/** Multiply ints\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INEG.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ..., result<\/PRE>\n@@ -29,3 +30,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ..., result\n- * <\/PRE>\n@@ -33,1 +31,2 @@\n-public class INSTANCEOF extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer, StackConsumer {\n+public class INSTANCEOF extends CPInstruction implements LoadClass, ExceptionThrower,\n+        StackProducer, StackConsumer {\n@@ -36,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -41,0 +41,1 @@\n+\n@@ -45,0 +46,17 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION);\n+    }\n+\n+\n+    @Override\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n+        Type t = getType(cpg);\n+        if (t instanceof ArrayType) {\n+            t = ((ArrayType) t).getBasicType();\n+        }\n+        return (t instanceof ObjectType) ? (ObjectType) t : null;\n+    }\n+\n+\n@@ -46,2 +64,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -52,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -61,14 +81,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION);\n-    }\n-\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        Type t = getType(cpg);\n-        if (t instanceof ArrayType) {\n-            t = ((ArrayType) t).getBasicType();\n-        }\n-        return t instanceof ObjectType ? (ObjectType) t : null;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INSTANCEOF.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,3 @@\n- * Class for INVOKEDYNAMIC. Not an instance of InvokeInstruction, since that class expects to be able to get the class\n- * of the method. Ignores the bootstrap mechanism entirely.\n+ * Class for INVOKEDYNAMIC. Not an instance of InvokeInstruction, since that class\n+ * expects to be able to get the class of the method. Ignores the bootstrap\n+ * mechanism entirely.\n@@ -37,2 +38,3 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\"> The\n- *      invokedynamic instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\">\n+ * The invokedynamic instruction in The Java Virtual Machine Specification<\/a>\n@@ -40,1 +42,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -45,1 +47,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -50,0 +53,1 @@\n+\n@@ -54,0 +58,45 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+        out.writeByte(0);\n+        out.writeByte(0);\n+       }\n+\n+\n+    \/**\n+     * Read needed data (i.e., index) from file.\n+     *\/\n+    @Override\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.initFromFile(bytes, wide);\n+        super.setLength(5);\n+        bytes.readByte(); \/\/ Skip 0 byte\n+        bytes.readByte(); \/\/ Skip 0 byte\n+    }\n+\n+\n+    \/**\n+     * @return mnemonic for instruction with symbolic references resolved\n+     *\/\n+    @Override\n+    public String toString( final ConstantPool cp ) {\n+        return super.toString(cp);\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR,\n+            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -55,2 +104,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -61,1 +112,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -74,1 +125,1 @@\n-     * Dump instruction as byte code to stream out.\n+     * Override the parent method because our classname is held elsewhere.\n@@ -76,12 +127,2 @@\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-        out.writeByte(0);\n-        out.writeByte(0);\n-    }\n-\n-    \/**\n-     * Override the parent method because our class name is held elsewhere.\n+     * @param cpg the ConstantPool generator\n+     * @deprecated in FieldOrMethod\n@@ -89,2 +130,1 @@\n-     * Note: Contrary to this method's name it does not return the class name of the invoke target; rather it returns the\n-     * name of the method that will be used to invoke the Lambda method generated by this invoke dynamic instruction.\n+     * @return name of the referenced class\/interface\n@@ -96,2 +136,2 @@\n-        final ConstantInvokeDynamic cid = cp.getConstant(super.getIndex(), Const.CONSTANT_InvokeDynamic, ConstantInvokeDynamic.class);\n-        return cp.getConstant(cid.getNameAndTypeIndex(), ConstantNameAndType.class).getName(cp);\n+        final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) cp.getConstant(super.getIndex(), Const.CONSTANT_InvokeDynamic);\n+        return ((ConstantNameAndType) cp.getConstant(cid.getNameAndTypeIndex())).getName(cp);\n@@ -100,5 +140,0 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.ILLEGAL_ACCESS_ERROR, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n@@ -107,2 +142,2 @@\n-     * Since InvokeDynamic doesn't refer to a reference type, just return java.lang.Object, as that is the only type we can\n-     * say for sure the reference will be.\n+     * Since InvokeDynamic doesn't refer to a reference type, just return java.lang.Object,\n+     * as that is the only type we can say for sure the reference will be.\n@@ -110,1 +145,2 @@\n-     * @param cpg the ConstantPoolGen used to create the instruction\n+     * @param cpg\n+     *            the ConstantPoolGen used to create the instruction\n@@ -118,12 +154,0 @@\n-\n-    \/**\n-     * Read needed data (i.e., index) from file.\n-     *\/\n-    @Override\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.initFromFile(bytes, wide);\n-        super.setLength(5);\n-        bytes.readByte(); \/\/ Skip 0 byte\n-        bytes.readByte(); \/\/ Skip 0 byte\n-    }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEDYNAMIC.java","additions":71,"deletions":47,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -35,6 +36,3 @@\n- * <PRE>\n- * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n- * <\/PRE>\n- *\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\"> The\n- *      invokeinterface instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\">\n+ * The invokeinterface instruction in The Java Virtual Machine Specification<\/a>\n@@ -46,0 +44,1 @@\n+\n@@ -47,1 +46,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -52,0 +52,1 @@\n+\n@@ -61,23 +62,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitStackProducer(this);\n-        v.visitLoadClass(this);\n-        v.visitCPInstruction(this);\n-        v.visitFieldOrMethod(this);\n-        v.visitInvokeInstruction(this);\n-        v.visitINVOKEINTERFACE(this);\n-    }\n-\n-    @Override\n-    public int consumeStack(final ConstantPoolGen cpg) { \/\/ nargs is given in byte-code\n-        return nargs; \/\/ nargs includes this reference\n-    }\n@@ -87,1 +65,0 @@\n-     *\n@@ -91,1 +68,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -98,0 +75,1 @@\n+\n@@ -99,1 +77,2 @@\n-     * The <B>count<\/B> argument according to the Java Language Specification, Second Edition.\n+     * The <B>count<\/B> argument according to the Java Language Specification,\n+     * Second Edition.\n@@ -105,5 +84,0 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.ILLEGAL_ACCESS_ERROR, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n@@ -115,1 +89,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -122,0 +96,1 @@\n+\n@@ -126,1 +101,1 @@\n-    public String toString(final ConstantPool cp) {\n+    public String toString( final ConstantPool cp ) {\n@@ -129,0 +104,38 @@\n+\n+\n+    @Override\n+    public int consumeStack( final ConstantPoolGen cpg ) { \/\/ nargs is given in byte-code\n+        return nargs; \/\/ nargs includes this reference\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR,\n+            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitStackProducer(this);\n+        v.visitLoadClass(this);\n+        v.visitCPInstruction(this);\n+        v.visitFieldOrMethod(this);\n+        v.visitInvokeInstruction(this);\n+        v.visitINVOKEINTERFACE(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEINTERFACE.java","additions":53,"deletions":40,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * INVOKESPECIAL - Invoke instance method; special handling for superclass, private and instance initialization method\n- * invocations\n+ * INVOKESPECIAL - Invoke instance method; special handling for superclass, private\n+ * and instance initialization method invocations\n@@ -34,3 +34,1 @@\n- * <PRE>\n- * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -38,2 +36,3 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\"> The\n- *      invokespecial instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\">\n+ * The invokespecial instruction in The Java Virtual Machine Specification<\/a>\n@@ -44,1 +43,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -49,0 +49,1 @@\n+\n@@ -53,0 +54,21 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR);\n+    }\n+\n+\n@@ -54,2 +76,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -60,1 +84,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -71,17 +95,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR, ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.UNSATISFIED_LINK_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKESPECIAL.java","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n- * <PRE>\n- * Stack: ..., [arg1, [arg2 ...]] -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -37,2 +35,3 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\"> The invokestatic\n- *      instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\">\n+ * The invokestatic instruction in The Java Virtual Machine Specification<\/a>\n@@ -43,1 +42,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +48,1 @@\n+\n@@ -52,0 +53,19 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+      out.writeByte(super.getOpcode());\n+      out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -53,2 +73,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,17 +92,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKESTATIC.java","additions":31,"deletions":26,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n- * <PRE>\n- * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -37,2 +35,3 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\"> The\n- *      invokevirtual instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\">\n+ * The invokevirtual instruction in The Java Virtual Machine Specification<\/a>\n@@ -43,1 +42,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +48,1 @@\n+\n@@ -52,0 +53,21 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR);\n+    }\n+\n+\n@@ -53,2 +75,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +83,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,17 +94,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR, ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.UNSATISFIED_LINK_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEVIRTUAL.java","additions":33,"deletions":26,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IOR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -35,2 +33,1 @@\n-    \/**\n-     * Remainder of ints\n+    \/** Remainder of ints\n@@ -42,0 +39,11 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ARITHMETIC_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -43,2 +51,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +59,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -57,8 +67,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IREM.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * IRETURN - Return int from method\n+ * IRETURN -  Return int from method\n+ * <PRE>Stack: ..., value -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Return int from method\n+    \/** Return int from method\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISHL.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISHR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ... <\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Store int into local variable\n-     *\n+\n+    \/** Store int into local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISTORE.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Substract ints\n+    \/** Substract ints\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IUSHR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IXOR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -30,1 +31,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -35,0 +37,1 @@\n+\n@@ -43,0 +46,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IfInstruction.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denote entity that refers to an index, e.g. local variable instructions, RET, CPInstruction, etc.\n+ * Denote entity that refers to an index, e.g. local variable instructions,\n+ * RET, CPInstruction, etc.\n+ *\n@@ -31,1 +33,2 @@\n-    void setIndex(int index);\n+\n+    void setIndex( int index );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IndexedInstruction.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: July 2020\n@@ -36,1 +36,2 @@\n-    static final Instruction[] EMPTY_ARRAY = {};\n+    private short length = 1; \/\/ Length of instruction in bytes\n+    private short opcode = -1; \/\/ Opcode number\n@@ -40,10 +41,0 @@\n-    \/**\n-     * Gets Comparator object used in the equals() method to determine equality of instructions.\n-     *\n-     * @return currently used comparator for equals()\n-     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n-     *\/\n-    @Deprecated\n-    public static InstructionComparator getComparator() {\n-        return cmp;\n-    }\n@@ -52,5 +43,2 @@\n-     * Tests if the value can fit in a byte (signed)\n-     *\n-     * @param value the value to check\n-     * @return true if the value is in range\n-     * @since 6.0\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -58,2 +46,1 @@\n-    public static boolean isValidByte(final int value) {\n-        return value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE;\n+    Instruction() {\n@@ -62,9 +49,4 @@\n-    \/**\n-     * Tests if the value can fit in a short (signed)\n-     *\n-     * @param value the value to check\n-     * @return true if the value is in range\n-     * @since 6.0\n-     *\/\n-    public static boolean isValidShort(final int value) {\n-        return value >= Short.MIN_VALUE && value <= Short.MAX_VALUE;\n+\n+    public Instruction(final short opcode, final short length) {\n+        this.length = length;\n+        this.opcode = opcode;\n@@ -73,0 +55,1 @@\n+\n@@ -74,8 +57,2 @@\n-     * Reads an instruction from (byte code) input stream and return the appropriate object.\n-     * <p>\n-     * If the Instruction is defined in {@link InstructionConst}, then the singleton instance is returned.\n-     * <\/p>\n-     * @param bytes input stream bytes\n-     * @return instruction object being read\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n-     * @see InstructionConst#getInstruction(int)\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n@@ -83,308 +60,3 @@\n-    \/\/ @since 6.0 no longer final\n-    public static Instruction readInstruction(final ByteSequence bytes) throws IOException {\n-        boolean wide = false;\n-        short opcode = (short) bytes.readUnsignedByte();\n-        Instruction obj = null;\n-        if (opcode == Const.WIDE) { \/\/ Read next opcode after wide byte\n-            wide = true;\n-            opcode = (short) bytes.readUnsignedByte();\n-        }\n-        final Instruction instruction = InstructionConst.getInstruction(opcode);\n-        if (instruction != null) {\n-            return instruction; \/\/ Used predefined immutable object, if available\n-        }\n-\n-        switch (opcode) {\n-        case Const.BIPUSH:\n-            obj = new BIPUSH();\n-            break;\n-        case Const.SIPUSH:\n-            obj = new SIPUSH();\n-            break;\n-        case Const.LDC:\n-            obj = new LDC();\n-            break;\n-        case Const.LDC_W:\n-            obj = new LDC_W();\n-            break;\n-        case Const.LDC2_W:\n-            obj = new LDC2_W();\n-            break;\n-        case Const.ILOAD:\n-            obj = new ILOAD();\n-            break;\n-        case Const.LLOAD:\n-            obj = new LLOAD();\n-            break;\n-        case Const.FLOAD:\n-            obj = new FLOAD();\n-            break;\n-        case Const.DLOAD:\n-            obj = new DLOAD();\n-            break;\n-        case Const.ALOAD:\n-            obj = new ALOAD();\n-            break;\n-        case Const.ILOAD_0:\n-            obj = new ILOAD(0);\n-            break;\n-        case Const.ILOAD_1:\n-            obj = new ILOAD(1);\n-            break;\n-        case Const.ILOAD_2:\n-            obj = new ILOAD(2);\n-            break;\n-        case Const.ILOAD_3:\n-            obj = new ILOAD(3);\n-            break;\n-        case Const.LLOAD_0:\n-            obj = new LLOAD(0);\n-            break;\n-        case Const.LLOAD_1:\n-            obj = new LLOAD(1);\n-            break;\n-        case Const.LLOAD_2:\n-            obj = new LLOAD(2);\n-            break;\n-        case Const.LLOAD_3:\n-            obj = new LLOAD(3);\n-            break;\n-        case Const.FLOAD_0:\n-            obj = new FLOAD(0);\n-            break;\n-        case Const.FLOAD_1:\n-            obj = new FLOAD(1);\n-            break;\n-        case Const.FLOAD_2:\n-            obj = new FLOAD(2);\n-            break;\n-        case Const.FLOAD_3:\n-            obj = new FLOAD(3);\n-            break;\n-        case Const.DLOAD_0:\n-            obj = new DLOAD(0);\n-            break;\n-        case Const.DLOAD_1:\n-            obj = new DLOAD(1);\n-            break;\n-        case Const.DLOAD_2:\n-            obj = new DLOAD(2);\n-            break;\n-        case Const.DLOAD_3:\n-            obj = new DLOAD(3);\n-            break;\n-        case Const.ALOAD_0:\n-            obj = new ALOAD(0);\n-            break;\n-        case Const.ALOAD_1:\n-            obj = new ALOAD(1);\n-            break;\n-        case Const.ALOAD_2:\n-            obj = new ALOAD(2);\n-            break;\n-        case Const.ALOAD_3:\n-            obj = new ALOAD(3);\n-            break;\n-        case Const.ISTORE:\n-            obj = new ISTORE();\n-            break;\n-        case Const.LSTORE:\n-            obj = new LSTORE();\n-            break;\n-        case Const.FSTORE:\n-            obj = new FSTORE();\n-            break;\n-        case Const.DSTORE:\n-            obj = new DSTORE();\n-            break;\n-        case Const.ASTORE:\n-            obj = new ASTORE();\n-            break;\n-        case Const.ISTORE_0:\n-            obj = new ISTORE(0);\n-            break;\n-        case Const.ISTORE_1:\n-            obj = new ISTORE(1);\n-            break;\n-        case Const.ISTORE_2:\n-            obj = new ISTORE(2);\n-            break;\n-        case Const.ISTORE_3:\n-            obj = new ISTORE(3);\n-            break;\n-        case Const.LSTORE_0:\n-            obj = new LSTORE(0);\n-            break;\n-        case Const.LSTORE_1:\n-            obj = new LSTORE(1);\n-            break;\n-        case Const.LSTORE_2:\n-            obj = new LSTORE(2);\n-            break;\n-        case Const.LSTORE_3:\n-            obj = new LSTORE(3);\n-            break;\n-        case Const.FSTORE_0:\n-            obj = new FSTORE(0);\n-            break;\n-        case Const.FSTORE_1:\n-            obj = new FSTORE(1);\n-            break;\n-        case Const.FSTORE_2:\n-            obj = new FSTORE(2);\n-            break;\n-        case Const.FSTORE_3:\n-            obj = new FSTORE(3);\n-            break;\n-        case Const.DSTORE_0:\n-            obj = new DSTORE(0);\n-            break;\n-        case Const.DSTORE_1:\n-            obj = new DSTORE(1);\n-            break;\n-        case Const.DSTORE_2:\n-            obj = new DSTORE(2);\n-            break;\n-        case Const.DSTORE_3:\n-            obj = new DSTORE(3);\n-            break;\n-        case Const.ASTORE_0:\n-            obj = new ASTORE(0);\n-            break;\n-        case Const.ASTORE_1:\n-            obj = new ASTORE(1);\n-            break;\n-        case Const.ASTORE_2:\n-            obj = new ASTORE(2);\n-            break;\n-        case Const.ASTORE_3:\n-            obj = new ASTORE(3);\n-            break;\n-        case Const.IINC:\n-            obj = new IINC();\n-            break;\n-        case Const.IFEQ:\n-            obj = new IFEQ();\n-            break;\n-        case Const.IFNE:\n-            obj = new IFNE();\n-            break;\n-        case Const.IFLT:\n-            obj = new IFLT();\n-            break;\n-        case Const.IFGE:\n-            obj = new IFGE();\n-            break;\n-        case Const.IFGT:\n-            obj = new IFGT();\n-            break;\n-        case Const.IFLE:\n-            obj = new IFLE();\n-            break;\n-        case Const.IF_ICMPEQ:\n-            obj = new IF_ICMPEQ();\n-            break;\n-        case Const.IF_ICMPNE:\n-            obj = new IF_ICMPNE();\n-            break;\n-        case Const.IF_ICMPLT:\n-            obj = new IF_ICMPLT();\n-            break;\n-        case Const.IF_ICMPGE:\n-            obj = new IF_ICMPGE();\n-            break;\n-        case Const.IF_ICMPGT:\n-            obj = new IF_ICMPGT();\n-            break;\n-        case Const.IF_ICMPLE:\n-            obj = new IF_ICMPLE();\n-            break;\n-        case Const.IF_ACMPEQ:\n-            obj = new IF_ACMPEQ();\n-            break;\n-        case Const.IF_ACMPNE:\n-            obj = new IF_ACMPNE();\n-            break;\n-        case Const.GOTO:\n-            obj = new GOTO();\n-            break;\n-        case Const.JSR:\n-            obj = new JSR();\n-            break;\n-        case Const.RET:\n-            obj = new RET();\n-            break;\n-        case Const.TABLESWITCH:\n-            obj = new TABLESWITCH();\n-            break;\n-        case Const.LOOKUPSWITCH:\n-            obj = new LOOKUPSWITCH();\n-            break;\n-        case Const.GETSTATIC:\n-            obj = new GETSTATIC();\n-            break;\n-        case Const.PUTSTATIC:\n-            obj = new PUTSTATIC();\n-            break;\n-        case Const.GETFIELD:\n-            obj = new GETFIELD();\n-            break;\n-        case Const.PUTFIELD:\n-            obj = new PUTFIELD();\n-            break;\n-        case Const.INVOKEVIRTUAL:\n-            obj = new INVOKEVIRTUAL();\n-            break;\n-        case Const.INVOKESPECIAL:\n-            obj = new INVOKESPECIAL();\n-            break;\n-        case Const.INVOKESTATIC:\n-            obj = new INVOKESTATIC();\n-            break;\n-        case Const.INVOKEINTERFACE:\n-            obj = new INVOKEINTERFACE();\n-            break;\n-        case Const.INVOKEDYNAMIC:\n-            obj = new INVOKEDYNAMIC();\n-            break;\n-        case Const.NEW:\n-            obj = new NEW();\n-            break;\n-        case Const.NEWARRAY:\n-            obj = new NEWARRAY();\n-            break;\n-        case Const.ANEWARRAY:\n-            obj = new ANEWARRAY();\n-            break;\n-        case Const.CHECKCAST:\n-            obj = new CHECKCAST();\n-            break;\n-        case Const.INSTANCEOF:\n-            obj = new INSTANCEOF();\n-            break;\n-        case Const.MULTIANEWARRAY:\n-            obj = new MULTIANEWARRAY();\n-            break;\n-        case Const.IFNULL:\n-            obj = new IFNULL();\n-            break;\n-        case Const.IFNONNULL:\n-            obj = new IFNONNULL();\n-            break;\n-        case Const.GOTO_W:\n-            obj = new GOTO_W();\n-            break;\n-        case Const.JSR_W:\n-            obj = new JSR_W();\n-            break;\n-        case Const.BREAKPOINT:\n-            obj = new BREAKPOINT();\n-            break;\n-        case Const.IMPDEP1:\n-            obj = new IMPDEP1();\n-            break;\n-        case Const.IMPDEP2:\n-            obj = new IMPDEP2();\n-            break;\n-        default:\n-            throw new ClassGenException(\"Illegal opcode detected: \" + opcode);\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(opcode); \/\/ Common for all instructions\n+    }\n@@ -392,1 +64,0 @@\n-        }\n@@ -394,6 +65,4 @@\n-        if (wide && !(obj instanceof LocalVariableInstruction || obj instanceof RET)) {\n-            throw new ClassGenException(\"Illegal opcode after wide: \" + opcode);\n-        }\n-        obj.setOpcode(opcode);\n-        obj.initFromFile(bytes, wide); \/\/ Do further initializations, if any\n-        return obj;\n+    \/** @return name of instruction, i.e., opcode name\n+     *\/\n+    public String getName() {\n+        return Const.getOpcodeName(opcode);\n@@ -402,0 +71,1 @@\n+\n@@ -403,1 +73,1 @@\n-     * Sets comparator to be used for equals().\n+     * Long output format:\n@@ -405,1 +75,5 @@\n-     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n+     * \"(\"&lt;length of instruction&gt;\")\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -407,3 +81,5 @@\n-    @Deprecated\n-    public static void setComparator(final InstructionComparator c) {\n-        cmp = c;\n+    public String toString( final boolean verbose ) {\n+        if (verbose) {\n+            return getName() + \"[\" + opcode + \"](\" + length + \")\";\n+        }\n+        return getName();\n@@ -412,5 +88,0 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected short length = 1; \/\/ Length of instruction in bytes\n@@ -419,7 +90,1 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected short opcode = -1; \/\/ Opcode number\n-\n-    \/**\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * @return mnemonic for instruction in verbose format\n@@ -427,6 +92,3 @@\n-    Instruction() {\n-    }\n-\n-    public Instruction(final short opcode, final short length) {\n-        this.length = length;\n-        this.opcode = opcode;\n+    @Override\n+    public String toString() {\n+        return toString(true);\n@@ -435,7 +97,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    public abstract void accept(Visitor v);\n@@ -444,5 +99,1 @@\n-     * This method also gives right results for instructions whose effect on the stack depends on the constant pool entry\n-     * they reference.\n-     *\n-     * @return Number of words consumed from stack by this instruction, or Constants.UNPREDICTABLE, if this can not be\n-     *         computed statically\n+     * @return mnemonic for instruction with sumbolic references resolved\n@@ -450,2 +101,2 @@\n-    public int consumeStack(final ConstantPoolGen cpg) {\n-        return Const.getConsumeStack(opcode);\n+    public String toString( final ConstantPool cp ) {\n+        return toString(false);\n@@ -454,0 +105,1 @@\n+\n@@ -455,2 +107,3 @@\n-     * Use with caution, since 'BranchInstruction's have a 'target' reference which is not copied correctly (only basic\n-     * types are). This also applies for 'Select' instructions with their multiple branch targets.\n+     * Use with caution, since `BranchInstruction's have a `target' reference which\n+     * is not copied correctly (only basic types are). This also applies for\n+     * `Select' instructions with their multiple branch targets.\n@@ -476,5 +129,0 @@\n-    \/**\n-     * Some instructions may be reused, so don't do anything by default.\n-     *\/\n-    void dispose() {\n-    }\n@@ -483,1 +131,1 @@\n-     * Dumps instruction as byte code to stream out.\n+     * Read needed data (e.g. index) from file.\n@@ -485,2 +133,3 @@\n-     * @param out Output stream\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param bytes byte sequence to read from\n+     * @param wide \"wide\" instruction flag\n+     * @throws IOException may be thrown if the implementation needs to read data from the file\n@@ -488,2 +137,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(opcode); \/\/ Common for all instructions\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -492,0 +140,1 @@\n+\n@@ -493,3 +142,8 @@\n-     * Tests for equality, delegated to comparator\n-     *\n-     * @return true if that is an Instruction and has the same opcode\n+     * Read an instruction from (byte code) input stream and return the\n+     * appropiate object.\n+     * <p>\n+     * If the Instruction is defined in {@link InstructionConst}, then the\n+     * singleton instance is returned.\n+     * @param bytes input stream bytes\n+     * @return instruction object being read\n+     * @see InstructionConst#getInstruction(int)\n@@ -497,3 +151,318 @@\n-    @Override\n-    public boolean equals(final Object that) {\n-        return that instanceof Instruction && cmp.equals(this, (Instruction) that);\n+    \/\/ @since 6.0 no longer final\n+    public static Instruction readInstruction( final ByteSequence bytes ) throws IOException {\n+        boolean wide = false;\n+        short opcode = (short) bytes.readUnsignedByte();\n+        Instruction obj = null;\n+        if (opcode == Const.WIDE) { \/\/ Read next opcode after wide byte\n+            wide = true;\n+            opcode = (short) bytes.readUnsignedByte();\n+        }\n+        final Instruction instruction = InstructionConst.getInstruction(opcode);\n+        if (instruction != null) {\n+            return instruction; \/\/ Used predefined immutable object, if available\n+        }\n+\n+        switch (opcode) {\n+            case Const.BIPUSH:\n+                obj = new BIPUSH();\n+                break;\n+            case Const.SIPUSH:\n+                obj = new SIPUSH();\n+                break;\n+            case Const.LDC:\n+                obj = new LDC();\n+                break;\n+            case Const.LDC_W:\n+                obj = new LDC_W();\n+                break;\n+            case Const.LDC2_W:\n+                obj = new LDC2_W();\n+                break;\n+            case Const.ILOAD:\n+                obj = new ILOAD();\n+                break;\n+            case Const.LLOAD:\n+                obj = new LLOAD();\n+                break;\n+            case Const.FLOAD:\n+                obj = new FLOAD();\n+                break;\n+            case Const.DLOAD:\n+                obj = new DLOAD();\n+                break;\n+            case Const.ALOAD:\n+                obj = new ALOAD();\n+                break;\n+            case Const.ILOAD_0:\n+                obj = new ILOAD(0);\n+                break;\n+            case Const.ILOAD_1:\n+                obj = new ILOAD(1);\n+                break;\n+            case Const.ILOAD_2:\n+                obj = new ILOAD(2);\n+                break;\n+            case Const.ILOAD_3:\n+                obj = new ILOAD(3);\n+                break;\n+            case Const.LLOAD_0:\n+                obj = new LLOAD(0);\n+                break;\n+            case Const.LLOAD_1:\n+                obj = new LLOAD(1);\n+                break;\n+            case Const.LLOAD_2:\n+                obj = new LLOAD(2);\n+                break;\n+            case Const.LLOAD_3:\n+                obj = new LLOAD(3);\n+                break;\n+            case Const.FLOAD_0:\n+                obj = new FLOAD(0);\n+                break;\n+            case Const.FLOAD_1:\n+                obj = new FLOAD(1);\n+                break;\n+            case Const.FLOAD_2:\n+                obj = new FLOAD(2);\n+                break;\n+            case Const.FLOAD_3:\n+                obj = new FLOAD(3);\n+                break;\n+            case Const.DLOAD_0:\n+                obj = new DLOAD(0);\n+                break;\n+            case Const.DLOAD_1:\n+                obj = new DLOAD(1);\n+                break;\n+            case Const.DLOAD_2:\n+                obj = new DLOAD(2);\n+                break;\n+            case Const.DLOAD_3:\n+                obj = new DLOAD(3);\n+                break;\n+            case Const.ALOAD_0:\n+                obj = new ALOAD(0);\n+                break;\n+            case Const.ALOAD_1:\n+                obj = new ALOAD(1);\n+                break;\n+            case Const.ALOAD_2:\n+                obj = new ALOAD(2);\n+                break;\n+            case Const.ALOAD_3:\n+                obj = new ALOAD(3);\n+                break;\n+            case Const.ISTORE:\n+                obj = new ISTORE();\n+                break;\n+            case Const.LSTORE:\n+                obj = new LSTORE();\n+                break;\n+            case Const.FSTORE:\n+                obj = new FSTORE();\n+                break;\n+            case Const.DSTORE:\n+                obj = new DSTORE();\n+                break;\n+            case Const.ASTORE:\n+                obj = new ASTORE();\n+                break;\n+            case Const.ISTORE_0:\n+                obj = new ISTORE(0);\n+                break;\n+            case Const.ISTORE_1:\n+                obj = new ISTORE(1);\n+                break;\n+            case Const.ISTORE_2:\n+                obj = new ISTORE(2);\n+                break;\n+            case Const.ISTORE_3:\n+                obj = new ISTORE(3);\n+                break;\n+            case Const.LSTORE_0:\n+                obj = new LSTORE(0);\n+                break;\n+            case Const.LSTORE_1:\n+                obj = new LSTORE(1);\n+                break;\n+            case Const.LSTORE_2:\n+                obj = new LSTORE(2);\n+                break;\n+            case Const.LSTORE_3:\n+                obj = new LSTORE(3);\n+                break;\n+            case Const.FSTORE_0:\n+                obj = new FSTORE(0);\n+                break;\n+            case Const.FSTORE_1:\n+                obj = new FSTORE(1);\n+                break;\n+            case Const.FSTORE_2:\n+                obj = new FSTORE(2);\n+                break;\n+            case Const.FSTORE_3:\n+                obj = new FSTORE(3);\n+                break;\n+            case Const.DSTORE_0:\n+                obj = new DSTORE(0);\n+                break;\n+            case Const.DSTORE_1:\n+                obj = new DSTORE(1);\n+                break;\n+            case Const.DSTORE_2:\n+                obj = new DSTORE(2);\n+                break;\n+            case Const.DSTORE_3:\n+                obj = new DSTORE(3);\n+                break;\n+            case Const.ASTORE_0:\n+                obj = new ASTORE(0);\n+                break;\n+            case Const.ASTORE_1:\n+                obj = new ASTORE(1);\n+                break;\n+            case Const.ASTORE_2:\n+                obj = new ASTORE(2);\n+                break;\n+            case Const.ASTORE_3:\n+                obj = new ASTORE(3);\n+                break;\n+            case Const.IINC:\n+                obj = new IINC();\n+                break;\n+            case Const.IFEQ:\n+                obj = new IFEQ();\n+                break;\n+            case Const.IFNE:\n+                obj = new IFNE();\n+                break;\n+            case Const.IFLT:\n+                obj = new IFLT();\n+                break;\n+            case Const.IFGE:\n+                obj = new IFGE();\n+                break;\n+            case Const.IFGT:\n+                obj = new IFGT();\n+                break;\n+            case Const.IFLE:\n+                obj = new IFLE();\n+                break;\n+            case Const.IF_ICMPEQ:\n+                obj = new IF_ICMPEQ();\n+                break;\n+            case Const.IF_ICMPNE:\n+                obj = new IF_ICMPNE();\n+                break;\n+            case Const.IF_ICMPLT:\n+                obj = new IF_ICMPLT();\n+                break;\n+            case Const.IF_ICMPGE:\n+                obj = new IF_ICMPGE();\n+                break;\n+            case Const.IF_ICMPGT:\n+                obj = new IF_ICMPGT();\n+                break;\n+            case Const.IF_ICMPLE:\n+                obj = new IF_ICMPLE();\n+                break;\n+            case Const.IF_ACMPEQ:\n+                obj = new IF_ACMPEQ();\n+                break;\n+            case Const.IF_ACMPNE:\n+                obj = new IF_ACMPNE();\n+                break;\n+            case Const.GOTO:\n+                obj = new GOTO();\n+                break;\n+            case Const.JSR:\n+                obj = new JSR();\n+                break;\n+            case Const.RET:\n+                obj = new RET();\n+                break;\n+            case Const.TABLESWITCH:\n+                obj = new TABLESWITCH();\n+                break;\n+            case Const.LOOKUPSWITCH:\n+                obj = new LOOKUPSWITCH();\n+                break;\n+            case Const.GETSTATIC:\n+                obj = new GETSTATIC();\n+                break;\n+            case Const.PUTSTATIC:\n+                obj = new PUTSTATIC();\n+                break;\n+            case Const.GETFIELD:\n+                obj = new GETFIELD();\n+                break;\n+            case Const.PUTFIELD:\n+                obj = new PUTFIELD();\n+                break;\n+            case Const.INVOKEVIRTUAL:\n+                obj = new INVOKEVIRTUAL();\n+                break;\n+            case Const.INVOKESPECIAL:\n+                obj = new INVOKESPECIAL();\n+                break;\n+            case Const.INVOKESTATIC:\n+                obj = new INVOKESTATIC();\n+                break;\n+            case Const.INVOKEINTERFACE:\n+                obj = new INVOKEINTERFACE();\n+                break;\n+            case Const.INVOKEDYNAMIC:\n+                obj = new INVOKEDYNAMIC();\n+                break;\n+            case Const.NEW:\n+                obj = new NEW();\n+                break;\n+            case Const.NEWARRAY:\n+                obj = new NEWARRAY();\n+                break;\n+            case Const.ANEWARRAY:\n+                obj = new ANEWARRAY();\n+                break;\n+            case Const.CHECKCAST:\n+                obj = new CHECKCAST();\n+                break;\n+            case Const.INSTANCEOF:\n+                obj = new INSTANCEOF();\n+                break;\n+            case Const.MULTIANEWARRAY:\n+                obj = new MULTIANEWARRAY();\n+                break;\n+            case Const.IFNULL:\n+                obj = new IFNULL();\n+                break;\n+            case Const.IFNONNULL:\n+                obj = new IFNONNULL();\n+                break;\n+            case Const.GOTO_W:\n+                obj = new GOTO_W();\n+                break;\n+            case Const.JSR_W:\n+                obj = new JSR_W();\n+                break;\n+            case Const.BREAKPOINT:\n+                obj = new BREAKPOINT();\n+                break;\n+            case Const.IMPDEP1:\n+                obj = new IMPDEP1();\n+                break;\n+            case Const.IMPDEP2:\n+                obj = new IMPDEP2();\n+                break;\n+            default:\n+                throw new ClassGenException(\"Illegal opcode detected: \" + opcode);\n+\n+        }\n+\n+        if (wide\n+                && !((obj instanceof LocalVariableInstruction) || (obj instanceof IINC) || (obj instanceof RET))) {\n+            throw new ClassGenException(\"Illegal opcode after wide: \" + opcode);\n+        }\n+        obj.setOpcode(opcode);\n+        obj.initFromFile(bytes, wide); \/\/ Do further initializations, if any\n+        return obj;\n@@ -503,1 +472,5 @@\n-     * @return length (in bytes) of instruction\n+     * This method also gives right results for instructions whose\n+     * effect on the stack depends on the constant pool entry they\n+     * reference.\n+     *  @return Number of words consumed from stack by this instruction,\n+     * or Constants.UNPREDICTABLE, if this can not be computed statically\n@@ -505,2 +478,2 @@\n-    public int getLength() {\n-        return length;\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n+        return Const.getConsumeStack(opcode);\n@@ -509,0 +482,1 @@\n+\n@@ -510,1 +484,5 @@\n-     * @return name of instruction, i.e., opcode name\n+     * This method also gives right results for instructions whose\n+     * effect on the stack depends on the constant pool entry they\n+     * reference.\n+     * @return Number of words produced onto stack by this instruction,\n+     * or Constants.UNPREDICTABLE, if this can not be computed statically\n@@ -512,2 +490,2 @@\n-    public String getName() {\n-        return Const.getOpcodeName(opcode);\n+    public int produceStack( final ConstantPoolGen cpg ) {\n+        return Const.getProduceStack(opcode);\n@@ -516,0 +494,1 @@\n+\n@@ -523,10 +502,0 @@\n-    \/**\n-     * Gets the hashCode of this object.\n-     *\n-     * @return the hashCode\n-     * @since 6.0\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return opcode;\n-    }\n@@ -535,5 +504,1 @@\n-     * Reads needed data (e.g. index) from file.\n-     *\n-     * @param bytes byte sequence to read from\n-     * @param wide \"wide\" instruction flag\n-     * @throws IOException may be thrown if the implementation needs to read data from the file\n+     * @return length (in bytes) of instruction\n@@ -541,2 +506,2 @@\n-    @SuppressWarnings(\"unused\") \/\/ thrown by subclasses\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    public int getLength() {\n+        return length;\n@@ -545,0 +510,1 @@\n+\n@@ -546,5 +512,1 @@\n-     * This method also gives right results for instructions whose effect on the stack depends on the constant pool entry\n-     * they reference.\n-     *\n-     * @return Number of words produced onto stack by this instruction, or Constants.UNPREDICTABLE, if this can not be\n-     *         computed statically\n+     * Needed in readInstruction and subclasses in this package\n@@ -552,2 +514,2 @@\n-    public int produceStack(final ConstantPoolGen cpg) {\n-        return Const.getProduceStack(opcode);\n+    void setOpcode( final short opcode ) {\n+        this.opcode = opcode;\n@@ -556,0 +518,1 @@\n+\n@@ -558,1 +521,0 @@\n-     *\n@@ -561,1 +523,1 @@\n-    final void setLength(final int length) {\n+    final void setLength( final int length ) {\n@@ -565,2 +527,2 @@\n-    \/**\n-     * Needed in readInstruction and subclasses in this package\n+\n+    \/** Some instructions may be reused, so don't do anything by default.\n@@ -568,2 +530,1 @@\n-    void setOpcode(final short opcode) {\n-        this.opcode = opcode;\n+    void dispose() {\n@@ -572,0 +533,1 @@\n+\n@@ -573,1 +535,33 @@\n-     * @return mnemonic for instruction in verbose format\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    public abstract void accept( Visitor v );\n+\n+\n+    \/** Get Comparator object used in the equals() method to determine\n+     * equality of instructions.\n+     *\n+     * @return currently used comparator for equals()\n+     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n+     *\/\n+    @Deprecated\n+    public static InstructionComparator getComparator() {\n+        return cmp;\n+    }\n+\n+\n+    \/** Set comparator to be used for equals().\n+      * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n+     *\/\n+    @Deprecated\n+    public static void setComparator( final InstructionComparator c ) {\n+        cmp = c;\n+    }\n+\n+\n+    \/** Check for equality, delegated to comparator\n+     * @return true if that is an Instruction and has the same opcode\n@@ -576,2 +570,11 @@\n-    public String toString() {\n-        return toString(true);\n+    public boolean equals( final Object that ) {\n+        return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;\n+    }\n+\n+    \/** calculate the hashCode of this object\n+     * @return the hashCode\n+     * @since 6.0\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return opcode;\n@@ -581,6 +584,4 @@\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\"\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * Check if the value can fit in a byte (signed)\n+     * @param value the value to check\n+     * @return true if the value is in range\n+     * @since 6.0\n@@ -588,5 +589,2 @@\n-    public String toString(final boolean verbose) {\n-        if (verbose) {\n-            return getName() + \"[\" + opcode + \"](\" + length + \")\";\n-        }\n-        return getName();\n+    public static boolean isValidByte(final int value) {\n+        return value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE;\n@@ -596,1 +594,4 @@\n-     * @return mnemonic for instruction with sumbolic references resolved\n+     * Check if the value can fit in a short (signed)\n+     * @param value the value to check\n+     * @return true if the value is in range\n+     * @since 6.0\n@@ -598,2 +599,2 @@\n-    public String toString(final ConstantPool cp) {\n-        return toString(false);\n+    public static boolean isValidShort(final int value) {\n+        return value >= Short.MIN_VALUE && value <= Short.MAX_VALUE;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Instruction.java","additions":461,"deletions":460,"binary":false,"changes":921,"status":"modified"},{"patch":"@@ -25,2 +25,4 @@\n- * Equality of instructions isn't clearly to be defined. You might wish, for example, to compare whether instructions\n- * have the same meaning. E.g., whether two INVOKEVIRTUALs describe the same call.\n+ * Equality of instructions isn't clearly to be defined. You might\n+ * wish, for example, to compare whether instructions have the same\n+ * meaning. E.g., whether two INVOKEVIRTUALs describe the same\n+ * call.\n@@ -28,3 +30,4 @@\n- * The DEFAULT comparator however, considers two instructions to be equal if they have same opcode and point to the same\n- * indexes (if any) in the constant pool or the same local variable index. Branch instructions must have the same\n- * target.\n+ * The DEFAULT comparator however, considers two instructions\n+ * to be equal if they have same opcode and point to the same indexes\n+ * (if any) in the constant pool or the same local variable index. Branch\n+ * instructions must have the same target.\n@@ -40,1 +43,1 @@\n-                \/\/ BIs are never equal to make targeters work correctly (BCEL-195)\n+             \/\/ BIs are never equal to make targeters work correctly (BCEL-195)\n@@ -44,8 +47,7 @@\n-            }\n-            if (i1 instanceof ConstantPushInstruction) {\n-                return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());\n-            }\n-            if (i1 instanceof IndexedInstruction) {\n-                return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();\n-            }\n-            if (i1 instanceof NEWARRAY) {\n+            } else if (i1 instanceof ConstantPushInstruction) {\n+                return ((ConstantPushInstruction) i1).getValue().equals(\n+                        ((ConstantPushInstruction) i2).getValue());\n+            } else if (i1 instanceof IndexedInstruction) {\n+                return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2)\n+                        .getIndex();\n+            } else if (i1 instanceof NEWARRAY) {\n@@ -53,0 +55,2 @@\n+            } else {\n+                return true;\n@@ -54,1 +58,0 @@\n-            return true;\n@@ -59,1 +62,2 @@\n-    boolean equals(Instruction i1, Instruction i2);\n+\n+    boolean equals( Instruction i1, Instruction i2 );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionComparator.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,11 +27,13 @@\n- * Contains shareable instruction objects.\n- * <p>\n- * In order to save memory you can use some instructions multiply, since they have an immutable state and are directly\n- * derived from Instruction. I.e. they have no instance fields that could be changed. Since some of these instructions\n- * like ICONST_0 occur very frequently this can save a lot of time and space. This feature is an adaptation of the\n- * FlyWeight design pattern, we just use an array instead of a factory.\n- * <\/p>\n- * <p>\n- * The Instructions can also accessed directly under their names, so it's possible to write\n- * il.append(Instruction.ICONST_0);\n- * <\/p>\n+ * This interface contains shareable instruction objects.\n+ *\n+ * In order to save memory you can use some instructions multiply,\n+ * since they have an immutable state and are directly derived from\n+ * Instruction.  I.e. they have no instance fields that could be\n+ * changed. Since some of these instructions like ICONST_0 occur\n+ * very frequently this can save a lot of time and space. This\n+ * feature is an adaptation of the FlyWeight design pattern, we\n+ * just use an array instead of a factory.\n+ *\n+ * The Instructions can also accessed directly under their names, so\n+ * it's possible to write il.append(Instruction.ICONST_0);\n+ *\n@@ -42,3 +44,5 @@\n-     * Predefined instruction objects.\n-     *\n-     * NOTE these are not currently immutable, because Instruction has mutable protected fields opcode and length.\n+     * Predefined instruction objects\n+     *\/\n+    \/*\n+     * NOTE these are not currently immutable, because Instruction\n+     * has mutable protected fields opcode and length.\n@@ -154,3 +158,2 @@\n-    \/**\n-     * You can use these constants in multiple places safely, if you can guarantee that you will never alter their internal\n-     * values, e.g. call setIndex().\n+    \/** You can use these constants in multiple places safely, if you can guarantee\n+     * that you will never alter their internal values, e.g. call setIndex().\n@@ -172,2 +175,2 @@\n-    \/**\n-     * Get object via its opcode, for immutable instructions like branch instructions entries are set to null.\n+    \/** Get object via its opcode, for immutable instructions like\n+     * branch instructions entries are set to null.\n@@ -175,1 +178,1 @@\n-    static final Instruction[] INSTRUCTIONS = new Instruction[256];\n+    private static final Instruction[] INSTRUCTIONS = new Instruction[256];\n@@ -287,0 +290,2 @@\n+    private InstructionConst() { } \/\/ non-instantiable\n+\n@@ -289,1 +294,0 @@\n-     *\n@@ -296,3 +300,0 @@\n-\n-    private InstructionConst() {\n-    } \/\/ non-instantiable\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionConst.java","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,4 @@\n- * Instances of this class may be used, e.g., to generate typed versions of instructions. Its main purpose is to be used\n- * as the byte code generating backend of a compiler. You can subclass it to add your own create methods.\n+ * Instances of this class may be used, e.g., to generate typed\n+ * versions of instructions. Its main purpose is to be used as the\n+ * byte code generating backend of a compiler. You can subclass it to\n+ * add your own create methods.\n@@ -28,2 +30,2 @@\n- * Note: The static createXXX methods return singleton instances from the {@link InstructionConst} class.\n- * <\/p>\n+ * Note: The static createXXX methods return singleton instances\n+ * from the {@link InstructionConst} class.\n@@ -33,1 +35,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -37,1 +39,4 @@\n-    private static class MethodObject {\n+    \/\/ N.N. These must agree with the order of Constants.T_CHAR through T_LONG\n+    private static final String[] short_names = {\n+            \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"L\"\n+    };\n@@ -39,4 +44,2 @@\n-        final Type[] argTypes;\n-        final Type resultType;\n-        final String className;\n-        final String name;\n+    private ClassGen cg;\n+    private ConstantPoolGen cp;\n@@ -44,6 +47,3 @@\n-        MethodObject(final String c, final String n, final Type r, final Type[] a) {\n-            this.className = c;\n-            this.name = n;\n-            this.resultType = r;\n-            this.argTypes = a;\n-        }\n+    public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {\n+        this.cg = cg;\n+        this.cp = cp;\n@@ -52,1 +52,0 @@\n-    private static final String APPEND = \"append\";\n@@ -54,1 +53,12 @@\n-    private static final String FQCN_STRING_BUFFER = \"java.lang.StringBuffer\";\n+    \/** Initialize with ClassGen object\n+     *\/\n+    public InstructionFactory(final ClassGen cg) {\n+        this(cg, cg.getConstantPool());\n+    }\n+\n+\n+    \/** Initialize just with ConstantPoolGen object\n+     *\/\n+    public InstructionFactory(final ConstantPoolGen cp) {\n+        this(null, cp);\n+    }\n@@ -56,14 +66,15 @@\n-    \/\/ N.N. These must agree with the order of Constants.T_CHAR through T_LONG\n-    private static final String[] shortNames = {\"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"L\"};\n-\n-    private static final MethodObject[] appendMethodObjects = {\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.STRING }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.OBJECT }), null, null, \/\/ indices 2, 3\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.BOOLEAN }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.CHAR }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.FLOAT }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.DOUBLE }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }), \/\/ No append(byte)\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }), \/\/ No append(short)\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.LONG })};\n+\n+    \/** Create an invoke instruction. (Except for invokedynamic.)\n+     *\n+     * @param class_name name of the called class\n+     * @param name name of the called method\n+     * @param ret_type return type of method\n+     * @param arg_types argument types of method\n+     * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL,\n+     * or INVOKESPECIAL\n+     * @see Const\n+     *\/\n+    public InvokeInstruction createInvoke( final String class_name, final String name,\n+            final Type ret_type, final Type[] arg_types, final short kind ) {\n+        return createInvoke(class_name, name, ret_type, arg_types, kind, kind == Const.INVOKEINTERFACE);\n+    }\n@@ -72,1 +83,10 @@\n-     * @param type type of elements of array, i.e., array.getElementType()\n+     * Creates an invoke instruction. (Except for invokedynamic.)\n+     *\n+     * @param class_name name of the called class\n+     * @param name name of the called method\n+     * @param ret_type return type of method\n+     * @param arg_types argument types of method\n+     * @param kind how to invoke: INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n+     * @param use_interface force use of InterfaceMethodref\n+     * @return A new InvokeInstruction.\n+     * @since 6.5.0\n@@ -74,20 +94,28 @@\n-    public static ArrayInstruction createArrayLoad(final Type type) {\n-        switch (type.getType()) {\n-        case Const.T_BOOLEAN:\n-        case Const.T_BYTE:\n-            return InstructionConst.BALOAD;\n-        case Const.T_CHAR:\n-            return InstructionConst.CALOAD;\n-        case Const.T_SHORT:\n-            return InstructionConst.SALOAD;\n-        case Const.T_INT:\n-            return InstructionConst.IALOAD;\n-        case Const.T_FLOAT:\n-            return InstructionConst.FALOAD;\n-        case Const.T_DOUBLE:\n-            return InstructionConst.DALOAD;\n-        case Const.T_LONG:\n-            return InstructionConst.LALOAD;\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return InstructionConst.AALOAD;\n+    public InvokeInstruction createInvoke( final String class_name, final String name, final Type ret_type,\n+        final Type[] arg_types, final short kind, final boolean use_interface) {\n+        if (kind != Const.INVOKESPECIAL && kind != Const.INVOKEVIRTUAL && kind != Const.INVOKESTATIC\n+            && kind != Const.INVOKEINTERFACE && kind != Const.INVOKEDYNAMIC) {\n+            throw new IllegalArgumentException(\"Unknown invoke kind: \" + kind);\n+        }\n+        int index;\n+        int nargs = 0;\n+        final String signature = Type.getMethodSignature(ret_type, arg_types);\n+        for (final Type arg_type : arg_types) {\n+            nargs += arg_type.getSize();\n+        }\n+        if (use_interface) {\n+            index = cp.addInterfaceMethodref(class_name, name, signature);\n+        } else {\n+            index = cp.addMethodref(class_name, name, signature);\n+        }\n+        switch (kind) {\n+        case Const.INVOKESPECIAL:\n+            return new INVOKESPECIAL(index);\n+        case Const.INVOKEVIRTUAL:\n+            return new INVOKEVIRTUAL(index);\n+        case Const.INVOKESTATIC:\n+            return new INVOKESTATIC(index);\n+        case Const.INVOKEINTERFACE:\n+            return new INVOKEINTERFACE(index, nargs + 1);\n+        case Const.INVOKEDYNAMIC:\n+            return new INVOKEDYNAMIC(index);\n@@ -95,1 +123,2 @@\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n+            \/\/ Can't happen\n+            throw new IllegalStateException(\"Unknown invoke kind: \" + kind);\n@@ -99,2 +128,7 @@\n-    \/**\n-     * @param type type of elements of array, i.e., array.getElementType()\n+    \/** Create an invokedynamic instruction.\n+     *\n+     * @param bootstrap_index index into the bootstrap_methods array\n+     * @param name name of the called method\n+     * @param ret_type return type of method\n+     * @param arg_types argument types of method\n+     * @see Constants\n@@ -102,22 +136,11 @@\n-    public static ArrayInstruction createArrayStore(final Type type) {\n-        switch (type.getType()) {\n-        case Const.T_BOOLEAN:\n-        case Const.T_BYTE:\n-            return InstructionConst.BASTORE;\n-        case Const.T_CHAR:\n-            return InstructionConst.CASTORE;\n-        case Const.T_SHORT:\n-            return InstructionConst.SASTORE;\n-        case Const.T_INT:\n-            return InstructionConst.IASTORE;\n-        case Const.T_FLOAT:\n-            return InstructionConst.FASTORE;\n-        case Const.T_DOUBLE:\n-            return InstructionConst.DASTORE;\n-        case Const.T_LONG:\n-            return InstructionConst.LASTORE;\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return InstructionConst.AASTORE;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n+\/*\n+ * createInvokeDynamic only needed if instrumention code wants to generate\n+ * a new invokedynamic instruction.  I don't think we need.  (markro)\n+ *\n+    public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,\n+            Type[] arg_types) {\n+        int index;\n+        int nargs = 0;\n+        String signature = Type.getMethodSignature(ret_type, arg_types);\n+        for (int i = 0; i < arg_types.length; i++) {\n+            nargs += arg_types[i].getSize();\n@@ -125,0 +148,4 @@\n+        \/\/ UNDONE - needs to be added to ConstantPoolGen\n+        \/\/index = cp.addInvokeDynamic(bootstrap_index, name, signature);\n+        index = 0;\n+        return new INVOKEDYNAMIC(index);\n@@ -126,0 +153,1 @@\n+ *\/\n@@ -127,14 +155,30 @@\n-    private static ArithmeticInstruction createBinaryDoubleOp(final char op) {\n-        switch (op) {\n-        case '-':\n-            return InstructionConst.DSUB;\n-        case '+':\n-            return InstructionConst.DADD;\n-        case '*':\n-            return InstructionConst.DMUL;\n-        case '\/':\n-            return InstructionConst.DDIV;\n-        case '%':\n-            return InstructionConst.DREM;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid operand \" + op);\n+    \/** Create a call to the most popular System.out.println() method.\n+     *\n+     * @param s the string to print\n+     *\/\n+    public InstructionList createPrintln( final String s ) {\n+        final InstructionList il = new InstructionList();\n+        final int out = cp.addFieldref(\"java.lang.System\", \"out\", \"Ljava\/io\/PrintStream;\");\n+        final int println = cp.addMethodref(\"java.io.PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\");\n+        il.append(new GETSTATIC(out));\n+        il.append(new PUSH(cp, s));\n+        il.append(new INVOKEVIRTUAL(println));\n+        return il;\n+    }\n+\n+\n+    \/** Uses PUSH to push a constant value onto the stack.\n+     * @param value must be of type Number, Boolean, Character or String\n+     *\/\n+    public Instruction createConstant( final Object value ) {\n+        PUSH push;\n+        if (value instanceof Number) {\n+            push = new PUSH(cp, (Number) value);\n+        } else if (value instanceof String) {\n+            push = new PUSH(cp, (String) value);\n+        } else if (value instanceof Boolean) {\n+            push = new PUSH(cp, (Boolean) value);\n+        } else if (value instanceof Character) {\n+            push = new PUSH(cp, (Character) value);\n+        } else {\n+            throw new ClassGenException(\"Illegal type: \" + value.getClass());\n@@ -142,0 +186,1 @@\n+        return push.getInstruction();\n@@ -144,14 +189,13 @@\n-    private static ArithmeticInstruction createBinaryFloatOp(final char op) {\n-        switch (op) {\n-        case '-':\n-            return InstructionConst.FSUB;\n-        case '+':\n-            return InstructionConst.FADD;\n-        case '*':\n-            return InstructionConst.FMUL;\n-        case '\/':\n-            return InstructionConst.FDIV;\n-        case '%':\n-            return InstructionConst.FREM;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid operand \" + op);\n+    private static class MethodObject {\n+\n+        final Type[] arg_types;\n+        final Type result_type;\n+        final String class_name;\n+        final String name;\n+\n+\n+        MethodObject(final String c, final String n, final Type r, final Type[] a) {\n+            class_name = c;\n+            name = n;\n+            result_type = r;\n+            arg_types = a;\n@@ -161,24 +205,69 @@\n-    private static ArithmeticInstruction createBinaryIntOp(final char first, final String op) {\n-        switch (first) {\n-        case '-':\n-            return InstructionConst.ISUB;\n-        case '+':\n-            return InstructionConst.IADD;\n-        case '%':\n-            return InstructionConst.IREM;\n-        case '*':\n-            return InstructionConst.IMUL;\n-        case '\/':\n-            return InstructionConst.IDIV;\n-        case '&':\n-            return InstructionConst.IAND;\n-        case '|':\n-            return InstructionConst.IOR;\n-        case '^':\n-            return InstructionConst.IXOR;\n-        case '<':\n-            return InstructionConst.ISHL;\n-        case '>':\n-            return op.equals(\">>>\") ? InstructionConst.IUSHR : InstructionConst.ISHR;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid operand \" + op);\n+\n+    private InvokeInstruction createInvoke( final MethodObject m, final short kind ) {\n+        return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);\n+    }\n+\n+    private static final MethodObject[] append_mos = {\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.STRING\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.OBJECT\n+            }),\n+            null,\n+            null, \/\/ indices 2, 3\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.BOOLEAN\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.CHAR\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.FLOAT\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.DOUBLE\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.INT\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, \/\/ No append(byte)\n+                    new Type[] {\n+                        Type.INT\n+                    }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, \/\/ No append(short)\n+                    new Type[] {\n+                        Type.INT\n+                    }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.LONG\n+            })\n+    };\n+\n+\n+    private static boolean isString( final Type type ) {\n+        return (type instanceof ObjectType) &&\n+              ((ObjectType) type).getClassName().equals(\"java.lang.String\");\n+    }\n+\n+\n+    public Instruction createAppend( final Type type ) {\n+        final byte t = type.getType();\n+        if (isString(type)) {\n+            return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);\n+        }\n+        switch (t) {\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_FLOAT:\n+            case Const.T_DOUBLE:\n+            case Const.T_BYTE:\n+            case Const.T_SHORT:\n+            case Const.T_INT:\n+            case Const.T_LONG:\n+                return createInvoke(append_mos[t], Const.INVOKEVIRTUAL);\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return createInvoke(append_mos[1], Const.INVOKEVIRTUAL);\n+            default:\n+                throw new IllegalArgumentException(\"No append for this type? \" + type);\n@@ -188,2 +277,2 @@\n-    \/**\n-     * Create an invokedynamic instruction.\n+\n+    \/** Create a field instruction.\n@@ -191,4 +280,4 @@\n-     * @param bootstrap_index index into the bootstrap_methods array\n-     * @param name name of the called method\n-     * @param ret_type return type of method\n-     * @param argTypes argument types of method\n+     * @param class_name name of the accessed class\n+     * @param name name of the referenced field\n+     * @param type  type of field\n+     * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC\n@@ -197,0 +286,18 @@\n+    public FieldInstruction createFieldAccess( final String class_name,\n+            final String name, final Type type, final short kind ) {\n+        int index;\n+        final String signature = type.getSignature();\n+        index = cp.addFieldref(class_name, name, signature);\n+        switch (kind) {\n+            case Const.GETFIELD:\n+                return new GETFIELD(index);\n+            case Const.PUTFIELD:\n+                return new PUTFIELD(index);\n+            case Const.GETSTATIC:\n+                return new GETSTATIC(index);\n+            case Const.PUTSTATIC:\n+                return new PUTSTATIC(index);\n+            default:\n+                throw new IllegalArgumentException(\"Unknown getfield kind:\" + kind);\n+        }\n+    }\n@@ -198,8 +305,2 @@\n-    \/*\n-     * createInvokeDynamic only needed if instrumentation code wants to generate a new invokedynamic instruction. I don't\n-     * think we need.\n-     *\n-     * public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type, Type[] argTypes) {\n-     * int index; int nargs = 0; String signature = Type.getMethodSignature(ret_type, argTypes); for (int i = 0; i <\n-     * argTypes.length; i++) { nargs += argTypes[i].getSize(); } \/\/ UNDONE - needs to be added to ConstantPoolGen \/\/index\n-     * = cp.addInvokeDynamic(bootstrap_index, name, signature); index = 0; return new INVOKEDYNAMIC(index); }\n+\n+    \/** Create reference to `this'\n@@ -207,0 +308,31 @@\n+    public static Instruction createThis() {\n+        return new ALOAD(0);\n+    }\n+\n+\n+    \/** Create typed return\n+     *\/\n+    public static ReturnInstruction createReturn( final Type type ) {\n+        switch (type.getType()) {\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return InstructionConst.ARETURN;\n+            case Const.T_INT:\n+            case Const.T_SHORT:\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+                return InstructionConst.IRETURN;\n+            case Const.T_FLOAT:\n+                return InstructionConst.FRETURN;\n+            case Const.T_DOUBLE:\n+                return InstructionConst.DRETURN;\n+            case Const.T_LONG:\n+                return InstructionConst.LRETURN;\n+            case Const.T_VOID:\n+                return InstructionConst.RETURN;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type: \" + type);\n+        }\n+    }\n+\n@@ -208,1 +340,1 @@\n-    private static ArithmeticInstruction createBinaryLongOp(final char first, final String op) {\n+    private static ArithmeticInstruction createBinaryIntOp( final char first, final String op ) {\n@@ -210,22 +342,86 @@\n-        case '-':\n-            return InstructionConst.LSUB;\n-        case '+':\n-            return InstructionConst.LADD;\n-        case '%':\n-            return InstructionConst.LREM;\n-        case '*':\n-            return InstructionConst.LMUL;\n-        case '\/':\n-            return InstructionConst.LDIV;\n-        case '&':\n-            return InstructionConst.LAND;\n-        case '|':\n-            return InstructionConst.LOR;\n-        case '^':\n-            return InstructionConst.LXOR;\n-        case '<':\n-            return InstructionConst.LSHL;\n-        case '>':\n-            return op.equals(\">>>\") ? InstructionConst.LUSHR : InstructionConst.LSHR;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid operand \" + op);\n+            case '-':\n+                return InstructionConst.ISUB;\n+            case '+':\n+                return InstructionConst.IADD;\n+            case '%':\n+                return InstructionConst.IREM;\n+            case '*':\n+                return InstructionConst.IMUL;\n+            case '\/':\n+                return InstructionConst.IDIV;\n+            case '&':\n+                return InstructionConst.IAND;\n+            case '|':\n+                return InstructionConst.IOR;\n+            case '^':\n+                return InstructionConst.IXOR;\n+            case '<':\n+                return InstructionConst.ISHL;\n+            case '>':\n+                return op.equals(\">>>\") ? InstructionConst.IUSHR : InstructionConst.ISHR;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operand \" + op);\n+        }\n+    }\n+\n+\n+    private static ArithmeticInstruction createBinaryLongOp( final char first, final String op ) {\n+        switch (first) {\n+            case '-':\n+                return InstructionConst.LSUB;\n+            case '+':\n+                return InstructionConst.LADD;\n+            case '%':\n+                return InstructionConst.LREM;\n+            case '*':\n+                return InstructionConst.LMUL;\n+            case '\/':\n+                return InstructionConst.LDIV;\n+            case '&':\n+                return InstructionConst.LAND;\n+            case '|':\n+                return InstructionConst.LOR;\n+            case '^':\n+                return InstructionConst.LXOR;\n+            case '<':\n+                return InstructionConst.LSHL;\n+            case '>':\n+                return op.equals(\">>>\") ? InstructionConst.LUSHR : InstructionConst.LSHR;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operand \" + op);\n+        }\n+    }\n+\n+\n+    private static ArithmeticInstruction createBinaryFloatOp( final char op ) {\n+        switch (op) {\n+            case '-':\n+                return InstructionConst.FSUB;\n+            case '+':\n+                return InstructionConst.FADD;\n+            case '*':\n+                return InstructionConst.FMUL;\n+            case '\/':\n+                return InstructionConst.FDIV;\n+            case '%':\n+                return InstructionConst.FREM;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operand \" + op);\n+        }\n+    }\n+\n+\n+    private static ArithmeticInstruction createBinaryDoubleOp( final char op ) {\n+        switch (op) {\n+            case '-':\n+                return InstructionConst.DSUB;\n+            case '+':\n+                return InstructionConst.DADD;\n+            case '*':\n+                return InstructionConst.DMUL;\n+            case '\/':\n+                return InstructionConst.DDIV;\n+            case '%':\n+                return InstructionConst.DREM;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operand \" + op);\n@@ -235,0 +431,1 @@\n+\n@@ -240,1 +437,1 @@\n-    public static ArithmeticInstruction createBinaryOperation(final String op, final Type type) {\n+    public static ArithmeticInstruction createBinaryOperation( final String op, final Type type ) {\n@@ -243,13 +440,13 @@\n-        case Const.T_BYTE:\n-        case Const.T_SHORT:\n-        case Const.T_INT:\n-        case Const.T_CHAR:\n-            return createBinaryIntOp(first, op);\n-        case Const.T_LONG:\n-            return createBinaryLongOp(first, op);\n-        case Const.T_FLOAT:\n-            return createBinaryFloatOp(first);\n-        case Const.T_DOUBLE:\n-            return createBinaryDoubleOp(first);\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n+            case Const.T_BYTE:\n+            case Const.T_SHORT:\n+            case Const.T_INT:\n+            case Const.T_CHAR:\n+                return createBinaryIntOp(first, op);\n+            case Const.T_LONG:\n+                return createBinaryLongOp(first, op);\n+            case Const.T_FLOAT:\n+                return createBinaryFloatOp(first);\n+            case Const.T_DOUBLE:\n+                return createBinaryDoubleOp(first);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -259,50 +456,0 @@\n-    \/**\n-     * Create branch instruction by given opcode, except LOOKUPSWITCH and TABLESWITCH. For those you should use the SWITCH\n-     * compound instruction.\n-     *\/\n-    public static BranchInstruction createBranchInstruction(final short opcode, final InstructionHandle target) {\n-        switch (opcode) {\n-        case Const.IFEQ:\n-            return new IFEQ(target);\n-        case Const.IFNE:\n-            return new IFNE(target);\n-        case Const.IFLT:\n-            return new IFLT(target);\n-        case Const.IFGE:\n-            return new IFGE(target);\n-        case Const.IFGT:\n-            return new IFGT(target);\n-        case Const.IFLE:\n-            return new IFLE(target);\n-        case Const.IF_ICMPEQ:\n-            return new IF_ICMPEQ(target);\n-        case Const.IF_ICMPNE:\n-            return new IF_ICMPNE(target);\n-        case Const.IF_ICMPLT:\n-            return new IF_ICMPLT(target);\n-        case Const.IF_ICMPGE:\n-            return new IF_ICMPGE(target);\n-        case Const.IF_ICMPGT:\n-            return new IF_ICMPGT(target);\n-        case Const.IF_ICMPLE:\n-            return new IF_ICMPLE(target);\n-        case Const.IF_ACMPEQ:\n-            return new IF_ACMPEQ(target);\n-        case Const.IF_ACMPNE:\n-            return new IF_ACMPNE(target);\n-        case Const.GOTO:\n-            return new GOTO(target);\n-        case Const.JSR:\n-            return new JSR(target);\n-        case Const.IFNULL:\n-            return new IFNULL(target);\n-        case Const.IFNONNULL:\n-            return new IFNONNULL(target);\n-        case Const.GOTO_W:\n-            return new GOTO_W(target);\n-        case Const.JSR_W:\n-            return new JSR_W(target);\n-        default:\n-            throw new IllegalArgumentException(\"Invalid opcode: \" + opcode);\n-        }\n-    }\n@@ -313,2 +460,2 @@\n-    public static StackInstruction createDup(final int size) {\n-        return size == 2 ? InstructionConst.DUP2 : InstructionConst.DUP;\n+    public static StackInstruction createPop( final int size ) {\n+        return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;\n@@ -317,6 +464,0 @@\n-    \/**\n-     * @param size size of operand, either 1 (int, e.g.) or 2 (double)\n-     *\/\n-    public static StackInstruction createDup_1(final int size) {\n-        return size == 2 ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;\n-    }\n@@ -327,2 +468,2 @@\n-    public static StackInstruction createDup_2(final int size) {\n-        return size == 2 ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;\n+    public static StackInstruction createDup( final int size ) {\n+        return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;\n@@ -331,24 +472,0 @@\n-    \/**\n-     * @param index index of local variable\n-     *\/\n-    public static LocalVariableInstruction createLoad(final Type type, final int index) {\n-        switch (type.getType()) {\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-        case Const.T_SHORT:\n-        case Const.T_INT:\n-            return new ILOAD(index);\n-        case Const.T_FLOAT:\n-            return new FLOAD(index);\n-        case Const.T_DOUBLE:\n-            return new DLOAD(index);\n-        case Const.T_LONG:\n-            return new LLOAD(index);\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return new ALOAD(index);\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n-        }\n-    }\n@@ -357,1 +474,1 @@\n-     * Create \"null\" value for reference types, 0 for basic types like int\n+     * @param size size of operand, either 1 (int, e.g.) or 2 (double)\n@@ -359,22 +476,2 @@\n-    public static Instruction createNull(final Type type) {\n-        switch (type.getType()) {\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return InstructionConst.ACONST_NULL;\n-        case Const.T_INT:\n-        case Const.T_SHORT:\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-            return InstructionConst.ICONST_0;\n-        case Const.T_FLOAT:\n-            return InstructionConst.FCONST_0;\n-        case Const.T_DOUBLE:\n-            return InstructionConst.DCONST_0;\n-        case Const.T_LONG:\n-            return InstructionConst.LCONST_0;\n-        case Const.T_VOID:\n-            return InstructionConst.NOP;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type: \" + type);\n-        }\n+    public static StackInstruction createDup_2( final int size ) {\n+        return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;\n@@ -383,0 +480,1 @@\n+\n@@ -386,2 +484,2 @@\n-    public static StackInstruction createPop(final int size) {\n-        return size == 2 ? InstructionConst.POP2 : InstructionConst.POP;\n+    public static StackInstruction createDup_1( final int size ) {\n+        return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;\n@@ -390,0 +488,1 @@\n+\n@@ -391,1 +490,1 @@\n-     * Create typed return\n+     * @param index index of local variable\n@@ -393,1 +492,1 @@\n-    public static ReturnInstruction createReturn(final Type type) {\n+    public static LocalVariableInstruction createStore( final Type type, final int index ) {\n@@ -395,19 +494,17 @@\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return InstructionConst.ARETURN;\n-        case Const.T_INT:\n-        case Const.T_SHORT:\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-            return InstructionConst.IRETURN;\n-        case Const.T_FLOAT:\n-            return InstructionConst.FRETURN;\n-        case Const.T_DOUBLE:\n-            return InstructionConst.DRETURN;\n-        case Const.T_LONG:\n-            return InstructionConst.LRETURN;\n-        case Const.T_VOID:\n-            return InstructionConst.RETURN;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type: \" + type);\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+            case Const.T_SHORT:\n+            case Const.T_INT:\n+                return new ISTORE(index);\n+            case Const.T_FLOAT:\n+                return new FSTORE(index);\n+            case Const.T_DOUBLE:\n+                return new DSTORE(index);\n+            case Const.T_LONG:\n+                return new LSTORE(index);\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return new ASTORE(index);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -417,0 +514,1 @@\n+\n@@ -420,1 +518,1 @@\n-    public static LocalVariableInstruction createStore(final Type type, final int index) {\n+    public static LocalVariableInstruction createLoad( final Type type, final int index ) {\n@@ -422,17 +520,17 @@\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-        case Const.T_SHORT:\n-        case Const.T_INT:\n-            return new ISTORE(index);\n-        case Const.T_FLOAT:\n-            return new FSTORE(index);\n-        case Const.T_DOUBLE:\n-            return new DSTORE(index);\n-        case Const.T_LONG:\n-            return new LSTORE(index);\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return new ASTORE(index);\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+            case Const.T_SHORT:\n+            case Const.T_INT:\n+                return new ILOAD(index);\n+            case Const.T_FLOAT:\n+                return new FLOAD(index);\n+            case Const.T_DOUBLE:\n+                return new DLOAD(index);\n+            case Const.T_LONG:\n+                return new LLOAD(index);\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return new ALOAD(index);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -442,22 +540,0 @@\n-    \/**\n-     * Create reference to 'this'\n-     *\/\n-    public static Instruction createThis() {\n-        return new ALOAD(0);\n-    }\n-\n-    private static boolean isString(final Type type) {\n-        return type instanceof ObjectType && ((ObjectType) type).getClassName().equals(\"java.lang.String\");\n-    }\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected ClassGen cg;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected ConstantPoolGen cp;\n@@ -466,1 +542,1 @@\n-     * Initialize with ClassGen object\n+     * @param type type of elements of array, i.e., array.getElementType()\n@@ -468,2 +544,23 @@\n-    public InstructionFactory(final ClassGen cg) {\n-        this(cg, cg.getConstantPool());\n+    public static ArrayInstruction createArrayLoad( final Type type ) {\n+        switch (type.getType()) {\n+            case Const.T_BOOLEAN:\n+            case Const.T_BYTE:\n+                return InstructionConst.BALOAD;\n+            case Const.T_CHAR:\n+                return InstructionConst.CALOAD;\n+            case Const.T_SHORT:\n+                return InstructionConst.SALOAD;\n+            case Const.T_INT:\n+                return InstructionConst.IALOAD;\n+            case Const.T_FLOAT:\n+                return InstructionConst.FALOAD;\n+            case Const.T_DOUBLE:\n+                return InstructionConst.DALOAD;\n+            case Const.T_LONG:\n+                return InstructionConst.LALOAD;\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return InstructionConst.AALOAD;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n+        }\n@@ -472,4 +569,0 @@\n-    public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {\n-        this.cg = cg;\n-        this.cp = cp;\n-    }\n@@ -478,1 +571,1 @@\n-     * Initialize just with ConstantPoolGen object\n+     * @param type type of elements of array, i.e., array.getElementType()\n@@ -480,24 +573,22 @@\n-    public InstructionFactory(final ConstantPoolGen cp) {\n-        this(null, cp);\n-    }\n-\n-    public Instruction createAppend(final Type type) {\n-        final byte t = type.getType();\n-        if (isString(type)) {\n-            return createInvoke(appendMethodObjects[0], Const.INVOKEVIRTUAL);\n-        }\n-        switch (t) {\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_FLOAT:\n-        case Const.T_DOUBLE:\n-        case Const.T_BYTE:\n-        case Const.T_SHORT:\n-        case Const.T_INT:\n-        case Const.T_LONG:\n-            return createInvoke(appendMethodObjects[t], Const.INVOKEVIRTUAL);\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return createInvoke(appendMethodObjects[1], Const.INVOKEVIRTUAL);\n-        default:\n-            throw new IllegalArgumentException(\"No append for this type? \" + type);\n+    public static ArrayInstruction createArrayStore( final Type type ) {\n+        switch (type.getType()) {\n+            case Const.T_BOOLEAN:\n+            case Const.T_BYTE:\n+                return InstructionConst.BASTORE;\n+            case Const.T_CHAR:\n+                return InstructionConst.CASTORE;\n+            case Const.T_SHORT:\n+                return InstructionConst.SASTORE;\n+            case Const.T_INT:\n+                return InstructionConst.IASTORE;\n+            case Const.T_FLOAT:\n+                return InstructionConst.FASTORE;\n+            case Const.T_DOUBLE:\n+                return InstructionConst.DASTORE;\n+            case Const.T_LONG:\n+                return InstructionConst.LASTORE;\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return InstructionConst.AASTORE;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -508,2 +599,3 @@\n-     * Create conversion operation for two stack operands, this may be an I2C, instruction, e.g., if the operands are basic\n-     * types and CHECKCAST if they are reference types.\n+     * Create conversion operation for two stack operands, this may be an I2C,\n+     * instruction, e.g., if the operands are basic types and CHECKCAST if they\n+     * are reference types.\n@@ -511,5 +603,6 @@\n-    public Instruction createCast(final Type srcType, final Type destType) {\n-        if (srcType instanceof BasicType && destType instanceof BasicType) {\n-            final byte dest = destType.getType();\n-            byte src = srcType.getType();\n-            if (dest == Const.T_LONG && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {\n+    public Instruction createCast( final Type src_type, final Type dest_type ) {\n+        if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {\n+            final byte dest = dest_type.getType();\n+            byte src = src_type.getType();\n+            if (dest == Const.T_LONG\n+                    && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {\n@@ -518,1 +611,2 @@\n-            final String name = \"com.sun.org.apache.bcel.internal.generic.\" + shortNames[src - Const.T_CHAR] + \"2\" + shortNames[dest - Const.T_CHAR];\n+            final String name = \"com.sun.org.apache.bcel.internal.generic.\" + short_names[src - Const.T_CHAR] + \"2\"\n+                    + short_names[dest - Const.T_CHAR];\n@@ -521,1 +615,1 @@\n-                i = (Instruction) Class.forName(name).getDeclaredConstructor().newInstance();;\n+                i = (Instruction) java.lang.Class.forName(name).getDeclaredConstructor().newInstance();\n@@ -526,0 +620,7 @@\n+        } else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {\n+            if (dest_type instanceof ArrayType) {\n+                return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));\n+            }\n+            return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot cast \" + src_type + \" to \" + dest_type);\n@@ -527,7 +628,0 @@\n-        if (!(srcType instanceof ReferenceType) || !(destType instanceof ReferenceType)) {\n-            throw new IllegalArgumentException(\"Cannot cast \" + srcType + \" to \" + destType);\n-        }\n-        if (destType instanceof ArrayType) {\n-            return new CHECKCAST(cp.addArrayClass((ArrayType) destType));\n-        }\n-        return new CHECKCAST(cp.addClass(((ObjectType) destType).getClassName()));\n@@ -536,6 +630,0 @@\n-    public CHECKCAST createCheckCast(final ReferenceType t) {\n-        if (t instanceof ArrayType) {\n-            return new CHECKCAST(cp.addArrayClass((ArrayType) t));\n-        }\n-        return new CHECKCAST(cp.addClass((ObjectType) t));\n-    }\n@@ -543,19 +631,2 @@\n-    \/**\n-     * Uses PUSH to push a constant value onto the stack.\n-     *\n-     * @param value must be of type Number, Boolean, Character or String\n-     *\/\n-    public Instruction createConstant(final Object value) {\n-        PUSH push;\n-        if (value instanceof Number) {\n-            push = new PUSH(cp, (Number) value);\n-        } else if (value instanceof String) {\n-            push = new PUSH(cp, (String) value);\n-        } else if (value instanceof Boolean) {\n-            push = new PUSH(cp, (Boolean) value);\n-        } else if (value instanceof Character) {\n-            push = new PUSH(cp, (Character) value);\n-        } else {\n-            throw new ClassGenException(\"Illegal type: \" + value.getClass());\n-        }\n-        return push.getInstruction();\n+    public GETFIELD createGetField( final String class_name, final String name, final Type t ) {\n+        return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));\n@@ -564,25 +635,3 @@\n-    \/**\n-     * Create a field instruction.\n-     *\n-     * @param className name of the accessed class\n-     * @param name name of the referenced field\n-     * @param type type of field\n-     * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC\n-     * @see Const\n-     *\/\n-    public FieldInstruction createFieldAccess(final String className, final String name, final Type type, final short kind) {\n-        int index;\n-        final String signature = type.getSignature();\n-        index = cp.addFieldref(className, name, signature);\n-        switch (kind) {\n-        case Const.GETFIELD:\n-            return new GETFIELD(index);\n-        case Const.PUTFIELD:\n-            return new PUTFIELD(index);\n-        case Const.GETSTATIC:\n-            return new GETSTATIC(index);\n-        case Const.PUTSTATIC:\n-            return new PUTSTATIC(index);\n-        default:\n-            throw new IllegalArgumentException(\"Unknown getfield kind:\" + kind);\n-        }\n+\n+    public GETSTATIC createGetStatic( final String class_name, final String name, final Type t ) {\n+        return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));\n@@ -591,2 +640,3 @@\n-    public GETFIELD createGetField(final String className, final String name, final Type t) {\n-        return new GETFIELD(cp.addFieldref(className, name, t.getSignature()));\n+\n+    public PUTFIELD createPutField( final String class_name, final String name, final Type t ) {\n+        return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));\n@@ -595,2 +645,3 @@\n-    public GETSTATIC createGetStatic(final String className, final String name, final Type t) {\n-        return new GETSTATIC(cp.addFieldref(className, name, t.getSignature()));\n+\n+    public PUTSTATIC createPutStatic( final String class_name, final String name, final Type t ) {\n+        return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));\n@@ -599,1 +650,2 @@\n-    public INSTANCEOF createInstanceOf(final ReferenceType t) {\n+\n+    public CHECKCAST createCheckCast( final ReferenceType t ) {\n@@ -601,1 +653,1 @@\n-            return new INSTANCEOF(cp.addArrayClass((ArrayType) t));\n+            return new CHECKCAST(cp.addArrayClass((ArrayType) t));\n@@ -603,5 +655,1 @@\n-        return new INSTANCEOF(cp.addClass((ObjectType) t));\n-    }\n-\n-    private InvokeInstruction createInvoke(final MethodObject m, final short kind) {\n-        return createInvoke(m.className, m.name, m.resultType, m.argTypes, kind);\n+        return new CHECKCAST(cp.addClass((ObjectType) t));\n@@ -610,13 +658,0 @@\n-    \/**\n-     * Create an invoke instruction. (Except for invokedynamic.)\n-     *\n-     * @param className name of the called class\n-     * @param name name of the called method\n-     * @param retType return type of method\n-     * @param argTypes argument types of method\n-     * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n-     * @see Const\n-     *\/\n-    public InvokeInstruction createInvoke(final String className, final String name, final Type retType, final Type[] argTypes, final short kind) {\n-        return createInvoke(className, name, retType, argTypes, kind, kind == Const.INVOKEINTERFACE);\n-    }\n@@ -624,43 +659,3 @@\n-    \/**\n-     * Create an invoke instruction. (Except for invokedynamic.)\n-     *\n-     * @param className name of the called class\n-     * @param name name of the called method\n-     * @param retType return type of method\n-     * @param argTypes argument types of method\n-     * @param kind how to invoke: INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n-     * @param useInterface force use of InterfaceMethodref\n-     * @return A new InvokeInstruction.\n-     * @since 6.5.0\n-     *\/\n-    public InvokeInstruction createInvoke(final String className, final String name, final Type retType, final Type[] argTypes, final short kind,\n-        final boolean useInterface) {\n-        if (kind != Const.INVOKESPECIAL && kind != Const.INVOKEVIRTUAL && kind != Const.INVOKESTATIC && kind != Const.INVOKEINTERFACE\n-            && kind != Const.INVOKEDYNAMIC) {\n-            throw new IllegalArgumentException(\"Unknown invoke kind: \" + kind);\n-        }\n-        int index;\n-        int nargs = 0;\n-        final String signature = Type.getMethodSignature(retType, argTypes);\n-        for (final Type argType : argTypes) {\n-            nargs += argType.getSize();\n-        }\n-        if (useInterface) {\n-            index = cp.addInterfaceMethodref(className, name, signature);\n-        } else {\n-            index = cp.addMethodref(className, name, signature);\n-        }\n-        switch (kind) {\n-        case Const.INVOKESPECIAL:\n-            return new INVOKESPECIAL(index);\n-        case Const.INVOKEVIRTUAL:\n-            return new INVOKEVIRTUAL(index);\n-        case Const.INVOKESTATIC:\n-            return new INVOKESTATIC(index);\n-        case Const.INVOKEINTERFACE:\n-            return new INVOKEINTERFACE(index, nargs + 1);\n-        case Const.INVOKEDYNAMIC:\n-            return new INVOKEDYNAMIC(index);\n-        default:\n-            \/\/ Can't happen\n-            throw new IllegalStateException(\"Unknown invoke kind: \" + kind);\n+    public INSTANCEOF createInstanceOf( final ReferenceType t ) {\n+        if (t instanceof ArrayType) {\n+            return new INSTANCEOF(cp.addArrayClass((ArrayType) t));\n@@ -668,0 +663,1 @@\n+        return new INSTANCEOF(cp.addClass((ObjectType) t));\n@@ -670,1 +666,2 @@\n-    public NEW createNew(final ObjectType t) {\n+\n+    public NEW createNew( final ObjectType t ) {\n@@ -674,1 +671,2 @@\n-    public NEW createNew(final String s) {\n+\n+    public NEW createNew( final String s ) {\n@@ -681,1 +679,2 @@\n-     * @return an instruction that creates the corresponding array at runtime, i.e. is an AllocationInstruction\n+     * @return an instruction that creates the corresponding array at runtime,\n+     * i.e. is an AllocationInstruction\n@@ -683,1 +682,1 @@\n-    public Instruction createNewArray(final Type t, final short dim) {\n+    public Instruction createNewArray( final Type t, final short dim ) {\n@@ -687,2 +686,1 @@\n-            }\n-            if (t instanceof ArrayType) {\n+            } else if (t instanceof ArrayType) {\n@@ -690,0 +688,2 @@\n+            } else {\n+                return new NEWARRAY(t.getType());\n@@ -691,1 +691,0 @@\n-            return new NEWARRAY(t.getType());\n@@ -703,3 +702,1 @@\n-     * Create a call to the most popular System.out.println() method.\n-     *\n-     * @param s the string to print\n+     * Create \"null\" value for reference types, 0 for basic types like int\n@@ -707,7 +704,22 @@\n-    public InstructionList createPrintln(final String s) {\n-        final InstructionList il = new InstructionList();\n-        il.append(createGetStatic(\"java.lang.System\", \"out\", Type.getType(\"Ljava\/io\/PrintStream;\")));\n-        il.append(new PUSH(cp, s));\n-        final MethodObject methodObject = new MethodObject(\"java.io.PrintStream\", \"println\", Type.VOID, new Type[] { Type.getType(\"Ljava\/lang\/String;\") });\n-        il.append(createInvoke(methodObject, Const.INVOKEVIRTUAL));\n-        return il;\n+    public static Instruction createNull( final Type type ) {\n+        switch (type.getType()) {\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return InstructionConst.ACONST_NULL;\n+            case Const.T_INT:\n+            case Const.T_SHORT:\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+                return InstructionConst.ICONST_0;\n+            case Const.T_FLOAT:\n+                return InstructionConst.FCONST_0;\n+            case Const.T_DOUBLE:\n+                return InstructionConst.DCONST_0;\n+            case Const.T_LONG:\n+                return InstructionConst.LCONST_0;\n+            case Const.T_VOID:\n+                return InstructionConst.NOP;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type: \" + type);\n+        }\n@@ -716,2 +728,50 @@\n-    public PUTFIELD createPutField(final String className, final String name, final Type t) {\n-        return new PUTFIELD(cp.addFieldref(className, name, t.getSignature()));\n+    \/**\n+     * Create branch instruction by given opcode, except LOOKUPSWITCH and\n+     * TABLESWITCH. For those you should use the SWITCH compound instruction.\n+     *\/\n+    public static BranchInstruction createBranchInstruction( final short opcode,\n+            final InstructionHandle target ) {\n+        switch (opcode) {\n+            case Const.IFEQ:\n+                return new IFEQ(target);\n+            case Const.IFNE:\n+                return new IFNE(target);\n+            case Const.IFLT:\n+                return new IFLT(target);\n+            case Const.IFGE:\n+                return new IFGE(target);\n+            case Const.IFGT:\n+                return new IFGT(target);\n+            case Const.IFLE:\n+                return new IFLE(target);\n+            case Const.IF_ICMPEQ:\n+                return new IF_ICMPEQ(target);\n+            case Const.IF_ICMPNE:\n+                return new IF_ICMPNE(target);\n+            case Const.IF_ICMPLT:\n+                return new IF_ICMPLT(target);\n+            case Const.IF_ICMPGE:\n+                return new IF_ICMPGE(target);\n+            case Const.IF_ICMPGT:\n+                return new IF_ICMPGT(target);\n+            case Const.IF_ICMPLE:\n+                return new IF_ICMPLE(target);\n+            case Const.IF_ACMPEQ:\n+                return new IF_ACMPEQ(target);\n+            case Const.IF_ACMPNE:\n+                return new IF_ACMPNE(target);\n+            case Const.GOTO:\n+                return new GOTO(target);\n+            case Const.JSR:\n+                return new JSR(target);\n+            case Const.IFNULL:\n+                return new IFNULL(target);\n+            case Const.IFNONNULL:\n+                return new IFNONNULL(target);\n+            case Const.GOTO_W:\n+                return new GOTO_W(target);\n+            case Const.JSR_W:\n+                return new JSR_W(target);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid opcode: \" + opcode);\n+        }\n@@ -720,2 +780,3 @@\n-    public PUTSTATIC createPutStatic(final String className, final String name, final Type t) {\n-        return new PUTSTATIC(cp.addFieldref(className, name, t.getSignature()));\n+\n+    public void setClassGen( final ClassGen c ) {\n+        cg = c;\n@@ -724,0 +785,1 @@\n+\n@@ -728,3 +790,0 @@\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n-    }\n@@ -732,2 +791,2 @@\n-    public void setClassGen(final ClassGen c) {\n-        cg = c;\n+    public void setConstantPool( final ConstantPoolGen c ) {\n+        cp = c;\n@@ -736,2 +795,3 @@\n-    public void setConstantPool(final ConstantPoolGen c) {\n-        cp = c;\n+\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionFactory.java","additions":605,"deletions":545,"binary":false,"changes":1150,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * Instances of this class give users a handle to the instructions contained in an InstructionList. Instruction objects\n- * may be used more than once within a list, this is useful because it saves memory and may be much faster.\n+ * Instances of this class give users a handle to the instructions contained in\n+ * an InstructionList. Instruction objects may be used more than once within a\n+ * list, this is useful because it saves memory and may be much faster.\n@@ -34,3 +35,6 @@\n- * Within an InstructionList an InstructionHandle object is wrapped around all instructions, i.e., it implements a cell\n- * in a doubly-linked list. From the outside only the next and the previous instruction (handle) are accessible. One can\n- * traverse the list via an Enumeration returned by InstructionList.elements().\n+ * Within an InstructionList an InstructionHandle object is wrapped\n+ * around all instructions, i.e., it implements a cell in a\n+ * doubly-linked list. From the outside only the next and the\n+ * previous instruction (handle) are accessible. One\n+ * can traverse the list via an Enumeration returned by\n+ * InstructionList.elements().\n@@ -45,0 +49,10 @@\n+    private InstructionHandle next;\n+    private InstructionHandle prev;\n+    private Instruction instruction;\n+\n+    private int i_position = -1; \/\/ byte code offset of instruction\n+\n+    private Set<InstructionTargeter> targeters;\n+    private Map<Object, Object> attributes;\n+\n+\n@@ -46,1 +60,1 @@\n-     * Empty array.\n+     * Does nothing.\n@@ -48,1 +62,1 @@\n-     * @since 6.6.0\n+     * @deprecated Does nothing as of 6.3.1.\n@@ -50,1 +64,18 @@\n-    public static final InstructionHandle[] EMPTY_ARRAY = {};\n+    @Deprecated\n+    protected void addHandle() {\n+        \/\/ noop\n+    }\n+\n+    public final InstructionHandle getNext() {\n+        return next;\n+    }\n+\n+\n+    public final InstructionHandle getPrev() {\n+        return prev;\n+    }\n+\n+\n+    public final Instruction getInstruction() {\n+        return instruction;\n+    }\n@@ -52,4 +83,0 @@\n-    \/**\n-     * Empty array.\n-     *\/\n-    static final InstructionTargeter[] EMPTY_INSTRUCTION_TARGETER_ARRAY = {};\n@@ -58,1 +85,2 @@\n-     * Factory method.\n+     * Replace current instruction contained in this handle.\n+     * Old instruction is disposed using Instruction.dispose().\n@@ -60,2 +88,11 @@\n-    static InstructionHandle getInstructionHandle(final Instruction i) {\n-        return new InstructionHandle(i);\n+    public void setInstruction( final Instruction i ) { \/\/ Overridden in BranchHandle TODO could be package-protected?\n+        if (i == null) {\n+            throw new ClassGenException(\"Assigning null to handle\");\n+        }\n+        if ((this.getClass() != BranchHandle.class) && (i instanceof BranchInstruction)) {\n+            throw new ClassGenException(\"Assigning branch instruction \" + i + \" to plain handle\");\n+        }\n+        if (instruction != null) {\n+            instruction.dispose();\n+        }\n+        instruction = i;\n@@ -64,4 +101,0 @@\n-    private InstructionHandle next;\n-    private InstructionHandle prev;\n-\n-    private Instruction instruction;\n@@ -70,1 +103,7 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     * Temporarily swap the current instruction, without disturbing\n+     * anything. Meant to be used by a debugger, implementing\n+     * breakpoints. Current instruction is returned.\n+     * <p>\n+     * Warning: if this is used on a BranchHandle then some methods such as\n+     * getPosition() will still refer to the original cached instruction, whereas\n+     * other BH methods may affect the cache and the replacement instruction.\n@@ -72,3 +111,7 @@\n-    @Deprecated\n-    protected int i_position = -1; \/\/ byte code offset of instruction\n-    private Set<InstructionTargeter> targeters;\n+    \/\/ See BCEL-273\n+    \/\/ TODO remove this method in any redesign of BCEL\n+    public Instruction swapInstruction( final Instruction i ) {\n+        final Instruction oldInstruction = instruction;\n+        instruction = i;\n+        return oldInstruction;\n+    }\n@@ -76,1 +119,0 @@\n-    private Map<Object, Object> attributes;\n@@ -78,1 +120,1 @@\n-    protected InstructionHandle(final Instruction i) {\n+    \/*private*\/protected InstructionHandle(final Instruction i) {\n@@ -82,4 +124,1 @@\n-    \/**\n-     * Convenience method, simply calls accept() on the contained instruction.\n-     *\n-     * @param v Visitor object\n+    \/** Factory method.\n@@ -87,2 +126,2 @@\n-    public void accept(final Visitor v) {\n-        instruction.accept(v);\n+    static InstructionHandle getInstructionHandle( final Instruction i ) {\n+        return new InstructionHandle(i);\n@@ -91,0 +130,1 @@\n+\n@@ -92,1 +132,4 @@\n-     * Add an attribute to an instruction handle.\n+     * Called by InstructionList.setPositions when setting the position for every\n+     * instruction. In the presence of variable length instructions `setPositions()'\n+     * performs multiple passes over the instruction list to calculate the\n+     * correct (byte) positions and offsets by calling this function.\n@@ -94,2 +137,3 @@\n-     * @param key the key object to store\/retrieve the attribute\n-     * @param attr the attribute to associate with this handle\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param max_offset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n@@ -97,5 +141,3 @@\n-    public void addAttribute(final Object key, final Object attr) {\n-        if (attributes == null) {\n-            attributes = new HashMap<>(3);\n-        }\n-        attributes.put(key, attr);\n+    protected int updatePosition( final int offset, final int max_offset ) {\n+        i_position += offset;\n+        return 0;\n@@ -104,4 +146,4 @@\n-    \/**\n-     * Does nothing.\n-     *\n-     * @deprecated Does nothing as of 6.3.1.\n+\n+    \/** @return the position, i.e., the byte code offset of the contained\n+     * instruction. This is accurate only after\n+     * InstructionList.setPositions() has been called.\n@@ -109,3 +151,2 @@\n-    @Deprecated\n-    protected void addHandle() {\n-        \/\/ noop\n+    public int getPosition() {\n+        return i_position;\n@@ -114,2 +155,3 @@\n-    \/**\n-     * Denote this handle is being referenced by t.\n+\n+    \/** Set the position, i.e., the byte code offset of the contained\n+     * instruction.\n@@ -117,6 +159,2 @@\n-    public void addTargeter(final InstructionTargeter t) {\n-        if (targeters == null) {\n-            targeters = new HashSet<>();\n-        }\n-        \/\/ if(!targeters.contains(t))\n-        targeters.add(t);\n+    void setPosition( final int pos ) {\n+        i_position = pos;\n@@ -125,0 +163,1 @@\n+\n@@ -137,4 +176,2 @@\n-    \/**\n-     * Get attribute of an instruction handle.\n-     *\n-     * @param key the key object to store\/retrieve the attribute\n+\n+    \/** Remove all targeters, if any.\n@@ -142,3 +179,3 @@\n-    public Object getAttribute(final Object key) {\n-        if (attributes != null) {\n-            return attributes.get(key);\n+    public void removeAllTargeters() {\n+        if (targeters != null) {\n+            targeters.clear();\n@@ -146,1 +183,0 @@\n-        return null;\n@@ -149,0 +185,1 @@\n+\n@@ -150,1 +187,1 @@\n-     * @return all attributes associated with this handle\n+     * Denote this handle isn't referenced anymore by t.\n@@ -152,3 +189,3 @@\n-    public Collection<Object> getAttributes() {\n-        if (attributes == null) {\n-            attributes = new HashMap<>(3);\n+    public void removeTargeter( final InstructionTargeter t ) {\n+        if (targeters != null) {\n+            targeters.remove(t);\n@@ -156,5 +193,0 @@\n-        return attributes.values();\n-    }\n-\n-    public final Instruction getInstruction() {\n-        return instruction;\n@@ -163,3 +195,0 @@\n-    public final InstructionHandle getNext() {\n-        return next;\n-    }\n@@ -168,2 +197,1 @@\n-     * @return the position, i.e., the byte code offset of the contained instruction. This is accurate only after\n-     *         InstructionList.setPositions() has been called.\n+     * Denote this handle is being referenced by t.\n@@ -171,2 +199,6 @@\n-    public int getPosition() {\n-        return i_position;\n+    public void addTargeter( final InstructionTargeter t ) {\n+        if (targeters == null) {\n+            targeters = new HashSet<>();\n+        }\n+        \/\/if(!targeters.contains(t))\n+        targeters.add(t);\n@@ -175,2 +207,3 @@\n-    public final InstructionHandle getPrev() {\n-        return prev;\n+\n+    public boolean hasTargeters() {\n+        return (targeters != null) && (targeters.size() > 0);\n@@ -179,0 +212,1 @@\n+\n@@ -184,1 +218,1 @@\n-            return EMPTY_INSTRUCTION_TARGETER_ARRAY;\n+            return new InstructionTargeter[0];\n@@ -191,2 +225,5 @@\n-    public boolean hasTargeters() {\n-        return targeters != null && !targeters.isEmpty();\n+\n+    \/** @return a (verbose) string representation of the contained instruction.\n+     *\/\n+    public String toString( final boolean verbose ) {\n+        return Utility.format(i_position, 4, false, ' ') + \": \" + instruction.toString(verbose);\n@@ -195,2 +232,2 @@\n-    \/**\n-     * Remove all targeters, if any.\n+\n+    \/** @return a string representation of the contained instruction.\n@@ -198,3 +235,14 @@\n-    public void removeAllTargeters() {\n-        if (targeters != null) {\n-            targeters.clear();\n+    @Override\n+    public String toString() {\n+        return toString(true);\n+    }\n+\n+\n+    \/** Add an attribute to an instruction handle.\n+     *\n+     * @param key the key object to store\/retrieve the attribute\n+     * @param attr the attribute to associate with this handle\n+     *\/\n+    public void addAttribute( final Object key, final Object attr ) {\n+        if (attributes == null) {\n+            attributes = new HashMap<>(3);\n@@ -202,0 +250,1 @@\n+        attributes.put(key, attr);\n@@ -204,2 +253,2 @@\n-    \/**\n-     * Delete an attribute of an instruction handle.\n+\n+    \/** Delete an attribute of an instruction handle.\n@@ -209,1 +258,1 @@\n-    public void removeAttribute(final Object key) {\n+    public void removeAttribute( final Object key ) {\n@@ -215,2 +264,4 @@\n-    \/**\n-     * Denote this handle isn't referenced anymore by t.\n+\n+    \/** Get attribute of an instruction handle.\n+     *\n+     * @param key the key object to store\/retrieve the attribute\n@@ -218,3 +269,3 @@\n-    public void removeTargeter(final InstructionTargeter t) {\n-        if (targeters != null) {\n-            targeters.remove(t);\n+    public Object getAttribute( final Object key ) {\n+        if (attributes != null) {\n+            return attributes.get(key);\n@@ -222,0 +273,1 @@\n+        return null;\n@@ -224,2 +276,2 @@\n-    \/**\n-     * Replace current instruction contained in this handle. Old instruction is disposed using Instruction.dispose().\n+\n+    \/** @return all attributes associated with this handle\n@@ -227,9 +279,3 @@\n-    public void setInstruction(final Instruction i) { \/\/ Overridden in BranchHandle TODO could be package-protected?\n-        if (i == null) {\n-            throw new ClassGenException(\"Assigning null to handle\");\n-        }\n-        if (this.getClass() != BranchHandle.class && i instanceof BranchInstruction) {\n-            throw new ClassGenException(\"Assigning branch instruction \" + i + \" to plain handle\");\n-        }\n-        if (instruction != null) {\n-            instruction.dispose();\n+    public Collection<Object> getAttributes() {\n+        if (attributes == null) {\n+            attributes = new HashMap<>(3);\n@@ -237,1 +283,10 @@\n-        instruction = i;\n+        return attributes.values();\n+    }\n+\n+\n+    \/** Convenience method, simply calls accept() on the contained instruction.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    public void accept( final Visitor v ) {\n+        instruction.accept(v);\n@@ -240,0 +295,1 @@\n+\n@@ -249,6 +305,0 @@\n-    \/**\n-     * Set the position, i.e., the byte code offset of the contained instruction.\n-     *\/\n-    void setPosition(final int pos) {\n-        i_position = pos;\n-    }\n@@ -264,44 +314,0 @@\n-\n-    \/**\n-     * Temporarily swap the current instruction, without disturbing anything. Meant to be used by a debugger, implementing\n-     * breakpoints. Current instruction is returned.\n-     * <p>\n-     * Warning: if this is used on a BranchHandle then some methods such as getPosition() will still refer to the original\n-     * cached instruction, whereas other BH methods may affect the cache and the replacement instruction.\n-     *\/\n-    \/\/ See BCEL-273\n-    \/\/ TODO remove this method in any redesign of BCEL\n-    public Instruction swapInstruction(final Instruction i) {\n-        final Instruction oldInstruction = instruction;\n-        instruction = i;\n-        return oldInstruction;\n-    }\n-\n-    \/**\n-     * @return a string representation of the contained instruction.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return toString(true);\n-    }\n-\n-    \/**\n-     * @return a (verbose) string representation of the contained instruction.\n-     *\/\n-    public String toString(final boolean verbose) {\n-        return Utility.format(i_position, 4, false, ' ') + \": \" + instruction.toString(verbose);\n-    }\n-\n-    \/**\n-     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n-     * length instructions 'setPositions()' performs multiple passes over the instruction list to calculate the correct\n-     * (byte) positions and offsets by calling this function.\n-     *\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param maxOffset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n-     *\/\n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        i_position += offset;\n-        return 0;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionHandle.java","additions":164,"deletions":158,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,0 +22,3 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.classfile.Constant;\n+import com.sun.org.apache.bcel.internal.util.ByteSequence;\n@@ -26,1 +29,0 @@\n-import java.util.Arrays;\n@@ -33,4 +35,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.classfile.Constant;\n-import com.sun.org.apache.bcel.internal.util.ByteSequence;\n-\n@@ -38,1 +36,2 @@\n- * This class is a container for a list of <a href=\"Instruction.html\">Instruction<\/a> objects. Instructions can be\n+ * This class is a container for a list of <a\n+ * href=\"Instruction.html\">Instruction<\/a> objects. Instructions can be\n@@ -40,3 +39,4 @@\n- * <a href=\"InstructionHandle.html\">InstructionHandles<\/a> objects that are returned upon append\/insert operations. They\n- * give the user (read only) access to the list structure, such that it can be traversed and manipulated in a controlled\n- * way.\n+ * <a href=\"InstructionHandle.html\">InstructionHandles<\/a> objects that are\n+ * returned upon append\/insert operations. They give the user (read only) access\n+ * to the list structure, such that it can be traversed and manipulated in a\n+ * controlled way.\n@@ -44,1 +44,2 @@\n- * A list is finally dumped to a byte code array with <a href=\"#getByteCode()\">getByteCode<\/a>.\n+ * A list is finally dumped to a byte code array with <a\n+ * href=\"#getByteCode()\">getByteCode<\/a>.\n@@ -49,1 +50,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -53,0 +54,49 @@\n+    private InstructionHandle start = null;\n+    private InstructionHandle end = null;\n+    private int length = 0; \/\/ number of elements in list\n+    private int[] bytePositions; \/\/ byte code offsets corresponding to instructions\n+\n+    \/**\n+     * Create (empty) instruction list.\n+     *\/\n+    public InstructionList() {\n+    }\n+\n+    \/**\n+     * Create instruction list containing one instruction.\n+     *\n+     * @param i\n+     *            initial instruction\n+     *\/\n+    public InstructionList(final Instruction i) {\n+        append(i);\n+    }\n+\n+    \/**\n+     * Create instruction list containing one instruction.\n+     *\n+     * @param i\n+     *            initial instruction\n+     *\/\n+    public InstructionList(final BranchInstruction i) {\n+        append(i);\n+    }\n+\n+    \/**\n+     * Initialize list with (nonnull) compound instruction. Consumes argument\n+     * list, i.e., it becomes empty.\n+     *\n+     * @param c\n+     *            compound instruction (list)\n+     *\/\n+    public InstructionList(final CompoundInstruction c) {\n+        append(c.getInstructionList());\n+    }\n+\n+    \/**\n+     * Test for empty list.\n+     *\/\n+    public boolean isEmpty() {\n+        return start == null;\n+    } \/\/ && end == null\n+\n@@ -54,1 +104,2 @@\n-     * Find the target instruction (handle) that corresponds to the given target position (byte code offset).\n+     * Find the target instruction (handle) that corresponds to the given target\n+     * position (byte code offset).\n@@ -56,4 +107,8 @@\n-     * @param ihs array of instruction handles, i.e. il.getInstructionHandles()\n-     * @param pos array of positions corresponding to ihs, i.e. il.getInstructionPositions()\n-     * @param count length of arrays\n-     * @param target target position to search for\n+     * @param ihs\n+     *            array of instruction handles, i.e. il.getInstructionHandles()\n+     * @param pos\n+     *            array of positions corresponding to ihs, i.e. il.getInstructionPositions()\n+     * @param count\n+     *            length of arrays\n+     * @param target\n+     *            target position to search for\n@@ -62,1 +117,2 @@\n-    public static InstructionHandle findHandle(final InstructionHandle[] ihs, final int[] pos, final int count, final int target) {\n+    public static InstructionHandle findHandle(final InstructionHandle[] ihs,\n+            final int[] pos, final int count, final int target) {\n@@ -69,1 +125,1 @@\n-            final int i = l + r >>> 1;\n+            final int i = (l + r) >>> 1;\n@@ -73,2 +129,1 @@\n-            }\n-            if (target < j) {\n+            } else if (target < j) {\n@@ -83,14 +138,0 @@\n-    private InstructionHandle start;\n-    private InstructionHandle end;\n-    private int length; \/\/ number of elements in list\n-\n-    private int[] bytePositions; \/\/ byte code offsets corresponding to instructions\n-\n-    private List<InstructionListObserver> observers;\n-\n-    \/**\n-     * Create (empty) instruction list.\n-     *\/\n-    public InstructionList() {\n-    }\n-\n@@ -98,1 +139,3 @@\n-     * Create instruction list containing one instruction.\n+     * Get instruction handle for instruction at byte code position pos. This\n+     * only works properly, if the list is freshly initialized from a byte array\n+     * or setPositions() has been called before this method.\n@@ -100,1 +143,3 @@\n-     * @param i initial instruction\n+     * @param pos\n+     *            byte code position to search for\n+     * @return target position's instruction handle if available\n@@ -102,2 +147,10 @@\n-    public InstructionList(final BranchInstruction i) {\n-        append(i);\n+    public InstructionHandle findHandle(final int pos) {\n+        final int[] positions = bytePositions;\n+        InstructionHandle ih = start;\n+        for (int i = 0; i < length; i++) {\n+            if (positions[i] == pos) {\n+                return ih;\n+            }\n+            ih = ih.getNext();\n+        }\n+        return null;\n@@ -109,1 +162,2 @@\n-     * @param code byte array containing the instructions\n+     * @param code\n+     *            byte array containing the instructions\n@@ -142,1 +196,2 @@\n-        bytePositions = Arrays.copyOf(pos, count); \/\/ Trim to proper size\n+        bytePositions = new int[count]; \/\/ Trim to proper size\n+        System.arraycopy(pos, 0, bytePositions, 0, count);\n@@ -149,3 +204,4 @@\n-                int target = bi.getPosition() + bi.getIndex(); \/*\n-                                                                * Byte code position: relative -> absolute.\n-                                                                *\/\n+                int target = bi.getPosition() + bi.getIndex();\n+                \/*\n+                 * Byte code position: relative -> absolute.\n+                 *\/\n@@ -176,1 +232,2 @@\n-     * Initialize list with (nonnull) compound instruction. Consumes argument list, i.e., it becomes empty.\n+     * Append another list after instruction (handle) ih contained in this list.\n+     * Consumes argument list, i.e., it becomes empty.\n@@ -178,1 +235,5 @@\n-     * @param c compound instruction (list)\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param il\n+     *            Instruction list to append to this one\n+     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n@@ -180,2 +241,20 @@\n-    public InstructionList(final CompoundInstruction c) {\n-        append(c.getInstructionList());\n+    public InstructionHandle append(final InstructionHandle ih, final InstructionList il) {\n+        if (il == null) {\n+            throw new ClassGenException(\"Appending null InstructionList\");\n+        }\n+        if (il.isEmpty()) {\n+            return ih;\n+        }\n+        final InstructionHandle next = ih.getNext();\n+        final InstructionHandle ret = il.start;\n+        ih.setNext(il.start);\n+        il.start.setPrev(ih);\n+        il.end.setNext(next);\n+        if (next != null) {\n+            next.setPrev(il.end);\n+        } else {\n+            end = il.end; \/\/ Update end ...\n+        }\n+        length += il.length; \/\/ Update length\n+        il.clear();\n+        return ret;\n@@ -185,1 +264,2 @@\n-     * Create instruction list containing one instruction.\n+     * Append another list after instruction i contained in this list. Consumes\n+     * argument list, i.e., it becomes empty.\n@@ -187,8 +267,5 @@\n-     * @param i initial instruction\n-     *\/\n-    public InstructionList(final Instruction i) {\n-        append(i);\n-    }\n-\n-    \/**\n-     * Add observer for this object.\n+     * @param i\n+     *            where to append the instruction list\n+     * @param il\n+     *            Instruction list to append to this one\n+     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n@@ -196,3 +273,4 @@\n-    public void addObserver(final InstructionListObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n+    public InstructionHandle append(final Instruction i, final InstructionList il) {\n+        InstructionHandle ih;\n+        if ((ih = findInstruction2(i)) == null) {\n+            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n@@ -200,1 +278,1 @@\n-        observers.add(o);\n+        return append(ih, il);\n@@ -204,1 +282,2 @@\n-     * Append a branch instruction to the end of this list.\n+     * Append another list to this one. Consumes argument list, i.e., it becomes\n+     * empty.\n@@ -206,2 +285,3 @@\n-     * @param i branch instruction to append\n-     * @return branch instruction handle of the appended instruction\n+     * @param il\n+     *            list to append to end of this list\n+     * @return instruction handle of the <B>first<\/B> appended instruction\n@@ -209,4 +289,15 @@\n-    public BranchHandle append(final BranchInstruction i) {\n-        final BranchHandle ih = BranchHandle.getBranchHandle(i);\n-        append(ih);\n-        return ih;\n+    public InstructionHandle append(final InstructionList il) {\n+        if (il == null) {\n+            throw new ClassGenException(\"Appending null InstructionList\");\n+        }\n+        if (il.isEmpty()) {\n+            return null;\n+        }\n+        if (isEmpty()) {\n+            start = il.start;\n+            end = il.end;\n+            length = il.length;\n+            il.clear();\n+            return start;\n+        }\n+        return append(end, il); \/\/ was end.instruction\n@@ -216,1 +307,1 @@\n-     * Append a compound instruction.\n+     * Append an instruction to the end of this list.\n@@ -218,2 +309,2 @@\n-     * @param c The composite instruction (containing an InstructionList)\n-     * @return instruction handle of the first appended instruction\n+     * @param ih\n+     *            instruction to append\n@@ -221,2 +312,11 @@\n-    public InstructionHandle append(final CompoundInstruction c) {\n-        return append(c.getInstructionList());\n+    private void append(final InstructionHandle ih) {\n+        if (isEmpty()) {\n+            start = end = ih;\n+            ih.setNext(ih.setPrev(null));\n+        } else {\n+            end.setNext(ih);\n+            ih.setPrev(end);\n+            ih.setNext(null);\n+            end = ih;\n+        }\n+        length++; \/\/ Update length\n@@ -228,1 +328,2 @@\n-     * @param i instruction to append\n+     * @param i\n+     *            instruction to append\n@@ -238,1 +339,1 @@\n-     * Append a compound instruction, after instruction i.\n+     * Append a branch instruction to the end of this list.\n@@ -240,3 +341,3 @@\n-     * @param i Instruction in list\n-     * @param c The composite instruction (containing an InstructionList)\n-     * @return instruction handle of the first appended instruction\n+     * @param i\n+     *            branch instruction to append\n+     * @return branch instruction handle of the appended instruction\n@@ -244,2 +345,4 @@\n-    public InstructionHandle append(final Instruction i, final CompoundInstruction c) {\n-        return append(i, c.getInstructionList());\n+    public BranchHandle append(final BranchInstruction i) {\n+        final BranchHandle ih = BranchHandle.getBranchHandle(i);\n+        append(ih);\n+        return ih;\n@@ -249,1 +352,2 @@\n-     * Append a single instruction j after another instruction i, which must be in this list of course!\n+     * Append a single instruction j after another instruction i, which must be\n+     * in this list of course!\n@@ -251,2 +355,4 @@\n-     * @param i Instruction in list\n-     * @param j Instruction to append after i in list\n+     * @param i\n+     *            Instruction in list\n+     * @param j\n+     *            Instruction to append after i in list\n@@ -260,16 +366,1 @@\n-     * Append another list after instruction i contained in this list. Consumes argument list, i.e., it becomes empty.\n-     *\n-     * @param i where to append the instruction list\n-     * @param il Instruction list to append to this one\n-     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n-     *\/\n-    public InstructionHandle append(final Instruction i, final InstructionList il) {\n-        InstructionHandle ih;\n-        if ((ih = findInstruction2(i)) == null) {\n-            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n-        }\n-        return append(ih, il);\n-    }\n-\n-    \/**\n-     * Append an instruction to the end of this list.\n+     * Append a compound instruction, after instruction i.\n@@ -277,1 +368,5 @@\n-     * @param ih instruction to append\n+     * @param i\n+     *            Instruction in list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n+     * @return instruction handle of the first appended instruction\n@@ -279,11 +374,2 @@\n-    private void append(final InstructionHandle ih) {\n-        if (isEmpty()) {\n-            start = end = ih;\n-            ih.setNext(ih.setPrev(null));\n-        } else {\n-            end.setNext(ih);\n-            ih.setPrev(end);\n-            ih.setNext(null);\n-            end = ih;\n-        }\n-        length++; \/\/ Update length\n+    public InstructionHandle append(final Instruction i, final CompoundInstruction c) {\n+        return append(i, c.getInstructionList());\n@@ -293,1 +379,1 @@\n-     * Append an instruction after instruction (handle) ih contained in this list.\n+     * Append a compound instruction.\n@@ -295,3 +381,3 @@\n-     * @param ih where to append the instruction list\n-     * @param i Instruction to append\n-     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n+     * @return instruction handle of the first appended instruction\n@@ -299,6 +385,2 @@\n-    public BranchHandle append(final InstructionHandle ih, final BranchInstruction i) {\n-        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n-        final InstructionList il = new InstructionList();\n-        il.append(bh);\n-        append(ih, il);\n-        return bh;\n+    public InstructionHandle append(final CompoundInstruction c) {\n+        return append(c.getInstructionList());\n@@ -310,2 +392,4 @@\n-     * @param ih where to append the instruction list\n-     * @param c The composite instruction (containing an InstructionList)\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n@@ -321,2 +405,4 @@\n-     * @param ih where to append the instruction list\n-     * @param i Instruction to append\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param i\n+     *            Instruction to append\n@@ -330,2 +416,1 @@\n-     * Append another list after instruction (handle) ih contained in this list. Consumes argument list, i.e., it becomes\n-     * empty.\n+     * Append an instruction after instruction (handle) ih contained in this list.\n@@ -333,2 +418,4 @@\n-     * @param ih where to append the instruction list\n-     * @param il Instruction list to append to this one\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param i\n+     *            Instruction to append\n@@ -337,1 +424,19 @@\n-    public InstructionHandle append(final InstructionHandle ih, final InstructionList il) {\n+    public BranchHandle append(final InstructionHandle ih, final BranchInstruction i) {\n+        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n+        final InstructionList il = new InstructionList();\n+        il.append(bh);\n+        append(ih, il);\n+        return bh;\n+    }\n+\n+    \/**\n+     * Insert another list before Instruction handle ih contained in this list.\n+     * Consumes argument list, i.e., it becomes empty.\n+     *\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param il\n+     *            Instruction list to insert\n+     * @return instruction handle of the first inserted instruction\n+     *\/\n+    public InstructionHandle insert(final InstructionHandle ih, final InstructionList il) {\n@@ -339,1 +444,1 @@\n-            throw new ClassGenException(\"Appending null InstructionList\");\n+            throw new ClassGenException(\"Inserting null InstructionList\");\n@@ -344,1 +449,1 @@\n-        final InstructionHandle next = ih.getNext();\n+        final InstructionHandle prev = ih.getPrev();\n@@ -346,5 +451,5 @@\n-        ih.setNext(il.start);\n-        il.start.setPrev(ih);\n-        il.end.setNext(next);\n-        if (next != null) {\n-            next.setPrev(il.end);\n+        ih.setPrev(il.end);\n+        il.end.setNext(ih);\n+        il.start.setPrev(prev);\n+        if (prev != null) {\n+            prev.setNext(il.start);\n@@ -352,1 +457,1 @@\n-            end = il.end; \/\/ Update end ...\n+            start = il.start; \/\/ Update start ...\n@@ -360,1 +465,1 @@\n-     * Append another list to this one. Consumes argument list, i.e., it becomes empty.\n+     * Insert another list.\n@@ -362,2 +467,3 @@\n-     * @param il list to append to end of this list\n-     * @return instruction handle of the <B>first<\/B> appended instruction\n+     * @param il\n+     *            list to insert before start of this list\n+     * @return instruction handle of the first inserted instruction\n@@ -365,7 +471,1 @@\n-    public InstructionHandle append(final InstructionList il) {\n-        if (il == null) {\n-            throw new ClassGenException(\"Appending null InstructionList\");\n-        }\n-        if (il.isEmpty()) {\n-            return null;\n-        }\n+    public InstructionHandle insert(final InstructionList il) {\n@@ -373,4 +473,1 @@\n-            start = il.start;\n-            end = il.end;\n-            length = il.length;\n-            il.clear();\n+            append(il); \/\/ Code is identical for this case\n@@ -379,22 +476,1 @@\n-        return append(end, il); \/\/ was end.instruction\n-    }\n-\n-    private void clear() {\n-        start = end = null;\n-        length = 0;\n-    }\n-\n-    public boolean contains(final Instruction i) {\n-        return findInstruction1(i) != null;\n-    }\n-\n-    public boolean contains(final InstructionHandle i) {\n-        if (i == null) {\n-            return false;\n-        }\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            if (ih == i) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        return insert(start, il);\n@@ -404,1 +480,4 @@\n-     * @return complete, i.e., deep copy of this list\n+     * Insert an instruction at start of this list.\n+     *\n+     * @param ih\n+     *            instruction to insert\n@@ -406,40 +485,9 @@\n-    public InstructionList copy() {\n-        final Map<InstructionHandle, InstructionHandle> map = new HashMap<>();\n-        final InstructionList il = new InstructionList();\n-        \/*\n-         * Pass 1: Make copies of all instructions, append them to the new list and associate old instruction references with\n-         * the new ones, i.e., a 1:1 mapping.\n-         *\/\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            final Instruction i = ih.getInstruction();\n-            final Instruction c = i.copy(); \/\/ Use clone for shallow copy\n-            if (c instanceof BranchInstruction) {\n-                map.put(ih, il.append((BranchInstruction) c));\n-            } else {\n-                map.put(ih, il.append(c));\n-            }\n-        }\n-        \/*\n-         * Pass 2: Update branch targets.\n-         *\/\n-        InstructionHandle ih = start;\n-        InstructionHandle ch = il.start;\n-        while (ih != null) {\n-            final Instruction i = ih.getInstruction();\n-            final Instruction c = ch.getInstruction();\n-            if (i instanceof BranchInstruction) {\n-                final BranchInstruction bi = (BranchInstruction) i;\n-                final BranchInstruction bc = (BranchInstruction) c;\n-                final InstructionHandle itarget = bi.getTarget(); \/\/ old target\n-                \/\/ New target is in hash map\n-                bc.setTarget(map.get(itarget));\n-                if (bi instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n-                    final InstructionHandle[] itargets = ((Select) bi).getTargets();\n-                    final InstructionHandle[] ctargets = ((Select) bc).getTargets();\n-                    for (int j = 0; j < itargets.length; j++) { \/\/ Update all targets\n-                        ctargets[j] = map.get(itargets[j]);\n-                    }\n-                }\n-            }\n-            ih = ih.getNext();\n-            ch = ch.getNext();\n+    private void insert(final InstructionHandle ih) {\n+        if (isEmpty()) {\n+            start = end = ih;\n+            ih.setNext(ih.setPrev(null));\n+        } else {\n+            start.setPrev(ih);\n+            ih.setNext(start);\n+            ih.setPrev(null);\n+            start = ih;\n@@ -447,1 +495,1 @@\n-        return il;\n+        length++;\n@@ -451,1 +499,2 @@\n-     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n+     * Insert another list before Instruction i contained in this list. Consumes\n+     * argument list, i.e., it becomes empty.\n@@ -453,1 +502,5 @@\n-     * @param i instruction to remove\n+     * @param i\n+     *            where to append the instruction list\n+     * @param il\n+     *            Instruction list to insert\n+     * @return instruction handle pointing to the first inserted instruction, i.e., il.getStart()\n@@ -455,1 +508,1 @@\n-    public void delete(final Instruction i) throws TargetLostException {\n+    public InstructionHandle insert(final Instruction i, final InstructionList il) {\n@@ -460,145 +513,1 @@\n-        delete(ih);\n-    }\n-\n-    \/**\n-     * Remove instructions from instruction 'from' to instruction 'to' contained in this list. The user must ensure that\n-     * 'from' is an instruction before 'to', or risk havoc. The corresponding Instruction handles must not be reused!\n-     *\n-     * @param from where to start deleting (inclusive)\n-     * @param to where to end deleting (inclusive)\n-     *\/\n-    public void delete(final Instruction from, final Instruction to) throws TargetLostException {\n-        InstructionHandle fromIh;\n-        InstructionHandle toIh;\n-        if ((fromIh = findInstruction1(from)) == null) {\n-            throw new ClassGenException(\"Instruction \" + from + \" is not contained in this list.\");\n-        }\n-        if ((toIh = findInstruction2(to)) == null) {\n-            throw new ClassGenException(\"Instruction \" + to + \" is not contained in this list.\");\n-        }\n-        delete(fromIh, toIh);\n-    }\n-\n-    \/**\n-     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n-     *\n-     * @param ih instruction (handle) to remove\n-     *\/\n-    public void delete(final InstructionHandle ih) throws TargetLostException {\n-        remove(ih.getPrev(), ih.getNext());\n-    }\n-\n-    \/**\n-     * Remove instructions from instruction 'from' to instruction 'to' contained in this list. The user must ensure that\n-     * 'from' is an instruction before 'to', or risk havoc. The corresponding Instruction handles must not be reused!\n-     *\n-     * @param from where to start deleting (inclusive)\n-     * @param to where to end deleting (inclusive)\n-     *\/\n-    public void delete(final InstructionHandle from, final InstructionHandle to) throws TargetLostException {\n-        remove(from.getPrev(), to.getNext());\n-    }\n-\n-    \/**\n-     * Delete contents of list. Provides better memory utilization, because the system then may reuse the instruction\n-     * handles. This method is typically called right after {@link MethodGen#getMethod()}.\n-     *\/\n-    public void dispose() {\n-        \/\/ Traverse in reverse order, because ih.next is overwritten\n-        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n-            \/\/ Causes BranchInstructions to release target and targeters, because it calls dispose() on the contained instruction.\n-            ih.dispose();\n-        }\n-        clear();\n-    }\n-\n-    \/**\n-     * Get instruction handle for instruction at byte code position pos. This only works properly, if the list is freshly\n-     * initialized from a byte array or setPositions() has been called before this method.\n-     *\n-     * @param pos byte code position to search for\n-     * @return target position's instruction handle if available\n-     *\/\n-    public InstructionHandle findHandle(final int pos) {\n-        final int[] positions = bytePositions;\n-        InstructionHandle ih = start;\n-        for (int i = 0; i < length; i++) {\n-            if (positions[i] == pos) {\n-                return ih;\n-            }\n-            ih = ih.getNext();\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Search for given Instruction reference, start at beginning of list.\n-     *\n-     * @param i instruction to search for\n-     * @return instruction found on success, null otherwise\n-     *\/\n-    private InstructionHandle findInstruction1(final Instruction i) {\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            if (ih.getInstruction() == i) {\n-                return ih;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Search for given Instruction reference, start at end of list\n-     *\n-     * @param i instruction to search for\n-     * @return instruction found on success, null otherwise\n-     *\/\n-    private InstructionHandle findInstruction2(final Instruction i) {\n-        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n-            if (ih.getInstruction() == i) {\n-                return ih;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * When everything is finished, use this method to convert the instruction list into an array of bytes.\n-     *\n-     * @return the byte code ready to be dumped\n-     *\/\n-    public byte[] getByteCode() {\n-        \/\/ Update position indices of instructions\n-        setPositions();\n-        final ByteArrayOutputStream b = new ByteArrayOutputStream();\n-        final DataOutputStream out = new DataOutputStream(b);\n-        try {\n-            for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-                final Instruction i = ih.getInstruction();\n-                i.dump(out); \/\/ Traverse list\n-            }\n-            out.flush();\n-        } catch (final IOException e) {\n-            System.err.println(e);\n-            return Const.EMPTY_BYTE_ARRAY;\n-        }\n-        return b.toByteArray();\n-    }\n-\n-    \/**\n-     * @return end of list\n-     *\/\n-    public InstructionHandle getEnd() {\n-        return end;\n-    }\n-\n-    \/**\n-     * @return array containing all instructions (handles)\n-     *\/\n-    public InstructionHandle[] getInstructionHandles() {\n-        final InstructionHandle[] ihs = new InstructionHandle[length];\n-        InstructionHandle ih = start;\n-        for (int i = 0; i < length; i++) {\n-            ihs[i] = ih;\n-            ih = ih.getNext();\n-        }\n-        return ihs;\n+        return insert(ih, il);\n@@ -608,2 +517,1 @@\n-     * Get positions (offsets) of all instructions in the list. This relies on that the list has been freshly created from\n-     * an byte code array, or that setPositions() has been called. Otherwise this may be inaccurate.\n+     * Insert an instruction at start of this list.\n@@ -611,30 +519,3 @@\n-     * @return array containing all instruction's offset in byte code\n-     *\/\n-    public int[] getInstructionPositions() {\n-        return bytePositions;\n-    }\n-\n-    \/**\n-     * @return an array of instructions without target information for branch instructions.\n-     *\/\n-    public Instruction[] getInstructions() {\n-        final List<Instruction> instructions = new ArrayList<>();\n-        try (ByteSequence bytes = new ByteSequence(getByteCode())) {\n-            while (bytes.available() > 0) {\n-                instructions.add(Instruction.readInstruction(bytes));\n-            }\n-        } catch (final IOException e) {\n-            throw new ClassGenException(e.toString(), e);\n-        }\n-        return instructions.toArray(Instruction.EMPTY_ARRAY);\n-    }\n-\n-    \/**\n-     * @return length of list (Number of instructions, not bytes)\n-     *\/\n-    public int getLength() {\n-        return length;\n-    }\n-\n-    \/**\n-     * @return start of list\n+     * @param i\n+     *            instruction to insert\n+     * @return instruction handle of the inserted instruction\n@@ -642,2 +523,4 @@\n-    public InstructionHandle getStart() {\n-        return start;\n+    public InstructionHandle insert(final Instruction i) {\n+        final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);\n+        insert(ih);\n+        return ih;\n@@ -649,1 +532,2 @@\n-     * @param i branch instruction to insert\n+     * @param i\n+     *            branch instruction to insert\n@@ -659,1 +543,2 @@\n-     * Insert a compound instruction.\n+     * Insert a single instruction j before another instruction i, which must be\n+     * in this list of course!\n@@ -661,1 +546,4 @@\n-     * @param c The composite instruction (containing an InstructionList)\n+     * @param i\n+     *            Instruction in list\n+     * @param j\n+     *            Instruction to insert before i in list\n@@ -664,14 +552,2 @@\n-    public InstructionHandle insert(final CompoundInstruction c) {\n-        return insert(c.getInstructionList());\n-    }\n-\n-    \/**\n-     * Insert an instruction at start of this list.\n-     *\n-     * @param i instruction to insert\n-     * @return instruction handle of the inserted instruction\n-     *\/\n-    public InstructionHandle insert(final Instruction i) {\n-        final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);\n-        insert(ih);\n-        return ih;\n+    public InstructionHandle insert(final Instruction i, final Instruction j) {\n+        return insert(i, new InstructionList(j));\n@@ -683,2 +559,4 @@\n-     * @param i Instruction in list\n-     * @param c The composite instruction (containing an InstructionList)\n+     * @param i\n+     *            Instruction in list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n@@ -692,1 +570,1 @@\n-     * Insert a single instruction j before another instruction i, which must be in this list of course!\n+     * Insert a compound instruction.\n@@ -694,2 +572,2 @@\n-     * @param i Instruction in list\n-     * @param j Instruction to insert before i in list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n@@ -698,35 +576,2 @@\n-    public InstructionHandle insert(final Instruction i, final Instruction j) {\n-        return insert(i, new InstructionList(j));\n-    }\n-\n-    \/**\n-     * Insert another list before Instruction i contained in this list. Consumes argument list, i.e., it becomes empty.\n-     *\n-     * @param i where to append the instruction list\n-     * @param il Instruction list to insert\n-     * @return instruction handle pointing to the first inserted instruction, i.e., il.getStart()\n-     *\/\n-    public InstructionHandle insert(final Instruction i, final InstructionList il) {\n-        InstructionHandle ih;\n-        if ((ih = findInstruction1(i)) == null) {\n-            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n-        }\n-        return insert(ih, il);\n-    }\n-\n-    \/**\n-     * Insert an instruction at start of this list.\n-     *\n-     * @param ih instruction to insert\n-     *\/\n-    private void insert(final InstructionHandle ih) {\n-        if (isEmpty()) {\n-            start = end = ih;\n-            ih.setNext(ih.setPrev(null));\n-        } else {\n-            start.setPrev(ih);\n-            ih.setNext(start);\n-            ih.setPrev(null);\n-            start = ih;\n-        }\n-        length++;\n+    public InstructionHandle insert(final CompoundInstruction c) {\n+        return insert(c.getInstructionList());\n@@ -738,2 +583,4 @@\n-     * @param ih where to insert to the instruction list\n-     * @param i Instruction to insert\n+     * @param ih\n+     *            where to insert to the instruction list\n+     * @param i\n+     *            Instruction to insert\n@@ -742,6 +589,2 @@\n-    public BranchHandle insert(final InstructionHandle ih, final BranchInstruction i) {\n-        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n-        final InstructionList il = new InstructionList();\n-        il.append(bh);\n-        insert(ih, il);\n-        return bh;\n+    public InstructionHandle insert(final InstructionHandle ih, final Instruction i) {\n+        return insert(ih, new InstructionList(i));\n@@ -753,2 +596,4 @@\n-     * @param ih where to insert the instruction list\n-     * @param c The composite instruction (containing an InstructionList)\n+     * @param ih\n+     *            where to insert the instruction list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n@@ -764,42 +609,4 @@\n-     * @param ih where to insert to the instruction list\n-     * @param i Instruction to insert\n-     * @return instruction handle of the first inserted instruction\n-     *\/\n-    public InstructionHandle insert(final InstructionHandle ih, final Instruction i) {\n-        return insert(ih, new InstructionList(i));\n-    }\n-\n-    \/**\n-     * Insert another list before Instruction handle ih contained in this list. Consumes argument list, i.e., it becomes\n-     * empty.\n-     *\n-     * @param ih where to append the instruction list\n-     * @param il Instruction list to insert\n-     * @return instruction handle of the first inserted instruction\n-     *\/\n-    public InstructionHandle insert(final InstructionHandle ih, final InstructionList il) {\n-        if (il == null) {\n-            throw new ClassGenException(\"Inserting null InstructionList\");\n-        }\n-        if (il.isEmpty()) {\n-            return ih;\n-        }\n-        final InstructionHandle prev = ih.getPrev();\n-        final InstructionHandle ret = il.start;\n-        ih.setPrev(il.end);\n-        il.end.setNext(ih);\n-        il.start.setPrev(prev);\n-        if (prev != null) {\n-            prev.setNext(il.start);\n-        } else {\n-            start = il.start; \/\/ Update start ...\n-        }\n-        length += il.length; \/\/ Update length\n-        il.clear();\n-        return ret;\n-    }\n-\n-    \/**\n-     * Insert another list.\n-     *\n-     * @param il list to insert before start of this list\n+     * @param ih\n+     *            where to insert to the instruction list\n+     * @param i\n+     *            Instruction to insert\n@@ -808,54 +615,6 @@\n-    public InstructionHandle insert(final InstructionList il) {\n-        if (isEmpty()) {\n-            append(il); \/\/ Code is identical for this case\n-            return start;\n-        }\n-        return insert(start, il);\n-    }\n-\n-    \/**\n-     * Test for empty list.\n-     *\/\n-    public boolean isEmpty() {\n-        return start == null;\n-    } \/\/ && end == null\n-\n-    \/**\n-     * @return iterator that lists all instructions (handles)\n-     *\/\n-    @Override\n-    public Iterator<InstructionHandle> iterator() {\n-        return new Iterator<InstructionHandle>() {\n-\n-            private InstructionHandle ih = start;\n-\n-            @Override\n-            public boolean hasNext() {\n-                return ih != null;\n-            }\n-\n-            @Override\n-            public InstructionHandle next() throws NoSuchElementException {\n-                if (ih == null) {\n-                    throw new NoSuchElementException();\n-                }\n-                final InstructionHandle i = ih;\n-                ih = ih.getNext();\n-                return i;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-    }\n-\n-    \/**\n-     * Move a single instruction (handle) to a new location.\n-     *\n-     * @param ih moved instruction\n-     * @param target new location of moved instruction\n-     *\/\n-    public void move(final InstructionHandle ih, final InstructionHandle target) {\n-        move(ih, ih, target);\n+    public BranchHandle insert(final InstructionHandle ih, final BranchInstruction i) {\n+        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n+        final InstructionList il = new InstructionList();\n+        il.append(bh);\n+        insert(ih, il);\n+        return bh;\n@@ -865,3 +624,4 @@\n-     * Take all instructions (handles) from \"start\" to \"end\" and append them after the new location \"target\". Of course,\n-     * \"end\" must be after \"start\" and target must not be located withing this range. If you want to move something to the\n-     * start of the list use null as value for target.\n+     * Take all instructions (handles) from \"start\" to \"end\" and append them\n+     * after the new location \"target\". Of course, \"end\" must be after \"start\"\n+     * and target must not be located within this range. If you want to move\n+     * something to the start of the list use null as value for target.\n@@ -869,2 +629,2 @@\n-     * Any instruction targeters pointing to handles within the block, keep their targets.\n-     * <\/p>\n+     * Any instruction targeters pointing to handles within the block, keep\n+     * their targets.\n@@ -872,3 +632,6 @@\n-     * @param start of moved block\n-     * @param end of moved block\n-     * @param target of moved block\n+     * @param start\n+     *            of moved block\n+     * @param end\n+     *            of moved block\n+     * @param target\n+     *            of moved block\n@@ -878,1 +641,1 @@\n-        if (start == null || end == null) {\n+        if ((start == null) || (end == null)) {\n@@ -881,1 +644,1 @@\n-        if (target == start || target == end) {\n+        if ((target == start) || (target == end)) {\n@@ -887,2 +650,1 @@\n-            }\n-            if (ih == target) {\n+            } else if (ih == target) {\n@@ -927,50 +689,1 @@\n-     * Redirect all references from oldTarget to newTarget, i.e., update targets of branch instructions.\n-     *\n-     * @param oldTarget the old target instruction handle\n-     * @param newTarget the new target instruction handle\n-     *\/\n-    public void redirectBranches(final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            final Instruction i = ih.getInstruction();\n-            if (i instanceof BranchInstruction) {\n-                final BranchInstruction b = (BranchInstruction) i;\n-                final InstructionHandle target = b.getTarget();\n-                if (target == oldTarget) {\n-                    b.setTarget(newTarget);\n-                }\n-                if (b instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n-                    final InstructionHandle[] targets = ((Select) b).getTargets();\n-                    for (int j = 0; j < targets.length; j++) {\n-                        if (targets[j] == oldTarget) {\n-                            ((Select) b).setTarget(j, newTarget);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Redirect all references of exception handlers from oldTarget to newTarget.\n-     *\n-     * @param exceptions array of exception handlers\n-     * @param oldTarget the old target instruction handle\n-     * @param newTarget the new target instruction handle\n-     * @see MethodGen\n-     *\/\n-    public void redirectExceptionHandlers(final CodeExceptionGen[] exceptions, final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n-        for (final CodeExceptionGen exception : exceptions) {\n-            if (exception.getStartPC() == oldTarget) {\n-                exception.setStartPC(newTarget);\n-            }\n-            if (exception.getEndPC() == oldTarget) {\n-                exception.setEndPC(newTarget);\n-            }\n-            if (exception.getHandlerPC() == oldTarget) {\n-                exception.setHandlerPC(newTarget);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Redirect all references of local variables from oldTarget to newTarget.\n+     * Move a single instruction (handle) to a new location.\n@@ -978,4 +691,4 @@\n-     * @param lg array of local variables\n-     * @param oldTarget the old target instruction handle\n-     * @param newTarget the new target instruction handle\n-     * @see MethodGen\n+     * @param ih\n+     *            moved instruction\n+     * @param target\n+     *            new location of moved instruction\n@@ -983,11 +696,2 @@\n-    public void redirectLocalVariables(final LocalVariableGen[] lg, final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n-        for (final LocalVariableGen element : lg) {\n-            final InstructionHandle start = element.getStart();\n-            final InstructionHandle end = element.getEnd();\n-            if (start == oldTarget) {\n-                element.setStart(newTarget);\n-            }\n-            if (end == oldTarget) {\n-                element.setEnd(newTarget);\n-            }\n-        }\n+    public void move(final InstructionHandle ih, final InstructionHandle target) {\n+        move(ih, ih, target);\n@@ -997,2 +701,3 @@\n-     * Remove from instruction 'prev' to instruction 'next' both contained in this list. Throws TargetLostException when one\n-     * of the removed instruction handles is still being targeted.\n+     * Remove from instruction `prev' to instruction `next' both contained in\n+     * this list. Throws TargetLostException when one of the removed instruction\n+     * handles is still being targeted.\n@@ -1000,2 +705,4 @@\n-     * @param prev where to start deleting (predecessor, exclusive)\n-     * @param next where to end deleting (successor, exclusive)\n+     * @param prev\n+     *            where to start deleting (predecessor, exclusive)\n+     * @param next\n+     *            where to end deleting (successor, exclusive)\n@@ -1006,1 +713,1 @@\n-        if (prev == null && next == null) {\n+        if ((prev == null) && (next == null)) {\n@@ -1028,1 +735,1 @@\n-        final List<InstructionHandle> targetList = new ArrayList<>();\n+        final List<InstructionHandle> target_vec = new ArrayList<>();\n@@ -1037,1 +744,1 @@\n-                targetList.add(ih);\n+                target_vec.add(ih);\n@@ -1045,2 +752,4 @@\n-        if (!targetList.isEmpty()) {\n-            throw new TargetLostException(targetList.toArray(InstructionHandle.EMPTY_ARRAY), buf.toString());\n+        if (!target_vec.isEmpty()) {\n+            final InstructionHandle[] targeted = new InstructionHandle[target_vec.size()];\n+            target_vec.toArray(targeted);\n+            throw new TargetLostException(targeted, buf.toString());\n@@ -1051,1 +760,5 @@\n-     * Remove observer for this object.\n+     * Remove instruction from this list. The corresponding Instruction handles\n+     * must not be reused!\n+     *\n+     * @param ih\n+     *            instruction (handle) to remove\n@@ -1053,3 +766,66 @@\n-    public void removeObserver(final InstructionListObserver o) {\n-        if (observers != null) {\n-            observers.remove(o);\n+    public void delete(final InstructionHandle ih) throws TargetLostException {\n+        remove(ih.getPrev(), ih.getNext());\n+    }\n+\n+    \/**\n+     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n+     *\n+     * @param i\n+     *            instruction to remove\n+     *\/\n+    public void delete(final Instruction i) throws TargetLostException {\n+        InstructionHandle ih;\n+        if ((ih = findInstruction1(i)) == null) {\n+            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n+        }\n+        delete(ih);\n+    }\n+\n+    \/**\n+     * Remove instructions from instruction `from' to instruction `to' contained\n+     * in this list. The user must ensure that `from' is an instruction before\n+     * `to', or risk havoc. The corresponding Instruction handles must not be\n+     * reused!\n+     *\n+     * @param from\n+     *            where to start deleting (inclusive)\n+     * @param to\n+     *            where to end deleting (inclusive)\n+     *\/\n+    public void delete(final InstructionHandle from, final InstructionHandle to) throws TargetLostException {\n+        remove(from.getPrev(), to.getNext());\n+    }\n+\n+    \/**\n+     * Remove instructions from instruction `from' to instruction `to' contained in this list. The user must ensure that `from' is an instruction before `to',\n+     * or risk havoc. The corresponding Instruction handles must not be reused!\n+     *\n+     * @param from\n+     *            where to start deleting (inclusive)\n+     * @param to\n+     *            where to end deleting (inclusive)\n+     *\/\n+    public void delete(final Instruction from, final Instruction to) throws TargetLostException {\n+        InstructionHandle from_ih;\n+        InstructionHandle to_ih;\n+        if ((from_ih = findInstruction1(from)) == null) {\n+            throw new ClassGenException(\"Instruction \" + from + \" is not contained in this list.\");\n+        }\n+        if ((to_ih = findInstruction2(to)) == null) {\n+            throw new ClassGenException(\"Instruction \" + to + \" is not contained in this list.\");\n+        }\n+        delete(from_ih, to_ih);\n+    }\n+\n+    \/**\n+     * Search for given Instruction reference, start at beginning of list.\n+     *\n+     * @param i\n+     *            instruction to search for\n+     * @return instruction found on success, null otherwise\n+     *\/\n+    private InstructionHandle findInstruction1(final Instruction i) {\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            if (ih.getInstruction() == i) {\n+                return ih;\n+            }\n@@ -1057,0 +833,1 @@\n+        return null;\n@@ -1060,1 +837,5 @@\n-     * Replace all references to the old constant pool with references to the new constant pool\n+     * Search for given Instruction reference, start at end of list\n+     *\n+     * @param i\n+     *            instruction to search for\n+     * @return instruction found on success, null otherwise\n@@ -1062,1 +843,13 @@\n-    public void replaceConstantPool(final ConstantPoolGen oldCp, final ConstantPoolGen newCp) {\n+    private InstructionHandle findInstruction2(final Instruction i) {\n+        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n+            if (ih.getInstruction() == i) {\n+                return ih;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public boolean contains(final InstructionHandle i) {\n+        if (i == null) {\n+            return false;\n+        }\n@@ -1064,5 +857,2 @@\n-            final Instruction i = ih.getInstruction();\n-            if (i instanceof CPInstruction) {\n-                final CPInstruction ci = (CPInstruction) i;\n-                final Constant c = oldCp.getConstant(ci.getIndex());\n-                ci.setIndex(newCp.addConstant(c, oldCp));\n+            if (ih == i) {\n+                return true;\n@@ -1071,0 +861,5 @@\n+        return false;\n+    }\n+\n+    public boolean contains(final Instruction i) {\n+        return findInstruction1(i) != null;\n@@ -1078,1 +873,2 @@\n-     * Give all instructions their position number (offset in byte stream), i.e., make the list ready to be dumped.\n+     * Give all instructions their position number (offset in byte stream),\n+     * i.e., make the list ready to be dumped.\n@@ -1080,1 +876,2 @@\n-     * @param check Perform sanity checks, e.g. if all targeted instructions really belong to this list\n+     * @param check\n+     *            Perform sanity checks, e.g. if all targeted instructions really belong to this list\n@@ -1083,2 +880,2 @@\n-        int maxAdditionalBytes = 0;\n-        int additionalBytes = 0;\n+        int max_additional_bytes = 0;\n+        int additional_bytes = 0;\n@@ -1097,1 +894,3 @@\n-                        throw new ClassGenException(\"Branch target of \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not in instruction list\");\n+                        throw new ClassGenException(\"Branch target of \"\n+                                + Const.getOpcodeName(i.getOpcode()) + \":\"\n+                                + inst + \" not in instruction list\");\n@@ -1104,1 +903,3 @@\n-                                throw new ClassGenException(\"Branch target of \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not in instruction list\");\n+                                throw new ClassGenException(\"Branch target of \"\n+                                        + Const.getOpcodeName(i.getOpcode()) + \":\"\n+                                        + inst + \" not in instruction list\");\n@@ -1110,1 +911,3 @@\n-                            \"Branch instruction \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not contained in BranchHandle.\");\n+                                \"Branch instruction \"\n+                                + Const.getOpcodeName(i.getOpcode()) + \":\"\n+                                + inst + \" not contained in BranchHandle.\");\n@@ -1123,2 +926,3 @@\n-             * Get an estimate about how many additional bytes may be added, because BranchInstructions may have variable length\n-             * depending on the target offset (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).\n+             * Get an estimate about how many additional bytes may be added,\n+             * because BranchInstructions may have variable length depending on the target offset\n+             * (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).\n@@ -1127,3 +931,3 @@\n-            case Const.JSR:\n-            case Const.GOTO:\n-                maxAdditionalBytes += 2;\n+                case Const.JSR:\n+                case Const.GOTO:\n+                    max_additional_bytes += 2;\n@@ -1131,3 +935,3 @@\n-            case Const.TABLESWITCH:\n-            case Const.LOOKUPSWITCH:\n-                maxAdditionalBytes += 3;\n+                case Const.TABLESWITCH:\n+                case Const.LOOKUPSWITCH:\n+                    max_additional_bytes += 3;\n@@ -1138,3 +942,4 @@\n-        \/*\n-         * Pass 2: Expand the variable-length (Branch)Instructions depending on the target offset (short or int) and ensure that\n-         * branch targets are within this list.\n+\n+        \/* Pass 2: Expand the variable-length (Branch)Instructions depending on\n+         * the target offset (short or int) and ensure that branch targets are\n+         * within this list.\n@@ -1143,1 +948,1 @@\n-            additionalBytes += ih.updatePosition(additionalBytes, maxAdditionalBytes);\n+            additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);\n@@ -1146,1 +951,2 @@\n-         * Pass 3: Update position numbers (which may have changed due to the preceding expansions), like pass 1.\n+         * Pass 3: Update position numbers (which may have changed due to the\n+         * preceding expansions), like pass 1.\n@@ -1160,1 +966,4 @@\n-     * @return length of list (Number of instructions, not bytes)\n+     * When everything is finished, use this method to convert the instruction\n+     * list into an array of bytes.\n+     *\n+     * @return the byte code ready to be dumped\n@@ -1162,2 +971,32 @@\n-    public int size() {\n-        return length;\n+    public byte[] getByteCode() {\n+        \/\/ Update position indices of instructions\n+        setPositions();\n+        final ByteArrayOutputStream b = new ByteArrayOutputStream();\n+        final DataOutputStream out = new DataOutputStream(b);\n+        try {\n+            for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+                final Instruction i = ih.getInstruction();\n+                i.dump(out); \/\/ Traverse list\n+            }\n+            out.flush();\n+        } catch (final IOException e) {\n+            System.err.println(e);\n+            return new byte[0];\n+        }\n+        return b.toByteArray();\n+    }\n+\n+    \/**\n+     * @return an array of instructions without target information for branch\n+     * instructions.\n+     *\/\n+    public Instruction[] getInstructions() {\n+        final List<Instruction> instructions = new ArrayList<>();\n+        try (ByteSequence bytes = new ByteSequence(getByteCode())) {\n+            while (bytes.available() > 0) {\n+                instructions.add(Instruction.readInstruction(bytes));\n+            }\n+        } catch (final IOException e) {\n+            throw new ClassGenException(e.toString(), e);\n+        }\n+        return instructions.toArray(new Instruction[instructions.size()]);\n@@ -1172,1 +1011,2 @@\n-     * @param verbose toggle output format\n+     * @param verbose\n+     *            toggle output format\n@@ -1184,2 +1024,271 @@\n-     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n-     * has to be called by the user after he has finished editing the object.\n+     * @return iterator that lists all instructions (handles)\n+     *\/\n+    @Override\n+    public Iterator<InstructionHandle> iterator() {\n+        return new Iterator<InstructionHandle>() {\n+\n+            private InstructionHandle ih = start;\n+\n+            @Override\n+            public InstructionHandle next() throws NoSuchElementException {\n+                if (ih == null) {\n+                    throw new NoSuchElementException();\n+                }\n+                final InstructionHandle i = ih;\n+                ih = ih.getNext();\n+                return i;\n+            }\n+\n+            @Override\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return ih != null;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * @return array containing all instructions (handles)\n+     *\/\n+    public InstructionHandle[] getInstructionHandles() {\n+        final InstructionHandle[] ihs = new InstructionHandle[length];\n+        InstructionHandle ih = start;\n+        for (int i = 0; i < length; i++) {\n+            ihs[i] = ih;\n+            ih = ih.getNext();\n+        }\n+        return ihs;\n+    }\n+\n+    \/**\n+     * Get positions (offsets) of all instructions in the list. This relies on\n+     * that the list has been freshly created from an byte code array, or that\n+     * setPositions() has been called. Otherwise this may be inaccurate.\n+     *\n+     * @return array containing all instruction's offset in byte code\n+     *\/\n+    public int[] getInstructionPositions() {\n+        return bytePositions;\n+    }\n+\n+    \/**\n+     * @return complete, i.e., deep copy of this list\n+     *\/\n+    public InstructionList copy() {\n+        final Map<InstructionHandle, InstructionHandle> map = new HashMap<>();\n+        final InstructionList il = new InstructionList();\n+        \/*\n+         * Pass 1: Make copies of all instructions, append them to the new list\n+         * and associate old instruction references with the new ones, i.e., a 1:1 mapping.\n+         *\/\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            final Instruction i = ih.getInstruction();\n+            final Instruction c = i.copy(); \/\/ Use clone for shallow copy\n+            if (c instanceof BranchInstruction) {\n+                map.put(ih, il.append((BranchInstruction) c));\n+            } else {\n+                map.put(ih, il.append(c));\n+            }\n+        }\n+        \/*\n+         * Pass 2: Update branch targets.\n+         *\/\n+        InstructionHandle ih = start;\n+        InstructionHandle ch = il.start;\n+        while (ih != null) {\n+            final Instruction i = ih.getInstruction();\n+            final Instruction c = ch.getInstruction();\n+            if (i instanceof BranchInstruction) {\n+                final BranchInstruction bi = (BranchInstruction) i;\n+                final BranchInstruction bc = (BranchInstruction) c;\n+                final InstructionHandle itarget = bi.getTarget(); \/\/ old target\n+                \/\/ New target is in hash map\n+                bc.setTarget(map.get(itarget));\n+                if (bi instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n+                    final InstructionHandle[] itargets = ((Select) bi).getTargets();\n+                    final InstructionHandle[] ctargets = ((Select) bc).getTargets();\n+                    for (int j = 0; j < itargets.length; j++) { \/\/ Update all targets\n+                        ctargets[j] = map.get(itargets[j]);\n+                    }\n+                }\n+            }\n+            ih = ih.getNext();\n+            ch = ch.getNext();\n+        }\n+        return il;\n+    }\n+\n+    \/**\n+     * Replace all references to the old constant pool with references to the\n+     * new constant pool\n+     *\/\n+    public void replaceConstantPool(final ConstantPoolGen old_cp, final ConstantPoolGen new_cp) {\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            final Instruction i = ih.getInstruction();\n+            if (i instanceof CPInstruction) {\n+                final CPInstruction ci = (CPInstruction) i;\n+                final Constant c = old_cp.getConstant(ci.getIndex());\n+                ci.setIndex(new_cp.addConstant(c, old_cp));\n+            }\n+        }\n+    }\n+\n+    private void clear() {\n+        start = end = null;\n+        length = 0;\n+    }\n+\n+    \/**\n+     * Delete contents of list. Provides better memory utilization, because the\n+     * system then may reuse the instruction handles. This method is typically\n+     * called right after {@link MethodGen#getMethod()}.\n+     *\/\n+    public void dispose() {\n+        \/\/ Traverse in reverse order, because ih.next is overwritten\n+        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n+            \/*\n+             * Causes BranchInstructions to release target and targeters,\n+             * because it calls dispose() on the contained instruction.\n+             *\/\n+            ih.dispose();\n+        }\n+        clear();\n+    }\n+\n+    \/**\n+     * @return start of list\n+     *\/\n+    public InstructionHandle getStart() {\n+        return start;\n+    }\n+\n+    \/**\n+     * @return end of list\n+     *\/\n+    public InstructionHandle getEnd() {\n+        return end;\n+    }\n+\n+    \/**\n+     * @return length of list (Number of instructions, not bytes)\n+     *\/\n+    public int getLength() {\n+        return length;\n+    }\n+\n+    \/**\n+     * @return length of list (Number of instructions, not bytes)\n+     *\/\n+    public int size() {\n+        return length;\n+    }\n+\n+    \/**\n+     * Redirect all references from old_target to new_target, i.e., update\n+     * targets of branch instructions.\n+     *\n+     * @param old_target\n+     *            the old target instruction handle\n+     * @param new_target\n+     *            the new target instruction handle\n+     *\/\n+    public void redirectBranches(final InstructionHandle old_target, final InstructionHandle new_target) {\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            final Instruction i = ih.getInstruction();\n+            if (i instanceof BranchInstruction) {\n+                final BranchInstruction b = (BranchInstruction) i;\n+                final InstructionHandle target = b.getTarget();\n+                if (target == old_target) {\n+                    b.setTarget(new_target);\n+                }\n+                if (b instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n+                    final InstructionHandle[] targets = ((Select) b).getTargets();\n+                    for (int j = 0; j < targets.length; j++) {\n+                        if (targets[j] == old_target) {\n+                            ((Select) b).setTarget(j, new_target);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Redirect all references of local variables from old_target to new_target.\n+     *\n+     * @param lg\n+     *            array of local variables\n+     * @param old_target\n+     *            the old target instruction handle\n+     * @param new_target\n+     *            the new target instruction handle\n+     * @see MethodGen\n+     *\/\n+    public void redirectLocalVariables(final LocalVariableGen[] lg, final InstructionHandle old_target, final InstructionHandle new_target) {\n+        for (final LocalVariableGen element : lg) {\n+            final InstructionHandle start = element.getStart();\n+            final InstructionHandle end = element.getEnd();\n+            if (start == old_target) {\n+                element.setStart(new_target);\n+            }\n+            if (end == old_target) {\n+                element.setEnd(new_target);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Redirect all references of exception handlers from old_target to new_target.\n+     *\n+     * @param exceptions\n+     *            array of exception handlers\n+     * @param old_target\n+     *            the old target instruction handle\n+     * @param new_target\n+     *            the new target instruction handle\n+     * @see MethodGen\n+     *\/\n+    public void redirectExceptionHandlers(final CodeExceptionGen[] exceptions,\n+            final InstructionHandle old_target, final InstructionHandle new_target) {\n+        for (final CodeExceptionGen exception : exceptions) {\n+            if (exception.getStartPC() == old_target) {\n+                exception.setStartPC(new_target);\n+            }\n+            if (exception.getEndPC() == old_target) {\n+                exception.setEndPC(new_target);\n+            }\n+            if (exception.getHandlerPC() == old_target) {\n+                exception.setHandlerPC(new_target);\n+            }\n+        }\n+    }\n+\n+    private List<InstructionListObserver> observers;\n+\n+    \/**\n+     * Add observer for this object.\n+     *\/\n+    public void addObserver(final InstructionListObserver o) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n+        }\n+        observers.add(o);\n+    }\n+\n+    \/**\n+     * Remove observer for this object.\n+     *\/\n+    public void removeObserver(final InstructionListObserver o) {\n+        if (observers != null) {\n+            observers.remove(o);\n+        }\n+    }\n+\n+    \/**\n+     * Call notify() method on all observers. This method is not called\n+     * automatically whenever the state has changed, but has to be called by the\n+     * user after he has finished editing the object.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionList.java","additions":793,"deletions":684,"binary":false,"changes":1477,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Implement this interface if you're interested in changes to an InstructionList object and register yourself with\n- * addObserver().\n+ * Implement this interface if you're interested in changes to an InstructionList object\n+ * and register yourself with addObserver().\n+ *\n@@ -30,1 +31,1 @@\n-    void notify(InstructionList list);\n+    void notify( InstructionList list );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionListObserver.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * Denote that a class targets InstructionHandles within an InstructionList. Namely the following implementers:\n+ * Denote that a class targets InstructionHandles within an InstructionList. Namely\n+ * the following implementers:\n@@ -33,2 +34,0 @@\n-    \/\/ static final InstructionTargeter[] EMPTY_ARRAY = new InstructionTargeter[0];\n-\n@@ -43,3 +42,3 @@\n-     * @param oldIh the old handle\n-     * @param newIh the new handle\n-     * @throws ClassGenException if oldIh is not targeted by this object\n+     * @param old_ih the old handle\n+     * @param new_ih the new handle\n+     * @throws ClassGenException if old_ih is not targeted by this object\n@@ -47,1 +46,1 @@\n-    void updateTarget(InstructionHandle oldIh, InstructionHandle newIh) throws ClassGenException;\n+    void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih) throws ClassGenException;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionTargeter.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -34,1 +33,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -36,1 +35,2 @@\n-public abstract class InvokeInstruction extends FieldOrMethod implements ExceptionThrower, StackConsumer, StackProducer {\n+public abstract class InvokeInstruction extends FieldOrMethod implements ExceptionThrower,\n+        StackConsumer, StackProducer {\n@@ -39,1 +39,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -44,0 +45,1 @@\n+\n@@ -51,0 +53,1 @@\n+\n@@ -52,2 +55,25 @@\n-     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n-     *\n+     * @return mnemonic for instruction with symbolic references resolved\n+     *\/\n+    @Override\n+    public String toString( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(super.getIndex());\n+        final StringTokenizer tok = new StringTokenizer(cp.constantToString(c));\n+\n+        final String opcodeName = Const.getOpcodeName(super.getOpcode());\n+\n+        final StringBuilder sb = new StringBuilder(opcodeName);\n+        if (tok.hasMoreTokens()) {\n+            sb.append(\" \");\n+            sb.append(tok.nextToken().replace('.', '\/'));\n+            if (tok.hasMoreTokens()) {\n+                sb.append(tok.nextToken());\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+\n+    \/**\n+     * Also works for instructions whose stack effect depends on the\n+     * constant pool entry they reference.\n@@ -57,1 +83,1 @@\n-    public int consumeStack(final ConstantPoolGen cpg) {\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n@@ -59,1 +85,1 @@\n-        if (super.getOpcode() == Const.INVOKESTATIC || super.getOpcode() == Const.INVOKEDYNAMIC) {\n+        if ((super.getOpcode() == Const.INVOKESTATIC) || (super.getOpcode() == Const.INVOKEDYNAMIC)) {\n@@ -70,0 +96,1 @@\n+\n@@ -71,1 +98,3 @@\n-     * @return argument types of referenced method.\n+     * Also works for instructions whose stack effect depends on the\n+     * constant pool entry they reference.\n+     * @return Number of words produced onto stack by this instruction\n@@ -73,2 +102,4 @@\n-    public Type[] getArgumentTypes(final ConstantPoolGen cpg) {\n-        return Type.getArgumentTypes(getSignature(cpg));\n+    @Override\n+    public int produceStack( final ConstantPoolGen cpg ) {\n+        final String signature = getSignature(cpg);\n+        return Type.getReturnTypeSize(signature);\n@@ -78,1 +109,4 @@\n-     * This overrides the deprecated version as we know here that the referenced class may legally be an array.\n+     * This overrides the deprecated version as we know here that the referenced class\n+     * may legally be an array.\n+     *\n+     * @deprecated in FieldOrMethod\n@@ -89,8 +123,1 @@\n-        return Utility.pathToPackage(className);\n-    }\n-\n-    \/**\n-     * @return name of referenced method.\n-     *\/\n-    public String getMethodName(final ConstantPoolGen cpg) {\n-        return getName(cpg);\n+        return className.replace('\/', '.');\n@@ -99,9 +126,1 @@\n-    \/**\n-     * @return return type of referenced method.\n-     *\/\n-    public Type getReturnType(final ConstantPoolGen cpg) {\n-        return Type.getReturnType(getSignature(cpg));\n-    }\n-\n-    \/**\n-     * @return return type of referenced method.\n+    \/** @return return type of referenced method.\n@@ -110,1 +129,1 @@\n-    public Type getType(final ConstantPoolGen cpg) {\n+    public Type getType( final ConstantPoolGen cpg ) {\n@@ -114,4 +133,2 @@\n-    \/**\n-     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n-     *\n-     * @return Number of words produced onto stack by this instruction\n+\n+    \/** @return name of referenced method.\n@@ -119,4 +136,2 @@\n-    @Override\n-    public int produceStack(final ConstantPoolGen cpg) {\n-        final String signature = getSignature(cpg);\n-        return Type.getReturnTypeSize(signature);\n+    public String getMethodName( final ConstantPoolGen cpg ) {\n+        return getName(cpg);\n@@ -125,7 +140,0 @@\n-    \/**\n-     * @return mnemonic for instruction with symbolic references resolved\n-     *\/\n-    @Override\n-    public String toString(final ConstantPool cp) {\n-        final Constant c = cp.getConstant(super.getIndex());\n-        final StringTokenizer tok = new StringTokenizer(cp.constantToString(c));\n@@ -133,1 +141,5 @@\n-        final String opcodeName = Const.getOpcodeName(super.getOpcode());\n+    \/** @return return type of referenced method.\n+     *\/\n+    public Type getReturnType( final ConstantPoolGen cpg ) {\n+        return Type.getReturnType(getSignature(cpg));\n+    }\n@@ -135,8 +147,0 @@\n-        final StringBuilder sb = new StringBuilder(opcodeName);\n-        if (tok.hasMoreTokens()) {\n-            sb.append(\" \");\n-            sb.append(Utility.packageToPath(tok.nextToken()));\n-            if (tok.hasMoreTokens()) {\n-                sb.append(tok.nextToken());\n-            }\n-        }\n@@ -144,1 +148,4 @@\n-        return sb.toString();\n+    \/** @return argument types of referenced method.\n+     *\/\n+    public Type[] getArgumentTypes( final ConstantPoolGen cpg ) {\n+        return Type.getArgumentTypes(getSignature(cpg));\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InvokeInstruction.java","additions":63,"deletions":56,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *\n@@ -33,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -38,0 +40,1 @@\n+\n@@ -42,14 +45,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackProducer(this);\n-        v.visitVariableLengthInstruction(this);\n-        v.visitBranchInstruction(this);\n-        v.visitJsrInstruction(this);\n-        v.visitJSR(this);\n-    }\n@@ -59,1 +48,0 @@\n-     *\n@@ -63,1 +51,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -74,0 +62,1 @@\n+\n@@ -75,1 +64,1 @@\n-    protected int updatePosition(final int offset, final int maxOffset) {\n+    protected int updatePosition( final int offset, final int max_offset ) {\n@@ -78,1 +67,1 @@\n-        if (Math.abs(i) >= Short.MAX_VALUE - maxOffset) { \/\/ to large for short (estimate)\n+        if (Math.abs(i) >= (Short.MAX_VALUE - max_offset)) { \/\/ to large for short (estimate)\n@@ -80,1 +69,1 @@\n-            final short oldLength = (short) super.getLength();\n+            final short old_length = (short) super.getLength();\n@@ -82,1 +71,1 @@\n-            return super.getLength() - oldLength;\n+            return super.getLength() - old_length;\n@@ -86,0 +75,18 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackProducer(this);\n+        v.visitVariableLengthInstruction(this);\n+        v.visitBranchInstruction(this);\n+        v.visitJsrInstruction(this);\n+        v.visitJSR(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JSR.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -35,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,0 +42,1 @@\n+\n@@ -45,13 +48,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackProducer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitJsrInstruction(this);\n-        v.visitJSR_W(this);\n-    }\n@@ -61,1 +51,0 @@\n-     *\n@@ -65,1 +54,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -71,0 +60,1 @@\n+\n@@ -75,1 +65,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -79,0 +69,17 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackProducer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitJsrInstruction(this);\n+        v.visitJSR_W(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JSR_W.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -27,1 +28,7 @@\n-public abstract class JsrInstruction extends BranchInstruction implements UnconditionalBranch, TypedInstruction, StackProducer {\n+public abstract class JsrInstruction extends BranchInstruction implements UnconditionalBranch,\n+        TypedInstruction, StackProducer {\n+\n+    JsrInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, target);\n+    }\n+\n@@ -30,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -35,3 +43,0 @@\n-    JsrInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, target);\n-    }\n@@ -39,2 +44,1 @@\n-    \/**\n-     * @return return address type\n+    \/** @return return address type\n@@ -43,1 +47,1 @@\n-    public Type getType(final ConstantPoolGen cp) {\n+    public Type getType( final ConstantPoolGen cp ) {\n@@ -47,0 +51,1 @@\n+\n@@ -48,5 +53,9 @@\n-     * Returns an InstructionHandle to the physical successor of this JsrInstruction. <B>For this method to work, this\n-     * JsrInstruction object must not be shared between multiple InstructionHandle objects!<\/B> Formally, there must not be\n-     * InstructionHandle objects i, j where i != j and i.getInstruction() == this == j.getInstruction().\n-     *\n-     * @return an InstructionHandle to the \"next\" instruction that will be executed when RETurned from a subroutine.\n+     * Returns an InstructionHandle to the physical successor\n+     * of this JsrInstruction. <B>For this method to work,\n+     * this JsrInstruction object must not be shared between\n+     * multiple InstructionHandle objects!<\/B>\n+     * Formally, there must not be InstructionHandle objects\n+     * i, j where i != j and i.getInstruction() == this ==\n+     * j.getInstruction().\n+     * @return an InstructionHandle to the \"next\" instruction that\n+     * will be executed when RETurned from a subroutine.\n@@ -67,1 +76,1 @@\n-            if (ih != null && ih.getInstruction() == this) {\n+            if ((ih != null) && (ih.getInstruction() == this)) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JsrInstruction.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2D.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2F.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2I.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value1, value2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value1, value2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load long from array\n+    \/** Load long from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LAND.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * LASTORE - Store into long array\n+ * LASTORE -  Store into long array\n+ * <PRE>Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store long into array\n+    \/** Store long into array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result &lt;= -1, 0, 1&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result &lt;= -1, 0, 1&gt;\n- * <\/PRE>\n@@ -38,0 +36,9 @@\n+\n+    \/** @return Type.LONG\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.LONG;\n+    }\n+\n+\n@@ -39,2 +46,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +54,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -51,8 +60,0 @@\n-\n-    \/**\n-     * @return Type.LONG\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.LONG;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LCMP.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,3 +26,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ...,\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., <\/PRE>\n+ *\n@@ -32,1 +31,2 @@\n-    private final long value;\n+    private long value;\n+\n@@ -35,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -38,1 +39,0 @@\n-        this(0);\n@@ -41,0 +41,1 @@\n+\n@@ -53,0 +54,15 @@\n+\n+    @Override\n+    public Number getValue() {\n+        return Long.valueOf(value);\n+    }\n+\n+\n+    \/** @return Type.LONG\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.LONG;\n+    }\n+\n+\n@@ -54,2 +70,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -60,1 +78,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -67,13 +85,0 @@\n-\n-    \/**\n-     * @return Type.LONG\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.LONG;\n-    }\n-\n-    @Override\n-    public Number getValue() {\n-        return Long.valueOf(value);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LCONST.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -32,3 +32,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., item\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., item<\/PRE>\n+ *\n@@ -40,1 +39,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -45,0 +45,1 @@\n+\n@@ -50,14 +51,10 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackProducer(this);\n-        v.visitPushInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitCPInstruction(this);\n-        v.visitLDC(this);\n+\n+    \/\/ Adjust to proper size\n+    protected final void setSize() {\n+        if (super.getIndex() <= com.sun.org.apache.bcel.internal.Const.MAX_BYTE) { \/\/ Fits in one byte?\n+            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC);\n+            super.setLength(2);\n+        } else {\n+            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC_W);\n+            super.setLength(3);\n+        }\n@@ -66,0 +63,1 @@\n+\n@@ -68,1 +66,0 @@\n-     *\n@@ -72,1 +69,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -81,0 +78,4 @@\n+\n+    \/**\n+     * Set the index to constant pool and adjust size.\n+     *\/\n@@ -82,2 +83,3 @@\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_STRING_RESOLUTION);\n+    public final void setIndex( final int index ) {\n+        super.setIndex(index);\n+        setSize();\n@@ -86,0 +88,4 @@\n+\n+    \/**\n+     * Read needed data (e.g. index) from file.\n+     *\/\n@@ -87,13 +93,3 @@\n-    public Type getType(final ConstantPoolGen cpg) {\n-        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n-            return Type.STRING;\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n-            return Type.FLOAT;\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n-            return Type.INT;\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n-            return Type.CLASS;\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n-        }\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.setLength(2);\n+        super.setIndex(bytes.readUnsignedByte());\n@@ -102,1 +98,2 @@\n-    public Object getValue(final ConstantPoolGen cpg) {\n+\n+    public Object getValue( final ConstantPoolGen cpg ) {\n@@ -105,14 +102,14 @@\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n-            final int i = ((com.sun.org.apache.bcel.internal.classfile.ConstantString) c).getStringIndex();\n-            c = cpg.getConstantPool().getConstant(i);\n-            return ((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes();\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n-            return Float.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantFloat) c).getBytes());\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n-            return Integer.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantInteger) c).getBytes());\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n-            final int nameIndex = ((com.sun.org.apache.bcel.internal.classfile.ConstantClass) c).getNameIndex();\n-            c = cpg.getConstantPool().getConstant(nameIndex);\n-            return Type.getType(((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes());\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n+                final int i = ((com.sun.org.apache.bcel.internal.classfile.ConstantString) c).getStringIndex();\n+                c = cpg.getConstantPool().getConstant(i);\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes();\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantFloat) c).getBytes();\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantInteger) c).getBytes();\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n+                final int nameIndex = ((com.sun.org.apache.bcel.internal.classfile.ConstantClass) c).getNameIndex();\n+                c = cpg.getConstantPool().getConstant(nameIndex);\n+                return new ObjectType(((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes());\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n@@ -122,3 +119,1 @@\n-    \/**\n-     * Read needed data (e.g. index) from file.\n-     *\/\n+\n@@ -126,3 +121,13 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.setLength(2);\n-        super.setIndex(bytes.readUnsignedByte());\n+    public Type getType( final ConstantPoolGen cpg ) {\n+        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n+                return Type.STRING;\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n+                return Type.FLOAT;\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n+                return Type.INT;\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n+                return Type.CLASS;\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+        }\n@@ -131,3 +136,1 @@\n-    \/**\n-     * Set the index to constant pool and adjust size.\n-     *\/\n+\n@@ -135,3 +138,2 @@\n-    public final void setIndex(final int index) {\n-        super.setIndex(index);\n-        setSize();\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_STRING_RESOLUTION);\n@@ -140,9 +142,17 @@\n-    \/\/ Adjust to proper size\n-    protected final void setSize() {\n-        if (super.getIndex() <= com.sun.org.apache.bcel.internal.Const.MAX_BYTE) { \/\/ Fits in one byte?\n-            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC);\n-            super.setLength(2);\n-        } else {\n-            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC_W);\n-            super.setLength(3);\n-        }\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackProducer(this);\n+        v.visitPushInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitCPInstruction(this);\n+        v.visitLDC(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC.java","additions":81,"deletions":71,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -26,3 +26,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., item.word1, item.word2\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., item.word1, item.word2<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,27 @@\n+\n+    @Override\n+    public Type getType( final ConstantPoolGen cpg ) {\n+        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n+                return Type.LONG;\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n+                return Type.DOUBLE;\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown constant type \" + super.getOpcode());\n+        }\n+    }\n+\n+\n+    public Number getValue( final ConstantPoolGen cpg ) {\n+        final com.sun.org.apache.bcel.internal.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());\n+        switch (c.getTag()) {\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantLong) c).getBytes();\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantDouble) c).getBytes();\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+        }\n+    }\n+\n+\n@@ -44,2 +72,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +80,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -57,24 +87,0 @@\n-\n-    @Override\n-    public Type getType(final ConstantPoolGen cpg) {\n-        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n-            return Type.LONG;\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n-            return Type.DOUBLE;\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown constant type \" + super.getOpcode());\n-        }\n-    }\n-\n-    public Number getValue(final ConstantPoolGen cpg) {\n-        final com.sun.org.apache.bcel.internal.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());\n-        switch (c.getTag()) {\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n-            return Long.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantLong) c).getBytes());\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n-            return Double.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantDouble) c).getBytes());\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n-        }\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC2_W.java","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., item.word1, item.word2\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., item.word1, item.word2<\/PRE>\n+ *\n@@ -38,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -43,0 +43,1 @@\n+\n@@ -47,0 +48,1 @@\n+\n@@ -51,1 +53,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC_W.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -28,5 +30,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -41,0 +38,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ARITHMETIC_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -42,2 +48,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +56,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,5 +64,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDIV.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *<PRE>Stack ... -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack ... -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,0 +39,1 @@\n+\n@@ -44,0 +44,1 @@\n+\n@@ -45,2 +46,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -51,1 +54,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LLOAD.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LNEG.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -42,1 +43,3 @@\n-    public LOOKUPSWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {\n+\n+    public LOOKUPSWITCH(final int[] match, final InstructionHandle[] targets,\n+            final InstructionHandle defaultTarget) {\n@@ -45,3 +48,3 @@\n-        final short length = (short) (9 + getMatchLength() * 8);\n-        super.setLength(length);\n-        setFixedLength(length);\n+        final short _length = (short) (9 + getMatch_length() * 8);\n+        super.setLength(_length);\n+        setFixed_length(_length);\n@@ -50,14 +53,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitSelect(this);\n-        v.visitLOOKUPSWITCH(this);\n-    }\n@@ -67,1 +56,0 @@\n-     *\n@@ -71,1 +59,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -73,3 +61,3 @@\n-        final int matchLength = getMatchLength();\n-        out.writeInt(matchLength); \/\/ npairs\n-        for (int i = 0; i < matchLength; i++) {\n+        final int _match_length = getMatch_length();\n+        out.writeInt(_match_length); \/\/ npairs\n+        for (int i = 0; i < _match_length; i++) {\n@@ -81,0 +69,1 @@\n+\n@@ -85,1 +74,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -87,10 +76,10 @@\n-        final int matchLength = bytes.readInt();\n-        setMatchLength(matchLength);\n-        final short fixedLength = (short) (9 + matchLength * 8);\n-        setFixedLength(fixedLength);\n-        final short length = (short) (matchLength + super.getPadding());\n-        super.setLength(length);\n-        super.setMatches(new int[matchLength]);\n-        super.setIndices(new int[matchLength]);\n-        super.setTargets(new InstructionHandle[matchLength]);\n-        for (int i = 0; i < matchLength; i++) {\n+        final int _match_length = bytes.readInt();\n+        setMatch_length(_match_length);\n+        final short _fixed_length = (short) (9 + _match_length * 8);\n+        setFixed_length(_fixed_length);\n+        final short _length = (short) (_match_length + super.getPadding());\n+        super.setLength(_length);\n+        super.setMatches(new int[_match_length]);\n+        super.setIndices(new int[_match_length]);\n+        super.setTargets(new InstructionHandle[_match_length]);\n+        for (int i = 0; i < _match_length; i++) {\n@@ -101,0 +90,18 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitSelect(this);\n+        v.visitLOOKUPSWITCH(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LOOKUPSWITCH.java","additions":42,"deletions":35,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LOR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -39,0 +37,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ARITHMETIC_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -40,2 +47,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +55,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -54,5 +63,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LREM.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * LRETURN - Return long from method\n+ * LRETURN -  Return long from method\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LRETURN.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSHL.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSHR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ... <\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,0 +39,1 @@\n+\n@@ -44,0 +44,1 @@\n+\n@@ -45,2 +46,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -51,1 +54,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSTORE.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LUSHR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LXOR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * This class represents a line number within a method, i.e., give an instruction a line number corresponding to the\n- * source code line.\n+ * This class represents a line number within a method, i.e., give an instruction\n+ * a line number corresponding to the source code line.\n@@ -32,2 +32,2 @@\n- * @see LineNumber\n- * @see MethodGen\n+ * @see     LineNumber\n+ * @see     MethodGen\n@@ -37,2 +37,0 @@\n-    static final LineNumberGen[] EMPTY_ARRAY = {};\n-\n@@ -47,1 +45,1 @@\n-    public LineNumberGen(final InstructionHandle ih, final int srcLine) {\n+    public LineNumberGen(final InstructionHandle ih, final int src_line) {\n@@ -49,1 +47,1 @@\n-        setSourceLine(srcLine);\n+        setSourceLine(src_line);\n@@ -52,8 +50,0 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n-    }\n@@ -65,1 +55,1 @@\n-    public boolean containsTarget(final InstructionHandle ih) {\n+    public boolean containsTarget( final InstructionHandle ih ) {\n@@ -69,2 +59,11 @@\n-    public InstructionHandle getInstruction() {\n-        return ih;\n+\n+    \/**\n+     * @param old_ih old target\n+     * @param new_ih new target\n+     *\/\n+    @Override\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        if (old_ih != ih) {\n+            throw new ClassGenException(\"Not targeting \" + old_ih + \", but \" + ih + \"}\");\n+        }\n+        setInstruction(new_ih);\n@@ -73,0 +72,1 @@\n+\n@@ -74,1 +74,1 @@\n-     * Get LineNumber attribute.\n+     * Get LineNumber attribute .\n@@ -76,2 +76,2 @@\n-     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n-     * has been called for the instruction list.\n+     * This relies on that the instruction list has already been dumped to byte code or\n+     * or that the `setPositions' methods has been called for the instruction list.\n@@ -83,3 +83,0 @@\n-    public int getSourceLine() {\n-        return srcLine;\n-    }\n@@ -87,1 +84,1 @@\n-    public void setInstruction(final InstructionHandle instructionHandle) { \/\/ TODO could be package-protected?\n+    public void setInstruction( final InstructionHandle instructionHandle ) { \/\/ TODO could be package-protected?\n@@ -93,3 +90,0 @@\n-    public void setSourceLine(final int srcLine) { \/\/ TODO could be package-protected?\n-        this.srcLine = srcLine;\n-    }\n@@ -97,4 +91,0 @@\n-    \/**\n-     * @param oldIh old target\n-     * @param newIh new target\n-     *\/\n@@ -102,3 +92,5 @@\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        if (oldIh != ih) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh + \", but \" + ih + \"}\");\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n@@ -106,1 +98,15 @@\n-        setInstruction(newIh);\n+    }\n+\n+\n+    public InstructionHandle getInstruction() {\n+        return ih;\n+    }\n+\n+\n+    public void setSourceLine( final int src_line ) { \/\/ TODO could be package-protected?\n+        this.srcLine = src_line;\n+    }\n+\n+\n+    public int getSourceLine() {\n+        return srcLine;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LineNumberGen.java","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denotes that an instruction may start the process of loading and resolving the referenced class in the Virtual Machine.\n+ * Denotes that an instruction may start the process of loading and resolving\n+ * the referenced class in the Virtual Machine.\n+ *\n@@ -30,4 +32,4 @@\n-     * Returns the {@link ObjectType} of the referenced class or interface that may be loaded and resolved.\n-     *\n-     * @param cpg A ConstantPoolGen\n-     * @return object type that may be loaded or null if a primitive is referenced\n+     * Returns the ObjectType of the referenced class or interface\n+     * that may be loaded and resolved.\n+     * @return object type that may be loaded or null if a primitive is\n+     * referenced\n@@ -35,1 +37,2 @@\n-    ObjectType getLoadClassType(ConstantPoolGen cpg);\n+    ObjectType getLoadClassType( ConstantPoolGen cpg );\n+\n@@ -38,7 +41,9 @@\n-     * Returns the type associated with this instruction. LoadClass instances are always typed, but this type does not always refer to the type of the class or\n-     * interface that it possibly forces to load. For example, {@link GETFIELD} would return the type of the field and not the type of the class where the field\n-     * is defined. If no class is forced to be loaded, {@code null} is returned. An example for this is an {@link NEWARRAY} instruction that creates an\n-     * {@code int[][]}.\n-     *\n-     * @param cpg A ConstantPoolGen\n-     * @return the type associated with this instruction.\n+     * Returns the type associated with this instruction.\n+     * LoadClass instances are always typed, but this type\n+     * does not always refer to the type of the class or interface\n+     * that it possibly forces to load. For example, GETFIELD would\n+     * return the type of the field and not the type of the class\n+     * where the field is defined.\n+     * If no class is forced to be loaded, <B>null<\/B> is returned.\n+     * An example for this is an ANEWARRAY instruction that creates\n+     * an int[][].\n@@ -47,1 +52,1 @@\n-    Type getType(ConstantPoolGen cpg);\n+    Type getType( ConstantPoolGen cpg );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LoadClass.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denotes an unparameterized instruction to load a value from a local variable, e.g. ILOAD.\n+ * Denotes an unparameterized instruction to load a value from a local\n+ * variable, e.g. ILOAD.\n+ *\n@@ -30,2 +32,3 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n-     * readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n+     * tag and length are defined in readInstruction and initFromFile, respectively.\n@@ -33,2 +36,2 @@\n-    LoadInstruction(final short canonTag, final short cTag) {\n-        super(canonTag, cTag);\n+    LoadInstruction(final short canon_tag, final short c_tag) {\n+        super(canon_tag, c_tag);\n@@ -37,0 +40,1 @@\n+\n@@ -39,1 +43,1 @@\n-     * @param cTag Instruction number for compact version, ALOAD_0, e.g.\n+     * @param c_tag Instruction number for compact version, ALOAD_0, e.g.\n@@ -42,2 +46,2 @@\n-    protected LoadInstruction(final short opcode, final short cTag, final int n) {\n-        super(opcode, cTag, n);\n+    protected LoadInstruction(final short opcode, final short c_tag, final int n) {\n+        super(opcode, c_tag, n);\n@@ -46,0 +50,1 @@\n+\n@@ -47,2 +52,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -53,1 +60,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LoadInstruction.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,2 +27,4 @@\n- * Represents a local variable within a method. It contains its scope, name and type. The generated LocalVariable object\n- * can be obtained with getLocalVariable which needs the instruction list and the constant pool as parameters.\n+ * Represents a local variable within a method. It contains its\n+ * scope, name and type. The generated LocalVariable object can be obtained\n+ * with getLocalVariable which needs the instruction list and the constant\n+ * pool as parameters.\n@@ -30,2 +32,2 @@\n- * @see LocalVariable\n- * @see MethodGen\n+ * @see     LocalVariable\n+ * @see     MethodGen\n@@ -43,0 +45,1 @@\n+\n@@ -44,2 +47,2 @@\n-     * Generate a local variable that with index 'index'. Note that double and long variables need two indexs. Index indices\n-     * have to be provided by the user.\n+     * Generate a local variable that with index `index'. Note that double and long\n+     * variables need two indexs. Index indices have to be provided by the user.\n@@ -53,3 +56,4 @@\n-    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start, final InstructionHandle end) {\n-        if (index < 0 || index > Const.MAX_SHORT) {\n-            throw new ClassGenException(\"Invalid index: \" + index);\n+    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,\n+            final InstructionHandle end) {\n+        if ((index < 0) || (index > Const.MAX_SHORT)) {\n+            throw new ClassGenException(\"Invalid index index: \" + index);\n@@ -66,0 +70,1 @@\n+\n@@ -67,2 +72,2 @@\n-     * Generates a local variable that with index 'index'. Note that double and long variables need two indexs. Index\n-     * indices have to be provided by the user.\n+     * Generates a local variable that with index `index'. Note that double and long\n+     * variables need two indexs. Index indices have to be provided by the user.\n@@ -77,2 +82,2 @@\n-    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start, final InstructionHandle end,\n-        final int origIndex) {\n+    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,\n+            final InstructionHandle end, final int origIndex) {\n@@ -83,8 +88,0 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n-    }\n@@ -93,1 +90,12 @@\n-     * @return true, if ih is target of this variable\n+     * Gets LocalVariable object.\n+     *\n+     * This relies on that the instruction list has already been dumped to byte code or\n+     * or that the `setPositions' methods has been called for the instruction list.\n+     *\n+     * Note that due to the conversion from byte code offset to InstructionHandle,\n+     * it is impossible to tell the difference between a live range that ends BEFORE\n+     * the last insturction of the method or a live range that ends AFTER the last\n+     * instruction of the method.  Hence the liveToEnd flag to differentiate\n+     * between these two cases.\n+     *\n+     * @param cp constant pool\n@@ -95,3 +103,14 @@\n-    @Override\n-    public boolean containsTarget(final InstructionHandle ih) {\n-        return start == ih || end == ih;\n+    public LocalVariable getLocalVariable( final ConstantPoolGen cp ) {\n+        int start_pc = 0;\n+        int length = 0;\n+        if ((start != null) && (end != null)) {\n+            start_pc = start.getPosition();\n+            length = end.getPosition() - start_pc;\n+            if ((end.getNext() == null) && liveToEnd) {\n+                length += end.getInstruction().getLength();\n+            }\n+        }\n+        final int name_index = cp.addUtf8(name);\n+        final int signature_index = cp.addUtf8(type.getSignature());\n+        return new LocalVariable(start_pc, length, name_index, signature_index, index, cp\n+                .getConstantPool(), origIndex);\n@@ -100,7 +119,0 @@\n-    \/**\n-     * Clear the references from and to this variable when it's removed.\n-     *\/\n-    void dispose() {\n-        setStart(null);\n-        setEnd(null);\n-    }\n@@ -108,10 +120,2 @@\n-    \/**\n-     * We consider to local variables to be equal, if the use the same index and are valid in the same range.\n-     *\/\n-    @Override\n-    public boolean equals(final Object o) {\n-        if (!(o instanceof LocalVariableGen)) {\n-            return false;\n-        }\n-        final LocalVariableGen l = (LocalVariableGen) o;\n-        return l.index == index && l.start == start && l.end == end;\n+    public void setIndex( final int index ) {\n+        this.index = index;\n@@ -120,3 +124,0 @@\n-    public InstructionHandle getEnd() {\n-        return end;\n-    }\n@@ -128,0 +129,11 @@\n+\n+    public int getOrigIndex() {\n+        return origIndex;\n+    }\n+\n+\n+    public void setLiveToEnd( final boolean live_to_end) {\n+        this.liveToEnd = live_to_end;\n+    }\n+\n+\n@@ -132,25 +144,4 @@\n-    \/**\n-     * Gets LocalVariable object.\n-     *\n-     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n-     * has been called for the instruction list.\n-     *\n-     * Note that due to the conversion from byte code offset to InstructionHandle, it is impossible to tell the difference\n-     * between a live range that ends BEFORE the last insturction of the method or a live range that ends AFTER the last\n-     * instruction of the method. Hence the liveToEnd flag to differentiate between these two cases.\n-     *\n-     * @param cp constant pool\n-     *\/\n-    public LocalVariable getLocalVariable(final ConstantPoolGen cp) {\n-        int startPc = 0;\n-        int length = 0;\n-        if (start != null && end != null) {\n-            startPc = start.getPosition();\n-            length = end.getPosition() - startPc;\n-            if (end.getNext() == null && liveToEnd) {\n-                length += end.getInstruction().getLength();\n-            }\n-        }\n-        final int nameIndex = cp.addUtf8(name);\n-        final int signatureIndex = cp.addUtf8(type.getSignature());\n-        return new LocalVariable(startPc, length, nameIndex, signatureIndex, index, cp.getConstantPool(), origIndex);\n+\n+    @Override\n+    public void setName( final String name ) {\n+        this.name = name;\n@@ -159,0 +150,1 @@\n+\n@@ -164,3 +156,0 @@\n-    public int getOrigIndex() {\n-        return origIndex;\n-    }\n@@ -168,2 +157,3 @@\n-    public InstructionHandle getStart() {\n-        return start;\n+    @Override\n+    public void setType( final Type type ) {\n+        this.type = type;\n@@ -172,0 +162,1 @@\n+\n@@ -177,5 +168,8 @@\n-    @Override\n-    public int hashCode() {\n-        \/\/ If the user changes the name or type, problems with the targeter hashmap will occur.\n-        \/\/ Note: index cannot be part of hash as it may be changed by the user.\n-        return name.hashCode() ^ type.hashCode();\n+\n+    public InstructionHandle getStart() {\n+        return start;\n+    }\n+\n+\n+    public InstructionHandle getEnd() {\n+        return end;\n@@ -184,1 +178,8 @@\n-    public void setEnd(final InstructionHandle end) { \/\/ TODO could be package-protected?\n+\n+    public void setStart( final InstructionHandle start ) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.start, start, this);\n+        this.start = start;\n+    }\n+\n+\n+    public void setEnd( final InstructionHandle end ) { \/\/ TODO could be package-protected?\n@@ -189,2 +190,20 @@\n-    public void setIndex(final int index) {\n-        this.index = index;\n+\n+    \/**\n+     * @param old_ih old target, either start or end\n+     * @param new_ih new target\n+     *\/\n+    @Override\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        boolean targeted = false;\n+        if (start == old_ih) {\n+            targeted = true;\n+            setStart(new_ih);\n+        }\n+        if (end == old_ih) {\n+            targeted = true;\n+            setEnd(new_ih);\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + old_ih + \", but {\" + start + \", \" + end\n+                    + \"}\");\n+        }\n@@ -193,2 +212,6 @@\n-    public void setLiveToEnd(final boolean liveToEnd) {\n-        this.liveToEnd = liveToEnd;\n+    \/**\n+     * Clear the references from and to this variable when it's removed.\n+     *\/\n+    void dispose() {\n+        setStart(null);\n+        setEnd(null);\n@@ -197,0 +220,3 @@\n+    \/**\n+     * @return true, if ih is target of this variable\n+     *\/\n@@ -198,2 +224,2 @@\n-    public void setName(final String name) {\n-        this.name = name;\n+    public boolean containsTarget( final InstructionHandle ih ) {\n+        return (start == ih) || (end == ih);\n@@ -202,3 +228,6 @@\n-    public void setStart(final InstructionHandle start) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.start, start, this);\n-        this.start = start;\n+\n+    @Override\n+    public int hashCode() {\n+        \/\/ If the user changes the name or type, problems with the targeter hashmap will occur.\n+        \/\/ Note: index cannot be part of hash as it may be changed by the user.\n+        return name.hashCode() ^ type.hashCode();\n@@ -207,0 +236,5 @@\n+\n+    \/**\n+     * We consider to local variables to be equal, if the use the same index and\n+     * are valid in the same range.\n+     *\/\n@@ -208,2 +242,6 @@\n-    public void setType(final Type type) {\n-        this.type = type;\n+    public boolean equals( final Object o ) {\n+        if (!(o instanceof LocalVariableGen)) {\n+            return false;\n+        }\n+        final LocalVariableGen l = (LocalVariableGen) o;\n+        return (l.index == index) && (l.start == start) && (l.end == end);\n@@ -212,0 +250,1 @@\n+\n@@ -217,4 +256,1 @@\n-    \/**\n-     * @param oldIh old target, either start or end\n-     * @param newIh new target\n-     *\/\n+\n@@ -222,12 +258,5 @@\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        boolean targeted = false;\n-        if (start == oldIh) {\n-            targeted = true;\n-            setStart(newIh);\n-        }\n-        if (end == oldIh) {\n-            targeted = true;\n-            setEnd(newIh);\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh + \", but {\" + start + \", \" + end + \"}\");\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LocalVariableGen.java","additions":137,"deletions":108,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -33,7 +33,2 @@\n-public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction, IndexedInstruction {\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int n = -1; \/\/ index of referenced variable\n+public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction,\n+        IndexedInstruction {\n@@ -41,0 +36,1 @@\n+    private int n = -1; \/\/ index of referenced variable\n@@ -44,0 +40,6 @@\n+\n+    private boolean wide() {\n+        return n > Const.MAX_BYTE;\n+    }\n+\n+\n@@ -45,1 +47,3 @@\n-     * Empty constructor needed for Instruction.readInstruction. Also used by IINC()!\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n+     * tag and length are defined in readInstruction and initFromFile, respectively.\n@@ -47,1 +51,4 @@\n-    LocalVariableInstruction() {\n+    LocalVariableInstruction(final short canon_tag, final short c_tag) {\n+        super();\n+        this.canonTag = canon_tag;\n+        this.cTag = c_tag;\n@@ -50,0 +57,1 @@\n+\n@@ -51,2 +59,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n-     * readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Also used by IINC()!\n@@ -54,3 +62,1 @@\n-    LocalVariableInstruction(final short canonTag, final short cTag) {\n-        this.canonTag = canonTag;\n-        this.cTag = cTag;\n+    LocalVariableInstruction() {\n@@ -59,0 +65,1 @@\n+\n@@ -71,0 +78,1 @@\n+\n@@ -73,1 +81,0 @@\n-     *\n@@ -77,1 +84,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -91,6 +98,0 @@\n-    \/**\n-     * @return canonical tag for instruction, e.g., ALOAD for ALOAD_0\n-     *\/\n-    public short getCanonicalTag() {\n-        return canonTag;\n-    }\n@@ -99,11 +100,1 @@\n-     * @return local variable index (n) referred by this instruction.\n-     *\/\n-    @Override\n-    public final int getIndex() {\n-        return n;\n-    }\n-\n-    \/**\n-     * Returns the type associated with the instruction - in case of ALOAD or ASTORE Type.OBJECT is returned. This is just a\n-     * bit incorrect, because ALOAD and ASTORE may work on every ReferenceType (including Type.NULL) and ASTORE may even\n-     * work on a ReturnaddressType .\n+     * Long output format:\n@@ -111,1 +102,5 @@\n-     * @return type associated with the instruction\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n+     * \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; local variable index&gt;\"&gt;\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -114,19 +109,5 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        switch (canonTag) {\n-        case Const.ILOAD:\n-        case Const.ISTORE:\n-            return Type.INT;\n-        case Const.LLOAD:\n-        case Const.LSTORE:\n-            return Type.LONG;\n-        case Const.DLOAD:\n-        case Const.DSTORE:\n-            return Type.DOUBLE;\n-        case Const.FLOAD:\n-        case Const.FSTORE:\n-            return Type.FLOAT;\n-        case Const.ALOAD:\n-        case Const.ASTORE:\n-            return Type.OBJECT;\n-        default:\n-            throw new ClassGenException(\"Unknown case in switch\" + canonTag);\n+    public String toString( final boolean verbose ) {\n+        final short _opcode = super.getOpcode();\n+        if (((_opcode >= Const.ILOAD_0) && (_opcode <= Const.ALOAD_3))\n+         || ((_opcode >= Const.ISTORE_0) && (_opcode <= Const.ASTORE_3))) {\n+            return super.toString(verbose);\n@@ -134,0 +115,1 @@\n+        return super.toString(verbose) + \" \" + n;\n@@ -136,0 +118,1 @@\n+\n@@ -138,1 +121,0 @@\n-     *\n@@ -144,1 +126,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -149,2 +131,3 @@\n-            final short opcode = super.getOpcode();\n-            if (opcode >= Const.ILOAD && opcode <= Const.ALOAD || opcode >= Const.ISTORE && opcode <= Const.ASTORE) {\n+            final short _opcode = super.getOpcode();\n+            if (((_opcode >= Const.ILOAD) && (_opcode <= Const.ALOAD))\n+             || ((_opcode >= Const.ISTORE) && (_opcode <= Const.ASTORE))) {\n@@ -153,6 +136,5 @@\n-            } else {\n-                if (opcode <= Const.ALOAD_3) { \/\/ compact load instruction such as ILOAD_2\n-                    n = (opcode - Const.ILOAD_0) % 4;\n-                } else { \/\/ Assert ISTORE_0 <= tag <= ASTORE_3\n-                    n = (opcode - Const.ISTORE_0) % 4;\n-                }\n+            } else if (_opcode <= Const.ALOAD_3) { \/\/ compact load instruction such as ILOAD_2\n+                n = (_opcode - Const.ILOAD_0) % 4;\n+                super.setLength(1);\n+            } else { \/\/ Assert ISTORE_0 <= tag <= ASTORE_3\n+                n = (_opcode - Const.ISTORE_0) % 4;\n@@ -164,0 +146,1 @@\n+\n@@ -165,2 +148,12 @@\n-     * Set the local variable index. also updates opcode and length TODO Why?\n-     *\n+     * @return local variable index (n) referred by this instruction.\n+     *\/\n+    @Override\n+    public final int getIndex() {\n+        return n;\n+    }\n+\n+\n+    \/**\n+     * Set the local variable index.\n+     * also updates opcode and length\n+     * TODO Why?\n@@ -170,2 +163,2 @@\n-    public void setIndex(final int n) { \/\/ TODO could be package-protected?\n-        if (n < 0 || n > Const.MAX_SHORT) {\n+    public void setIndex( final int n ) { \/\/ TODO could be package-protected?\n+        if ((n < 0) || (n > Const.MAX_SHORT)) {\n@@ -189,5 +182,2 @@\n-    \/**\n-     * Sets the index of the referenced variable (n) only\n-     *\n-     * @since 6.0\n-     * @see #setIndex(int)\n+\n+    \/** @return canonical tag for instruction, e.g., ALOAD for ALOAD_0\n@@ -195,2 +185,2 @@\n-    final void setIndexOnly(final int n) {\n-        this.n = n;\n+    public short getCanonicalTag() {\n+        return canonTag;\n@@ -199,0 +189,1 @@\n+\n@@ -200,7 +191,6 @@\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; local variable\n-     * index&gt;\"&gt;\"\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * Returns the type associated with the instruction -\n+     * in case of ALOAD or ASTORE Type.OBJECT is returned.\n+     * This is just a bit incorrect, because ALOAD and ASTORE\n+     * may work on every ReferenceType (including Type.NULL) and\n+     * ASTORE may even work on a ReturnaddressType .\n+     * @return type associated with the instruction\n@@ -209,4 +199,19 @@\n-    public String toString(final boolean verbose) {\n-        final short opcode = super.getOpcode();\n-        if (opcode >= Const.ILOAD_0 && opcode <= Const.ALOAD_3 || opcode >= Const.ISTORE_0 && opcode <= Const.ASTORE_3) {\n-            return super.toString(verbose);\n+    public Type getType( final ConstantPoolGen cp ) {\n+        switch (canonTag) {\n+            case Const.ILOAD:\n+            case Const.ISTORE:\n+                return Type.INT;\n+            case Const.LLOAD:\n+            case Const.LSTORE:\n+                return Type.LONG;\n+            case Const.DLOAD:\n+            case Const.DSTORE:\n+                return Type.DOUBLE;\n+            case Const.FLOAD:\n+            case Const.FSTORE:\n+                return Type.FLOAT;\n+            case Const.ALOAD:\n+            case Const.ASTORE:\n+                return Type.OBJECT;\n+            default:\n+                throw new ClassGenException(\"Unknown case in switch\" + canonTag);\n@@ -214,1 +219,0 @@\n-        return super.toString(verbose) + \" \" + n;\n@@ -217,2 +221,7 @@\n-    private boolean wide() {\n-        return n > Const.MAX_BYTE;\n+    \/**\n+     * Sets the index of the referenced variable (n) only\n+     * @since 6.0\n+     * @see #setIndex(int)\n+     *\/\n+    final void setIndexOnly(final int n) {\n+        this.n = n;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LocalVariableInstruction.java","additions":97,"deletions":88,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ...<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ...\n- * <\/PRE>\n@@ -39,0 +37,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.NULL_POINTER_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -40,2 +47,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +55,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -51,5 +60,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MONITORENTER.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ...<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ...\n- * <\/PRE>\n@@ -39,0 +37,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.NULL_POINTER_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -40,2 +47,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +55,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -51,5 +60,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MONITOREXIT.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * <PRE>Stack: ..., count1, [count2, ...] -&gt; ..., arrayref<\/PRE>\n@@ -34,3 +35,0 @@\n- * <PRE>\n- * Stack: ..., count1, [count2, ...] -&gt; ..., arrayref\n- * <\/PRE>\n@@ -38,1 +36,2 @@\n-public class MULTIANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower {\n+public class MULTIANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction,\n+        ExceptionThrower {\n@@ -42,0 +41,1 @@\n+\n@@ -43,1 +43,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +49,1 @@\n+\n@@ -57,0 +59,1 @@\n+\n@@ -58,4 +61,2 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n@@ -64,7 +65,4 @@\n-    public void accept(final Visitor v) {\n-        v.visitLoadClass(this);\n-        v.visitAllocationInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitCPInstruction(this);\n-        v.visitMULTIANEWARRAY(this);\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+        out.writeByte(dimensions);\n@@ -73,0 +71,1 @@\n+\n@@ -74,3 +73,1 @@\n-     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n-     *\n-     * @return Number of words consumed from stack by this instruction\n+     * Read needed data (i.e., no. dimension) from file.\n@@ -79,1 +76,11 @@\n-    public int consumeStack(final ConstantPoolGen cpg) {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.initFromFile(bytes, wide);\n+        dimensions = bytes.readByte();\n+        super.setLength(4);\n+    }\n+\n+\n+    \/**\n+     * @return number of dimensions to be created\n+     *\/\n+    public final short getDimensions() {\n@@ -83,0 +90,1 @@\n+\n@@ -84,3 +92,1 @@\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n+     * @return mnemonic for instruction\n@@ -89,4 +95,2 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-        out.writeByte(dimensions);\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + super.getIndex() + \" \" + dimensions;\n@@ -95,0 +99,1 @@\n+\n@@ -96,1 +101,1 @@\n-     * @return number of dimensions to be created\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -98,1 +103,13 @@\n-    public final short getDimensions() {\n+    @Override\n+    public String toString( final ConstantPool cp ) {\n+        return super.toString(cp) + \" \" + dimensions;\n+    }\n+\n+\n+    \/**\n+     * Also works for instructions whose stack effect depends on the\n+     * constant pool entry they reference.\n+     * @return Number of words consumed from stack by this instruction\n+     *\/\n+    @Override\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n@@ -102,0 +119,1 @@\n+\n@@ -104,1 +122,2 @@\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n@@ -108,0 +127,1 @@\n+\n@@ -109,1 +129,1 @@\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n@@ -114,1 +134,1 @@\n-        return t instanceof ObjectType ? (ObjectType) t : null;\n+        return (t instanceof ObjectType) ? (ObjectType) t : null;\n@@ -117,17 +137,0 @@\n-    \/**\n-     * Read needed data (i.e., no. dimension) from file.\n-     *\/\n-    @Override\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.initFromFile(bytes, wide);\n-        dimensions = bytes.readByte();\n-        super.setLength(4);\n-    }\n-\n-    \/**\n-     * @return mnemonic for instruction\n-     *\/\n-    @Override\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + super.getIndex() + \" \" + dimensions;\n-    }\n@@ -136,1 +139,6 @@\n-     * @return mnemonic for instruction with symbolic references resolved\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -139,2 +147,7 @@\n-    public String toString(final ConstantPool cp) {\n-        return super.toString(cp) + \" \" + dimensions;\n+    public void accept( final Visitor v ) {\n+        v.visitLoadClass(this);\n+        v.visitAllocationInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitCPInstruction(this);\n+        v.visitMULTIANEWARRAY(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MULTIANEWARRAY.java","additions":65,"deletions":52,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,9 +22,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Stack;\n-\n@@ -49,0 +40,7 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Stack;\n@@ -51,3 +49,4 @@\n- * Template class for building up a method. This is done by defining exception handlers, adding thrown exceptions, local\n- * variables and attributes, whereas the 'LocalVariableTable' and 'LineNumberTable' attributes will be set automatically\n- * for the code. Use stripAttributes() if you don't like this.\n+ * Template class for building up a method. This is done by defining exception\n+ * handlers, adding thrown exceptions, local variables and attributes, whereas\n+ * the `LocalVariableTable' and `LineNumberTable' attributes will be set\n+ * automatically for the code. Use stripAttributes() if you don't like this.\n@@ -55,2 +54,3 @@\n- * While generating code it may be necessary to insert NOP operations. You can use the 'removeNOPs' method to get rid\n- * off them. The resulting method object can be obtained via the 'getMethod()' method.\n+ * While generating code it may be necessary to insert NOP operations. You can\n+ * use the `removeNOPs' method to get rid off them.\n+ * The resulting method object can be obtained via the `getMethod()' method.\n@@ -58,3 +58,3 @@\n- * @see InstructionList\n- * @see Method\n- * @LastModified: Feb 2023\n+ * @see     InstructionList\n+ * @see     Method\n+ * @LastModified: May 2021\n@@ -64,151 +64,0 @@\n-    static final class BranchStack {\n-\n-        private final Stack<BranchTarget> branchTargets = new Stack<>();\n-        private final HashMap<InstructionHandle, BranchTarget> visitedTargets = new HashMap<>();\n-\n-        public BranchTarget pop() {\n-            if (!branchTargets.empty()) {\n-                return branchTargets.pop();\n-            }\n-            return null;\n-        }\n-\n-        public void push(final InstructionHandle target, final int stackDepth) {\n-            if (visited(target)) {\n-                return;\n-            }\n-            branchTargets.push(visit(target, stackDepth));\n-        }\n-\n-        private BranchTarget visit(final InstructionHandle target, final int stackDepth) {\n-            final BranchTarget bt = new BranchTarget(target, stackDepth);\n-            visitedTargets.put(target, bt);\n-            return bt;\n-        }\n-\n-        private boolean visited(final InstructionHandle target) {\n-            return visitedTargets.get(target) != null;\n-        }\n-    }\n-\n-    static final class BranchTarget {\n-\n-        final InstructionHandle target;\n-        final int stackDepth;\n-\n-        BranchTarget(final InstructionHandle target, final int stackDepth) {\n-            this.target = target;\n-            this.stackDepth = stackDepth;\n-        }\n-    }\n-\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n-\n-        @Override\n-        public boolean equals(final Object o1, final Object o2) {\n-            final FieldGenOrMethodGen THIS = (FieldGenOrMethodGen) o1;\n-            final FieldGenOrMethodGen THAT = (FieldGenOrMethodGen) o2;\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n-        }\n-\n-        @Override\n-        public int hashCode(final Object o) {\n-            final FieldGenOrMethodGen THIS = (FieldGenOrMethodGen) o;\n-            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n-        }\n-    };\n-\n-    private static byte[] getByteCodes(final Method method) {\n-        final Code code = method.getCode();\n-        if (code == null) {\n-            throw new IllegalStateException(String.format(\"The method '%s' has no code.\", method));\n-        }\n-        return code.getCode();\n-    }\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-    \/**\n-     * Computes stack usage of an instruction list by performing control flow analysis.\n-     *\n-     * @return maximum stack depth used by method\n-     *\/\n-    public static int getMaxStack(final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et) {\n-        final BranchStack branchTargets = new BranchStack();\n-        \/*\n-         * Initially, populate the branch stack with the exception handlers, because these aren't (necessarily) branched to\n-         * explicitly. in each case, the stack will have depth 1, containing the exception object.\n-         *\/\n-        for (final CodeExceptionGen element : et) {\n-            final InstructionHandle handlerPc = element.getHandlerPC();\n-            if (handlerPc != null) {\n-                branchTargets.push(handlerPc, 1);\n-            }\n-        }\n-        int stackDepth = 0;\n-        int maxStackDepth = 0;\n-        InstructionHandle ih = il.getStart();\n-        while (ih != null) {\n-            final Instruction instruction = ih.getInstruction();\n-            final short opcode = instruction.getOpcode();\n-            final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);\n-            stackDepth += delta;\n-            if (stackDepth > maxStackDepth) {\n-                maxStackDepth = stackDepth;\n-            }\n-            \/\/ choose the next instruction based on whether current is a branch.\n-            if (instruction instanceof BranchInstruction) {\n-                final BranchInstruction branch = (BranchInstruction) instruction;\n-                if (instruction instanceof Select) {\n-                    \/\/ explore all of the select's targets. the default target is handled below.\n-                    final Select select = (Select) branch;\n-                    final InstructionHandle[] targets = select.getTargets();\n-                    for (final InstructionHandle target : targets) {\n-                        branchTargets.push(target, stackDepth);\n-                    }\n-                    \/\/ nothing to fall through to.\n-                    ih = null;\n-                } else if (!(branch instanceof IfInstruction)) {\n-                    \/\/ if an instruction that comes back to following PC,\n-                    \/\/ push next instruction, with stack depth reduced by 1.\n-                    if (opcode == Const.JSR || opcode == Const.JSR_W) {\n-                        branchTargets.push(ih.getNext(), stackDepth - 1);\n-                    }\n-                    ih = null;\n-                }\n-                \/\/ for all branches, the target of the branch is pushed on the branch stack.\n-                \/\/ conditional branches have a fall through case, selects don't, and\n-                \/\/ jsr\/jsr_w return to the next instruction.\n-                branchTargets.push(branch.getTarget(), stackDepth);\n-            } else \/\/ check for instructions that terminate the method.\n-            if (opcode == Const.ATHROW || opcode == Const.RET || opcode >= Const.IRETURN && opcode <= Const.RETURN) {\n-                ih = null;\n-            }\n-            \/\/ normal case, go to the next instruction.\n-            if (ih != null) {\n-                ih = ih.getNext();\n-            }\n-            \/\/ if we have no more instructions, see if there are any deferred branches to explore.\n-            if (ih == null) {\n-                final BranchTarget bt = branchTargets.pop();\n-                if (bt != null) {\n-                    ih = bt.target;\n-                    stackDepth = bt.stackDepth;\n-                }\n-            }\n-        }\n-        return maxStackDepth;\n-    }\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n-    }\n-\n@@ -221,1 +70,0 @@\n-\n@@ -223,1 +71,1 @@\n-    private LocalVariableTypeTable localVariableTypeTable;\n+    private LocalVariableTypeTable localVariableTypeTable = null;\n@@ -225,1 +73,0 @@\n-\n@@ -227,1 +74,0 @@\n-\n@@ -229,1 +75,0 @@\n-\n@@ -231,1 +76,0 @@\n-\n@@ -235,0 +79,4 @@\n+    private boolean hasParameterAnnotations = false;\n+    private boolean haveUnpackedParameterAnnotations = false;\n+\n+    private static BCELComparator bcelComparator = new BCELComparator() {\n@@ -236,1 +84,7 @@\n-    private boolean hasParameterAnnotations;\n+        @Override\n+        public boolean equals( final Object o1, final Object o2 ) {\n+            final MethodGen THIS = (MethodGen) o1;\n+            final MethodGen THAT = (MethodGen) o2;\n+            return Objects.equals(THIS.getName(), THAT.getName())\n+                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+        }\n@@ -238,1 +92,0 @@\n-    private boolean haveUnpackedParameterAnnotations;\n@@ -240,1 +93,7 @@\n-    private List<MethodObserver> observers;\n+        @Override\n+        public int hashCode( final Object o ) {\n+            final MethodGen THIS = (MethodGen) o;\n+            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n+        }\n+    };\n+\n@@ -243,3 +102,5 @@\n-     * Declare method. If the method is non-static the constructor automatically declares a local variable '$this' in slot\n-     * 0. The actual code is contained in the 'il' parameter, which may further manipulated by the user. But they must take\n-     * care not to remove any instruction (handles) that are still referenced from this object.\n+     * Declare method. If the method is non-static the constructor\n+     * automatically declares a local variable `$this' in slot 0. The\n+     * actual code is contained in the `il' parameter, which may further\n+     * manipulated by the user. But he must take care not to remove any\n+     * instruction (handles) that are still referenced from this object.\n@@ -247,2 +108,3 @@\n-     * For example one may not add a local variable and later remove the instructions it refers to without causing havoc. It\n-     * is safe however if you remove that local variable, too.\n+     * For example one may not add a local variable and later remove the\n+     * instructions it refers to without causing havoc. It is safe\n+     * however if you remove that local variable, too.\n@@ -250,2 +112,2 @@\n-     * @param accessFlags access qualifiers\n-     * @param returnType method type\n+     * @param access_flags access qualifiers\n+     * @param return_type  method type\n@@ -253,2 +115,3 @@\n-     * @param argNames argument names (if this is null, default names will be provided for them)\n-     * @param methodName name of method\n+     * @param argNames argument names (if this is null, default names will be provided\n+     * for them)\n+     * @param method_name name of method\n@@ -256,1 +119,2 @@\n-     * @param il instruction list associated with this method, may be null only for abstract or native methods\n+     * @param il instruction list associated with this method, may be null only for\n+     * abstract or native methods\n@@ -259,4 +123,4 @@\n-    public MethodGen(final int accessFlags, final Type returnType, final Type[] argTypes, String[] argNames, final String methodName, final String className,\n-        final InstructionList il, final ConstantPoolGen cp) {\n-        super(accessFlags);\n-        setType(returnType);\n+    public MethodGen(final int access_flags, final Type return_type, final Type[] argTypes, String[] argNames,\n+            final String method_name, final String className, final InstructionList il, final ConstantPoolGen cp) {\n+        super(access_flags);\n+        setType(return_type);\n@@ -265,1 +129,1 @@\n-        setName(methodName);\n+        setName(method_name);\n@@ -275,2 +139,1 @@\n-            \/*\n-             * Add local variables, namely the implicit 'this' and the arguments\n+            \/* Add local variables, namely the implicit `this' and the arguments\n@@ -278,2 +141,2 @@\n-            if (!isStatic() && className != null) { \/\/ Instance method -> 'this' is local var 0\n-                addLocalVariable(\"this\", ObjectType.getInstance(className), start, end);\n+            if (!isStatic() && (className != null)) { \/\/ Instance method -> `this' is local var 0\n+                addLocalVariable(\"this\",  ObjectType.getInstance(className), start, end);\n@@ -284,2 +147,2 @@\n-            for (final Type argType : argTypes) {\n-                if (Type.VOID == argType) {\n+            for (final Type arg_type : argTypes) {\n+                if (Type.VOID == arg_type) {\n@@ -291,1 +154,2 @@\n-                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + size + \" vs. \" + argNames.length);\n+                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + size\n+                            + \" vs. \" + argNames.length);\n@@ -308,0 +172,1 @@\n+\n@@ -316,2 +181,2 @@\n-        this(method.getAccessFlags(), Type.getReturnType(method.getSignature()), Type.getArgumentTypes(method.getSignature()),\n-            null \/* may be overridden anyway *\/\n+        this(method.getAccessFlags(), Type.getReturnType(method.getSignature()),\n+            Type.getArgumentTypes(method.getSignature()), null \/* may be overridden anyway *\/\n@@ -319,1 +184,4 @@\n-            (method.getAccessFlags() & (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0 ? new InstructionList(getByteCodes(method)) : null, cp);\n+            ((method.getAccessFlags() & (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)\n+                ? new InstructionList(getByteCodes(method))\n+                : null,\n+            cp);\n@@ -331,1 +199,1 @@\n-                        ObjectType cType = null;\n+                        ObjectType c_type = null;\n@@ -333,2 +201,3 @@\n-                            final String cen = method.getConstantPool().getConstantString(type, Const.CONSTANT_Class);\n-                            cType = ObjectType.getInstance(cen);\n+                            final String cen = method.getConstantPool().getConstantString(type,\n+                                    Const.CONSTANT_Class);\n+                            c_type =  ObjectType.getInstance(cen);\n@@ -336,1 +205,1 @@\n-                        final int endPc = ce.getEndPC();\n+                        final int end_pc = ce.getEndPC();\n@@ -339,1 +208,1 @@\n-                        if (length == endPc) { \/\/ May happen, because end_pc is exclusive\n+                        if (length == end_pc) { \/\/ May happen, because end_pc is exclusive\n@@ -342,1 +211,1 @@\n-                            end = il.findHandle(endPc);\n+                            end = il.findHandle(end_pc);\n@@ -345,1 +214,2 @@\n-                        addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce.getHandlerPC()), cType);\n+                        addExceptionHandler(il.findHandle(ce.getStartPC()), end,\n+                                il.findHandle(ce.getHandlerPC()), c_type);\n@@ -348,3 +218,3 @@\n-                final Attribute[] cAttributes = c.getAttributes();\n-                for (final Attribute cAttribute : cAttributes) {\n-                    a = cAttribute;\n+                final Attribute[] c_attributes = c.getAttributes();\n+                for (final Attribute c_attribute : c_attributes) {\n+                    a = c_attribute;\n@@ -352,1 +222,2 @@\n-                        ((LineNumberTable) a).forEach(l -> {\n+                        final LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();\n+                        for (final LineNumber l : ln) {\n@@ -357,1 +228,1 @@\n-                        });\n+                        }\n@@ -367,1 +238,4 @@\n-                Collections.addAll(throwsList, ((ExceptionTable) a).getExceptionNames());\n+                final String[] names = ((ExceptionTable) a).getExceptionNames();\n+                for (final String name2 : names) {\n+                    addException(name2);\n+                }\n@@ -370,1 +244,4 @@\n-                runtimeAnnotations.forEach(element -> addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n+                final AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();\n+                for (final AnnotationEntry element : aes) {\n+                    addAnnotationEntry(new AnnotationEntryGen(element, cp, false));\n+                }\n@@ -377,26 +254,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        addAll(AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries()));\n-    }\n-\n-    \/**\n-     * Add an attribute to the code. Currently, the JVM knows about the LineNumberTable, LocalVariableTable and StackMap\n-     * attributes, where the former two will be generated automatically and the latter is used for the MIDP only. Other\n-     * attributes will be ignored by the JVM but do no harm.\n-     *\n-     * @param a attribute to be added\n-     *\/\n-    public void addCodeAttribute(final Attribute a) {\n-        codeAttrsList.add(a);\n-    }\n-\n-    \/**\n-     * Add an exception possibly thrown by this method.\n-     *\n-     * @param className (fully qualified) name of exception\n-     *\/\n-    public void addException(final String className) {\n-        throwsList.add(className);\n-    }\n@@ -404,14 +255,4 @@\n-    \/**\n-     * Add an exception handler, i.e., specify region where a handler is active and an instruction where the actual handling\n-     * is done.\n-     *\n-     * @param startPc Start of region (inclusive)\n-     * @param endPc End of region (inclusive)\n-     * @param handlerPc Where handling is done\n-     * @param catchType class type of handled exception or null if any exception is handled\n-     * @return new exception handler object\n-     *\/\n-    public CodeExceptionGen addExceptionHandler(final InstructionHandle startPc, final InstructionHandle endPc, final InstructionHandle handlerPc,\n-        final ObjectType catchType) {\n-        if (startPc == null || endPc == null || handlerPc == null) {\n-            throw new ClassGenException(\"Exception handler target is null instruction\");\n+    private static byte[] getByteCodes(final Method method) {\n+        final Code code = method.getCode();\n+        if (code == null) {\n+            throw new IllegalStateException(String.format(\"The method '%s' has no code.\", method));\n@@ -419,16 +260,1 @@\n-        final CodeExceptionGen c = new CodeExceptionGen(startPc, endPc, handlerPc, catchType);\n-        exceptionList.add(c);\n-        return c;\n-    }\n-\n-    \/**\n-     * Give an instruction a line number corresponding to the source code line.\n-     *\n-     * @param ih instruction to tag\n-     * @return new line number object\n-     * @see LineNumber\n-     *\/\n-    public LineNumberGen addLineNumber(final InstructionHandle ih, final int srcLine) {\n-        final LineNumberGen l = new LineNumberGen(ih, srcLine);\n-        lineNumberList.add(l);\n-        return l;\n+        return code.getCode();\n@@ -438,1 +264,1 @@\n-     * Adds a local variable to this method and assigns an index automatically.\n+     * Adds a local variable to this method.\n@@ -442,2 +268,5 @@\n-     * @param start from where the variable is valid, if this is null, it is valid from the start\n-     * @param end until where the variable is valid, if this is null, it is valid to the end\n+     * @param slot the index of the local variable, if type is long or double, the next available\n+     * index is slot+2\n+     * @param start from where the variable is valid\n+     * @param end until where the variable is valid\n+     * @param orig_index the index of the local variable prior to any modifications\n@@ -447,2 +276,19 @@\n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final InstructionHandle start, final InstructionHandle end) {\n-        return addLocalVariable(name, type, maxLocals, start, end);\n+    public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,\n+            final InstructionHandle start, final InstructionHandle end, final int orig_index ) {\n+        final byte t = type.getType();\n+        if (t != Const.T_ADDRESS) {\n+            final int add = type.getSize();\n+            if (slot + add > maxLocals) {\n+                maxLocals = slot + add;\n+            }\n+            final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, orig_index);\n+            int i;\n+            if ((i = variableList.indexOf(l)) >= 0) {\n+                variableList.set(i, l);\n+            } else {\n+                variableList.add(l);\n+            }\n+            return l;\n+        }\n+        throw new IllegalArgumentException(\"Can not use \" + type\n+                + \" as type for local variable\");\n@@ -451,0 +297,1 @@\n+\n@@ -456,1 +303,2 @@\n-     * @param slot the index of the local variable, if type is long or double, the next available index is slot+2\n+     * @param slot the index of the local variable, if type is long or double, the next available\n+     * index is slot+2\n@@ -462,1 +310,2 @@\n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end) {\n+    public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,\n+            final InstructionHandle start, final InstructionHandle end ) {\n@@ -467,1 +316,1 @@\n-     * Adds a local variable to this method.\n+     * Adds a local variable to this method and assigns an index automatically.\n@@ -471,4 +320,4 @@\n-     * @param slot the index of the local variable, if type is long or double, the next available index is slot+2\n-     * @param start from where the variable is valid\n-     * @param end until where the variable is valid\n-     * @param origIndex the index of the local variable prior to any modifications\n+     * @param start from where the variable is valid, if this is null,\n+     * it is valid from the start\n+     * @param end until where the variable is valid, if this is null,\n+     * it is valid to the end\n@@ -478,18 +327,3 @@\n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end,\n-        final int origIndex) {\n-        final byte t = type.getType();\n-        if (t != Const.T_ADDRESS) {\n-            final int add = type.getSize();\n-            if (slot + add > maxLocals) {\n-                maxLocals = slot + add;\n-            }\n-            final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, origIndex);\n-            int i;\n-            if ((i = variableList.indexOf(l)) >= 0) {\n-                variableList.set(i, l);\n-            } else {\n-                variableList.add(l);\n-            }\n-            return l;\n-        }\n-        throw new IllegalArgumentException(\"Can not use \" + type + \" as type for local variable\");\n+    public LocalVariableGen addLocalVariable( final String name, final Type type, final InstructionHandle start,\n+            final InstructionHandle end ) {\n+        return addLocalVariable(name, type, maxLocals, start, end);\n@@ -498,0 +332,1 @@\n+\n@@ -499,1 +334,2 @@\n-     * Add observer for this object.\n+     * Remove a local variable, its slot will not be reused, if you do not use\n+     * addLocalVariable with an explicit index argument.\n@@ -501,5 +337,2 @@\n-    public void addObserver(final MethodObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n-        }\n-        observers.add(o);\n+    public void removeLocalVariable(final LocalVariableGen l) {\n+        variableList.remove(l);\n@@ -508,17 +341,0 @@\n-    public void addParameterAnnotation(final int parameterIndex, final AnnotationEntryGen annotation) {\n-        ensureExistingParameterAnnotationsUnpacked();\n-        if (!hasParameterAnnotations) {\n-            @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-            final List<AnnotationEntryGen>[] parmList = (List<AnnotationEntryGen>[])new List[argTypes.length];\n-            paramAnnotations = parmList;\n-            hasParameterAnnotations = true;\n-        }\n-        final List<AnnotationEntryGen> existingAnnotations = paramAnnotations[parameterIndex];\n-        if (existingAnnotations != null) {\n-            existingAnnotations.add(annotation);\n-        } else {\n-            final List<AnnotationEntryGen> l = new ArrayList<>();\n-            l.add(annotation);\n-            paramAnnotations[parameterIndex] = l;\n-        }\n-    }\n@@ -527,1 +343,1 @@\n-     * @since 6.0\n+     * Remove all local variables.\n@@ -529,14 +345,2 @@\n-    public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        if (!hasParameterAnnotations) {\n-            return;\n-        }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n-        if (attrs != null) {\n-            addAll(attrs);\n-        }\n-    }\n-\n-    private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n-        addAll(attrs);\n-        return attrs;\n+    public void removeLocalVariables() {\n+        variableList.clear();\n@@ -545,8 +349,0 @@\n-    private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        if (!hasParameterAnnotations) {\n-            return Attribute.EMPTY_ARRAY;\n-        }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n-        addAll(attrs);\n-        return attrs;\n-    }\n@@ -554,10 +350,16 @@\n-    private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n-        final LocalVariable[] lv = lvt.getLocalVariableTable();\n-        for (final LocalVariable element : localVariableTypeTable.getLocalVariableTypeTable()) {\n-            for (final LocalVariable l : lv) {\n-                if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n-                    element.setLength(l.getLength());\n-                    element.setStartPC(l.getStartPC());\n-                    element.setIndex(l.getIndex());\n-                    break;\n-                }\n+    \/*\n+     * If the range of the variable has not been set yet, it will be set to be valid from\n+     * the start to the end of the instruction list.\n+     *\n+     * @return array of declared local variables sorted by index\n+     *\/\n+    public LocalVariableGen[] getLocalVariables() {\n+        final int size = variableList.size();\n+        final LocalVariableGen[] lg = new LocalVariableGen[size];\n+        variableList.toArray(lg);\n+        for (int i = 0; i < size; i++) {\n+            if ((lg[i].getStart() == null) && (il != null)) {\n+                lg[i].setStart(il.getStart());\n+            }\n+            if ((lg[i].getEnd() == null) && (il != null)) {\n+                lg[i].setEnd(il.getEnd());\n@@ -566,0 +368,4 @@\n+        if (size > 1) {\n+            Arrays.sort(lg, (o1, o2) -> o1.getIndex() - o2.getIndex());\n+        }\n+        return lg;\n@@ -568,0 +374,1 @@\n+\n@@ -569,1 +376,1 @@\n-     * @return deep copy of this method\n+     * @return `LocalVariableTable' attribute of all the local variables of this method.\n@@ -571,6 +378,6 @@\n-    public MethodGen copy(final String className, final ConstantPoolGen cp) {\n-        final Method m = ((MethodGen) clone()).getMethod();\n-        final MethodGen mg = new MethodGen(m, className, super.getConstantPool());\n-        if (super.getConstantPool() != cp) {\n-            mg.setConstantPool(cp);\n-            mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n+    public LocalVariableTable getLocalVariableTable( final ConstantPoolGen cp ) {\n+        final LocalVariableGen[] lg = getLocalVariables();\n+        final int size = lg.length;\n+        final LocalVariable[] lv = new LocalVariable[size];\n+        for (int i = 0; i < size; i++) {\n+            lv[i] = lg[i].getLocalVariable(cp);\n@@ -578,1 +385,2 @@\n-        return mg;\n+        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp\n+                .getConstantPool());\n@@ -582,4 +390,1 @@\n-     * Goes through the attributes on the method and identifies any that are RuntimeParameterAnnotations, extracting their\n-     * contents and storing them as parameter annotations. There are two kinds of parameter annotation - visible and\n-     * invisible. Once they have been unpacked, these attributes are deleted. (The annotations will be rebuilt as attributes\n-     * when someone builds a Method object out of this MethodGen object).\n+     * @return `LocalVariableTypeTable' attribute of this method.\n@@ -587,42 +392,2 @@\n-    private void ensureExistingParameterAnnotationsUnpacked() {\n-        if (haveUnpackedParameterAnnotations) {\n-            return;\n-        }\n-        \/\/ Find attributes that contain parameter annotation data\n-        final Attribute[] attrs = getAttributes();\n-        ParameterAnnotations paramAnnVisAttr = null;\n-        ParameterAnnotations paramAnnInvisAttr = null;\n-        for (final Attribute attribute : attrs) {\n-            if (attribute instanceof ParameterAnnotations) {\n-                \/\/ Initialize paramAnnotations\n-                if (!hasParameterAnnotations) {\n-                    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-                    final List<AnnotationEntryGen>[] parmList = (List<AnnotationEntryGen>[])new List[argTypes.length];\n-                    paramAnnotations = parmList;\n-                    Arrays.setAll(paramAnnotations, i -> new ArrayList<>());\n-                }\n-                hasParameterAnnotations = true;\n-                final ParameterAnnotations rpa = (ParameterAnnotations) attribute;\n-                if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n-                    paramAnnVisAttr = rpa;\n-                } else {\n-                    paramAnnInvisAttr = rpa;\n-                }\n-                final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();\n-                for (int j = 0; j < parameterAnnotationEntries.length; j++) {\n-                    \/\/ This returns Annotation[] ...\n-                    final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];\n-                    \/\/ ... which needs transforming into an AnnotationGen[] ...\n-                    final List<AnnotationEntryGen> mutable = makeMutableVersion(immutableArray.getAnnotationEntries());\n-                    \/\/ ... then add these to any we already know about\n-                    paramAnnotations[j].addAll(mutable);\n-                }\n-            }\n-        }\n-        if (paramAnnVisAttr != null) {\n-            removeAttribute(paramAnnVisAttr);\n-        }\n-        if (paramAnnInvisAttr != null) {\n-            removeAttribute(paramAnnInvisAttr);\n-        }\n-        haveUnpackedParameterAnnotations = true;\n+    public LocalVariableTypeTable getLocalVariableTypeTable() {\n+        return localVariableTypeTable;\n@@ -632,2 +397,1 @@\n-     * Return value as defined by given BCELComparator strategy. By default two MethodGen objects are said to be equal when\n-     * their names and signatures are equal.\n+     * Give an instruction a line number corresponding to the source code line.\n@@ -635,1 +399,3 @@\n-     * @see Object#equals(Object)\n+     * @param ih instruction to tag\n+     * @return new line number object\n+     * @see LineNumber\n@@ -637,3 +403,4 @@\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n+    public LineNumberGen addLineNumber( final InstructionHandle ih, final int srcLine ) {\n+        final LineNumberGen l = new LineNumberGen(ih, srcLine);\n+        lineNumberList.add(l);\n+        return l;\n@@ -642,2 +409,1 @@\n-    \/\/ J5TODO: Should paramAnnotations be an array of arrays? Rather than an array of lists, this\n-    \/\/ is more likely to suggest to the caller it is readonly (which a List does not).\n+\n@@ -645,3 +411,1 @@\n-     * Return a list of AnnotationGen objects representing parameter annotations\n-     *\n-     * @since 6.0\n+     * Remove a line number.\n@@ -649,6 +413,2 @@\n-    public List<AnnotationEntryGen> getAnnotationsOnParameter(final int i) {\n-        ensureExistingParameterAnnotationsUnpacked();\n-        if (!hasParameterAnnotations || i > argTypes.length) {\n-            return null;\n-        }\n-        return paramAnnotations[i];\n+    public void removeLineNumber( final LineNumberGen l ) {\n+        lineNumberList.remove(l);\n@@ -657,3 +417,0 @@\n-    public String getArgumentName(final int i) {\n-        return argNames[i];\n-    }\n@@ -661,2 +418,5 @@\n-    public String[] getArgumentNames() {\n-        return argNames.clone();\n+    \/**\n+     * Remove all line numbers.\n+     *\/\n+    public void removeLineNumbers() {\n+        lineNumberList.clear();\n@@ -665,2 +425,8 @@\n-    public Type getArgumentType(final int i) {\n-        return argTypes[i];\n+\n+    \/*\n+     * @return array of line numbers\n+     *\/\n+    public LineNumberGen[] getLineNumbers() {\n+        final LineNumberGen[] lg = new LineNumberGen[lineNumberList.size()];\n+        lineNumberList.toArray(lg);\n+        return lg;\n@@ -669,2 +435,12 @@\n-    public Type[] getArgumentTypes() {\n-        return argTypes.clone();\n+\n+    \/**\n+     * @return `LineNumberTable' attribute of all the local variables of this method.\n+     *\/\n+    public LineNumberTable getLineNumberTable( final ConstantPoolGen cp ) {\n+        final int size = lineNumberList.size();\n+        final LineNumber[] ln = new LineNumber[size];\n+        for (int i = 0; i < size; i++) {\n+            ln[i] = lineNumberList.get(i).getLineNumber();\n+        }\n+        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + ln.length * 4, ln, cp\n+                .getConstantPool());\n@@ -673,0 +449,1 @@\n+\n@@ -674,1 +451,9 @@\n-     * @return class that contains this method\n+     * Add an exception handler, i.e., specify region where a handler is active and an\n+     * instruction where the actual handling is done.\n+     *\n+     * @param start_pc Start of region (inclusive)\n+     * @param end_pc End of region (inclusive)\n+     * @param handler_pc Where handling is done\n+     * @param catch_type class type of handled exception or null if any\n+     * exception is handled\n+     * @return new exception handler object\n@@ -676,2 +461,8 @@\n-    public String getClassName() {\n-        return className;\n+    public CodeExceptionGen addExceptionHandler( final InstructionHandle start_pc,\n+            final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type ) {\n+        if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {\n+            throw new ClassGenException(\"Exception handler target is null instruction\");\n+        }\n+        final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);\n+        exceptionList.add(c);\n+        return c;\n@@ -680,0 +471,1 @@\n+\n@@ -681,1 +473,1 @@\n-     * @return all attributes of this method.\n+     * Remove an exception handler.\n@@ -683,2 +475,2 @@\n-    public Attribute[] getCodeAttributes() {\n-        return codeAttrsList.toArray(Attribute.EMPTY_ARRAY);\n+    public void removeExceptionHandler( final CodeExceptionGen c ) {\n+        exceptionList.remove(c);\n@@ -687,0 +479,1 @@\n+\n@@ -688,1 +481,1 @@\n-     * @return code exceptions for 'Code' attribute\n+     * Remove all line numbers.\n@@ -690,5 +483,2 @@\n-    private CodeException[] getCodeExceptions() {\n-        final int size = exceptionList.size();\n-        final CodeException[] cExc = new CodeException[size];\n-        Arrays.setAll(cExc, i -> exceptionList.get(i).getCodeException(super.getConstantPool()));\n-        return cExc;\n+    public void removeExceptionHandlers() {\n+        exceptionList.clear();\n@@ -697,0 +487,1 @@\n+\n@@ -701,1 +492,3 @@\n-        return exceptionList.toArray(CodeExceptionGen.EMPTY_ARRAY);\n+        final CodeExceptionGen[] cg = new CodeExceptionGen[exceptionList.size()];\n+        exceptionList.toArray(cg);\n+        return cg;\n@@ -704,2 +497,3 @@\n-    \/*\n-     * @return array of thrown exceptions\n+\n+    \/**\n+     * @return code exceptions for `Code' attribute\n@@ -707,2 +501,8 @@\n-    public String[] getExceptions() {\n-        return throwsList.toArray(Const.EMPTY_STRING_ARRAY);\n+    private CodeException[] getCodeExceptions() {\n+        final int size = exceptionList.size();\n+        final CodeException[] c_exc = new CodeException[size];\n+        for (int i = 0; i < size; i++) {\n+            final CodeExceptionGen c =  exceptionList.get(i);\n+            c_exc[i] = c.getCodeException(super.getConstantPool());\n+        }\n+        return c_exc;\n@@ -711,0 +511,1 @@\n+\n@@ -712,1 +513,3 @@\n-     * @return 'Exceptions' attribute of all the exceptions thrown by this method.\n+     * Add an exception possibly thrown by this method.\n+     *\n+     * @param className (fully qualified) name of exception\n@@ -714,5 +517,2 @@\n-    private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {\n-        final int size = throwsList.size();\n-        final int[] ex = new int[size];\n-        Arrays.setAll(ex, i -> cp.addClass(throwsList.get(i)));\n-        return new ExceptionTable(cp.addUtf8(\"Exceptions\"), 2 + 2 * size, ex, cp.getConstantPool());\n+    public void addException( final String className ) {\n+        throwsList.add(className);\n@@ -721,3 +521,0 @@\n-    public InstructionList getInstructionList() {\n-        return il;\n-    }\n@@ -725,2 +522,2 @@\n-    \/*\n-     * @return array of line numbers\n+    \/**\n+     * Remove an exception.\n@@ -728,2 +525,2 @@\n-    public LineNumberGen[] getLineNumbers() {\n-        return lineNumberList.toArray(LineNumberGen.EMPTY_ARRAY);\n+    public void removeException( final String c ) {\n+        throwsList.remove(c);\n@@ -732,0 +529,1 @@\n+\n@@ -733,1 +531,1 @@\n-     * @return 'LineNumberTable' attribute of all the local variables of this method.\n+     * Remove all exceptions.\n@@ -735,5 +533,2 @@\n-    public LineNumberTable getLineNumberTable(final ConstantPoolGen cp) {\n-        final int size = lineNumberList.size();\n-        final LineNumber[] ln = new LineNumber[size];\n-        Arrays.setAll(ln, i -> lineNumberList.get(i).getLineNumber());\n-        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + ln.length * 4, ln, cp.getConstantPool());\n+    public void removeExceptions() {\n+        throwsList.clear();\n@@ -742,0 +537,1 @@\n+\n@@ -743,4 +539,1 @@\n-     * If the range of the variable has not been set yet, it will be set to be valid from the start to the end of the\n-     * instruction list.\n-     *\n-     * @return array of declared local variables sorted by index\n+     * @return array of thrown exceptions\n@@ -748,4 +541,11 @@\n-    public LocalVariableGen[] getLocalVariables() {\n-        final int size = variableList.size();\n-        final LocalVariableGen[] lg = new LocalVariableGen[size];\n-        variableList.toArray(lg);\n+    public String[] getExceptions() {\n+        return throwsList.toArray(new String[0]);\n+    }\n+\n+\n+    \/**\n+     * @return `Exceptions' attribute of all the exceptions thrown by this method.\n+     *\/\n+    private ExceptionTable getExceptionTable( final ConstantPoolGen cp ) {\n+        final int size = throwsList.size();\n+        final int[] ex = new int[size];\n@@ -753,6 +553,1 @@\n-            if (lg[i].getStart() == null && il != null) {\n-                lg[i].setStart(il.getStart());\n-            }\n-            if (lg[i].getEnd() == null && il != null) {\n-                lg[i].setEnd(il.getEnd());\n-            }\n+            ex[i] = cp.addClass(throwsList.get(i));\n@@ -760,4 +555,1 @@\n-        if (size > 1) {\n-            Arrays.sort(lg, Comparator.comparingInt(LocalVariableGen::getIndex));\n-        }\n-        return lg;\n+        return new ExceptionTable(cp.addUtf8(\"Exceptions\"), 2 + 2 * size, ex, cp.getConstantPool());\n@@ -766,0 +558,1 @@\n+\n@@ -767,1 +560,7 @@\n-     * @return 'LocalVariableTable' attribute of all the local variables of this method.\n+     * Add an attribute to the code. Currently, the JVM knows about the\n+     * LineNumberTable, LocalVariableTable and StackMap attributes,\n+     * where the former two will be generated automatically and the\n+     * latter is used for the MIDP only. Other attributes will be\n+     * ignored by the JVM but do no harm.\n+     *\n+     * @param a attribute to be added\n@@ -769,6 +568,2 @@\n-    public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {\n-        final LocalVariableGen[] lg = getLocalVariables();\n-        final int size = lg.length;\n-        final LocalVariable[] lv = new LocalVariable[size];\n-        Arrays.setAll(lv, i -> lg[i].getLocalVariable(cp));\n-        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp.getConstantPool());\n+    public void addCodeAttribute( final Attribute a ) {\n+        codeAttrsList.add(a);\n@@ -777,0 +572,1 @@\n+\n@@ -778,1 +574,1 @@\n-     * @return 'LocalVariableTypeTable' attribute of this method.\n+     * Remove the LocalVariableTypeTable\n@@ -780,2 +576,2 @@\n-    public LocalVariableTypeTable getLocalVariableTypeTable() {\n-        return localVariableTypeTable;\n+    public void removeLocalVariableTypeTable( ) {\n+        localVariableTypeTable = null;\n@@ -784,2 +580,5 @@\n-    public int getMaxLocals() {\n-        return maxLocals;\n+    \/**\n+     * Remove a code attribute.\n+     *\/\n+    public void removeCodeAttribute( final Attribute a ) {\n+        codeAttrsList.remove(a);\n@@ -788,3 +587,0 @@\n-    public int getMaxStack() {\n-        return maxStack;\n-    }\n@@ -793,4 +589,1 @@\n-     * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively, before calling this method\n-     * (the same applies for max locals).\n-     *\n-     * @return method object\n+     * Remove all code attributes.\n@@ -798,10 +591,87 @@\n-    public Method getMethod() {\n-        final String signature = getSignature();\n-        final ConstantPoolGen cp = super.getConstantPool();\n-        final int nameIndex = cp.addUtf8(super.getName());\n-        final int signatureIndex = cp.addUtf8(signature);\n-        \/*\n-         * Also updates positions of instructions, i.e., their indices\n-         *\/\n-        final byte[] byteCode = il != null ? il.getByteCode() : null;\n-        LineNumberTable lnt = null;\n+    public void removeCodeAttributes() {\n+        localVariableTypeTable = null;\n+        codeAttrsList.clear();\n+    }\n+\n+\n+    \/**\n+     * @return all attributes of this method.\n+     *\/\n+    public Attribute[] getCodeAttributes() {\n+        return codeAttrsList.toArray(new Attribute[0]);\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n+        for (final Attribute attr : attrs) {\n+            addAttribute(attr);\n+        }\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        if (!hasParameterAnnotations) {\n+            return;\n+        }\n+        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n+        if (attrs != null) {\n+            for (final Attribute attr : attrs) {\n+                addAttribute(attr);\n+            }\n+        }\n+    }\n+\n+    private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n+        for (final Attribute attr : attrs) {\n+            addAttribute(attr);\n+        }\n+        return attrs;\n+    }\n+\n+    private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        if (!hasParameterAnnotations) {\n+            return new Attribute[0];\n+        }\n+        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n+        for (final Attribute attr : attrs) {\n+            addAttribute(attr);\n+        }\n+        return attrs;\n+    }\n+\n+    \/**\n+     * Would prefer to make this private, but need a way to test if client is\n+     * using BCEL version 6.5.0 or later that contains fix for BCEL-329.\n+     * @since 6.5.0\n+     *\/\n+    public void removeRuntimeAttributes(final Attribute[] attrs) {\n+        for (final Attribute attr : attrs) {\n+            removeAttribute(attr);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,\n+     * before calling this method (the same applies for max locals).\n+     *\n+     * @return method object\n+     *\/\n+    public Method getMethod() {\n+        final String signature = getSignature();\n+        final ConstantPoolGen _cp = super.getConstantPool();\n+        final int name_index = _cp.addUtf8(super.getName());\n+        final int signature_index = _cp.addUtf8(signature);\n+        \/* Also updates positions of instructions, i.e., their indices\n+         *\/\n+        byte[] byte_code = null;\n+        if (il != null) {\n+            byte_code = il.getByteCode();\n+        }\n+        LineNumberTable lnt = null;\n@@ -809,2 +679,1 @@\n-        \/*\n-         * Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)\n+        \/* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)\n@@ -812,3 +681,3 @@\n-        if (!variableList.isEmpty() && !stripAttributes) {\n-            updateLocalVariableTable(getLocalVariableTable(cp));\n-            addCodeAttribute(lvt = getLocalVariableTable(cp));\n+        if ((variableList.size() > 0) && !stripAttributes) {\n+            updateLocalVariableTable(getLocalVariableTable(_cp));\n+            addCodeAttribute(lvt = getLocalVariableTable(_cp));\n@@ -817,2 +686,1 @@\n-            \/\/ LocalVariable length in LocalVariableTypeTable is not updated automatically. It's a difference with\n-            \/\/ LocalVariableTable.\n+            \/\/ LocalVariable length in LocalVariableTypeTable is not updated automatically. It's a difference with LocalVariableTable.\n@@ -824,2 +692,2 @@\n-        if (!lineNumberList.isEmpty() && !stripAttributes) {\n-            addCodeAttribute(lnt = getLineNumberTable(cp));\n+        if ((lineNumberList.size() > 0) && !stripAttributes) {\n+            addCodeAttribute(lnt = getLineNumberTable(_cp));\n@@ -827,3 +695,2 @@\n-        final Attribute[] codeAttrs = getCodeAttributes();\n-        \/*\n-         * Each attribute causes 6 additional header bytes\n+        final Attribute[] code_attrs = getCodeAttributes();\n+        \/* Each attribute causes 6 additional header bytes\n@@ -831,3 +698,3 @@\n-        int attrsLen = 0;\n-        for (final Attribute codeAttr : codeAttrs) {\n-            attrsLen += codeAttr.getLength() + 6;\n+        int attrs_len = 0;\n+        for (final Attribute code_attr : code_attrs) {\n+            attrs_len += code_attr.getLength() + 6;\n@@ -835,2 +702,2 @@\n-        final CodeException[] cExc = getCodeExceptions();\n-        final int excLen = cExc.length * 8; \/\/ Every entry takes 8 bytes\n+        final CodeException[] c_exc = getCodeExceptions();\n+        final int exc_len = c_exc.length * 8; \/\/ Every entry takes 8 bytes\n@@ -838,1 +705,1 @@\n-        if (byteCode != null && !isAbstract() && !isNative()) {\n+        if ((il != null) && !isAbstract() && !isNative()) {\n@@ -846,4 +713,4 @@\n-            code = new Code(cp.addUtf8(\"Code\"), 8 + byteCode.length + \/\/ prologue byte code\n-                2 + excLen + \/\/ exceptions\n-                2 + attrsLen, \/\/ attributes\n-                maxStack, maxLocals, byteCode, cExc, codeAttrs, cp.getConstantPool());\n+            code = new Code(_cp.addUtf8(\"Code\"), 8 + byte_code.length + \/\/ prologue byte code\n+                    2 + exc_len + \/\/ exceptions\n+                    2 + attrs_len, \/\/ attributes\n+                    maxStack, maxLocals, byte_code, c_exc, code_attrs, _cp.getConstantPool());\n@@ -852,2 +719,2 @@\n-        final Attribute[] annotations = addRuntimeAnnotationsAsAttribute(cp);\n-        final Attribute[] parameterAnnotations = addRuntimeParameterAnnotationsAsAttribute(cp);\n+        final Attribute[] annotations = addRuntimeAnnotationsAsAttribute(_cp);\n+        final Attribute[] parameterAnnotations = addRuntimeParameterAnnotationsAsAttribute(_cp);\n@@ -855,3 +722,3 @@\n-        if (!throwsList.isEmpty()) {\n-            addAttribute(et = getExceptionTable(cp));\n-            \/\/ Add 'Exceptions' if there are \"throws\" clauses\n+        if (throwsList.size() > 0) {\n+            addAttribute(et = getExceptionTable(_cp));\n+            \/\/ Add `Exceptions' if there are \"throws\" clauses\n@@ -859,1 +726,2 @@\n-        final Method m = new Method(super.getAccessFlags(), nameIndex, signatureIndex, getAttributes(), cp.getConstantPool());\n+        final Method m = new Method(super.getAccessFlags(), name_index, signature_index, getAttributes(), _cp\n+                .getConstantPool());\n@@ -881,2 +749,16 @@\n-    public Type getReturnType() {\n-        return getType();\n+    private void updateLocalVariableTable(final LocalVariableTable a) {\n+        final LocalVariable[] lv = a.getLocalVariableTable();\n+        removeLocalVariables();\n+        for (final LocalVariable l : lv) {\n+            InstructionHandle start = il.findHandle(l.getStartPC());\n+            final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());\n+            \/\/ Repair malformed handles\n+            if (null == start) {\n+                start = il.getStart();\n+            }\n+            \/\/ end == null => live to end of method\n+            \/\/ Since we are recreating the LocalVaraible, we must\n+            \/\/ propagate the orig_index to new copy.\n+            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l\n+                    .getIndex(), start, end, l.getOrigIndex());\n+        }\n@@ -885,3 +767,14 @@\n-    @Override\n-    public String getSignature() {\n-        return Type.getMethodSignature(super.getType(), argTypes);\n+    private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n+        final LocalVariable[] lv = lvt.getLocalVariableTable();\n+        final LocalVariable[] lvg = localVariableTypeTable.getLocalVariableTypeTable();\n+\n+        for (final LocalVariable element : lvg) {\n+            for (final LocalVariable l : lv) {\n+                if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n+                    element.setLength(l.getLength());\n+                    element.setStartPC(l.getStartPC());\n+                    element.setIndex(l.getIndex());\n+                    break;\n+                }\n+            }\n+        }\n@@ -890,0 +783,1 @@\n+\n@@ -891,4 +785,3 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the method's name XOR\n-     * signature.\n-     *\n-     * @see Object#hashCode()\n+     * Remove all NOPs from the instruction list (if possible) and update every\n+     * object referring to them, i.e., branch instructions, local variables and\n+     * exception handlers.\n@@ -896,9 +789,19 @@\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] mutableArray) {\n-        final List<AnnotationEntryGen> result = new ArrayList<>();\n-        for (final AnnotationEntry element : mutableArray) {\n-            result.add(new AnnotationEntryGen(element, getConstantPool(), false));\n+    public void removeNOPs() {\n+        if (il != null) {\n+            InstructionHandle next;\n+            \/* Check branch instructions.\n+             *\/\n+            for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {\n+                next = ih.getNext();\n+                if ((next != null) && (ih.getInstruction() instanceof NOP)) {\n+                    try {\n+                        il.delete(ih);\n+                    } catch (final TargetLostException e) {\n+                        for (final InstructionHandle target : e.getTargets()) {\n+                            for (final InstructionTargeter targeter : target.getTargeters()) {\n+                                targeter.updateTarget(target, next);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n@@ -906,1 +809,0 @@\n-        return result;\n@@ -909,0 +811,1 @@\n+\n@@ -910,1 +813,1 @@\n-     * Remove a code attribute.\n+     * Set maximum number of local variables.\n@@ -912,2 +815,2 @@\n-    public void removeCodeAttribute(final Attribute a) {\n-        codeAttrsList.remove(a);\n+    public void setMaxLocals( final int m ) {\n+        maxLocals = m;\n@@ -916,6 +819,3 @@\n-    \/**\n-     * Remove all code attributes.\n-     *\/\n-    public void removeCodeAttributes() {\n-        localVariableTypeTable = null;\n-        codeAttrsList.clear();\n+\n+    public int getMaxLocals() {\n+        return maxLocals;\n@@ -924,0 +824,1 @@\n+\n@@ -925,1 +826,1 @@\n-     * Remove an exception.\n+     * Set maximum stack size for this method.\n@@ -927,2 +828,2 @@\n-    public void removeException(final String c) {\n-        throwsList.remove(c);\n+    public void setMaxStack( final int m ) { \/\/ TODO could be package-protected?\n+        maxStack = m;\n@@ -931,5 +832,3 @@\n-    \/**\n-     * Remove an exception handler.\n-     *\/\n-    public void removeExceptionHandler(final CodeExceptionGen c) {\n-        exceptionList.remove(c);\n+\n+    public int getMaxStack() {\n+        return maxStack;\n@@ -938,2 +837,2 @@\n-    \/**\n-     * Remove all line numbers.\n+\n+    \/** @return class that contains this method\n@@ -941,2 +840,2 @@\n-    public void removeExceptionHandlers() {\n-        exceptionList.clear();\n+    public String getClassName() {\n+        return className;\n@@ -945,5 +844,3 @@\n-    \/**\n-     * Remove all exceptions.\n-     *\/\n-    public void removeExceptions() {\n-        throwsList.clear();\n+\n+    public void setClassName( final String class_name ) { \/\/ TODO could be package-protected?\n+        this.className = class_name;\n@@ -952,5 +849,3 @@\n-    \/**\n-     * Remove a line number.\n-     *\/\n-    public void removeLineNumber(final LineNumberGen l) {\n-        lineNumberList.remove(l);\n+\n+    public void setReturnType( final Type return_type ) {\n+        setType(return_type);\n@@ -959,5 +854,3 @@\n-    \/**\n-     * Remove all line numbers.\n-     *\/\n-    public void removeLineNumbers() {\n-        lineNumberList.clear();\n+\n+    public Type getReturnType() {\n+        return getType();\n@@ -966,6 +859,3 @@\n-    \/**\n-     * Remove a local variable, its slot will not be reused, if you do not use addLocalVariable with an explicit index\n-     * argument.\n-     *\/\n-    public void removeLocalVariable(final LocalVariableGen l) {\n-        variableList.remove(l);\n+\n+    public void setArgumentTypes( final Type[] arg_types ) {\n+        this.argTypes = arg_types;\n@@ -974,5 +864,3 @@\n-    \/**\n-     * Remove all local variables.\n-     *\/\n-    public void removeLocalVariables() {\n-        variableList.clear();\n+\n+    public Type[] getArgumentTypes() {\n+        return argTypes.clone();\n@@ -981,5 +869,3 @@\n-    \/**\n-     * Remove the LocalVariableTypeTable\n-     *\/\n-    public void removeLocalVariableTypeTable() {\n-        localVariableTypeTable = null;\n+\n+    public void setArgumentType( final int i, final Type type ) {\n+        argTypes[i] = type;\n@@ -988,25 +874,3 @@\n-    \/**\n-     * Remove all NOPs from the instruction list (if possible) and update every object referring to them, i.e., branch\n-     * instructions, local variables and exception handlers.\n-     *\/\n-    public void removeNOPs() {\n-        if (il != null) {\n-            InstructionHandle next;\n-            \/*\n-             * Check branch instructions.\n-             *\/\n-            for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {\n-                next = ih.getNext();\n-                if (next != null && ih.getInstruction() instanceof NOP) {\n-                    try {\n-                        il.delete(ih);\n-                    } catch (final TargetLostException e) {\n-                        for (final InstructionHandle target : e.getTargets()) {\n-                            for (final InstructionTargeter targeter : target.getTargeters()) {\n-                                targeter.updateTarget(target, next);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+\n+    public Type getArgumentType( final int i ) {\n+        return argTypes[i];\n@@ -1015,7 +879,3 @@\n-    \/**\n-     * Remove observer for this object.\n-     *\/\n-    public void removeObserver(final MethodObserver o) {\n-        if (observers != null) {\n-            observers.remove(o);\n-        }\n+\n+    public void setArgumentNames( final String[] arg_names ) {\n+        this.argNames = arg_names;\n@@ -1024,10 +884,3 @@\n-    \/**\n-     * Would prefer to make this private, but need a way to test if client is using BCEL version 6.5.0 or later that\n-     * contains fix for BCEL-329.\n-     *\n-     * @since 6.5.0\n-     *\/\n-    public void removeRuntimeAttributes(final Attribute[] attrs) {\n-        for (final Attribute attr : attrs) {\n-            removeAttribute(attr);\n-        }\n+\n+    public String[] getArgumentNames() {\n+        return argNames.clone();\n@@ -1036,1 +889,2 @@\n-    public void setArgumentName(final int i, final String name) {\n+\n+    public void setArgumentName( final int i, final String name ) {\n@@ -1040,3 +894,0 @@\n-    public void setArgumentNames(final String[] argNames) {\n-        this.argNames = argNames;\n-    }\n@@ -1044,2 +895,2 @@\n-    public void setArgumentType(final int i, final Type type) {\n-        argTypes[i] = type;\n+    public String getArgumentName( final int i ) {\n+        return argNames[i];\n@@ -1048,3 +899,0 @@\n-    public void setArgumentTypes(final Type[] argTypes) {\n-        this.argTypes = argTypes;\n-    }\n@@ -1052,2 +900,2 @@\n-    public void setClassName(final String className) { \/\/ TODO could be package-protected?\n-        this.className = className;\n+    public InstructionList getInstructionList() {\n+        return il;\n@@ -1056,1 +904,2 @@\n-    public void setInstructionList(final InstructionList il) { \/\/ TODO could be package-protected?\n+\n+    public void setInstructionList( final InstructionList il ) { \/\/ TODO could be package-protected?\n@@ -1060,0 +909,7 @@\n+\n+    @Override\n+    public String getSignature() {\n+        return Type.getMethodSignature(super.getType(), argTypes);\n+    }\n+\n+\n@@ -1061,1 +917,1 @@\n-     * Compute maximum number of local variables.\n+     * Computes max. stack size by performing control flow analysis.\n@@ -1063,1 +919,1 @@\n-    public void setMaxLocals() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n+    public void setMaxStack() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n@@ -1065,1 +921,13 @@\n-            int max = isStatic() ? 0 : 1;\n+            maxStack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());\n+        } else {\n+            maxStack = 0;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Compute maximum number of local variables.\n+     *\/\n+    public void setMaxLocals() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n+        if (il != null) {\n+            int max = isStatic() ? 0 : 1;\n@@ -1067,2 +935,2 @@\n-                for (final Type argType : argTypes) {\n-                    max += argType.getSize();\n+                for (final Type arg_type : argTypes) {\n+                    max += arg_type.getSize();\n@@ -1073,2 +941,4 @@\n-                if (ins instanceof LocalVariableInstruction || ins instanceof RET || ins instanceof IINC) {\n-                    final int index = ((IndexedInstruction) ins).getIndex() + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();\n+                if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)\n+                        || (ins instanceof IINC)) {\n+                    final int index = ((IndexedInstruction) ins).getIndex()\n+                            + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();\n@@ -1086,2 +956,3 @@\n-    \/**\n-     * Set maximum number of local variables.\n+\n+    \/** Do not\/Do produce attributes code attributesLineNumberTable and\n+     * LocalVariableTable, like javac -O\n@@ -1089,2 +960,2 @@\n-    public void setMaxLocals(final int m) {\n-        maxLocals = m;\n+    public void stripAttributes( final boolean flag ) {\n+        stripAttributes = flag;\n@@ -1093,0 +964,48 @@\n+    static final class BranchTarget {\n+\n+        final InstructionHandle target;\n+        final int stackDepth;\n+\n+\n+        BranchTarget(final InstructionHandle target, final int stackDepth) {\n+            this.target = target;\n+            this.stackDepth = stackDepth;\n+        }\n+    }\n+\n+    static final class BranchStack {\n+\n+        private final Stack<BranchTarget> branchTargets = new Stack<>();\n+        private final Map<InstructionHandle, BranchTarget> visitedTargets = new HashMap<>();\n+\n+\n+        public void push( final InstructionHandle target, final int stackDepth ) {\n+            if (visited(target)) {\n+                return;\n+            }\n+            branchTargets.push(visit(target, stackDepth));\n+        }\n+\n+\n+        public BranchTarget pop() {\n+            if (!branchTargets.empty()) {\n+                final BranchTarget bt = branchTargets.pop();\n+                return bt;\n+            }\n+            return null;\n+        }\n+\n+\n+        private BranchTarget visit( final InstructionHandle target, final int stackDepth ) {\n+            final BranchTarget bt = new BranchTarget(target, stackDepth);\n+            visitedTargets.put(target, bt);\n+            return bt;\n+        }\n+\n+\n+        private boolean visited( final InstructionHandle target ) {\n+            return visitedTargets.get(target) != null;\n+        }\n+    }\n+\n+\n@@ -1094,1 +1013,3 @@\n-     * Computes max. stack size by performing control flow analysis.\n+     * Computes stack usage of an instruction list by performing control flow analysis.\n+     *\n+     * @return maximum stack depth used by method\n@@ -1096,5 +1017,67 @@\n-    public void setMaxStack() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n-        if (il != null) {\n-            maxStack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());\n-        } else {\n-            maxStack = 0;\n+    public static int getMaxStack( final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et ) {\n+        final BranchStack branchTargets = new BranchStack();\n+        \/* Initially, populate the branch stack with the exception\n+         * handlers, because these aren't (necessarily) branched to\n+         * explicitly. in each case, the stack will have depth 1,\n+         * containing the exception object.\n+         *\/\n+        for (final CodeExceptionGen element : et) {\n+            final InstructionHandle handler_pc = element.getHandlerPC();\n+            if (handler_pc != null) {\n+                branchTargets.push(handler_pc, 1);\n+            }\n+        }\n+        int stackDepth = 0;\n+        int maxStackDepth = 0;\n+        InstructionHandle ih = il.getStart();\n+        while (ih != null) {\n+            final Instruction instruction = ih.getInstruction();\n+            final short opcode = instruction.getOpcode();\n+            final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);\n+            stackDepth += delta;\n+            if (stackDepth > maxStackDepth) {\n+                maxStackDepth = stackDepth;\n+            }\n+            \/\/ choose the next instruction based on whether current is a branch.\n+            if (instruction instanceof BranchInstruction) {\n+                final BranchInstruction branch = (BranchInstruction) instruction;\n+                if (instruction instanceof Select) {\n+                    \/\/ explore all of the select's targets. the default target is handled below.\n+                    final Select select = (Select) branch;\n+                    final InstructionHandle[] targets = select.getTargets();\n+                    for (final InstructionHandle target : targets) {\n+                        branchTargets.push(target, stackDepth);\n+                    }\n+                    \/\/ nothing to fall through to.\n+                    ih = null;\n+                } else if (!(branch instanceof IfInstruction)) {\n+                    \/\/ if an instruction that comes back to following PC,\n+                    \/\/ push next instruction, with stack depth reduced by 1.\n+                    if (opcode == Const.JSR || opcode == Const.JSR_W) {\n+                        branchTargets.push(ih.getNext(), stackDepth - 1);\n+                    }\n+                    ih = null;\n+                }\n+                \/\/ for all branches, the target of the branch is pushed on the branch stack.\n+                \/\/ conditional branches have a fall through case, selects don't, and\n+                \/\/ jsr\/jsr_w return to the next instruction.\n+                branchTargets.push(branch.getTarget(), stackDepth);\n+            } else {\n+                \/\/ check for instructions that terminate the method.\n+                if (opcode == Const.ATHROW || opcode == Const.RET\n+                        || (opcode >= Const.IRETURN && opcode <= Const.RETURN)) {\n+                    ih = null;\n+                }\n+            }\n+            \/\/ normal case, go to the next instruction.\n+            if (ih != null) {\n+                ih = ih.getNext();\n+            }\n+            \/\/ if we have no more instructions, see if there are any deferred branches to explore.\n+            if (ih == null) {\n+                final BranchTarget bt = branchTargets.pop();\n+                if (bt != null) {\n+                    ih = bt.target;\n+                    stackDepth = bt.stackDepth;\n+                }\n+            }\n@@ -1102,0 +1085,1 @@\n+        return maxStackDepth;\n@@ -1104,2 +1088,4 @@\n-    \/**\n-     * Set maximum stack size for this method.\n+    private List<MethodObserver> observers;\n+\n+\n+    \/** Add observer for this object.\n@@ -1107,2 +1093,5 @@\n-    public void setMaxStack(final int m) { \/\/ TODO could be package-protected?\n-        maxStack = m;\n+    public void addObserver( final MethodObserver o ) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n+        }\n+        observers.add(o);\n@@ -1111,2 +1100,7 @@\n-    public void setReturnType(final Type returnType) {\n-        setType(returnType);\n+\n+    \/** Remove observer for this object.\n+     *\/\n+    public void removeObserver( final MethodObserver o ) {\n+        if (observers != null) {\n+            observers.remove(o);\n+        }\n@@ -1115,2 +1109,4 @@\n-    \/**\n-     * Do not\/Do produce attributes code attributesLineNumberTable and LocalVariableTable, like javac -O\n+\n+    \/** Call notify() method on all observers. This method is not called\n+     * automatically whenever the state has changed, but has to be\n+     * called by the user after he has finished editing the object.\n@@ -1118,2 +1114,6 @@\n-    public void stripAttributes(final boolean flag) {\n-        stripAttributes = flag;\n+    public void update() {\n+        if (observers != null) {\n+            for (final MethodObserver observer : observers) {\n+                observer.notify(this);\n+            }\n+        }\n@@ -1122,0 +1122,1 @@\n+\n@@ -1123,2 +1124,2 @@\n-     * Return string representation close to declaration format, 'public static void main(String[]) throws IOException',\n-     * e.g.\n+     * Return string representation close to declaration format,\n+     * `public static void main(String[]) throws IOException', e.g.\n@@ -1132,1 +1133,2 @@\n-        signature = Utility.methodSignatureToString(signature, super.getName(), access, true, getLocalVariableTable(super.getConstantPool()));\n+        signature = Utility.methodSignatureToString(signature, super.getName(), access, true,\n+                getLocalVariableTable(super.getConstantPool()));\n@@ -1135,1 +1137,1 @@\n-            if (!(a instanceof Code || a instanceof ExceptionTable)) {\n+            if (!((a instanceof Code) || (a instanceof ExceptionTable))) {\n@@ -1140,1 +1142,1 @@\n-        if (!throwsList.isEmpty()) {\n+        if (throwsList.size() > 0) {\n@@ -1148,0 +1150,15 @@\n+\n+    \/** @return deep copy of this method\n+     *\/\n+    public MethodGen copy( final String className, final ConstantPoolGen cp ) {\n+        final Method m = ((MethodGen) clone()).getMethod();\n+        final MethodGen mg = new MethodGen(m, className, super.getConstantPool());\n+        if (super.getConstantPool() != cp) {\n+            mg.setConstantPool(cp);\n+            mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n+        }\n+        return mg;\n+    }\n+\n+    \/\/J5TODO: Should paramAnnotations be an array of arrays? Rather than an array of lists, this\n+    \/\/ is more likely to suggest to the caller it is readonly (which a List does not).\n@@ -1149,2 +1166,2 @@\n-     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n-     * has to be called by the user after they have finished editing the object.\n+     * Return a list of AnnotationGen objects representing parameter annotations\n+     * @since 6.0\n@@ -1152,5 +1169,4 @@\n-    public void update() {\n-        if (observers != null) {\n-            for (final MethodObserver observer : observers) {\n-                observer.notify(this);\n-            }\n+    public List<AnnotationEntryGen> getAnnotationsOnParameter(final int i) {\n+        ensureExistingParameterAnnotationsUnpacked();\n+        if (!hasParameterAnnotations || i > argTypes.length) {\n+            return null;\n@@ -1158,0 +1174,1 @@\n+        return paramAnnotations[i];\n@@ -1160,8 +1177,47 @@\n-    private void updateLocalVariableTable(final LocalVariableTable a) {\n-        removeLocalVariables();\n-        for (final LocalVariable l : a.getLocalVariableTable()) {\n-            InstructionHandle start = il.findHandle(l.getStartPC());\n-            final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());\n-            \/\/ Repair malformed handles\n-            if (null == start) {\n-                start = il.getStart();\n+    \/**\n+     * Goes through the attributes on the method and identifies any that are\n+     * RuntimeParameterAnnotations, extracting their contents and storing them\n+     * as parameter annotations. There are two kinds of parameter annotation -\n+     * visible and invisible. Once they have been unpacked, these attributes are\n+     * deleted. (The annotations will be rebuilt as attributes when someone\n+     * builds a Method object out of this MethodGen object).\n+     *\/\n+    private void ensureExistingParameterAnnotationsUnpacked()\n+    {\n+        if (haveUnpackedParameterAnnotations) {\n+            return;\n+        }\n+        \/\/ Find attributes that contain parameter annotation data\n+        final Attribute[] attrs = getAttributes();\n+        ParameterAnnotations paramAnnVisAttr = null;\n+        ParameterAnnotations paramAnnInvisAttr = null;\n+        for (final Attribute attribute : attrs) {\n+            if (attribute instanceof ParameterAnnotations)\n+            {\n+                \/\/ Initialize paramAnnotations\n+                if (!hasParameterAnnotations)\n+                {\n+                    @SuppressWarnings({\"rawtypes\", \"unchecked\"}) \/\/ OK\n+                    final List<AnnotationEntryGen>[] parmList = new List[argTypes.length];\n+                    paramAnnotations = parmList;\n+                    for (int j = 0; j < argTypes.length; j++) {\n+                        paramAnnotations[j] = new ArrayList<>();\n+                    }\n+                }\n+                hasParameterAnnotations = true;\n+                final ParameterAnnotations rpa = (ParameterAnnotations) attribute;\n+                if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n+                    paramAnnVisAttr = rpa;\n+                } else {\n+                    paramAnnInvisAttr = rpa;\n+                }\n+                final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();\n+                for (int j = 0; j < parameterAnnotationEntries.length; j++)\n+                {\n+                    \/\/ This returns Annotation[] ...\n+                    final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];\n+                    \/\/ ... which needs transforming into an AnnotationGen[] ...\n+                    final List<AnnotationEntryGen> mutable = makeMutableVersion(immutableArray.getAnnotationEntries());\n+                    \/\/ ... then add these to any we already know about\n+                    paramAnnotations[j].addAll(mutable);\n+                }\n@@ -1169,4 +1225,0 @@\n-            \/\/ end == null => live to end of method\n-            \/\/ Since we are recreating the LocalVaraible, we must\n-            \/\/ propagate the orig_index to new copy.\n-            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l.getIndex(), start, end, l.getOrigIndex());\n@@ -1174,0 +1226,81 @@\n+        if (paramAnnVisAttr != null) {\n+            removeAttribute(paramAnnVisAttr);\n+        }\n+        if (paramAnnInvisAttr != null) {\n+            removeAttribute(paramAnnInvisAttr);\n+        }\n+        haveUnpackedParameterAnnotations = true;\n+    }\n+\n+    private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] mutableArray)\n+    {\n+        final List<AnnotationEntryGen> result = new ArrayList<>();\n+        for (final AnnotationEntry element : mutableArray) {\n+            result.add(new AnnotationEntryGen(element, getConstantPool(),\n+                    false));\n+        }\n+        return result;\n+    }\n+\n+    public void addParameterAnnotation(final int parameterIndex,\n+            final AnnotationEntryGen annotation)\n+    {\n+        ensureExistingParameterAnnotationsUnpacked();\n+        if (!hasParameterAnnotations)\n+        {\n+            @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+            final List<AnnotationEntryGen>[] parmList = new List[argTypes.length];\n+            paramAnnotations = parmList;\n+            hasParameterAnnotations = true;\n+        }\n+        final List<AnnotationEntryGen> existingAnnotations = paramAnnotations[parameterIndex];\n+        if (existingAnnotations != null)\n+        {\n+            existingAnnotations.add(annotation);\n+        }\n+        else\n+        {\n+            final List<AnnotationEntryGen> l = new ArrayList<>();\n+            l.add(annotation);\n+            paramAnnotations[parameterIndex] = l;\n+        }\n+    }\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two MethodGen objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the method's name XOR signature.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MethodGen.java","additions":859,"deletions":726,"binary":false,"changes":1585,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Implement this interface if you're interested in changes to a MethodGen object and register yourself with\n- * addObserver().\n+ * Implement this interface if you're interested in changes to a MethodGen object\n+ * and register yourself with addObserver().\n+ *\n@@ -30,1 +31,1 @@\n-    void notify(MethodGen method);\n+    void notify( MethodGen method );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MethodObserver.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * <PRE>Stack: ... -&gt; ..., objectref<\/PRE>\n@@ -29,3 +30,0 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., objectref\n- * <\/PRE>\n@@ -33,1 +31,2 @@\n-public class NEW extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower, StackProducer {\n+public class NEW extends CPInstruction implements LoadClass, AllocationInstruction,\n+        ExceptionThrower, StackProducer {\n@@ -36,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -41,0 +41,1 @@\n+\n@@ -45,0 +46,15 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+            ExceptionConst.INSTANTIATION_ERROR);\n+    }\n+\n+\n+    @Override\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n+        return (ObjectType) getType(cpg);\n+    }\n+\n+\n@@ -46,2 +62,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -52,1 +70,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -61,11 +79,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.ILLEGAL_ACCESS_ERROR,\n-            ExceptionConst.INSTANTIATION_ERROR);\n-    }\n-\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        return (ObjectType) getType(cpg);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NEW.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,6 +30,2 @@\n- * NEWARRAY - Create new array of basic type (int, short, ...)\n- *\n- * <PRE>\n- * Stack: ..., count -&gt; ..., arrayref\n- * <\/PRE>\n- *\n+ * NEWARRAY -  Create new array of basic type (int, short, ...)\n+ * <PRE>Stack: ..., count -&gt; ..., arrayref<\/PRE>\n@@ -37,0 +33,1 @@\n+ *\n@@ -39,1 +36,2 @@\n-public class NEWARRAY extends Instruction implements AllocationInstruction, ExceptionThrower, StackProducer {\n+public class NEWARRAY extends Instruction implements AllocationInstruction, ExceptionThrower,\n+        StackProducer {\n@@ -43,0 +41,1 @@\n+\n@@ -44,1 +43,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -49,3 +49,0 @@\n-    public NEWARRAY(final BasicType type) {\n-        this(type.getType());\n-    }\n@@ -58,12 +55,3 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitAllocationInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitStackProducer(this);\n-        v.visitNEWARRAY(this);\n+\n+    public NEWARRAY(final BasicType type) {\n+        this(type.getType());\n@@ -72,0 +60,1 @@\n+\n@@ -74,1 +63,0 @@\n-     *\n@@ -78,1 +66,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -83,3 +71,6 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION};\n+\n+    \/**\n+     * @return numeric code for basic element type\n+     *\/\n+    public final byte getTypecode() {\n+        return type;\n@@ -88,0 +79,1 @@\n+\n@@ -95,0 +87,1 @@\n+\n@@ -96,1 +89,1 @@\n-     * @return numeric code for basic element type\n+     * @return mnemonic for instruction\n@@ -98,2 +91,3 @@\n-    public final byte getTypecode() {\n-        return type;\n+    @Override\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + com.sun.org.apache.bcel.internal.Const.getTypeName(type);\n@@ -102,0 +96,1 @@\n+\n@@ -106,1 +101,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -111,0 +106,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -112,1 +116,6 @@\n-     * @return mnemonic for instruction\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -115,2 +124,5 @@\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + com.sun.org.apache.bcel.internal.Const.getTypeName(type);\n+    public void accept( final Visitor v ) {\n+        v.visitAllocationInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitStackProducer(this);\n+        v.visitNEWARRAY(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NEWARRAY.java","additions":47,"deletions":35,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -33,0 +34,1 @@\n+\n@@ -34,2 +36,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -40,1 +44,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NOP.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * Super class for FieldOrMethod and INVOKEDYNAMIC, since they both have names and signatures\n+ * Super class for FieldOrMethod and INVOKEDYNAMIC, since they both have\n+ * names and signatures\n@@ -37,0 +38,1 @@\n+        super();\n@@ -43,9 +45,0 @@\n-    \/**\n-     * @return name of referenced method\/field.\n-     *\/\n-    public String getName(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantNameAndType cnat = getNameAndType(cpg);\n-        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n-    }\n-\n@@ -55,1 +48,1 @@\n-        return (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return  (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n@@ -57,3 +50,1 @@\n-\n-    \/**\n-     * @return signature of referenced method\/field.\n+    \/** @return signature of referenced method\/field.\n@@ -67,0 +58,8 @@\n+    \/** @return name of referenced method\/field.\n+     *\/\n+    public String getName(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantNameAndType cnat = getNameAndType(cpg);\n+        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NameSignatureInstruction.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denote entity that has both name and type. This is true for local variables, methods and fields.\n+ * Denote entity that has both name and type. This is true for local variables,\n+ * methods and fields.\n+ *\n@@ -31,0 +33,1 @@\n+\n@@ -33,1 +36,0 @@\n-    void setName(String name);\n@@ -35,1 +37,4 @@\n-    void setType(Type type);\n+    void setName( String name );\n+\n+\n+    void setType( Type type );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NamedAndTyped.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -31,0 +30,1 @@\n+ *\n@@ -34,0 +34,2 @@\n+    private final String className; \/\/ Class name of type\n+\n@@ -35,4 +37,0 @@\n-     * Constructs a new instance.\n-     *\n-     * @param className fully qualified class name, e.g. java.lang.String\n-     * @return a new instance.\n@@ -45,2 +43,0 @@\n-    private final String className; \/\/ Class name of type\n-\n@@ -48,2 +44,0 @@\n-     * Constructs a new instance.\n-     *\n@@ -53,16 +47,2 @@\n-        super(Const.T_REFERENCE, \"L\" + Utility.packageToPath(className) + \";\");\n-        this.className = Utility.pathToPackage(className);\n-    }\n-\n-    \/**\n-     * Java Virtual Machine Specification edition 2,  5.4.4 Access Control\n-     *\n-     * @throws ClassNotFoundException if the class referenced by this type can't be found\n-     *\/\n-    public boolean accessibleTo(final ObjectType accessor) throws ClassNotFoundException {\n-        final JavaClass jc = Repository.lookupClass(className);\n-        if (jc.isPublic()) {\n-            return true;\n-        }\n-        final JavaClass acc = Repository.lookupClass(accessor.className);\n-        return acc.getPackageName().equals(jc.getPackageName());\n+        super(Const.T_REFERENCE, \"L\" + className.replace('.', '\/') + \";\");\n+        this.className = className.replace('\/', '.');\n@@ -71,7 +51,0 @@\n-    \/**\n-     * @return true if both type objects refer to the same class.\n-     *\/\n-    @Override\n-    public boolean equals(final Object type) {\n-        return type instanceof ObjectType && ((ObjectType) type).className.equals(className);\n-    }\n@@ -79,2 +52,1 @@\n-    \/**\n-     * @return name of referenced class\n+    \/** @return name of referenced class\n@@ -82,1 +54,0 @@\n-    @Override\n@@ -87,2 +58,2 @@\n-    \/**\n-     * @return a hash code value for the object.\n+\n+    \/** @return a hash code value for the object.\n@@ -95,0 +66,11 @@\n+\n+    \/** @return true if both type objects refer to the same class.\n+     *\/\n+    @Override\n+    public boolean equals( final Object type ) {\n+        return (type instanceof ObjectType)\n+                ? ((ObjectType) type).className.equals(className)\n+                : false;\n+    }\n+\n+\n@@ -96,3 +78,5 @@\n-     * If \"this\" doesn't reference a class, it references an interface or a non-existant entity.\n-     * @deprecated (since 6.0) this method returns an inaccurate result if the class or interface referenced cannot be\n-     *             found: use referencesClassExact() instead\n+     * If \"this\" doesn't reference a class, it references an interface\n+     * or a non-existant entity.\n+     * @deprecated (since 6.0) this method returns an inaccurate result\n+     *   if the class or interface referenced cannot\n+     *   be found: use referencesClassExact() instead\n@@ -110,10 +94,0 @@\n-    \/**\n-     * Return true if this type references a class, false if it references an interface.\n-     *\n-     * @return true if the type references a class, false if it references an interface\n-     * @throws ClassNotFoundException if the class or interface referenced by this type can't be found\n-     *\/\n-    public boolean referencesClassExact() throws ClassNotFoundException {\n-        final JavaClass jc = Repository.lookupClass(className);\n-        return jc.isClass();\n-    }\n@@ -122,4 +96,5 @@\n-     * If \"this\" doesn't reference an interface, it references a class or a non-existant entity.\n-     *\n-     * @deprecated (since 6.0) this method returns an inaccurate result if the class or interface referenced cannot be\n-     *             found: use referencesInterfaceExact() instead\n+     * If \"this\" doesn't reference an interface, it references a class\n+     * or a non-existant entity.\n+     * @deprecated (since 6.0) this method returns an inaccurate result\n+     *   if the class or interface referenced cannot\n+     *   be found: use referencesInterfaceExact() instead\n@@ -137,0 +112,1 @@\n+\n@@ -138,4 +114,20 @@\n-     * Return true if this type references an interface, false if it references a class.\n-     *\n-     * @return true if the type references an interface, false if it references a class\n-     * @throws ClassNotFoundException if the class or interface referenced by this type can't be found\n+     * Return true if this type references a class,\n+     * false if it references an interface.\n+     * @return true if the type references a class, false if\n+     *   it references an interface\n+     * @throws ClassNotFoundException if the class or interface\n+     *   referenced by this type can't be found\n+     *\/\n+    public boolean referencesClassExact() throws ClassNotFoundException {\n+        final JavaClass jc = Repository.lookupClass(className);\n+        return jc.isClass();\n+    }\n+\n+\n+    \/**\n+     * Return true if this type references an interface,\n+     * false if it references a class.\n+     * @return true if the type references an interface, false if\n+     *   it references a class\n+     * @throws ClassNotFoundException if the class or interface\n+     *   referenced by this type can't be found\n@@ -148,0 +140,1 @@\n+\n@@ -150,2 +143,2 @@\n-     *\n-     * @throws ClassNotFoundException if any of this class's superclasses can't be found\n+     * @throws ClassNotFoundException if any of this class's superclasses\n+     *  can't be found\n@@ -153,1 +146,1 @@\n-    public boolean subclassOf(final ObjectType superclass) throws ClassNotFoundException {\n+    public boolean subclassOf( final ObjectType superclass ) throws ClassNotFoundException {\n@@ -159,0 +152,15 @@\n+\n+\n+    \/**\n+     * Java Virtual Machine Specification edition 2,  5.4.4 Access Control\n+     * @throws ClassNotFoundException if the class referenced by this type\n+     *   can't be found\n+     *\/\n+    public boolean accessibleTo( final ObjectType accessor ) throws ClassNotFoundException {\n+        final JavaClass jc = Repository.lookupClass(className);\n+        if (jc.isPublic()) {\n+            return true;\n+        }\n+        final JavaClass acc = Repository.lookupClass(accessor.className);\n+        return acc.getPackageName().equals(jc.getPackageName());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ObjectType.java","additions":69,"deletions":61,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., word -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., word -&gt; ...<\/PRE>\n+ *\n@@ -37,0 +36,1 @@\n+\n@@ -38,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/POP.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., word2, word1 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., word2, word1 -&gt; ...<\/PRE>\n+ *\n@@ -37,0 +36,1 @@\n+\n@@ -38,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/POP2.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import java.util.Objects;\n-\n@@ -28,2 +26,4 @@\n- * Wrapper class for push operations, which are implemented either as BIPUSH, LDC or xCONST_n instructions.\n- * @LastModified: Feb 2023\n+ * Wrapper class for push operations, which are implemented either as BIPUSH,\n+ * LDC or xCONST_n instructions.\n+ *\n+ * @LastModified: Jan 2020\n@@ -33,1 +33,2 @@\n-    private final Instruction instruction;\n+    private Instruction instruction;\n+\n@@ -36,1 +37,1 @@\n-     * Pushes an array type constant, for example {@code int[].class}, {@code String[].class}, and so on.\n+     * This constructor also applies for values of type short, char, byte\n@@ -38,3 +39,2 @@\n-     * @param cp generated constant pool.\n-     * @param value to be pushed.\n-     * @since 6.7.0\n+     * @param cp Constant pool\n+     * @param value to be pushed\n@@ -42,3 +42,7 @@\n-    public PUSH(final ConstantPoolGen cp, final ArrayType value) {\n-        if (value == null) {\n-            instruction = InstructionConst.ACONST_NULL;\n+    public PUSH(final ConstantPoolGen cp, final int value) {\n+        if ((value >= -1) && (value <= 5)) {\n+            instruction = InstructionConst.getInstruction(Const.ICONST_0 + value);\n+        } else if (Instruction.isValidByte(value)) {\n+            instruction = new BIPUSH((byte) value);\n+        } else if (Instruction.isValidShort(value)) {\n+            instruction = new SIPUSH((short) value);\n@@ -46,1 +50,1 @@\n-            instruction = new LDC(cp.addArrayClass(value));\n+            instruction = new LDC(cp.addInteger(value));\n@@ -50,1 +54,2 @@\n-   \/**\n+\n+    \/**\n@@ -55,1 +60,0 @@\n-        Objects.requireNonNull(cp, \"cp\");\n@@ -59,0 +63,1 @@\n+\n@@ -63,2 +68,10 @@\n-    public PUSH(final ConstantPoolGen cp, final Boolean value) {\n-        this(cp, value.booleanValue());\n+    public PUSH(final ConstantPoolGen cp, final float value) {\n+        if (value == 0.0) {\n+            instruction = InstructionConst.FCONST_0;\n+        } else if (value == 1.0) {\n+            instruction = InstructionConst.FCONST_1;\n+        } else if (value == 2.0) {\n+            instruction = InstructionConst.FCONST_2;\n+        } else {\n+            instruction = new LDC(cp.addFloat(value));\n+        }\n@@ -67,0 +80,1 @@\n+\n@@ -68,3 +82,0 @@\n-     * creates a push object from a Character value. Warning: Make sure not to attempt to allow autoboxing to create this\n-     * value parameter, as an alternative constructor will be called\n-     *\n@@ -74,2 +85,8 @@\n-    public PUSH(final ConstantPoolGen cp, final Character value) {\n-        this(cp, value.charValue());\n+    public PUSH(final ConstantPoolGen cp, final long value) {\n+        if (value == 0) {\n+            instruction = InstructionConst.LCONST_0;\n+        } else if (value == 1) {\n+            instruction = InstructionConst.LCONST_1;\n+        } else {\n+            instruction = new LDC2_W(cp.addLong(value));\n+        }\n@@ -78,0 +95,1 @@\n+\n@@ -92,15 +110,0 @@\n-    \/**\n-     * @param cp Constant pool\n-     * @param value to be pushed\n-     *\/\n-    public PUSH(final ConstantPoolGen cp, final float value) {\n-        if (value == 0.0) {\n-            instruction = InstructionConst.FCONST_0;\n-        } else if (value == 1.0) {\n-            instruction = InstructionConst.FCONST_1;\n-        } else if (value == 2.0) {\n-            instruction = InstructionConst.FCONST_2;\n-        } else {\n-            instruction = new LDC(cp.addFloat(value));\n-        }\n-    }\n@@ -109,2 +112,0 @@\n-     * This constructor also applies for values of type short, char, byte\n-     *\n@@ -114,7 +115,3 @@\n-    public PUSH(final ConstantPoolGen cp, final int value) {\n-        if (value >= -1 && value <= 5) {\n-            instruction = InstructionConst.getInstruction(Const.ICONST_0 + value);\n-        } else if (Instruction.isValidByte(value)) {\n-            instruction = new BIPUSH((byte) value);\n-        } else if (Instruction.isValidShort(value)) {\n-            instruction = new SIPUSH((short) value);\n+    public PUSH(final ConstantPoolGen cp, final String value) {\n+        if (value == null) {\n+            instruction = InstructionConst.ACONST_NULL;\n@@ -122,1 +119,1 @@\n-            instruction = new LDC(cp.addInteger(value));\n+            instruction = new LDC(cp.addString(value));\n@@ -127,2 +124,4 @@\n-     * @param cp Constant pool\n-     * @param value to be pushed\n+     *\n+     * @param cp\n+     * @param value\n+     * @since 6.0\n@@ -130,5 +129,3 @@\n-    public PUSH(final ConstantPoolGen cp, final long value) {\n-        if (value == 0) {\n-            instruction = InstructionConst.LCONST_0;\n-        } else if (value == 1) {\n-            instruction = InstructionConst.LCONST_1;\n+    public PUSH(final ConstantPoolGen cp, final ObjectType value) {\n+        if (value == null) {\n+            instruction = InstructionConst.ACONST_NULL;\n@@ -136,1 +133,1 @@\n-            instruction = new LDC2_W(cp.addLong(value));\n+            instruction = new LDC(cp.addClass(value));\n@@ -145,1 +142,1 @@\n-        if (value instanceof Integer || value instanceof Short || value instanceof Byte) {\n+        if ((value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n@@ -158,0 +155,1 @@\n+\n@@ -159,0 +157,2 @@\n+     * creates a push object from a Character value. Warning: Make sure not to attempt to allow\n+     * autoboxing to create this value parameter, as an alternative constructor will be called\n@@ -160,3 +160,2 @@\n-     * @param cp\n-     * @param value\n-     * @since 6.0\n+     * @param cp Constant pool\n+     * @param value to be pushed\n@@ -164,6 +163,2 @@\n-    public PUSH(final ConstantPoolGen cp, final ObjectType value) {\n-        if (value == null) {\n-            instruction = InstructionConst.ACONST_NULL;\n-        } else {\n-            instruction = new LDC(cp.addClass(value));\n-        }\n+    public PUSH(final ConstantPoolGen cp, final Character value) {\n+        this(cp, value.charValue());\n@@ -172,0 +167,1 @@\n+\n@@ -176,6 +172,2 @@\n-    public PUSH(final ConstantPoolGen cp, final String value) {\n-        if (value == null) {\n-            instruction = InstructionConst.ACONST_NULL;\n-        } else {\n-            instruction = new LDC(cp.addString(value));\n-        }\n+    public PUSH(final ConstantPoolGen cp, final Boolean value) {\n+        this(cp, value.booleanValue());\n@@ -184,3 +176,0 @@\n-    public Instruction getInstruction() {\n-        return instruction;\n-    }\n@@ -193,0 +182,6 @@\n+\n+    public Instruction getInstruction() {\n+        return instruction;\n+    }\n+\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUSH.java","additions":70,"deletions":75,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -29,5 +29,1 @@\n- *\n- * <PRE>\n- * Stack: ..., objectref, value -&gt; ...\n- * <\/PRE>\n- *\n+ * <PRE>Stack: ..., objectref, value -&gt; ...<\/PRE>\n@@ -35,0 +31,1 @@\n+ * <PRE>Stack: ..., objectref, value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -36,3 +33,0 @@\n- * <PRE>\n- * Stack: ..., objectref, value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -43,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +43,1 @@\n+\n@@ -52,0 +48,15 @@\n+\n+    @Override\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n+        return getFieldSize(cpg) + 1;\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -53,2 +64,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,11 +83,0 @@\n-\n-    @Override\n-    public int consumeStack(final ConstantPoolGen cpg) {\n-        return getFieldSize(cpg) + 1;\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUTFIELD.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,5 +29,1 @@\n- *\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n- *\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n@@ -35,0 +31,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -36,3 +33,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -43,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +43,1 @@\n+\n@@ -52,0 +48,14 @@\n+\n+    @Override\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n+        return getFieldSize(cpg);\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -53,2 +63,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,10 +82,0 @@\n-\n-    @Override\n-    public int consumeStack(final ConstantPoolGen cpg) {\n-        return getFieldSize(cpg);\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUTSTATIC.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * Denotes an unparameterized instruction to pop a value on top from the stack, such as ISTORE, POP, PUTSTATIC.\n+ * Denotes an unparameterized instruction to pop a value on top from the stack,\n+ * such as ISTORE, POP, PUTSTATIC.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PopInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,2 @@\n- * Denotes an unparameterized instruction to produce a value on top of the stack, such as ILOAD, LDC, SIPUSH, DUP,\n- * ICONST, etc.\n- *\n+ * Denotes an unparameterized instruction to produce a value on top of the stack,\n+ * such as ILOAD, LDC, SIPUSH, DUP, ICONST, etc.\n@@ -29,0 +28,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PushInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,3 +32,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ...<\/PRE>\n+ *\n@@ -41,0 +40,1 @@\n+\n@@ -42,1 +42,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -47,0 +48,1 @@\n+\n@@ -52,10 +54,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitRET(this);\n-    }\n@@ -65,1 +57,0 @@\n-     *\n@@ -69,1 +60,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -81,7 +72,0 @@\n-    \/**\n-     * @return index of local variable containg the return address\n-     *\/\n-    @Override\n-    public final int getIndex() {\n-        return index;\n-    }\n@@ -89,6 +73,7 @@\n-    \/**\n-     * @return return address type\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return ReturnaddressType.NO_TARGET;\n+    private void setWide() {\n+        wide = index > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n+        if (wide) {\n+            super.setLength(4); \/\/ Including the wide byte\n+        } else {\n+            super.setLength(2);\n+        }\n@@ -97,0 +82,1 @@\n+\n@@ -101,1 +87,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -112,0 +98,10 @@\n+\n+    \/**\n+     * @return index of local variable containg the return address\n+     *\/\n+    @Override\n+    public final int getIndex() {\n+        return index;\n+    }\n+\n+\n@@ -116,1 +112,1 @@\n-    public final void setIndex(final int n) {\n+    public final void setIndex( final int n ) {\n@@ -124,8 +120,0 @@\n-    private void setWide() {\n-        wide = index > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n-        if (wide) {\n-            super.setLength(4); \/\/ Including the wide byte\n-        } else {\n-            super.setLength(2);\n-        }\n-    }\n@@ -137,1 +125,1 @@\n-    public String toString(final boolean verbose) {\n+    public String toString( final boolean verbose ) {\n@@ -140,0 +128,22 @@\n+\n+\n+    \/** @return return address type\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return ReturnaddressType.NO_TARGET;\n+    }\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitRET(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/RET.java","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * RETURN - Return from void method\n+ * RETURN -  Return from void method\n+ * <PRE>Stack: ... -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ... -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/RETURN.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *\n@@ -32,7 +33,0 @@\n-    \/**\n-     * Class is non-abstract but not instantiable from the outside\n-     *\/\n-    ReferenceType() {\n-        super(Const.T_OBJECT, \"<null object>\");\n-    }\n-\n@@ -43,10 +37,2 @@\n-    \/**\n-     * This commutative operation returns the first common superclass (narrowest ReferenceType referencing a class, not an\n-     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is Type.NULL, then t\n-     * is returned. If t is Type.NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n-     * \"this\" or t is an ArrayType, then Type.OBJECT is returned. If \"this\" or t is a ReferenceType referencing an\n-     * interface, then Type.OBJECT is returned. If not all of the two classes' superclasses cannot be found, \"null\" is\n-     * returned. See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n-     *\n-     * @deprecated use getFirstCommonSuperclass(ReferenceType t) which has slightly changed semantics.\n-     * @throws ClassNotFoundException on failure to find superclasses of this type, or the type passed as a parameter\n+\n+    \/** Class is non-abstract but not instantiable from the outside\n@@ -54,18 +40,2 @@\n-    @Deprecated\n-    public ReferenceType firstCommonSuperclass(final ReferenceType t) throws ClassNotFoundException {\n-        if (this.equals(Type.NULL)) {\n-            return t;\n-        }\n-        if (t.equals(Type.NULL) || this.equals(t)) {\n-            return this;\n-            \/*\n-             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by Type.NULL so we can also\n-             * say all the objects referenced by Type.NULL were derived from java.lang.Object. However, the Java Language's\n-             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of java.lang.Object :)\n-             *\/\n-        }\n-        if (this instanceof ArrayType || t instanceof ArrayType) {\n-            return Type.OBJECT;\n-            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n-        }\n-        return getFirstCommonSuperclassInternal(t);\n+    ReferenceType() {\n+        super(Const.T_OBJECT, \"<null object>\");\n@@ -74,0 +44,1 @@\n+\n@@ -75,8 +46,6 @@\n-     * This commutative operation returns the first common superclass (narrowest ReferenceType referencing a class, not an\n-     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is Type.NULL, then t\n-     * is returned. If t is Type.NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n-     * \"this\" or t is an ArrayType, then Type.OBJECT is returned; unless their dimensions match. Then an ArrayType of the\n-     * same number of dimensions is returned, with its basic type being the first common super class of the basic types of\n-     * \"this\" and t. If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned. If not all of\n-     * the two classes' superclasses cannot be found, \"null\" is returned. See the JVM specification edition 2, \"4.9.2 The\n-     * Bytecode Verifier\".\n+     * Return true iff this type is castable to another type t as defined in\n+     * the JVM specification.  The case where this is Type.NULL is not\n+     * defined (see the CHECKCAST definition in the JVM specification).\n+     * However, because e.g. CHECKCAST doesn't throw a\n+     * ClassCastException when casting a null reference to any Object,\n+     * true is returned in this case.\n@@ -84,1 +53,2 @@\n-     * @throws ClassNotFoundException on failure to find superclasses of this type, or the type passed as a parameter\n+     * @throws ClassNotFoundException if any classes or interfaces required\n+     *  to determine assignment compatibility can't be found\n@@ -86,1 +56,1 @@\n-    public ReferenceType getFirstCommonSuperclass(final ReferenceType t) throws ClassNotFoundException {\n+    public boolean isCastableTo( final Type t ) throws ClassNotFoundException {\n@@ -88,23 +58,1 @@\n-            return t;\n-        }\n-        if (t.equals(Type.NULL) || this.equals(t)) {\n-            return this;\n-            \/*\n-             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by Type.NULL so we can also\n-             * say all the objects referenced by Type.NULL were derived from java.lang.Object. However, the Java Language's\n-             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of java.lang.Object :)\n-             *\/\n-        }\n-        \/* This code is from a bug report by Konstantin Shagin <konst@cs.technion.ac.il> *\/\n-        if (this instanceof ArrayType && t instanceof ArrayType) {\n-            final ArrayType arrType1 = (ArrayType) this;\n-            final ArrayType arrType2 = (ArrayType) t;\n-            if (arrType1.getDimensions() == arrType2.getDimensions() && arrType1.getBasicType() instanceof ObjectType\n-                && arrType2.getBasicType() instanceof ObjectType) {\n-                return new ArrayType(((ObjectType) arrType1.getBasicType()).getFirstCommonSuperclass((ObjectType) arrType2.getBasicType()),\n-                    arrType1.getDimensions());\n-            }\n-        }\n-        if (this instanceof ArrayType || t instanceof ArrayType) {\n-            return Type.OBJECT;\n-            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+            return t instanceof ReferenceType; \/\/ If this is ever changed in isAssignmentCompatible()\n@@ -112,1 +60,4 @@\n-        return getFirstCommonSuperclassInternal(t);\n+        return isAssignmentCompatibleWith(t);\n+        \/* Yes, it's true: It's the same definition.\n+         * See vmspec2 AASTORE \/ CHECKCAST definitions.\n+         *\/\n@@ -115,33 +66,0 @@\n-    private ReferenceType getFirstCommonSuperclassInternal(final ReferenceType t) throws ClassNotFoundException {\n-        if (this instanceof ObjectType && ((ObjectType) this).referencesInterfaceExact()\n-            || t instanceof ObjectType && ((ObjectType) t).referencesInterfaceExact()) {\n-            return Type.OBJECT;\n-            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n-            \/\/ make class file verification a bit stronger here by using the notion of\n-            \/\/ superinterfaces or even castability or assignment compatibility.\n-        }\n-        \/\/ this and t are ObjectTypes, see above.\n-        final ObjectType thiz = (ObjectType) this;\n-        final ObjectType other = (ObjectType) t;\n-        final JavaClass[] thizSups = Repository.getSuperClasses(thiz.getClassName());\n-        final JavaClass[] otherSups = Repository.getSuperClasses(other.getClassName());\n-        if (thizSups == null || otherSups == null) {\n-            return null;\n-        }\n-        \/\/ Waaahh...\n-        final JavaClass[] thisSups = new JavaClass[thizSups.length + 1];\n-        final JavaClass[] tSups = new JavaClass[otherSups.length + 1];\n-        System.arraycopy(thizSups, 0, thisSups, 1, thizSups.length);\n-        System.arraycopy(otherSups, 0, tSups, 1, otherSups.length);\n-        thisSups[0] = Repository.lookupClass(thiz.getClassName());\n-        tSups[0] = Repository.lookupClass(other.getClassName());\n-        for (final JavaClass tSup : tSups) {\n-            for (final JavaClass thisSup : thisSups) {\n-                if (thisSup.equals(tSup)) {\n-                    return ObjectType.getInstance(thisSup.getClassName());\n-                }\n-            }\n-        }\n-        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n-        return null;\n-    }\n@@ -150,5 +68,5 @@\n-     * Return true iff this is assignment compatible with another type t as defined in the JVM specification; see the\n-     * AASTORE definition there.\n-     *\n-     * @throws ClassNotFoundException if any classes or interfaces required to determine assignment compatibility can't be\n-     *         found\n+     * Return true iff this is assignment compatible with another type t\n+     * as defined in the JVM specification; see the AASTORE definition\n+     * there.\n+     * @throws ClassNotFoundException if any classes or interfaces required\n+     *  to determine assignment compatibility can't be found\n@@ -156,1 +74,1 @@\n-    public boolean isAssignmentCompatibleWith(final Type t) throws ClassNotFoundException {\n+    public boolean isAssignmentCompatibleWith( final Type t ) throws ClassNotFoundException {\n@@ -162,1 +80,1 @@\n-            return true; \/\/ This is not explicitly stated, but clear. Isn't it?\n+            return true; \/\/ This is not explicitely stated, but clear. Isn't it?\n@@ -164,2 +82,1 @@\n-        \/*\n-         * If this is a class type then\n+        \/* If this is a class type then\n@@ -167,3 +84,3 @@\n-        if (this instanceof ObjectType && ((ObjectType) this).referencesClassExact()) {\n-            \/*\n-             * If T is a class type, then this must be the same class as T, or this must be a subclass of T;\n+        if ((this instanceof ObjectType) && (((ObjectType) this).referencesClassExact())) {\n+            \/* If T is a class type, then this must be the same class as T,\n+             or this must be a subclass of T;\n@@ -171,3 +88,8 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact()\n-                && (this.equals(T) || Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n+                if (this.equals(T)) {\n+                    return true;\n+                }\n+                if (Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T)\n+                        .getClassName())) {\n+                    return true;\n+                }\n@@ -175,2 +97,1 @@\n-            \/*\n-             * If T is an interface type, this must implement interface T.\n+            \/* If T is an interface type, this must implement interface T.\n@@ -178,3 +99,5 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()\n-                && Repository.implementationOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName())) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n+                if (Repository.implementationOf(((ObjectType) this).getClassName(),\n+                        ((ObjectType) T).getClassName())) {\n+                    return true;\n+                }\n@@ -183,2 +106,1 @@\n-        \/*\n-         * If this is an interface type, then:\n+        \/* If this is an interface type, then:\n@@ -186,3 +108,2 @@\n-        if (this instanceof ObjectType && ((ObjectType) this).referencesInterfaceExact()) {\n-            \/*\n-             * If T is a class type, then T must be Object (2.4.7).\n+        if ((this instanceof ObjectType) && (((ObjectType) this).referencesInterfaceExact())) {\n+            \/* If T is a class type, then T must be Object (2.4.7).\n@@ -190,2 +111,4 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(Type.OBJECT)) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n+                if (T.equals(Type.OBJECT)) {\n+                    return true;\n+                }\n@@ -193,2 +116,2 @@\n-            \/*\n-             * If T is an interface type, then T must be the same interface as this or a superinterface of this (2.13.2).\n+            \/* If T is an interface type, then T must be the same interface\n+             * as this or a superinterface of this (2.13.2).\n@@ -196,3 +119,8 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()\n-                && (this.equals(T) || Repository.implementationOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n+                if (this.equals(T)) {\n+                    return true;\n+                }\n+                if (Repository.implementationOf(((ObjectType) this).getClassName(),\n+                        ((ObjectType) T).getClassName())) {\n+                    return true;\n+                }\n@@ -201,2 +129,2 @@\n-        \/*\n-         * If this is an array type, namely, the type SC[], that is, an array of components of type SC, then:\n+        \/* If this is an array type, namely, the type SC[], that is, an\n+         * array of components of type SC, then:\n@@ -205,2 +133,1 @@\n-            \/*\n-             * If T is a class type, then T must be Object (2.4.7).\n+            \/* If T is a class type, then T must be Object (2.4.7).\n@@ -208,2 +135,4 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(Type.OBJECT)) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n+                if (T.equals(Type.OBJECT)) {\n+                    return true;\n+                }\n@@ -211,2 +140,2 @@\n-            \/*\n-             * If T is an array type TC[], that is, an array of components of type TC, then one of the following must be true:\n+            \/* If T is an array type TC[], that is, an array of components\n+             * of type TC, then one of the following must be true:\n@@ -215,2 +144,1 @@\n-                \/*\n-                 * TC and SC are the same primitive type (2.4.1).\n+                \/* TC and SC are the same primitive type (2.4.1).\n@@ -223,2 +151,2 @@\n-                \/*\n-                 * TC and SC are reference types (2.4.6), and type SC is assignable to TC by these runtime rules.\n+                \/* TC and SC are reference types (2.4.6), and type SC is\n+                 * assignable to TC by these runtime rules.\n@@ -226,1 +154,2 @@\n-                if (tc instanceof ReferenceType && sc instanceof ReferenceType && ((ReferenceType) sc).isAssignmentCompatibleWith(tc)) {\n+                if (tc instanceof ReferenceType && sc instanceof ReferenceType\n+                        && ((ReferenceType) sc).isAssignmentCompatibleWith(tc)) {\n@@ -236,1 +165,1 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()) {\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n@@ -247,0 +176,1 @@\n+\n@@ -248,3 +178,13 @@\n-     * Return true iff this type is castable to another type t as defined in the JVM specification. The case where this is\n-     * Type.NULL is not defined (see the CHECKCAST definition in the JVM specification). However, because e.g. CHECKCAST\n-     * doesn't throw a ClassCastException when casting a null reference to any Object, true is returned in this case.\n+     * This commutative operation returns the first common superclass (narrowest ReferenceType\n+     * referencing a class, not an interface).\n+     * If one of the types is a superclass of the other, the former is returned.\n+     * If \"this\" is Type.NULL, then t is returned.\n+     * If t is Type.NULL, then \"this\" is returned.\n+     * If \"this\" equals t ['this.equals(t)'] \"this\" is returned.\n+     * If \"this\" or t is an ArrayType, then Type.OBJECT is returned;\n+     * unless their dimensions match. Then an ArrayType of the same\n+     * number of dimensions is returned, with its basic type being the\n+     * first common super class of the basic types of \"this\" and t.\n+     * If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.\n+     * If not all of the two classes' superclasses cannot be found, \"null\" is returned.\n+     * See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n@@ -252,2 +192,2 @@\n-     * @throws ClassNotFoundException if any classes or interfaces required to determine assignment compatibility can't be\n-     *         found\n+     * @throws ClassNotFoundException on failure to find superclasses of this\n+     *  type, or the type passed as a parameter\n@@ -255,1 +195,1 @@\n-    public boolean isCastableTo(final Type t) throws ClassNotFoundException {\n+    public ReferenceType getFirstCommonSuperclass( final ReferenceType t ) throws ClassNotFoundException {\n@@ -257,1 +197,1 @@\n-            return t instanceof ReferenceType; \/\/ If this is ever changed in isAssignmentCompatible()\n+            return t;\n@@ -259,4 +199,132 @@\n-        return isAssignmentCompatibleWith(t);\n-        \/*\n-         * Yes, it's true: It's the same definition. See vmspec2 AASTORE \/ CHECKCAST definitions.\n-         *\/\n+        if (t.equals(Type.NULL)) {\n+            return this;\n+        }\n+        if (this.equals(t)) {\n+            return this;\n+            \/*\n+             * TODO: Above sounds a little arbitrary. On the other hand, there is\n+             * no object referenced by Type.NULL so we can also say all the objects\n+             * referenced by Type.NULL were derived from java.lang.Object.\n+             * However, the Java Language's \"instanceof\" operator proves us wrong:\n+             * \"null\" is not referring to an instance of java.lang.Object :)\n+             *\/\n+        }\n+        \/* This code is from a bug report by Konstantin Shagin <konst@cs.technion.ac.il> *\/\n+        if ((this instanceof ArrayType) && (t instanceof ArrayType)) {\n+            final ArrayType arrType1 = (ArrayType) this;\n+            final ArrayType arrType2 = (ArrayType) t;\n+            if ((arrType1.getDimensions() == arrType2.getDimensions())\n+                    && arrType1.getBasicType() instanceof ObjectType\n+                    && arrType2.getBasicType() instanceof ObjectType) {\n+                return new ArrayType(((ObjectType) arrType1.getBasicType())\n+                        .getFirstCommonSuperclass((ObjectType) arrType2.getBasicType()), arrType1\n+                        .getDimensions());\n+            }\n+        }\n+        if ((this instanceof ArrayType) || (t instanceof ArrayType)) {\n+            return Type.OBJECT;\n+            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+        }\n+        if (((this instanceof ObjectType) && ((ObjectType) this).referencesInterfaceExact())\n+                || ((t instanceof ObjectType) && ((ObjectType) t).referencesInterfaceExact())) {\n+            return Type.OBJECT;\n+            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n+            \/\/ make class file verification a bit stronger here by using the notion of\n+            \/\/ superinterfaces or even castability or assignment compatibility.\n+        }\n+        \/\/ this and t are ObjectTypes, see above.\n+        final ObjectType thiz = (ObjectType) this;\n+        final ObjectType other = (ObjectType) t;\n+        final JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());\n+        final JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());\n+        if ((thiz_sups == null) || (other_sups == null)) {\n+            return null;\n+        }\n+        \/\/ Waaahh...\n+        final JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];\n+        final JavaClass[] t_sups = new JavaClass[other_sups.length + 1];\n+        System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);\n+        System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);\n+        this_sups[0] = Repository.lookupClass(thiz.getClassName());\n+        t_sups[0] = Repository.lookupClass(other.getClassName());\n+        for (final JavaClass t_sup : t_sups) {\n+            for (final JavaClass this_sup : this_sups) {\n+                if (this_sup.equals(t_sup)) {\n+                    return ObjectType.getInstance(this_sup.getClassName());\n+                }\n+            }\n+        }\n+        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n+        return null;\n+    }\n+\n+    \/**\n+     * This commutative operation returns the first common superclass (narrowest ReferenceType\n+     * referencing a class, not an interface).\n+     * If one of the types is a superclass of the other, the former is returned.\n+     * If \"this\" is Type.NULL, then t is returned.\n+     * If t is Type.NULL, then \"this\" is returned.\n+     * If \"this\" equals t ['this.equals(t)'] \"this\" is returned.\n+     * If \"this\" or t is an ArrayType, then Type.OBJECT is returned.\n+     * If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.\n+     * If not all of the two classes' superclasses cannot be found, \"null\" is returned.\n+     * See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n+     *\n+     * @deprecated use getFirstCommonSuperclass(ReferenceType t) which has\n+     *             slightly changed semantics.\n+     * @throws ClassNotFoundException on failure to find superclasses of this\n+     *  type, or the type passed as a parameter\n+     *\/\n+    @Deprecated\n+    public ReferenceType firstCommonSuperclass( final ReferenceType t ) throws ClassNotFoundException {\n+        if (this.equals(Type.NULL)) {\n+            return t;\n+        }\n+        if (t.equals(Type.NULL)) {\n+            return this;\n+        }\n+        if (this.equals(t)) {\n+            return this;\n+            \/*\n+             * TODO: Above sounds a little arbitrary. On the other hand, there is\n+             * no object referenced by Type.NULL so we can also say all the objects\n+             * referenced by Type.NULL were derived from java.lang.Object.\n+             * However, the Java Language's \"instanceof\" operator proves us wrong:\n+             * \"null\" is not referring to an instance of java.lang.Object :)\n+             *\/\n+        }\n+        if ((this instanceof ArrayType) || (t instanceof ArrayType)) {\n+            return Type.OBJECT;\n+            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+        }\n+        if (((this instanceof ObjectType) && ((ObjectType) this).referencesInterface())\n+                || ((t instanceof ObjectType) && ((ObjectType) t).referencesInterface())) {\n+            return Type.OBJECT;\n+            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n+            \/\/ make class file verification a bit stronger here by using the notion of\n+            \/\/ superinterfaces or even castability or assignment compatibility.\n+        }\n+        \/\/ this and t are ObjectTypes, see above.\n+        final ObjectType thiz = (ObjectType) this;\n+        final ObjectType other = (ObjectType) t;\n+        final JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());\n+        final JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());\n+        if ((thiz_sups == null) || (other_sups == null)) {\n+            return null;\n+        }\n+        \/\/ Waaahh...\n+        final JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];\n+        final JavaClass[] t_sups = new JavaClass[other_sups.length + 1];\n+        System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);\n+        System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);\n+        this_sups[0] = Repository.lookupClass(thiz.getClassName());\n+        t_sups[0] = Repository.lookupClass(other.getClassName());\n+        for (final JavaClass t_sup : t_sups) {\n+            for (final JavaClass this_sup : this_sups) {\n+                if (this_sup.equals(t_sup)) {\n+                    return ObjectType.getInstance(this_sup.getClassName());\n+                }\n+            }\n+        }\n+        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReferenceType.java","additions":227,"deletions":159,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -31,1 +31,2 @@\n-public abstract class ReturnInstruction extends Instruction implements ExceptionThrower, TypedInstruction, StackConsumer {\n+public abstract class ReturnInstruction extends Instruction implements ExceptionThrower,\n+        TypedInstruction, StackConsumer {\n@@ -34,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +41,1 @@\n+\n@@ -46,4 +49,0 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ILLEGAL_MONITOR_STATE};\n-    }\n@@ -52,16 +51,16 @@\n-        final short opcode = super.getOpcode();\n-        switch (opcode) {\n-        case Const.IRETURN:\n-            return Type.INT;\n-        case Const.LRETURN:\n-            return Type.LONG;\n-        case Const.FRETURN:\n-            return Type.FLOAT;\n-        case Const.DRETURN:\n-            return Type.DOUBLE;\n-        case Const.ARETURN:\n-            return Type.OBJECT;\n-        case Const.RETURN:\n-            return Type.VOID;\n-        default: \/\/ Never reached\n-            throw new ClassGenException(\"Unknown type \" + opcode);\n+        final short _opcode = super.getOpcode();\n+        switch (_opcode) {\n+            case Const.IRETURN:\n+                return Type.INT;\n+            case Const.LRETURN:\n+                return Type.LONG;\n+            case Const.FRETURN:\n+                return Type.FLOAT;\n+            case Const.DRETURN:\n+                return Type.DOUBLE;\n+            case Const.ARETURN:\n+                return Type.OBJECT;\n+            case Const.RETURN:\n+                return Type.VOID;\n+            default: \/\/ Never reached\n+                throw new ClassGenException(\"Unknown type \" + _opcode);\n@@ -71,2 +70,10 @@\n-    \/**\n-     * @return type associated with the instruction\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ILLEGAL_MONITOR_STATE\n+        };\n+    }\n+\n+\n+    \/** @return type associated with the instruction\n@@ -75,1 +82,1 @@\n-    public Type getType(final ConstantPoolGen cp) {\n+    public Type getType( final ConstantPoolGen cp ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReturnInstruction.java","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+\n@@ -43,0 +44,1 @@\n+\n@@ -51,0 +53,12 @@\n+\n+    \/** @return a hash code value for the object.\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        if (returnTarget == null) {\n+            return 0;\n+        }\n+        return returnTarget.hashCode();\n+    }\n+\n+\n@@ -55,1 +69,1 @@\n-    public boolean equals(final Object rat) {\n+    public boolean equals( final Object rat ) {\n@@ -66,0 +80,1 @@\n+\n@@ -72,11 +87,0 @@\n-\n-    \/**\n-     * @return a hash code value for the object.\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        if (returnTarget == null) {\n-            return 0;\n-        }\n-        return returnTarget.hashCode();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReturnaddressType.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SALOAD.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SASTORE.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., value\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., value<\/PRE>\n+ *\n@@ -39,0 +38,1 @@\n+\n@@ -40,1 +40,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -45,0 +46,1 @@\n+\n@@ -50,0 +52,1 @@\n+\n@@ -51,4 +54,1 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * Dump instruction as short code to stream out.\n@@ -57,6 +57,3 @@\n-    public void accept(final Visitor v) {\n-        v.visitPushInstruction(this);\n-        v.visitStackProducer(this);\n-        v.visitTypedInstruction(this);\n-        v.visitConstantPushInstruction(this);\n-        v.visitSIPUSH(this);\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        super.dump(out);\n+        out.writeShort(b);\n@@ -65,0 +62,1 @@\n+\n@@ -66,1 +64,1 @@\n-     * Dump instruction as short code to stream out.\n+     * @return mnemonic for instruction\n@@ -69,3 +67,2 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        super.dump(out);\n-        out.writeShort(b);\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + b;\n@@ -74,0 +71,1 @@\n+\n@@ -75,1 +73,1 @@\n-     * @return Type.SHORT\n+     * Read needed data (e.g. index) from file.\n@@ -78,2 +76,3 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.SHORT;\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.setLength(3);\n+        b = bytes.readShort();\n@@ -82,0 +81,1 @@\n+\n@@ -87,2 +87,2 @@\n-    \/**\n-     * Read needed data (e.g. index) from file.\n+\n+    \/** @return Type.SHORT\n@@ -91,3 +91,2 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.setLength(3);\n-        b = bytes.readShort();\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.SHORT;\n@@ -96,0 +95,1 @@\n+\n@@ -97,1 +97,6 @@\n-     * @return mnemonic for instruction\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -100,2 +105,6 @@\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + b;\n+    public void accept( final Visitor v ) {\n+        v.visitPushInstruction(this);\n+        v.visitStackProducer(this);\n+        v.visitTypedInstruction(this);\n+        v.visitConstantPushInstruction(this);\n+        v.visitSIPUSH(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SIPUSH.java","additions":38,"deletions":29,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word2, word1 -&gt; ..., word1, word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word2, word1 -&gt; ..., word1, word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SWAP.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import java.util.Arrays;\n-\n@@ -27,2 +25,4 @@\n- * SWITCH - Branch depending on int value, generates either LOOKUPSWITCH or TABLESWITCH instruction, depending on\n- * whether the match values (int[]) can be sorted with no gaps between the numbers.\n+ * SWITCH - Branch depending on int value, generates either LOOKUPSWITCH or\n+ * TABLESWITCH instruction, depending on whether the match values (int[]) can be\n+ * sorted with no gaps between the numbers.\n+ *\n@@ -32,0 +32,6 @@\n+    private int[] match;\n+    private InstructionHandle[] targets;\n+    private Select instruction;\n+    private int matchLength;\n+\n+\n@@ -33,1 +39,13 @@\n-     * @return match is sorted in ascending order with no gap bigger than maxGap?\n+     * Template for switch() constructs. If the match array can be\n+     * sorted in ascending order with gaps no larger than max_gap\n+     * between the numbers, a TABLESWITCH instruction is generated, and\n+     * a LOOKUPSWITCH otherwise. The former may be more efficient, but\n+     * needs more space.\n+     *\n+     * Note, that the key array always will be sorted, though we leave\n+     * the original arrays unaltered.\n+     *\n+     * @param match array of match values (case 2: ... case 7: ..., etc.)\n+     * @param targets the instructions to be branched to for each case\n+     * @param target the default target\n+     * @param max_gap maximum gap that may between case branches\n@@ -35,1 +53,29 @@\n-    private static boolean matchIsOrdered(final int[] match, final int matchLength, final int maxGap) {\n+    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target, final int max_gap) {\n+        this.match = match.clone();\n+        this.targets = targets.clone();\n+        if ((matchLength = match.length) < 2) {\n+            instruction = new TABLESWITCH(match, targets, target);\n+        } else {\n+            sort(0, matchLength - 1);\n+            if (matchIsOrdered(max_gap)) {\n+                fillup(max_gap, target);\n+                instruction = new TABLESWITCH(this.match, this.targets, target);\n+            } else {\n+                instruction = new LOOKUPSWITCH(this.match, this.targets, target);\n+            }\n+        }\n+    }\n+\n+\n+    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {\n+        this(match, targets, target, 1);\n+    }\n+\n+\n+    private void fillup( final int max_gap, final InstructionHandle target ) {\n+        final int max_size = matchLength + matchLength * max_gap;\n+        final int[] m_vec = new int[max_size];\n+        final InstructionHandle[] t_vec = new InstructionHandle[max_size];\n+        int count = 1;\n+        m_vec[0] = match[0];\n+        t_vec[0] = targets[0];\n@@ -37,2 +83,6 @@\n-            if (match[i] - match[i - 1] > maxGap) {\n-                return false;\n+            final int prev = match[i - 1];\n+            final int gap = match[i] - prev;\n+            for (int j = 1; j < gap; j++) {\n+                m_vec[count] = prev + j;\n+                t_vec[count] = target;\n+                count++;\n@@ -40,0 +90,3 @@\n+            m_vec[count] = match[i];\n+            t_vec[count] = targets[i];\n+            count++;\n@@ -41,1 +94,4 @@\n-        return true;\n+        match = new int[count];\n+        targets = new InstructionHandle[count];\n+        System.arraycopy(m_vec, 0, match, 0, count);\n+        System.arraycopy(t_vec, 0, targets, 0, count);\n@@ -44,0 +100,1 @@\n+\n@@ -45,1 +102,1 @@\n-     * Sorts match and targets array with QuickSort.\n+     * Sort match and targets array with QuickSort.\n@@ -47,1 +104,1 @@\n-    private static void sort(final int l, final int r, final int[] match, final InstructionHandle[] targets) {\n+    private void sort( final int l, final int r ) {\n@@ -51,1 +108,1 @@\n-        final int m = match[l + r >>> 1];\n+        final int m = match[(l + r) >>> 1];\n@@ -72,1 +129,1 @@\n-            sort(l, j, match, targets);\n+            sort(l, j);\n@@ -75,1 +132,1 @@\n-            sort(i, r, match, targets);\n+            sort(i, r);\n@@ -79,5 +136,0 @@\n-    private final Select instruction;\n-\n-    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {\n-        this(match, targets, target, 1);\n-    }\n@@ -86,10 +138,1 @@\n-     * Template for switch() constructs. If the match array can be sorted in ascending order with gaps no larger than\n-     * maxGap between the numbers, a TABLESWITCH instruction is generated, and a LOOKUPSWITCH otherwise. The former may be\n-     * more efficient, but needs more space.\n-     *\n-     * Note, that the key array always will be sorted, though we leave the original arrays unaltered.\n-     *\n-     * @param match array of match values (case 2: ... case 7: ..., etc.)\n-     * @param targets the instructions to be branched to for each case\n-     * @param target the default target\n-     * @param maxGap maximum gap that may between case branches\n+     * @return match is sorted in ascending order with no gap bigger than max_gap?\n@@ -97,30 +140,4 @@\n-    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target, final int maxGap) {\n-        int[] matchClone = match.clone();\n-        final InstructionHandle[] targetsClone = targets.clone();\n-        final int matchLength = match.length;\n-        if (matchLength < 2) {\n-            instruction = new TABLESWITCH(match, targets, target);\n-        } else {\n-            sort(0, matchLength - 1, matchClone, targetsClone);\n-            if (matchIsOrdered(matchClone, matchLength, maxGap)) {\n-                final int maxSize = matchLength + matchLength * maxGap;\n-                final int[] mVec = new int[maxSize];\n-                final InstructionHandle[] tVec = new InstructionHandle[maxSize];\n-                int count = 1;\n-                mVec[0] = match[0];\n-                tVec[0] = targets[0];\n-                for (int i = 1; i < matchLength; i++) {\n-                    final int prev = match[i - 1];\n-                    final int gap = match[i] - prev;\n-                    for (int j = 1; j < gap; j++) {\n-                        mVec[count] = prev + j;\n-                        tVec[count] = target;\n-                        count++;\n-                    }\n-                    mVec[count] = match[i];\n-                    tVec[count] = targets[i];\n-                    count++;\n-                }\n-                instruction = new TABLESWITCH(Arrays.copyOf(mVec, count), Arrays.copyOf(tVec, count), target);\n-            } else {\n-                instruction = new LOOKUPSWITCH(matchClone, targetsClone, target);\n+    private boolean matchIsOrdered( final int max_gap ) {\n+        for (int i = 1; i < matchLength; i++) {\n+            if (match[i] - match[i - 1] > max_gap) {\n+                return false;\n@@ -129,0 +146,1 @@\n+        return true;\n@@ -131,3 +149,0 @@\n-    public Instruction getInstruction() {\n-        return instruction;\n-    }\n@@ -139,0 +154,5 @@\n+\n+\n+    public Instruction getInstruction() {\n+        return instruction;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SWITCH.java","additions":82,"deletions":62,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * <p>\n- * We use our super's {@code target} property as the default target.\n+ * <p>We use our super's {@code target} property as the default target.\n@@ -38,1 +37,2 @@\n-public abstract class Select extends BranchInstruction implements VariableLengthInstruction, StackConsumer \/* @since 6.0 *\/, StackProducer {\n+public abstract class Select extends BranchInstruction implements VariableLengthInstruction,\n+        StackConsumer \/* @since 6.0 *\/, StackProducer {\n@@ -40,17 +40,6 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int[] match; \/\/ matches, i.e., case 1: ... TODO could be package-protected?\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int[] indices; \/\/ target offsets TODO could be package-protected?\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected InstructionHandle[] targets; \/\/ target objects in instruction list TODO could be package-protected?\n+    private int[] match; \/\/ matches, i.e., case 1: ... TODO could be package-protected?\n+    private int[] indices; \/\/ target offsets TODO could be package-protected?\n+    private InstructionHandle[] targets; \/\/ target objects in instruction list TODO could be package-protected?\n+    private int fixed_length; \/\/ fixed length defined by subclasses TODO could be package-protected?\n+    private int match_length; \/\/ number of cases TODO could be package-protected?\n+    private int padding = 0; \/\/ number of pad bytes for alignment TODO could be package-protected?\n@@ -59,19 +48,2 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int fixed_length; \/\/ fixed length defined by subclasses TODO could be package-protected?\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int match_length; \/\/ number of cases TODO could be package-protected?\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int padding; \/\/ number of pad bytes for alignment TODO could be package-protected?\n-\n-    \/**\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -82,0 +54,1 @@\n+\n@@ -83,1 +56,2 @@\n-     * (Match, target) pairs for switch. 'Match' and 'targets' must have the same length of course.\n+     * (Match, target) pairs for switch.\n+     * `Match' and `targets' must have the same length of course.\n@@ -100,1 +74,2 @@\n-            throw new ClassGenException(\"Match and target array have not the same length: Match length: \" + match.length + \" Target length: \" + targets.length);\n+            throw new ClassGenException(\"Match and target array have not the same length: Match length: \" +\n+                match.length + \" Target length: \" + targets.length);\n@@ -105,0 +80,14 @@\n+\n+    \/**\n+     * Since this is a variable length instruction, it may shift the following\n+     * instructions which then need to update their position.\n+     *\n+     * Called by InstructionList.setPositions when setting the position for every\n+     * instruction. In the presence of variable length instructions `setPositions'\n+     * performs multiple passes over the instruction list to calculate the\n+     * correct (byte) positions and offsets by calling this function.\n+     *\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param max_offset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n+     *\/\n@@ -106,6 +95,91 @@\n-    protected Object clone() throws CloneNotSupportedException {\n-        final Select copy = (Select) super.clone();\n-        copy.match = match.clone();\n-        copy.indices = indices.clone();\n-        copy.targets = targets.clone();\n-        return copy;\n+    protected int updatePosition( final int offset, final int max_offset ) {\n+        setPosition(getPosition() + offset); \/\/ Additional offset caused by preceding SWITCHs, GOTOs, etc.\n+        final short old_length = (short) super.getLength();\n+        \/* Alignment on 4-byte-boundary, + 1, because of tag byte.\n+         *\/\n+        padding = (4 - ((getPosition() + 1) % 4)) % 4;\n+        super.setLength((short) (fixed_length + padding)); \/\/ Update length\n+        return super.getLength() - old_length;\n+    }\n+\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        for (int i = 0; i < padding; i++) {\n+            out.writeByte(0);\n+        }\n+        super.setIndex(getTargetOffset()); \/\/ Write default target offset\n+        out.writeInt(super.getIndex());\n+    }\n+\n+\n+    \/**\n+     * Read needed data (e.g. index) from file.\n+     *\/\n+    @Override\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        padding = (4 - (bytes.getIndex() % 4)) % 4; \/\/ Compute number of pad bytes\n+        for (int i = 0; i < padding; i++) {\n+            bytes.readByte();\n+        }\n+        \/\/ Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)\n+        super.setIndex(bytes.readInt());\n+    }\n+\n+\n+    \/**\n+     * @return mnemonic for instruction\n+     *\/\n+    @Override\n+    public String toString( final boolean verbose ) {\n+        final StringBuilder buf = new StringBuilder(super.toString(verbose));\n+        if (verbose) {\n+            for (int i = 0; i < match_length; i++) {\n+                String s = \"null\";\n+                if (targets[i] != null) {\n+                    s = targets[i].getInstruction().toString();\n+                }\n+                buf.append(\"(\").append(match[i]).append(\", \").append(s).append(\" = {\").append(\n+                        indices[i]).append(\"})\");\n+            }\n+        } else {\n+            buf.append(\" ...\");\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    \/**\n+     * Set branch target for `i'th case\n+     *\/\n+    public void setTarget( final int i, final InstructionHandle target ) { \/\/ TODO could be package-protected?\n+        notifyTarget(targets[i], target, this);\n+        targets[i] = target;\n+    }\n+\n+\n+    \/**\n+     * @param old_ih old target\n+     * @param new_ih new target\n+     *\/\n+    @Override\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        boolean targeted = false;\n+        if (super.getTarget() == old_ih) {\n+            targeted = true;\n+            setTarget(new_ih);\n+        }\n+        for (int i = 0; i < targets.length; i++) {\n+            if (targets[i] == old_ih) {\n+                targeted = true;\n+                setTarget(i, new_ih);\n+            }\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + old_ih);\n+        }\n@@ -114,0 +188,1 @@\n+\n@@ -118,1 +193,1 @@\n-    public boolean containsTarget(final InstructionHandle ih) {\n+    public boolean containsTarget( final InstructionHandle ih ) {\n@@ -130,0 +205,11 @@\n+\n+    @Override\n+    protected Object clone() throws CloneNotSupportedException {\n+        final Select copy = (Select) super.clone();\n+        copy.match = match.clone();\n+        copy.indices = indices.clone();\n+        copy.targets = targets.clone();\n+        return copy;\n+    }\n+\n+\n@@ -141,14 +227,0 @@\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        for (int i = 0; i < padding; i++) {\n-            out.writeByte(0);\n-        }\n-        super.setIndex(getTargetOffset()); \/\/ Write default target offset\n-        out.writeInt(super.getIndex());\n-    }\n@@ -157,2 +229,1 @@\n-     * @return the fixed_length\n-     * @since 6.0\n+     * @return array of match indices\n@@ -160,2 +231,2 @@\n-    final int getFixedLength() {\n-        return fixed_length;\n+    public int[] getMatchs() {\n+        return match;\n@@ -164,0 +235,1 @@\n+\n@@ -171,0 +243,1 @@\n+\n@@ -172,2 +245,1 @@\n-     * @return index entry from indices\n-     * @since 6.0\n+     * @return array of match targets\n@@ -175,2 +247,2 @@\n-    final int getIndices(final int index) {\n-        return indices[index];\n+    public InstructionHandle[] getTargets() {\n+        return targets;\n@@ -187,7 +259,0 @@\n-    \/**\n-     * @return the match_length\n-     * @since 6.0\n-     *\/\n-    final int getMatchLength() {\n-        return match_length;\n-    }\n@@ -196,9 +261,1 @@\n-     * @return array of match indices\n-     *\/\n-    public int[] getMatchs() {\n-        return match;\n-    }\n-\n-    \/**\n-     *\n-     * @return the padding\n+     * @return index entry from indices\n@@ -207,2 +264,2 @@\n-    final int getPadding() {\n-        return padding;\n+    final int getIndices(final int index) {\n+        return indices[index];\n@@ -219,0 +276,1 @@\n+\n@@ -220,1 +278,2 @@\n-     * @return array of match targets\n+     * @return the fixed_length\n+     * @since 6.0\n@@ -222,2 +281,2 @@\n-    public InstructionHandle[] getTargets() {\n-        return targets;\n+    final int getFixed_length() {\n+        return fixed_length;\n@@ -226,0 +285,1 @@\n+\n@@ -227,1 +287,2 @@\n-     * Read needed data (e.g. index) from file.\n+     * @param fixed_length the fixed_length to set\n+     * @since 6.0\n@@ -229,8 +290,2 @@\n-    @Override\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        padding = (4 - bytes.getIndex() % 4) % 4; \/\/ Compute number of pad bytes\n-        for (int i = 0; i < padding; i++) {\n-            bytes.readByte();\n-        }\n-        \/\/ Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)\n-        super.setIndex(bytes.readInt());\n+    final void setFixed_length(final int fixed_length) {\n+        this.fixed_length = fixed_length;\n@@ -239,0 +294,1 @@\n+\n@@ -240,1 +296,1 @@\n-     * @param fixedLength the fixed_length to set\n+     * @return the match_length\n@@ -243,2 +299,2 @@\n-    final void setFixedLength(final int fixedLength) {\n-        this.fixed_length = fixedLength;\n+    final int getMatch_length() {\n+        return match_length;\n@@ -247,5 +303,0 @@\n-    \/** @since 6.0 *\/\n-    final int setIndices(final int i, final int value) {\n-        indices[i] = value;\n-        return value; \/\/ Allow use in nested calls\n-    }\n@@ -254,2 +305,1 @@\n-     *\n-     * @param array\n+     * @param match_length the match_length to set\n@@ -258,2 +308,3 @@\n-    final void setIndices(final int[] array) {\n-        indices = array;\n+    final int setMatch_length(final int match_length) {\n+        this.match_length = match_length;\n+        return match_length;\n@@ -277,2 +328,2 @@\n-    final void setMatches(final int[] array) {\n-        match = array;\n+    final void setIndices(final int[] array) {\n+        indices = array;\n@@ -282,1 +333,2 @@\n-     * @param matchLength the match_length to set\n+     *\n+     * @param array\n@@ -285,11 +337,2 @@\n-    final int setMatchLength(final int matchLength) {\n-        this.match_length = matchLength;\n-        return matchLength;\n-    }\n-\n-    \/**\n-     * Set branch target for 'i'th case\n-     *\/\n-    public void setTarget(final int i, final InstructionHandle target) { \/\/ TODO could be package-protected?\n-        notifyTarget(targets[i], target, this);\n-        targets[i] = target;\n+    final void setMatches(final int[] array) {\n+        match = array;\n@@ -308,22 +351,0 @@\n-     * @return mnemonic for instruction\n-     *\/\n-    @Override\n-    public String toString(final boolean verbose) {\n-        final StringBuilder buf = new StringBuilder(super.toString(verbose));\n-        if (verbose) {\n-            for (int i = 0; i < match_length; i++) {\n-                String s = \"null\";\n-                if (targets[i] != null) {\n-                    s = targets[i].getInstruction().toString();\n-                }\n-                buf.append(\"(\").append(match[i]).append(\", \").append(s).append(\" = {\").append(indices[i]).append(\"})\");\n-            }\n-        } else {\n-            buf.append(\" ...\");\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Since this is a variable length instruction, it may shift the following instructions which then need to update their\n-     * position.\n@@ -331,7 +352,2 @@\n-     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n-     * length instructions 'setPositions' performs multiple passes over the instruction list to calculate the correct (byte)\n-     * positions and offsets by calling this function.\n-     *\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param maxOffset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n+     * @return the padding\n+     * @since 6.0\n@@ -339,10 +355,2 @@\n-    @Override\n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        setPosition(getPosition() + offset); \/\/ Additional offset caused by preceding SWITCHs, GOTOs, etc.\n-        final short oldLength = (short) super.getLength();\n-        \/*\n-         * Alignment on 4-byte-boundary, + 1, because of tag byte.\n-         *\/\n-        padding = (4 - (getPosition() + 1) % 4) % 4;\n-        super.setLength((short) (fixed_length + padding)); \/\/ Update length\n-        return super.getLength() - oldLength;\n+    final int getPadding() {\n+        return padding;\n@@ -351,20 +359,5 @@\n-    \/**\n-     * @param oldIh old target\n-     * @param newIh new target\n-     *\/\n-    @Override\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        boolean targeted = false;\n-        if (super.getTarget() == oldIh) {\n-            targeted = true;\n-            setTarget(newIh);\n-        }\n-        for (int i = 0; i < targets.length; i++) {\n-            if (targets[i] == oldIh) {\n-                targeted = true;\n-                setTarget(i, newIh);\n-            }\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh);\n-        }\n+\n+    \/** @since 6.0 *\/\n+    final int setIndices(final int i, final int value) {\n+        indices[i] = value;\n+        return value;  \/\/ Allow use in nested calls\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Select.java","additions":178,"deletions":185,"binary":false,"changes":363,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-public class SimpleElementValueGen extends ElementValueGen {\n+public class SimpleElementValueGen extends ElementValueGen\n+{\n@@ -42,1 +43,1 @@\n-    private final int idx;\n+    private int idx;\n@@ -44,1 +45,8 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final boolean value) {\n+    \/\/ ctors for each supported type... type could be inferred but for now lets\n+    \/\/ force it to be passed\n+    \/**\n+     * Protected ctor used for deserialization, doesn't *put* an entry in the\n+     * constant pool, assumes the one at the supplied index is correct.\n+     *\/\n+    protected SimpleElementValueGen(final int type, final int idx, final ConstantPoolGen cpGen)\n+    {\n@@ -46,5 +54,1 @@\n-        if (value) {\n-            idx = getConstantPool().addInteger(1);\n-        } else {\n-            idx = getConstantPool().addInteger(0);\n-        }\n+        this.idx = idx;\n@@ -53,1 +57,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final byte value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final int value)\n+    {\n@@ -58,1 +63,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final char value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final long value)\n+    {\n@@ -60,1 +66,1 @@\n-        idx = getConstantPool().addInteger(value);\n+        idx = getConstantPool().addLong(value);\n@@ -63,1 +69,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final double value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final double value)\n+    {\n@@ -68,1 +75,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final float value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final float value)\n+    {\n@@ -73,1 +81,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final int value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final short value)\n+    {\n@@ -78,1 +87,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final long value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final byte value)\n+    {\n@@ -80,1 +90,1 @@\n-        idx = getConstantPool().addLong(value);\n+        idx = getConstantPool().addInteger(value);\n@@ -83,1 +93,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final short value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final char value)\n+    {\n@@ -88,1 +99,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final String value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final boolean value)\n+    {\n@@ -90,1 +102,5 @@\n-        idx = getConstantPool().addUtf8(value);\n+        if (value) {\n+            idx = getConstantPool().addInteger(1);\n+        } else {\n+            idx = getConstantPool().addInteger(0);\n+        }\n@@ -93,7 +109,2 @@\n-    \/\/ ctors for each supported type... type could be inferred but for now lets\n-    \/\/ force it to be passed\n-    \/**\n-     * Protected ctor used for deserialization, doesn't *put* an entry in the constant pool, assumes the one at the supplied\n-     * index is correct.\n-     *\/\n-    protected SimpleElementValueGen(final int type, final int idx, final ConstantPoolGen cpGen) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final String value)\n+    {\n@@ -101,1 +112,1 @@\n-        this.idx = idx;\n+        idx = getConstantPool().addUtf8(value);\n@@ -105,2 +116,3 @@\n-     * The boolean controls whether we copy info from the 'old' constant pool to the 'new'. You need to use this ctor if the\n-     * annotation is being copied from one file to another.\n+     * The boolean controls whether we copy info from the 'old' constant pool to\n+     * the 'new'. You need to use this ctor if the annotation is being copied\n+     * from one file to another.\n@@ -108,1 +120,3 @@\n-    public SimpleElementValueGen(final SimpleElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+    public SimpleElementValueGen(final SimpleElementValue value,\n+            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n+    {\n@@ -110,1 +124,2 @@\n-        if (!copyPoolEntries) {\n+        if (!copyPoolEntries)\n+        {\n@@ -114,2 +129,5 @@\n-        } else {\n-            switch (value.getElementValueType()) {\n+        }\n+        else\n+        {\n+            switch (value.getElementValueType())\n+            {\n@@ -138,1 +156,2 @@\n-                if (value.getValueBoolean()) {\n+                if (value.getValueBoolean())\n+                {\n@@ -140,1 +159,3 @@\n-                } else {\n+                }\n+                else\n+                {\n@@ -148,1 +169,2 @@\n-                throw new IllegalArgumentException(\"SimpleElementValueGen class does not know how to copy this type \" + super.getElementValueType());\n+                throw new IllegalArgumentException(\n+                    \"SimpleElementValueGen class does not know how to copy this type \" + super.getElementValueType());\n@@ -153,20 +175,0 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n-        switch (super.getElementValueType()) {\n-        case PRIMITIVE_INT:\n-        case PRIMITIVE_BYTE:\n-        case PRIMITIVE_CHAR:\n-        case PRIMITIVE_FLOAT:\n-        case PRIMITIVE_LONG:\n-        case PRIMITIVE_BOOLEAN:\n-        case PRIMITIVE_SHORT:\n-        case PRIMITIVE_DOUBLE:\n-        case STRING:\n-            dos.writeShort(idx);\n-            break;\n-        default:\n-            throw new IllegalStateException(\"SimpleElementValueGen doesnt know how to write out type \" + super.getElementValueType());\n-        }\n-    }\n-\n@@ -177,1 +179,2 @@\n-    public ElementValue getElementValue() {\n+    public ElementValue getElementValue()\n+    {\n@@ -181,1 +184,2 @@\n-    public int getIndex() {\n+    public int getIndex()\n+    {\n@@ -185,3 +189,5 @@\n-    public int getValueInt() {\n-        if (super.getElementValueType() != PRIMITIVE_INT) {\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n+    public String getValueString()\n+    {\n+        if (super.getElementValueType() != STRING) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueString() on a non STRING ElementValue\");\n@@ -189,1 +195,1 @@\n-        final ConstantInteger c = (ConstantInteger) getConstantPool().getConstant(idx);\n+        final ConstantUtf8 c = (ConstantUtf8) getConstantPool().getConstant(idx);\n@@ -193,3 +199,5 @@\n-    public String getValueString() {\n-        if (super.getElementValueType() != STRING) {\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n+    public int getValueInt()\n+    {\n+        if (super.getElementValueType() != PRIMITIVE_INT) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueString() on a non STRING ElementValue\");\n@@ -197,1 +205,1 @@\n-        final ConstantUtf8 c = (ConstantUtf8) getConstantPool().getConstant(idx);\n+        final ConstantInteger c = (ConstantInteger) getConstantPool().getConstant(idx);\n@@ -203,2 +211,4 @@\n-    public String stringifyValue() {\n-        switch (super.getElementValueType()) {\n+    public String stringifyValue()\n+    {\n+        switch (super.getElementValueType())\n+        {\n@@ -236,1 +246,25 @@\n-            throw new IllegalStateException(\"SimpleElementValueGen class does not know how to stringify type \" + super.getElementValueType());\n+            throw new IllegalStateException(\n+                \"SimpleElementValueGen class does not know how to stringify type \" + super.getElementValueType());\n+        }\n+    }\n+\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n+        switch (super.getElementValueType())\n+        {\n+        case PRIMITIVE_INT:\n+        case PRIMITIVE_BYTE:\n+        case PRIMITIVE_CHAR:\n+        case PRIMITIVE_FLOAT:\n+        case PRIMITIVE_LONG:\n+        case PRIMITIVE_BOOLEAN:\n+        case PRIMITIVE_SHORT:\n+        case PRIMITIVE_DOUBLE:\n+        case STRING:\n+            dos.writeShort(idx);\n+            break;\n+        default:\n+            throw new IllegalStateException(\n+                \"SimpleElementValueGen doesnt know how to write out type \" + super.getElementValueType());\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SimpleElementValueGen.java","additions":103,"deletions":69,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -29,2 +30,1 @@\n-    \/**\n-     * @return how many words are consumed from stack\n+    \/** @return how many words are consumed from stack\n@@ -32,1 +32,1 @@\n-    int consumeStack(ConstantPoolGen cpg);\n+    int consumeStack( ConstantPoolGen cpg );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackConsumer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -30,1 +31,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -35,0 +37,1 @@\n+\n@@ -42,2 +45,2 @@\n-    \/**\n-     * @return Type.UNKNOWN\n+\n+    \/** @return Type.UNKNOWN\n@@ -45,1 +48,1 @@\n-    public Type getType(final ConstantPoolGen cp) {\n+    public Type getType( final ConstantPoolGen cp ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackInstruction.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denotes an instruction that may produce a value on top of the stack (this excludes DUP_X1, e.g.)\n+ * Denote an instruction that may produce a value on top of the stack\n+ * (this excludes DUP_X1, e.g.)\n+ *\n@@ -29,2 +31,1 @@\n-    \/**\n-     * @return how many words are produced on stack\n+    \/** @return how many words are produced on stack\n@@ -32,1 +33,1 @@\n-    int produceStack(ConstantPoolGen cpg);\n+    int produceStack( ConstantPoolGen cpg );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackProducer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denotes an unparameterized instruction to store a value into a local variable, e.g. ISTORE.\n+ * Denotes an unparameterized instruction to store a value into a local variable,\n+ * e.g. ISTORE.\n+ *\n@@ -30,2 +32,3 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n-     * readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n+     * tag and length are defined in readInstruction and initFromFile, respectively.\n@@ -33,2 +36,2 @@\n-    StoreInstruction(final short canonTag, final short cTag) {\n-        super(canonTag, cTag);\n+    StoreInstruction(final short canon_tag, final short c_tag) {\n+        super(canon_tag, c_tag);\n@@ -37,0 +40,1 @@\n+\n@@ -39,1 +43,1 @@\n-     * @param cTag Instruction number for compact version, ASTORE_0, e.g.\n+     * @param c_tag Instruction number for compact version, ASTORE_0, e.g.\n@@ -42,2 +46,2 @@\n-    protected StoreInstruction(final short opcode, final short cTag, final int n) {\n-        super(opcode, cTag, n);\n+    protected StoreInstruction(final short opcode, final short c_tag, final int n) {\n+        super(opcode, c_tag, n);\n@@ -46,0 +50,1 @@\n+\n@@ -47,2 +52,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -53,1 +60,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StoreInstruction.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -42,0 +43,1 @@\n+\n@@ -43,1 +45,2 @@\n-     * @param match sorted array of match values, match[0] must be low value, match[match_length - 1] high value\n+     * @param match sorted array of match values, match[0] must be low value,\n+     * match[match_length - 1] high value\n@@ -50,3 +53,3 @@\n-        final short length = (short) (13 + getMatchLength() * 4);\n-        super.setLength(length);\n-        setFixedLength(length);\n+        final short _length = (short) (13 + getMatch_length() * 4);\n+        super.setLength(_length);\n+        setFixed_length(_length);\n@@ -55,14 +58,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitSelect(this);\n-        v.visitTABLESWITCH(this);\n-    }\n@@ -72,1 +61,0 @@\n-     *\n@@ -76,1 +64,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -78,2 +66,2 @@\n-        final int matchLength = getMatchLength();\n-        final int low = matchLength > 0 ? super.getMatch(0) : 0;\n+        final int _match_length = getMatch_length();\n+        final int low = (_match_length > 0) ? super.getMatch(0) : 0;\n@@ -81,1 +69,1 @@\n-        final int high = matchLength > 0 ? super.getMatch(matchLength - 1) : 0;\n+        final int high = (_match_length > 0) ? super.getMatch(_match_length - 1) : 0;\n@@ -83,1 +71,1 @@\n-        for (int i = 0; i < matchLength; i++) {\n+        for (int i = 0; i < _match_length; i++) {\n@@ -88,0 +76,1 @@\n+\n@@ -92,1 +81,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -96,9 +85,9 @@\n-        final int matchLength = high - low + 1;\n-        setMatchLength(matchLength);\n-        final short fixedLength = (short) (13 + matchLength * 4);\n-        setFixedLength(fixedLength);\n-        super.setLength((short) (fixedLength + super.getPadding()));\n-        super.setMatches(new int[matchLength]);\n-        super.setIndices(new int[matchLength]);\n-        super.setTargets(new InstructionHandle[matchLength]);\n-        for (int i = 0; i < matchLength; i++) {\n+        final int _match_length = high - low + 1;\n+        setMatch_length(_match_length);\n+        final short _fixed_length = (short) (13 + _match_length * 4);\n+        setFixed_length(_fixed_length);\n+        super.setLength((short) (_fixed_length + super.getPadding()));\n+        super.setMatches(new int[_match_length]);\n+        super.setIndices(new int[_match_length]);\n+        super.setTargets(new InstructionHandle[_match_length]);\n+        for (int i = 0; i < _match_length; i++) {\n@@ -109,0 +98,18 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitSelect(this);\n+        v.visitTABLESWITCH(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TABLESWITCH.java","additions":42,"deletions":35,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -24,3 +25,4 @@\n- * Thrown by InstructionList.remove() when one or multiple disposed instructions are still being referenced by an\n- * InstructionTargeter object. I.e. the InstructionTargeter has to be notified that (one of) the InstructionHandle it is\n- * referencing is being removed from the InstructionList and thus not valid anymore.\n+ * Thrown by InstructionList.remove() when one or multiple disposed instructions\n+ * are still being referenced by an InstructionTargeter object. I.e. the\n+ * InstructionTargeter has to be notified that (one of) the InstructionHandle it\n+ * is referencing is being removed from the InstructionList and thus not valid anymore.\n@@ -28,4 +30,3 @@\n- * <p>\n- * Making this an exception instead of a return value forces the user to handle these case explicitly in a try { ... }\n- * catch. The following code illustrates how this may be done:\n- * <\/p>\n+ * <p>Making this an exception instead of a return value forces the user to handle\n+ * these case explicitely in a try { ... } catch. The following code illustrates\n+ * how this may be done:<\/p>\n@@ -49,1 +50,0 @@\n- * @LastModified: Feb 2023\n@@ -56,0 +56,1 @@\n+\n@@ -61,0 +62,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TargetLostException.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-import java.util.Arrays;\n@@ -25,1 +24,0 @@\n-import java.util.Objects;\n@@ -32,2 +30,3 @@\n- * Abstract super class for all possible java types, namely basic types such as int, object types like String and array\n- * types, e.g. int[]\n+ * Abstract super class for all possible java types, namely basic types\n+ * such as int, object types like String and array types, e.g. int[]\n+ *\n@@ -38,0 +37,2 @@\n+    private final byte type;\n+    private String signature; \/\/ signature for the type\n@@ -42,1 +43,0 @@\n-\n@@ -56,5 +56,1 @@\n-\n-    \/**\n-     * Empty array.\n-     *\/\n-    public static final Type[] NO_ARGS = {};\n+    public static final Type[] NO_ARGS = new Type[0]; \/\/ EMPTY, so immutable\n@@ -63,1 +59,0 @@\n-\n@@ -67,1 +62,0 @@\n-    private static final ThreadLocal<Integer> CONSUMED_CHARS = ThreadLocal.withInitial(() -> Integer.valueOf(0));\n@@ -69,3 +63,3 @@\n-    \/\/ int consumed_chars=0; \/\/ Remember position in string, see getArgumentTypes\n-    static int consumed(final int coded) {\n-        return coded >> 2;\n+    protected Type(final byte t, final String s) {\n+        type = t;\n+        signature = s;\n@@ -74,2 +68,7 @@\n-    static int encode(final int size, final int consumed) {\n-        return consumed << 2 | size;\n+\n+    \/**\n+     * @return hashcode of Type\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return type ^ signature.hashCode();\n@@ -78,0 +77,1 @@\n+\n@@ -79,4 +79,1 @@\n-     * Convert arguments of a method (signature) to an array of Type objects.\n-     *\n-     * @param signature signature string such as (Ljava\/lang\/String;)V\n-     * @return array of argument types\n+     * @return whether the Types are equal\n@@ -84,16 +81,34 @@\n-    public static Type[] getArgumentTypes(final String signature) {\n-        final List<Type> vec = new ArrayList<>();\n-        int index;\n-        try {\n-            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n-            index = signature.indexOf('(') + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            while (signature.charAt(index) != ')') {\n-                vec.add(getType(signature.substring(index)));\n-                \/\/ corrected concurrent private static field acess\n-                index += unwrap(CONSUMED_CHARS); \/\/ update position\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+    @Override\n+    public boolean equals(final Object o) {\n+          if (o instanceof Type) {\n+              final Type t = (Type)o;\n+              return (type == t.type) && signature.equals(t.signature);\n+          }\n+          return false;\n+    }\n+\n+\n+    \/**\n+     * @return signature for given type.\n+     *\/\n+    public String getSignature() {\n+        return signature;\n+    }\n+\n+\n+    \/**\n+     * @return type as defined in Constants\n+     *\/\n+    public byte getType() {\n+        return type;\n+    }\n+\n+    \/**\n+     * boolean, short and char variable are considered as int in the stack or local variable area.\n+     * Returns {@link Type#INT} for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise\n+     * returns the given type.\n+     * @since 6.0\n+     *\/\n+    public Type normalizeForStackOrLocal() {\n+        if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {\n+            return Type.INT;\n@@ -101,3 +116,1 @@\n-        final Type[] types = new Type[vec.size()];\n-        vec.toArray(types);\n-        return types;\n+        return this;\n@@ -106,16 +119,12 @@\n-    static int getArgumentTypesSize(final String signature) {\n-        int res = 0;\n-        int index;\n-        try {\n-            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n-            index = signature.indexOf('(') + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            while (signature.charAt(index) != ')') {\n-                final int coded = getTypeSize(signature.substring(index));\n-                res += size(coded);\n-                index += consumed(coded);\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+    \/**\n+     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)\n+     *\/\n+    public int getSize() {\n+        switch (type) {\n+            case Const.T_DOUBLE:\n+            case Const.T_LONG:\n+                return 2;\n+            case Const.T_VOID:\n+                return 0;\n+            default:\n+                return 1;\n@@ -123,1 +132,0 @@\n-        return res;\n@@ -126,0 +134,1 @@\n+\n@@ -127,1 +136,12 @@\n-     * Convert type to Java method signature, e.g. int[] f(java.lang.String x) becomes (Ljava\/lang\/String;)[I\n+     * @return Type string, e.g. `int[]'\n+     *\/\n+    @Override\n+    public String toString() {\n+        return ((this.equals(Type.NULL) || (type >= Const.T_UNKNOWN))) ? signature : Utility\n+                .signatureToString(signature, false);\n+    }\n+\n+\n+    \/**\n+     * Convert type to Java method signature, e.g. int[] f(java.lang.String x)\n+     * becomes (Ljava\/lang\/String;)[I\n@@ -129,2 +149,2 @@\n-     * @param returnType what the method returns\n-     * @param argTypes what are the argument types\n+     * @param return_type what the method returns\n+     * @param arg_types what are the argument types\n@@ -133,1 +153,1 @@\n-    public static String getMethodSignature(final Type returnType, final Type[] argTypes) {\n+    public static String getMethodSignature( final Type return_type, final Type[] arg_types ) {\n@@ -135,3 +155,3 @@\n-        if (argTypes != null) {\n-            for (final Type argType : argTypes) {\n-                buf.append(argType.getSignature());\n+        if (arg_types != null) {\n+            for (final Type arg_type : arg_types) {\n+                buf.append(arg_type.getSignature());\n@@ -141,1 +161,1 @@\n-        buf.append(returnType.getSignature());\n+        buf.append(return_type.getSignature());\n@@ -145,0 +165,52 @@\n+    private static final ThreadLocal<Integer> consumed_chars = new ThreadLocal<Integer>() {\n+\n+        @Override\n+        protected Integer initialValue() {\n+            return Integer.valueOf(0);\n+        }\n+    };\/\/int consumed_chars=0; \/\/ Remember position in string, see getArgumentTypes\n+\n+\n+    private static int unwrap( final ThreadLocal<Integer> tl ) {\n+        return tl.get().intValue();\n+    }\n+\n+\n+    private static void wrap( final ThreadLocal<Integer> tl, final int value ) {\n+        tl.set(Integer.valueOf(value));\n+    }\n+\n+\n+    \/**\n+     * Convert signature to a Type object.\n+     * @param signature signature string such as Ljava\/lang\/String;\n+     * @return type object\n+     *\/\n+    \/\/ @since 6.0 no longer final\n+    public static Type getType( final String signature ) throws StringIndexOutOfBoundsException {\n+        final byte type = Utility.typeOfSignature(signature);\n+        if (type <= Const.T_VOID) {\n+            \/\/corrected concurrent private static field acess\n+            wrap(consumed_chars, 1);\n+            return BasicType.getType(type);\n+        } else if (type == Const.T_ARRAY) {\n+            int dim = 0;\n+            do { \/\/ Count dimensions\n+                dim++;\n+            } while (signature.charAt(dim) == '[');\n+            \/\/ Recurse, but just once, if the signature is ok\n+            final Type t = getType(signature.substring(dim));\n+            \/\/corrected concurrent private static field acess\n+            \/\/  consumed_chars += dim; \/\/ update counter - is replaced by\n+            final int _temp = unwrap(consumed_chars) + dim;\n+            wrap(consumed_chars, _temp);\n+            return new ArrayType(t, dim);\n+        } else { \/\/ type == T_REFERENCE\n+            \/\/ Utility.typeSignatureToString understands how to parse generic types.\n+            final String parsedSignature = Utility.typeSignatureToString(signature, false);\n+            wrap(consumed_chars, parsedSignature.length() + 2); \/\/ \"Lblabla;\" `L' and `;' are removed\n+            return ObjectType.getInstance(parsedSignature.replace('\/', '.'));\n+        }\n+    }\n+\n+\n@@ -151,1 +223,1 @@\n-    public static Type getReturnType(final String signature) {\n+    public static Type getReturnType( final String signature ) {\n@@ -153,1 +225,1 @@\n-            \/\/ Read return type after ')'\n+            \/\/ Read return type after `)'\n@@ -161,15 +233,0 @@\n-    static int getReturnTypeSize(final String signature) {\n-        final int index = signature.lastIndexOf(')') + 1;\n-        return Type.size(getTypeSize(signature.substring(index)));\n-    }\n-\n-    public static String getSignature(final java.lang.reflect.Method meth) {\n-        final StringBuilder sb = new StringBuilder(\"(\");\n-        final Class<?>[] params = meth.getParameterTypes(); \/\/ avoid clone\n-        for (final Class<?> param : params) {\n-            sb.append(getType(param).getSignature());\n-        }\n-        sb.append(\")\");\n-        sb.append(getType(meth.getReturnType()).getSignature());\n-        return sb.toString();\n-    }\n@@ -178,4 +235,3 @@\n-     * Convert runtime java.lang.Class to BCEL Type object.\n-     *\n-     * @param cls Java class\n-     * @return corresponding Type object\n+     * Convert arguments of a method (signature) to an array of Type objects.\n+     * @param signature signature string such as (Ljava\/lang\/String;)V\n+     * @return array of argument types\n@@ -183,37 +239,17 @@\n-    public static Type getType(final Class<?> cls) {\n-        Objects.requireNonNull(cls, \"cls\");\n-        \/*\n-         * That's an amzingly easy case, because getName() returns the signature. That's what we would have liked anyway.\n-         *\/\n-        if (cls.isArray()) {\n-            return getType(cls.getName());\n-        }\n-        if (!cls.isPrimitive()) { \/\/ \"Real\" class\n-            return ObjectType.getInstance(cls.getName());\n-        }\n-        if (cls == Integer.TYPE) {\n-            return INT;\n-        }\n-        if (cls == Void.TYPE) {\n-            return VOID;\n-        }\n-        if (cls == Double.TYPE) {\n-            return DOUBLE;\n-        }\n-        if (cls == Float.TYPE) {\n-            return FLOAT;\n-        }\n-        if (cls == Boolean.TYPE) {\n-            return BOOLEAN;\n-        }\n-        if (cls == Byte.TYPE) {\n-            return BYTE;\n-        }\n-        if (cls == Short.TYPE) {\n-            return SHORT;\n-        }\n-        if (cls == Long.TYPE) {\n-            return LONG;\n-        }\n-        if (cls == Character.TYPE) {\n-            return CHAR;\n+    public static Type[] getArgumentTypes( final String signature ) {\n+        final List<Type> vec = new ArrayList<>();\n+        int index;\n+        Type[] types;\n+        try {\n+            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n+            index = signature.indexOf('(') + 1;\n+            if (index <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+            while (signature.charAt(index) != ')') {\n+                vec.add(getType(signature.substring(index)));\n+                \/\/corrected concurrent private static field acess\n+                index += unwrap(consumed_chars); \/\/ update position\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n@@ -221,1 +257,3 @@\n-        throw new IllegalStateException(\"Unknown primitive type \" + cls);\n+        types = new Type[vec.size()];\n+        vec.toArray(types);\n+        return types;\n@@ -224,5 +262,4 @@\n-    \/**\n-     * Convert signature to a Type object.\n-     *\n-     * @param signature signature string such as Ljava\/lang\/String;\n-     * @return type object\n+\n+    \/** Convert runtime java.lang.Class to BCEL Type object.\n+     * @param cl Java class\n+     * @return corresponding Type object\n@@ -230,6 +267,3 @@\n-    public static Type getType(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= Const.T_VOID) {\n-            \/\/ corrected concurrent private static field acess\n-            wrap(CONSUMED_CHARS, 1);\n-            return BasicType.getType(type);\n+    public static Type getType( final java.lang.Class<?> cl ) {\n+        if (cl == null) {\n+            throw new IllegalArgumentException(\"Class must not be null\");\n@@ -237,5 +271,31 @@\n-        if (type != Const.T_ARRAY) { \/\/ type == T_REFERENCE\n-            \/\/ Utility.typeSignatureToString understands how to parse generic types.\n-            final String parsedSignature = Utility.typeSignatureToString(signature, false);\n-            wrap(CONSUMED_CHARS, parsedSignature.length() + 2); \/\/ \"Lblabla;\" 'L' and ';' are removed\n-            return ObjectType.getInstance(Utility.pathToPackage(parsedSignature));\n+        \/* That's an amzingly easy case, because getName() returns\n+         * the signature. That's what we would have liked anyway.\n+         *\/\n+        if (cl.isArray()) {\n+            return getType(cl.getName());\n+        } else if (cl.isPrimitive()) {\n+            if (cl == Integer.TYPE) {\n+                return INT;\n+            } else if (cl == Void.TYPE) {\n+                return VOID;\n+            } else if (cl == Double.TYPE) {\n+                return DOUBLE;\n+            } else if (cl == Float.TYPE) {\n+                return FLOAT;\n+            } else if (cl == Boolean.TYPE) {\n+                return BOOLEAN;\n+            } else if (cl == Byte.TYPE) {\n+                return BYTE;\n+            } else if (cl == Short.TYPE) {\n+                return SHORT;\n+            } else if (cl == Byte.TYPE) {\n+                return BYTE;\n+            } else if (cl == Long.TYPE) {\n+                return LONG;\n+            } else if (cl == Character.TYPE) {\n+                return CHAR;\n+            } else {\n+                throw new IllegalStateException(\"Unknown primitive type \" + cl);\n+            }\n+        } else { \/\/ \"Real\" class\n+            return ObjectType.getInstance(cl.getName());\n@@ -243,11 +303,0 @@\n-        int dim = 0;\n-        do { \/\/ Count dimensions\n-            dim++;\n-        } while (signature.charAt(dim) == '[');\n-        \/\/ Recurse, but just once, if the signature is ok\n-        final Type t = getType(signature.substring(dim));\n-        \/\/ corrected concurrent private static field acess\n-        \/\/ consumed_chars += dim; \/\/ update counter - is replaced by\n-        final int temp = unwrap(CONSUMED_CHARS) + dim;\n-        wrap(CONSUMED_CHARS, temp);\n-        return new ArrayType(t, dim);\n@@ -256,0 +305,1 @@\n+\n@@ -258,1 +308,0 @@\n-     *\n@@ -262,1 +311,1 @@\n-    public static Type[] getTypes(final Class<?>[] classes) {\n+    public static Type[] getTypes( final java.lang.Class<?>[] classes ) {\n@@ -264,1 +313,3 @@\n-        Arrays.setAll(ret, i -> getType(classes[i]));\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = getType(classes[i]);\n+        }\n@@ -268,17 +319,6 @@\n-    static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= Const.T_VOID) {\n-            return encode(BasicType.getType(type).getSize(), 1);\n-        }\n-        if (type == Const.T_ARRAY) {\n-            int dim = 0;\n-            do { \/\/ Count dimensions\n-                dim++;\n-            } while (signature.charAt(dim) == '[');\n-            \/\/ Recurse, but just once, if the signature is ok\n-            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n-            return encode(1, dim + consumed);\n-        }\n-        final int index = signature.indexOf(';'); \/\/ Look for closing ';'\n-        if (index < 0) {\n-            throw new ClassFormatException(\"Invalid signature: \" + signature);\n+\n+    public static String getSignature( final java.lang.reflect.Method meth ) {\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        final Class<?>[] params = meth.getParameterTypes(); \/\/ avoid clone\n+        for (final Class<?> param : params) {\n+            sb.append(getType(param).getSignature());\n@@ -286,1 +326,3 @@\n-        return encode(1, index + 1);\n+        sb.append(\")\");\n+        sb.append(getType(meth.getReturnType()).getSignature());\n+        return sb.toString();\n@@ -293,6 +335,2 @@\n-    private static int unwrap(final ThreadLocal<Integer> tl) {\n-        return tl.get().intValue();\n-    }\n-\n-    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n-        tl.set(Integer.valueOf(value));\n+    static int consumed(final int coded) {\n+        return coded >> 2;\n@@ -301,15 +339,2 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected byte type; \/\/ TODO should be final (and private)\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected String signature; \/\/ signature for the type TODO should be private\n-\n-    protected Type(final byte type, final String signature) {\n-        this.type = type;\n-        this.signature = signature;\n+    static int encode(final int size, final int consumed) {\n+        return consumed << 2 | size;\n@@ -318,8 +343,16 @@\n-    \/**\n-     * @return whether the Types are equal\n-     *\/\n-    @Override\n-    public boolean equals(final Object o) {\n-        if (o instanceof Type) {\n-            final Type t = (Type) o;\n-            return type == t.type && signature.equals(t.signature);\n+    static int getArgumentTypesSize( final String signature ) {\n+        int res = 0;\n+        int index;\n+        try {\n+            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n+            index = signature.indexOf('(') + 1;\n+            if (index <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+            while (signature.charAt(index) != ')') {\n+                final int coded = getTypeSize(signature.substring(index));\n+                res += size(coded);\n+                index += consumed(coded);\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n@@ -327,12 +360,1 @@\n-        return false;\n-    }\n-\n-    public String getClassName() {\n-        return toString();\n-    }\n-\n-    \/**\n-     * @return signature for given type.\n-     *\/\n-    public String getSignature() {\n-        return signature;\n+        return res;\n@@ -341,12 +363,18 @@\n-    \/**\n-     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)\n-     *\/\n-    public int getSize() {\n-        switch (type) {\n-        case Const.T_DOUBLE:\n-        case Const.T_LONG:\n-            return 2;\n-        case Const.T_VOID:\n-            return 0;\n-        default:\n-            return 1;\n+    static int getTypeSize( final String signature ) throws StringIndexOutOfBoundsException {\n+        final byte type = Utility.typeOfSignature(signature);\n+        if (type <= Const.T_VOID) {\n+            return encode(BasicType.getType(type).getSize(), 1);\n+        } else if (type == Const.T_ARRAY) {\n+            int dim = 0;\n+            do { \/\/ Count dimensions\n+                dim++;\n+            } while (signature.charAt(dim) == '[');\n+            \/\/ Recurse, but just once, if the signature is ok\n+            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n+            return encode(1, dim + consumed);\n+        } else { \/\/ type == T_REFERENCE\n+            final int index = signature.indexOf(';'); \/\/ Look for closing `;'\n+            if (index < 0) {\n+                throw new ClassFormatException(\"Invalid signature: \" + signature);\n+            }\n+            return encode(1, index + 1);\n@@ -356,6 +384,0 @@\n-    \/**\n-     * @return type as defined in Constants\n-     *\/\n-    public byte getType() {\n-        return type;\n-    }\n@@ -363,6 +385,3 @@\n-    \/**\n-     * @return hashcode of Type\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return type ^ signature.hashCode();\n+    static int getReturnTypeSize(final String signature) {\n+        final int index = signature.lastIndexOf(')') + 1;\n+        return Type.size(getTypeSize(signature.substring(index)));\n@@ -371,12 +390,0 @@\n-    \/**\n-     * boolean, short and char variable are considered as int in the stack or local variable area. Returns {@link Type#INT}\n-     * for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise returns the given type.\n-     *\n-     * @since 6.0\n-     *\/\n-    public Type normalizeForStackOrLocal() {\n-        if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {\n-            return Type.INT;\n-        }\n-        return this;\n-    }\n@@ -385,2 +392,3 @@\n-     * Currently only used by the ArrayType constructor. The signature has a complicated dependency on other parameter so\n-     * it's tricky to do it in a call to the super ctor.\n+     * Currently only used by the ArrayType constructor.\n+     * The signature has a complicated dependency on other parameter\n+     * so it's tricky to do it in a call to the super ctor.\n@@ -391,8 +399,0 @@\n-\n-    \/**\n-     * @return Type string, e.g. 'int[]'\n-     *\/\n-    @Override\n-    public String toString() {\n-        return this.equals(Type.NULL) || type >= Const.T_UNKNOWN ? signature : Utility.signatureToString(signature, false);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Type.java","additions":259,"deletions":259,"binary":false,"changes":518,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Get the type associated with an instruction, int for ILOAD, or the type of the field of a PUTFIELD instruction, e.g..\n+ * Get the type associated with an instruction, int for ILOAD, or the type\n+ * of the field of a PUTFIELD instruction, e.g..\n+ *\n@@ -29,1 +31,1 @@\n-    Type getType(ConstantPoolGen cpg);\n+    Type getType( ConstantPoolGen cpg );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TypedInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/UnconditionalBranch.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Denotes an instruction to be a variable length instruction, such as GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n- *\n+ * Denotes an instruction to be a variable length instruction, such as\n+ * GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n@@ -28,0 +28,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/VariableLengthInstruction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,2 +25,5 @@\n- * Interface implementing the Visitor pattern programming style. I.e., a class that implements this interface can handle\n- * all types of instructions with the properly typed methods just by calling the accept() method.\n+ * Interface implementing the Visitor pattern programming style.\n+ * I.e., a class that implements this interface can handle all types of\n+ * instructions with the properly typed methods just by calling the accept()\n+ * method.\n+ *\n@@ -30,1 +33,136 @@\n-    void visitAALOAD(AALOAD obj);\n+    void visitStackInstruction( StackInstruction obj );\n+\n+\n+    void visitLocalVariableInstruction( LocalVariableInstruction obj );\n+\n+\n+    void visitBranchInstruction( BranchInstruction obj );\n+\n+\n+    void visitLoadClass( LoadClass obj );\n+\n+\n+    void visitFieldInstruction( FieldInstruction obj );\n+\n+\n+    void visitIfInstruction( IfInstruction obj );\n+\n+\n+    void visitConversionInstruction( ConversionInstruction obj );\n+\n+\n+    void visitPopInstruction( PopInstruction obj );\n+\n+\n+    void visitStoreInstruction( StoreInstruction obj );\n+\n+\n+    void visitTypedInstruction( TypedInstruction obj );\n+\n+\n+    void visitSelect( Select obj );\n+\n+\n+    void visitJsrInstruction( JsrInstruction obj );\n+\n+\n+    void visitGotoInstruction( GotoInstruction obj );\n+\n+\n+    void visitUnconditionalBranch( UnconditionalBranch obj );\n+\n+\n+    void visitPushInstruction( PushInstruction obj );\n+\n+\n+    void visitArithmeticInstruction( ArithmeticInstruction obj );\n+\n+\n+    void visitCPInstruction( CPInstruction obj );\n+\n+\n+    void visitInvokeInstruction( InvokeInstruction obj );\n+\n+\n+    void visitArrayInstruction( ArrayInstruction obj );\n+\n+\n+    void visitAllocationInstruction( AllocationInstruction obj );\n+\n+\n+    void visitReturnInstruction( ReturnInstruction obj );\n+\n+\n+    void visitFieldOrMethod( FieldOrMethod obj );\n+\n+\n+    void visitConstantPushInstruction( ConstantPushInstruction obj );\n+\n+\n+    void visitExceptionThrower( ExceptionThrower obj );\n+\n+\n+    void visitLoadInstruction( LoadInstruction obj );\n+\n+\n+    void visitVariableLengthInstruction( VariableLengthInstruction obj );\n+\n+\n+    void visitStackProducer( StackProducer obj );\n+\n+\n+    void visitStackConsumer( StackConsumer obj );\n+\n+\n+    void visitACONST_NULL( ACONST_NULL obj );\n+\n+\n+    void visitGETSTATIC( GETSTATIC obj );\n+\n+\n+    void visitIF_ICMPLT( IF_ICMPLT obj );\n+\n+\n+    void visitMONITOREXIT( MONITOREXIT obj );\n+\n+\n+    void visitIFLT( IFLT obj );\n+\n+\n+    void visitLSTORE( LSTORE obj );\n+\n+\n+    void visitPOP2( POP2 obj );\n+\n+\n+    void visitBASTORE( BASTORE obj );\n+\n+\n+    void visitISTORE( ISTORE obj );\n+\n+\n+    void visitCHECKCAST( CHECKCAST obj );\n+\n+\n+    void visitFCMPG( FCMPG obj );\n+\n+\n+    void visitI2F( I2F obj );\n+\n+\n+    void visitATHROW( ATHROW obj );\n+\n+\n+    void visitDCMPL( DCMPL obj );\n+\n+\n+    void visitARRAYLENGTH( ARRAYLENGTH obj );\n+\n+\n+    void visitDUP( DUP obj );\n+\n+\n+    void visitINVOKESTATIC( INVOKESTATIC obj );\n+\n+\n+    void visitLCONST( LCONST obj );\n@@ -32,1 +170,0 @@\n-    void visitAASTORE(AASTORE obj);\n@@ -34,1 +171,1 @@\n-    void visitACONST_NULL(ACONST_NULL obj);\n+    void visitDREM( DREM obj );\n@@ -36,1 +173,0 @@\n-    void visitAllocationInstruction(AllocationInstruction obj);\n@@ -38,1 +174,1 @@\n-    void visitALOAD(ALOAD obj);\n+    void visitIFGE( IFGE obj );\n@@ -40,1 +176,0 @@\n-    void visitANEWARRAY(ANEWARRAY obj);\n@@ -42,1 +177,1 @@\n-    void visitARETURN(ARETURN obj);\n+    void visitCALOAD( CALOAD obj );\n@@ -44,1 +179,0 @@\n-    void visitArithmeticInstruction(ArithmeticInstruction obj);\n@@ -46,1 +180,1 @@\n-    void visitArrayInstruction(ArrayInstruction obj);\n+    void visitLASTORE( LASTORE obj );\n@@ -48,1 +182,0 @@\n-    void visitARRAYLENGTH(ARRAYLENGTH obj);\n@@ -50,1 +183,1 @@\n-    void visitASTORE(ASTORE obj);\n+    void visitI2D( I2D obj );\n@@ -52,1 +185,0 @@\n-    void visitATHROW(ATHROW obj);\n@@ -54,1 +186,1 @@\n-    void visitBALOAD(BALOAD obj);\n+    void visitDADD( DADD obj );\n@@ -56,1 +188,0 @@\n-    void visitBASTORE(BASTORE obj);\n@@ -58,1 +189,1 @@\n-    void visitBIPUSH(BIPUSH obj);\n+    void visitINVOKESPECIAL( INVOKESPECIAL obj );\n@@ -60,1 +191,0 @@\n-    void visitBranchInstruction(BranchInstruction obj);\n@@ -62,1 +192,1 @@\n-    void visitBREAKPOINT(BREAKPOINT obj);\n+    void visitIAND( IAND obj );\n@@ -64,1 +194,0 @@\n-    void visitCALOAD(CALOAD obj);\n@@ -66,1 +195,1 @@\n-    void visitCASTORE(CASTORE obj);\n+    void visitPUTFIELD( PUTFIELD obj );\n@@ -68,1 +197,0 @@\n-    void visitCHECKCAST(CHECKCAST obj);\n@@ -70,1 +198,1 @@\n-    void visitConstantPushInstruction(ConstantPushInstruction obj);\n+    void visitILOAD( ILOAD obj );\n@@ -72,1 +200,0 @@\n-    void visitConversionInstruction(ConversionInstruction obj);\n@@ -74,1 +201,1 @@\n-    void visitCPInstruction(CPInstruction obj);\n+    void visitDLOAD( DLOAD obj );\n@@ -76,1 +203,0 @@\n-    void visitD2F(D2F obj);\n@@ -78,1 +204,1 @@\n-    void visitD2I(D2I obj);\n+    void visitDCONST( DCONST obj );\n@@ -80,1 +206,0 @@\n-    void visitD2L(D2L obj);\n@@ -82,1 +207,1 @@\n-    void visitDADD(DADD obj);\n+    void visitNEW( NEW obj );\n@@ -84,1 +209,0 @@\n-    void visitDALOAD(DALOAD obj);\n@@ -86,1 +210,1 @@\n-    void visitDASTORE(DASTORE obj);\n+    void visitIFNULL( IFNULL obj );\n@@ -88,1 +212,0 @@\n-    void visitDCMPG(DCMPG obj);\n@@ -90,1 +213,1 @@\n-    void visitDCMPL(DCMPL obj);\n+    void visitLSUB( LSUB obj );\n@@ -92,1 +215,0 @@\n-    void visitDCONST(DCONST obj);\n@@ -94,1 +216,1 @@\n-    void visitDDIV(DDIV obj);\n+    void visitL2I( L2I obj );\n@@ -96,1 +218,0 @@\n-    void visitDLOAD(DLOAD obj);\n@@ -98,1 +219,1 @@\n-    void visitDMUL(DMUL obj);\n+    void visitISHR( ISHR obj );\n@@ -100,1 +221,0 @@\n-    void visitDNEG(DNEG obj);\n@@ -102,1 +222,1 @@\n-    void visitDREM(DREM obj);\n+    void visitTABLESWITCH( TABLESWITCH obj );\n@@ -104,1 +224,0 @@\n-    void visitDRETURN(DRETURN obj);\n@@ -106,1 +225,1 @@\n-    void visitDSTORE(DSTORE obj);\n+    void visitIINC( IINC obj );\n@@ -108,1 +227,0 @@\n-    void visitDSUB(DSUB obj);\n@@ -110,1 +228,1 @@\n-    void visitDUP(DUP obj);\n+    void visitDRETURN( DRETURN obj );\n@@ -112,1 +230,0 @@\n-    void visitDUP_X1(DUP_X1 obj);\n@@ -114,1 +231,1 @@\n-    void visitDUP_X2(DUP_X2 obj);\n+    void visitFSTORE( FSTORE obj );\n@@ -116,1 +233,0 @@\n-    void visitDUP2(DUP2 obj);\n@@ -118,1 +234,1 @@\n-    void visitDUP2_X1(DUP2_X1 obj);\n+    void visitDASTORE( DASTORE obj );\n@@ -120,1 +236,0 @@\n-    void visitDUP2_X2(DUP2_X2 obj);\n@@ -122,1 +237,1 @@\n-    void visitExceptionThrower(ExceptionThrower obj);\n+    void visitIALOAD( IALOAD obj );\n@@ -124,1 +239,0 @@\n-    void visitF2D(F2D obj);\n@@ -126,1 +240,1 @@\n-    void visitF2I(F2I obj);\n+    void visitDDIV( DDIV obj );\n@@ -128,1 +242,0 @@\n-    void visitF2L(F2L obj);\n@@ -130,1 +243,1 @@\n-    void visitFADD(FADD obj);\n+    void visitIF_ICMPGE( IF_ICMPGE obj );\n@@ -132,1 +245,0 @@\n-    void visitFALOAD(FALOAD obj);\n@@ -134,1 +246,1 @@\n-    void visitFASTORE(FASTORE obj);\n+    void visitLAND( LAND obj );\n@@ -136,1 +248,0 @@\n-    void visitFCMPG(FCMPG obj);\n@@ -138,1 +249,1 @@\n-    void visitFCMPL(FCMPL obj);\n+    void visitIDIV( IDIV obj );\n@@ -140,1 +251,0 @@\n-    void visitFCONST(FCONST obj);\n@@ -142,1 +252,1 @@\n-    void visitFDIV(FDIV obj);\n+    void visitLOR( LOR obj );\n@@ -144,1 +254,0 @@\n-    void visitFieldInstruction(FieldInstruction obj);\n@@ -146,1 +255,1 @@\n-    void visitFieldOrMethod(FieldOrMethod obj);\n+    void visitCASTORE( CASTORE obj );\n@@ -148,1 +257,0 @@\n-    void visitFLOAD(FLOAD obj);\n@@ -150,1 +258,1 @@\n-    void visitFMUL(FMUL obj);\n+    void visitFREM( FREM obj );\n@@ -152,1 +260,0 @@\n-    void visitFNEG(FNEG obj);\n@@ -154,1 +261,1 @@\n-    void visitFREM(FREM obj);\n+    void visitLDC( LDC obj );\n@@ -156,1 +263,0 @@\n-    void visitFRETURN(FRETURN obj);\n@@ -158,1 +264,1 @@\n-    void visitFSTORE(FSTORE obj);\n+    void visitBIPUSH( BIPUSH obj );\n@@ -160,1 +266,0 @@\n-    void visitFSUB(FSUB obj);\n@@ -162,1 +267,1 @@\n-    void visitGETFIELD(GETFIELD obj);\n+    void visitDSTORE( DSTORE obj );\n@@ -164,1 +269,0 @@\n-    void visitGETSTATIC(GETSTATIC obj);\n@@ -166,1 +270,1 @@\n-    void visitGOTO(GOTO obj);\n+    void visitF2L( F2L obj );\n@@ -168,1 +272,0 @@\n-    void visitGOTO_W(GOTO_W obj);\n@@ -170,1 +273,1 @@\n-    void visitGotoInstruction(GotoInstruction obj);\n+    void visitFMUL( FMUL obj );\n@@ -172,1 +275,0 @@\n-    void visitI2B(I2B obj);\n@@ -174,1 +276,1 @@\n-    void visitI2C(I2C obj);\n+    void visitLLOAD( LLOAD obj );\n@@ -176,1 +278,0 @@\n-    void visitI2D(I2D obj);\n@@ -178,1 +279,1 @@\n-    void visitI2F(I2F obj);\n+    void visitJSR( JSR obj );\n@@ -180,1 +281,0 @@\n-    void visitI2L(I2L obj);\n@@ -182,1 +282,1 @@\n-    void visitI2S(I2S obj);\n+    void visitFSUB( FSUB obj );\n@@ -184,1 +284,0 @@\n-    void visitIADD(IADD obj);\n@@ -186,1 +285,1 @@\n-    void visitIALOAD(IALOAD obj);\n+    void visitSASTORE( SASTORE obj );\n@@ -188,1 +287,0 @@\n-    void visitIAND(IAND obj);\n@@ -190,1 +288,1 @@\n-    void visitIASTORE(IASTORE obj);\n+    void visitALOAD( ALOAD obj );\n@@ -192,1 +290,0 @@\n-    void visitICONST(ICONST obj);\n@@ -194,1 +291,1 @@\n-    void visitIDIV(IDIV obj);\n+    void visitDUP2_X2( DUP2_X2 obj );\n@@ -196,1 +293,0 @@\n-    void visitIF_ACMPEQ(IF_ACMPEQ obj);\n@@ -198,1 +294,1 @@\n-    void visitIF_ACMPNE(IF_ACMPNE obj);\n+    void visitRETURN( RETURN obj );\n@@ -200,1 +296,0 @@\n-    void visitIF_ICMPEQ(IF_ICMPEQ obj);\n@@ -202,1 +297,1 @@\n-    void visitIF_ICMPGE(IF_ICMPGE obj);\n+    void visitDALOAD( DALOAD obj );\n@@ -204,1 +299,0 @@\n-    void visitIF_ICMPGT(IF_ICMPGT obj);\n@@ -206,1 +300,1 @@\n-    void visitIF_ICMPLE(IF_ICMPLE obj);\n+    void visitSIPUSH( SIPUSH obj );\n@@ -208,1 +302,0 @@\n-    void visitIF_ICMPLT(IF_ICMPLT obj);\n@@ -210,1 +303,1 @@\n-    void visitIF_ICMPNE(IF_ICMPNE obj);\n+    void visitDSUB( DSUB obj );\n@@ -212,1 +305,0 @@\n-    void visitIFEQ(IFEQ obj);\n@@ -214,1 +306,1 @@\n-    void visitIFGE(IFGE obj);\n+    void visitL2F( L2F obj );\n@@ -216,1 +308,0 @@\n-    void visitIFGT(IFGT obj);\n@@ -218,1 +309,1 @@\n-    void visitIfInstruction(IfInstruction obj);\n+    void visitIF_ICMPGT( IF_ICMPGT obj );\n@@ -220,1 +311,0 @@\n-    void visitIFLE(IFLE obj);\n@@ -222,1 +312,1 @@\n-    void visitIFLT(IFLT obj);\n+    void visitF2D( F2D obj );\n@@ -224,1 +314,0 @@\n-    void visitIFNE(IFNE obj);\n@@ -226,1 +315,1 @@\n-    void visitIFNONNULL(IFNONNULL obj);\n+    void visitI2L( I2L obj );\n@@ -228,1 +317,0 @@\n-    void visitIFNULL(IFNULL obj);\n@@ -230,1 +318,1 @@\n-    void visitIINC(IINC obj);\n+    void visitIF_ACMPNE( IF_ACMPNE obj );\n@@ -232,1 +320,0 @@\n-    void visitILOAD(ILOAD obj);\n@@ -234,1 +321,1 @@\n-    void visitIMPDEP1(IMPDEP1 obj);\n+    void visitPOP( POP obj );\n@@ -236,1 +323,0 @@\n-    void visitIMPDEP2(IMPDEP2 obj);\n@@ -238,1 +324,1 @@\n-    void visitIMUL(IMUL obj);\n+    void visitI2S( I2S obj );\n@@ -240,1 +326,0 @@\n-    void visitINEG(INEG obj);\n@@ -242,1 +327,125 @@\n-    void visitINSTANCEOF(INSTANCEOF obj);\n+    void visitIFEQ( IFEQ obj );\n+\n+\n+    void visitSWAP( SWAP obj );\n+\n+\n+    void visitIOR( IOR obj );\n+\n+\n+    void visitIREM( IREM obj );\n+\n+\n+    void visitIASTORE( IASTORE obj );\n+\n+\n+    void visitNEWARRAY( NEWARRAY obj );\n+\n+\n+    void visitINVOKEINTERFACE( INVOKEINTERFACE obj );\n+\n+\n+    void visitINEG( INEG obj );\n+\n+\n+    void visitLCMP( LCMP obj );\n+\n+\n+    void visitJSR_W( JSR_W obj );\n+\n+\n+    void visitMULTIANEWARRAY( MULTIANEWARRAY obj );\n+\n+\n+    void visitDUP_X2( DUP_X2 obj );\n+\n+\n+    void visitSALOAD( SALOAD obj );\n+\n+\n+    void visitIFNONNULL( IFNONNULL obj );\n+\n+\n+    void visitDMUL( DMUL obj );\n+\n+\n+    void visitIFNE( IFNE obj );\n+\n+\n+    void visitIF_ICMPLE( IF_ICMPLE obj );\n+\n+\n+    void visitLDC2_W( LDC2_W obj );\n+\n+\n+    void visitGETFIELD( GETFIELD obj );\n+\n+\n+    void visitLADD( LADD obj );\n+\n+\n+    void visitNOP( NOP obj );\n+\n+\n+    void visitFALOAD( FALOAD obj );\n+\n+\n+    void visitINSTANCEOF( INSTANCEOF obj );\n+\n+\n+    void visitIFLE( IFLE obj );\n+\n+\n+    void visitLXOR( LXOR obj );\n+\n+\n+    void visitLRETURN( LRETURN obj );\n+\n+\n+    void visitFCONST( FCONST obj );\n+\n+\n+    void visitIUSHR( IUSHR obj );\n+\n+\n+    void visitBALOAD( BALOAD obj );\n+\n+\n+    void visitDUP2( DUP2 obj );\n+\n+\n+    void visitIF_ACMPEQ( IF_ACMPEQ obj );\n+\n+\n+    void visitIMPDEP1( IMPDEP1 obj );\n+\n+\n+    void visitMONITORENTER( MONITORENTER obj );\n+\n+\n+    void visitLSHL( LSHL obj );\n+\n+\n+    void visitDCMPG( DCMPG obj );\n+\n+\n+    void visitD2L( D2L obj );\n+\n+\n+    void visitIMPDEP2( IMPDEP2 obj );\n+\n+\n+    void visitL2D( L2D obj );\n+\n+\n+    void visitRET( RET obj );\n+\n+\n+    void visitIFGT( IFGT obj );\n+\n+\n+    void visitIXOR( IXOR obj );\n+\n+\n+    void visitINVOKEVIRTUAL( INVOKEVIRTUAL obj );\n+\n@@ -247,1 +456,11 @@\n-    void visitINVOKEDYNAMIC(INVOKEDYNAMIC obj);\n+    void visitINVOKEDYNAMIC( INVOKEDYNAMIC obj );\n+\n+\n+    void visitFASTORE( FASTORE obj );\n+\n+\n+    void visitIRETURN( IRETURN obj );\n+\n+\n+    void visitIF_ICMPNE( IF_ICMPNE obj );\n+\n@@ -249,1 +468,1 @@\n-    void visitInvokeInstruction(InvokeInstruction obj);\n+    void visitFLOAD( FLOAD obj );\n@@ -251,1 +470,0 @@\n-    void visitINVOKEINTERFACE(INVOKEINTERFACE obj);\n@@ -253,1 +471,1 @@\n-    void visitINVOKESPECIAL(INVOKESPECIAL obj);\n+    void visitLDIV( LDIV obj );\n@@ -255,1 +473,0 @@\n-    void visitINVOKESTATIC(INVOKESTATIC obj);\n@@ -257,1 +474,1 @@\n-    void visitINVOKEVIRTUAL(INVOKEVIRTUAL obj);\n+    void visitPUTSTATIC( PUTSTATIC obj );\n@@ -259,1 +476,0 @@\n-    void visitIOR(IOR obj);\n@@ -261,1 +477,1 @@\n-    void visitIREM(IREM obj);\n+    void visitAALOAD( AALOAD obj );\n@@ -263,1 +479,0 @@\n-    void visitIRETURN(IRETURN obj);\n@@ -265,1 +480,1 @@\n-    void visitISHL(ISHL obj);\n+    void visitD2I( D2I obj );\n@@ -267,1 +482,0 @@\n-    void visitISHR(ISHR obj);\n@@ -269,1 +483,1 @@\n-    void visitISTORE(ISTORE obj);\n+    void visitIF_ICMPEQ( IF_ICMPEQ obj );\n@@ -271,1 +485,0 @@\n-    void visitISUB(ISUB obj);\n@@ -273,1 +486,1 @@\n-    void visitIUSHR(IUSHR obj);\n+    void visitAASTORE( AASTORE obj );\n@@ -275,1 +488,0 @@\n-    void visitIXOR(IXOR obj);\n@@ -277,1 +489,1 @@\n-    void visitJSR(JSR obj);\n+    void visitARETURN( ARETURN obj );\n@@ -279,1 +491,0 @@\n-    void visitJSR_W(JSR_W obj);\n@@ -281,1 +492,1 @@\n-    void visitJsrInstruction(JsrInstruction obj);\n+    void visitDUP2_X1( DUP2_X1 obj );\n@@ -283,1 +494,0 @@\n-    void visitL2D(L2D obj);\n@@ -285,1 +495,1 @@\n-    void visitL2F(L2F obj);\n+    void visitFNEG( FNEG obj );\n@@ -287,1 +497,0 @@\n-    void visitL2I(L2I obj);\n@@ -289,1 +498,1 @@\n-    void visitLADD(LADD obj);\n+    void visitGOTO_W( GOTO_W obj );\n@@ -291,1 +500,0 @@\n-    void visitLALOAD(LALOAD obj);\n@@ -293,1 +501,1 @@\n-    void visitLAND(LAND obj);\n+    void visitD2F( D2F obj );\n@@ -295,1 +503,0 @@\n-    void visitLASTORE(LASTORE obj);\n@@ -297,1 +504,1 @@\n-    void visitLCMP(LCMP obj);\n+    void visitGOTO( GOTO obj );\n@@ -299,1 +506,0 @@\n-    void visitLCONST(LCONST obj);\n@@ -301,1 +507,1 @@\n-    void visitLDC(LDC obj);\n+    void visitISUB( ISUB obj );\n@@ -303,1 +509,0 @@\n-    void visitLDC2_W(LDC2_W obj);\n@@ -305,1 +510,1 @@\n-    void visitLDIV(LDIV obj);\n+    void visitF2I( F2I obj );\n@@ -307,1 +512,0 @@\n-    void visitLLOAD(LLOAD obj);\n@@ -309,1 +513,1 @@\n-    void visitLMUL(LMUL obj);\n+    void visitDNEG( DNEG obj );\n@@ -311,1 +515,0 @@\n-    void visitLNEG(LNEG obj);\n@@ -313,1 +516,1 @@\n-    void visitLoadClass(LoadClass obj);\n+    void visitICONST( ICONST obj );\n@@ -315,1 +518,0 @@\n-    void visitLoadInstruction(LoadInstruction obj);\n@@ -317,1 +519,1 @@\n-    void visitLocalVariableInstruction(LocalVariableInstruction obj);\n+    void visitFDIV( FDIV obj );\n@@ -319,1 +521,0 @@\n-    void visitLOOKUPSWITCH(LOOKUPSWITCH obj);\n@@ -321,1 +522,1 @@\n-    void visitLOR(LOR obj);\n+    void visitI2B( I2B obj );\n@@ -323,1 +524,0 @@\n-    void visitLREM(LREM obj);\n@@ -325,1 +525,1 @@\n-    void visitLRETURN(LRETURN obj);\n+    void visitLNEG( LNEG obj );\n@@ -327,1 +527,0 @@\n-    void visitLSHL(LSHL obj);\n@@ -329,1 +528,1 @@\n-    void visitLSHR(LSHR obj);\n+    void visitLREM( LREM obj );\n@@ -331,1 +530,0 @@\n-    void visitLSTORE(LSTORE obj);\n@@ -333,1 +531,1 @@\n-    void visitLSUB(LSUB obj);\n+    void visitIMUL( IMUL obj );\n@@ -335,1 +533,0 @@\n-    void visitLUSHR(LUSHR obj);\n@@ -337,1 +534,1 @@\n-    void visitLXOR(LXOR obj);\n+    void visitIADD( IADD obj );\n@@ -339,1 +536,0 @@\n-    void visitMONITORENTER(MONITORENTER obj);\n@@ -341,1 +537,1 @@\n-    void visitMONITOREXIT(MONITOREXIT obj);\n+    void visitLSHR( LSHR obj );\n@@ -343,1 +539,0 @@\n-    void visitMULTIANEWARRAY(MULTIANEWARRAY obj);\n@@ -345,1 +540,1 @@\n-    void visitNEW(NEW obj);\n+    void visitLOOKUPSWITCH( LOOKUPSWITCH obj );\n@@ -347,1 +542,0 @@\n-    void visitNEWARRAY(NEWARRAY obj);\n@@ -349,1 +543,1 @@\n-    void visitNOP(NOP obj);\n+    void visitDUP_X1( DUP_X1 obj );\n@@ -351,1 +545,0 @@\n-    void visitPOP(POP obj);\n@@ -353,1 +546,1 @@\n-    void visitPOP2(POP2 obj);\n+    void visitFCMPL( FCMPL obj );\n@@ -355,1 +548,0 @@\n-    void visitPopInstruction(PopInstruction obj);\n@@ -357,1 +549,1 @@\n-    void visitPushInstruction(PushInstruction obj);\n+    void visitI2C( I2C obj );\n@@ -359,1 +551,0 @@\n-    void visitPUTFIELD(PUTFIELD obj);\n@@ -361,1 +552,1 @@\n-    void visitPUTSTATIC(PUTSTATIC obj);\n+    void visitLMUL( LMUL obj );\n@@ -363,1 +554,0 @@\n-    void visitRET(RET obj);\n@@ -365,1 +555,1 @@\n-    void visitRETURN(RETURN obj);\n+    void visitLUSHR( LUSHR obj );\n@@ -367,1 +557,0 @@\n-    void visitReturnInstruction(ReturnInstruction obj);\n@@ -369,1 +558,1 @@\n-    void visitSALOAD(SALOAD obj);\n+    void visitISHL( ISHL obj );\n@@ -371,1 +560,0 @@\n-    void visitSASTORE(SASTORE obj);\n@@ -373,1 +561,1 @@\n-    void visitSelect(Select obj);\n+    void visitLALOAD( LALOAD obj );\n@@ -375,1 +563,0 @@\n-    void visitSIPUSH(SIPUSH obj);\n@@ -377,1 +564,1 @@\n-    void visitStackConsumer(StackConsumer obj);\n+    void visitASTORE( ASTORE obj );\n@@ -379,1 +566,0 @@\n-    void visitStackInstruction(StackInstruction obj);\n@@ -381,1 +567,1 @@\n-    void visitStackProducer(StackProducer obj);\n+    void visitANEWARRAY( ANEWARRAY obj );\n@@ -383,1 +569,0 @@\n-    void visitStoreInstruction(StoreInstruction obj);\n@@ -385,1 +570,1 @@\n-    void visitSWAP(SWAP obj);\n+    void visitFRETURN( FRETURN obj );\n@@ -387,1 +572,0 @@\n-    void visitTABLESWITCH(TABLESWITCH obj);\n@@ -389,1 +573,1 @@\n-    void visitTypedInstruction(TypedInstruction obj);\n+    void visitFADD( FADD obj );\n@@ -391,1 +575,0 @@\n-    void visitUnconditionalBranch(UnconditionalBranch obj);\n@@ -393,1 +576,1 @@\n-    void visitVariableLengthInstruction(VariableLengthInstruction obj);\n+    void visitBREAKPOINT( BREAKPOINT obj );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Visitor.java","additions":366,"deletions":183,"binary":false,"changes":549,"status":"modified"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- *\/\n-\n-package com.sun.org.apache.bcel.internal.util;\n-\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;\n-\n-\/**\n- * Argument validation.\n- *\n- * @since 6.7.0\n- *\/\n-public class Args {\n-\n-    \/**\n-     * Requires a specific value.\n-     *\n-     * @param value    The value to test.\n-     * @param required The required value.\n-     * @param message  The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int require(final int value, final int required, final String message) {\n-        if (value != required) {\n-            throw new ClassFormatException(String.format(\"%s [Value must be 0: %,d]\", message, value));\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Requires a 0 value.\n-     *\n-     * @param value   The value to test.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int require0(final int value, final String message) {\n-        return require(value, 0, message);\n-    }\n-\n-    \/**\n-     * Requires a u1 value.\n-     *\n-     * @param value   The value to test.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU1(final int value, final String message) {\n-        if (value < 0 || value > Const.MAX_BYTE) {\n-            throw new ClassFormatException(String.format(\"%s [Value out of range (0 - %,d) for type u1: %,d]\", message, Const.MAX_BYTE, value));\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Requires a u2 value of at least {@code min} and not above {@code max}.\n-     *\n-     * @param value   The value to test.\n-     * @param min     The minimum required u2 value.\n-     * @param max     The maximum required u2 value.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU2(final int value, final int min, final int max, final String message) {\n-        if (max > Const.MAX_SHORT) {\n-            throw new IllegalArgumentException(String.format(\"%s programming error: max %,d > %,d\", message, max, Const.MAX_SHORT));\n-        }\n-        if (min < 0) {\n-            throw new IllegalArgumentException(String.format(\"%s programming error: min %,d < 0\", message, min));\n-        }\n-        if (value < min || value > max) {\n-            throw new ClassFormatException(String.format(\"%s [Value out of range (%,d - %,d) for type u2: %,d]\", message, min, Const.MAX_SHORT, value));\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Requires a u2 value of at least {@code min}.\n-     *\n-     * @param value   The value to test.\n-     * @param min     The minimum required value.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU2(final int value, final int min, final String message) {\n-        return requireU2(value, min, Const.MAX_SHORT, message);\n-    }\n-\n-    \/**\n-     * Requires a u2 value.\n-     *\n-     * @param value   The value to test.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU2(final int value, final String message) {\n-        return requireU2(value, 0, message);\n-    }\n-\n-    \/**\n-     * Requires a u4 value of at least {@code min}.\n-     *\n-     * @param value   The value to test.\n-     * @param min     The minimum required value.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU4(final int value, final int min, final String message) {\n-        if (min < 0) {\n-            throw new IllegalArgumentException(String.format(\"%s programming error: min %,d < 0\", message, min));\n-        }\n-        if (value < min) {\n-            throw new ClassFormatException(\n-                    String.format(\"%s [Value out of range (%,d - %,d) for type u2: %,d]\", message, min, Integer.MAX_VALUE, value & 0xFFFFFFFFL));\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Requires a u4 value.\n-     *\n-     * @param value   The value to test.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU4(final int value, final String message) {\n-        return requireU4(value, 0, message);\n-    }\n-}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Args.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -24,2 +24,2 @@\n-import java.io.Closeable;\n-import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n@@ -27,2 +27,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.Charset;\n@@ -35,0 +33,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;\n@@ -41,0 +40,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.LocalVariable;\n@@ -47,0 +47,2 @@\n+ *\n+ *\n@@ -48,1 +50,1 @@\n-final class AttributeHTML implements Closeable {\n+final class AttributeHTML {\n@@ -50,5 +52,5 @@\n-    private final String className; \/\/ name of current class\n-    private final PrintWriter printWriter; \/\/ file to write to\n-    private int attrCount;\n-    private final ConstantHTML constantHtml;\n-    private final ConstantPool constantPool;\n+    private final String class_name; \/\/ name of current class\n+    private final PrintWriter file; \/\/ file to write to\n+    private int attr_count = 0;\n+    private final ConstantHTML constant_html;\n+    private final ConstantPool constant_pool;\n@@ -56,10 +58,8 @@\n-    AttributeHTML(final String dir, final String className, final ConstantPool constantPool, final ConstantHTML constantHtml, final Charset charset)\n-        throws FileNotFoundException, UnsupportedEncodingException {\n-        this.className = className;\n-        this.constantPool = constantPool;\n-        this.constantHtml = constantHtml;\n-        printWriter = new PrintWriter(dir + className + \"_attributes.html\", charset.name());\n-        printWriter.print(\"<HTML><head><meta charset=\\\"\");\n-        printWriter.print(charset.name());\n-        printWriter.println(\"\\\"><\/head>\");\n-        printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+\n+    AttributeHTML(final String dir, final String class_name, final ConstantPool constant_pool,\n+            final ConstantHTML constant_html) throws IOException {\n+        this.class_name = class_name;\n+        this.constant_pool = constant_pool;\n+        this.constant_html = constant_html;\n+        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_attributes.html\"));\n+        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n@@ -68,4 +68,4 @@\n-    @Override\n-    public void close() {\n-        printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n-        printWriter.close();\n+\n+    private String codeLink( final int link, final int method_number ) {\n+        return \"<A HREF=\\\"\" + class_name + \"_code.html#code\" + method_number + \"@\" + link\n+                + \"\\\" TARGET=Code>\" + link + \"<\/A>\";\n@@ -74,2 +74,4 @@\n-    private String codeLink(final int link, final int methodNumber) {\n-        return \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + link + \"\\\" TARGET=Code>\" + link + \"<\/A>\";\n+\n+    void close() {\n+        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+        file.close();\n@@ -78,1 +80,2 @@\n-    void writeAttribute(final Attribute attribute, final String anchor) {\n+\n+    void writeAttribute( final Attribute attribute, final String anchor ) {\n@@ -82,1 +85,2 @@\n-    void writeAttribute(final Attribute attribute, final String anchor, final int methodNumber) {\n+\n+    void writeAttribute( final Attribute attribute, final String anchor, final int method_number ) {\n@@ -88,3 +92,3 @@\n-        attrCount++; \/\/ Increment number of attributes found so far\n-        if (attrCount % 2 == 0) {\n-            printWriter.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n+        attr_count++; \/\/ Increment number of attributes found so far\n+        if (attr_count % 2 == 0) {\n+            file.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n@@ -92,1 +96,1 @@\n-            printWriter.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n+            file.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n@@ -94,3 +98,3 @@\n-        printWriter.println(\"<H4><A NAME=\\\"\" + anchor + \"\\\">\" + attrCount + \" \" + Const.getAttributeName(tag) + \"<\/A><\/H4>\");\n-        \/*\n-         * Handle different attributes\n+        file.println(\"<H4><A NAME=\\\"\" + anchor + \"\\\">\" + attr_count + \" \" + Const.getAttributeName(tag)\n+                + \"<\/A><\/H4>\");\n+        \/* Handle different attributes\n@@ -99,17 +103,61 @@\n-        case Const.ATTR_CODE:\n-            final Code c = (Code) attribute;\n-            \/\/ Some directly printable values\n-            printWriter.print(\"<UL><LI>Maximum stack size = \" + c.getMaxStack() + \"<\/LI>\\n<LI>Number of local variables = \" + c.getMaxLocals()\n-                + \"<\/LI>\\n<LI><A HREF=\\\"\" + className + \"_code.html#method\" + methodNumber + \"\\\" TARGET=Code>Byte code<\/A><\/LI><\/UL>\\n\");\n-            \/\/ Get handled exceptions and list them\n-            final CodeException[] ce = c.getExceptionTable();\n-            final int len = ce.length;\n-            if (len > 0) {\n-                printWriter.print(\"<P><B>Exceptions handled<\/B><UL>\");\n-                for (final CodeException cex : ce) {\n-                    final int catchType = cex.getCatchType(); \/\/ Index in constant pool\n-                    printWriter.print(\"<LI>\");\n-                    if (catchType != 0) {\n-                        printWriter.print(constantHtml.referenceConstant(catchType)); \/\/ Create Link to _cp.html\n-                    } else {\n-                        printWriter.print(\"Any Exception\");\n+            case Const.ATTR_CODE:\n+                final Code c = (Code) attribute;\n+                \/\/ Some directly printable values\n+                file.print(\"<UL><LI>Maximum stack size = \" + c.getMaxStack()\n+                        + \"<\/LI>\\n<LI>Number of local variables = \" + c.getMaxLocals()\n+                        + \"<\/LI>\\n<LI><A HREF=\\\"\" + class_name + \"_code.html#method\"\n+                        + method_number + \"\\\" TARGET=Code>Byte code<\/A><\/LI><\/UL>\\n\");\n+                \/\/ Get handled exceptions and list them\n+                final CodeException[] ce = c.getExceptionTable();\n+                final int len = ce.length;\n+                if (len > 0) {\n+                    file.print(\"<P><B>Exceptions handled<\/B><UL>\");\n+                    for (final CodeException cex : ce) {\n+                        final int catch_type = cex.getCatchType(); \/\/ Index in constant pool\n+                        file.print(\"<LI>\");\n+                        if (catch_type != 0) {\n+                            file.print(constant_html.referenceConstant(catch_type)); \/\/ Create Link to _cp.html\n+                        } else {\n+                            file.print(\"Any Exception\");\n+                        }\n+                        file.print(\"<BR>(Ranging from lines \"\n+                                + codeLink(cex.getStartPC(), method_number) + \" to \"\n+                                + codeLink(cex.getEndPC(), method_number) + \", handled at line \"\n+                                + codeLink(cex.getHandlerPC(), method_number) + \")<\/LI>\");\n+                    }\n+                    file.print(\"<\/UL>\");\n+                }\n+                break;\n+            case Const.ATTR_CONSTANT_VALUE:\n+                index = ((ConstantValue) attribute).getConstantValueIndex();\n+                \/\/ Reference _cp.html\n+                file.print(\"<UL><LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index\n+                        + \"\\\" TARGET=\\\"ConstantPool\\\">Constant value index(\" + index\n+                        + \")<\/A><\/UL>\\n\");\n+                break;\n+            case Const.ATTR_SOURCE_FILE:\n+                index = ((SourceFile) attribute).getSourceFileIndex();\n+                \/\/ Reference _cp.html\n+                file.print(\"<UL><LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index\n+                        + \"\\\" TARGET=\\\"ConstantPool\\\">Source file index(\" + index + \")<\/A><\/UL>\\n\");\n+                break;\n+            case Const.ATTR_EXCEPTIONS:\n+                \/\/ List thrown exceptions\n+                final int[] indices = ((ExceptionTable) attribute).getExceptionIndexTable();\n+                file.print(\"<UL>\");\n+                for (final int indice : indices) {\n+                    file.print(\"<LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + indice\n+                            + \"\\\" TARGET=\\\"ConstantPool\\\">Exception class index(\" + indice\n+                            + \")<\/A>\\n\");\n+                }\n+                file.print(\"<\/UL>\\n\");\n+                break;\n+            case Const.ATTR_LINE_NUMBER_TABLE:\n+                final LineNumber[] line_numbers = ((LineNumberTable) attribute).getLineNumberTable();\n+                \/\/ List line number pairs\n+                file.print(\"<P>\");\n+                for (int i = 0; i < line_numbers.length; i++) {\n+                    file.print(\"(\" + line_numbers[i].getStartPC() + \",&nbsp;\"\n+                            + line_numbers[i].getLineNumber() + \")\");\n+                    if (i < line_numbers.length - 1) {\n+                        file.print(\", \"); \/\/ breakable\n@@ -117,2 +165,0 @@\n-                    printWriter.print(\"<BR>(Ranging from lines \" + codeLink(cex.getStartPC(), methodNumber) + \" to \" + codeLink(cex.getEndPC(), methodNumber)\n-                        + \", handled at line \" + codeLink(cex.getHandlerPC(), methodNumber) + \")<\/LI>\");\n@@ -120,33 +166,18 @@\n-                printWriter.print(\"<\/UL>\");\n-            }\n-            break;\n-        case Const.ATTR_CONSTANT_VALUE:\n-            index = ((ConstantValue) attribute).getConstantValueIndex();\n-            \/\/ Reference _cp.html\n-            printWriter\n-                .print(\"<UL><LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=\\\"ConstantPool\\\">Constant value index(\" + index + \")<\/A><\/UL>\\n\");\n-            break;\n-        case Const.ATTR_SOURCE_FILE:\n-            index = ((SourceFile) attribute).getSourceFileIndex();\n-            \/\/ Reference _cp.html\n-            printWriter\n-                .print(\"<UL><LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=\\\"ConstantPool\\\">Source file index(\" + index + \")<\/A><\/UL>\\n\");\n-            break;\n-        case Const.ATTR_EXCEPTIONS:\n-            \/\/ List thrown exceptions\n-            final int[] indices = ((ExceptionTable) attribute).getExceptionIndexTable();\n-            printWriter.print(\"<UL>\");\n-            for (final int indice : indices) {\n-                printWriter\n-                    .print(\"<LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + indice + \"\\\" TARGET=\\\"ConstantPool\\\">Exception class index(\" + indice + \")<\/A>\\n\");\n-            }\n-            printWriter.print(\"<\/UL>\\n\");\n-            break;\n-        case Const.ATTR_LINE_NUMBER_TABLE:\n-            final LineNumber[] lineNumbers = ((LineNumberTable) attribute).getLineNumberTable();\n-            \/\/ List line number pairs\n-            printWriter.print(\"<P>\");\n-            for (int i = 0; i < lineNumbers.length; i++) {\n-                printWriter.print(\"(\" + lineNumbers[i].getStartPC() + \",&nbsp;\" + lineNumbers[i].getLineNumber() + \")\");\n-                if (i < lineNumbers.length - 1) {\n-                    printWriter.print(\", \"); \/\/ breakable\n+                break;\n+            case Const.ATTR_LOCAL_VARIABLE_TABLE:\n+                final LocalVariable[] vars = ((LocalVariableTable) attribute).getLocalVariableTable();\n+                \/\/ List name, range and type\n+                file.print(\"<UL>\");\n+                for (final LocalVariable var : vars) {\n+                    index = var.getSignatureIndex();\n+                    String signature = ((ConstantUtf8) constant_pool.getConstant(index,\n+                            Const.CONSTANT_Utf8)).getBytes();\n+                    signature = Utility.signatureToString(signature, false);\n+                    final int start = var.getStartPC();\n+                    final int end = start + var.getLength();\n+                    file.println(\"<LI>\" + Class2HTML.referenceType(signature) + \"&nbsp;<B>\"\n+                            + var.getName() + \"<\/B> in slot %\" + var.getIndex()\n+                            + \"<BR>Valid from lines \" + \"<A HREF=\\\"\" + class_name\n+                            + \"_code.html#code\" + method_number + \"@\" + start + \"\\\" TARGET=Code>\"\n+                            + start + \"<\/A> to \" + \"<A HREF=\\\"\" + class_name + \"_code.html#code\"\n+                            + method_number + \"@\" + end + \"\\\" TARGET=Code>\" + end + \"<\/A><\/LI>\");\n@@ -154,28 +185,22 @@\n-            }\n-            break;\n-        case Const.ATTR_LOCAL_VARIABLE_TABLE:\n-            \/\/ List name, range and type\n-            printWriter.print(\"<UL>\");\n-            ((LocalVariableTable) attribute).forEach(var -> {\n-                final int sigIdx = var.getSignatureIndex();\n-                String signature = constantPool.getConstantUtf8(sigIdx).getBytes();\n-                signature = Utility.signatureToString(signature, false);\n-                final int start = var.getStartPC();\n-                final int end = start + var.getLength();\n-                printWriter.println(\"<LI>\" + Class2HTML.referenceType(signature) + \"&nbsp;<B>\" + var.getName() + \"<\/B> in slot %\" + var.getIndex()\n-                    + \"<BR>Valid from lines \" + \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + start + \"\\\" TARGET=Code>\" + start\n-                    + \"<\/A> to \" + \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + end + \"\\\" TARGET=Code>\" + end + \"<\/A><\/LI>\");\n-            });\n-            printWriter.print(\"<\/UL>\\n\");\n-            break;\n-        case Const.ATTR_INNER_CLASSES:\n-            \/\/ List inner classes\n-            printWriter.print(\"<UL>\");\n-            for (final InnerClass clazz : ((InnerClasses) attribute).getInnerClasses()) {\n-                final String name;\n-                final String access;\n-                index = clazz.getInnerNameIndex();\n-                if (index > 0) {\n-                    name = constantPool.getConstantUtf8(index).getBytes();\n-                } else {\n-                    name = \"&lt;anonymous&gt;\";\n+                file.print(\"<\/UL>\\n\");\n+                break;\n+            case Const.ATTR_INNER_CLASSES:\n+                final InnerClass[] classes = ((InnerClasses) attribute).getInnerClasses();\n+                \/\/ List inner classes\n+                file.print(\"<UL>\");\n+                for (final InnerClass classe : classes) {\n+                    String name;\n+                    String access;\n+                    index = classe.getInnerNameIndex();\n+                    if (index > 0) {\n+                        name = ((ConstantUtf8) constant_pool.getConstant(index, Const.CONSTANT_Utf8))\n+                                .getBytes();\n+                    } else {\n+                        name = \"&lt;anonymous&gt;\";\n+                    }\n+                    access = Utility.accessToString(classe.getInnerAccessFlags());\n+                    file.print(\"<LI><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT> \"\n+                            + constant_html.referenceConstant(classe.getInnerClassIndex())\n+                            + \" in&nbsp;class \"\n+                            + constant_html.referenceConstant(classe.getOuterClassIndex())\n+                            + \" named \" + name + \"<\/LI>\\n\");\n@@ -183,8 +208,4 @@\n-                access = Utility.accessToString(clazz.getInnerAccessFlags());\n-                printWriter.print(\"<LI><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT> \" + constantHtml.referenceConstant(clazz.getInnerClassIndex())\n-                    + \" in&nbsp;class \" + constantHtml.referenceConstant(clazz.getOuterClassIndex()) + \" named \" + name + \"<\/LI>\\n\");\n-            }\n-            printWriter.print(\"<\/UL>\\n\");\n-            break;\n-        default: \/\/ Such as Unknown attribute or Deprecated\n-            printWriter.print(\"<P>\" + attribute);\n+                file.print(\"<\/UL>\\n\");\n+                break;\n+            default: \/\/ Such as Unknown attribute or Deprecated\n+                file.print(\"<P>\" + attribute);\n@@ -192,2 +213,2 @@\n-        printWriter.println(\"<\/TD><\/TR>\");\n-        printWriter.flush();\n+        file.println(\"<\/TD><\/TR>\");\n+        file.flush();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/AttributeHTML.java","additions":146,"deletions":125,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-    boolean equals(Object THIS, Object THAT);\n+    boolean equals( Object THIS, Object THAT );\n+\n@@ -46,1 +47,1 @@\n-    int hashCode(Object THIS);\n+    int hashCode( Object THIS );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELComparator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,2 @@\n- * Factory creates il.append() statements, and sets instruction targets. A helper class for BCELifier.\n+ * Factory creates il.append() statements, and sets instruction targets.\n+ * A helper class for BCELifier.\n@@ -66,1 +67,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -70,4 +71,4 @@\n-    private static final String CONSTANT_PREFIX = Const.class.getSimpleName() + \".\";\n-    private final MethodGen methodGen;\n-    private final PrintWriter printWriter;\n-    private final ConstantPoolGen constantPoolGen;\n+    private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+\".\";\n+    private final MethodGen _mg;\n+    private final PrintWriter _out;\n+    private final ConstantPoolGen _cp;\n@@ -75,4 +76,0 @@\n-    private final Map<Instruction, InstructionHandle> branchMap = new HashMap<>();\n-\n-    \/\/ Memorize BranchInstructions that need an update\n-    private final List<BranchInstruction> branches = new ArrayList<>();\n@@ -81,3 +78,3 @@\n-        methodGen = mg;\n-        constantPoolGen = mg.getConstantPool();\n-        printWriter = out;\n+        _mg = mg;\n+        _cp = mg.getConstantPool();\n+        _out = out;\n@@ -86,37 +83,1 @@\n-    private void createConstant(final Object value) {\n-        String embed = value.toString();\n-        if (value instanceof String) {\n-            embed = '\"' + Utility.convertString(embed) + '\"';\n-        } else if (value instanceof Character) {\n-            embed = \"(char)0x\" + Integer.toHexString(((Character) value).charValue());\n-        } else if (value instanceof Float) {\n-            final Float f = (Float) value;\n-            if (Float.isNaN(f)) {\n-                embed = \"Float.NaN\";\n-            } else if (f == Float.POSITIVE_INFINITY) {\n-                embed = \"Float.POSITIVE_INFINITY\";\n-            } else if (f == Float.NEGATIVE_INFINITY) {\n-                embed = \"Float.NEGATIVE_INFINITY\";\n-            } else {\n-                embed += \"f\";\n-            }\n-        }  else if (value instanceof Double) {\n-            final Double d = (Double) value;\n-            if (Double.isNaN(d)) {\n-                embed = \"Double.NaN\";\n-            } else if (d == Double.POSITIVE_INFINITY) {\n-                embed = \"Double.POSITIVE_INFINITY\";\n-            } else if (d == Double.NEGATIVE_INFINITY) {\n-                embed = \"Double.NEGATIVE_INFINITY\";\n-            } else {\n-                embed += \"d\";\n-            }\n-        } else if (value instanceof Long) {\n-            embed += \"L\";\n-        } else if (value instanceof ObjectType) {\n-            final ObjectType ot = (ObjectType) value;\n-            embed = \"new ObjectType(\\\"\" + ot.getClassName() + \"\\\")\";\n-        } else if (value instanceof ArrayType) {\n-            final ArrayType at = (ArrayType) value;\n-            embed = \"new ArrayType(\" + BCELifier.printType(at.getBasicType()) + \", \" + at.getDimensions() + \")\";\n-        }\n+    private final Map<Instruction, InstructionHandle> branch_map = new HashMap<>();\n@@ -124,2 +85,0 @@\n-        printWriter.println(\"il.append(new PUSH(_cp, \" + embed + \"));\");\n-    }\n@@ -128,2 +87,3 @@\n-        if (!methodGen.isAbstract() && !methodGen.isNative()) {\n-            for (InstructionHandle ih = methodGen.getInstructionList().getStart(); ih != null; ih = ih.getNext()) {\n+        if (!_mg.isAbstract() && !_mg.isNative()) {\n+            for (InstructionHandle ih = _mg.getInstructionList().getStart(); ih != null; ih = ih\n+                    .getNext()) {\n@@ -132,1 +92,1 @@\n-                    branchMap.put(i, ih); \/\/ memorize container\n+                    branch_map.put(i, ih); \/\/ memorize container\n@@ -136,1 +96,1 @@\n-                        printWriter.println(\"    InstructionHandle ih_\" + ih.getPosition() + \";\");\n+                        _out.println(\"    InstructionHandle ih_\" + ih.getPosition() + \";\");\n@@ -138,1 +98,1 @@\n-                        printWriter.print(\"    InstructionHandle ih_\" + ih.getPosition() + \" = \");\n+                        _out.print(\"    InstructionHandle ih_\" + ih.getPosition() + \" = \");\n@@ -141,1 +101,1 @@\n-                    printWriter.print(\"    \");\n+                    _out.print(\"    \");\n@@ -152,15 +112,10 @@\n-    private void updateBranchTargets() {\n-        branches.forEach(bi -> {\n-            final BranchHandle bh = (BranchHandle) branchMap.get(bi);\n-            final int pos = bh.getPosition();\n-            final String name = bi.getName() + \"_\" + pos;\n-            int targetPos = bh.getTarget().getPosition();\n-            printWriter.println(\"    \" + name + \".setTarget(ih_\" + targetPos + \");\");\n-            if (bi instanceof Select) {\n-                final InstructionHandle[] ihs = ((Select) bi).getTargets();\n-                for (int j = 0; j < ihs.length; j++) {\n-                    targetPos = ihs[j].getPosition();\n-                    printWriter.println(\"    \" + name + \".setTarget(\" + j + \", ih_\" + targetPos + \");\");\n-                }\n-            }\n-        });\n+\n+    private boolean visitInstruction( final Instruction i ) {\n+        final short opcode = i.getOpcode();\n+        if ((InstructionConst.getInstruction(opcode) != null)\n+                && !(i instanceof ConstantPushInstruction) && !(i instanceof ReturnInstruction)) { \/\/ Handled below\n+            _out.println(\"il.append(InstructionConst.\"\n+                    + i.getName().toUpperCase(Locale.ENGLISH) + \");\");\n+            return true;\n+        }\n+        return false;\n@@ -169,6 +124,12 @@\n-    private void updateExceptionHandlers() {\n-        final CodeExceptionGen[] handlers = methodGen.getExceptionHandlers();\n-        for (final CodeExceptionGen h : handlers) {\n-            final String type = h.getCatchType() == null ? \"null\" : BCELifier.printType(h.getCatchType());\n-            printWriter.println(\"    method.addExceptionHandler(\" + \"ih_\" + h.getStartPC().getPosition() + \", \" + \"ih_\" + h.getEndPC().getPosition() + \", \"\n-                + \"ih_\" + h.getHandlerPC().getPosition() + \", \" + type + \");\");\n+\n+    @Override\n+    public void visitLocalVariableInstruction( final LocalVariableInstruction i ) {\n+        final short opcode = i.getOpcode();\n+        final Type type = i.getType(_cp);\n+        if (opcode == Const.IINC) {\n+            _out.println(\"il.append(new IINC(\" + i.getIndex() + \", \" + ((IINC) i).getIncrement()\n+                    + \"));\");\n+        } else {\n+            final String kind = (opcode < Const.ISTORE) ? \"Load\" : \"Store\";\n+            _out.println(\"il.append(_factory.create\" + kind + \"(\" + BCELifier.printType(type)\n+                    + \", \" + i.getIndex() + \"));\");\n@@ -178,0 +139,37 @@\n+\n+    @Override\n+    public void visitArrayInstruction( final ArrayInstruction i ) {\n+        final short opcode = i.getOpcode();\n+        final Type type = i.getType(_cp);\n+        final String kind = (opcode < Const.IASTORE) ? \"Load\" : \"Store\";\n+        _out.println(\"il.append(_factory.createArray\" + kind + \"(\" + BCELifier.printType(type)\n+                + \"));\");\n+    }\n+\n+\n+    @Override\n+    public void visitFieldInstruction( final FieldInstruction i ) {\n+        final short opcode = i.getOpcode();\n+        final String class_name = i.getReferenceType(_cp).getSignature();\n+        final String field_name = i.getFieldName(_cp);\n+        final Type type = i.getFieldType(_cp);\n+        _out.println(\"il.append(_factory.createFieldAccess(\\\"\" + class_name + \"\\\", \\\"\" + field_name\n+                + \"\\\", \" + BCELifier.printType(type) + \", \" + CONSTANT_PREFIX\n+                + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n+    }\n+\n+\n+    @Override\n+    public void visitInvokeInstruction( final InvokeInstruction i ) {\n+        final short opcode = i.getOpcode();\n+        final String class_name = i.getReferenceType(_cp).getSignature();\n+        final String method_name = i.getMethodName(_cp);\n+        final Type type = i.getReturnType(_cp);\n+        final Type[] arg_types = i.getArgumentTypes(_cp);\n+        _out.println(\"il.append(_factory.createInvoke(\\\"\" + class_name + \"\\\", \\\"\" + method_name\n+                + \"\\\", \" + BCELifier.printType(type) + \", \"\n+                + BCELifier.printArgumentTypes(arg_types) + \", \" + CONSTANT_PREFIX\n+                + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n+    }\n+\n+\n@@ -180,1 +178,1 @@\n-    public void visitAllocationInstruction(final AllocationInstruction i) {\n+    public void visitAllocationInstruction( final AllocationInstruction i ) {\n@@ -183,1 +181,1 @@\n-            type = ((CPInstruction) i).getType(constantPoolGen);\n+            type = ((CPInstruction) i).getType(_cp);\n@@ -190,16 +188,34 @@\n-        case Const.NEW:\n-            printWriter.println(\"il.append(_factory.createNew(\\\"\" + ((ObjectType) type).getClassName() + \"\\\"));\");\n-            break;\n-        case Const.MULTIANEWARRAY:\n-            dim = ((MULTIANEWARRAY) i).getDimensions();\n-            \/\/$FALL-THROUGH$\n-        case Const.NEWARRAY:\n-            if (type instanceof ArrayType) {\n-                type = ((ArrayType) type).getBasicType();\n-            }\n-            \/\/$FALL-THROUGH$\n-        case Const.ANEWARRAY:\n-            printWriter.println(\"il.append(_factory.createNewArray(\" + BCELifier.printType(type) + \", (short) \" + dim + \"));\");\n-            break;\n-        default:\n-            throw new IllegalArgumentException(\"Unhandled opcode: \" + opcode);\n+            case Const.NEW:\n+                _out.println(\"il.append(_factory.createNew(\\\"\" + ((ObjectType) type).getClassName()\n+                        + \"\\\"));\");\n+                break;\n+            case Const.MULTIANEWARRAY:\n+                dim = ((MULTIANEWARRAY) i).getDimensions();\n+                \/\/$FALL-THROUGH$\n+            case Const.ANEWARRAY:\n+            case Const.NEWARRAY:\n+                if (type instanceof ArrayType) {\n+                    type = ((ArrayType) type).getBasicType();\n+                }\n+                _out.println(\"il.append(_factory.createNewArray(\" + BCELifier.printType(type)\n+                        + \", (short) \" + dim + \"));\");\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled opcode: \" + opcode);\n+        }\n+    }\n+\n+\n+    private void createConstant( final Object value ) {\n+        String embed = value.toString();\n+        if (value instanceof String) {\n+            embed = '\"' + Utility.convertString(embed) + '\"';\n+        } else if (value instanceof Character) {\n+            embed = \"(char)0x\" + Integer.toHexString(((Character) value).charValue());\n+        } else if (value instanceof Float) {\n+            embed += \"f\";\n+        } else if (value instanceof Long) {\n+            embed += \"L\";\n+        } else if (value instanceof ObjectType) {\n+            final ObjectType ot = (ObjectType) value;\n+            embed = \"new ObjectType(\\\"\"+ot.getClassName()+\"\\\")\";\n@@ -207,0 +223,2 @@\n+\n+        _out.println(\"il.append(new PUSH(_cp, \" + embed + \"));\");\n@@ -209,0 +227,1 @@\n+\n@@ -210,5 +229,14 @@\n-    public void visitArrayInstruction(final ArrayInstruction i) {\n-        final short opcode = i.getOpcode();\n-        final Type type = i.getType(constantPoolGen);\n-        final String kind = opcode < Const.IASTORE ? \"Load\" : \"Store\";\n-        printWriter.println(\"il.append(_factory.createArray\" + kind + \"(\" + BCELifier.printType(type) + \"));\");\n+    public void visitLDC( final LDC i ) {\n+        createConstant(i.getValue(_cp));\n+    }\n+\n+\n+    @Override\n+    public void visitLDC2_W( final LDC2_W i ) {\n+        createConstant(i.getValue(_cp));\n+    }\n+\n+\n+    @Override\n+    public void visitConstantPushInstruction( final ConstantPushInstruction i ) {\n+        createConstant(i.getValue());\n@@ -217,0 +245,8 @@\n+\n+    @Override\n+    public void visitINSTANCEOF( final INSTANCEOF i ) {\n+        final Type type = i.getType(_cp);\n+        _out.println(\"il.append(new INSTANCEOF(_cp.addClass(\" + BCELifier.printType(type) + \")));\");\n+    }\n+\n+\n@@ -218,2 +254,19 @@\n-    public void visitBranchInstruction(final BranchInstruction bi) {\n-        final BranchHandle bh = (BranchHandle) branchMap.get(bi);\n+    public void visitCHECKCAST( final CHECKCAST i ) {\n+        final Type type = i.getType(_cp);\n+        _out.println(\"il.append(_factory.createCheckCast(\" + BCELifier.printType(type) + \"));\");\n+    }\n+\n+\n+    @Override\n+    public void visitReturnInstruction( final ReturnInstruction i ) {\n+        final Type type = i.getType(_cp);\n+        _out.println(\"il.append(_factory.createReturn(\" + BCELifier.printType(type) + \"));\");\n+    }\n+\n+    \/\/ Memorize BranchInstructions that need an update\n+    private final List<BranchInstruction> branches = new ArrayList<>();\n+\n+\n+    @Override\n+    public void visitBranchInstruction( final BranchInstruction bi ) {\n+        final BranchHandle bh = (BranchHandle) branch_map.get(bi);\n@@ -234,1 +287,2 @@\n-            printWriter.print(\"Select \" + name + \" = new \" + bi.getName().toUpperCase(Locale.ENGLISH) + \"(\" + args + \", new InstructionHandle[] { \");\n+            _out.print(\"Select \" + name + \" = new \" + bi.getName().toUpperCase(Locale.ENGLISH)\n+                    + \"(\" + args + \", new InstructionHandle[] { \");\n@@ -236,1 +290,1 @@\n-                printWriter.print(\"null\");\n+                _out.print(\"null\");\n@@ -238,1 +292,1 @@\n-                    printWriter.print(\", \");\n+                    _out.print(\", \");\n@@ -241,1 +295,1 @@\n-            printWriter.println(\" }, null);\");\n+            _out.println(\" }, null);\");\n@@ -243,1 +297,1 @@\n-            final int tPos = bh.getTarget().getPosition();\n+            final int t_pos = bh.getTarget().getPosition();\n@@ -245,2 +299,2 @@\n-            if (pos > tPos) {\n-                target = \"ih_\" + tPos;\n+            if (pos > t_pos) {\n+                target = \"ih_\" + t_pos;\n@@ -251,2 +305,3 @@\n-            printWriter.println(\"    BranchInstruction \" + name + \" = _factory.createBranchInstruction(\" + CONSTANT_PREFIX\n-                + bi.getName().toUpperCase(Locale.ENGLISH) + \", \" + target + \");\");\n+            _out.println(\"    BranchInstruction \" + name + \" = _factory.createBranchInstruction(\"\n+                    + CONSTANT_PREFIX + bi.getName().toUpperCase(Locale.ENGLISH) + \", \" + target\n+                    + \");\");\n@@ -255,1 +310,1 @@\n-            printWriter.println(\"    ih_\" + pos + \" = il.append(\" + name + \");\");\n+            _out.println(\"    ih_\" + pos + \" = il.append(\" + name + \");\");\n@@ -257,1 +312,1 @@\n-            printWriter.println(\"    il.append(\" + name + \");\");\n+            _out.println(\"    il.append(\" + name + \");\");\n@@ -261,10 +316,0 @@\n-    @Override\n-    public void visitCHECKCAST(final CHECKCAST i) {\n-        final Type type = i.getType(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createCheckCast(\" + BCELifier.printType(type) + \"));\");\n-    }\n-\n-    @Override\n-    public void visitConstantPushInstruction(final ConstantPushInstruction i) {\n-        createConstant(i.getValue());\n-    }\n@@ -273,7 +318,2 @@\n-    public void visitFieldInstruction(final FieldInstruction i) {\n-        final short opcode = i.getOpcode();\n-        final String className = i.getReferenceType(constantPoolGen).getClassName();\n-        final String fieldName = i.getFieldName(constantPoolGen);\n-        final Type type = i.getFieldType(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createFieldAccess(\\\"\" + className + \"\\\", \\\"\" + fieldName + \"\\\", \" + BCELifier.printType(type) + \", \"\n-            + CONSTANT_PREFIX + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n+    public void visitRET( final RET i ) {\n+        _out.println(\"il.append(new RET(\" + i.getIndex() + \")));\");\n@@ -282,5 +322,0 @@\n-    @Override\n-    public void visitINSTANCEOF(final INSTANCEOF i) {\n-        final Type type = i.getType(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createInstanceOf(\" + BCELifier.printType(type) + \"));\");\n-    }\n@@ -288,5 +323,14 @@\n-    private boolean visitInstruction(final Instruction i) {\n-        final short opcode = i.getOpcode();\n-        if (InstructionConst.getInstruction(opcode) != null && !(i instanceof ConstantPushInstruction) && !(i instanceof ReturnInstruction)) { \/\/ Handled below\n-            printWriter.println(\"il.append(InstructionConst.\" + i.getName().toUpperCase(Locale.ENGLISH) + \");\");\n-            return true;\n+    private void updateBranchTargets() {\n+        for (final BranchInstruction bi : branches) {\n+            final BranchHandle bh = (BranchHandle) branch_map.get(bi);\n+            final int pos = bh.getPosition();\n+            final String name = bi.getName() + \"_\" + pos;\n+            int t_pos = bh.getTarget().getPosition();\n+            _out.println(\"    \" + name + \".setTarget(ih_\" + t_pos + \");\");\n+            if (bi instanceof Select) {\n+                final InstructionHandle[] ihs = ((Select) bi).getTargets();\n+                for (int j = 0; j < ihs.length; j++) {\n+                    t_pos = ihs[j].getPosition();\n+                    _out.println(\"    \" + name + \".setTarget(\" + j + \", ih_\" + t_pos + \");\");\n+                }\n+            }\n@@ -294,1 +338,0 @@\n-        return false;\n@@ -297,10 +340,0 @@\n-    @Override\n-    public void visitInvokeInstruction(final InvokeInstruction i) {\n-        final short opcode = i.getOpcode();\n-        final String className = i.getReferenceType(constantPoolGen).getClassName();\n-        final String methodName = i.getMethodName(constantPoolGen);\n-        final Type type = i.getReturnType(constantPoolGen);\n-        final Type[] argTypes = i.getArgumentTypes(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createInvoke(\\\"\" + className + \"\\\", \\\"\" + methodName + \"\\\", \" + BCELifier.printType(type) + \", \"\n-            + BCELifier.printArgumentTypes(argTypes) + \", \" + CONSTANT_PREFIX + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n-    }\n@@ -308,19 +341,8 @@\n-    @Override\n-    public void visitLDC(final LDC i) {\n-        createConstant(i.getValue(constantPoolGen));\n-    }\n-\n-    @Override\n-    public void visitLDC2_W(final LDC2_W i) {\n-        createConstant(i.getValue(constantPoolGen));\n-    }\n-\n-    @Override\n-    public void visitLocalVariableInstruction(final LocalVariableInstruction i) {\n-        final short opcode = i.getOpcode();\n-        final Type type = i.getType(constantPoolGen);\n-        if (opcode == Const.IINC) {\n-            printWriter.println(\"il.append(new IINC(\" + i.getIndex() + \", \" + ((IINC) i).getIncrement() + \"));\");\n-        } else {\n-            final String kind = opcode < Const.ISTORE ? \"Load\" : \"Store\";\n-            printWriter.println(\"il.append(_factory.create\" + kind + \"(\" + BCELifier.printType(type) + \", \" + i.getIndex() + \"));\");\n+    private void updateExceptionHandlers() {\n+        final CodeExceptionGen[] handlers = _mg.getExceptionHandlers();\n+        for (final CodeExceptionGen h : handlers) {\n+            final String type = (h.getCatchType() == null) ? \"null\" : BCELifier.printType(h\n+                    .getCatchType());\n+            _out.println(\"    method.addExceptionHandler(\" + \"ih_\" + h.getStartPC().getPosition()\n+                    + \", \" + \"ih_\" + h.getEndPC().getPosition() + \", \" + \"ih_\"\n+                    + h.getHandlerPC().getPosition() + \", \" + type + \");\");\n@@ -329,11 +351,0 @@\n-\n-    @Override\n-    public void visitRET(final RET i) {\n-        printWriter.println(\"il.append(new RET(\" + i.getIndex() + \"));\");\n-    }\n-\n-    @Override\n-    public void visitReturnInstruction(final ReturnInstruction i) {\n-        final Type type = i.getType(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createReturn(\" + BCELifier.printType(type) + \"));\");\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELFactory.java","additions":195,"deletions":184,"binary":false,"changes":379,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -25,1 +26,0 @@\n-import java.io.OutputStreamWriter;\n@@ -27,1 +27,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -34,1 +33,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.ExceptionTable;\n@@ -45,3 +43,5 @@\n- * This class takes a given JavaClass object and converts it to a Java program that creates that very class using BCEL.\n- * This gives new users of BCEL a useful example showing how things are done with BCEL. It does not cover all features\n- * of BCEL, but tries to mimic hand-written code as close as possible.\n+ * This class takes a given JavaClass object and converts it to a\n+ * Java program that creates that very class using BCEL. This\n+ * gives new users of BCEL a useful example showing how things\n+ * are done with BCEL. It does not cover all features of BCEL,\n+ * but tries to mimic hand-written code as close as possible.\n@@ -49,1 +49,0 @@\n- * @LastModified: Feb 2023\n@@ -57,1 +56,3 @@\n-        UNKNOWN, CLASS, METHOD,\n+        UNKNOWN,\n+        CLASS,\n+        METHOD,\n@@ -63,1 +64,1 @@\n-    private static final String CONSTANT_PREFIX = Const.class.getSimpleName() + \".\";\n+    private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+\".\";\n@@ -65,7 +66,11 @@\n-    \/\/ Needs to be accessible from unit test code\n-    static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {\n-        JavaClass javaClass;\n-        if ((javaClass = Repository.lookupClass(name)) == null) {\n-            javaClass = new ClassParser(name).parse(); \/\/ May throw IOException\n-        }\n-        return javaClass;\n+    private final JavaClass _clazz;\n+    private final PrintWriter _out;\n+    private final ConstantPoolGen _cp;\n+\n+    \/** @param clazz Java class to \"decompile\"\n+     * @param out where to output Java program\n+     *\/\n+    public BCELifier(final JavaClass clazz, final OutputStream out) {\n+        _clazz = clazz;\n+        _out = new PrintWriter(out);\n+        _cp = new ConstantPoolGen(_clazz.getConstantPool());\n@@ -74,2 +79,2 @@\n-    \/**\n-     * Default main method\n+\n+    \/** Start Java code generation\n@@ -77,8 +82,3 @@\n-    public static void _main(final String[] argv) throws Exception {\n-        if (argv.length != 1) {\n-            System.out.println(\"Usage: BCELifier className\");\n-            System.out.println(\"\\tThe class must exist on the classpath\");\n-            return;\n-        }\n-        final BCELifier bcelifier = new BCELifier(getJavaClass(argv[0]), System.out);\n-        bcelifier.start();\n+    public void start() {\n+        visitJavaClass(_clazz);\n+        _out.flush();\n@@ -87,3 +87,11 @@\n-    static String printArgumentTypes(final Type[] argTypes) {\n-        if (argTypes.length == 0) {\n-            return \"Type.NO_ARGS\";\n+\n+    @Override\n+    public void visitJavaClass( final JavaClass clazz ) {\n+        String class_name = clazz.getClassName();\n+        final String super_name = clazz.getSuperclassName();\n+        final String package_name = clazz.getPackageName();\n+        final String inter = Utility.printArray(clazz.getInterfaceNames(), false, true);\n+        if (!\"\".equals(package_name)) {\n+            class_name = class_name.substring(package_name.length() + 1);\n+            _out.println(\"package \" + package_name + \";\");\n+            _out.println();\n@@ -91,5 +99,30 @@\n-        final StringBuilder args = new StringBuilder();\n-        for (int i = 0; i < argTypes.length; i++) {\n-            args.append(printType(argTypes[i]));\n-            if (i < argTypes.length - 1) {\n-                args.append(\", \");\n+        _out.println(\"import \" + BASE_PACKAGE + \".generic.*;\");\n+        _out.println(\"import \" + BASE_PACKAGE + \".classfile.*;\");\n+        _out.println(\"import \" + BASE_PACKAGE + \".*;\");\n+        _out.println(\"import java.io.*;\");\n+        _out.println();\n+        _out.println(\"public class \" + class_name + \"Creator {\");\n+        _out.println(\"  private InstructionFactory _factory;\");\n+        _out.println(\"  private ConstantPoolGen    _cp;\");\n+        _out.println(\"  private ClassGen           _cg;\");\n+        _out.println();\n+        _out.println(\"  public \" + class_name + \"Creator() {\");\n+        _out.println(\"    _cg = new ClassGen(\\\"\"\n+                + ((\"\".equals(package_name)) ? class_name : package_name + \".\" + class_name)\n+                + \"\\\", \\\"\" + super_name + \"\\\", \" + \"\\\"\" + clazz.getSourceFileName() + \"\\\", \"\n+                + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + \", \"\n+                + \"new String[] { \" + inter + \" });\");\n+        _out.println(\"    _cg.setMajor(\" + clazz.getMajor() +\");\");\n+        _out.println(\"    _cg.setMinor(\" + clazz.getMinor() +\");\");\n+        _out.println();\n+        _out.println(\"    _cp = _cg.getConstantPool();\");\n+        _out.println(\"    _factory = new InstructionFactory(_cg, _cp);\");\n+        _out.println(\"  }\");\n+        _out.println();\n+        printCreate();\n+        final Field[] fields = clazz.getFields();\n+        if (fields.length > 0) {\n+            _out.println(\"  private void createFields() {\");\n+            _out.println(\"    FieldGen field;\");\n+            for (final Field field : fields) {\n+                field.accept(this);\n@@ -97,0 +130,2 @@\n+            _out.println(\"  }\");\n+            _out.println();\n@@ -98,1 +133,68 @@\n-        return \"new Type[] { \" + args.toString() + \" }\";\n+        final Method[] methods = clazz.getMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            _out.println(\"  private void createMethod_\" + i + \"() {\");\n+            methods[i].accept(this);\n+            _out.println(\"  }\");\n+            _out.println();\n+        }\n+        printMain();\n+        _out.println(\"}\");\n+    }\n+\n+\n+    private void printCreate() {\n+        _out.println(\"  public void create(OutputStream out) throws IOException {\");\n+        final Field[] fields = _clazz.getFields();\n+        if (fields.length > 0) {\n+            _out.println(\"    createFields();\");\n+        }\n+        final Method[] methods = _clazz.getMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            _out.println(\"    createMethod_\" + i + \"();\");\n+        }\n+        _out.println(\"    _cg.getJavaClass().dump(out);\");\n+        _out.println(\"  }\");\n+        _out.println();\n+    }\n+\n+\n+    private void printMain() {\n+        final String class_name = _clazz.getClassName();\n+        _out.println(\"  public static void main(String[] args) throws Exception {\");\n+        _out.println(\"    \" + class_name + \"Creator creator = new \" + class_name + \"Creator();\");\n+        _out.println(\"    creator.create(new FileOutputStream(\\\"\" + class_name + \".class\\\"));\");\n+        _out.println(\"  }\");\n+    }\n+\n+\n+    @Override\n+    public void visitField( final Field field ) {\n+        _out.println();\n+        _out.println(\"    field = new FieldGen(\" + printFlags(field.getAccessFlags()) + \", \"\n+                + printType(field.getSignature()) + \", \\\"\" + field.getName() + \"\\\", _cp);\");\n+        final ConstantValue cv = field.getConstantValue();\n+        if (cv != null) {\n+            final String value = cv.toString();\n+            _out.println(\"    field.setInitValue(\" + value + \")\");\n+        }\n+        _out.println(\"    _cg.addField(field.getField());\");\n+    }\n+\n+\n+    @Override\n+    public void visitMethod( final Method method ) {\n+        final MethodGen mg = new MethodGen(method, _clazz.getClassName(), _cp);\n+        _out.println(\"    InstructionList il = new InstructionList();\");\n+        _out.println(\"    MethodGen method = new MethodGen(\"\n+                + printFlags(method.getAccessFlags(), FLAGS.METHOD) + \", \"\n+                + printType(mg.getReturnType()) + \", \"\n+                + printArgumentTypes(mg.getArgumentTypes()) + \", \"\n+                + \"new String[] { \" + Utility.printArray(mg.getArgumentNames(), false, true)\n+                + \" }, \\\"\" + method.getName() + \"\\\", \\\"\" + _clazz.getClassName() + \"\\\", il, _cp);\");\n+        _out.println();\n+        final BCELFactory factory = new BCELFactory(mg, _out);\n+        factory.start();\n+        _out.println(\"    method.setMaxStack();\");\n+        _out.println(\"    method.setMaxLocals();\");\n+        _out.println(\"    _cg.addMethod(method.getMethod());\");\n+        _out.println(\"    il.dispose();\");\n@@ -101,1 +203,2 @@\n-    static String printFlags(final int flags) {\n+\n+    static String printFlags( final int flags ) {\n@@ -107,1 +210,0 @@\n-     *\n@@ -113,1 +215,1 @@\n-    public static String printFlags(final int flags, final FLAGS location) {\n+    public static String printFlags( final int flags, final FLAGS location ) {\n@@ -120,8 +222,6 @@\n-                if (pow == Const.ACC_SYNCHRONIZED && location == FLAGS.CLASS) {\n-                    buf.append(CONSTANT_PREFIX).append(\"ACC_SUPER | \");\n-                } else if (pow == Const.ACC_VOLATILE && location == FLAGS.METHOD) {\n-                    buf.append(CONSTANT_PREFIX).append(\"ACC_BRIDGE | \");\n-                } else if (pow == Const.ACC_TRANSIENT && location == FLAGS.METHOD) {\n-                    buf.append(CONSTANT_PREFIX).append(\"ACC_VARARGS | \");\n-                } else if (i < Const.ACCESS_NAMES_LENGTH) {\n-                    buf.append(CONSTANT_PREFIX).append(\"ACC_\").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append(\" | \");\n+                if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {\n+                    buf.append(CONSTANT_PREFIX+\"ACC_SUPER | \");\n+                } else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {\n+                    buf.append(CONSTANT_PREFIX+\"ACC_BRIDGE | \");\n+                } else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {\n+                    buf.append(CONSTANT_PREFIX+\"ACC_VARARGS | \");\n@@ -129,1 +229,7 @@\n-                    buf.append(String.format(CONSTANT_PREFIX + \"ACC_BIT %x | \", pow));\n+                    if (i < Const.ACCESS_NAMES_LENGTH) {\n+                        buf.append(CONSTANT_PREFIX+\"ACC_\")\n+                                .append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH))\n+                                .append( \" | \");\n+                    } else {\n+                        buf.append(String.format (CONSTANT_PREFIX+\"ACC_BIT %x | \", pow));\n+                    }\n@@ -138,14 +244,4 @@\n-    static String printType(final String signature) {\n-        final Type type = Type.getType(signature);\n-        final byte t = type.getType();\n-        if (t <= Const.T_VOID) {\n-            return \"Type.\" + Const.getTypeName(t).toUpperCase(Locale.ENGLISH);\n-        }\n-        if (type.toString().equals(\"java.lang.String\")) {\n-            return \"Type.STRING\";\n-        }\n-        if (type.toString().equals(\"java.lang.Object\")) {\n-            return \"Type.OBJECT\";\n-        }\n-        if (type.toString().equals(\"java.lang.StringBuffer\")) {\n-            return \"Type.STRINGBUFFER\";\n+\n+    static String printArgumentTypes( final Type[] arg_types ) {\n+        if (arg_types.length == 0) {\n+            return \"Type.NO_ARGS\";\n@@ -153,3 +249,6 @@\n-        if (type instanceof ArrayType) {\n-            final ArrayType at = (ArrayType) type;\n-            return \"new ArrayType(\" + printType(at.getBasicType()) + \", \" + at.getDimensions() + \")\";\n+        final StringBuilder args = new StringBuilder();\n+        for (int i = 0; i < arg_types.length; i++) {\n+            args.append(printType(arg_types[i]));\n+            if (i < arg_types.length - 1) {\n+                args.append(\", \");\n+            }\n@@ -157,1 +256,1 @@\n-        return \"new ObjectType(\\\"\" + Utility.signatureToString(signature, false) + \"\\\")\";\n+        return \"new Type[] { \" + args.toString() + \" }\";\n@@ -160,1 +259,2 @@\n-    static String printType(final Type type) {\n+\n+    static String printType( final Type type ) {\n@@ -164,3 +264,0 @@\n-    private final JavaClass clazz;\n-\n-    private final PrintWriter printWriter;\n@@ -168,23 +265,17 @@\n-    private final ConstantPoolGen constantPoolGen;\n-\n-    \/**\n-     * Constructs a new instance.\n-     *\n-     * @param clazz Java class to \"decompile\".\n-     * @param out where to print the Java program in UTF-8.\n-     *\/\n-    public BCELifier(final JavaClass clazz, final OutputStream out) {\n-        this.clazz = clazz;\n-        this.printWriter = new PrintWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8), false);\n-        this.constantPoolGen = new ConstantPoolGen(this.clazz.getConstantPool());\n-    }\n-\n-    private void printCreate() {\n-        printWriter.println(\"  public void create(OutputStream out) throws IOException {\");\n-        final Field[] fields = clazz.getFields();\n-        if (fields.length > 0) {\n-            printWriter.println(\"    createFields();\");\n-        }\n-        final Method[] methods = clazz.getMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            printWriter.println(\"    createMethod_\" + i + \"();\");\n+    static String printType( final String signature ) {\n+        final Type type = Type.getType(signature);\n+        final byte t = type.getType();\n+        if (t <= Const.T_VOID) {\n+            return \"Type.\" + Const.getTypeName(t).toUpperCase(Locale.ENGLISH);\n+        } else if (type.toString().equals(\"java.lang.String\")) {\n+            return \"Type.STRING\";\n+        } else if (type.toString().equals(\"java.lang.Object\")) {\n+            return \"Type.OBJECT\";\n+        } else if (type.toString().equals(\"java.lang.StringBuffer\")) {\n+            return \"Type.STRINGBUFFER\";\n+        } else if (type instanceof ArrayType) {\n+            final ArrayType at = (ArrayType) type;\n+            return \"new ArrayType(\" + printType(at.getBasicType()) + \", \" + at.getDimensions()\n+                    + \")\";\n+        } else {\n+            return \"new ObjectType(\\\"\" + Utility.signatureToString(signature, false) + \"\\\")\";\n@@ -192,3 +283,0 @@\n-        printWriter.println(\"    _cg.getJavaClass().dump(out);\");\n-        printWriter.println(\"  }\");\n-        printWriter.println();\n@@ -197,7 +285,0 @@\n-    private void printMain() {\n-        final String className = clazz.getClassName();\n-        printWriter.println(\"  public static void main(String[] args) throws Exception {\");\n-        printWriter.println(\"    \" + className + \"Creator creator = new \" + className + \"Creator();\");\n-        printWriter.println(\"    creator.create(new FileOutputStream(\\\"\" + className + \".class\\\"));\");\n-        printWriter.println(\"  }\");\n-    }\n@@ -205,2 +286,1 @@\n-    \/**\n-     * Start Java code generation\n+    \/** Default main method\n@@ -208,33 +288,5 @@\n-    public void start() {\n-        visitJavaClass(clazz);\n-        printWriter.flush();\n-    }\n-\n-    @Override\n-    public void visitField(final Field field) {\n-        printWriter.println();\n-        printWriter.println(\n-            \"    field = new FieldGen(\" + printFlags(field.getAccessFlags()) + \", \" + printType(field.getSignature()) + \", \\\"\" + field.getName() + \"\\\", _cp);\");\n-        final ConstantValue cv = field.getConstantValue();\n-        if (cv != null) {\n-            printWriter.print(\"    field.setInitValue(\");\n-            if (field.getType() == Type.CHAR) {\n-                printWriter.print(\"(char)\");\n-            }\n-            if (field.getType() == Type.SHORT) {\n-                printWriter.print(\"(short)\");\n-            }\n-            if (field.getType() == Type.BYTE) {\n-                printWriter.print(\"(byte)\");\n-            }\n-            printWriter.print(cv);\n-            if (field.getType() == Type.LONG) {\n-                printWriter.print(\"L\");\n-            }\n-            if (field.getType() == Type.FLOAT) {\n-                printWriter.print(\"F\");\n-            }\n-            if (field.getType() == Type.DOUBLE) {\n-                printWriter.print(\"D\");\n-            }\n-            printWriter.println(\");\");\n+    public static void main( final String[] argv ) throws Exception {\n+        if (argv.length != 1) {\n+            System.out.println(\"Usage: BCELifier classname\");\n+            System.out.println(\"\\tThe class must exist on the classpath\");\n+            return;\n@@ -242,1 +294,3 @@\n-        printWriter.println(\"    _cg.addField(field.getField());\");\n+        final JavaClass java_class = getJavaClass(argv[0]);\n+        final BCELifier bcelifier = new BCELifier(java_class, System.out);\n+        bcelifier.start();\n@@ -245,52 +299,0 @@\n-    @Override\n-    public void visitJavaClass(final JavaClass clazz) {\n-        String className = clazz.getClassName();\n-        final String superName = clazz.getSuperclassName();\n-        final String packageName = clazz.getPackageName();\n-        final String inter = Utility.printArray(clazz.getInterfaceNames(), false, true);\n-        if (packageName != null && !packageName.trim().isEmpty()) {\n-            className = className.substring(packageName.length() + 1);\n-            printWriter.println(\"package \" + packageName + \";\");\n-            printWriter.println();\n-        }\n-        printWriter.println(\"import \" + BASE_PACKAGE + \".generic.*;\");\n-        printWriter.println(\"import \" + BASE_PACKAGE + \".classfile.*;\");\n-        printWriter.println(\"import \" + BASE_PACKAGE + \".*;\");\n-        printWriter.println(\"import java.io.*;\");\n-        printWriter.println();\n-        printWriter.println(\"public class \" + className + \"Creator {\");\n-        printWriter.println(\"  private InstructionFactory _factory;\");\n-        printWriter.println(\"  private ConstantPoolGen    _cp;\");\n-        printWriter.println(\"  private ClassGen           _cg;\");\n-        printWriter.println();\n-        printWriter.println(\"  public \" + className + \"Creator() {\");\n-        printWriter.println(\"    _cg = new ClassGen(\\\"\" + (packageName.isEmpty() ? className : packageName + \".\" + className) + \"\\\", \\\"\" + superName\n-            + \"\\\", \" + \"\\\"\" + clazz.getSourceFileName() + \"\\\", \" + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + \", \" + \"new String[] { \" + inter + \" });\");\n-        printWriter.println(\"    _cg.setMajor(\" + clazz.getMajor() + \");\");\n-        printWriter.println(\"    _cg.setMinor(\" + clazz.getMinor() + \");\");\n-        printWriter.println();\n-        printWriter.println(\"    _cp = _cg.getConstantPool();\");\n-        printWriter.println(\"    _factory = new InstructionFactory(_cg, _cp);\");\n-        printWriter.println(\"  }\");\n-        printWriter.println();\n-        printCreate();\n-        final Field[] fields = clazz.getFields();\n-        if (fields.length > 0) {\n-            printWriter.println(\"  private void createFields() {\");\n-            printWriter.println(\"    FieldGen field;\");\n-            for (final Field field : fields) {\n-                field.accept(this);\n-            }\n-            printWriter.println(\"  }\");\n-            printWriter.println();\n-        }\n-        final Method[] methods = clazz.getMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            printWriter.println(\"  private void createMethod_\" + i + \"() {\");\n-            methods[i].accept(this);\n-            printWriter.println(\"  }\");\n-            printWriter.println();\n-        }\n-        printMain();\n-        printWriter.println(\"}\");\n-    }\n@@ -298,15 +300,5 @@\n-    @Override\n-    public void visitMethod(final Method method) {\n-        final MethodGen mg = new MethodGen(method, clazz.getClassName(), constantPoolGen);\n-        printWriter.println(\"    InstructionList il = new InstructionList();\");\n-        printWriter.println(\"    MethodGen method = new MethodGen(\" + printFlags(method.getAccessFlags(), FLAGS.METHOD) + \", \" + printType(mg.getReturnType())\n-            + \", \" + printArgumentTypes(mg.getArgumentTypes()) + \", \" + \"new String[] { \" + Utility.printArray(mg.getArgumentNames(), false, true) + \" }, \\\"\"\n-            + method.getName() + \"\\\", \\\"\" + clazz.getClassName() + \"\\\", il, _cp);\");\n-        final ExceptionTable exceptionTable = method.getExceptionTable();\n-        if (exceptionTable != null) {\n-            final String[] exceptionNames = exceptionTable.getExceptionNames();\n-            for (final String exceptionName : exceptionNames) {\n-                printWriter.print(\"    method.addException(\\\"\");\n-                printWriter.print(exceptionName);\n-                printWriter.println(\"\\\");\");\n-            }\n+    \/\/ Needs to be accessible from unit test code\n+    static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {\n+        JavaClass java_class;\n+        if ((java_class = Repository.lookupClass(name)) == null) {\n+            java_class = new ClassParser(name).parse(); \/\/ May throw IOException\n@@ -314,7 +306,1 @@\n-        printWriter.println();\n-        final BCELFactory factory = new BCELFactory(mg, printWriter);\n-        factory.start();\n-        printWriter.println(\"    method.setMaxStack();\");\n-        printWriter.println(\"    method.setMaxLocals();\");\n-        printWriter.println(\"    _cg.addMethod(method.getMethod());\");\n-        printWriter.println(\"    il.dispose();\");\n+        return java_class;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELifier.java","additions":199,"deletions":213,"binary":false,"changes":412,"status":"modified"},{"patch":"@@ -28,2 +28,4 @@\n- * Utility class that implements a sequence of bytes which can be read via the 'readByte()' method. This is used to\n- * implement a wrapper for the Java byte code stream to gain some more readability.\n+ * Utility class that implements a sequence of bytes which can be read\n+ * via the `readByte()' method. This is used to implement a wrapper for the\n+ * Java byte code stream to gain some more readability.\n+ *\n@@ -33,0 +35,18 @@\n+    private final ByteArrayStream byteStream;\n+\n+\n+    public ByteSequence(final byte[] bytes) {\n+        super(new ByteArrayStream(bytes));\n+        byteStream = (ByteArrayStream) in;\n+    }\n+\n+\n+    public int getIndex() {\n+        return byteStream.getPosition();\n+    }\n+\n+\n+    void unreadByte() {\n+        byteStream.unreadByte();\n+    }\n+\n@@ -50,15 +70,0 @@\n-\n-    private final ByteArrayStream byteStream;\n-\n-    public ByteSequence(final byte[] bytes) {\n-        super(new ByteArrayStream(bytes));\n-        byteStream = (ByteArrayStream) in;\n-    }\n-\n-    public int getIndex() {\n-        return byteStream.getPosition();\n-    }\n-\n-    void unreadByte() {\n-        byteStream.unreadByte();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ByteSequence.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n@@ -26,3 +26,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n@@ -43,1 +40,2 @@\n- * Given a JavaClass object \"class\" that is in package \"package\" five files will be created in the specified directory.\n+ * Given a JavaClass object \"class\" that is in package \"package\" five files\n+ * will be created in the specified directory.\n@@ -46,5 +44,6 @@\n- * <LI>\"package\".\"class\".html as the main file which defines the frames for the following subfiles.\n- * <LI>\"package\".\"class\"_attributes.html contains all (known) attributes found in the file\n- * <LI>\"package\".\"class\"_cp.html contains the constant pool\n- * <LI>\"package\".\"class\"_code.html contains the byte code\n- * <LI>\"package\".\"class\"_methods.html contains references to all methods and fields of the class\n+ * <LI> \"package\".\"class\".html as the main file which defines the frames for\n+ * the following subfiles.\n+ * <LI>  \"package\".\"class\"_attributes.html contains all (known) attributes found in the file\n+ * <LI>  \"package\".\"class\"_cp.html contains the constant pool\n+ * <LI>  \"package\".\"class\"_code.html contains the byte code\n+ * <LI>  \"package\".\"class\"_methods.html contains references to all methods and fields of the class\n@@ -53,2 +52,3 @@\n- * All subfiles reference each other appropriately, e.g. clicking on a method in the Method's frame will jump to the\n- * appropriate method in the Code frame.\n+ * All subfiles reference each other appropriately, e.g. clicking on a\n+ * method in the Method's frame will jump to the appropriate method in\n+ * the Code frame.\n@@ -56,1 +56,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -60,4 +60,7 @@\n-    private static String classPackage; \/\/ name of package, unclean to make it static, but ...\n-    private static String className; \/\/ name of current class, dito\n-    private static ConstantPool constantPool;\n-    private static final Set<String> basicTypes = new HashSet<>();\n+    private final JavaClass java_class; \/\/ current class object\n+    private final String dir;\n+    private static String class_package; \/\/ name of package, unclean to make it static, but ...\n+    private static String class_name; \/\/ name of current class, dito\n+    private static ConstantPool constant_pool;\n+    private static final Set<String> basic_types = new HashSet<>();\n+\n@@ -65,9 +68,9 @@\n-        basicTypes.add(\"int\");\n-        basicTypes.add(\"short\");\n-        basicTypes.add(\"boolean\");\n-        basicTypes.add(\"void\");\n-        basicTypes.add(\"char\");\n-        basicTypes.add(\"byte\");\n-        basicTypes.add(\"long\");\n-        basicTypes.add(\"double\");\n-        basicTypes.add(\"float\");\n+        basic_types.add(\"int\");\n+        basic_types.add(\"short\");\n+        basic_types.add(\"boolean\");\n+        basic_types.add(\"void\");\n+        basic_types.add(\"char\");\n+        basic_types.add(\"byte\");\n+        basic_types.add(\"long\");\n+        basic_types.add(\"double\");\n+        basic_types.add(\"float\");\n@@ -76,2 +79,37 @@\n-    public static void _main(final String[] argv) throws IOException {\n-        final String[] fileName = new String[argv.length];\n+    \/**\n+     * Write contents of the given JavaClass into HTML files.\n+     *\n+     * @param java_class The class to write\n+     * @param dir The directory to put the files in\n+     *\/\n+    public Class2HTML(final JavaClass java_class, final String dir) throws IOException {\n+        final Method[] methods = java_class.getMethods();\n+        this.java_class = java_class;\n+        this.dir = dir;\n+        class_name = java_class.getClassName(); \/\/ Remember full name\n+        constant_pool = java_class.getConstantPool();\n+        \/\/ Get package name by tacking off everything after the last `.'\n+        final int index = class_name.lastIndexOf('.');\n+        if (index > -1) {\n+            class_package = class_name.substring(0, index);\n+        } else {\n+            class_package = \"\"; \/\/ default package\n+        }\n+        final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods,\n+                constant_pool);\n+        \/* Attributes can't be written in one step, so we just open a file\n+         * which will be written consequently.\n+         *\/\n+        final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool,\n+                constant_html);\n+        new MethodHTML(dir, class_name, methods, java_class.getFields(),\n+                constant_html, attribute_html);\n+        \/\/ Write main file (with frames, yuk)\n+        writeMainHTML(attribute_html);\n+        new CodeHTML(dir, class_name, methods, constant_pool, constant_html);\n+        attribute_html.close();\n+    }\n+\n+\n+    public static void main( final String[] argv ) throws IOException {\n+        final String[] file_name = new String[argv.length];\n@@ -80,2 +118,2 @@\n-        JavaClass javaClass = null;\n-        String zipFile = null;\n+        JavaClass java_class = null;\n+        String zip_file = null;\n@@ -84,2 +122,1 @@\n-        \/*\n-         * Parse command line arguments.\n+        \/* Parse command line arguments.\n@@ -97,2 +134,4 @@\n-                        if (!created && !store.isDirectory()) {\n-                            System.out.println(\"Tried to create the directory \" + dir + \" but failed\");\n+                        if (!created) {\n+                            if (!store.isDirectory()) {\n+                                System.out.println(\"Tried to create the directory \" + dir + \" but failed\");\n+                            }\n@@ -102,1 +141,1 @@\n-                    zipFile = argv[++i];\n+                    zip_file = argv[++i];\n@@ -107,1 +146,1 @@\n-                fileName[files++] = argv[i];\n+                file_name[files++] = argv[i];\n@@ -114,3 +153,3 @@\n-                System.out.print(\"Processing \" + fileName[i] + \"...\");\n-                if (zipFile == null) {\n-                    parser = new ClassParser(fileName[i]); \/\/ Create parser object from file\n+                System.out.print(\"Processing \" + file_name[i] + \"...\");\n+                if (zip_file == null) {\n+                    parser = new ClassParser(file_name[i]); \/\/ Create parser object from file\n@@ -118,1 +157,1 @@\n-                    parser = new ClassParser(zipFile, fileName[i]); \/\/ Create parser object from zip file\n+                    parser = new ClassParser(zip_file, file_name[i]); \/\/ Create parser object from zip file\n@@ -120,2 +159,2 @@\n-                javaClass = parser.parse();\n-                new Class2HTML(javaClass, dir);\n+                java_class = parser.parse();\n+                new Class2HTML(java_class, dir);\n@@ -128,1 +167,2 @@\n-     * Utility method that converts a class reference in the constant pool, i.e., an index to a string.\n+     * Utility method that converts a class reference in the constant pool,\n+     * i.e., an index to a string.\n@@ -131,1 +171,1 @@\n-        String str = constantPool.getConstantString(index, Const.CONSTANT_Class);\n+        String str = constant_pool.getConstantString(index, Const.CONSTANT_Class);\n@@ -133,2 +173,3 @@\n-        str = Utility.compactClassName(str, classPackage + \".\", true);\n-        return \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + str + \"<\/A>\";\n+        str = Utility.compactClassName(str, class_package + \".\", true);\n+        return \"<A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + str\n+                + \"<\/A>\";\n@@ -137,3 +178,4 @@\n-    static String referenceType(final String type) {\n-        String shortType = Utility.compactClassName(type);\n-        shortType = Utility.compactClassName(shortType, classPackage + \".\", true);\n+\n+    static String referenceType( final String type ) {\n+        String short_type = Utility.compactClassName(type);\n+        short_type = Utility.compactClassName(short_type, class_package + \".\", true);\n@@ -141,1 +183,1 @@\n-        String baseType = type;\n+        String base_type = type;\n@@ -143,1 +185,1 @@\n-            baseType = type.substring(0, index); \/\/ Tack of the '['\n+            base_type = type.substring(0, index); \/\/ Tack of the `['\n@@ -146,1 +188,1 @@\n-        if (basicTypes.contains(baseType)) {\n+        if (basic_types.contains(base_type)) {\n@@ -149,1 +191,1 @@\n-        return \"<A HREF=\\\"\" + baseType + \".html\\\" TARGET=_top>\" + shortType + \"<\/A>\";\n+        return \"<A HREF=\\\"\" + base_type + \".html\\\" TARGET=_top>\" + short_type + \"<\/A>\";\n@@ -152,1 +194,2 @@\n-    static String toHTML(final String str) {\n+\n+    static String toHTML( final String str ) {\n@@ -157,14 +200,14 @@\n-            case '<':\n-                buf.append(\"&lt;\");\n-                break;\n-            case '>':\n-                buf.append(\"&gt;\");\n-                break;\n-            case '\\n':\n-                buf.append(\"\\\\n\");\n-                break;\n-            case '\\r':\n-                buf.append(\"\\\\r\");\n-                break;\n-            default:\n-                buf.append(ch);\n+                case '<':\n+                    buf.append(\"&lt;\");\n+                    break;\n+                case '>':\n+                    buf.append(\"&gt;\");\n+                    break;\n+                case '\\n':\n+                    buf.append(\"\\\\n\");\n+                    break;\n+                case '\\r':\n+                    buf.append(\"\\\\r\");\n+                    break;\n+                default:\n+                    buf.append(ch);\n@@ -176,39 +219,0 @@\n-    private final JavaClass javaClass; \/\/ current class object\n-\n-    private final String dir;\n-\n-    \/**\n-     * Write contents of the given JavaClass into HTML files.\n-     *\n-     * @param javaClass The class to write\n-     * @param dir The directory to put the files in\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n-     *\/\n-    public Class2HTML(final JavaClass javaClass, final String dir) throws IOException {\n-        this(javaClass, dir, StandardCharsets.UTF_8);\n-    }\n-\n-    private Class2HTML(final JavaClass javaClass, final String dir, final Charset charset) throws IOException {\n-        final Method[] methods = javaClass.getMethods();\n-        this.javaClass = javaClass;\n-        this.dir = dir;\n-        className = javaClass.getClassName(); \/\/ Remember full name\n-        constantPool = javaClass.getConstantPool();\n-        \/\/ Get package name by tacking off everything after the last '.'\n-        final int index = className.lastIndexOf('.');\n-        if (index > -1) {\n-            classPackage = className.substring(0, index);\n-        } else {\n-            classPackage = \"\"; \/\/ default package\n-        }\n-        final ConstantHTML constantHtml = new ConstantHTML(dir, className, classPackage, methods, constantPool, charset);\n-        \/*\n-         * Attributes can't be written in one step, so we just open a file which will be written consequently.\n-         *\/\n-        try (AttributeHTML attributeHtml = new AttributeHTML(dir, className, constantPool, constantHtml, charset)) {\n-            new MethodHTML(dir, className, methods, javaClass.getFields(), constantHtml, attributeHtml, charset);\n-            \/\/ Write main file (with frames, yuk)\n-            writeMainHTML(attributeHtml, charset);\n-            new CodeHTML(dir, className, methods, constantPool, constantHtml, charset);\n-        }\n-    }\n@@ -216,9 +220,12 @@\n-    private void writeMainHTML(final AttributeHTML attributeHtml, final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n-        try (PrintWriter file = new PrintWriter(dir + className + \".html\", charset.name())) {\n-            file.println(\"<HTML>\\n\" + \"<HEAD><TITLE>Documentation for \" + className + \"<\/TITLE>\" + \"<\/HEAD>\\n\" + \"<FRAMESET BORDER=1 cols=\\\"30%,*\\\">\\n\"\n-                + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"ConstantPool\\\" SRC=\\\"\" + className + \"_cp.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n-                + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Attributes\\\" SRC=\\\"\" + className + \"_attributes.html\"\n-                + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \" + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET>\\n\"\n-                + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"Code\\\" SRC=\\\"\" + className + \"_code.html\\\"\\n MARGINWIDTH=0 \"\n-                + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Methods\\\" SRC=\\\"\" + className + \"_methods.html\\\"\\n MARGINWIDTH=0 \"\n-                + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET><\/FRAMESET><\/HTML>\");\n+    private void writeMainHTML( final AttributeHTML attribute_html ) throws IOException {\n+        try (PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + \".html\"))) {\n+            file.println(\"<HTML>\\n\" + \"<HEAD><TITLE>Documentation for \" + class_name + \"<\/TITLE>\" + \"<\/HEAD>\\n\"\n+                    + \"<FRAMESET BORDER=1 cols=\\\"30%,*\\\">\\n\" + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\"\n+                    + \"<FRAME NAME=\\\"ConstantPool\\\" SRC=\\\"\" + class_name + \"_cp.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n+                    + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Attributes\\\" SRC=\\\"\"\n+                    + class_name + \"_attributes.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n+                    + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET>\\n\"\n+                    + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"Code\\\" SRC=\\\"\" + class_name\n+                    + \"_code.html\\\"\\n MARGINWIDTH=0 \" + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\"\n+                    + \"<FRAME NAME=\\\"Methods\\\" SRC=\\\"\" + class_name + \"_methods.html\\\"\\n MARGINWIDTH=0 \"\n+                    + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET><\/FRAMESET><\/HTML>\");\n@@ -226,1 +233,1 @@\n-        final Attribute[] attributes = javaClass.getAttributes();\n+        final Attribute[] attributes = java_class.getAttributes();\n@@ -228,1 +235,1 @@\n-            attributeHtml.writeAttribute(attributes[i], \"class\" + i);\n+            attribute_html.writeAttribute(attributes[i], \"class\" + i);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Class2HTML.java","additions":126,"deletions":119,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n- * Utility class implementing a (typesafe) queue of JavaClass objects.\n+ * Utility class implementing a (typesafe) queue of JavaClass\n+ * objects.\n+ *\n@@ -32,5 +34,7 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access\n-     *\/\n-    @Deprecated\n-    protected LinkedList<JavaClass> vec = new LinkedList<>(); \/\/ TODO not used externally\n+    private final LinkedList<JavaClass> vec = new LinkedList<>();\n+\n+\n+    public void enqueue( final JavaClass clazz ) {\n+        vec.addLast(clazz);\n+    }\n+\n@@ -42,0 +46,1 @@\n+\n@@ -46,3 +51,0 @@\n-    public void enqueue(final JavaClass clazz) {\n-        vec.addLast(clazz);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassQueue.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -23,1 +24,1 @@\n-import com.sun.org.apache.bcel.internal.Const;\n+import java.util.Collection;\n@@ -30,1 +31,3 @@\n- * Utility class implementing a (type-safe) set of JavaClass objects. Since JavaClass has no equals() method, the name of the class is used for comparison.\n+ * Utility class implementing a (typesafe) set of JavaClass objects.\n+ * Since JavaClass has no equals() method, the name of the class is\n+ * used for comparison.\n@@ -33,1 +36,0 @@\n- * @LastModified: Feb 2023\n@@ -39,2 +41,8 @@\n-    public boolean add(final JavaClass clazz) {\n-        return map.putIfAbsent(clazz.getClassName(), clazz) != null;\n+\n+    public boolean add( final JavaClass clazz ) {\n+        boolean result = false;\n+        if (!map.containsKey(clazz.getClassName())) {\n+            result = true;\n+            map.put(clazz.getClassName(), clazz);\n+        }\n+        return result;\n@@ -43,0 +51,6 @@\n+\n+    public void remove( final JavaClass clazz ) {\n+        map.remove(clazz.getClassName());\n+    }\n+\n+\n@@ -47,3 +61,0 @@\n-    public String[] getClassNames() {\n-        return map.keySet().toArray(Const.EMPTY_STRING_ARRAY);\n-    }\n@@ -51,2 +62,5 @@\n-    public void remove(final JavaClass clazz) {\n-        map.remove(clazz.getClassName());\n+    public JavaClass[] toArray() {\n+        final Collection<JavaClass> values = map.values();\n+        final JavaClass[] classes = new JavaClass[values.size()];\n+        values.toArray(classes);\n+        return classes;\n@@ -55,2 +69,3 @@\n-    public JavaClass[] toArray() {\n-        return map.values().toArray(JavaClass.EMPTY_ARRAY);\n+\n+    public String[] getClassNames() {\n+        return map.keySet().toArray(new String[map.size()]);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassSet.java","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -37,2 +37,3 @@\n-    public boolean empty() {\n-        return stack.empty();\n+\n+    public void push( final JavaClass clazz ) {\n+        stack.push(clazz);\n@@ -41,0 +42,1 @@\n+\n@@ -45,3 +47,0 @@\n-    public void push(final JavaClass clazz) {\n-        stack.push(clazz);\n-    }\n@@ -52,0 +51,5 @@\n+\n+\n+    public boolean empty() {\n+        return stack.empty();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassStack.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.FileOutputStream;\n@@ -26,1 +27,0 @@\n-import java.nio.charset.Charset;\n@@ -39,0 +39,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.LocalVariable;\n@@ -45,0 +46,2 @@\n+ *\n+ *\n@@ -48,1 +51,0 @@\n-    private static boolean wide;\n@@ -50,2 +52,2 @@\n-    \/\/ private Method[] methods; \/\/ Methods to print\n-    private final PrintWriter printWriter; \/\/ file to write to\n+\/\/    private Method[] methods; \/\/ Methods to print\n+    private final PrintWriter file; \/\/ file to write to\n@@ -55,0 +57,1 @@\n+    private static boolean wide = false;\n@@ -56,3 +59,4 @@\n-    CodeHTML(final String dir, final String className, final Method[] methods, final ConstantPool constantPool, final ConstantHTML constantHtml,\n-        final Charset charset) throws IOException {\n-        this.className = className;\n+\n+    CodeHTML(final String dir, final String class_name, final Method[] methods, final ConstantPool constant_pool,\n+            final ConstantHTML constant_html) throws IOException {\n+        this.className = class_name;\n@@ -60,12 +64,6 @@\n-        this.constantPool = constantPool;\n-        this.constantHtml = constantHtml;\n-        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_code.html\", charset.name())) {\n-            printWriter = newPrintWriter;\n-            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n-            printWriter.print(charset.name());\n-            printWriter.println(\"\\\"><\/head>\");\n-            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\">\");\n-            for (int i = 0; i < methods.length; i++) {\n-                writeMethod(methods[i], i);\n-            }\n-            printWriter.println(\"<\/BODY><\/HTML>\");\n+        this.constantPool = constant_pool;\n+        this.constantHtml = constant_html;\n+        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_code.html\"));\n+        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\">\");\n+        for (int i = 0; i < methods.length; i++) {\n+            writeMethod(methods[i], i);\n@@ -73,0 +71,2 @@\n+        file.println(\"<\/BODY><\/HTML>\");\n+        file.close();\n@@ -75,0 +75,1 @@\n+\n@@ -76,1 +77,2 @@\n-     * Disassemble a stream of byte codes and return the string representation.\n+     * Disassemble a stream of byte codes and return the\n+     * string representation.\n@@ -78,1 +80,1 @@\n-     * @param stream data input stream\n+     * @param  stream data input stream\n@@ -81,1 +83,1 @@\n-    private String codeToHTML(final ByteSequence bytes, final int methodNumber) throws IOException {\n+    private String codeToHTML( final ByteSequence bytes, final int method_number ) throws IOException {\n@@ -85,1 +87,1 @@\n-        int defaultOffset = 0;\n+        int default_offset = 0;\n@@ -89,1 +91,1 @@\n-        int classIndex;\n+        int class_index;\n@@ -92,2 +94,2 @@\n-        int[] jumpTable;\n-        int noPadBytes = 0;\n+        int[] jump_table;\n+        int no_pad_bytes = 0;\n@@ -97,2 +99,2 @@\n-        \/*\n-         * Special case: Skip (0-3) padding bytes, i.e., the following bytes are 4-byte-aligned\n+        \/* Special case: Skip (0-3) padding bytes, i.e., the\n+         * following bytes are 4-byte-aligned\n@@ -100,1 +102,1 @@\n-        if (opcode == Const.TABLESWITCH || opcode == Const.LOOKUPSWITCH) {\n+        if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {\n@@ -102,2 +104,2 @@\n-            noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n-            for (int i = 0; i < noPadBytes; i++) {\n+            no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n+            for (int i = 0; i < no_pad_bytes; i++) {\n@@ -107,1 +109,1 @@\n-            defaultOffset = bytes.readInt();\n+            default_offset = bytes.readInt();\n@@ -110,131 +112,17 @@\n-        case Const.TABLESWITCH:\n-            low = bytes.readInt();\n-            high = bytes.readInt();\n-            offset = bytes.getIndex() - 12 - noPadBytes - 1;\n-            defaultOffset += offset;\n-            buf.append(\"<TABLE BORDER=1><TR>\");\n-            \/\/ Print switch indices in first row (and default)\n-            jumpTable = new int[high - low + 1];\n-            for (int i = 0; i < jumpTable.length; i++) {\n-                jumpTable[i] = offset + bytes.readInt();\n-                buf.append(\"<TH>\").append(low + i).append(\"<\/TH>\");\n-            }\n-            buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n-            \/\/ Print target and default indices in second row\n-            for (final int element : jumpTable) {\n-                buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(element).append(\"\\\">\").append(element).append(\"<\/A><\/TD>\");\n-            }\n-            buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(defaultOffset).append(\"\\\">\").append(defaultOffset)\n-                .append(\"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n-            break;\n-        \/*\n-         * Lookup switch has variable length arguments.\n-         *\/\n-        case Const.LOOKUPSWITCH:\n-            final int npairs = bytes.readInt();\n-            offset = bytes.getIndex() - 8 - noPadBytes - 1;\n-            jumpTable = new int[npairs];\n-            defaultOffset += offset;\n-            buf.append(\"<TABLE BORDER=1><TR>\");\n-            \/\/ Print switch indices in first row (and default)\n-            for (int i = 0; i < npairs; i++) {\n-                final int match = bytes.readInt();\n-                jumpTable[i] = offset + bytes.readInt();\n-                buf.append(\"<TH>\").append(match).append(\"<\/TH>\");\n-            }\n-            buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n-            \/\/ Print target and default indices in second row\n-            for (int i = 0; i < npairs; i++) {\n-                buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(jumpTable[i]).append(\"\\\">\").append(jumpTable[i])\n-                    .append(\"<\/A><\/TD>\");\n-            }\n-            buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(defaultOffset).append(\"\\\">\").append(defaultOffset)\n-                .append(\"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n-            break;\n-        \/*\n-         * Two address bytes + offset from start of byte stream form the jump target.\n-         *\/\n-        case Const.GOTO:\n-        case Const.IFEQ:\n-        case Const.IFGE:\n-        case Const.IFGT:\n-        case Const.IFLE:\n-        case Const.IFLT:\n-        case Const.IFNE:\n-        case Const.IFNONNULL:\n-        case Const.IFNULL:\n-        case Const.IF_ACMPEQ:\n-        case Const.IF_ACMPNE:\n-        case Const.IF_ICMPEQ:\n-        case Const.IF_ICMPGE:\n-        case Const.IF_ICMPGT:\n-        case Const.IF_ICMPLE:\n-        case Const.IF_ICMPLT:\n-        case Const.IF_ICMPNE:\n-        case Const.JSR:\n-            index = bytes.getIndex() + bytes.readShort() - 1;\n-            buf.append(\"<A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(index).append(\"\\\">\").append(index).append(\"<\/A>\");\n-            break;\n-        \/*\n-         * Same for 32-bit wide jumps\n-         *\/\n-        case Const.GOTO_W:\n-        case Const.JSR_W:\n-            final int windex = bytes.getIndex() + bytes.readInt() - 1;\n-            buf.append(\"<A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(windex).append(\"\\\">\").append(windex).append(\"<\/A>\");\n-            break;\n-        \/*\n-         * Index byte references local variable (register)\n-         *\/\n-        case Const.ALOAD:\n-        case Const.ASTORE:\n-        case Const.DLOAD:\n-        case Const.DSTORE:\n-        case Const.FLOAD:\n-        case Const.FSTORE:\n-        case Const.ILOAD:\n-        case Const.ISTORE:\n-        case Const.LLOAD:\n-        case Const.LSTORE:\n-        case Const.RET:\n-            if (wide) {\n-                vindex = bytes.readShort();\n-                wide = false; \/\/ Clear flag\n-            } else {\n-                vindex = bytes.readUnsignedByte();\n-            }\n-            buf.append(\"%\").append(vindex);\n-            break;\n-        \/*\n-         * Remember wide byte which is used to form a 16-bit address in the following instruction. Relies on that the method is\n-         * called again with the following opcode.\n-         *\/\n-        case Const.WIDE:\n-            wide = true;\n-            buf.append(\"(wide)\");\n-            break;\n-        \/*\n-         * Array of basic type.\n-         *\/\n-        case Const.NEWARRAY:\n-            buf.append(\"<FONT COLOR=\\\"#00FF00\\\">\").append(Const.getTypeName(bytes.readByte())).append(\"<\/FONT>\");\n-            break;\n-        \/*\n-         * Access object\/class fields.\n-         *\/\n-        case Const.GETFIELD:\n-        case Const.GETSTATIC:\n-        case Const.PUTFIELD:\n-        case Const.PUTSTATIC:\n-            index = bytes.readShort();\n-            final ConstantFieldref c1 = constantPool.getConstant(index, Const.CONSTANT_Fieldref, ConstantFieldref.class);\n-            classIndex = c1.getClassIndex();\n-            name = constantPool.getConstantString(classIndex, Const.CONSTANT_Class);\n-            name = Utility.compactClassName(name, false);\n-            index = c1.getNameAndTypeIndex();\n-            final String fieldName = constantPool.constantToString(index, Const.CONSTANT_NameAndType);\n-            if (name.equals(className)) { \/\/ Local field\n-                buf.append(\"<A HREF=\\\"\").append(className).append(\"_methods.html#field\").append(fieldName).append(\"\\\" TARGET=Methods>\").append(fieldName)\n-                    .append(\"<\/A>\\n\");\n-            } else {\n-                buf.append(constantHtml.referenceConstant(classIndex)).append(\".\").append(fieldName);\n+            case Const.TABLESWITCH:\n+                low = bytes.readInt();\n+                high = bytes.readInt();\n+                offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n+                default_offset += offset;\n+                buf.append(\"<TABLE BORDER=1><TR>\");\n+                \/\/ Print switch indices in first row (and default)\n+                jump_table = new int[high - low + 1];\n+                for (int i = 0; i < jump_table.length; i++) {\n+                    jump_table[i] = offset + bytes.readInt();\n+                    buf.append(\"<TH>\").append(low + i).append(\"<\/TH>\");\n+                }\n+                buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n+                \/\/ Print target and default indices in second row\n+            for (final int element : jump_table) {\n+                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n+                        element).append(\"\\\">\").append(element).append(\"<\/A><\/TD>\");\n@@ -242,23 +130,140 @@\n-            break;\n-        \/*\n-         * Operands are references to classes in constant pool\n-         *\/\n-        case Const.CHECKCAST:\n-        case Const.INSTANCEOF:\n-        case Const.NEW:\n-            index = bytes.readShort();\n-            buf.append(constantHtml.referenceConstant(index));\n-            break;\n-        \/*\n-         * Operands are references to methods in constant pool\n-         *\/\n-        case Const.INVOKESPECIAL:\n-        case Const.INVOKESTATIC:\n-        case Const.INVOKEVIRTUAL:\n-        case Const.INVOKEINTERFACE:\n-        case Const.INVOKEDYNAMIC:\n-            final int mIndex = bytes.readShort();\n-            String str;\n-            if (opcode == Const.INVOKEINTERFACE) { \/\/ Special treatment needed\n-                bytes.readUnsignedByte(); \/\/ Redundant\n-                bytes.readUnsignedByte(); \/\/ Reserved\n+                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n+                        default_offset).append(\"\\\">\").append(default_offset).append(\n+                        \"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n+                break;\n+            \/* Lookup switch has variable length arguments.\n+             *\/\n+            case Const.LOOKUPSWITCH:\n+                final int npairs = bytes.readInt();\n+                offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n+                jump_table = new int[npairs];\n+                default_offset += offset;\n+                buf.append(\"<TABLE BORDER=1><TR>\");\n+                \/\/ Print switch indices in first row (and default)\n+                for (int i = 0; i < npairs; i++) {\n+                    final int match = bytes.readInt();\n+                    jump_table[i] = offset + bytes.readInt();\n+                    buf.append(\"<TH>\").append(match).append(\"<\/TH>\");\n+                }\n+                buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n+                \/\/ Print target and default indices in second row\n+                for (int i = 0; i < npairs; i++) {\n+                    buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n+                            jump_table[i]).append(\"\\\">\").append(jump_table[i]).append(\"<\/A><\/TD>\");\n+                }\n+                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n+                        default_offset).append(\"\\\">\").append(default_offset).append(\n+                        \"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n+                break;\n+            \/* Two address bytes + offset from start of byte stream form the\n+             * jump target.\n+             *\/\n+            case Const.GOTO:\n+            case Const.IFEQ:\n+            case Const.IFGE:\n+            case Const.IFGT:\n+            case Const.IFLE:\n+            case Const.IFLT:\n+            case Const.IFNE:\n+            case Const.IFNONNULL:\n+            case Const.IFNULL:\n+            case Const.IF_ACMPEQ:\n+            case Const.IF_ACMPNE:\n+            case Const.IF_ICMPEQ:\n+            case Const.IF_ICMPGE:\n+            case Const.IF_ICMPGT:\n+            case Const.IF_ICMPLE:\n+            case Const.IF_ICMPLT:\n+            case Const.IF_ICMPNE:\n+            case Const.JSR:\n+                index = bytes.getIndex() + bytes.readShort() - 1;\n+                buf.append(\"<A HREF=\\\"#code\").append(method_number).append(\"@\").append(index)\n+                        .append(\"\\\">\").append(index).append(\"<\/A>\");\n+                break;\n+            \/* Same for 32-bit wide jumps\n+             *\/\n+            case Const.GOTO_W:\n+            case Const.JSR_W:\n+                final int windex = bytes.getIndex() + bytes.readInt() - 1;\n+                buf.append(\"<A HREF=\\\"#code\").append(method_number).append(\"@\").append(windex)\n+                        .append(\"\\\">\").append(windex).append(\"<\/A>\");\n+                break;\n+            \/* Index byte references local variable (register)\n+             *\/\n+            case Const.ALOAD:\n+            case Const.ASTORE:\n+            case Const.DLOAD:\n+            case Const.DSTORE:\n+            case Const.FLOAD:\n+            case Const.FSTORE:\n+            case Const.ILOAD:\n+            case Const.ISTORE:\n+            case Const.LLOAD:\n+            case Const.LSTORE:\n+            case Const.RET:\n+                if (wide) {\n+                    vindex = bytes.readShort();\n+                    wide = false; \/\/ Clear flag\n+                } else {\n+                    vindex = bytes.readUnsignedByte();\n+                }\n+                buf.append(\"%\").append(vindex);\n+                break;\n+            \/*\n+             * Remember wide byte which is used to form a 16-bit address in the\n+             * following instruction. Relies on that the method is called again with\n+             * the following opcode.\n+             *\/\n+            case Const.WIDE:\n+                wide = true;\n+                buf.append(\"(wide)\");\n+                break;\n+            \/* Array of basic type.\n+             *\/\n+            case Const.NEWARRAY:\n+                buf.append(\"<FONT COLOR=\\\"#00FF00\\\">\").append(Const.getTypeName(bytes.readByte())).append(\n+                        \"<\/FONT>\");\n+                break;\n+            \/* Access object\/class fields.\n+             *\/\n+            case Const.GETFIELD:\n+            case Const.GETSTATIC:\n+            case Const.PUTFIELD:\n+            case Const.PUTSTATIC:\n+                index = bytes.readShort();\n+                final ConstantFieldref c1 = (ConstantFieldref) constantPool.getConstant(index,\n+                        Const.CONSTANT_Fieldref);\n+                class_index = c1.getClassIndex();\n+                name = constantPool.getConstantString(class_index, Const.CONSTANT_Class);\n+                name = Utility.compactClassName(name, false);\n+                index = c1.getNameAndTypeIndex();\n+                final String field_name = constantPool.constantToString(index, Const.CONSTANT_NameAndType);\n+                if (name.equals(className)) { \/\/ Local field\n+                    buf.append(\"<A HREF=\\\"\").append(className).append(\"_methods.html#field\")\n+                            .append(field_name).append(\"\\\" TARGET=Methods>\").append(field_name)\n+                            .append(\"<\/A>\\n\");\n+                } else {\n+                    buf.append(constantHtml.referenceConstant(class_index)).append(\".\").append(\n+                            field_name);\n+                }\n+                break;\n+            \/* Operands are references to classes in constant pool\n+             *\/\n+            case Const.CHECKCAST:\n+            case Const.INSTANCEOF:\n+            case Const.NEW:\n+                index = bytes.readShort();\n+                buf.append(constantHtml.referenceConstant(index));\n+                break;\n+            \/* Operands are references to methods in constant pool\n+             *\/\n+            case Const.INVOKESPECIAL:\n+            case Const.INVOKESTATIC:\n+            case Const.INVOKEVIRTUAL:\n+            case Const.INVOKEINTERFACE:\n+            case Const.INVOKEDYNAMIC:\n+                final int m_index = bytes.readShort();\n+                String str;\n+                if (opcode == Const.INVOKEINTERFACE) { \/\/ Special treatment needed\n+                    bytes.readUnsignedByte(); \/\/ Redundant\n+                    bytes.readUnsignedByte(); \/\/ Reserved\n@@ -267,32 +272,21 @@\n-                final ConstantInterfaceMethodref c = constantPool.getConstant(mIndex, Const.CONSTANT_InterfaceMethodref, ConstantInterfaceMethodref.class);\n-                classIndex = c.getClassIndex();\n-                index = c.getNameAndTypeIndex();\n-                name = Class2HTML.referenceClass(classIndex);\n-            } else if (opcode == Const.INVOKEDYNAMIC) { \/\/ Special treatment needed\n-                bytes.readUnsignedByte(); \/\/ Reserved\n-                bytes.readUnsignedByte(); \/\/ Reserved\n-                final ConstantInvokeDynamic c = constantPool.getConstant(mIndex, Const.CONSTANT_InvokeDynamic, ConstantInvokeDynamic.class);\n-                index = c.getNameAndTypeIndex();\n-                name = \"#\" + c.getBootstrapMethodAttrIndex();\n-            } else {\n-                \/\/ UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to\n-                \/\/ reference EITHER a Methodref OR an InterfaceMethodref.\n-                \/\/ Not sure if that affects this code or not. (markro)\n-                final ConstantMethodref c = constantPool.getConstant(mIndex, Const.CONSTANT_Methodref, ConstantMethodref.class);\n-                classIndex = c.getClassIndex();\n-                index = c.getNameAndTypeIndex();\n-                name = Class2HTML.referenceClass(classIndex);\n-            }\n-            str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(index, Const.CONSTANT_NameAndType)));\n-            \/\/ Get signature, i.e., types\n-            final ConstantNameAndType c2 = constantPool.getConstant(index, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n-            signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n-            final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n-            final String type = Utility.methodSignatureReturnType(signature, false);\n-            buf.append(name).append(\".<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(mIndex).append(\"\\\" TARGET=ConstantPool>\").append(str)\n-                .append(\"<\/A>\").append(\"(\");\n-            \/\/ List arguments\n-            for (int i = 0; i < args.length; i++) {\n-                buf.append(Class2HTML.referenceType(args[i]));\n-                if (i < args.length - 1) {\n-                    buf.append(\", \");\n+                    final ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constantPool\n+                            .getConstant(m_index, Const.CONSTANT_InterfaceMethodref);\n+                    class_index = c.getClassIndex();\n+                    index = c.getNameAndTypeIndex();\n+                    name = Class2HTML.referenceClass(class_index);\n+                } else if (opcode == Const.INVOKEDYNAMIC) { \/\/ Special treatment needed\n+                    bytes.readUnsignedByte(); \/\/ Reserved\n+                    bytes.readUnsignedByte(); \/\/ Reserved\n+                    final ConstantInvokeDynamic c = (ConstantInvokeDynamic) constantPool\n+                            .getConstant(m_index, Const.CONSTANT_InvokeDynamic);\n+                    index = c.getNameAndTypeIndex();\n+                    name = \"#\" + c.getBootstrapMethodAttrIndex();\n+                } else {\n+                    \/\/ UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to\n+                    \/\/ reference EITHER a Methodref OR an InterfaceMethodref.\n+                    \/\/ Not sure if that affects this code or not.  (markro)\n+                    final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(m_index,\n+                            Const.CONSTANT_Methodref);\n+                    class_index = c.getClassIndex();\n+                    index = c.getNameAndTypeIndex();\n+                name = Class2HTML.referenceClass(class_index);\n@@ -300,62 +294,84 @@\n-            }\n-            \/\/ Attach return type\n-            buf.append(\"):\").append(Class2HTML.referenceType(type));\n-            break;\n-        \/*\n-         * Operands are references to items in constant pool\n-         *\/\n-        case Const.LDC_W:\n-        case Const.LDC2_W:\n-            index = bytes.readShort();\n-            buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index).append(\"\\\" TARGET=\\\"ConstantPool\\\">\")\n-                .append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n-            break;\n-        case Const.LDC:\n-            index = bytes.readUnsignedByte();\n-            buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index).append(\"\\\" TARGET=\\\"ConstantPool\\\">\")\n-                .append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n-            break;\n-        \/*\n-         * Array of references.\n-         *\/\n-        case Const.ANEWARRAY:\n-            index = bytes.readShort();\n-            buf.append(constantHtml.referenceConstant(index));\n-            break;\n-        \/*\n-         * Multidimensional array of references.\n-         *\/\n-        case Const.MULTIANEWARRAY:\n-            index = bytes.readShort();\n-            final int dimensions = bytes.readByte();\n-            buf.append(constantHtml.referenceConstant(index)).append(\":\").append(dimensions).append(\"-dimensional\");\n-            break;\n-        \/*\n-         * Increment local variable.\n-         *\/\n-        case Const.IINC:\n-            if (wide) {\n-                vindex = bytes.readShort();\n-                constant = bytes.readShort();\n-                wide = false;\n-            } else {\n-                vindex = bytes.readUnsignedByte();\n-                constant = bytes.readByte();\n-            }\n-            buf.append(\"%\").append(vindex).append(\" \").append(constant);\n-            break;\n-        default:\n-            if (Const.getNoOfOperands(opcode) > 0) {\n-                for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n-                    switch (Const.getOperandType(opcode, i)) {\n-                    case Const.T_BYTE:\n-                        buf.append(bytes.readUnsignedByte());\n-                        break;\n-                    case Const.T_SHORT: \/\/ Either branch or index\n-                        buf.append(bytes.readShort());\n-                        break;\n-                    case Const.T_INT:\n-                        buf.append(bytes.readInt());\n-                        break;\n-                    default: \/\/ Never reached\n-                        throw new IllegalStateException(\"Unreachable default case reached! \" + Const.getOperandType(opcode, i));\n+                str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(\n+                        index, Const.CONSTANT_NameAndType)));\n+                \/\/ Get signature, i.e., types\n+                final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(index,\n+                        Const.CONSTANT_NameAndType);\n+                signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n+                final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n+                final String type = Utility.methodSignatureReturnType(signature, false);\n+                buf.append(name).append(\".<A HREF=\\\"\").append(className).append(\"_cp.html#cp\")\n+                        .append(m_index).append(\"\\\" TARGET=ConstantPool>\").append(str).append(\n+                                \"<\/A>\").append(\"(\");\n+                \/\/ List arguments\n+                for (int i = 0; i < args.length; i++) {\n+                    buf.append(Class2HTML.referenceType(args[i]));\n+                    if (i < args.length - 1) {\n+                        buf.append(\", \");\n+                    }\n+                }\n+                \/\/ Attach return type\n+                buf.append(\"):\").append(Class2HTML.referenceType(type));\n+                break;\n+            \/* Operands are references to items in constant pool\n+             *\/\n+            case Const.LDC_W:\n+            case Const.LDC2_W:\n+                index = bytes.readShort();\n+                buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index)\n+                        .append(\"\\\" TARGET=\\\"ConstantPool\\\">\").append(\n+                                Class2HTML.toHTML(constantPool.constantToString(index,\n+                                        constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n+                break;\n+            case Const.LDC:\n+                index = bytes.readUnsignedByte();\n+                buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index)\n+                        .append(\"\\\" TARGET=\\\"ConstantPool\\\">\").append(\n+                                Class2HTML.toHTML(constantPool.constantToString(index,\n+                                        constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n+                break;\n+            \/* Array of references.\n+             *\/\n+            case Const.ANEWARRAY:\n+                index = bytes.readShort();\n+                buf.append(constantHtml.referenceConstant(index));\n+                break;\n+            \/* Multidimensional array of references.\n+             *\/\n+            case Const.MULTIANEWARRAY:\n+                index = bytes.readShort();\n+                final int dimensions = bytes.readByte();\n+                buf.append(constantHtml.referenceConstant(index)).append(\":\").append(dimensions)\n+                        .append(\"-dimensional\");\n+                break;\n+            \/* Increment local variable.\n+             *\/\n+            case Const.IINC:\n+                if (wide) {\n+                    vindex = bytes.readShort();\n+                    constant = bytes.readShort();\n+                    wide = false;\n+                } else {\n+                    vindex = bytes.readUnsignedByte();\n+                    constant = bytes.readByte();\n+                }\n+                buf.append(\"%\").append(vindex).append(\" \").append(constant);\n+                break;\n+            default:\n+                if (Const.getNoOfOperands(opcode) > 0) {\n+                    for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n+                        switch (Const.getOperandType(opcode, i)) {\n+                            case Const.T_BYTE:\n+                                buf.append(bytes.readUnsignedByte());\n+                                break;\n+                            case Const.T_SHORT: \/\/ Either branch or index\n+                                buf.append(bytes.readShort());\n+                                break;\n+                            case Const.T_INT:\n+                                buf.append(bytes.readInt());\n+                                break;\n+                            default: \/\/ Never reached\n+                                throw new IllegalStateException(\n+                                        \"Unreachable default case reached! \" +\n+                                                Const.getOperandType(opcode, i));\n+                        }\n+                        buf.append(\"&nbsp;\");\n@@ -363,1 +379,0 @@\n-                    buf.append(\"&nbsp;\");\n@@ -365,1 +380,0 @@\n-            }\n@@ -371,0 +385,1 @@\n+\n@@ -372,2 +387,2 @@\n-     * Find all target addresses in code, so that they can be marked with &lt;A NAME = ...&gt;. Target addresses are kept in\n-     * an BitSet object.\n+     * Find all target addresses in code, so that they can be marked\n+     * with &lt;A NAME = ...&gt;. Target addresses are kept in an BitSet object.\n@@ -375,1 +390,1 @@\n-    private void findGotos(final ByteSequence bytes, final Code code) throws IOException {\n+    private void findGotos( final ByteSequence bytes, final Code code ) throws IOException {\n@@ -379,3 +394,2 @@\n-        \/*\n-         * First get Code attribute from method and the exceptions handled (try .. catch) in this method. We only need the line\n-         * number here.\n+        \/* First get Code attribute from method and the exceptions handled\n+         * (try .. catch) in this method. We only need the line number here.\n@@ -394,1 +408,3 @@\n-                    ((LocalVariableTable) attribute).forEach(var -> {\n+                    final LocalVariable[] vars = ((LocalVariableTable) attribute)\n+                            .getLocalVariableTable();\n+                    for (final LocalVariable var : vars) {\n@@ -396,0 +412,1 @@\n+                        final int end = start + var.getLength();\n@@ -397,2 +414,2 @@\n-                        gotoSet.set(start + var.getLength());\n-                    });\n+                        gotoSet.set(end);\n+                    }\n@@ -404,1 +421,1 @@\n-        while (bytes.available() > 0) {\n+        for (; bytes.available() > 0;) {\n@@ -406,1 +423,1 @@\n-            \/\/ System.out.println(getOpcodeName(opcode));\n+            \/\/System.out.println(getOpcodeName(opcode));\n@@ -408,21 +425,9 @@\n-            case Const.TABLESWITCH:\n-            case Const.LOOKUPSWITCH:\n-                \/\/ bytes.readByte(); \/\/ Skip already read byte\n-                final int remainder = bytes.getIndex() % 4;\n-                final int noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n-                int defaultOffset;\n-                int offset;\n-                for (int j = 0; j < noPadBytes; j++) {\n-                    bytes.readByte();\n-                }\n-                \/\/ Both cases have a field default_offset in common\n-                defaultOffset = bytes.readInt();\n-                if (opcode == Const.TABLESWITCH) {\n-                    final int low = bytes.readInt();\n-                    final int high = bytes.readInt();\n-                    offset = bytes.getIndex() - 12 - noPadBytes - 1;\n-                    defaultOffset += offset;\n-                    gotoSet.set(defaultOffset);\n-                    for (int j = 0; j < high - low + 1; j++) {\n-                        index = offset + bytes.readInt();\n-                        gotoSet.set(index);\n+                case Const.TABLESWITCH:\n+                case Const.LOOKUPSWITCH:\n+                    \/\/bytes.readByte(); \/\/ Skip already read byte\n+                    final int remainder = bytes.getIndex() % 4;\n+                    final int no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n+                    int default_offset;\n+                    int offset;\n+                    for (int j = 0; j < no_pad_bytes; j++) {\n+                        bytes.readByte();\n@@ -430,6 +435,18 @@\n-                } else { \/\/ LOOKUPSWITCH\n-                    final int npairs = bytes.readInt();\n-                    offset = bytes.getIndex() - 8 - noPadBytes - 1;\n-                    defaultOffset += offset;\n-                    gotoSet.set(defaultOffset);\n-                    for (int j = 0; j < npairs; j++) {\n+                    \/\/ Both cases have a field default_offset in common\n+                    default_offset = bytes.readInt();\n+                    if (opcode == Const.TABLESWITCH) {\n+                        final int low = bytes.readInt();\n+                        final int high = bytes.readInt();\n+                        offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n+                        default_offset += offset;\n+                        gotoSet.set(default_offset);\n+                        for (int j = 0; j < (high - low + 1); j++) {\n+                            index = offset + bytes.readInt();\n+                            gotoSet.set(index);\n+                        }\n+                    } else { \/\/ LOOKUPSWITCH\n+                        final int npairs = bytes.readInt();\n+                        offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n+                        default_offset += offset;\n+                        gotoSet.set(default_offset);\n+                        for (int j = 0; j < npairs; j++) {\n@@ -437,3 +454,4 @@\n-                        bytes.readInt();\n-                        index = offset + bytes.readInt();\n-                        gotoSet.set(index);\n+                            bytes.readInt();\n+                            index = offset + bytes.readInt();\n+                            gotoSet.set(index);\n+                        }\n@@ -441,33 +459,32 @@\n-                }\n-                break;\n-            case Const.GOTO:\n-            case Const.IFEQ:\n-            case Const.IFGE:\n-            case Const.IFGT:\n-            case Const.IFLE:\n-            case Const.IFLT:\n-            case Const.IFNE:\n-            case Const.IFNONNULL:\n-            case Const.IFNULL:\n-            case Const.IF_ACMPEQ:\n-            case Const.IF_ACMPNE:\n-            case Const.IF_ICMPEQ:\n-            case Const.IF_ICMPGE:\n-            case Const.IF_ICMPGT:\n-            case Const.IF_ICMPLE:\n-            case Const.IF_ICMPLT:\n-            case Const.IF_ICMPNE:\n-            case Const.JSR:\n-                \/\/ bytes.readByte(); \/\/ Skip already read byte\n-                index = bytes.getIndex() + bytes.readShort() - 1;\n-                gotoSet.set(index);\n-                break;\n-            case Const.GOTO_W:\n-            case Const.JSR_W:\n-                \/\/ bytes.readByte(); \/\/ Skip already read byte\n-                index = bytes.getIndex() + bytes.readInt() - 1;\n-                gotoSet.set(index);\n-                break;\n-            default:\n-                bytes.unreadByte();\n-                codeToHTML(bytes, 0); \/\/ Ignore output\n+                    break;\n+                case Const.GOTO:\n+                case Const.IFEQ:\n+                case Const.IFGE:\n+                case Const.IFGT:\n+                case Const.IFLE:\n+                case Const.IFLT:\n+                case Const.IFNE:\n+                case Const.IFNONNULL:\n+                case Const.IFNULL:\n+                case Const.IF_ACMPEQ:\n+                case Const.IF_ACMPNE:\n+                case Const.IF_ICMPEQ:\n+                case Const.IF_ICMPGE:\n+                case Const.IF_ICMPGT:\n+                case Const.IF_ICMPLE:\n+                case Const.IF_ICMPLT:\n+                case Const.IF_ICMPNE:\n+                case Const.JSR:\n+                    \/\/bytes.readByte(); \/\/ Skip already read byte\n+                    index = bytes.getIndex() + bytes.readShort() - 1;\n+                    gotoSet.set(index);\n+                    break;\n+                case Const.GOTO_W:\n+                case Const.JSR_W:\n+                    \/\/bytes.readByte(); \/\/ Skip already read byte\n+                    index = bytes.getIndex() + bytes.readInt() - 1;\n+                    gotoSet.set(index);\n+                    break;\n+                default:\n+                    bytes.unreadByte();\n+                    codeToHTML(bytes, 0); \/\/ Ignore output\n@@ -478,0 +495,1 @@\n+\n@@ -481,1 +499,1 @@\n-    private void writeMethod(final Method method, final int methodNumber) throws IOException {\n+    private void writeMethod( final Method method, final int method_number ) throws IOException {\n@@ -490,1 +508,1 @@\n-        final String htmlName = Class2HTML.toHTML(name);\n+        final String html_name = Class2HTML.toHTML(name);\n@@ -496,2 +514,4 @@\n-        printWriter.print(\"<P><B><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT>&nbsp;\" + \"<A NAME=method\" + methodNumber + \">\" + Class2HTML.referenceType(type)\n-            + \"<\/A>&nbsp<A HREF=\\\"\" + className + \"_methods.html#method\" + methodNumber + \"\\\" TARGET=Methods>\" + htmlName + \"<\/A>(\");\n+        file.print(\"<P><B><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT>&nbsp;\" + \"<A NAME=method\"\n+                + method_number + \">\" + Class2HTML.referenceType(type) + \"<\/A>&nbsp<A HREF=\\\"\"\n+                + className + \"_methods.html#method\" + method_number + \"\\\" TARGET=Methods>\"\n+                + html_name + \"<\/A>(\");\n@@ -499,1 +519,1 @@\n-            printWriter.print(Class2HTML.referenceType(args[i]));\n+            file.print(Class2HTML.referenceType(args[i]));\n@@ -501,1 +521,1 @@\n-                printWriter.print(\",&nbsp;\");\n+                file.print(\",&nbsp;\");\n@@ -504,1 +524,1 @@\n-        printWriter.println(\")<\/B><\/P>\");\n+        file.println(\")<\/B><\/P>\");\n@@ -508,1 +528,1 @@\n-            printWriter.print(\"<H4>Attributes<\/H4><UL>\\n\");\n+            file.print(\"<H4>Attributes<\/H4><UL>\\n\");\n@@ -512,2 +532,3 @@\n-                    printWriter.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#method\" + methodNumber + \"@\" + i + \"\\\" TARGET=Attributes>\"\n-                        + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n+                    file.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#method\"\n+                            + method_number + \"@\" + i + \"\\\" TARGET=Attributes>\"\n+                            + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n@@ -515,1 +536,1 @@\n-                    printWriter.print(\"<LI>\" + attributes[i] + \"<\/LI>\");\n+                    file.print(\"<LI>\" + attributes[i] + \"<\/LI>\");\n@@ -521,1 +542,1 @@\n-                    printWriter.print(\"<UL>\");\n+                    file.print(\"<UL>\");\n@@ -524,2 +545,3 @@\n-                        printWriter.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#\" + \"method\" + methodNumber + \"@\" + i + \"@\" + j\n-                            + \"\\\" TARGET=Attributes>\" + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n+                        file.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#\" + \"method\"\n+                                + method_number + \"@\" + i + \"@\" + j + \"\\\" TARGET=Attributes>\"\n+                                + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n@@ -527,1 +549,1 @@\n-                    printWriter.print(\"<\/UL>\");\n+                    file.print(\"<\/UL>\");\n@@ -530,1 +552,1 @@\n-            printWriter.println(\"<\/UL>\");\n+            file.println(\"<\/UL>\");\n@@ -533,1 +555,1 @@\n-            \/\/ System.out.println(name + \"\\n\" + Utility.codeToString(code, constantPool, 0, -1));\n+            \/\/System.out.println(name + \"\\n\" + Utility.codeToString(code, constantPool, 0, -1));\n@@ -539,2 +561,3 @@\n-                printWriter.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Byte<BR>offset<\/TH>\" + \"<TH ALIGN=LEFT>Instruction<\/TH><TH ALIGN=LEFT>Argument<\/TH>\");\n-                while (stream.available() > 0) {\n+                file.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Byte<BR>offset<\/TH>\"\n+                        + \"<TH ALIGN=LEFT>Instruction<\/TH><TH ALIGN=LEFT>Argument<\/TH>\");\n+                for (; stream.available() > 0;) {\n@@ -542,1 +565,1 @@\n-                    final String str = codeToHTML(stream, methodNumber);\n+                    final String str = codeToHTML(stream, method_number);\n@@ -545,2 +568,2 @@\n-                     * Set an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every line is very\n-                     * inefficient!\n+                     * Set an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every\n+                     * line is very inefficient!\n@@ -549,1 +572,1 @@\n-                        anchor = \"<A NAME=code\" + methodNumber + \"@\" + offset + \"><\/A>\";\n+                        anchor = \"<A NAME=code\" + method_number + \"@\" + offset + \"><\/A>\";\n@@ -553,1 +576,1 @@\n-                        anchor2 = \"<A NAME=code\" + methodNumber + \"@\" + code.length + \">\" + offset + \"<\/A>\";\n+                        anchor2 = \"<A NAME=code\" + method_number + \"@\" + code.length + \">\" + offset + \"<\/A>\";\n@@ -557,1 +580,1 @@\n-                    printWriter.println(\"<TR VALIGN=TOP><TD>\" + anchor2 + \"<\/TD><TD>\" + anchor + str + \"<\/TR>\");\n+                    file.println(\"<TR VALIGN=TOP><TD>\" + anchor2 + \"<\/TD><TD>\" + anchor + str + \"<\/TR>\");\n@@ -561,2 +584,2 @@\n-            printWriter.println(\"<TR><TD> <\/A><\/TD><\/TR>\");\n-            printWriter.println(\"<\/TABLE>\");\n+            file.println(\"<TR><TD> <\/A><\/TD><\/TR>\");\n+            file.println(\"<\/TABLE>\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/CodeHTML.java","additions":406,"deletions":383,"binary":false,"changes":789,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n-import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n@@ -26,2 +27,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.Charset;\n@@ -43,0 +42,2 @@\n+ *\n+ *\n@@ -49,1 +50,1 @@\n-    private final PrintWriter printWriter; \/\/ file to write to\n+    private final PrintWriter file; \/\/ file to write to\n@@ -54,5 +55,6 @@\n-    ConstantHTML(final String dir, final String className, final String classPackage, final Method[] methods, final ConstantPool constantPool,\n-        final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n-        this.className = className;\n-        this.classPackage = classPackage;\n-        this.constantPool = constantPool;\n+\n+    ConstantHTML(final String dir, final String class_name, final String class_package, final Method[] methods,\n+            final ConstantPool constant_pool) throws IOException {\n+        this.className = class_name;\n+        this.classPackage = class_package;\n+        this.constantPool = constant_pool;\n@@ -60,20 +62,11 @@\n-        this.constants = constantPool.getConstantPool();\n-        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_cp.html\", charset.name())) {\n-            printWriter = newPrintWriter;\n-            constantRef = new String[constants.length];\n-            constantRef[0] = \"&lt;unknown&gt;\";\n-            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n-            printWriter.print(charset.name());\n-            printWriter.println(\"\\\"><\/head>\");\n-            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n-            \/\/ Loop through constants, constants[0] is reserved\n-            for (int i = 1; i < constants.length; i++) {\n-                if (i % 2 == 0) {\n-                    printWriter.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n-                } else {\n-                    printWriter.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n-                }\n-                if (constants[i] != null) {\n-                    writeConstant(i);\n-                }\n-                printWriter.print(\"<\/TD><\/TR>\\n\");\n+        constants = constant_pool.getConstantPool();\n+        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_cp.html\"));\n+        constantRef = new String[constants.length];\n+        constantRef[0] = \"&lt;unknown&gt;\";\n+        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+        \/\/ Loop through constants, constants[0] is reserved\n+        for (int i = 1; i < constants.length; i++) {\n+            if (i % 2 == 0) {\n+                file.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n+            } else {\n+                file.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n@@ -81,9 +74,2 @@\n-            printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n-        }\n-    }\n-\n-    private int getMethodNumber(final String str) {\n-        for (int i = 0; i < methods.length; i++) {\n-            final String cmp = methods[i].getName() + methods[i].getSignature();\n-            if (cmp.equals(str)) {\n-                return i;\n+            if (constants[i] != null) {\n+                writeConstant(i);\n@@ -91,0 +77,1 @@\n+            file.print(\"<\/TD><\/TR>\\n\");\n@@ -92,1 +79,2 @@\n-        return -1;\n+        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+        file.close();\n@@ -95,1 +83,2 @@\n-    String referenceConstant(final int index) {\n+\n+    String referenceConstant( final int index ) {\n@@ -99,1 +88,2 @@\n-    private void writeConstant(final int index) {\n+\n+    private void writeConstant( final int index ) {\n@@ -101,2 +91,2 @@\n-        int classIndex;\n-        int nameIndex;\n+        int class_index;\n+        int name_index;\n@@ -105,3 +95,3 @@\n-        printWriter.println(\"<H4> <A NAME=cp\" + index + \">\" + index + \"<\/A> \" + Const.getConstantName(tag) + \"<\/H4>\");\n-        \/*\n-         * For every constant type get the needed parameters and print them appropriately\n+        file.println(\"<H4> <A NAME=cp\" + index + \">\" + index + \"<\/A> \" + Const.getConstantName(tag)\n+                + \"<\/H4>\");\n+        \/* For every constant type get the needed parameters and print them appropiately\n@@ -110,32 +100,13 @@\n-        case Const.CONSTANT_InterfaceMethodref:\n-        case Const.CONSTANT_Methodref:\n-            \/\/ Get class_index and name_and_type_index, depending on type\n-            if (tag == Const.CONSTANT_Methodref) {\n-                final ConstantMethodref c = constantPool.getConstant(index, Const.CONSTANT_Methodref, ConstantMethodref.class);\n-                classIndex = c.getClassIndex();\n-                nameIndex = c.getNameAndTypeIndex();\n-            } else {\n-                final ConstantInterfaceMethodref c1 = constantPool.getConstant(index, Const.CONSTANT_InterfaceMethodref, ConstantInterfaceMethodref.class);\n-                classIndex = c1.getClassIndex();\n-                nameIndex = c1.getNameAndTypeIndex();\n-            }\n-            \/\/ Get method name and its class\n-            final String methodName = constantPool.constantToString(nameIndex, Const.CONSTANT_NameAndType);\n-            final String htmlMethodName = Class2HTML.toHTML(methodName);\n-            \/\/ Partially compacted class name, i.e., \/ -> .\n-            final String methodClass = constantPool.constantToString(classIndex, Const.CONSTANT_Class);\n-            String shortMethodClass = Utility.compactClassName(methodClass); \/\/ I.e., remove java.lang.\n-            shortMethodClass = Utility.compactClassName(shortMethodClass, classPackage + \".\", true); \/\/ Remove class package prefix\n-            \/\/ Get method signature\n-            final ConstantNameAndType c2 = constantPool.getConstant(nameIndex, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n-            final String signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n-            \/\/ Get array of strings containing the argument types\n-            final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n-            \/\/ Get return type string\n-            final String type = Utility.methodSignatureReturnType(signature, false);\n-            final String retType = Class2HTML.referenceType(type);\n-            final StringBuilder buf = new StringBuilder(\"(\");\n-            for (int i = 0; i < args.length; i++) {\n-                buf.append(Class2HTML.referenceType(args[i]));\n-                if (i < args.length - 1) {\n-                    buf.append(\",&nbsp;\");\n+            case Const.CONSTANT_InterfaceMethodref:\n+            case Const.CONSTANT_Methodref:\n+                \/\/ Get class_index and name_and_type_index, depending on type\n+                if (tag == Const.CONSTANT_Methodref) {\n+                    final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(index,\n+                            Const.CONSTANT_Methodref);\n+                    class_index = c.getClassIndex();\n+                    name_index = c.getNameAndTypeIndex();\n+                } else {\n+                    final ConstantInterfaceMethodref c1 = (ConstantInterfaceMethodref) constantPool\n+                            .getConstant(index, Const.CONSTANT_InterfaceMethodref);\n+                    class_index = c1.getClassIndex();\n+                    name_index = c1.getNameAndTypeIndex();\n@@ -143,58 +114,109 @@\n-            }\n-            buf.append(\")\");\n-            final String argTypes = buf.toString();\n-            if (methodClass.equals(className)) {\n-                ref = \"<A HREF=\\\"\" + className + \"_code.html#method\" + getMethodNumber(methodName + signature) + \"\\\" TARGET=Code>\" + htmlMethodName + \"<\/A>\";\n-            } else {\n-                ref = \"<A HREF=\\\"\" + methodClass + \".html\" + \"\\\" TARGET=_top>\" + shortMethodClass + \"<\/A>.\" + htmlMethodName;\n-            }\n-            constantRef[index] = retType + \"&nbsp;<A HREF=\\\"\" + className + \"_cp.html#cp\" + classIndex + \"\\\" TARGET=Constants>\" + shortMethodClass\n-                + \"<\/A>.<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + htmlMethodName + \"<\/A>&nbsp;\" + argTypes;\n-            printWriter.println(\"<P><TT>\" + retType + \"&nbsp;\" + ref + argTypes + \"&nbsp;<\/TT>\\n<UL>\" + \"<LI><A HREF=\\\"#cp\" + classIndex + \"\\\">Class index(\"\n-                + classIndex + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">NameAndType index(\" + nameIndex + \")<\/A><\/UL>\");\n-            break;\n-        case Const.CONSTANT_Fieldref:\n-            \/\/ Get class_index and name_and_type_index\n-            final ConstantFieldref c3 = constantPool.getConstant(index, Const.CONSTANT_Fieldref, ConstantFieldref.class);\n-            classIndex = c3.getClassIndex();\n-            nameIndex = c3.getNameAndTypeIndex();\n-            \/\/ Get method name and its class (compacted)\n-            final String fieldClass = constantPool.constantToString(classIndex, Const.CONSTANT_Class);\n-            String shortFieldClass = Utility.compactClassName(fieldClass); \/\/ I.e., remove java.lang.\n-            shortFieldClass = Utility.compactClassName(shortFieldClass, classPackage + \".\", true); \/\/ Remove class package prefix\n-            final String fieldName = constantPool.constantToString(nameIndex, Const.CONSTANT_NameAndType);\n-            if (fieldClass.equals(className)) {\n-                ref = \"<A HREF=\\\"\" + fieldClass + \"_methods.html#field\" + fieldName + \"\\\" TARGET=Methods>\" + fieldName + \"<\/A>\";\n-            } else {\n-                ref = \"<A HREF=\\\"\" + fieldClass + \".html\\\" TARGET=_top>\" + shortFieldClass + \"<\/A>.\" + fieldName + \"\\n\";\n-            }\n-            constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + classIndex + \"\\\" TARGET=Constants>\" + shortFieldClass + \"<\/A>.<A HREF=\\\"\"\n-                + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + fieldName + \"<\/A>\";\n-            printWriter.println(\"<P><TT>\" + ref + \"<\/TT><BR>\\n\" + \"<UL>\" + \"<LI><A HREF=\\\"#cp\" + classIndex + \"\\\">Class(\" + classIndex + \")<\/A><BR>\\n\"\n-                + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">NameAndType(\" + nameIndex + \")<\/A><\/UL>\");\n-            break;\n-        case Const.CONSTANT_Class:\n-            final ConstantClass c4 = constantPool.getConstant(index, Const.CONSTANT_Class, ConstantClass.class);\n-            nameIndex = c4.getNameIndex();\n-            final String className2 = constantPool.constantToString(index, tag); \/\/ \/ -> .\n-            String shortClassName = Utility.compactClassName(className2); \/\/ I.e., remove java.lang.\n-            shortClassName = Utility.compactClassName(shortClassName, classPackage + \".\", true); \/\/ Remove class package prefix\n-            ref = \"<A HREF=\\\"\" + className2 + \".html\\\" TARGET=_top>\" + shortClassName + \"<\/A>\";\n-            constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + shortClassName + \"<\/A>\";\n-            printWriter.println(\"<P><TT>\" + ref + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">Name index(\" + nameIndex + \")<\/A><\/UL>\\n\");\n-            break;\n-        case Const.CONSTANT_String:\n-            final ConstantString c5 = constantPool.getConstant(index, Const.CONSTANT_String, ConstantString.class);\n-            nameIndex = c5.getStringIndex();\n-            final String str = Class2HTML.toHTML(constantPool.constantToString(index, tag));\n-            printWriter.println(\"<P><TT>\" + str + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">Name index(\" + nameIndex + \")<\/A><\/UL>\\n\");\n-            break;\n-        case Const.CONSTANT_NameAndType:\n-            final ConstantNameAndType c6 = constantPool.getConstant(index, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n-            nameIndex = c6.getNameIndex();\n-            final int signatureIndex = c6.getSignatureIndex();\n-            printWriter.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex\n-                + \"\\\">Name index(\" + nameIndex + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + signatureIndex + \"\\\">Signature index(\" + signatureIndex + \")<\/A><\/UL>\\n\");\n-            break;\n-        default:\n-            printWriter.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT>\\n\");\n+                \/\/ Get method name and its class\n+                final String method_name = constantPool.constantToString(name_index,\n+                        Const.CONSTANT_NameAndType);\n+                final String html_method_name = Class2HTML.toHTML(method_name);\n+                \/\/ Partially compacted class name, i.e., \/ -> .\n+                final String method_class = constantPool.constantToString(class_index, Const.CONSTANT_Class);\n+                String short_method_class = Utility.compactClassName(method_class); \/\/ I.e., remove java.lang.\n+                short_method_class = Utility.compactClassName(short_method_class, classPackage\n+                        + \".\", true); \/\/ Remove class package prefix\n+                \/\/ Get method signature\n+                final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(\n+                        name_index, Const.CONSTANT_NameAndType);\n+                final String signature = constantPool.constantToString(c2.getSignatureIndex(),\n+                        Const.CONSTANT_Utf8);\n+                \/\/ Get array of strings containing the argument types\n+                final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n+                \/\/ Get return type string\n+                final String type = Utility.methodSignatureReturnType(signature, false);\n+                final String ret_type = Class2HTML.referenceType(type);\n+                final StringBuilder buf = new StringBuilder(\"(\");\n+                for (int i = 0; i < args.length; i++) {\n+                    buf.append(Class2HTML.referenceType(args[i]));\n+                    if (i < args.length - 1) {\n+                        buf.append(\",&nbsp;\");\n+                    }\n+                }\n+                buf.append(\")\");\n+                final String arg_types = buf.toString();\n+                if (method_class.equals(className)) {\n+                    ref = \"<A HREF=\\\"\" + className + \"_code.html#method\"\n+                            + getMethodNumber(method_name + signature) + \"\\\" TARGET=Code>\"\n+                            + html_method_name + \"<\/A>\";\n+                } else {\n+                    ref = \"<A HREF=\\\"\" + method_class + \".html\" + \"\\\" TARGET=_top>\"\n+                            + short_method_class + \"<\/A>.\" + html_method_name;\n+                }\n+                constantRef[index] = ret_type + \"&nbsp;<A HREF=\\\"\" + className + \"_cp.html#cp\"\n+                        + class_index + \"\\\" TARGET=Constants>\" + short_method_class\n+                        + \"<\/A>.<A HREF=\\\"\" + className + \"_cp.html#cp\" + index\n+                        + \"\\\" TARGET=ConstantPool>\" + html_method_name + \"<\/A>&nbsp;\" + arg_types;\n+                file.println(\"<P><TT>\" + ret_type + \"&nbsp;\" + ref + arg_types\n+                        + \"&nbsp;<\/TT>\\n<UL>\" + \"<LI><A HREF=\\\"#cp\" + class_index\n+                        + \"\\\">Class index(\" + class_index + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\"\n+                        + name_index + \"\\\">NameAndType index(\" + name_index + \")<\/A><\/UL>\");\n+                break;\n+            case Const.CONSTANT_Fieldref:\n+                \/\/ Get class_index and name_and_type_index\n+                final ConstantFieldref c3 = (ConstantFieldref) constantPool.getConstant(index,\n+                        Const.CONSTANT_Fieldref);\n+                class_index = c3.getClassIndex();\n+                name_index = c3.getNameAndTypeIndex();\n+                \/\/ Get method name and its class (compacted)\n+                final String field_class = constantPool.constantToString(class_index, Const.CONSTANT_Class);\n+                String short_field_class = Utility.compactClassName(field_class); \/\/ I.e., remove java.lang.\n+                short_field_class = Utility.compactClassName(short_field_class,\n+                        classPackage + \".\", true); \/\/ Remove class package prefix\n+                final String field_name = constantPool\n+                        .constantToString(name_index, Const.CONSTANT_NameAndType);\n+                if (field_class.equals(className)) {\n+                    ref = \"<A HREF=\\\"\" + field_class + \"_methods.html#field\" + field_name\n+                            + \"\\\" TARGET=Methods>\" + field_name + \"<\/A>\";\n+                } else {\n+                    ref = \"<A HREF=\\\"\" + field_class + \".html\\\" TARGET=_top>\" + short_field_class\n+                            + \"<\/A>.\" + field_name + \"\\n\";\n+                }\n+                constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + class_index\n+                        + \"\\\" TARGET=Constants>\" + short_field_class + \"<\/A>.<A HREF=\\\"\"\n+                        + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\"\n+                        + field_name + \"<\/A>\";\n+                file.println(\"<P><TT>\" + ref + \"<\/TT><BR>\\n\" + \"<UL>\" + \"<LI><A HREF=\\\"#cp\"\n+                        + class_index + \"\\\">Class(\" + class_index + \")<\/A><BR>\\n\"\n+                        + \"<LI><A HREF=\\\"#cp\" + name_index + \"\\\">NameAndType(\" + name_index\n+                        + \")<\/A><\/UL>\");\n+                break;\n+            case Const.CONSTANT_Class:\n+                final ConstantClass c4 = (ConstantClass) constantPool.getConstant(index, Const.CONSTANT_Class);\n+                name_index = c4.getNameIndex();\n+                final String class_name2 = constantPool.constantToString(index, tag); \/\/ \/ -> .\n+                String short_class_name = Utility.compactClassName(class_name2); \/\/ I.e., remove java.lang.\n+                short_class_name = Utility.compactClassName(short_class_name, classPackage + \".\",\n+                        true); \/\/ Remove class package prefix\n+                ref = \"<A HREF=\\\"\" + class_name2 + \".html\\\" TARGET=_top>\" + short_class_name\n+                        + \"<\/A>\";\n+                constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index\n+                        + \"\\\" TARGET=ConstantPool>\" + short_class_name + \"<\/A>\";\n+                file.println(\"<P><TT>\" + ref + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index\n+                        + \"\\\">Name index(\" + name_index + \")<\/A><\/UL>\\n\");\n+                break;\n+            case Const.CONSTANT_String:\n+                final ConstantString c5 = (ConstantString) constantPool.getConstant(index,\n+                        Const.CONSTANT_String);\n+                name_index = c5.getStringIndex();\n+                final String str = Class2HTML.toHTML(constantPool.constantToString(index, tag));\n+                file.println(\"<P><TT>\" + str + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index\n+                        + \"\\\">Name index(\" + name_index + \")<\/A><\/UL>\\n\");\n+                break;\n+            case Const.CONSTANT_NameAndType:\n+                final ConstantNameAndType c6 = (ConstantNameAndType) constantPool.getConstant(index,\n+                        Const.CONSTANT_NameAndType);\n+                name_index = c6.getNameIndex();\n+                final int signature_index = c6.getSignatureIndex();\n+                file.println(\"<P><TT>\"\n+                        + Class2HTML.toHTML(constantPool.constantToString(index, tag))\n+                        + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index + \"\\\">Name index(\"\n+                        + name_index + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + signature_index\n+                        + \"\\\">Signature index(\" + signature_index + \")<\/A><\/UL>\\n\");\n+                break;\n+            default:\n+                file.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT>\\n\");\n@@ -203,0 +225,11 @@\n+\n+\n+    private int getMethodNumber( final String str ) {\n+        for (int i = 0; i < methods.length; i++) {\n+            final String cmp = methods[i].getName() + methods[i].getSignature();\n+            if (cmp.equals(str)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ConstantHTML.java","additions":169,"deletions":136,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -23,0 +23,4 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.generic.ClassGenException;\n+import com.sun.org.apache.bcel.internal.generic.InstructionHandle;\n+import com.sun.org.apache.bcel.internal.generic.InstructionList;\n@@ -24,1 +28,0 @@\n-import java.util.Arrays;\n@@ -33,5 +36,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.generic.ClassGenException;\n-import com.sun.org.apache.bcel.internal.generic.InstructionHandle;\n-import com.sun.org.apache.bcel.internal.generic.InstructionList;\n-\n@@ -39,3 +37,5 @@\n- * InstructionFinder is a tool to search for given instructions patterns, i.e., match sequences of instructions in an\n- * instruction list via regular expressions. This can be used, e.g., in order to implement a peep hole optimizer that\n- * looks for code patterns and replaces them with faster equivalents.\n+ * InstructionFinder is a tool to search for given instructions patterns, i.e.,\n+ * match sequences of instructions in an instruction list via regular\n+ * expressions. This can be used, e.g., in order to implement a peep hole\n+ * optimizer that looks for code patterns and replaces them with faster\n+ * equivalents.\n@@ -44,1 +44,2 @@\n- * This class internally uses the java.util.regex package to search for regular expressions.\n+ * This class internally uses the java.util.regex\n+ * package to search for regular expressions.\n@@ -70,14 +71,0 @@\n-    \/**\n-     * Code patterns found may be checked using an additional user-defined constraint object whether they really match the\n-     * needed criterion. I.e., check constraints that can not expressed with regular expressions.\n-     *\n-     *\/\n-    public interface CodeConstraint {\n-\n-        \/**\n-         * @param match array of instructions matching the requested pattern\n-         * @return true if the matched area is really useful\n-         *\/\n-        boolean checkCode(InstructionHandle[] match);\n-    }\n-\n@@ -87,153 +74,0 @@\n-\n-    \/\/ Initialize pattern map\n-    static {\n-        map.put(\"arithmeticinstruction\",\n-            \"(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)\");\n-        map.put(\"invokeinstruction\", \"(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)\");\n-        map.put(\"arrayinstruction\",\n-            \"(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)\");\n-        map.put(\"gotoinstruction\", \"(goto|goto_w)\");\n-        map.put(\"conversioninstruction\", \"(d2l|l2d|i2s|d2i|l2i|i2b|l2f|d2f|f2i|i2d|i2l|f2d|i2c|f2l|i2f)\");\n-        map.put(\"localvariableinstruction\", \"(fstore|iinc|lload|dstore|dload|iload|aload|astore|istore|fload|lstore)\");\n-        map.put(\"loadinstruction\", \"(fload|dload|lload|iload|aload)\");\n-        map.put(\"fieldinstruction\", \"(getfield|putstatic|getstatic|putfield)\");\n-        map.put(\"cpinstruction\",\n-            \"(ldc2_w|invokeinterface|invokedynamic|multianewarray|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|ldc_w|invokestatic|invokevirtual|putfield|ldc|new|anewarray)\");\n-        map.put(\"stackinstruction\", \"(dup2|swap|dup2_x2|pop|pop2|dup|dup2_x1|dup_x2|dup_x1)\");\n-        map.put(\"branchinstruction\",\n-            \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n-        map.put(\"returninstruction\", \"(lreturn|ireturn|freturn|dreturn|areturn|return)\");\n-        map.put(\"storeinstruction\", \"(istore|fstore|dstore|astore|lstore)\");\n-        map.put(\"select\", \"(tableswitch|lookupswitch)\");\n-        map.put(\"ifinstruction\",\n-            \"(ifeq|ifgt|if_icmpne|if_icmpeq|ifge|ifnull|ifne|if_icmple|if_icmpge|if_acmpeq|if_icmplt|if_acmpne|ifnonnull|iflt|if_icmpgt|ifle)\");\n-        map.put(\"jsrinstruction\", \"(jsr|jsr_w)\");\n-        map.put(\"variablelengthinstruction\", \"(tableswitch|jsr|goto|lookupswitch)\");\n-        map.put(\"unconditionalbranch\", \"(goto|jsr|jsr_w|athrow|goto_w)\");\n-        map.put(\"constantpushinstruction\", \"(dconst|bipush|sipush|fconst|iconst|lconst)\");\n-        map.put(\"typedinstruction\",\n-            \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dastore|ret|f2d|f2i|drem|iinc|i2c|checkcast|frem|lreturn|astore|lushr|daload|dneg|fastore|istore|lshl|ldiv|lstore|areturn|ishr|ldc_w|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|faload|sipush|iushr|caload|instanceof|invokespecial|putfield|fmul|ireturn|laload|d2f|lneg|ixor|i2l|fdiv|lastore|multianewarray|i2b|getstatic|i2d|putstatic|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|freturn|ldc|aconst_null|castore|lmul|ldc2_w|dadd|iconst|f2l|ddiv|dstore|land|jsr|anewarray|dmul|bipush|dsub|sastore|d2i|i2s|lshr|iadd|l2i|lload|bastore|fstore|fneg|iload|fadd|baload|fconst|ior|ineg|dreturn|l2f|lconst|getfield|invokevirtual|invokestatic|iastore)\");\n-        map.put(\"popinstruction\", \"(fstore|dstore|pop|pop2|astore|putstatic|istore|lstore)\");\n-        map.put(\"allocationinstruction\", \"(multianewarray|new|anewarray|newarray)\");\n-        map.put(\"indexedinstruction\",\n-            \"(lload|lstore|fload|ldc2_w|invokeinterface|invokedynamic|multianewarray|astore|dload|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|dstore|istore|iinc|ldc_w|ret|fstore|invokestatic|iload|putfield|invokevirtual|ldc|new|aload|anewarray)\");\n-        map.put(\"pushinstruction\", \"(dup|lload|dup2|bipush|fload|ldc2_w|sipush|lconst|fconst|dload|getstatic|ldc_w|aconst_null|dconst|iload|ldc|iconst|aload)\");\n-        map.put(\"stackproducer\",\n-            \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dup|f2d|f2i|drem|i2c|checkcast|frem|lushr|daload|dneg|lshl|ldiv|ishr|ldc_w|invokeinterface|invokedynamic|lxor|ishl|l2d|i2f|faload|sipush|iushr|caload|instanceof|invokespecial|fmul|laload|d2f|lneg|ixor|i2l|fdiv|getstatic|i2b|swap|i2d|dup2|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|ldc|arraylength|aconst_null|tableswitch|lmul|ldc2_w|iconst|dadd|f2l|ddiv|land|jsr|anewarray|dmul|bipush|dsub|d2i|newarray|i2s|lshr|iadd|lload|l2i|fneg|iload|fadd|baload|fconst|lookupswitch|ior|ineg|lconst|l2f|getfield|invokevirtual|invokestatic)\");\n-        map.put(\"stackconsumer\",\n-            \"(imul|lsub|lor|iflt|fcmpg|if_icmpgt|iand|ifeq|if_icmplt|lrem|ifnonnull|idiv|d2l|isub|dcmpg|dastore|if_icmpeq|f2d|f2i|drem|i2c|checkcast|frem|lreturn|astore|lushr|pop2|monitorexit|dneg|fastore|istore|lshl|ldiv|lstore|areturn|if_icmpge|ishr|monitorenter|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|iushr|instanceof|invokespecial|fmul|ireturn|d2f|lneg|ixor|pop|i2l|ifnull|fdiv|lastore|i2b|if_acmpeq|ifge|swap|i2d|putstatic|fcmpl|ladd|irem|dcmpl|fsub|freturn|ifgt|castore|lmul|dadd|f2l|ddiv|dstore|land|if_icmpne|if_acmpne|dmul|dsub|sastore|ifle|d2i|i2s|lshr|iadd|l2i|bastore|fstore|fneg|fadd|ior|ineg|ifne|dreturn|l2f|if_icmple|getfield|invokevirtual|invokestatic|iastore)\");\n-        map.put(\"exceptionthrower\",\n-            \"(irem|lrem|laload|putstatic|baload|dastore|areturn|getstatic|ldiv|anewarray|iastore|castore|idiv|saload|lastore|fastore|putfield|lreturn|caload|getfield|return|aastore|freturn|newarray|instanceof|multianewarray|athrow|faload|iaload|aaload|dreturn|monitorenter|checkcast|bastore|arraylength|new|invokevirtual|sastore|ldc_w|ireturn|invokespecial|monitorexit|invokeinterface|invokedynamic|ldc|invokestatic|daload)\");\n-        map.put(\"loadclass\",\n-            \"(multianewarray|invokeinterface|invokedynamic|instanceof|invokespecial|putfield|checkcast|putstatic|invokevirtual|new|getstatic|invokestatic|getfield|anewarray)\");\n-        map.put(\"instructiontargeter\",\n-            \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n-        \/\/ Some aliases\n-        map.put(\"if_icmp\", \"(if_icmpne|if_icmpeq|if_icmple|if_icmpge|if_icmplt|if_icmpgt)\");\n-        map.put(\"if_acmp\", \"(if_acmpeq|if_acmpne)\");\n-        map.put(\"if\", \"(ifeq|ifne|iflt|ifge|ifgt|ifle)\");\n-        \/\/ Precompile some aliases first\n-        map.put(\"iconst\", precompile(Const.ICONST_0, Const.ICONST_5, Const.ICONST_M1));\n-        map.put(\"lconst\", new String(new char[] {'(', makeChar(Const.LCONST_0), '|', makeChar(Const.LCONST_1), ')'}));\n-        map.put(\"dconst\", new String(new char[] {'(', makeChar(Const.DCONST_0), '|', makeChar(Const.DCONST_1), ')'}));\n-        map.put(\"fconst\", new String(new char[] {'(', makeChar(Const.FCONST_0), '|', makeChar(Const.FCONST_1), '|', makeChar(Const.FCONST_2), ')'}));\n-        map.put(\"lload\", precompile(Const.LLOAD_0, Const.LLOAD_3, Const.LLOAD));\n-        map.put(\"iload\", precompile(Const.ILOAD_0, Const.ILOAD_3, Const.ILOAD));\n-        map.put(\"dload\", precompile(Const.DLOAD_0, Const.DLOAD_3, Const.DLOAD));\n-        map.put(\"fload\", precompile(Const.FLOAD_0, Const.FLOAD_3, Const.FLOAD));\n-        map.put(\"aload\", precompile(Const.ALOAD_0, Const.ALOAD_3, Const.ALOAD));\n-        map.put(\"lstore\", precompile(Const.LSTORE_0, Const.LSTORE_3, Const.LSTORE));\n-        map.put(\"istore\", precompile(Const.ISTORE_0, Const.ISTORE_3, Const.ISTORE));\n-        map.put(\"dstore\", precompile(Const.DSTORE_0, Const.DSTORE_3, Const.DSTORE));\n-        map.put(\"fstore\", precompile(Const.FSTORE_0, Const.FSTORE_3, Const.FSTORE));\n-        map.put(\"astore\", precompile(Const.ASTORE_0, Const.ASTORE_3, Const.ASTORE));\n-        \/\/ Compile strings\n-        map.forEach((key, value) -> {\n-            final char ch = value.charAt(1); \/\/ Omit already precompiled patterns\n-            if (ch < OFFSET) {\n-                map.put(key, compilePattern(value)); \/\/ precompile all patterns\n-            }\n-        });\n-        \/\/ Add instruction alias to match anything\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        for (short i = 0; i < NO_OPCODES; i++) {\n-            if (Const.getNoOfOperands(i) != Const.UNDEFINED) { \/\/ Not an invalid opcode\n-                buf.append(makeChar(i));\n-                if (i < NO_OPCODES - 1) {\n-                    buf.append('|');\n-                }\n-            }\n-        }\n-        buf.append(')');\n-        map.put(\"instruction\", buf.toString());\n-    }\n-\n-    \/**\n-     * Replace symbolic names of instructions with the appropriate character and remove all white space from string. Meta\n-     * characters such as +, * are ignored.\n-     *\n-     * @param pattern The pattern to compile\n-     * @return translated regular expression string\n-     *\/\n-    private static String compilePattern(final String pattern) {\n-        \/\/ Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues\n-        final String lower = pattern.toLowerCase(Locale.ENGLISH);\n-        final StringBuilder buf = new StringBuilder();\n-        final int size = pattern.length();\n-        for (int i = 0; i < size; i++) {\n-            char ch = lower.charAt(i);\n-            if (Character.isLetterOrDigit(ch)) {\n-                final StringBuilder name = new StringBuilder();\n-                while ((Character.isLetterOrDigit(ch) || ch == '_') && i < size) {\n-                    name.append(ch);\n-                    if (++i >= size) {\n-                        break;\n-                    }\n-                    ch = lower.charAt(i);\n-                }\n-                i--;\n-                buf.append(mapName(name.toString()));\n-            } else if (!Character.isWhitespace(ch)) {\n-                buf.append(ch);\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Convert opcode number to char.\n-     *\/\n-    private static char makeChar(final short opcode) {\n-        return (char) (opcode + OFFSET);\n-    }\n-\n-    \/**\n-     * Map symbolic instruction names like \"getfield\" to a single character.\n-     *\n-     * @param pattern instruction pattern in lower case\n-     * @return encoded string for a pattern such as \"BranchInstruction\".\n-     *\/\n-    private static String mapName(final String pattern) {\n-        final String result = map.get(pattern);\n-        if (result != null) {\n-            return result;\n-        }\n-        for (short i = 0; i < NO_OPCODES; i++) {\n-            if (pattern.equals(Const.getOpcodeName(i))) {\n-                return String.valueOf(makeChar(i));\n-            }\n-        }\n-        throw new IllegalArgumentException(\"Instruction unknown: \" + pattern);\n-    }\n-\n-    private static String precompile(final short from, final short to, final short extra) {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        for (short i = from; i <= to; i++) {\n-            buf.append(makeChar(i));\n-            buf.append('|');\n-        }\n-        buf.append(makeChar(extra));\n-        buf.append(\")\");\n-        return buf.toString();\n-    }\n-\n@@ -241,1 +75,0 @@\n-\n@@ -243,1 +76,0 @@\n-\n@@ -246,0 +78,1 @@\n+\n@@ -248,1 +81,2 @@\n-     * @param il instruction list to search for given patterns\n+     * @param il\n+     *          instruction list to search for given patterns\n@@ -255,13 +89,0 @@\n-    \/**\n-     * @return the inquired instruction list\n-     *\/\n-    public final InstructionList getInstructionList() {\n-        return il;\n-    }\n-\n-    \/**\n-     * @return the matched piece of code as an array of instruction (handles)\n-     *\/\n-    private InstructionHandle[] getMatch(final int matchedFrom, final int matchLength) {\n-        return Arrays.copyOfRange(handles, matchedFrom, matchedFrom + matchLength);\n-    }\n@@ -270,1 +91,2 @@\n-     * Reread the instruction list, e.g., after you've altered the list upon a match.\n+     * Reread the instruction list, e.g., after you've altered the list upon a\n+     * match.\n@@ -283,0 +105,1 @@\n+\n@@ -284,1 +107,1 @@\n-     * Start search beginning from the start of the given instruction list.\n+     * Map symbolic instruction names like \"getfield\" to a single character.\n@@ -286,2 +109,3 @@\n-     * @param pattern the instruction pattern to search for, where case is ignored\n-     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n+     * @param pattern\n+     *          instruction pattern in lower case\n+     * @return encoded string for a pattern such as \"BranchInstruction\".\n@@ -289,2 +113,11 @@\n-    public final Iterator<InstructionHandle[]> search(final String pattern) {\n-        return search(pattern, il.getStart(), null);\n+    private static String mapName( final String pattern ) {\n+        final String result = map.get(pattern);\n+        if (result != null) {\n+            return result;\n+        }\n+        for (short i = 0; i < NO_OPCODES; i++) {\n+            if (pattern.equals(Const.getOpcodeName(i))) {\n+                return \"\" + makeChar(i);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Instruction unknown: \" + pattern);\n@@ -293,0 +126,1 @@\n+\n@@ -294,1 +128,3 @@\n-     * Start search beginning from the start of the given instruction list. Check found matches with the constraint object.\n+     * Replace symbolic names of instructions with the appropiate character and\n+     * remove all white space from string. Meta characters such as +, * are\n+     * ignored.\n@@ -296,3 +132,3 @@\n-     * @param pattern the instruction pattern to search for, case is ignored\n-     * @param constraint constraints to be checked on matching code\n-     * @return instruction handle or 'null' if the match failed\n+     * @param pattern\n+     *          The pattern to compile\n+     * @return translated regular expression string\n@@ -300,2 +136,24 @@\n-    public final Iterator<InstructionHandle[]> search(final String pattern, final CodeConstraint constraint) {\n-        return search(pattern, il.getStart(), constraint);\n+    private static String compilePattern( final String pattern ) {\n+        \/\/Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues\n+        final String lower = pattern.toLowerCase(Locale.ENGLISH);\n+        final StringBuilder buf = new StringBuilder();\n+        final int size = pattern.length();\n+        for (int i = 0; i < size; i++) {\n+            char ch = lower.charAt(i);\n+            if (Character.isLetterOrDigit(ch)) {\n+                final StringBuilder name = new StringBuilder();\n+                while ((Character.isLetterOrDigit(ch) || ch == '_') && i < size) {\n+                    name.append(ch);\n+                    if (++i < size) {\n+                        ch = lower.charAt(i);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                i--;\n+                buf.append(mapName(name.toString()));\n+            } else if (!Character.isWhitespace(ch)) {\n+                buf.append(ch);\n+            }\n+        }\n+        return buf.toString();\n@@ -304,0 +162,1 @@\n+\n@@ -305,5 +164,1 @@\n-     * Start search beginning from 'from'.\n-     *\n-     * @param pattern the instruction pattern to search for, where case is ignored\n-     * @param from where to start the search in the instruction list\n-     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n+     * @return the matched piece of code as an array of instruction (handles)\n@@ -311,2 +166,4 @@\n-    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionHandle from) {\n-        return search(pattern, from, null);\n+    private InstructionHandle[] getMatch( final int matched_from, final int match_length ) {\n+        final InstructionHandle[] match = new InstructionHandle[match_length];\n+        System.arraycopy(handles, matched_from, match, 0, match_length);\n+        return match;\n@@ -315,0 +172,1 @@\n+\n@@ -316,4 +174,6 @@\n-     * Search for the given pattern in the instruction list. You can search for any valid opcode via its symbolic name, e.g.\n-     * \"istore\". You can also use a super class or an interface name to match a whole set of instructions, e.g.\n-     * \"BranchInstruction\" or \"LoadInstruction\". \"istore\" is also an alias for all \"istore_x\" instructions. Additional\n-     * aliases are \"if\" for \"ifxx\", \"if_icmp\" for \"if_icmpxx\", \"if_acmp\" for \"if_acmpxx\".\n+     * Search for the given pattern in the instruction list. You can search for\n+     * any valid opcode via its symbolic name, e.g. \"istore\". You can also use a\n+     * super class or an interface name to match a whole set of instructions, e.g.\n+     * \"BranchInstruction\" or \"LoadInstruction\". \"istore\" is also an alias for all\n+     * \"istore_x\" instructions. Additional aliases are \"if\" for \"ifxx\", \"if_icmp\"\n+     * for \"if_icmpxx\", \"if_acmp\" for \"if_acmpxx\".\n@@ -321,2 +181,2 @@\n-     * Consecutive instruction names must be separated by white space which will be removed during the compilation of the\n-     * pattern.\n+     * Consecutive instruction names must be separated by white space which will\n+     * be removed during the compilation of the pattern.\n@@ -324,1 +184,2 @@\n-     * For the rest the usual pattern matching rules for regular expressions apply.\n+     * For the rest the usual pattern matching rules for regular expressions\n+     * apply.\n@@ -333,2 +194,3 @@\n-     * If you alter the instruction list upon a match such that other matching areas are affected, you should call reread()\n-     * to update the finder and call search() again, because the matches are cached.\n+     * If you alter the instruction list upon a match such that other matching\n+     * areas are affected, you should call reread() to update the finder and call\n+     * search() again, because the matches are cached.\n@@ -336,4 +198,9 @@\n-     * @param pattern the instruction pattern to search for, where case is ignored\n-     * @param from where to start the search in the instruction list\n-     * @param constraint optional CodeConstraint to check the found code pattern for user-defined constraints\n-     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n+     * @param pattern\n+     *          the instruction pattern to search for, where case is ignored\n+     * @param from\n+     *          where to start the search in the instruction list\n+     * @param constraint\n+     *          optional CodeConstraint to check the found code pattern for\n+     *          user-defined constraints\n+     * @return iterator of matches where e.nextElement() returns an array of\n+     *         instruction handles describing the matched area\n@@ -341,1 +208,2 @@\n-    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionHandle from, final CodeConstraint constraint) {\n+    public final Iterator<InstructionHandle[]> search( final String pattern,\n+            final InstructionHandle from, final CodeConstraint constraint ) {\n@@ -351,1 +219,2 @@\n-            throw new ClassGenException(\"Instruction handle \" + from + \" not found in instruction list.\");\n+            throw new ClassGenException(\"Instruction handle \" + from\n+                    + \" not found in instruction list.\");\n@@ -361,1 +230,1 @@\n-            if (constraint == null || constraint.checkCode(match)) {\n+            if ((constraint == null) || constraint.checkCode(match)) {\n@@ -369,0 +238,163 @@\n+\n+    \/**\n+     * Start search beginning from the start of the given instruction list.\n+     *\n+     * @param pattern\n+     *          the instruction pattern to search for, where case is ignored\n+     * @return iterator of matches where e.nextElement() returns an array of\n+     *         instruction handles describing the matched area\n+     *\/\n+    public final Iterator<InstructionHandle[]> search( final String pattern ) {\n+        return search(pattern, il.getStart(), null);\n+    }\n+\n+\n+    \/**\n+     * Start search beginning from `from'.\n+     *\n+     * @param pattern\n+     *          the instruction pattern to search for, where case is ignored\n+     * @param from\n+     *          where to start the search in the instruction list\n+     * @return iterator of matches where e.nextElement() returns an array of\n+     *         instruction handles describing the matched area\n+     *\/\n+    public final Iterator<InstructionHandle[]> search( final String pattern,\n+            final InstructionHandle from ) {\n+        return search(pattern, from, null);\n+    }\n+\n+\n+    \/**\n+     * Start search beginning from the start of the given instruction list. Check\n+     * found matches with the constraint object.\n+     *\n+     * @param pattern\n+     *          the instruction pattern to search for, case is ignored\n+     * @param constraint\n+     *          constraints to be checked on matching code\n+     * @return instruction handle or `null' if the match failed\n+     *\/\n+    public final Iterator<InstructionHandle[]> search( final String pattern,\n+            final CodeConstraint constraint ) {\n+        return search(pattern, il.getStart(), constraint);\n+    }\n+\n+\n+    \/**\n+     * Convert opcode number to char.\n+     *\/\n+    private static char makeChar( final short opcode ) {\n+        return (char) (opcode + OFFSET);\n+    }\n+\n+\n+    \/**\n+     * @return the inquired instruction list\n+     *\/\n+    public final InstructionList getInstructionList() {\n+        return il;\n+    }\n+\n+    \/**\n+     * Code patterns found may be checked using an additional user-defined\n+     * constraint object whether they really match the needed criterion. I.e.,\n+     * check constraints that can not expressed with regular expressions.\n+     *\n+     *\/\n+    public interface CodeConstraint {\n+\n+        \/**\n+         * @param match\n+         *          array of instructions matching the requested pattern\n+         * @return true if the matched area is really useful\n+         *\/\n+        boolean checkCode( InstructionHandle[] match );\n+    }\n+\n+    \/\/ Initialize pattern map\n+    static {\n+        map.put(\"arithmeticinstruction\",\"(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)\");\n+        map.put(\"invokeinstruction\", \"(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)\");\n+        map.put(\"arrayinstruction\", \"(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)\");\n+        map.put(\"gotoinstruction\", \"(goto|goto_w)\");\n+        map.put(\"conversioninstruction\", \"(d2l|l2d|i2s|d2i|l2i|i2b|l2f|d2f|f2i|i2d|i2l|f2d|i2c|f2l|i2f)\");\n+        map.put(\"localvariableinstruction\",\"(fstore|iinc|lload|dstore|dload|iload|aload|astore|istore|fload|lstore)\");\n+        map.put(\"loadinstruction\", \"(fload|dload|lload|iload|aload)\");\n+        map.put(\"fieldinstruction\", \"(getfield|putstatic|getstatic|putfield)\");\n+        map.put(\"cpinstruction\", \"(ldc2_w|invokeinterface|invokedynamic|multianewarray|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|ldc_w|invokestatic|invokevirtual|putfield|ldc|new|anewarray)\");\n+        map.put(\"stackinstruction\", \"(dup2|swap|dup2_x2|pop|pop2|dup|dup2_x1|dup_x2|dup_x1)\");\n+        map.put(\"branchinstruction\", \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n+        map.put(\"returninstruction\", \"(lreturn|ireturn|freturn|dreturn|areturn|return)\");\n+        map.put(\"storeinstruction\", \"(istore|fstore|dstore|astore|lstore)\");\n+        map.put(\"select\", \"(tableswitch|lookupswitch)\");\n+        map.put(\"ifinstruction\", \"(ifeq|ifgt|if_icmpne|if_icmpeq|ifge|ifnull|ifne|if_icmple|if_icmpge|if_acmpeq|if_icmplt|if_acmpne|ifnonnull|iflt|if_icmpgt|ifle)\");\n+        map.put(\"jsrinstruction\", \"(jsr|jsr_w)\");\n+        map.put(\"variablelengthinstruction\", \"(tableswitch|jsr|goto|lookupswitch)\");\n+        map.put(\"unconditionalbranch\", \"(goto|jsr|jsr_w|athrow|goto_w)\");\n+        map.put(\"constantpushinstruction\", \"(dconst|bipush|sipush|fconst|iconst|lconst)\");\n+        map.put(\"typedinstruction\", \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dastore|ret|f2d|f2i|drem|iinc|i2c|checkcast|frem|lreturn|astore|lushr|daload|dneg|fastore|istore|lshl|ldiv|lstore|areturn|ishr|ldc_w|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|faload|sipush|iushr|caload|instanceof|invokespecial|putfield|fmul|ireturn|laload|d2f|lneg|ixor|i2l|fdiv|lastore|multianewarray|i2b|getstatic|i2d|putstatic|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|freturn|ldc|aconst_null|castore|lmul|ldc2_w|dadd|iconst|f2l|ddiv|dstore|land|jsr|anewarray|dmul|bipush|dsub|sastore|d2i|i2s|lshr|iadd|l2i|lload|bastore|fstore|fneg|iload|fadd|baload|fconst|ior|ineg|dreturn|l2f|lconst|getfield|invokevirtual|invokestatic|iastore)\");\n+        map.put(\"popinstruction\", \"(fstore|dstore|pop|pop2|astore|putstatic|istore|lstore)\");\n+        map.put(\"allocationinstruction\", \"(multianewarray|new|anewarray|newarray)\");\n+        map.put(\"indexedinstruction\", \"(lload|lstore|fload|ldc2_w|invokeinterface|invokedynamic|multianewarray|astore|dload|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|dstore|istore|iinc|ldc_w|ret|fstore|invokestatic|iload|putfield|invokevirtual|ldc|new|aload|anewarray)\");\n+        map.put(\"pushinstruction\", \"(dup|lload|dup2|bipush|fload|ldc2_w|sipush|lconst|fconst|dload|getstatic|ldc_w|aconst_null|dconst|iload|ldc|iconst|aload)\");\n+        map.put(\"stackproducer\", \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dup|f2d|f2i|drem|i2c|checkcast|frem|lushr|daload|dneg|lshl|ldiv|ishr|ldc_w|invokeinterface|invokedynamic|lxor|ishl|l2d|i2f|faload|sipush|iushr|caload|instanceof|invokespecial|fmul|laload|d2f|lneg|ixor|i2l|fdiv|getstatic|i2b|swap|i2d|dup2|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|ldc|arraylength|aconst_null|tableswitch|lmul|ldc2_w|iconst|dadd|f2l|ddiv|land|jsr|anewarray|dmul|bipush|dsub|d2i|newarray|i2s|lshr|iadd|lload|l2i|fneg|iload|fadd|baload|fconst|lookupswitch|ior|ineg|lconst|l2f|getfield|invokevirtual|invokestatic)\");\n+        map.put(\"stackconsumer\", \"(imul|lsub|lor|iflt|fcmpg|if_icmpgt|iand|ifeq|if_icmplt|lrem|ifnonnull|idiv|d2l|isub|dcmpg|dastore|if_icmpeq|f2d|f2i|drem|i2c|checkcast|frem|lreturn|astore|lushr|pop2|monitorexit|dneg|fastore|istore|lshl|ldiv|lstore|areturn|if_icmpge|ishr|monitorenter|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|iushr|instanceof|invokespecial|fmul|ireturn|d2f|lneg|ixor|pop|i2l|ifnull|fdiv|lastore|i2b|if_acmpeq|ifge|swap|i2d|putstatic|fcmpl|ladd|irem|dcmpl|fsub|freturn|ifgt|castore|lmul|dadd|f2l|ddiv|dstore|land|if_icmpne|if_acmpne|dmul|dsub|sastore|ifle|d2i|i2s|lshr|iadd|l2i|bastore|fstore|fneg|fadd|ior|ineg|ifne|dreturn|l2f|if_icmple|getfield|invokevirtual|invokestatic|iastore)\");\n+        map.put(\"exceptionthrower\",\"(irem|lrem|laload|putstatic|baload|dastore|areturn|getstatic|ldiv|anewarray|iastore|castore|idiv|saload|lastore|fastore|putfield|lreturn|caload|getfield|return|aastore|freturn|newarray|instanceof|multianewarray|athrow|faload|iaload|aaload|dreturn|monitorenter|checkcast|bastore|arraylength|new|invokevirtual|sastore|ldc_w|ireturn|invokespecial|monitorexit|invokeinterface|invokedynamic|ldc|invokestatic|daload)\");\n+        map.put(\"loadclass\", \"(multianewarray|invokeinterface|invokedynamic|instanceof|invokespecial|putfield|checkcast|putstatic|invokevirtual|new|getstatic|invokestatic|getfield|anewarray)\");\n+        map.put(\"instructiontargeter\", \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n+        \/\/ Some aliases\n+        map.put(\"if_icmp\", \"(if_icmpne|if_icmpeq|if_icmple|if_icmpge|if_icmplt|if_icmpgt)\");\n+        map.put(\"if_acmp\", \"(if_acmpeq|if_acmpne)\");\n+        map.put(\"if\", \"(ifeq|ifne|iflt|ifge|ifgt|ifle)\");\n+        \/\/ Precompile some aliases first\n+        map.put(\"iconst\", precompile(Const.ICONST_0, Const.ICONST_5, Const.ICONST_M1));\n+        map.put(\"lconst\", new String(new char[] { '(', makeChar(Const.LCONST_0), '|', makeChar(Const.LCONST_1), ')' }));\n+        map.put(\"dconst\", new String(new char[] { '(', makeChar(Const.DCONST_0), '|', makeChar(Const.DCONST_1), ')' }));\n+        map.put(\"fconst\", new String(new char[] { '(', makeChar(Const.FCONST_0), '|', makeChar(Const.FCONST_1), '|', makeChar(Const.FCONST_2), ')' }));\n+        map.put(\"lload\", precompile(Const.LLOAD_0, Const.LLOAD_3, Const.LLOAD));\n+        map.put(\"iload\", precompile(Const.ILOAD_0, Const.ILOAD_3, Const.ILOAD));\n+        map.put(\"dload\", precompile(Const.DLOAD_0, Const.DLOAD_3, Const.DLOAD));\n+        map.put(\"fload\", precompile(Const.FLOAD_0, Const.FLOAD_3, Const.FLOAD));\n+        map.put(\"aload\", precompile(Const.ALOAD_0, Const.ALOAD_3, Const.ALOAD));\n+        map.put(\"lstore\", precompile(Const.LSTORE_0, Const.LSTORE_3, Const.LSTORE));\n+        map.put(\"istore\", precompile(Const.ISTORE_0, Const.ISTORE_3, Const.ISTORE));\n+        map.put(\"dstore\", precompile(Const.DSTORE_0, Const.DSTORE_3, Const.DSTORE));\n+        map.put(\"fstore\", precompile(Const.FSTORE_0, Const.FSTORE_3, Const.FSTORE));\n+        map.put(\"astore\", precompile(Const.ASTORE_0, Const.ASTORE_3, Const.ASTORE));\n+        \/\/ Compile strings\n+        for (final Map.Entry<String, String> entry : map.entrySet()) {\n+            final String key = entry.getKey();\n+            final String value = entry.getValue();\n+            final char ch = value.charAt(1); \/\/ Omit already precompiled patterns\n+            if (ch < OFFSET) {\n+                map.put(key, compilePattern(value)); \/\/ precompile all patterns\n+            }\n+        }\n+        \/\/ Add instruction alias to match anything\n+        final StringBuilder buf = new StringBuilder(\"(\");\n+        for (short i = 0; i < NO_OPCODES; i++) {\n+            if (Const.getNoOfOperands(i) != Const.UNDEFINED) { \/\/ Not an invalid opcode\n+                buf.append(makeChar(i));\n+                if (i < NO_OPCODES - 1) {\n+                    buf.append('|');\n+                }\n+            }\n+        }\n+        buf.append(')');\n+        map.put(\"instruction\", buf.toString());\n+    }\n+\n+\n+    private static String precompile( final short from, final short to, final short extra ) {\n+        final StringBuilder buf = new StringBuilder(\"(\");\n+        for (short i = from; i <= to; i++) {\n+            buf.append(makeChar(i));\n+            buf.append('|');\n+        }\n+        buf.append(makeChar(extra));\n+        buf.append(\")\");\n+        return buf.toString();\n+    }\n+\n+\n@@ -376,0 +408,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/InstructionFinder.java","additions":261,"deletions":228,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n-import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n@@ -26,2 +27,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.Charset;\n@@ -32,0 +31,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.ConstantValue;\n@@ -39,0 +39,2 @@\n+ *\n+ *\n@@ -43,1 +45,1 @@\n-    private final PrintWriter printWriter; \/\/ file to write to\n+    private final PrintWriter file; \/\/ file to write to\n@@ -45,1 +47,1 @@\n-    private final AttributeHTML attributeHtml;\n+    private final AttributeHTML attribute_html;\n@@ -47,22 +49,19 @@\n-    MethodHTML(final String dir, final String className, final Method[] methods, final Field[] fields, final ConstantHTML constantHtml,\n-        final AttributeHTML attributeHtml, final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n-        this.className = className;\n-        this.attributeHtml = attributeHtml;\n-        this.constantHtml = constantHtml;\n-        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_methods.html\", charset.name())) {\n-            printWriter = newPrintWriter;\n-            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n-            printWriter.print(charset.name());\n-            printWriter.println(\"\\\"><\/head>\");\n-            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n-            printWriter.println(\"<TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH><TH ALIGN=LEFT>Type<\/TH>\" + \"<TH ALIGN=LEFT>Field&nbsp;name<\/TH><\/TR>\");\n-            for (final Field field : fields) {\n-                writeField(field);\n-            }\n-            printWriter.println(\"<\/TABLE>\");\n-            printWriter.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH>\"\n-                + \"<TH ALIGN=LEFT>Return&nbsp;type<\/TH><TH ALIGN=LEFT>Method&nbsp;name<\/TH>\" + \"<TH ALIGN=LEFT>Arguments<\/TH><\/TR>\");\n-            for (int i = 0; i < methods.length; i++) {\n-                writeMethod(methods[i], i);\n-            }\n-            printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+\n+    MethodHTML(final String dir, final String class_name, final Method[] methods, final Field[] fields,\n+            final ConstantHTML constant_html, final AttributeHTML attribute_html) throws IOException {\n+        this.className = class_name;\n+        this.attribute_html = attribute_html;\n+        this.constantHtml = constant_html;\n+        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_methods.html\"));\n+        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+        file.println(\"<TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH><TH ALIGN=LEFT>Type<\/TH>\"\n+                + \"<TH ALIGN=LEFT>Field&nbsp;name<\/TH><\/TR>\");\n+        for (final Field field : fields) {\n+            writeField(field);\n+        }\n+        file.println(\"<\/TABLE>\");\n+        file.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH>\"\n+                + \"<TH ALIGN=LEFT>Return&nbsp;type<\/TH><TH ALIGN=LEFT>Method&nbsp;name<\/TH>\"\n+                + \"<TH ALIGN=LEFT>Arguments<\/TH><\/TR>\");\n+        for (int i = 0; i < methods.length; i++) {\n+            writeMethod(methods[i], i);\n@@ -70,0 +69,2 @@\n+        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+        file.close();\n@@ -72,0 +73,1 @@\n+\n@@ -76,0 +78,1 @@\n+     * @throws java.io.IOException\n@@ -77,1 +80,1 @@\n-    private void writeField(final Field field) {\n+    private void writeField( final Field field ) throws IOException {\n@@ -83,2 +86,3 @@\n-        printWriter.print(\"<TR><TD><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT><\/TD>\\n<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD><A NAME=\\\"field\"\n-            + name + \"\\\">\" + name + \"<\/A><\/TD>\");\n+        file.print(\"<TR><TD><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT><\/TD>\\n<TD>\"\n+                + Class2HTML.referenceType(type) + \"<\/TD><TD><A NAME=\\\"field\" + name + \"\\\">\" + name\n+                + \"<\/A><\/TD>\");\n@@ -88,1 +92,1 @@\n-            attributeHtml.writeAttribute(attributes[i], name + \"@\" + i);\n+            attribute_html.writeAttribute(attributes[i], name + \"@\" + i);\n@@ -92,1 +96,1 @@\n-                final String str = attributes[i].toString();\n+                final String str = ((ConstantValue) attributes[i]).toString();\n@@ -94,1 +98,2 @@\n-                printWriter.print(\"<TD>= <A HREF=\\\"\" + className + \"_attributes.html#\" + name + \"@\" + i + \"\\\" TARGET=\\\"Attributes\\\">\" + str + \"<\/TD>\\n\");\n+                file.print(\"<TD>= <A HREF=\\\"\" + className + \"_attributes.html#\" + name + \"@\" + i\n+                        + \"\\\" TARGET=\\\"Attributes\\\">\" + str + \"<\/TD>\\n\");\n@@ -98,1 +103,1 @@\n-        printWriter.println(\"<\/TR>\");\n+        file.println(\"<\/TR>\");\n@@ -101,1 +106,2 @@\n-    private void writeMethod(final Method method, final int methodNumber) {\n+\n+    private void writeMethod( final Method method, final int method_number ) {\n@@ -110,1 +116,1 @@\n-        String htmlName;\n+        String html_name;\n@@ -115,2 +121,2 @@\n-        \/*\n-         * HTML doesn't like names like <clinit> and spaces are places to break lines. Both we don't want...\n+        \/* HTML doesn't like names like <clinit> and spaces are places to break\n+         * lines. Both we don't want...\n@@ -119,4 +125,6 @@\n-        htmlName = Class2HTML.toHTML(name);\n-        printWriter.print(\"<TR VALIGN=TOP><TD><FONT COLOR=\\\"#FF0000\\\"><A NAME=method\" + methodNumber + \">\" + access + \"<\/A><\/FONT><\/TD>\");\n-        printWriter.print(\"<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD>\" + \"<A HREF=\" + className + \"_code.html#method\" + methodNumber + \" TARGET=Code>\"\n-            + htmlName + \"<\/A><\/TD>\\n<TD>(\");\n+        html_name = Class2HTML.toHTML(name);\n+        file.print(\"<TR VALIGN=TOP><TD><FONT COLOR=\\\"#FF0000\\\"><A NAME=method\" + method_number\n+                + \">\" + access + \"<\/A><\/FONT><\/TD>\");\n+        file.print(\"<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD>\" + \"<A HREF=\" + className\n+                + \"_code.html#method\" + method_number + \" TARGET=Code>\" + html_name\n+                + \"<\/A><\/TD>\\n<TD>(\");\n@@ -124,1 +132,1 @@\n-            printWriter.print(Class2HTML.referenceType(args[i]));\n+            file.print(Class2HTML.referenceType(args[i]));\n@@ -126,1 +134,1 @@\n-                printWriter.print(\", \");\n+                file.print(\", \");\n@@ -129,1 +137,1 @@\n-        printWriter.print(\")<\/TD><\/TR>\");\n+        file.print(\")<\/TD><\/TR>\");\n@@ -132,1 +140,2 @@\n-            attributeHtml.writeAttribute(attributes[i], \"method\" + methodNumber + \"@\" + i, methodNumber);\n+            attribute_html.writeAttribute(attributes[i], \"method\" + method_number + \"@\" + i,\n+                    method_number);\n@@ -135,1 +144,1 @@\n-                printWriter.print(\"<TR VALIGN=TOP><TD COLSPAN=2><\/TD><TH ALIGN=LEFT>throws<\/TH><TD>\");\n+                file.print(\"<TR VALIGN=TOP><TD COLSPAN=2><\/TD><TH ALIGN=LEFT>throws<\/TH><TD>\");\n@@ -138,1 +147,1 @@\n-                    printWriter.print(constantHtml.referenceConstant(exceptions[j]));\n+                    file.print(constantHtml.referenceConstant(exceptions[j]));\n@@ -140,1 +149,1 @@\n-                        printWriter.print(\", \");\n+                        file.print(\", \");\n@@ -143,1 +152,1 @@\n-                printWriter.println(\"<\/TD><\/TR>\");\n+                file.println(\"<\/TD><\/TR>\");\n@@ -145,3 +154,4 @@\n-                final Attribute[] attributeArray = ((Code) attributes[i]).getAttributes();\n-                for (int j = 0; j < attributeArray.length; j++) {\n-                    attributeHtml.writeAttribute(attributeArray[j], \"method\" + methodNumber + \"@\" + i + \"@\" + j, methodNumber);\n+                final Attribute[] c_a = ((Code) attributes[i]).getAttributes();\n+                for (int j = 0; j < c_a.length; j++) {\n+                    attribute_html.writeAttribute(c_a[j], \"method\" + method_number + \"@\" + i + \"@\"\n+                            + j, method_number);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/MethodHTML.java","additions":63,"deletions":53,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Iterator;\n@@ -56,0 +57,3 @@\n+     *\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -57,2 +61,1 @@\n-    @SuppressWarnings(\"resource\") \/\/ See #close()\n-    public ModularRuntimeImage() {\n+    public ModularRuntimeImage() throws IOException {\n@@ -65,1 +68,2 @@\n-     * @param javaHome Path to a Java 9 or greater home.\n+     * @param javaHome\n+     *            Path to a Java 9 or greater home.\n@@ -67,1 +71,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -73,1 +78,1 @@\n-        this.classLoader = URLClassLoader.newInstance(new URL[] {jrtFsPath.toUri().toURL()});\n+        this.classLoader = new URLClassLoader(new URL[] {jrtFsPath.toUri().toURL() });\n@@ -92,4 +97,0 @@\n-    public FileSystem getFileSystem() {\n-        return fileSystem;\n-    }\n-\n@@ -99,1 +100,2 @@\n-     * @param dirPath directory path.\n+     * @param dirPath\n+     *            directory path.\n@@ -101,1 +103,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -106,1 +109,4 @@\n-            ds.forEach(list::add);\n+            final Iterator<Path> iterator = ds.iterator();\n+            while (iterator.hasNext()) {\n+                list.add(iterator.next());\n+            }\n@@ -114,1 +120,2 @@\n-     * @param dirName directory path.\n+     * @param dirName\n+     *            directory path.\n@@ -116,1 +123,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -126,1 +134,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -136,1 +145,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -142,0 +152,4 @@\n+    public FileSystem getFileSystem() {\n+        return fileSystem;\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ModularRuntimeImage.java","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,3 @@\n- * Abstract definition of a class repository. Instances may be used to load classes from different sources and may be\n- * used in the Repository.setRepository method.\n+ * Abstract definition of a class repository. Instances may be used\n+ * to load classes from different sources and may be used in the\n+ * Repository.setRepository method.\n@@ -28,2 +29,2 @@\n- * @see org.apache.bcel.Repository\n- * @LastModified: Feb 2023\n+ * @see com.sun.org.apache.bcel.internal.Repository\n+ * @LastModified: Jan 2020\n@@ -34,1 +35,1 @@\n-     * Clears all entries from cache.\n+     * Stores the provided class under \"clazz.getClassName()\"\n@@ -36,1 +37,1 @@\n-    void clear();\n+    void storeClass(JavaClass clazz);\n@@ -39,1 +40,1 @@\n-     * Finds the class with the name provided, if the class isn't there, return NULL.\n+     * Removes class from repository\n@@ -41,1 +42,1 @@\n-    JavaClass findClass(String className);\n+    void removeClass(JavaClass clazz);\n@@ -44,3 +45,1 @@\n-     * Finds the JavaClass instance for the given run-time class object.\n-     *\n-     * @throws ClassNotFoundException if the class can't be found.\n+     * Finds the class with the name provided, if the class isn't there, return NULL.\n@@ -48,1 +47,1 @@\n-    JavaClass loadClass(Class<?> clazz) throws ClassNotFoundException;\n+    JavaClass findClass(String className);\n@@ -52,2 +51,0 @@\n-     *\n-     * @throws ClassNotFoundException if the class can't be found.\n@@ -55,1 +52,1 @@\n-    JavaClass loadClass(String className) throws ClassNotFoundException;\n+    JavaClass loadClass(String className) throws java.lang.ClassNotFoundException;\n@@ -58,1 +55,1 @@\n-     * Removes class from repository\n+     * Finds the JavaClass instance for the given run-time class object\n@@ -60,1 +57,1 @@\n-    void removeClass(JavaClass clazz);\n+    JavaClass loadClass(Class<?> clazz) throws java.lang.ClassNotFoundException;\n@@ -63,1 +60,1 @@\n-     * Stores the provided class under \"clazz.getClassName()\"\n+     * Clears all entries from cache.\n@@ -65,1 +62,1 @@\n-    void storeClass(JavaClass clazz);\n+    void clear();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Repository.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -33,7 +32,7 @@\n- * This repository is used in situations where a Class is created outside the realm of a ClassLoader. Classes are loaded\n- * from the file systems using the paths specified in the given class path. By default, this is the value returned by\n- * ClassPath.getClassPath().\n- * <p>\n- * This repository uses a factory design, allowing it to maintain a collection of different classpaths, and as such It\n- * is designed to be used as a singleton per classpath.\n- * <\/p>\n+ * This repository is used in situations where a Class is created outside the\n+ * realm of a ClassLoader. Classes are loaded from the file systems using the\n+ * paths specified in the given class path. By default, this is the value\n+ * returned by ClassPath.getClassPath(). <br>\n+ * This repository uses a factory design, allowing it to maintain a collection\n+ * of different classpaths, and as such It is designed to be used as a singleton\n+ * per classpath.\n@@ -43,1 +42,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -58,1 +57,1 @@\n-     * Clear all entries from cache.\n+     * Store a new JavaClass instance into this Repository.\n@@ -61,2 +60,11 @@\n-    public void clear() {\n-        loadedClasses.clear();\n+    public void storeClass(final JavaClass clazz) {\n+        loadedClasses.put(clazz.getClassName(), new SoftReference<>(clazz));\n+        clazz.setRepository(this);\n+        }\n+\n+    \/**\n+     * Remove class from repository\n+     *\/\n+    @Override\n+    public void removeClass(final JavaClass clazz) {\n+        loadedClasses.remove(clazz.getClassName());\n@@ -71,1 +79,4 @@\n-        return ref == null ? null : ref.get();\n+        if (ref == null) {\n+            return null;\n+}\n+        return ref.get();\n@@ -75,1 +86,6 @@\n-     * Remove class from repository\n+     * Finds a JavaClass object by name. If it is already in this Repository, the\n+     * Repository version is returned.\n+     *\n+     * @param className the name of the class\n+     * @return the JavaClass object\n+     * @throws ClassNotFoundException if the class is not in the Repository\n@@ -78,2 +94,3 @@\n-    public void removeClass(final JavaClass clazz) {\n-        loadedClasses.remove(clazz.getClassName());\n+    public JavaClass loadClass(String className) throws ClassNotFoundException {\n+        if ((className == null) || className.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid class name \" + className);\n@@ -81,0 +98,5 @@\n+        className = className.replace('\/', '.'); \/\/ Just in case, canonical form\n+        final JavaClass clazz = findClass(className);\n+        if (clazz != null) {\n+            return clazz;\n+        }\n@@ -82,8 +104,3 @@\n-    \/**\n-     * Store a new JavaClass instance into this Repository.\n-     *\/\n-    @Override\n-    public void storeClass(final JavaClass clazz) {\n-        \/\/ Not calling super.storeClass because this subclass maintains the mapping.\n-        loadedClasses.put(clazz.getClassName(), new SoftReference<>(clazz));\n-        clazz.setRepository(this);\n+        IOException e = new IOException(\"Couldn't find: \" + className + \".class\");\n+        throw new ClassNotFoundException(\"Exception while looking for class \" +\n+                className + \": \" + e, e);\n@@ -93,3 +110,5 @@\n-     * Finds the JavaClass object for a runtime Class object. If a class with the same name is already in this Repository,\n-     * the Repository version is returned. Otherwise, getResourceAsStream() is called on the Class object to find the\n-     * class's representation. If the representation is found, it is added to the Repository.\n+     * Find the JavaClass object for a runtime Class object. If a class with the\n+     * same name is already in this Repository, the Repository version is\n+     * returned. Otherwise, getResourceAsStream() is called on the Class object\n+     * to find the class's representation. If the representation is found, it is\n+     * added to the Repository.\n@@ -100,1 +119,2 @@\n-     * @throws ClassNotFoundException if the class is not in the Repository, and its representation could not be found\n+     * @throws ClassNotFoundException if the class is not in the Repository, and\n+     * its representation could not be found\n@@ -108,1 +128,1 @@\n-        }\n+    }\n@@ -114,3 +134,3 @@\n-\n-        try (InputStream clsStream = clazz.getResourceAsStream(name + JavaClass.EXTENSION)) {\n-            return loadClass(clsStream, className);\n+        JavaClass cls = null;\n+        try (InputStream clsStream = clazz.getResourceAsStream(name + \".class\")) {\n+            return cls = loadClass(clsStream, className);\n@@ -118,1 +138,1 @@\n-            return null;\n+            return cls;\n@@ -120,0 +140,1 @@\n+\n@@ -122,1 +143,3 @@\n-    private JavaClass loadClass(final InputStream inputStream, final String className) throws ClassNotFoundException {\n+\n+    private JavaClass loadClass(final InputStream is, final String className)\n+            throws ClassNotFoundException {\n@@ -124,2 +147,2 @@\n-            if (inputStream != null) {\n-                final ClassParser parser = new ClassParser(inputStream, className);\n+            if (is != null) {\n+                final ClassParser parser = new ClassParser(is, className);\n@@ -131,1 +154,10 @@\n-            throw new ClassNotFoundException(\"Exception while looking for class \" + className + \": \" + e, e);\n+            throw new ClassNotFoundException(\"Exception while looking for class \"\n+                    + className + \": \" + e, e);\n+        } finally {\n+            if (is != null) {\n+                try {\n+                    is.close();\n+                } catch (final IOException e) {\n+                    \/\/ ignored\n+                }\n+            }\n@@ -133,1 +165,2 @@\n-        throw new ClassNotFoundException(\"ClassRepository could not load \" + className);\n+        throw new ClassNotFoundException(\"SyntheticRepository could not load \"\n+                + className);\n@@ -137,6 +170,1 @@\n-     * Finds a JavaClass object by name. If it is already in this Repository, the Repository version is returned. Otherwise,\n-     * the Repository's classpath is searched for the class (and it is added to the Repository if found).\n-     *\n-     * @param className the name of the class\n-     * @return the JavaClass object\n-     * @throws ClassNotFoundException if the class is not in the Repository, and could not be found on the classpath\n+     * Clear all entries from cache.\n@@ -145,12 +173,2 @@\n-    public JavaClass loadClass(String className) throws ClassNotFoundException {\n-        if (className == null || className.isEmpty()) {\n-            throw new IllegalArgumentException(\"Invalid class name \" + className);\n-        }\n-        className = Utility.pathToPackage(className); \/\/ Just in case, canonical form\n-        final JavaClass clazz = findClass(className);\n-        if (clazz != null) {\n-            return clazz;\n-        }\n-        IOException e = new IOException(\"Couldn't find: \" + className + \".class\");\n-        throw new ClassNotFoundException(\"Exception while looking for class \" +\n-                className + \": \" + e, e);\n+    public void clear() {\n+        loadedClasses.clear();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/SyntheticRepository.java","additions":75,"deletions":57,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.xml.internal;\n-\n-import java.util.Arrays;\n-\n-\/**\n- * General utility. Use JdkXmlUtils for XML processing related functions.\n- *\/\n-public class Utils {\n-    \/**\n-     * Creates a new array with copies of the original array and additional items\n-     * appended to the end of it.\n-     *\n-     * @param original the original array\n-     * @param items items to be appended to the original array\n-     * @return a new array with copies of the original array and additional items\n-     *\/\n-    public static Class<?>[] arraysAppend(final Class<?>[] original, final Class<?>... items) {\n-        if (original == null && items == null) {\n-            return null;\n-        }\n-        if (items == null) {\n-            return Arrays.copyOf(original, original.length);\n-        }\n-        if (original == null) {\n-            return Arrays.copyOf(items, items.length);\n-        }\n-\n-        Class<?>[] result = Arrays.copyOf(original, original.length + items.length);\n-        System.arraycopy(items, 0, result, original.length, items.length);\n-        return result;\n-    }\n-}\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/Utils.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-## Apache Commons Byte Code Engineering Library (BCEL) Version 6.7.0\n+## Apache Commons Byte Code Engineering Library (BCEL) Version 6.5.0\n@@ -7,1 +7,1 @@\n-    Copyright 2004-2022 The Apache Software Foundation\n+    Copyright 2004-2020 The Apache Software Foundation\n","filename":"src\/java.xml\/share\/legal\/bcel.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -731,7 +731,0 @@\n-                        long uncompressedSize = je.getSize();\n-                        if (uncompressedSize > SignatureFileVerifier.MAX_SIG_FILE_SIZE) {\n-                            unparsableSignatures.putIfAbsent(alias, String.format(\n-                                    rb.getString(\"history.unparsable\"), name));\n-                            continue;\n-                        }\n-\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*! jQuery UI - v1.13.2 - 2023-02-27\n+\/*! jQuery UI - v1.13.1 - 2022-05-12\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-ui.css","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*! jQuery UI - v1.13.2 - 2023-02-27\n+\/*! jQuery UI - v1.13.1 - 2022-05-12\n@@ -23,1 +23,1 @@\n-var version = $.ui.version = \"1.13.2\";\n+var version = $.ui.version = \"1.13.1\";\n@@ -27,1 +27,1 @@\n- * jQuery UI Widget 1.13.2\n+ * jQuery UI Widget 1.13.1\n@@ -769,1 +769,1 @@\n- * jQuery UI Position 1.13.2\n+ * jQuery UI Position 1.13.1\n@@ -1266,1 +1266,1 @@\n- * jQuery UI Keycode 1.13.2\n+ * jQuery UI Keycode 1.13.1\n@@ -1301,1 +1301,1 @@\n- * jQuery UI Unique ID 1.13.2\n+ * jQuery UI Unique ID 1.13.1\n@@ -1369,1 +1369,1 @@\n- * jQuery UI Menu 1.13.2\n+ * jQuery UI Menu 1.13.1\n@@ -1388,1 +1388,1 @@\n-\tversion: \"1.13.2\",\n+\tversion: \"1.13.1\",\n@@ -2060,1 +2060,1 @@\n- * jQuery UI Autocomplete 1.13.2\n+ * jQuery UI Autocomplete 1.13.1\n@@ -2079,1 +2079,1 @@\n-\tversion: \"1.13.2\",\n+\tversion: \"1.13.1\",\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-ui.js","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*! jQuery UI - v1.13.2 - 2023-02-27\n+\/*! jQuery UI - v1.13.1 - 2022-05-12\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-ui.min.css","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*! jQuery UI - v1.13.2 - 2023-02-27\n+\/*! jQuery UI - v1.13.1 - 2022-05-12\n@@ -6,1 +6,1 @@\n-!function(t){\"use strict\";\"function\"==typeof define&&define.amd?define([\"jquery\"],t):t(jQuery)}(function(x){\"use strict\";x.ui=x.ui||{};x.ui.version=\"1.13.2\";var n,i=0,l=Array.prototype.hasOwnProperty,a=Array.prototype.slice;x.cleanData=(n=x.cleanData,function(t){for(var e,i,s=0;null!=(i=t[s]);s++)(e=x._data(i,\"events\"))&&e.remove&&x(i).triggerHandler(\"remove\");n(t)}),x.widget=function(t,i,e){var s,n,o,l={},a=t.split(\".\")[0],r=a+\"-\"+(t=t.split(\".\")[1]);return e||(e=i,i=x.Widget),Array.isArray(e)&&(e=x.extend.apply(null,[{}].concat(e))),x.expr.pseudos[r.toLowerCase()]=function(t){return!!x.data(t,r)},x[a]=x[a]||{},s=x[a][t],n=x[a][t]=function(t,e){if(!this||!this._createWidget)return new n(t,e);arguments.length&&this._createWidget(t,e)},x.extend(n,s,{version:e.version,_proto:x.extend({},e),_childConstructors:[]}),(o=new i).options=x.widget.extend({},o.options),x.each(e,function(e,s){function n(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}l[e]=\"function\"==typeof s?function(){var t,e=this._super,i=this._superApply;return this._super=n,this._superApply=o,t=s.apply(this,arguments),this._super=e,this._superApply=i,t}:s}),n.prototype=x.widget.extend(o,{widgetEventPrefix:s&&o.widgetEventPrefix||t},l,{constructor:n,namespace:a,widgetName:t,widgetFullName:r}),s?(x.each(s._childConstructors,function(t,e){var i=e.prototype;x.widget(i.namespace+\".\"+i.widgetName,n,e._proto)}),delete s._childConstructors):i._childConstructors.push(n),x.widget.bridge(t,n),n},x.widget.extend=function(t){for(var e,i,s=a.call(arguments,1),n=0,o=s.length;n<o;n++)for(e in s[n])i=s[n][e],l.call(s[n],e)&&void 0!==i&&(x.isPlainObject(i)?t[e]=x.isPlainObject(t[e])?x.widget.extend({},t[e],i):x.widget.extend({},i):t[e]=i);return t},x.widget.bridge=function(o,e){var l=e.prototype.widgetFullName||o;x.fn[o]=function(i){var t=\"string\"==typeof i,s=a.call(arguments,1),n=this;return t?this.length||\"instance\"!==i?this.each(function(){var t,e=x.data(this,l);return\"instance\"===i?(n=e,!1):e?\"function\"!=typeof e[i]||\"_\"===i.charAt(0)?x.error(\"no such method '\"+i+\"' for \"+o+\" widget instance\"):(t=e[i].apply(e,s))!==e&&void 0!==t?(n=t&&t.jquery?n.pushStack(t.get()):t,!1):void 0:x.error(\"cannot call methods on \"+o+\" prior to initialization; attempted to call method '\"+i+\"'\")}):n=void 0:(s.length&&(i=x.widget.extend.apply(null,[i].concat(s))),this.each(function(){var t=x.data(this,l);t?(t.option(i||{}),t._init&&t._init()):x.data(this,l,new e(i,this))})),n}},x.Widget=function(){},x.Widget._childConstructors=[],x.Widget.prototype={widgetName:\"widget\",widgetEventPrefix:\"\",defaultElement:\"<div>\",options:{classes:{},disabled:!1,create:null},_createWidget:function(t,e){e=x(e||this.defaultElement||this)[0],this.element=x(e),this.uuid=i++,this.eventNamespace=\".\"+this.widgetName+this.uuid,this.bindings=x(),this.hoverable=x(),this.focusable=x(),this.classesElementLookup={},e!==this&&(x.data(e,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===e&&this.destroy()}}),this.document=x(e.style?e.ownerDocument:e.document||e),this.window=x(this.document[0].defaultView||this.document[0].parentWindow)),this.options=x.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger(\"create\",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:x.noop,_create:x.noop,_init:x.noop,destroy:function(){var i=this;this._destroy(),x.each(this.classesElementLookup,function(t,e){i._removeClass(e,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr(\"aria-disabled\"),this.bindings.off(this.eventNamespace)},_destroy:x.noop,widget:function(){return this.element},option:function(t,e){var i,s,n,o=t;if(0===arguments.length)return x.widget.extend({},this.options);if(\"string\"==typeof t)if(o={},t=(i=t.split(\".\")).shift(),i.length){for(s=o[t]=x.widget.extend({},this.options[t]),n=0;n<i.length-1;n++)s[i[n]]=s[i[n]]||{},s=s[i[n]];if(t=i.pop(),1===arguments.length)return void 0===s[t]?null:s[t];s[t]=e}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=e}return this._setOptions(o),this},_setOptions:function(t){for(var e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return\"classes\"===t&&this._setOptionClasses(e),this.options[t]=e,\"disabled\"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(t){var e,i,s;for(e in t)s=this.classesElementLookup[e],t[e]!==this.options.classes[e]&&s&&s.length&&(i=x(s.get()),this._removeClass(s,e),i.addClass(this._classes({element:i,keys:e,classes:t,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+\"-disabled\",null,!!t),t&&(this._removeClass(this.hoverable,null,\"ui-state-hover\"),this._removeClass(this.focusable,null,\"ui-state-focus\"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(n){var o=[],l=this;function t(t,e){for(var i,s=0;s<t.length;s++)i=l.classesElementLookup[t[s]]||x(),i=n.add?(function(){var i=[];n.element.each(function(t,e){x.map(l.classesElementLookup,function(t){return t}).some(function(t){return t.is(e)})||i.push(e)}),l._on(x(i),{remove:\"_untrackClassesElement\"})}(),x(x.uniqueSort(i.get().concat(n.element.get())))):x(i.not(n.element).get()),l.classesElementLookup[t[s]]=i,o.push(t[s]),e&&n.classes[t[s]]&&o.push(n.classes[t[s]])}return(n=x.extend({element:this.element,classes:this.options.classes||{}},n)).keys&&t(n.keys.match(\/\\S+\/g)||[],!0),n.extra&&t(n.extra.match(\/\\S+\/g)||[]),o.join(\" \")},_untrackClassesElement:function(i){var s=this;x.each(s.classesElementLookup,function(t,e){-1!==x.inArray(i.target,e)&&(s.classesElementLookup[t]=x(e.not(i.target).get()))}),this._off(x(i.target))},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){var n=\"string\"==typeof t||null===t,i={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s=\"boolean\"==typeof s?s:i};return i.element.toggleClass(this._classes(i),s),this},_on:function(n,o,t){var l,a=this;\"boolean\"!=typeof n&&(t=o,o=n,n=!1),t?(o=l=x(o),this.bindings=this.bindings.add(o)):(t=o,o=this.element,l=this.widget()),x.each(t,function(t,e){function i(){if(n||!0!==a.options.disabled&&!x(this).hasClass(\"ui-state-disabled\"))return(\"string\"==typeof e?a[e]:e).apply(a,arguments)}\"string\"!=typeof e&&(i.guid=e.guid=e.guid||i.guid||x.guid++);var s=t.match(\/^([\\w:-]*)\\s*(.*)$\/),t=s[1]+a.eventNamespace,s=s[2];s?l.on(t,s,i):o.on(t,i)})},_off:function(t,e){e=(e||\"\").split(\" \").join(this.eventNamespace+\" \")+this.eventNamespace,t.off(e),this.bindings=x(this.bindings.not(t).get()),this.focusable=x(this.focusable.not(t).get()),this.hoverable=x(this.hoverable.not(t).get())},_delay:function(t,e){var i=this;return setTimeout(function(){return(\"string\"==typeof t?i[t]:t).apply(i,arguments)},e||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){this._addClass(x(t.currentTarget),null,\"ui-state-hover\")},mouseleave:function(t){this._removeClass(x(t.currentTarget),null,\"ui-state-hover\")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){this._addClass(x(t.currentTarget),null,\"ui-state-focus\")},focusout:function(t){this._removeClass(x(t.currentTarget),null,\"ui-state-focus\")}})},_trigger:function(t,e,i){var s,n,o=this.options[t];if(i=i||{},(e=x.Event(e)).type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),e.target=this.element[0],n=e.originalEvent)for(s in n)s in e||(e[s]=n[s]);return this.element.trigger(e,i),!(\"function\"==typeof o&&!1===o.apply(this.element[0],[e].concat(i))||e.isDefaultPrevented())}},x.each({show:\"fadeIn\",hide:\"fadeOut\"},function(o,l){x.Widget.prototype[\"_\"+o]=function(e,t,i){var s,n=(t=\"string\"==typeof t?{effect:t}:t)?!0!==t&&\"number\"!=typeof t&&t.effect||l:o;\"number\"==typeof(t=t||{})?t={duration:t}:!0===t&&(t={}),s=!x.isEmptyObject(t),t.complete=i,t.delay&&e.delay(t.delay),s&&x.effects&&x.effects.effect[n]?e[o](t):n!==o&&e[n]?e[n](t.duration,t.easing,i):e.queue(function(t){x(this)[o](),i&&i.call(e[0]),t()})}});var s,C,E,o,r,u,h,c,k;x.widget;function T(t,e,i){return[parseFloat(t[0])*(c.test(t[0])?e\/100:1),parseFloat(t[1])*(c.test(t[1])?i\/100:1)]}function A(t,e){return parseInt(x.css(t,e),10)||0}function W(t){return null!=t&&t===t.window}C=Math.max,E=Math.abs,o=\/left|center|right\/,r=\/top|center|bottom\/,u=\/[\\+\\-]\\d+(\\.[\\d]+)?%?\/,h=\/^\\w+\/,c=\/%$\/,k=x.fn.position,x.position={scrollbarWidth:function(){if(void 0!==s)return s;var t,e=x(\"<div style='display:block;position:absolute;width:200px;height:200px;overflow:hidden;'><div style='height:300px;width:auto;'><\/div><\/div>\"),i=e.children()[0];return x(\"body\").append(e),t=i.offsetWidth,e.css(\"overflow\",\"scroll\"),t===(i=i.offsetWidth)&&(i=e[0].clientWidth),e.remove(),s=t-i},getScrollInfo:function(t){var e=t.isWindow||t.isDocument?\"\":t.element.css(\"overflow-x\"),i=t.isWindow||t.isDocument?\"\":t.element.css(\"overflow-y\"),e=\"scroll\"===e||\"auto\"===e&&t.width<t.element[0].scrollWidth;return{width:\"scroll\"===i||\"auto\"===i&&t.height<t.element[0].scrollHeight?x.position.scrollbarWidth():0,height:e?x.position.scrollbarWidth():0}},getWithinInfo:function(t){var e=x(t||window),i=W(e[0]),s=!!e[0]&&9===e[0].nodeType;return{element:e,isWindow:i,isDocument:s,offset:!i&&!s?x(t).offset():{left:0,top:0},scrollLeft:e.scrollLeft(),scrollTop:e.scrollTop(),width:e.outerWidth(),height:e.outerHeight()}}},x.fn.position=function(c){if(!c||!c.of)return k.apply(this,arguments);var d,f,m,p,v,t,g=\"string\"==typeof(c=x.extend({},c)).of?x(document).find(c.of):x(c.of),_=x.position.getWithinInfo(c.within),y=x.position.getScrollInfo(_),b=(c.collision||\"flip\").split(\" \"),w={},e=9===(t=(e=g)[0]).nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:W(t)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:t.preventDefault?{width:0,height:0,offset:{top:t.pageY,left:t.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()};return g[0].preventDefault&&(c.at=\"left top\"),f=e.width,m=e.height,v=x.extend({},p=e.offset),x.each([\"my\",\"at\"],function(){var t,e,i=(c[this]||\"\").split(\" \");(i=1===i.length?o.test(i[0])?i.concat([\"center\"]):r.test(i[0])?[\"center\"].concat(i):[\"center\",\"center\"]:i)[0]=o.test(i[0])?i[0]:\"center\",i[1]=r.test(i[1])?i[1]:\"center\",t=u.exec(i[0]),e=u.exec(i[1]),w[this]=[t?t[0]:0,e?e[0]:0],c[this]=[h.exec(i[0])[0],h.exec(i[1])[0]]}),1===b.length&&(b[1]=b[0]),\"right\"===c.at[0]?v.left+=f:\"center\"===c.at[0]&&(v.left+=f\/2),\"bottom\"===c.at[1]?v.top+=m:\"center\"===c.at[1]&&(v.top+=m\/2),d=T(w.at,f,m),v.left+=d[0],v.top+=d[1],this.each(function(){var i,t,l=x(this),a=l.outerWidth(),r=l.outerHeight(),e=A(this,\"marginLeft\"),s=A(this,\"marginTop\"),n=a+e+A(this,\"marginRight\")+y.width,o=r+s+A(this,\"marginBottom\")+y.height,u=x.extend({},v),h=T(w.my,l.outerWidth(),l.outerHeight());\"right\"===c.my[0]?u.left-=a:\"center\"===c.my[0]&&(u.left-=a\/2),\"bottom\"===c.my[1]?u.top-=r:\"center\"===c.my[1]&&(u.top-=r\/2),u.left+=h[0],u.top+=h[1],i={marginLeft:e,marginTop:s},x.each([\"left\",\"top\"],function(t,e){x.ui.position[b[t]]&&x.ui.position[b[t]][e](u,{targetWidth:f,targetHeight:m,elemWidth:a,elemHeight:r,collisionPosition:i,collisionWidth:n,collisionHeight:o,offset:[d[0]+h[0],d[1]+h[1]],my:c.my,at:c.at,within:_,elem:l})}),c.using&&(t=function(t){var e=p.left-u.left,i=e+f-a,s=p.top-u.top,n=s+m-r,o={target:{element:g,left:p.left,top:p.top,width:f,height:m},element:{element:l,left:u.left,top:u.top,width:a,height:r},horizontal:i<0?\"left\":0<e?\"right\":\"center\",vertical:n<0?\"top\":0<s?\"bottom\":\"middle\"};f<a&&E(e+i)<f&&(o.horizontal=\"center\"),m<r&&E(s+n)<m&&(o.vertical=\"middle\"),C(E(e),E(i))>C(E(s),E(n))?o.important=\"horizontal\":o.important=\"vertical\",c.using.call(this,t,o)}),l.offset(x.extend(u,{using:t}))})},x.ui.position={fit:{left:function(t,e){var i=e.within,s=i.isWindow?i.scrollLeft:i.offset.left,n=i.width,o=t.left-e.collisionPosition.marginLeft,l=s-o,a=o+e.collisionWidth-n-s;e.collisionWidth>n?0<l&&a<=0?(i=t.left+l+e.collisionWidth-n-s,t.left+=l-i):t.left=!(0<a&&l<=0)&&a<l?s+n-e.collisionWidth:s:0<l?t.left+=l:0<a?t.left-=a:t.left=C(t.left-o,t.left)},top:function(t,e){var i=e.within,s=i.isWindow?i.scrollTop:i.offset.top,n=e.within.height,o=t.top-e.collisionPosition.marginTop,l=s-o,a=o+e.collisionHeight-n-s;e.collisionHeight>n?0<l&&a<=0?(i=t.top+l+e.collisionHeight-n-s,t.top+=l-i):t.top=!(0<a&&l<=0)&&a<l?s+n-e.collisionHeight:s:0<l?t.top+=l:0<a?t.top-=a:t.top=C(t.top-o,t.top)}},flip:{left:function(t,e){var i=e.within,s=i.offset.left+i.scrollLeft,n=i.width,o=i.isWindow?i.scrollLeft:i.offset.left,l=t.left-e.collisionPosition.marginLeft,a=l-o,r=l+e.collisionWidth-n-o,u=\"left\"===e.my[0]?-e.elemWidth:\"right\"===e.my[0]?e.elemWidth:0,i=\"left\"===e.at[0]?e.targetWidth:\"right\"===e.at[0]?-e.targetWidth:0,l=-2*e.offset[0];a<0?((s=t.left+u+i+l+e.collisionWidth-n-s)<0||s<E(a))&&(t.left+=u+i+l):0<r&&(0<(o=t.left-e.collisionPosition.marginLeft+u+i+l-o)||E(o)<r)&&(t.left+=u+i+l)},top:function(t,e){var i=e.within,s=i.offset.top+i.scrollTop,n=i.height,o=i.isWindow?i.scrollTop:i.offset.top,l=t.top-e.collisionPosition.marginTop,a=l-o,r=l+e.collisionHeight-n-o,u=\"top\"===e.my[1]?-e.elemHeight:\"bottom\"===e.my[1]?e.elemHeight:0,i=\"top\"===e.at[1]?e.targetHeight:\"bottom\"===e.at[1]?-e.targetHeight:0,l=-2*e.offset[1];a<0?((s=t.top+u+i+l+e.collisionHeight-n-s)<0||s<E(a))&&(t.top+=u+i+l):0<r&&(0<(o=t.top-e.collisionPosition.marginTop+u+i+l-o)||E(o)<r)&&(t.top+=u+i+l)}},flipfit:{left:function(){x.ui.position.flip.left.apply(this,arguments),x.ui.position.fit.left.apply(this,arguments)},top:function(){x.ui.position.flip.top.apply(this,arguments),x.ui.position.fit.top.apply(this,arguments)}}};var t;x.ui.position,x.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},x.fn.extend({uniqueId:(t=0,function(){return this.each(function(){this.id||(this.id=\"ui-id-\"+ ++t)})}),removeUniqueId:function(){return this.each(function(){\/^ui-id-\\d+$\/.test(this.id)&&x(this).removeAttr(\"id\")})}}),x.ui.safeActiveElement=function(e){var i;try{i=e.activeElement}catch(t){i=e.body}return i=!(i=i||e.body).nodeName?e.body:i},x.widget(\"ui.menu\",{version:\"1.13.2\",defaultElement:\"<ul>\",delay:300,options:{icons:{submenu:\"ui-icon-caret-1-e\"},items:\"> *\",menus:\"ul\",position:{my:\"left top\",at:\"right top\"},role:\"menu\",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.lastMousePosition={x:null,y:null},this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass(\"ui-menu\",\"ui-widget ui-widget-content\"),this._on({\"mousedown .ui-menu-item\":function(t){t.preventDefault(),this._activateItem(t)},\"click .ui-menu-item\":function(t){var e=x(t.target),i=x(x.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&e.not(\".ui-state-disabled\").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),e.has(\".ui-menu\").length?this.expand(t):!this.element.is(\":focus\")&&i.closest(\".ui-menu\").length&&(this.element.trigger(\"focus\",[!0]),this.active&&1===this.active.parents(\".ui-menu\").length&&clearTimeout(this.timer)))},\"mouseenter .ui-menu-item\":\"_activateItem\",\"mousemove .ui-menu-item\":\"_activateItem\",mouseleave:\"collapseAll\",\"mouseleave .ui-menu\":\"collapseAll\",focus:function(t,e){var i=this.active||this._menuItems().first();e||this.focus(t,i)},blur:function(t){this._delay(function(){x.contains(this.element[0],x.ui.safeActiveElement(this.document[0]))||this.collapseAll(t)})},keydown:\"_keydown\"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t,!0),this.mouseHandled=!1}})},_activateItem:function(t){var e,i;this.previousFilter||t.clientX===this.lastMousePosition.x&&t.clientY===this.lastMousePosition.y||(this.lastMousePosition={x:t.clientX,y:t.clientY},e=x(t.target).closest(\".ui-menu-item\"),i=x(t.currentTarget),e[0]===i[0]&&(i.is(\".ui-state-active\")||(this._removeClass(i.siblings().children(\".ui-state-active\"),null,\"ui-state-active\"),this.focus(t,i))))},_destroy:function(){var t=this.element.find(\".ui-menu-item\").removeAttr(\"role aria-disabled\").children(\".ui-menu-item-wrapper\").removeUniqueId().removeAttr(\"tabIndex role aria-haspopup\");this.element.removeAttr(\"aria-activedescendant\").find(\".ui-menu\").addBack().removeAttr(\"role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex\").removeUniqueId().show(),t.children().each(function(){var t=x(this);t.data(\"ui-menu-submenu-caret\")&&t.remove()})},_keydown:function(t){var e,i,s,n=!0;switch(t.keyCode){case x.ui.keyCode.PAGE_UP:this.previousPage(t);break;case x.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case x.ui.keyCode.HOME:this._move(\"first\",\"first\",t);break;case x.ui.keyCode.END:this._move(\"last\",\"last\",t);break;case x.ui.keyCode.UP:this.previous(t);break;case x.ui.keyCode.DOWN:this.next(t);break;case x.ui.keyCode.LEFT:this.collapse(t);break;case x.ui.keyCode.RIGHT:this.active&&!this.active.is(\".ui-state-disabled\")&&this.expand(t);break;case x.ui.keyCode.ENTER:case x.ui.keyCode.SPACE:this._activate(t);break;case x.ui.keyCode.ESCAPE:this.collapse(t);break;default:e=this.previousFilter||\"\",s=n=!1,i=96<=t.keyCode&&t.keyCode<=105?(t.keyCode-96).toString():String.fromCharCode(t.keyCode),clearTimeout(this.filterTimer),i===e?s=!0:i=e+i,e=this._filterMenuItems(i),(e=s&&-1!==e.index(this.active.next())?this.active.nextAll(\".ui-menu-item\"):e).length||(i=String.fromCharCode(t.keyCode),e=this._filterMenuItems(i)),e.length?(this.focus(t,e),this.previousFilter=i,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}n&&t.preventDefault()},_activate:function(t){this.active&&!this.active.is(\".ui-state-disabled\")&&(this.active.children(\"[aria-haspopup='true']\").length?this.expand(t):this.select(t))},refresh:function(){var t,e,s=this,n=this.options.icons.submenu,i=this.element.find(this.options.menus);this._toggleClass(\"ui-menu-icons\",null,!!this.element.find(\".ui-icon\").length),e=i.filter(\":not(.ui-menu)\").hide().attr({role:this.options.role,\"aria-hidden\":\"true\",\"aria-expanded\":\"false\"}).each(function(){var t=x(this),e=t.prev(),i=x(\"<span>\").data(\"ui-menu-submenu-caret\",!0);s._addClass(i,\"ui-menu-icon\",\"ui-icon \"+n),e.attr(\"aria-haspopup\",\"true\").prepend(i),t.attr(\"aria-labelledby\",e.attr(\"id\"))}),this._addClass(e,\"ui-menu\",\"ui-widget ui-widget-content ui-front\"),(t=i.add(this.element).find(this.options.items)).not(\".ui-menu-item\").each(function(){var t=x(this);s._isDivider(t)&&s._addClass(t,\"ui-menu-divider\",\"ui-widget-content\")}),i=(e=t.not(\".ui-menu-item, .ui-menu-divider\")).children().not(\".ui-menu\").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(e,\"ui-menu-item\")._addClass(i,\"ui-menu-item-wrapper\"),t.filter(\".ui-state-disabled\").attr(\"aria-disabled\",\"true\"),this.active&&!x.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:\"menuitem\",listbox:\"option\"}[this.options.role]},_setOption:function(t,e){var i;\"icons\"===t&&(i=this.element.find(\".ui-menu-icon\"),this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr(\"aria-disabled\",String(t)),this._toggleClass(null,\"ui-state-disabled\",!!t)},focus:function(t,e){var i;this.blur(t,t&&\"focus\"===t.type),this._scrollIntoView(e),this.active=e.first(),i=this.active.children(\".ui-menu-item-wrapper\"),this._addClass(i,null,\"ui-state-active\"),this.options.role&&this.element.attr(\"aria-activedescendant\",i.attr(\"id\")),i=this.active.parent().closest(\".ui-menu-item\").children(\".ui-menu-item-wrapper\"),this._addClass(i,null,\"ui-state-active\"),t&&\"keydown\"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),(i=e.children(\".ui-menu\")).length&&t&&\/^mouse\/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger(\"focus\",t,{item:e})},_scrollIntoView:function(t){var e,i,s;this._hasScroll()&&(i=parseFloat(x.css(this.activeMenu[0],\"borderTopWidth\"))||0,s=parseFloat(x.css(this.activeMenu[0],\"paddingTop\"))||0,e=t.offset().top-this.activeMenu.offset().top-i-s,i=this.activeMenu.scrollTop(),s=this.activeMenu.height(),t=t.outerHeight(),e<0?this.activeMenu.scrollTop(i+e):s<e+t&&this.activeMenu.scrollTop(i+e-s+t))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(\".ui-menu-item-wrapper\"),null,\"ui-state-active\"),this._trigger(\"blur\",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),\"true\"===t.attr(\"aria-hidden\")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(t){var e=x.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(\".ui-menu\").not(t.parents(\".ui-menu\")).hide().attr(\"aria-hidden\",\"true\"),t.show().removeAttr(\"aria-hidden\").attr(\"aria-expanded\",\"true\").position(e)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var t=i?this.element:x(e&&e.target).closest(this.element.find(\".ui-menu\"));t.length||(t=this.element),this._close(t),this.blur(e),this._removeClass(t.find(\".ui-state-active\"),null,\"ui-state-active\"),this.activeMenu=t},i?0:this.delay)},_close:function(t){(t=t||(this.active?this.active.parent():this.element)).find(\".ui-menu\").hide().attr(\"aria-hidden\",\"true\").attr(\"aria-expanded\",\"false\")},_closeOnDocumentClick:function(t){return!x(t.target).closest(\".ui-menu\").length},_isDivider:function(t){return!\/[^\\-\\u2014\\u2013\\s]\/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(\".ui-menu-item\",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this._menuItems(this.active.children(\".ui-menu\")).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move(\"next\",\"first\",t)},previous:function(t){this._move(\"prev\",\"last\",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(\".ui-menu-item\").length},isLastItem:function(){return this.active&&!this.active.nextAll(\".ui-menu-item\").length},_menuItems:function(t){return(t||this.element).find(this.options.items).filter(\".ui-menu-item\")},_move:function(t,e,i){var s;(s=this.active?\"first\"===t||\"last\"===t?this.active[\"first\"===t?\"prevAll\":\"nextAll\"](\".ui-menu-item\").last():this.active[t+\"All\"](\".ui-menu-item\").first():s)&&s.length&&this.active||(s=this._menuItems(this.activeMenu)[e]()),this.focus(i,s)},nextPage:function(t){var e,i,s;this.active?this.isLastItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===x.fn.jquery.indexOf(\"3.2.\")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.nextAll(\".ui-menu-item\").each(function(){return(e=x(this)).offset().top-i-s<0}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu)[this.active?\"last\":\"first\"]())):this.next(t)},previousPage:function(t){var e,i,s;this.active?this.isFirstItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===x.fn.jquery.indexOf(\"3.2.\")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.prevAll(\".ui-menu-item\").each(function(){return 0<(e=x(this)).offset().top-i+s}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu).first())):this.next(t)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop(\"scrollHeight\")},select:function(t){this.active=this.active||x(t.target).closest(\".ui-menu-item\");var e={item:this.active};this.active.has(\".ui-menu\").length||this.collapseAll(t,!0),this._trigger(\"select\",t,e)},_filterMenuItems:function(t){var t=t.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]\/g,\"\\\\$&\"),e=new RegExp(\"^\"+t,\"i\");return this.activeMenu.find(this.options.items).filter(\".ui-menu-item\").filter(function(){return e.test(String.prototype.trim.call(x(this).children(\".ui-menu-item-wrapper\").text()))})}});x.widget(\"ui.autocomplete\",{version:\"1.13.2\",defaultElement:\"<input>\",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:\"left top\",at:\"left bottom\",collision:\"none\"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,liveRegionTimer:null,_create:function(){var i,s,n,t=this.element[0].nodeName.toLowerCase(),e=\"textarea\"===t,t=\"input\"===t;this.isMultiLine=e||!t&&this._isContentEditable(this.element),this.valueMethod=this.element[e||t?\"val\":\"text\"],this.isNewMenu=!0,this._addClass(\"ui-autocomplete-input\"),this.element.attr(\"autocomplete\",\"off\"),this._on(this.element,{keydown:function(t){if(this.element.prop(\"readOnly\"))s=n=i=!0;else{s=n=i=!1;var e=x.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:i=!0,this._move(\"previousPage\",t);break;case e.PAGE_DOWN:i=!0,this._move(\"nextPage\",t);break;case e.UP:i=!0,this._keyEvent(\"previous\",t);break;case e.DOWN:i=!0,this._keyEvent(\"next\",t);break;case e.ENTER:this.menu.active&&(i=!0,t.preventDefault(),this.menu.select(t));break;case e.TAB:this.menu.active&&this.menu.select(t);break;case e.ESCAPE:this.menu.element.is(\":visible\")&&(this.isMultiLine||this._value(this.term),this.close(t),t.preventDefault());break;default:s=!0,this._searchTimeout(t)}}},keypress:function(t){if(i)return i=!1,void(this.isMultiLine&&!this.menu.element.is(\":visible\")||t.preventDefault());if(!s){var e=x.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:this._move(\"previousPage\",t);break;case e.PAGE_DOWN:this._move(\"nextPage\",t);break;case e.UP:this._keyEvent(\"previous\",t);break;case e.DOWN:this._keyEvent(\"next\",t)}}},input:function(t){if(n)return n=!1,void t.preventDefault();this._searchTimeout(t)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){clearTimeout(this.searching),this.close(t),this._change(t)}}),this._initSource(),this.menu=x(\"<ul>\").appendTo(this._appendTo()).menu({role:null}).hide().attr({unselectable:\"on\"}).menu(\"instance\"),this._addClass(this.menu.element,\"ui-autocomplete\",\"ui-front\"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault()},menufocus:function(t,e){var i,s;if(this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&\/^mouse\/.test(t.originalEvent.type)))return this.menu.blur(),void this.document.one(\"mousemove\",function(){x(t.target).trigger(t.originalEvent)});s=e.item.data(\"ui-autocomplete-item\"),!1!==this._trigger(\"focus\",t,{item:s})&&t.originalEvent&&\/^key\/.test(t.originalEvent.type)&&this._value(s.value),(i=e.item.attr(\"aria-label\")||s.value)&&String.prototype.trim.call(i).length&&(clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(x(\"<div>\").text(i))},100))},menuselect:function(t,e){var i=e.item.data(\"ui-autocomplete-item\"),s=this.previous;this.element[0]!==x.ui.safeActiveElement(this.document[0])&&(this.element.trigger(\"focus\"),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger(\"select\",t,{item:i})&&this._value(i.value),this.term=this._value(),this.close(t),this.selectedItem=i}}),this.liveRegion=x(\"<div>\",{role:\"status\",\"aria-live\":\"assertive\",\"aria-relevant\":\"additions\"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,\"ui-helper-hidden-accessible\"),this._on(this.window,{beforeunload:function(){this.element.removeAttr(\"autocomplete\")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr(\"autocomplete\"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),\"source\"===t&&this._initSource(),\"appendTo\"===t&&this.menu.element.appendTo(this._appendTo()),\"disabled\"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(t){var e=this.menu.element[0];return t.target===this.element[0]||t.target===e||x.contains(e,t.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var t=this.options.appendTo;return t=!(t=!(t=t&&(t.jquery||t.nodeType?x(t):this.document.find(t).eq(0)))||!t[0]?this.element.closest(\".ui-front, dialog\"):t).length?this.document[0].body:t},_initSource:function(){var i,s,n=this;Array.isArray(this.options.source)?(i=this.options.source,this.source=function(t,e){e(x.ui.autocomplete.filter(i,t.term))}):\"string\"==typeof this.options.source?(s=this.options.source,this.source=function(t,e){n.xhr&&n.xhr.abort(),n.xhr=x.ajax({url:s,data:t,dataType:\"json\",success:function(t){e(t)},error:function(){e([])}})}):this.source=this.options.source},_searchTimeout:function(s){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),e=this.menu.element.is(\":visible\"),i=s.altKey||s.ctrlKey||s.metaKey||s.shiftKey;t&&(e||i)||(this.selectedItem=null,this.search(null,s))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):!1!==this._trigger(\"search\",e)?this._search(t):void 0},_search:function(t){this.pending++,this._addClass(\"ui-autocomplete-loading\"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass(\"ui-autocomplete-loading\")}.bind(this)},__response:function(t){t=t&&this._normalize(t),this._trigger(\"response\",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger(\"open\")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,\"mousedown\"),this.menu.element.is(\":visible\")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger(\"close\",t))},_change:function(t){this.previous!==this._value()&&this._trigger(\"change\",t,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:x.map(t,function(t){return\"string\"==typeof t?{label:t,value:t}:x.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var e=this.menu.element.empty();this._renderMenu(e,t),this.isNewMenu=!0,this.menu.refresh(),e.show(),this._resizeMenu(),e.position(x.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:\"_closeOnClickOutside\"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width(\"\").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(i,t){var s=this;x.each(t,function(t,e){s._renderItemData(i,e)})},_renderItemData:function(t,e){return this._renderItem(t,e).data(\"ui-autocomplete-item\",e)},_renderItem:function(t,e){return x(\"<li>\").append(x(\"<div>\").text(e.label)).appendTo(t)},_move:function(t,e){if(this.menu.element.is(\":visible\"))return this.menu.isFirstItem()&&\/^previous\/.test(t)||this.menu.isLastItem()&&\/^next\/.test(t)?(this.isMultiLine||this._value(this.term),void this.menu.blur()):void this.menu[t](e);this.search(null,e)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){this.isMultiLine&&!this.menu.element.is(\":visible\")||(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop(\"contentEditable\");return\"inherit\"===e?this._isContentEditable(t.parent()):\"true\"===e}}),x.extend(x.ui.autocomplete,{escapeRegex:function(t){return t.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]\/g,\"\\\\$&\")},filter:function(t,e){var i=new RegExp(x.ui.autocomplete.escapeRegex(e),\"i\");return x.grep(t,function(t){return i.test(t.label||t.value||t)})}}),x.widget(\"ui.autocomplete\",x.ui.autocomplete,{options:{messages:{noResults:\"No search results.\",results:function(t){return t+(1<t?\" results are\":\" result is\")+\" available, use up and down arrow keys to navigate.\"}}},__response:function(t){var e;this._superApply(arguments),this.options.disabled||this.cancelSearch||(e=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(x(\"<div>\").text(e))},100))}});x.ui.autocomplete});\n\\ No newline at end of file\n+!function(t){\"use strict\";\"function\"==typeof define&&define.amd?define([\"jquery\"],t):t(jQuery)}(function(x){\"use strict\";x.ui=x.ui||{};x.ui.version=\"1.13.1\";var n,i=0,l=Array.prototype.hasOwnProperty,a=Array.prototype.slice;x.cleanData=(n=x.cleanData,function(t){for(var e,i,s=0;null!=(i=t[s]);s++)(e=x._data(i,\"events\"))&&e.remove&&x(i).triggerHandler(\"remove\");n(t)}),x.widget=function(t,i,e){var s,n,o,l={},a=t.split(\".\")[0],r=a+\"-\"+(t=t.split(\".\")[1]);return e||(e=i,i=x.Widget),Array.isArray(e)&&(e=x.extend.apply(null,[{}].concat(e))),x.expr.pseudos[r.toLowerCase()]=function(t){return!!x.data(t,r)},x[a]=x[a]||{},s=x[a][t],n=x[a][t]=function(t,e){if(!this||!this._createWidget)return new n(t,e);arguments.length&&this._createWidget(t,e)},x.extend(n,s,{version:e.version,_proto:x.extend({},e),_childConstructors:[]}),(o=new i).options=x.widget.extend({},o.options),x.each(e,function(e,s){function n(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}l[e]=\"function\"==typeof s?function(){var t,e=this._super,i=this._superApply;return this._super=n,this._superApply=o,t=s.apply(this,arguments),this._super=e,this._superApply=i,t}:s}),n.prototype=x.widget.extend(o,{widgetEventPrefix:s&&o.widgetEventPrefix||t},l,{constructor:n,namespace:a,widgetName:t,widgetFullName:r}),s?(x.each(s._childConstructors,function(t,e){var i=e.prototype;x.widget(i.namespace+\".\"+i.widgetName,n,e._proto)}),delete s._childConstructors):i._childConstructors.push(n),x.widget.bridge(t,n),n},x.widget.extend=function(t){for(var e,i,s=a.call(arguments,1),n=0,o=s.length;n<o;n++)for(e in s[n])i=s[n][e],l.call(s[n],e)&&void 0!==i&&(x.isPlainObject(i)?t[e]=x.isPlainObject(t[e])?x.widget.extend({},t[e],i):x.widget.extend({},i):t[e]=i);return t},x.widget.bridge=function(o,e){var l=e.prototype.widgetFullName||o;x.fn[o]=function(i){var t=\"string\"==typeof i,s=a.call(arguments,1),n=this;return t?this.length||\"instance\"!==i?this.each(function(){var t,e=x.data(this,l);return\"instance\"===i?(n=e,!1):e?\"function\"!=typeof e[i]||\"_\"===i.charAt(0)?x.error(\"no such method '\"+i+\"' for \"+o+\" widget instance\"):(t=e[i].apply(e,s))!==e&&void 0!==t?(n=t&&t.jquery?n.pushStack(t.get()):t,!1):void 0:x.error(\"cannot call methods on \"+o+\" prior to initialization; attempted to call method '\"+i+\"'\")}):n=void 0:(s.length&&(i=x.widget.extend.apply(null,[i].concat(s))),this.each(function(){var t=x.data(this,l);t?(t.option(i||{}),t._init&&t._init()):x.data(this,l,new e(i,this))})),n}},x.Widget=function(){},x.Widget._childConstructors=[],x.Widget.prototype={widgetName:\"widget\",widgetEventPrefix:\"\",defaultElement:\"<div>\",options:{classes:{},disabled:!1,create:null},_createWidget:function(t,e){e=x(e||this.defaultElement||this)[0],this.element=x(e),this.uuid=i++,this.eventNamespace=\".\"+this.widgetName+this.uuid,this.bindings=x(),this.hoverable=x(),this.focusable=x(),this.classesElementLookup={},e!==this&&(x.data(e,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===e&&this.destroy()}}),this.document=x(e.style?e.ownerDocument:e.document||e),this.window=x(this.document[0].defaultView||this.document[0].parentWindow)),this.options=x.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger(\"create\",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:x.noop,_create:x.noop,_init:x.noop,destroy:function(){var i=this;this._destroy(),x.each(this.classesElementLookup,function(t,e){i._removeClass(e,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr(\"aria-disabled\"),this.bindings.off(this.eventNamespace)},_destroy:x.noop,widget:function(){return this.element},option:function(t,e){var i,s,n,o=t;if(0===arguments.length)return x.widget.extend({},this.options);if(\"string\"==typeof t)if(o={},t=(i=t.split(\".\")).shift(),i.length){for(s=o[t]=x.widget.extend({},this.options[t]),n=0;n<i.length-1;n++)s[i[n]]=s[i[n]]||{},s=s[i[n]];if(t=i.pop(),1===arguments.length)return void 0===s[t]?null:s[t];s[t]=e}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=e}return this._setOptions(o),this},_setOptions:function(t){for(var e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return\"classes\"===t&&this._setOptionClasses(e),this.options[t]=e,\"disabled\"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(t){var e,i,s;for(e in t)s=this.classesElementLookup[e],t[e]!==this.options.classes[e]&&s&&s.length&&(i=x(s.get()),this._removeClass(s,e),i.addClass(this._classes({element:i,keys:e,classes:t,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+\"-disabled\",null,!!t),t&&(this._removeClass(this.hoverable,null,\"ui-state-hover\"),this._removeClass(this.focusable,null,\"ui-state-focus\"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(n){var o=[],l=this;function t(t,e){for(var i,s=0;s<t.length;s++)i=l.classesElementLookup[t[s]]||x(),i=n.add?(function(){var i=[];n.element.each(function(t,e){x.map(l.classesElementLookup,function(t){return t}).some(function(t){return t.is(e)})||i.push(e)}),l._on(x(i),{remove:\"_untrackClassesElement\"})}(),x(x.uniqueSort(i.get().concat(n.element.get())))):x(i.not(n.element).get()),l.classesElementLookup[t[s]]=i,o.push(t[s]),e&&n.classes[t[s]]&&o.push(n.classes[t[s]])}return(n=x.extend({element:this.element,classes:this.options.classes||{}},n)).keys&&t(n.keys.match(\/\\S+\/g)||[],!0),n.extra&&t(n.extra.match(\/\\S+\/g)||[]),o.join(\" \")},_untrackClassesElement:function(i){var s=this;x.each(s.classesElementLookup,function(t,e){-1!==x.inArray(i.target,e)&&(s.classesElementLookup[t]=x(e.not(i.target).get()))}),this._off(x(i.target))},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){var n=\"string\"==typeof t||null===t,i={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s=\"boolean\"==typeof s?s:i};return i.element.toggleClass(this._classes(i),s),this},_on:function(n,o,t){var l,a=this;\"boolean\"!=typeof n&&(t=o,o=n,n=!1),t?(o=l=x(o),this.bindings=this.bindings.add(o)):(t=o,o=this.element,l=this.widget()),x.each(t,function(t,e){function i(){if(n||!0!==a.options.disabled&&!x(this).hasClass(\"ui-state-disabled\"))return(\"string\"==typeof e?a[e]:e).apply(a,arguments)}\"string\"!=typeof e&&(i.guid=e.guid=e.guid||i.guid||x.guid++);var s=t.match(\/^([\\w:-]*)\\s*(.*)$\/),t=s[1]+a.eventNamespace,s=s[2];s?l.on(t,s,i):o.on(t,i)})},_off:function(t,e){e=(e||\"\").split(\" \").join(this.eventNamespace+\" \")+this.eventNamespace,t.off(e),this.bindings=x(this.bindings.not(t).get()),this.focusable=x(this.focusable.not(t).get()),this.hoverable=x(this.hoverable.not(t).get())},_delay:function(t,e){var i=this;return setTimeout(function(){return(\"string\"==typeof t?i[t]:t).apply(i,arguments)},e||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){this._addClass(x(t.currentTarget),null,\"ui-state-hover\")},mouseleave:function(t){this._removeClass(x(t.currentTarget),null,\"ui-state-hover\")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){this._addClass(x(t.currentTarget),null,\"ui-state-focus\")},focusout:function(t){this._removeClass(x(t.currentTarget),null,\"ui-state-focus\")}})},_trigger:function(t,e,i){var s,n,o=this.options[t];if(i=i||{},(e=x.Event(e)).type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),e.target=this.element[0],n=e.originalEvent)for(s in n)s in e||(e[s]=n[s]);return this.element.trigger(e,i),!(\"function\"==typeof o&&!1===o.apply(this.element[0],[e].concat(i))||e.isDefaultPrevented())}},x.each({show:\"fadeIn\",hide:\"fadeOut\"},function(o,l){x.Widget.prototype[\"_\"+o]=function(e,t,i){var s,n=(t=\"string\"==typeof t?{effect:t}:t)?!0!==t&&\"number\"!=typeof t&&t.effect||l:o;\"number\"==typeof(t=t||{})?t={duration:t}:!0===t&&(t={}),s=!x.isEmptyObject(t),t.complete=i,t.delay&&e.delay(t.delay),s&&x.effects&&x.effects.effect[n]?e[o](t):n!==o&&e[n]?e[n](t.duration,t.easing,i):e.queue(function(t){x(this)[o](),i&&i.call(e[0]),t()})}});var s,C,E,o,r,u,h,c,k;x.widget;function T(t,e,i){return[parseFloat(t[0])*(c.test(t[0])?e\/100:1),parseFloat(t[1])*(c.test(t[1])?i\/100:1)]}function A(t,e){return parseInt(x.css(t,e),10)||0}function W(t){return null!=t&&t===t.window}C=Math.max,E=Math.abs,o=\/left|center|right\/,r=\/top|center|bottom\/,u=\/[\\+\\-]\\d+(\\.[\\d]+)?%?\/,h=\/^\\w+\/,c=\/%$\/,k=x.fn.position,x.position={scrollbarWidth:function(){if(void 0!==s)return s;var t,e=x(\"<div style='display:block;position:absolute;width:200px;height:200px;overflow:hidden;'><div style='height:300px;width:auto;'><\/div><\/div>\"),i=e.children()[0];return x(\"body\").append(e),t=i.offsetWidth,e.css(\"overflow\",\"scroll\"),t===(i=i.offsetWidth)&&(i=e[0].clientWidth),e.remove(),s=t-i},getScrollInfo:function(t){var e=t.isWindow||t.isDocument?\"\":t.element.css(\"overflow-x\"),i=t.isWindow||t.isDocument?\"\":t.element.css(\"overflow-y\"),e=\"scroll\"===e||\"auto\"===e&&t.width<t.element[0].scrollWidth;return{width:\"scroll\"===i||\"auto\"===i&&t.height<t.element[0].scrollHeight?x.position.scrollbarWidth():0,height:e?x.position.scrollbarWidth():0}},getWithinInfo:function(t){var e=x(t||window),i=W(e[0]),s=!!e[0]&&9===e[0].nodeType;return{element:e,isWindow:i,isDocument:s,offset:!i&&!s?x(t).offset():{left:0,top:0},scrollLeft:e.scrollLeft(),scrollTop:e.scrollTop(),width:e.outerWidth(),height:e.outerHeight()}}},x.fn.position=function(c){if(!c||!c.of)return k.apply(this,arguments);var d,f,m,p,v,t,g=\"string\"==typeof(c=x.extend({},c)).of?x(document).find(c.of):x(c.of),_=x.position.getWithinInfo(c.within),y=x.position.getScrollInfo(_),b=(c.collision||\"flip\").split(\" \"),w={},e=9===(t=(e=g)[0]).nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:W(t)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:t.preventDefault?{width:0,height:0,offset:{top:t.pageY,left:t.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()};return g[0].preventDefault&&(c.at=\"left top\"),f=e.width,m=e.height,v=x.extend({},p=e.offset),x.each([\"my\",\"at\"],function(){var t,e,i=(c[this]||\"\").split(\" \");(i=1===i.length?o.test(i[0])?i.concat([\"center\"]):r.test(i[0])?[\"center\"].concat(i):[\"center\",\"center\"]:i)[0]=o.test(i[0])?i[0]:\"center\",i[1]=r.test(i[1])?i[1]:\"center\",t=u.exec(i[0]),e=u.exec(i[1]),w[this]=[t?t[0]:0,e?e[0]:0],c[this]=[h.exec(i[0])[0],h.exec(i[1])[0]]}),1===b.length&&(b[1]=b[0]),\"right\"===c.at[0]?v.left+=f:\"center\"===c.at[0]&&(v.left+=f\/2),\"bottom\"===c.at[1]?v.top+=m:\"center\"===c.at[1]&&(v.top+=m\/2),d=T(w.at,f,m),v.left+=d[0],v.top+=d[1],this.each(function(){var i,t,l=x(this),a=l.outerWidth(),r=l.outerHeight(),e=A(this,\"marginLeft\"),s=A(this,\"marginTop\"),n=a+e+A(this,\"marginRight\")+y.width,o=r+s+A(this,\"marginBottom\")+y.height,u=x.extend({},v),h=T(w.my,l.outerWidth(),l.outerHeight());\"right\"===c.my[0]?u.left-=a:\"center\"===c.my[0]&&(u.left-=a\/2),\"bottom\"===c.my[1]?u.top-=r:\"center\"===c.my[1]&&(u.top-=r\/2),u.left+=h[0],u.top+=h[1],i={marginLeft:e,marginTop:s},x.each([\"left\",\"top\"],function(t,e){x.ui.position[b[t]]&&x.ui.position[b[t]][e](u,{targetWidth:f,targetHeight:m,elemWidth:a,elemHeight:r,collisionPosition:i,collisionWidth:n,collisionHeight:o,offset:[d[0]+h[0],d[1]+h[1]],my:c.my,at:c.at,within:_,elem:l})}),c.using&&(t=function(t){var e=p.left-u.left,i=e+f-a,s=p.top-u.top,n=s+m-r,o={target:{element:g,left:p.left,top:p.top,width:f,height:m},element:{element:l,left:u.left,top:u.top,width:a,height:r},horizontal:i<0?\"left\":0<e?\"right\":\"center\",vertical:n<0?\"top\":0<s?\"bottom\":\"middle\"};f<a&&E(e+i)<f&&(o.horizontal=\"center\"),m<r&&E(s+n)<m&&(o.vertical=\"middle\"),C(E(e),E(i))>C(E(s),E(n))?o.important=\"horizontal\":o.important=\"vertical\",c.using.call(this,t,o)}),l.offset(x.extend(u,{using:t}))})},x.ui.position={fit:{left:function(t,e){var i=e.within,s=i.isWindow?i.scrollLeft:i.offset.left,n=i.width,o=t.left-e.collisionPosition.marginLeft,l=s-o,a=o+e.collisionWidth-n-s;e.collisionWidth>n?0<l&&a<=0?(i=t.left+l+e.collisionWidth-n-s,t.left+=l-i):t.left=!(0<a&&l<=0)&&a<l?s+n-e.collisionWidth:s:0<l?t.left+=l:0<a?t.left-=a:t.left=C(t.left-o,t.left)},top:function(t,e){var i=e.within,s=i.isWindow?i.scrollTop:i.offset.top,n=e.within.height,o=t.top-e.collisionPosition.marginTop,l=s-o,a=o+e.collisionHeight-n-s;e.collisionHeight>n?0<l&&a<=0?(i=t.top+l+e.collisionHeight-n-s,t.top+=l-i):t.top=!(0<a&&l<=0)&&a<l?s+n-e.collisionHeight:s:0<l?t.top+=l:0<a?t.top-=a:t.top=C(t.top-o,t.top)}},flip:{left:function(t,e){var i=e.within,s=i.offset.left+i.scrollLeft,n=i.width,o=i.isWindow?i.scrollLeft:i.offset.left,l=t.left-e.collisionPosition.marginLeft,a=l-o,r=l+e.collisionWidth-n-o,u=\"left\"===e.my[0]?-e.elemWidth:\"right\"===e.my[0]?e.elemWidth:0,i=\"left\"===e.at[0]?e.targetWidth:\"right\"===e.at[0]?-e.targetWidth:0,l=-2*e.offset[0];a<0?((s=t.left+u+i+l+e.collisionWidth-n-s)<0||s<E(a))&&(t.left+=u+i+l):0<r&&(0<(o=t.left-e.collisionPosition.marginLeft+u+i+l-o)||E(o)<r)&&(t.left+=u+i+l)},top:function(t,e){var i=e.within,s=i.offset.top+i.scrollTop,n=i.height,o=i.isWindow?i.scrollTop:i.offset.top,l=t.top-e.collisionPosition.marginTop,a=l-o,r=l+e.collisionHeight-n-o,u=\"top\"===e.my[1]?-e.elemHeight:\"bottom\"===e.my[1]?e.elemHeight:0,i=\"top\"===e.at[1]?e.targetHeight:\"bottom\"===e.at[1]?-e.targetHeight:0,l=-2*e.offset[1];a<0?((s=t.top+u+i+l+e.collisionHeight-n-s)<0||s<E(a))&&(t.top+=u+i+l):0<r&&(0<(o=t.top-e.collisionPosition.marginTop+u+i+l-o)||E(o)<r)&&(t.top+=u+i+l)}},flipfit:{left:function(){x.ui.position.flip.left.apply(this,arguments),x.ui.position.fit.left.apply(this,arguments)},top:function(){x.ui.position.flip.top.apply(this,arguments),x.ui.position.fit.top.apply(this,arguments)}}};var t;x.ui.position,x.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},x.fn.extend({uniqueId:(t=0,function(){return this.each(function(){this.id||(this.id=\"ui-id-\"+ ++t)})}),removeUniqueId:function(){return this.each(function(){\/^ui-id-\\d+$\/.test(this.id)&&x(this).removeAttr(\"id\")})}}),x.ui.safeActiveElement=function(e){var i;try{i=e.activeElement}catch(t){i=e.body}return i=!(i=i||e.body).nodeName?e.body:i},x.widget(\"ui.menu\",{version:\"1.13.1\",defaultElement:\"<ul>\",delay:300,options:{icons:{submenu:\"ui-icon-caret-1-e\"},items:\"> *\",menus:\"ul\",position:{my:\"left top\",at:\"right top\"},role:\"menu\",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.lastMousePosition={x:null,y:null},this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass(\"ui-menu\",\"ui-widget ui-widget-content\"),this._on({\"mousedown .ui-menu-item\":function(t){t.preventDefault(),this._activateItem(t)},\"click .ui-menu-item\":function(t){var e=x(t.target),i=x(x.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&e.not(\".ui-state-disabled\").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),e.has(\".ui-menu\").length?this.expand(t):!this.element.is(\":focus\")&&i.closest(\".ui-menu\").length&&(this.element.trigger(\"focus\",[!0]),this.active&&1===this.active.parents(\".ui-menu\").length&&clearTimeout(this.timer)))},\"mouseenter .ui-menu-item\":\"_activateItem\",\"mousemove .ui-menu-item\":\"_activateItem\",mouseleave:\"collapseAll\",\"mouseleave .ui-menu\":\"collapseAll\",focus:function(t,e){var i=this.active||this._menuItems().first();e||this.focus(t,i)},blur:function(t){this._delay(function(){x.contains(this.element[0],x.ui.safeActiveElement(this.document[0]))||this.collapseAll(t)})},keydown:\"_keydown\"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t,!0),this.mouseHandled=!1}})},_activateItem:function(t){var e,i;this.previousFilter||t.clientX===this.lastMousePosition.x&&t.clientY===this.lastMousePosition.y||(this.lastMousePosition={x:t.clientX,y:t.clientY},e=x(t.target).closest(\".ui-menu-item\"),i=x(t.currentTarget),e[0]===i[0]&&(i.is(\".ui-state-active\")||(this._removeClass(i.siblings().children(\".ui-state-active\"),null,\"ui-state-active\"),this.focus(t,i))))},_destroy:function(){var t=this.element.find(\".ui-menu-item\").removeAttr(\"role aria-disabled\").children(\".ui-menu-item-wrapper\").removeUniqueId().removeAttr(\"tabIndex role aria-haspopup\");this.element.removeAttr(\"aria-activedescendant\").find(\".ui-menu\").addBack().removeAttr(\"role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex\").removeUniqueId().show(),t.children().each(function(){var t=x(this);t.data(\"ui-menu-submenu-caret\")&&t.remove()})},_keydown:function(t){var e,i,s,n=!0;switch(t.keyCode){case x.ui.keyCode.PAGE_UP:this.previousPage(t);break;case x.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case x.ui.keyCode.HOME:this._move(\"first\",\"first\",t);break;case x.ui.keyCode.END:this._move(\"last\",\"last\",t);break;case x.ui.keyCode.UP:this.previous(t);break;case x.ui.keyCode.DOWN:this.next(t);break;case x.ui.keyCode.LEFT:this.collapse(t);break;case x.ui.keyCode.RIGHT:this.active&&!this.active.is(\".ui-state-disabled\")&&this.expand(t);break;case x.ui.keyCode.ENTER:case x.ui.keyCode.SPACE:this._activate(t);break;case x.ui.keyCode.ESCAPE:this.collapse(t);break;default:e=this.previousFilter||\"\",s=n=!1,i=96<=t.keyCode&&t.keyCode<=105?(t.keyCode-96).toString():String.fromCharCode(t.keyCode),clearTimeout(this.filterTimer),i===e?s=!0:i=e+i,e=this._filterMenuItems(i),(e=s&&-1!==e.index(this.active.next())?this.active.nextAll(\".ui-menu-item\"):e).length||(i=String.fromCharCode(t.keyCode),e=this._filterMenuItems(i)),e.length?(this.focus(t,e),this.previousFilter=i,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}n&&t.preventDefault()},_activate:function(t){this.active&&!this.active.is(\".ui-state-disabled\")&&(this.active.children(\"[aria-haspopup='true']\").length?this.expand(t):this.select(t))},refresh:function(){var t,e,s=this,n=this.options.icons.submenu,i=this.element.find(this.options.menus);this._toggleClass(\"ui-menu-icons\",null,!!this.element.find(\".ui-icon\").length),e=i.filter(\":not(.ui-menu)\").hide().attr({role:this.options.role,\"aria-hidden\":\"true\",\"aria-expanded\":\"false\"}).each(function(){var t=x(this),e=t.prev(),i=x(\"<span>\").data(\"ui-menu-submenu-caret\",!0);s._addClass(i,\"ui-menu-icon\",\"ui-icon \"+n),e.attr(\"aria-haspopup\",\"true\").prepend(i),t.attr(\"aria-labelledby\",e.attr(\"id\"))}),this._addClass(e,\"ui-menu\",\"ui-widget ui-widget-content ui-front\"),(t=i.add(this.element).find(this.options.items)).not(\".ui-menu-item\").each(function(){var t=x(this);s._isDivider(t)&&s._addClass(t,\"ui-menu-divider\",\"ui-widget-content\")}),i=(e=t.not(\".ui-menu-item, .ui-menu-divider\")).children().not(\".ui-menu\").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(e,\"ui-menu-item\")._addClass(i,\"ui-menu-item-wrapper\"),t.filter(\".ui-state-disabled\").attr(\"aria-disabled\",\"true\"),this.active&&!x.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:\"menuitem\",listbox:\"option\"}[this.options.role]},_setOption:function(t,e){var i;\"icons\"===t&&(i=this.element.find(\".ui-menu-icon\"),this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr(\"aria-disabled\",String(t)),this._toggleClass(null,\"ui-state-disabled\",!!t)},focus:function(t,e){var i;this.blur(t,t&&\"focus\"===t.type),this._scrollIntoView(e),this.active=e.first(),i=this.active.children(\".ui-menu-item-wrapper\"),this._addClass(i,null,\"ui-state-active\"),this.options.role&&this.element.attr(\"aria-activedescendant\",i.attr(\"id\")),i=this.active.parent().closest(\".ui-menu-item\").children(\".ui-menu-item-wrapper\"),this._addClass(i,null,\"ui-state-active\"),t&&\"keydown\"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),(i=e.children(\".ui-menu\")).length&&t&&\/^mouse\/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger(\"focus\",t,{item:e})},_scrollIntoView:function(t){var e,i,s;this._hasScroll()&&(i=parseFloat(x.css(this.activeMenu[0],\"borderTopWidth\"))||0,s=parseFloat(x.css(this.activeMenu[0],\"paddingTop\"))||0,e=t.offset().top-this.activeMenu.offset().top-i-s,i=this.activeMenu.scrollTop(),s=this.activeMenu.height(),t=t.outerHeight(),e<0?this.activeMenu.scrollTop(i+e):s<e+t&&this.activeMenu.scrollTop(i+e-s+t))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(\".ui-menu-item-wrapper\"),null,\"ui-state-active\"),this._trigger(\"blur\",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),\"true\"===t.attr(\"aria-hidden\")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(t){var e=x.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(\".ui-menu\").not(t.parents(\".ui-menu\")).hide().attr(\"aria-hidden\",\"true\"),t.show().removeAttr(\"aria-hidden\").attr(\"aria-expanded\",\"true\").position(e)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var t=i?this.element:x(e&&e.target).closest(this.element.find(\".ui-menu\"));t.length||(t=this.element),this._close(t),this.blur(e),this._removeClass(t.find(\".ui-state-active\"),null,\"ui-state-active\"),this.activeMenu=t},i?0:this.delay)},_close:function(t){(t=t||(this.active?this.active.parent():this.element)).find(\".ui-menu\").hide().attr(\"aria-hidden\",\"true\").attr(\"aria-expanded\",\"false\")},_closeOnDocumentClick:function(t){return!x(t.target).closest(\".ui-menu\").length},_isDivider:function(t){return!\/[^\\-\\u2014\\u2013\\s]\/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(\".ui-menu-item\",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this._menuItems(this.active.children(\".ui-menu\")).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move(\"next\",\"first\",t)},previous:function(t){this._move(\"prev\",\"last\",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(\".ui-menu-item\").length},isLastItem:function(){return this.active&&!this.active.nextAll(\".ui-menu-item\").length},_menuItems:function(t){return(t||this.element).find(this.options.items).filter(\".ui-menu-item\")},_move:function(t,e,i){var s;(s=this.active?\"first\"===t||\"last\"===t?this.active[\"first\"===t?\"prevAll\":\"nextAll\"](\".ui-menu-item\").last():this.active[t+\"All\"](\".ui-menu-item\").first():s)&&s.length&&this.active||(s=this._menuItems(this.activeMenu)[e]()),this.focus(i,s)},nextPage:function(t){var e,i,s;this.active?this.isLastItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===x.fn.jquery.indexOf(\"3.2.\")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.nextAll(\".ui-menu-item\").each(function(){return(e=x(this)).offset().top-i-s<0}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu)[this.active?\"last\":\"first\"]())):this.next(t)},previousPage:function(t){var e,i,s;this.active?this.isFirstItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===x.fn.jquery.indexOf(\"3.2.\")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.prevAll(\".ui-menu-item\").each(function(){return 0<(e=x(this)).offset().top-i+s}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu).first())):this.next(t)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop(\"scrollHeight\")},select:function(t){this.active=this.active||x(t.target).closest(\".ui-menu-item\");var e={item:this.active};this.active.has(\".ui-menu\").length||this.collapseAll(t,!0),this._trigger(\"select\",t,e)},_filterMenuItems:function(t){var t=t.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]\/g,\"\\\\$&\"),e=new RegExp(\"^\"+t,\"i\");return this.activeMenu.find(this.options.items).filter(\".ui-menu-item\").filter(function(){return e.test(String.prototype.trim.call(x(this).children(\".ui-menu-item-wrapper\").text()))})}});x.widget(\"ui.autocomplete\",{version:\"1.13.1\",defaultElement:\"<input>\",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:\"left top\",at:\"left bottom\",collision:\"none\"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,liveRegionTimer:null,_create:function(){var i,s,n,t=this.element[0].nodeName.toLowerCase(),e=\"textarea\"===t,t=\"input\"===t;this.isMultiLine=e||!t&&this._isContentEditable(this.element),this.valueMethod=this.element[e||t?\"val\":\"text\"],this.isNewMenu=!0,this._addClass(\"ui-autocomplete-input\"),this.element.attr(\"autocomplete\",\"off\"),this._on(this.element,{keydown:function(t){if(this.element.prop(\"readOnly\"))s=n=i=!0;else{s=n=i=!1;var e=x.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:i=!0,this._move(\"previousPage\",t);break;case e.PAGE_DOWN:i=!0,this._move(\"nextPage\",t);break;case e.UP:i=!0,this._keyEvent(\"previous\",t);break;case e.DOWN:i=!0,this._keyEvent(\"next\",t);break;case e.ENTER:this.menu.active&&(i=!0,t.preventDefault(),this.menu.select(t));break;case e.TAB:this.menu.active&&this.menu.select(t);break;case e.ESCAPE:this.menu.element.is(\":visible\")&&(this.isMultiLine||this._value(this.term),this.close(t),t.preventDefault());break;default:s=!0,this._searchTimeout(t)}}},keypress:function(t){if(i)return i=!1,void(this.isMultiLine&&!this.menu.element.is(\":visible\")||t.preventDefault());if(!s){var e=x.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:this._move(\"previousPage\",t);break;case e.PAGE_DOWN:this._move(\"nextPage\",t);break;case e.UP:this._keyEvent(\"previous\",t);break;case e.DOWN:this._keyEvent(\"next\",t)}}},input:function(t){if(n)return n=!1,void t.preventDefault();this._searchTimeout(t)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){clearTimeout(this.searching),this.close(t),this._change(t)}}),this._initSource(),this.menu=x(\"<ul>\").appendTo(this._appendTo()).menu({role:null}).hide().attr({unselectable:\"on\"}).menu(\"instance\"),this._addClass(this.menu.element,\"ui-autocomplete\",\"ui-front\"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault()},menufocus:function(t,e){var i,s;if(this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&\/^mouse\/.test(t.originalEvent.type)))return this.menu.blur(),void this.document.one(\"mousemove\",function(){x(t.target).trigger(t.originalEvent)});s=e.item.data(\"ui-autocomplete-item\"),!1!==this._trigger(\"focus\",t,{item:s})&&t.originalEvent&&\/^key\/.test(t.originalEvent.type)&&this._value(s.value),(i=e.item.attr(\"aria-label\")||s.value)&&String.prototype.trim.call(i).length&&(clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(x(\"<div>\").text(i))},100))},menuselect:function(t,e){var i=e.item.data(\"ui-autocomplete-item\"),s=this.previous;this.element[0]!==x.ui.safeActiveElement(this.document[0])&&(this.element.trigger(\"focus\"),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger(\"select\",t,{item:i})&&this._value(i.value),this.term=this._value(),this.close(t),this.selectedItem=i}}),this.liveRegion=x(\"<div>\",{role:\"status\",\"aria-live\":\"assertive\",\"aria-relevant\":\"additions\"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,\"ui-helper-hidden-accessible\"),this._on(this.window,{beforeunload:function(){this.element.removeAttr(\"autocomplete\")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr(\"autocomplete\"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),\"source\"===t&&this._initSource(),\"appendTo\"===t&&this.menu.element.appendTo(this._appendTo()),\"disabled\"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(t){var e=this.menu.element[0];return t.target===this.element[0]||t.target===e||x.contains(e,t.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var t=this.options.appendTo;return t=!(t=!(t=t&&(t.jquery||t.nodeType?x(t):this.document.find(t).eq(0)))||!t[0]?this.element.closest(\".ui-front, dialog\"):t).length?this.document[0].body:t},_initSource:function(){var i,s,n=this;Array.isArray(this.options.source)?(i=this.options.source,this.source=function(t,e){e(x.ui.autocomplete.filter(i,t.term))}):\"string\"==typeof this.options.source?(s=this.options.source,this.source=function(t,e){n.xhr&&n.xhr.abort(),n.xhr=x.ajax({url:s,data:t,dataType:\"json\",success:function(t){e(t)},error:function(){e([])}})}):this.source=this.options.source},_searchTimeout:function(s){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),e=this.menu.element.is(\":visible\"),i=s.altKey||s.ctrlKey||s.metaKey||s.shiftKey;t&&(e||i)||(this.selectedItem=null,this.search(null,s))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):!1!==this._trigger(\"search\",e)?this._search(t):void 0},_search:function(t){this.pending++,this._addClass(\"ui-autocomplete-loading\"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass(\"ui-autocomplete-loading\")}.bind(this)},__response:function(t){t=t&&this._normalize(t),this._trigger(\"response\",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger(\"open\")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,\"mousedown\"),this.menu.element.is(\":visible\")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger(\"close\",t))},_change:function(t){this.previous!==this._value()&&this._trigger(\"change\",t,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:x.map(t,function(t){return\"string\"==typeof t?{label:t,value:t}:x.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var e=this.menu.element.empty();this._renderMenu(e,t),this.isNewMenu=!0,this.menu.refresh(),e.show(),this._resizeMenu(),e.position(x.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:\"_closeOnClickOutside\"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width(\"\").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(i,t){var s=this;x.each(t,function(t,e){s._renderItemData(i,e)})},_renderItemData:function(t,e){return this._renderItem(t,e).data(\"ui-autocomplete-item\",e)},_renderItem:function(t,e){return x(\"<li>\").append(x(\"<div>\").text(e.label)).appendTo(t)},_move:function(t,e){if(this.menu.element.is(\":visible\"))return this.menu.isFirstItem()&&\/^previous\/.test(t)||this.menu.isLastItem()&&\/^next\/.test(t)?(this.isMultiLine||this._value(this.term),void this.menu.blur()):void this.menu[t](e);this.search(null,e)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){this.isMultiLine&&!this.menu.element.is(\":visible\")||(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop(\"contentEditable\");return\"inherit\"===e?this._isContentEditable(t.parent()):\"true\"===e}}),x.extend(x.ui.autocomplete,{escapeRegex:function(t){return t.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]\/g,\"\\\\$&\")},filter:function(t,e){var i=new RegExp(x.ui.autocomplete.escapeRegex(e),\"i\");return x.grep(t,function(t){return i.test(t.label||t.value||t)})}}),x.widget(\"ui.autocomplete\",x.ui.autocomplete,{options:{messages:{noResults:\"No search results.\",results:function(t){return t+(1<t?\" results are\":\" result is\")+\" available, use up and down arrow keys to navigate.\"}}},__response:function(t){var e;this._superApply(arguments),this.options.disabled||this.cancelSearch||(e=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(x(\"<div>\").text(e))},100))}});x.ui.autocomplete});\n\\ No newline at end of file\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-ui.min.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## jQuery UI v1.13.2\n+## jQuery UI v1.12.1\n","filename":"src\/jdk.javadoc\/share\/legal\/jqueryUI.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/ so they can at a later staged be removed.\n+\/\/ so they can a later staged be removed.\n@@ -66,7 +66,0 @@\n-        try {\n-            if (!SecuritySupport.exists(p)) {\n-                return true;\n-            }\n-        } catch (IOException e) {\n-            \/\/ ignore\n-        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/FilePurger.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -606,7 +606,0 @@\n-\n-    \/**\n-     * Emit a jdk.DataLoss event for the specified amount of bytes.\n-     *\n-     * @param bytes number of bytes that were lost\n-     *\/\n-    public static native void emitDataLoss(long bytes);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static jdk.jfr.internal.LogLevel.ERROR;\n@@ -455,13 +454,4 @@\n-        if (chunk.finish(time)) {\n-            for (PlatformRecording r : getRecordings()) {\n-                if (r != ignoreMe && r.getState() == RecordingState.RUNNING) {\n-                    r.appendChunk(chunk);\n-                }\n-            }\n-        } else {\n-            if (chunk.isMissingFile()) {\n-                \/\/ With one chunkfile found missing, its likely more could've been removed too. Iterate through all recordings,\n-                \/\/ and check for missing files. This will emit more error logs that can be seen in subsequent recordings.\n-                for (PlatformRecording r : getRecordings()) {\n-                    r.removeNonExistantPaths();\n-                }\n+        chunk.finish(time);\n+        for (PlatformRecording r : getRecordings()) {\n+            if (r != ignoreMe && r.getState() == RecordingState.RUNNING) {\n+                r.appendChunk(chunk);\n@@ -508,9 +498,6 @@\n-            long wait = Options.getWaitInterval();\n-            try {\n-                synchronized (this) {\n-                    if (jvm.shouldRotateDisk()) {\n-                        rotateDisk();\n-                    }\n-                    if (isToDisk()) {\n-                        EventLog.update();\n-                    }\n+            synchronized (this) {\n+                if (jvm.shouldRotateDisk()) {\n+                    rotateDisk();\n+                }\n+                if (isToDisk()) {\n+                    EventLog.update();\n@@ -518,7 +505,0 @@\n-                long minDelta = RequestEngine.doPeriodic();\n-                wait = Math.min(minDelta, Options.getWaitInterval());\n-            } catch (Throwable t) {\n-                \/\/ Catch everything and log, but don't allow it to end the periodic task\n-                Logger.log(JFR_SYSTEM, ERROR, \"Error in Periodic task: \" + t.getClass().getName());\n-            } finally {\n-                takeNap(wait);\n@@ -526,0 +506,3 @@\n+            long minDelta = RequestEngine.doPeriodic();\n+            long wait = Math.min(minDelta, Options.getWaitInterval());\n+            takeNap(wait);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":13,"deletions":30,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import static jdk.jfr.internal.LogLevel.ERROR;\n-import static jdk.jfr.internal.LogLevel.INFO;\n@@ -37,1 +35,0 @@\n-import java.nio.file.NoSuchFileException;\n@@ -717,27 +714,11 @@\n-            transferChunksWithRetry(userPath);\n-        }\n-    }\n-\n-    private void transferChunksWithRetry(WriteableUserPath userPath) throws IOException {\n-        userPath.doPrivilegedIO(() -> {\n-            try {\n-                transferChunks(userPath);\n-            } catch (NoSuchFileException nsfe) {\n-                Logger.log(LogTag.JFR, LogLevel.ERROR, \"Missing chunkfile when writing recording \\\"\" + name + \"\\\" (\" + id + \") to \" + userPath.getRealPathText() + \".\");\n-                \/\/ if one chunkfile was missing, its likely more are missing\n-                removeNonExistantPaths();\n-                \/\/ and try the transfer again\n-                transferChunks(userPath);\n-            }\n-            return null;\n-        });\n-    }\n-\n-    private void transferChunks(WriteableUserPath userPath) throws IOException {\n-        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n-            long bytes = cc.transferTo(fc);\n-            Logger.log(LogTag.JFR, LogLevel.INFO, \"Transferred \" + bytes + \" bytes from the disk repository\");\n-            \/\/ No need to force if no data was transferred, which avoids IOException when device is \/dev\/null\n-            if (bytes != 0) {\n-                fc.force(true);\n-            }\n+                userPath.doPrivilegedIO(() -> {\n+                    try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n+                        long bytes = cc.transferTo(fc);\n+                        Logger.log(LogTag.JFR, LogLevel.INFO, \"Transferred \" + bytes + \" bytes from the disk repository\");\n+                        \/\/ No need to force if no data was transferred, which avoids IOException when device is \/dev\/null\n+                        if (bytes != 0) {\n+                            fc.force(true);\n+                        }\n+                    }\n+                    return null;\n+                });\n@@ -895,23 +876,0 @@\n-\n-    void removeNonExistantPaths() {\n-        synchronized (recorder) {\n-            Iterator<RepositoryChunk> it = chunks.iterator();\n-            Logger.log(JFR, INFO, \"Checking for missing chunkfiles for recording \\\"\" + name + \"\\\" (\" + id + \")\");\n-            while (it.hasNext()) {\n-                RepositoryChunk chunk = it.next();\n-                if (chunk.isMissingFile()) {\n-                    String msg = \"Chunkfile \\\"\" + chunk.getFile() + \"\\\" is missing. \" +\n-                                 \"Data loss might occur from \" + chunk.getStartTime();\n-                    if (chunk.getEndTime() != null) {\n-                        msg += \" to \" + chunk.getEndTime();\n-                    }\n-                    Logger.log(JFR, ERROR, msg);\n-\n-                    JVM.emitDataLoss(chunk.getSize());\n-\n-                    it.remove();\n-                    removed(chunk);\n-                }\n-            }\n-        }\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":11,"deletions":53,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.time.Period;\n-import java.time.Duration;\n@@ -35,1 +33,0 @@\n-import java.util.Optional;\n@@ -61,1 +58,1 @@\n-    boolean finish(Instant endTime) {\n+    void finish(Instant endTime) {\n@@ -63,7 +60,1 @@\n-            unFinishedRAF.close();\n-            size = SecuritySupport.getFileSize(chunkFile);\n-            this.endTime = endTime;\n-            if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n-                Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Chunk finished: \" + chunkFile);\n-            }\n-            return true;\n+            finishWithException(endTime);\n@@ -71,9 +62,10 @@\n-            final String reason;\n-            if (isMissingFile()) {\n-                reason = \"Chunkfile \\\"\"+ getFile() + \"\\\" is missing. \" +\n-                         \"Data loss might occur from \" + getStartTime() + \" to \" + endTime;\n-            } else {\n-                reason = e.getClass().getName();\n-            }\n-            Logger.log(LogTag.JFR, LogLevel.ERROR, \"Could not finish chunk. \" + reason);\n-            return false;\n+            Logger.log(LogTag.JFR, LogLevel.ERROR, \"Could not finish chunk. \" + e.getClass() + \" \"+ e.getMessage());\n+        }\n+    }\n+\n+    private void finishWithException(Instant endTime) throws IOException {\n+        unFinishedRAF.close();\n+        this.size = SecuritySupport.getFileSize(chunkFile);\n+        this.endTime = endTime;\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Chunk finished: \" + chunkFile);\n@@ -114,0 +106,4 @@\n+        if (!isFinished()) {\n+            finish(Instant.MIN);\n+        }\n+         delete(chunkFile);\n@@ -120,2 +116,0 @@\n-        } finally {\n-            delete(chunkFile);\n@@ -189,8 +183,0 @@\n-\n-    boolean isMissingFile() {\n-        try {\n-            return !SecuritySupport.exists(chunkFile);\n-        } catch (IOException ioe) {\n-            return true;\n-        }\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":16,"deletions":30,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -82,2 +82,1 @@\n-     * These are JDI com.sun.jdi.connect.Connector arguments. The {@code vmexec}\n-     * argument is not supported.\n+     * These are JDI com.sun.jdi.connect.Connector arguments.\n@@ -108,4 +107,1 @@\n-        customConnectorArgs.entrySet()\n-                           .stream()\n-                           .filter(e -> !\"vmexec\".equals(e.getKey()))\n-                           .forEach(e -> argumentName2Value.put(e.getKey(), e.getValue()));\n+        argumentName2Value.putAll(customConnectorArgs);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiInitiator.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -3066,5 +3066,0 @@\n-            \/\/ Extra field Length cannot exceed 65,535 bytes per the PKWare\n-            \/\/ APP.note 4.4.11\n-            if (elen > 0xFFFF) {\n-                throw new ZipException(\"invalid extra field length\");\n-            }\n@@ -3080,3 +3075,2 @@\n-                if (pos + sz > elen) {        \/\/ invalid data\n-                    throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                }\n+                if (pos + sz > elen)         \/\/ invalid data\n+                    break;\n@@ -3085,4 +3079,0 @@\n-                    \/\/ Check to see if we have a valid block size\n-                    if (!isZip64ExtBlockSizeValid(sz)) {\n-                        throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                    }\n@@ -3093,3 +3083,0 @@\n-                        if (size < 0) {\n-                            throw new ZipException(\"Invalid zip64 extra block size value\");\n-                        }\n@@ -3102,3 +3089,0 @@\n-                        if (csize < 0) {\n-                            throw new ZipException(\"Invalid zip64 extra block compressed size value\");\n-                        }\n@@ -3111,3 +3095,0 @@\n-                        if (locoff < 0) {\n-                            throw new ZipException(\"Invalid zip64 extra block LOC offset value\");\n-                        }\n@@ -3171,30 +3152,0 @@\n-        \/**\n-         * Validate the size and contents of a Zip64 extended information field\n-         * The order of the Zip64 fields is fixed, but the fields MUST\n-         * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n-         * or 0xFFFFFFFF:\n-         * Uncompressed Size - 8 bytes\n-         * Compressed Size   - 8 bytes\n-         * LOC Header offset - 8 bytes\n-         * Disk Start Number - 4 bytes\n-         * See PKWare APP.Note Section 4.5.3 for more details\n-         *\n-         * @param blockSize the Zip64 Extended Information Extra Field size\n-         * @return true if the extra block size is valid; false otherwise\n-         *\/\n-        private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n-            \/*\n-             * As the fields must appear in order, the block size indicates which\n-             * fields to expect:\n-             *  8 - uncompressed size\n-             * 16 - uncompressed size, compressed size\n-             * 24 - uncompressed size, compressed sise, LOC Header offset\n-             * 28 - uncompressed size, compressed sise, LOC Header offset,\n-             * and Disk start number\n-             *\/\n-            return switch(blockSize) {\n-                case 8, 16, 24, 28 -> true;\n-                default -> false;\n-            };\n-        }\n-\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":3,"deletions":52,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -879,24 +879,0 @@\n-\n-#ifdef __GLIBC__\n-TEST_VM(os, trim_native_heap) {\n-  EXPECT_TRUE(os::can_trim_native_heap());\n-  os::size_change_t sc;\n-  sc.before = sc.after = (size_t)-1;\n-  EXPECT_TRUE(os::trim_native_heap(&sc));\n-  tty->print_cr(SIZE_FORMAT \"->\" SIZE_FORMAT, sc.before, sc.after);\n-  \/\/ Regardless of whether we freed memory, both before and after\n-  \/\/ should be somewhat believable numbers (RSS).\n-  const size_t min = 5 * M;\n-  const size_t max = LP64_ONLY(20 * G) NOT_LP64(3 * G);\n-  ASSERT_LE(min, sc.before);\n-  ASSERT_GT(max, sc.before);\n-  ASSERT_LE(min, sc.after);\n-  ASSERT_GT(max, sc.after);\n-  \/\/ Should also work\n-  EXPECT_TRUE(os::trim_native_heap());\n-}\n-#else\n-TEST_VM(os, trim_native_heap) {\n-  EXPECT_FALSE(os::can_trim_native_heap());\n-}\n-#endif \/\/ __GLIBC__\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-gc\/CriticalNativeArgs.java#id1 8312028 generic-all\n@@ -81,1 +80,0 @@\n-gc\/stress\/CriticalNativeStress.java#id1 8312028 generic-all\n@@ -106,1 +104,0 @@\n-runtime\/CompressedOops\/CompressedClassPointers.java 8305765 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8313402\n- * @summary C1: Incorrect LoadIndexed value numbering\n- * @requires vm.compiler1.enabled\n- * @library \/compiler\/patches \/test\/lib\n- * @build java.base\/java.lang.Helper\n- * @run main\/othervm -Xbatch -XX:CompileThreshold=100\n- *                   -XX:TieredStopAtLevel=1\n- *                   compiler.c1.TestLoadIndexedMismatch\n- *\/\n-\n-package compiler.c1;\n-\n-public class TestLoadIndexedMismatch {\n-    static final byte[] ARR = {42, 42};\n-    static final char EXPECTED_CHAR = (char)(42*256 + 42);\n-\n-    public static char work() {\n-        \/\/ LoadIndexed (B)\n-        byte b = ARR[0];\n-        \/\/ StringUTF16.charAt intrinsic, LoadIndexed (C)\n-        char c = Helper.charAt(ARR, 0);\n-        return c;\n-    }\n-\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 10_000; i++) {\n-            char c = work();\n-            if (c != EXPECTED_CHAR) {\n-                throw new IllegalStateException(\"Read: \" + (int)c + \", expected: \" + (int)EXPECTED_CHAR);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestLoadIndexedMismatch.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -64,1 +64,1 @@\n-        if (!jdk.test.whitebox.code.Compiler.isC1Enabled()) {\n+        if (!sun.hotspot.code.Compiler.isC1Enabled()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        if (!jdk.test.whitebox.code.Compiler.isC1Enabled()) {\n+        if (!sun.hotspot.code.Compiler.isC1Enabled()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-import jdk.test.whitebox.code.BlobType;\n-import jdk.test.whitebox.code.CodeBlob;\n+import sun.hotspot.code.BlobType;\n+import sun.hotspot.code.CodeBlob;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/OverflowCodeCacheTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/TestSegmentedCodeCacheOption.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/CodeCacheFreeSpaceRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/GenericCodeHeapSizeRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/JVMStartupRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/TestCodeHeapSizeOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheCLITestCase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheInfoFormatter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/printcodecache\/PrintCodeCacheRunner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/printcodecache\/TestPrintCodeCacheOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/BeanTypeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import jdk.test.whitebox.code.BlobType;\n-import jdk.test.whitebox.code.CodeBlob;\n+import sun.hotspot.code.BlobType;\n+import sun.hotspot.code.CodeBlob;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/CodeCacheUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/CodeHeapBeanPresenceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/GetUsageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/InitialAndMaxUsageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/ManagerNamesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/MemoryPoolsPresenceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/PeakUsageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/PoolsIndependenceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/ThresholdNotificationsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdExceededTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdIncreasedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdNotExceededTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/RandomAllocationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/ReturnBlobToWrongHeapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Check for 128-bit AES\/CTR wraparound\n- * @library \/test\/lib \/\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm -Xbatch\n- * -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * compiler.codegen.aes.CTR_Wraparound 32\n- * @run main\/othervm -Xbatch\n- * -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * compiler.codegen.aes.CTR_Wraparound 1009\n- * @run main\/othervm -Xbatch\n- * -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- * compiler.codegen.aes.CTR_Wraparound 2048\n- *\/\n-\n-package compiler.codegen.aes;\n-\n-import java.util.Arrays;\n-import java.util.Random;\n-import javax.crypto.Cipher;\n-import javax.crypto.spec.IvParameterSpec;\n-import javax.crypto.spec.SecretKeySpec;\n-\n-import compiler.whitebox.CompilerWhiteBoxTest;\n-import jdk.test.whitebox.code.Compiler;\n-import jdk.test.lib.Utils;\n-import jtreg.SkippedException;\n-\n-public class CTR_Wraparound {\n-    private static final String ALGO = \"AES\/CTR\/NoPadding\";\n-    private static final int LOOPS = 100000;\n-\n-    public static void main(String[] args) throws Exception {\n-        int length = Integer.parseInt(args[0]);\n-        int maxOffset = 60;\n-        if (args.length > 1) {\n-            maxOffset = Integer.parseInt(args[1]);\n-            System.out.println(\"InitialOffset = \" + maxOffset);\n-        }\n-\n-        if (!Compiler.isIntrinsicAvailable(CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"com.sun.crypto.provider.CounterMode\", \"implCrypt\", byte[].class, int.class, int.class, byte[].class, int.class)) {\n-            throw new SkippedException(\"AES-CTR intrinsic is not available\");\n-        }\n-\n-        Random random = Utils.getRandomInstance();\n-\n-        byte[] keyBytes = new byte[32];\n-        Arrays.fill(keyBytes, (byte)0xff);\n-        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n-\n-        byte[] ivBytes = new byte[16];\n-\n-        Arrays.fill(ivBytes, (byte)0xff);\n-\n-        byte[][] plaintext = new byte[maxOffset][];\n-        byte[][] ciphertext = new byte[maxOffset][];\n-\n-        for (int offset = 0; offset < maxOffset; offset++) {\n-            ivBytes[ivBytes.length - 1] = (byte)-offset;\n-            IvParameterSpec iv = new IvParameterSpec(ivBytes);\n-\n-            Cipher encryptCipher = Cipher.getInstance(ALGO);\n-            Cipher decryptCipher = Cipher.getInstance(ALGO);\n-\n-            encryptCipher.init(Cipher.ENCRYPT_MODE, key, iv);\n-            decryptCipher.init(Cipher.DECRYPT_MODE, key, iv);\n-\n-            plaintext[offset] = new byte[length];\n-            ciphertext[offset] = new byte[length];\n-            random.nextBytes(plaintext[offset]);\n-\n-            byte[] decrypted = new byte[length];\n-\n-            encryptCipher.doFinal(plaintext[offset], 0, length, ciphertext[offset]);\n-            decryptCipher.doFinal(ciphertext[offset], 0, length, decrypted);\n-\n-            if (!Arrays.equals(plaintext[offset], decrypted)) {\n-                throw new Exception(\"mismatch in setup at offset \" + offset);\n-            }\n-        }\n-\n-        for (int offset = 0; offset < maxOffset; offset++) {\n-            ivBytes[ivBytes.length - 1] = (byte)-offset;\n-            IvParameterSpec iv = new IvParameterSpec(ivBytes);\n-\n-            Cipher encryptCipher = Cipher.getInstance(ALGO);\n-\n-            encryptCipher.init(Cipher.ENCRYPT_MODE, key, iv);\n-\n-            byte[] encrypted = new byte[length];\n-\n-            for (int i = 0; i < LOOPS; i++) {\n-                encryptCipher.doFinal(plaintext[offset], 0, length, encrypted);\n-                if (!Arrays.equals(ciphertext[offset], encrypted)) {\n-                    throw new Exception(\"array mismatch at offset \" + offset\n-                                        + \" with length \" + length);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/CTR_Wraparound.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/Test8292158.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestAESMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestCipherBlockChainingEncrypt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestAndnI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestAndnL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsiI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsiL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsmskI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsmskL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsrI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBlsrL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBzhiI2L.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestLzcntI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestLzcntL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestTzcntI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestTzcntL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-import jdk.test.whitebox.code.NMethod;\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.code.NMethod;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BmiIntrinsicBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/AllocateCompileIdTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/CompileCodeTestCase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/DisassembleCodeBlobTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ExecuteInstalledCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/HasCompiledCodeForOSRTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/InvalidateInstalledCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,4 +56,4 @@\n-    public static final String ALLOC = \"(.*precise klass .*\\\\R((.*(?i:mov|mv|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n-    public static final String ALLOC_OF = COMPOSITE_PREFIX + \"(.*precise klass .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n-    public static final String ALLOC_ARRAY = \"(.*precise klass \\\\[L.*\\\\R((.*(?i:mov|mv|xor|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n-    public static final String ALLOC_ARRAY_OF = COMPOSITE_PREFIX + \"(.*precise klass \\\\[L.*\" + IS_REPLACED + \";:.*\\\\R((.*(?i:mov|mv|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+    public static final String ALLOC = \"(.*precise klass .*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+    public static final String ALLOC_OF = COMPOSITE_PREFIX + \"(.*precise klass .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+    public static final String ALLOC_ARRAY = \"(.*precise klass \\\\[L.*\\\\R((.*(?i:mov|xor|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+    public static final String ALLOC_ARRAY_OF = COMPOSITE_PREFIX + \"(.*precise klass \\\\[L.*\" + IS_REPLACED + \";:.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n@@ -61,2 +61,2 @@\n-    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*precise klass \\\\[.*;:|.*(?i:mov|mv|or).*precise klass \\\\[.*;:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n-    public static final String CHECKCAST_ARRAY_OF = COMPOSITE_PREFIX + \"(((?i:cmp|CLFI|CLR).*precise klass \\\\[.*\" + IS_REPLACED + \";:|.*(?i:mov|mv|or).*precise klass \\\\[.*\" + IS_REPLACED + \";:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*precise klass \\\\[.*;:|.*(?i:mov|or).*precise klass \\\\[.*;:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+    public static final String CHECKCAST_ARRAY_OF = COMPOSITE_PREFIX + \"(((?i:cmp|CLFI|CLR).*precise klass \\\\[.*\" + IS_REPLACED + \";:|.*(?i:mov|or).*precise klass \\\\[.*\" + IS_REPLACED + \";:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/hotspot\/jtreg\/compiler\/onSpinWait\/TestOnSpinWaitAArch64DefaultFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8303279\n- * @summary C2: crash in SubTypeCheckNode::sub() at IGVN split if\n- * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:StressSeed=598200189 TestCrashAtIGVNSplitIfSubType\n- * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN TestCrashAtIGVNSplitIfSubType\n- *\/\n-\n-public class TestCrashAtIGVNSplitIfSubType {\n-    private static volatile int barrier;\n-\n-    public static void main(String[] args) {\n-        A a = new A();\n-        B b = new B();\n-        for (int i = 0; i < 20_000; i++) {\n-            test(a);\n-            test(b);\n-            testHelper1(null, 0);\n-        }\n-    }\n-\n-    private static void test(Object o) {\n-        int i = 2;\n-        for (; i < 4; i *= 2) {\n-\n-        }\n-        o = testHelper1(o, i);\n-        if (o instanceof A) {\n-            barrier = 0x42;\n-        }\n-    }\n-\n-    private static Object testHelper1(Object o, int i) {\n-        if (i < 3) {\n-            o = null;\n-        } else {\n-            if (o == null) {\n-            }\n-        }\n-        if (i < 2) {\n-            barrier = 42;\n-        }\n-        return o;\n-    }\n-\n-    private static class A {\n-    }\n-\n-    private static class B {\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestCrashAtIGVNSplitIfSubType.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -55,1 +55,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeGetStableArrayElement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/AllocationCodeBlobTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/CompilerWhiteBoxTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeFramesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/ForceNMethodSweepTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-import jdk.test.whitebox.code.BlobType;\n-import jdk.test.whitebox.code.CodeBlob;\n+import sun.hotspot.code.BlobType;\n+import sun.hotspot.code.CodeBlob;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/GetCodeHeapEntriesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-import jdk.test.whitebox.code.BlobType;\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.BlobType;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/GetNMethodTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Red Hat, Inc.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/\/ Check dynamic limits updating. HotSpot side.\n-public class LimitUpdateChecker {\n-\n-    private static final File UPDATE_FILE = new File(\"\/tmp\", \"limitsUpdated\");\n-    private static final File STARTED_FILE = new File(\"\/tmp\", \"started\");\n-\n-    public static void main(String[] args) throws Exception {\n-        System.out.println(\"LimitUpdateChecker: Entering\");\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        printMetrics(wb); \/\/ print initial limits\n-        createStartedFile();\n-        while (!UPDATE_FILE.exists()) {\n-            Thread.sleep(200);\n-        }\n-        System.out.println(\"'limitsUpdated' file appeared. Stopped loop.\");\n-        printMetrics(wb); \/\/ print limits after update\n-        System.out.println(\"LimitUpdateChecker DONE.\");\n-\n-    }\n-\n-    private static void printMetrics(WhiteBox wb) {\n-        wb.printOsInfo();\n-    }\n-\n-    private static void createStartedFile() throws Exception {\n-        FileOutputStream fout = new FileOutputStream(STARTED_FILE);\n-        fout.close();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/LimitUpdateChecker.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Red Hat, Inc.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @bug 8308090\n- * @key cgroups\n- * @summary Test container limits updating as they get updated at runtime without restart\n- * @requires docker.support\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox LimitUpdateChecker\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar whitebox.jar jdk.test.whitebox.WhiteBox\n- * @run driver TestLimitsUpdating\n- *\/\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.containers.docker.Common;\n-import jdk.test.lib.containers.docker.DockerRunOptions;\n-import jdk.test.lib.containers.docker.DockerTestUtils;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class TestLimitsUpdating {\n-    private static final String TARGET_CONTAINER = \"limitsUpdatingHS_\" + Runtime.getRuntime().version().major();\n-    private static final String imageName = Common.imageName(\"limitsUpdating\");\n-\n-    public static void main(String[] args) throws Exception {\n-        if (!DockerTestUtils.canTestDocker()) {\n-            return;\n-        }\n-\n-        Common.prepareWhiteBox();\n-        DockerTestUtils.buildJdkContainerImage(imageName);\n-\n-        try {\n-            testLimitUpdates();\n-        } finally {\n-            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n-                DockerTestUtils.removeDockerImage(imageName);\n-            }\n-        }\n-    }\n-\n-    private static void testLimitUpdates() throws Exception {\n-        File sharedtmpdir = new File(\"test-sharedtmp\");\n-        File flag = new File(sharedtmpdir, \"limitsUpdated\"); \/\/ shared with LimitUpdateChecker\n-        File started = new File(sharedtmpdir, \"started\"); \/\/ shared with LimitUpdateChecker\n-        sharedtmpdir.mkdir();\n-        flag.delete();\n-        started.delete();\n-        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"LimitUpdateChecker\");\n-        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n-        opts.addDockerOpts(\"--volume\", sharedtmpdir.getAbsolutePath() + \":\/tmp\");\n-        opts.addDockerOpts(\"--cpu-period\", \"100000\");\n-        opts.addDockerOpts(\"--cpu-quota\", \"200000\");\n-        opts.addDockerOpts(\"--memory\", \"500m\");\n-        opts.addDockerOpts(\"--memory-swap\", \"500m\");\n-        opts.addDockerOpts(\"--name\", TARGET_CONTAINER);\n-        opts.addJavaOpts(\"-cp\", \"\/test-classes\/\");\n-        Common.addWhiteBoxOpts(opts);\n-        final OutputAnalyzer out[] = new OutputAnalyzer[1];\n-        Thread t1 = new Thread() {\n-                public void run() {\n-                    try {\n-                        out[0] = DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0);\n-                    } catch (Exception e) {\n-                        e.printStackTrace();\n-                    }\n-                }\n-            };\n-        t1.start();\n-\n-       \/\/ Wait for target container (that we later update) to complete its\n-       \/\/ initial starting-up phase. Prints initial container limits.\n-        while (!started.exists()) {\n-            System.out.println(\"Wait for target container to start\");\n-            Thread.sleep(100);\n-        }\n-\n-        final List<String> containerCommand = getContainerUpdate(300_000, 100_000, \"300m\");\n-        \/\/ Run the update command so as to increase resources once the container signaled it has started.\n-        Thread t2 = new Thread() {\n-                public void run() {\n-                    try {\n-                        DockerTestUtils.execute(containerCommand).shouldHaveExitValue(0);\n-                    } catch (Exception e) {\n-                        e.printStackTrace();\n-                    }\n-                }\n-            };\n-        t2.start();\n-        t2.join();\n-\n-        \/\/ Set the flag for the to-get updated container, indicating the update\n-        \/\/ has completed.\n-        FileOutputStream fout = new FileOutputStream(flag);\n-        fout.close();\n-\n-        t1.join();\n-\n-        \/\/ Do assertions based on the output in target container\n-        OutputAnalyzer targetOut = out[0];\n-        targetOut.shouldContain(\"active_processor_count: 2\"); \/\/ initial value\n-        targetOut.shouldContain(\"active_processor_count: 3\"); \/\/ updated value\n-        targetOut.shouldContain(\"memory_limit_in_bytes: 512000 k\"); \/\/ initial value\n-        targetOut.shouldContain(\"memory_and_swap_limit_in_bytes: 512000 k\"); \/\/ initial value\n-        targetOut.shouldContain(\"memory_limit_in_bytes: 307200 k\"); \/\/ updated value\n-        targetOut.shouldContain(\"memory_and_swap_limit_in_bytes: 307200 k\"); \/\/ updated value\n-    }\n-\n-    private static List<String> getContainerUpdate(int cpuQuota, int cpuPeriod, String memory) {\n-        List<String> cmd = DockerTestUtils.buildContainerCommand();\n-        cmd.add(\"update\");\n-        cmd.add(\"--cpu-period=\" + cpuPeriod);\n-        cmd.add(\"--cpu-quota=\" + cpuQuota);\n-        cmd.add(\"--memory=\" + memory);\n-        cmd.add(\"--memory-swap=\" + memory); \/\/ no swap\n-        cmd.add(TARGET_CONTAINER);\n-        return cmd;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestLimitsUpdating.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/TestConcurrentGCBreakpoints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/TestJNIWeak\/TestJNIWeak.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/TestSmallHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelGCThreads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelRefProc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/ergonomics\/TestDynamicNumberOfGCThreads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/ergonomics\/TestInitialGCThreadLogging.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestGCId.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n@@ -42,1 +42,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/UseCompressedOops.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-import jdk.test.whitebox.code.Compiler;\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.code.Compiler;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/runtime\/MemberName\/MemberNameLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @bug 8181143 8269523 8307653\n+ * @bug 8181143 8269523\n@@ -53,3 +53,5 @@\n-        \/\/ This should definitely pass: more than 3 minutes is enough for Serial to act.\n-        \/\/ The value is deliberately non-round to trip off periodic task granularity.\n-        testWith(183423, true);\n+        \/\/ These should definitely pass: more than a minute is enough for Serial to act.\n+        \/\/ The values are deliberately non-round to trip off periodic task granularity.\n+        for (int delay : new int[]{63423, 12388131}) {\n+            testWith(delay, true);\n+        }\n@@ -72,1 +74,1 @@\n-                \"-Xlog:gc*=info\",\n+                \"-Xlog:gc\",\n","filename":"test\/hotspot\/jtreg\/runtime\/Safepoint\/TestAbortOnVMOperationTimeout.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommandLineFlagCombo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,2 +134,2 @@\n-    \/\/ we support only jdk\/test\/whitebox\/WhiteBox$WhiteBoxPermission.\n-    \/\/ See JDK-8199290\n+    \/\/ we support only jdk\/test\/whitebox\/WhiteBox$WhiteBoxPermission and\n+    \/\/ sun\/hotspot\/WhiteBox$WhiteBoxPermission. See JDK-8199290\n@@ -139,0 +139,2 @@\n+        boolean seenOldWb = false;\n+        boolean seenOldWbInner = false;\n@@ -143,0 +145,2 @@\n+        final String oldWb = \"sun\/hotspot\/WhiteBox\";\n+        final String oldWbInner = oldWb + \"$WhiteBoxPermission\";\n@@ -152,0 +156,2 @@\n+            case oldWb:      seenOldWb      = true; break;\n+            case oldWbInner: seenOldWbInner = true; break;\n@@ -157,0 +163,4 @@\n+        if (seenOldWb && !seenOldWbInner) {\n+            list.add(oldWbInner);\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/JarBuilder.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CDSStreamTestDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/MainModuleOnly.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/MainModuleOnly.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-import jdk.test.whitebox.code.Compiler;\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.code.Compiler;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/IncompatibleOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,143 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-\/**\n- * @test\n- * @summary Check that timer slack options work\n- * @requires os.family == \"linux\"\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @run driver TestTimerSlack\n- *\/\n-public class TestTimerSlack {\n-\n-    public static void main(String[] args) throws Exception {\n-        int defaultSlack;\n-\n-        \/\/ Check the timer slack value is not printed by default\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:os+thread\",\n-                                                      \"TestTimerSlack$TestMain\");\n-\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.shouldHaveExitValue(0);\n-            output.shouldNotContain(\"timer slack:\");\n-        }\n-\n-        \/\/ Check the timer slack value is not printed when explicitly disabled\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:os+thread\",\n-                                                      \"-XX:+UnlockExperimentalVMOptions\",\n-                                                      \"-XX:TimerSlack=-1\",\n-                                                      \"TestTimerSlack$TestMain\");\n-\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.shouldHaveExitValue(0);\n-            output.shouldNotContain(\"timer slack:\");\n-        }\n-\n-        \/\/ Check the timer slack value is good when system-wide default is requested\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:os+thread\",\n-                                                      \"-XX:+UnlockExperimentalVMOptions\",\n-                                                      \"-XX:TimerSlack=0\",\n-                                                      \"TestTimerSlack$TestMain\");\n-\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.shouldHaveExitValue(0);\n-            output.shouldContain(\"timer slack:\");\n-\n-            defaultSlack = parseSlackValue(output);\n-\n-            if (defaultSlack == 0) {\n-                fail(output, \"Default slack value (\" + defaultSlack + \") is unexpected\");\n-            }\n-        }\n-\n-        \/\/ Check the timer slack value is accepted by all threads\n-        for (int slack : new int[] {1, 10, 100, 1000, 10000, 100000, 1000000}) {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:os+thread\",\n-                                                      \"-XX:+UnlockExperimentalVMOptions\",\n-                                                      \"-XX:TimerSlack=\" + slack,\n-                                                      \"TestTimerSlack$TestMain\");\n-\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.shouldHaveExitValue(0);\n-            output.shouldContain(\"timer slack:\");\n-\n-            int actualSlack = parseSlackValue(output);\n-            if (actualSlack != slack) {\n-                fail(output, \"Actual slack value (\" + actualSlack + \") is not the requested one (\" + slack + \")\");\n-            }\n-        }\n-    }\n-\n-    static final Pattern EXTRACT_PATTERN = Pattern.compile(\"(.*)timer slack: ([0-9]+)ns(.*)\");\n-\n-    public static int parseSlackValue(OutputAnalyzer output) {\n-        Integer value = null;\n-        for (String s : output.asLines()) {\n-            Matcher m = EXTRACT_PATTERN.matcher(s);\n-            if (m.matches()) {\n-                Integer parsedValue = Integer.parseInt(m.group(2));\n-                if (value == null) {\n-                    value = parsedValue;\n-                } else if (!value.equals(parsedValue)) {\n-                    fail(output, \"Multiple timer slack values detected\");\n-                }\n-            }\n-        }\n-        if (value == null) {\n-            fail(output, \"No timer slack values detected\");\n-        }\n-        return value;\n-    }\n-\n-    private static void fail(OutputAnalyzer output, String msg) {\n-        output.reportDiagnosticSummary();\n-        throw new IllegalStateException(msg);\n-    }\n-\n-    public static class TestMain {\n-        static final int THREADS = 8;\n-\n-        public static void main(String... args) throws Exception {\n-            Thread[] ts = new Thread[THREADS];\n-            for (int c = 0; c < THREADS; c++) {\n-                ts[c] = new Thread();\n-                ts[c].start();\n-            }\n-\n-            for (int c = 0; c < THREADS; c++) {\n-                ts[c].join();\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTimerSlack.java","additions":0,"deletions":143,"binary":false,"changes":143,"status":"deleted"},{"patch":"@@ -53,1 +53,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/runtime\/stringtable\/StringTableCleaningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires (os.family==\"linux\") & !vm.musl\n+ * @requires os.family == \"linux\"\n@@ -45,1 +45,4 @@\n-        output.shouldMatch(\".*Trim native heap: RSS\\\\+Swap: \\\\d+[BKM]->\\\\d+[BKM].*\");\n+        output.shouldMatch(\"(Done|Not available)\"); \/\/ Not available could happen on Linux + non-glibc (eg. muslc)\n+        if (output.firstMatch(\"Done\") != null) {\n+            output.shouldMatch(\"(Virtual size before|RSS before|Swap before|No details available)\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n@@ -32,1 +32,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestUniverse.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    static final String DEBUGGEE_RESULT = DEBUGGEE_CLASS + \".notInterrupted\";\n+    static final String DEBUGGEE_RESULT = DEBUGGEE_CLASS + \".notInterrupted.get()\";\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/interrupt\/interrupt001\/interrupt001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+                    notInterrupted.decrementAndGet();\n@@ -60,1 +61,0 @@\n-                        notInterrupted--;\n@@ -86,1 +86,1 @@\n-    public static volatile int notInterrupted = numThreads;\n+    public static final AtomicInteger notInterrupted = new AtomicInteger(numThreads);\n@@ -125,2 +125,2 @@\n-        synchronized (waitnotify) {\n-            while (notInterrupted > 0 && System.currentTimeMillis() - startTime <= waitTime) {\n+        while (notInterrupted.get() > 0 && System.currentTimeMillis() - startTime <= waitTime) {\n+            synchronized (waitnotify) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/interrupt\/interrupt001\/interrupt001a.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n@@ -66,1 +66,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF08\/gf08t001\/TestDriver.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -220,4 +220,0 @@\n-                cmdline += \" -waittime \" + argumentHandler.getWaitTime();\n-                if (argumentHandler.verbose()) {\n-                    cmdline += \" -verbose\";\n-                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,245 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package xpath;\n-\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.w3c.dom.Document;\n-import org.w3c.dom.Node;\n-import org.w3c.dom.NodeList;\n-\n-\/*\n- * @test\n- * @bug 8289510\n- * @library \/javax\/xml\/jaxp\/unittest\n- * @run testng\/othervm xpath.XPathExpNamespaceTest\n- * @summary Tests for XPath namespace axis specifier.\n- *\/\n-public class XPathExpNamespaceTest extends XPathTestBase {\n-    static final String RAW_XML\n-            = \"<Customers xmlns:foo=\\\"www.foo.com\\\">\"\n-            + \"    <Customer id=\\\"x1\\\">\"\n-            + \"        <Name>name1<\/Name>\"\n-            + \"        <Phone>1111111111<\/Phone>\"\n-            + \"        <Email id=\\\"x\\\">123@xyz.com<\/Email>\"\n-            + \"        <Address>\"\n-            + \"            <Street xmlns:street=\\\"www.street.com\\\" xmlns:bstreet=\\\"www.bstreet.com\\\">1111 111st ave<\/Street>\"\n-            + \"            <City>The City<\/City>\"\n-            + \"            <State>The State<\/State>\"\n-            + \"        <\/Address>\"\n-            + \"    <\/Customer>\"\n-            + \"    <Customer id=\\\"x2\\\" xmlns:dog=\\\"www.pets.com\\\">\"\n-            + \"        <Name>name2<\/Name>\"\n-            + \"        <Phone>2222222222<\/Phone>\"\n-            + \"        <Email id=\\\"y\\\">123@xyz.com<\/Email>\"\n-            + \"        <dog:Address>\"\n-            + \"            <Street>2222 222nd ave<\/Street>\"\n-            + \"            <City>The City<\/City>\"\n-            + \"            <State>The State<\/State>\"\n-            + \"        <\/dog:Address>\"\n-            + \"    <\/Customer>\"\n-            + \"    <Customer id=\\\"x3\\\">\"\n-            + \"        <Name>name3<\/Name>\"\n-            + \"        <Phone>3333333333<\/Phone>\"\n-            + \"        <Email id=\\\"z\\\">123@xyz.com<\/Email>\"\n-            + \"        <Address>\"\n-            + \"            <Street>3333 333rd ave<\/Street>\"\n-            + \"            <City>The City<\/City>\"\n-            + \"            <State>The State<\/State>\"\n-            + \"        <\/Address>\"\n-            + \"    <\/Customer>\"\n-            + \"    <foo:Customer foo:id=\\\"x1\\\">\"\n-            + \"        <foo:Name>name1<\/foo:Name>\"\n-            + \"        <foo:Phone>1111111111<\/foo:Phone>\"\n-            + \"        <foo:Email foo:id=\\\"x\\\">123@xyz.com<\/foo:Email>\"\n-            + \"        <foo:Address>\"\n-            + \"            <foo:Street>1111 111st ave<\/foo:Street>\"\n-            + \"            <foo:City>The City<\/foo:City>\"\n-            + \"            <foo:State>The State<\/foo:State>\"\n-            + \"        <\/foo:Address>\"\n-            + \"    <\/foo:Customer>\"\n-            + \"    <VendCustomer id=\\\"vx1\\\">\"\n-            + \"        <Name>name3<\/Name>\"\n-            + \"        <Phone>3333333333<\/Phone>\"\n-            + \"        <Email id=\\\"z\\\">123@xyz.com<\/Email>\"\n-            + \"        <Address xmlns=\\\"default-namespace-uri\\\">\"\n-            + \"            <Street>3333 333rd ave<\/Street>\"\n-            + \"            <City xmlns=\\\"redeclared-namespace-uri\\\">The City<\/City>\"\n-            + \"            <State>The State<\/State>\"\n-            + \"        <\/Address>\"\n-            + \"    <\/VendCustomer>\"\n-            + \"<\/Customers>\";\n-\n-    \/*\n-     * DataProvider: provides XPath namespace expressions and expected local name, expected namespace prefix, expected\n-     * namespace node name, and expected namespace Uri.\n-     *\/\n-    @DataProvider(name = \"namespaceXpath\")\n-    public Object[][] getNamespaceXpathExpression() {\n-        return new Object[][] {\n-                {\"\/Customers\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\",\"www.foo.com\"},\n-                {\"\/Customers\/namespace::xml\", \"xml\", \"xml\", \"xmlns:xml\", \"http:\/\/www.w3.org\/XML\/1998\/namespace\"},\n-                {\"\/\/Customer\/Name\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\",\"www.foo.com\"},\n-                {\"\/Customers\/Customer\/Name\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\",\"www.foo.com\"},\n-                {\"\/\/Customer\/Name\/namespace::xml\", \"xml\", \"xml\", \"xmlns:xml\",\"http:\/\/www.w3.org\/XML\/1998\/namespace\"},\n-                {\"\/Customers\/Customer\/Name\/namespace::xml\", \"xml\", \"xml\", \"xmlns:xml\",\"http:\/\/www.w3.org\/XML\/1998\/namespace\"},\n-                {\"\/\/Customer\/Name\/namespace::dog\", \"dog\", \"xmlns\", \"xmlns:dog\",\"www.pets.com\"},\n-                {\"\/Customers\/Customer\/Name\/namespace::dog\", \"dog\", \"xmlns\", \"xmlns:dog\",\"www.pets.com\"},\n-                {\"\/\/www.foo.com:Customer\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\", \"www.foo.com\"},\n-                {\"\/Customers\/*[name() = 'foo:Customer']\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\", \"www.foo.com\"},\n-                {\"\/Customers\/*[namespace-uri() = 'www.foo.com']\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\", \"www.foo.com\"},\n-                {\"\/Customers\/*[contains(name(.), 'foo:')]\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\", \"www.foo.com\"},\n-                {\"\/Customers\/*[starts-with(name(.), 'foo:')]\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\", \"www.foo.com\"},\n-                {\"\/\/*[local-name()='Customer' and namespace-uri() = 'www.foo.com']\/namespace::foo\", \"foo\", \"xmlns\", \"xmlns:foo\", \"www.foo.com\"},\n-                {\"\/Customers\/VendCustomer\/default-namespace-uri:Address\/namespace::*[name()='']\", \"xmlns\", null, \"xmlns\",\"default-namespace-uri\"},\n-                {\"\/Customers\/VendCustomer\/default-namespace-uri:Address\/redeclared-namespace-uri:City\/namespace::*[name()='']\", \"xmlns\", null, \"xmlns\",\"redeclared-namespace-uri\"}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider: provides XPath namespace expressions which should return no namespace nodes.\n-     *\/\n-    @DataProvider(name = \"namespaceXpathEmpty\")\n-    public Object[][] getNamespaceXpathExpressionEmpty() {\n-        return new Object[][] {\n-                {\"\/\/VendCustomer\/Name\/namespace::dog\"},\n-                {\"\/Customers\/VendCustomer\/Name\/namespace::dog\"},\n-                {\"\/\/Customer\/Name\/namespace::cat\"},\n-                {\"\/Customers\/Customer\/Name\/namespace::cat\"},\n-                {\"\/\/Customer\/Address\/namespace::street\"},\n-                {\"\/Customers\/Customer\/Address\/namespace::street\"},\n-                {\"\/\/VendCustomer\/Address\/namespace::street\"},\n-                {\"\/Customers\/VendCustomer\/Address\/namespace::street\"},\n-                {\"\/\/@id\/namespace::*\"},\n-                {\"\/\/@*[name() = 'foo:id']\/namespace::*\"},\n-                {\"\/\/@*[local-name() = 'id' and namespace-uri() = 'www.foo.com']\/namespace::*\"}\n-        };\n-\n-    }\n-\n-    \/*\n-     * DataProvider: provides XPath namespace expressions and expected total number of namespace nodes count.\n-     *\/\n-    @DataProvider(name = \"namespaceXpathNodeCount\")\n-    public Object[][] getNamespaceXpathExpressionNodeCount() {\n-        return new Object[][] {\n-                {\"\/Customers\/namespace::*\", 2},\n-                {\"\/Customers\/Customer\/namespace::*\", 3},\n-                {\"\/Customers\/Customer\/Address\/namespace::*\", 2},\n-                {\"\/Customers\/www.foo.com:Customer\/www.foo.com:Address\/namespace::*\", 2},\n-                {\"\/Customers\/*[name()='foo:Customer']\/*[name() = 'foo:Address']\/namespace::*\", 2},\n-                {\"\/Customers\/Customer\/Address\/Street\/namespace::*\", 4},\n-                {\"\/Customers\/Customer\/Address\/City\/namespace::*\", 2},\n-                {\"\/Customers\/VendCustomer\/namespace::*\", 2},\n-                {\"\/Customers\/VendCustomer\/default-namespace-uri:Address\/namespace::*\", 3},\n-                {\"\/Customers\/VendCustomer\/default-namespace-uri:Address\/redeclared-namespace-uri:City\/namespace::*\", 3},\n-                {\"\/Customers\/Customer[@id='x1']\/namespace::*\", 2}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider: provides node functions and expected return of different node functions.\n-     *\/\n-    @DataProvider(name = \"namespaceUsingNodeFunctions\")\n-    public Object[][] getNamespaceNodeNameAndUri() {\n-        return new Object[][] {\n-                {\"namespace-uri(\/\/www.foo.com:Customer)\",\"www.foo.com\" },\n-                {\"namespace-uri(\/\/www.pets.com:Address)\",\"www.pets.com\" },\n-                {\"namespace-uri(\/Customers\/www.foo.com:Customer)\",\"www.foo.com\" },\n-                {\"namespace-uri(\/Customers\/Customer\/www.pets.com:Address)\",\"www.pets.com\" },\n-                {\"namespace-uri(\/Customers\/VendCustomer\/Email)\",\"\" },\n-                {\"namespace-uri(\/\/@*[name() = 'id'])\", \"\"},\n-                {\"namespace-uri(\/\/@*[name() = 'foo:id'])\", \"www.foo.com\"}\n-        };\n-    }\n-\n-    \/**\n-     * Verifies namespace expression retrieves different namespace nodes.\n-     * @param  exp        XPath expression.\n-     * @param  localName  expected local name of namespace node.\n-     * @param  nsPrefix   expected namespace prefix of namespace node.\n-     * @param  nsNodeName expected name of namespace node.\n-     * @param  nsUri      expected namespace Uri.\n-     * @throws XPathExpressionException\n-     *\/\n-    @Test(dataProvider = \"namespaceXpath\")\n-    public void namespaceExpTests(String exp, String localName, String nsPrefix, String nsNodeName, String nsUri) throws XPathExpressionException {\n-        Document doc = documentOf(DECLARATION + RAW_XML);\n-        XPath xPath = XPathFactory.newInstance().newXPath();\n-        Node node = xPath.evaluateExpression(exp, doc, Node.class);\n-        Assert.assertEquals(node.getLocalName(), localName);\n-        Assert.assertEquals(node.getPrefix(), nsPrefix);\n-        Assert.assertEquals(node.getNodeName(), nsNodeName);\n-        Assert.assertEquals(node.getNodeValue(),nsUri);\n-    }\n-\n-    \/**\n-     * Verifies namespace path expression return no nodes if namespace expression context nodes don't have namespace\n-     * @param  exp     XPath expression.\n-     * @throws XPathExpressionException\n-     *\/\n-    @Test(dataProvider = \"namespaceXpathEmpty\")\n-    public void NamespaceScopeTests(String exp) throws XPathExpressionException {\n-        Document doc = documentOf(DECLARATION + RAW_XML);\n-        XPath xPath = XPathFactory.newInstance().newXPath();\n-        Node node = xPath.evaluateExpression(exp, doc, Node.class);\n-        Assert.assertNull(node);\n-    }\n-\n-    \/**\n-     * Verifies namespace path expression return namespace nodes list with correct number of nodes.\n-     * @param  exp       XPath expression.\n-     * @param  nodeCount number of namespace nodes in nodelist.\n-     * @throws XPathExpressionException\n-     *\/\n-    @Test(dataProvider = \"namespaceXpathNodeCount\")\n-    public void NamespaceNodesCountTests(String exp, int nodeCount) throws XPathExpressionException {\n-        Document doc = documentOf(DECLARATION + RAW_XML);\n-        XPath xPath = XPathFactory.newInstance().newXPath();\n-        NodeList nodeList = (NodeList) xPath.evaluate(exp, doc, XPathConstants.NODESET);\n-        Assert.assertEquals(nodeList.getLength(), nodeCount);\n-    }\n-\n-    \/**\n-     * Verifies namespace-uri functions returns the correct namespace uri.\n-     * @param  exp          XPath expression.\n-     * @param  expectedName number of namespace nodes in nodelist.\n-     * @throws XPathExpressionException\n-     *\/\n-    @Test(dataProvider = \"namespaceUsingNodeFunctions\")\n-    public void NamespaceNodeFunctionsTests(String exp, String expectedName) throws XPathExpressionException {\n-        Document doc = documentOf(DECLARATION + RAW_XML);\n-        XPath xPath = XPathFactory.newInstance().newXPath();\n-        String s = xPath.evaluateExpression(exp, doc, String.class);\n-        String s2 = (String) xPath.evaluate(exp, doc, XPathConstants.STRING);\n-        Assert.assertEquals(s, expectedName);\n-        Assert.assertEquals(s2, s);\n-    }\n-\n-}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathExpNamespaceTest.java","additions":0,"deletions":245,"binary":false,"changes":245,"status":"deleted"},{"patch":"@@ -638,0 +638,4 @@\n+sun\/security\/tools\/keytool\/ListKeychainStore.sh                 8156889 macosx-all\n+\n+sun\/security\/tools\/jarsigner\/warnings\/BadKeyUsageTest.java      8026393 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-import jdk.test.whitebox.gc.GC;\n+import sun.hotspot.gc.GC;\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,1 +176,1 @@\n-                handleSocketException(socket, t);\n+                t.printStackTrace();\n@@ -192,9 +192,0 @@\n-    \/*\n-     * Called to handle exceptions observed on an established client connection.\n-     *\n-     * By default, an exception stack trace is printed.\n-     *\/\n-    protected void handleSocketException(Socket socket, Throwable exception) {\n-        exception.printStackTrace();\n-    }\n-\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/lib\/BaseLdapServer.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+\n@@ -34,1 +35,0 @@\n-import javax.security.auth.login.FailedLoginException;\n@@ -37,4 +37,0 @@\n-\n-    private static final String UNIX_MODULE = \"UnixLoginModule\";\n-    private static final String NT_MODULE = \"NTLoginModule\";\n-\n@@ -43,4 +39,13 @@\n-                UNIX_MODULE, \"optional\",\n-                NT_MODULE, \"optional\");\n-        login(\"windows\", NT_MODULE, \"required\");\n-        login(\"unix\", UNIX_MODULE, \"required\");\n+                \"UnixLoginModule\", \"optional\",\n+                \"NTLoginModule\", \"optional\",\n+                \"SolarisLoginModule\", \"optional\");\n+        try {\n+            login(\"windows\", \"NTLoginModule\", \"required\");\n+            login(\"unix\", \"UnixLoginModule\", \"required\");\n+            login(\"solaris\", \"SolarisLoginModule\", \"required\");\n+        } catch (Exception e) {\n+            e.printStackTrace(System.out);\n+            if (e.toString().contains(\"UnsatisfiedLinkError\")) {\n+                throw new Exception(\"This is ugly\");\n+            }\n+        }\n@@ -54,4 +59,3 @@\n-        for (int i = 0; i < conf.length; i += 2) {\n-            sb.append(\"    com.sun.security.auth.module.\")\n-                    .append(conf[i]).append(\" \")\n-                    .append(conf[i + 1]).append(\";\\n\");\n+        for (int i=0; i<conf.length; i+=2) {\n+            sb.append(\"    com.sun.security.auth.module.\" + conf[i]\n+                    + \" \" + conf[i+1] + \";\\n\");\n@@ -66,12 +70,3 @@\n-        try {\n-            LoginContext lc = new LoginContext(\"hello\");\n-            lc.login();\n-            System.out.println(lc.getSubject());\n-            lc.logout();\n-        } catch (FailedLoginException e) {\n-            \/\/ This exception can occur in other platform module than the running one.\n-            if(e.getMessage().startsWith(\"Failed in attempt to import\")) {\n-                System.out.println(\"Expected Exception found.\");\n-                e.printStackTrace(System.out);\n-            }\n-        }\n+        LoginContext lc = new LoginContext(\"hello\");\n+        lc.login();\n+        System.out.println(lc.getSubject());\n","filename":"test\/jdk\/com\/sun\/security\/auth\/module\/AllPlatforms.java","additions":21,"deletions":26,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        frame.pack();\n+        frame.setSize(400, 400);\n","filename":"test\/jdk\/java\/awt\/Choice\/DragOffNoSelectTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-    volatile DragSourcePanel dragSourcePanel;\n-    volatile DropTargetPanel dropTargetPanel;\n+    DragSourcePanel dragSourcePanel;\n+    DropTargetPanel dropTargetPanel;\n@@ -106,0 +106,1 @@\n+            robot.setAutoWaitForIdle(true);\n@@ -136,1 +137,0 @@\n-            robot.waitForIdle();\n@@ -247,1 +247,1 @@\n-    volatile boolean passed = false;\n+    boolean passed = false;\n","filename":"test\/jdk\/java\/awt\/dnd\/NoFormatsDropTest\/NoFormatsDropTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n- * @test\n@@ -30,1 +29,1 @@\n- * @run main\/manual InitToBlack\n+ * @run applet\/manual=yesno InitToBlack.html\n@@ -33,18 +32,3 @@\n-import java.awt.BorderLayout;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.print.Book;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-import java.awt.print.PrinterJob;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import javax.swing.JButton;\n-import javax.swing.JDialog;\n-import javax.swing.JFrame;\n-import javax.swing.JLabel;\n-import javax.swing.JPanel;\n-import javax.swing.JTextArea;\n-import javax.swing.SwingUtilities;\n+import java.awt.*;\n+import java.awt.print.*;\n+import java.applet.Applet;\n@@ -52,1 +36,1 @@\n-public class InitToBlack implements Printable {\n+public class InitToBlack extends Applet implements Printable {\n@@ -54,17 +38,1 @@\n-    private static volatile JFrame frame;\n-    private static volatile boolean testResult = false;\n-    private static volatile CountDownLatch printButtonCountDownLatch =\n-            new CountDownLatch(1);\n-    private static volatile CountDownLatch CountDownLatch =\n-            new CountDownLatch(1);\n-    private static volatile String failureReason;\n-\n-    @Override\n-    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n-        Graphics2D g2d = (Graphics2D) graphics;\n-        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n-        graphics.drawString(\"Test Passes\", 200, 200);\n-        return PAGE_EXISTS;\n-    }\n-\n-    private void test() {\n+    public void init() {\n@@ -72,4 +40,0 @@\n-        if (pjob.getPrintService() == null) {\n-            System.out.println(\"There is no printer configured on this system\");\n-            return;\n-        }\n@@ -88,61 +52,3 @@\n-    private static void createTestUI() {\n-        frame = new JFrame(\"Test InitToBlack\");\n-        String INSTRUCTION = \"\"\"\n-                Aim: This test checks whether the default foreground color on a printer\n-                graphics object is black so that rendering will appear without having\n-                to execute setColor.\n-                Step:\n-                1) Click on the \"Print\" button. Check whether page is printed on the printer.\n-                2) Check whether \"Test Passes\" is printed on the page and it should be in\n-                black color. If yes then press \"Pass\" button else press \"Fail\" button.\n-                \"\"\";\n-        JTextArea instructionTextArea = new JTextArea(INSTRUCTION, 4, 40);\n-        instructionTextArea.setEditable(false);\n-\n-        JPanel buttonPanel = new JPanel();\n-        JButton printButton = new JButton(\"Print\");\n-        printButton.addActionListener((ae) -> {\n-            InitToBlack initToBlack = new InitToBlack();\n-            initToBlack.test();\n-            printButtonCountDownLatch.countDown();\n-        });\n-\n-        JButton passButton = new JButton(\"Pass\");\n-        passButton.addActionListener((ae) -> {\n-            testResult = true;\n-            CountDownLatch.countDown();\n-            frame.dispose();\n-        });\n-        JButton failButton = new JButton(\"Fail\");\n-        failButton.addActionListener((ae) -> {\n-            getFailureReason();\n-            frame.dispose();\n-        });\n-        buttonPanel.add(printButton);\n-        buttonPanel.add(passButton);\n-        buttonPanel.add(failButton);\n-\n-        JPanel panel = new JPanel(new BorderLayout());\n-        panel.add(instructionTextArea, BorderLayout.CENTER);\n-        panel.add(buttonPanel, BorderLayout.SOUTH);\n-\n-        frame.add(panel);\n-        frame.setLocationRelativeTo(null);\n-        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public static void getFailureReason() {\n-        final JDialog dialog = new JDialog();\n-        dialog.setTitle(\"Read testcase failure reason\");\n-        JPanel jPanel = new JPanel(new BorderLayout());\n-        JTextArea jTextArea = new JTextArea(5, 20);\n-\n-        JButton okButton = new JButton(\"Ok\");\n-        okButton.addActionListener((ae) -> {\n-            failureReason = jTextArea.getText();\n-            testResult = false;\n-            CountDownLatch.countDown();\n-            dialog.dispose();\n-        });\n+    public int print(Graphics g, PageFormat pf, int pageIndex) {\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pf.getImageableX(), pf.getImageableY());\n@@ -150,3 +56,1 @@\n-        jPanel.add(new JLabel(\"Enter the testcase failed reason below and \" +\n-                \"click OK button\", JLabel.CENTER), BorderLayout.NORTH);\n-        jPanel.add(jTextArea, BorderLayout.CENTER);\n+        g.drawString(\"Test Passes\", 200, 200);\n@@ -154,8 +58,1 @@\n-        JPanel okayBtnPanel = new JPanel();\n-        okayBtnPanel.add(okButton);\n-\n-        jPanel.add(okayBtnPanel, BorderLayout.SOUTH);\n-        dialog.add(jPanel);\n-        dialog.setLocationRelativeTo(null);\n-        dialog.pack();\n-        dialog.setVisible(true);\n+        return PAGE_EXISTS;\n@@ -164,16 +61,3 @@\n-    public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n-        SwingUtilities.invokeAndWait(InitToBlack::createTestUI);\n-        if (!printButtonCountDownLatch.await(2, TimeUnit.MINUTES)) {\n-            throw new RuntimeException(\"Timeout: User did not perform action \" +\n-                    \"on Print button.\");\n-        }\n-        if (!CountDownLatch.await(2, TimeUnit.MINUTES)) {\n-            throw new RuntimeException(\"Timeout : User did not decide \" +\n-                    \"whether test passed or failed\");\n-        }\n-\n-        if (!testResult) {\n-            throw new RuntimeException(\"Test failed : \" + failureReason);\n-        } else {\n-            System.out.println(\"Test Passed\");\n-        }\n+    public static void main(String[] args) {\n+        new InitToBlack().init();\n+        System.exit(0);\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/InitToBlack.java","additions":15,"deletions":131,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,39 +33,1 @@\n-\/*\n- * @test id=G1\n- * @requires vm.gc.G1\n- * @bug 8277072\n- * @library \/test\/lib\/\n- * @summary ObjectStreamClass caches keep ClassLoaders alive (G1 GC)\n- * @run testng\/othervm -Xmx64m -XX:+UseG1GC ObjectStreamClassCaching\n- *\/\n-\n-\/*\n- * @test id=Parallel\n- * @requires vm.gc.Parallel\n- * @bug 8277072\n- * @library \/test\/lib\/\n- * @summary ObjectStreamClass caches keep ClassLoaders alive (Parallel GC)\n- * @run testng\/othervm -Xmx64m -XX:+UseParallelGC ObjectStreamClassCaching\n- *\/\n-\n-\/*\n- * @test id=Z\n- * @requires vm.gc.Z\n- * @bug 8277072\n- * @library \/test\/lib\/\n- * @summary ObjectStreamClass caches keep ClassLoaders alive (Z GC)\n- * @run testng\/othervm -Xmx64m -XX:+UseZGC ObjectStreamClassCaching\n- *\/\n-\n-\/*\n- * @test id=Shenandoah\n- * @requires vm.gc.Shenandoah\n- * @bug 8277072\n- * @library \/test\/lib\/\n- * @summary ObjectStreamClass caches keep ClassLoaders alive (Shenandoah GC)\n- * @run testng\/othervm -Xmx64m -XX:+UseShenandoahGC ObjectStreamClassCaching\n- *\/\n-\n-\/*\n- * @test id=Serial\n- * @requires vm.gc.Serial\n+\/* @test\n@@ -74,2 +36,2 @@\n- * @summary ObjectStreamClass caches keep ClassLoaders alive (Serial GC)\n- * @run testng\/othervm -Xmx64m -XX:+UseSerialGC ObjectStreamClassCaching\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive\n+ * @run testng\/othervm -Xmx10m -XX:SoftRefLRUPolicyMSPerMB=1 ObjectStreamClassCaching\n@@ -79,4 +41,0 @@\n-    \/**\n-     * Test methods execute in same VM and are ordered by name.\n-     * We test effectiveness 1st which is sensitive to previous allocations when ZGC is used.\n-     *\/\n@@ -84,19 +42,2 @@\n-    public void test1CacheEffectiveness() throws Exception {\n-        var list = new ArrayList<>();\n-        var ref1 = lookupObjectStreamClass(TestClass1.class);\n-        var ref2 = newWeakRef();\n-        boolean oome = false;\n-        try {\n-            while (!ref2.refersTo(null)) {\n-                list.add(new byte[1024 * 1024 * 1]); \/\/ 1 MiB chunks\n-                System.out.println(\"1MiB allocated...\");\n-                Thread.sleep(5L);\n-            }\n-        } catch (OutOfMemoryError e) {\n-            \/\/ release\n-            list = null;\n-            oome = true;\n-        }\n-        assertFalse(oome, \"WeakReference was not cleared although memory was pressed hard\");\n-        assertFalse(ref1.refersTo(null),\n-                    \"Cache lost entry together with WeakReference being cleared although memory was not under pressure\");\n+    public void testCachingEffectiveness() throws Exception {\n+        var ref = lookupObjectStreamClass(TestClass.class);\n@@ -105,0 +46,4 @@\n+        \/\/ to trigger any ReferenceQueue processing...\n+        lookupObjectStreamClass(AnotherTestClass.class);\n+        assertFalse(ref.refersTo(null),\n+                    \"Cache lost entry although memory was not under pressure\");\n@@ -108,12 +53,3 @@\n-    public void test2CacheReleaseUnderMemoryPressure() throws Exception {\n-        var list = new ArrayList<>();\n-        var ref = lookupObjectStreamClass(TestClass2.class);\n-        try {\n-            while (!ref.refersTo(null)) {\n-                list.add(new byte[1024 * 1024 * 4]); \/\/ 4 MiB chunks\n-                System.out.println(\"4MiB allocated...\");\n-            }\n-        } catch (OutOfMemoryError e) {\n-            \/\/ release\n-            list = null;\n-        }\n+    public void testCacheReleaseUnderMemoryPressure() throws Exception {\n+        var ref = lookupObjectStreamClass(TestClass.class);\n+        pressMemoryHard(ref);\n@@ -127,1 +63,1 @@\n-    private static Reference<?> lookupObjectStreamClass(Class<?> cl) {\n+    private static WeakReference<?> lookupObjectStreamClass(Class<?> cl) {\n@@ -131,3 +67,9 @@\n-    \/\/ separate method so that the new Object() is not kept on stack\n-    private static Reference<?> newWeakRef() {\n-        return new WeakReference<>(new Object());\n+    private static void pressMemoryHard(Reference<?> ref) {\n+        try {\n+            var list = new ArrayList<>();\n+            while (!ref.refersTo(null)) {\n+                list.add(new byte[1024 * 1024 * 64]); \/\/ 64 MiB chunks\n+            }\n+        } catch (OutOfMemoryError e) {\n+            \/\/ release\n+        }\n@@ -135,0 +77,1 @@\n+}\n@@ -136,2 +79,2 @@\n-    static class TestClass1 implements Serializable {\n-    }\n+class TestClass implements Serializable {\n+}\n@@ -139,2 +82,1 @@\n-    static class TestClass2 implements Serializable {\n-    }\n+class AnotherTestClass implements Serializable {\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/ObjectStreamClassCaching.java","additions":27,"deletions":85,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/CollectionUsageThreshold.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/LowMemoryTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import jdk.test.whitebox.code.Compiler;\n+import sun.hotspot.code.Compiler;\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/ResetPeakMemoryUsage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8196965 8302475\n+ * @bug 8196965\n@@ -130,12 +130,12 @@\n-            { \"030\", \"attachment; filename=\\\"foo\/file1.txt\\\"\",        \"file1.txt\" },\n-            { \"031\", \"attachment; filename=\\\"foo\/bar\/file2.txt\\\"\",    \"file2.txt\" },\n-            { \"032\", \"attachment; filename=\\\"baz\\\\\\\\file3.txt\\\"\",       \"file3.txt\" },\n-            { \"033\", \"attachment; filename=\\\"baz\\\\\\\\bar\\\\\\\\file4.txt\\\"\",  \"file4.txt\" },\n-            { \"034\", \"attachment; filename=\\\"x\/y\\\\\\\\file5.txt\\\"\",       \"file5.txt\" },\n-            { \"035\", \"attachment; filename=\\\"x\/y\\\\\\\\file6.txt\\\"\",       \"file6.txt\" },\n-            { \"036\", \"attachment; filename=\\\"x\/y\\\\\\\\z\/file7.txt\\\"\",     \"file7.txt\" },\n-            { \"037\", \"attachment; filename=\\\"x\/y\\\\\\\\z\/\\\\\\\\x\/file8.txt\\\"\", \"file8.txt\" },\n-            { \"038\", \"attachment; filename=\\\"\/root\/file9.txt\\\"\",      \"file9.txt\" },\n-            { \"039\", \"attachment; filename=\\\"..\/file10.txt\\\"\",        \"file10.txt\" },\n-            { \"040\", \"attachment; filename=\\\"..\\\\\\\\file11.txt\\\"\",       \"file11.txt\" },\n-            { \"041\", \"attachment; filename=\\\"foo\/..\/..\/file12.txt\\\"\", \"file12.txt\" },\n+            { \"030\", \"attachment; filename=foo\/file1.txt\",        \"file1.txt\" },\n+            { \"031\", \"attachment; filename=foo\/bar\/file2.txt\",    \"file2.txt\" },\n+            { \"032\", \"attachment; filename=baz\\\\file3.txt\",       \"file3.txt\" },\n+            { \"033\", \"attachment; filename=baz\\\\bar\\\\file4.txt\",  \"file4.txt\" },\n+            { \"034\", \"attachment; filename=x\/y\\\\file5.txt\",       \"file5.txt\" },\n+            { \"035\", \"attachment; filename=x\/y\\\\file6.txt\",       \"file6.txt\" },\n+            { \"036\", \"attachment; filename=x\/y\\\\z\/file7.txt\",     \"file7.txt\" },\n+            { \"037\", \"attachment; filename=x\/y\\\\z\/\\\\x\/file8.txt\", \"file8.txt\" },\n+            { \"038\", \"attachment; filename=\/root\/file9.txt\",      \"file9.txt\" },\n+            { \"039\", \"attachment; filename=..\/file10.txt\",        \"file10.txt\" },\n+            { \"040\", \"attachment; filename=..\\\\file11.txt\",       \"file11.txt\" },\n+            { \"041\", \"attachment; filename=foo\/..\/..\/file12.txt\", \"file12.txt\" },\n@@ -180,1 +180,0 @@\n-        Path body = response.body();\n@@ -182,1 +181,1 @@\n-        out.println(\"Got body Path: \" + body);\n+        out.println(\"Got body Path: \" + response.body());\n@@ -187,1 +186,1 @@\n-        assertEquals(body.getFileName().toString(), expectedFilename);\n+        assertEquals(response.body().getFileName().toString(), expectedFilename);\n@@ -193,5 +192,0 @@\n-        if (!body.toAbsolutePath().startsWith(tempDir.toAbsolutePath())) {\n-            System.out.println(\"Tempdir = \" + tempDir.toAbsolutePath());\n-            System.out.println(\"body = \" + body.toAbsolutePath());\n-            throw new AssertionError(\"body in wrong location\");\n-        }\n","filename":"test\/jdk\/java\/net\/httpclient\/AsFileDownloadTest.java","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8241960 8277353\n+ * @bug 8241960\n@@ -28,1 +28,1 @@\n- * @run main ThreadSafetyTest 4 2\n+ * @run main\/othervm ThreadSafetyTest 5 4\n@@ -59,1 +59,1 @@\n-        int nTasks = Math.min(nProcessors, 4) * threadsFactor;\n+        int nTasks = nProcessors * threadsFactor;\n","filename":"test\/jdk\/java\/security\/MessageDigest\/ThreadSafetyTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom NoSync\n+ * @run main\/othervm NoSync\n","filename":"test\/jdk\/java\/security\/SecureRandom\/NoSync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/CurrencySymbols.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import static java.util.Calendar.*;\n","filename":"test\/jdk\/java\/util\/Calendar\/CalendarTestScripts\/Symbol.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4173528 5068772 8148936 8196334 8308803\n+ * @bug 4173528 5068772 8148936 8196334\n@@ -28,4 +28,2 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.RandomFactory\n- * @run main\/othervm -Xmx1g -XX:+CompactStrings UUIDTest\n- * @run main\/othervm -Xmx1g -XX:-CompactStrings UUIDTest\n+ * @run main\/othervm -XX:+CompactStrings UUIDTest\n+ * @run main\/othervm -XX:-CompactStrings UUIDTest\n@@ -35,2 +33,0 @@\n-import java.util.stream.IntStream;\n-import jdk.test.lib.RandomFactory;\n@@ -40,4 +36,1 @@\n-    \/\/ Single UUID instance is ~32 bytes, 1M instances take ~256M in the set\n-    private static final int COUNT = 1_000_000;\n-\n-    static final Random generator = RandomFactory.getRandom();\n+    static Random generator = new Random();\n@@ -46,1 +39,1 @@\n-        negativeTest();\n+        containsTest();\n@@ -48,1 +41,0 @@\n-        randomUUIDTest_Multi();\n@@ -60,6 +52,6 @@\n-    private static void negativeTest() throws Exception {\n-        Set<UUID> set = new HashSet<>();\n-        set.add(new UUID(4, 4));\n-        if (set.add(new UUID(4, 4))) {\n-            throw new Exception(\"Contains test does not work as expected\");\n-        }\n+    \/\/ Verify that list.contains detects UUID collisons\n+    private static void containsTest() throws Exception {\n+        List list = new LinkedList();\n+        list.add(new UUID(4,4));\n+        if (!list.contains(new UUID(4,4)))\n+            throw new Exception(\"contains test did not work as expected\");\n@@ -69,38 +61,5 @@\n-        List<UUID> collisions = new ArrayList<>();\n-\n-        Set<UUID> set = new HashSet<>();\n-        for (int i = 0; i < COUNT; i++) {\n-            UUID u = UUID.randomUUID();\n-            if (u.version() != 4) {\n-                throw new Exception(\"Bad version: \" + u);\n-            }\n-            if (u.variant() != 2) {\n-                throw new Exception(\"Bad variant: \" + u);\n-            }\n-            if (!set.add(u)) {\n-                collisions.add(u);\n-            }\n-        }\n-\n-        if (!collisions.isEmpty()) {\n-           \/\/ This is extremely unlikely to happen. If you see this failure,\n-           \/\/ this highly likely points to the implementation bug, rather than\n-           \/\/ the odd chance.\n-           throw new Exception(\"UUID collisions detected: \" + collisions);\n-        }\n-    }\n-\n-    private static void randomUUIDTest_Multi() throws Exception {\n-        List<UUID> uuids = IntStream.range(0, COUNT).parallel()\n-                                    .mapToObj(i -> UUID.randomUUID())\n-                                    .toList();\n-\n-        List<UUID> collisions = new ArrayList<>();\n-\n-        Set<UUID> set = new HashSet<>();\n-        for (UUID u : uuids) {\n-            if (u.version() != 4) {\n-                throw new Exception(\"Bad version: \" + u);\n-            }\n-            if (u.variant() != 2) {\n-                throw new Exception(\"Bad variant: \" + u);\n+        List list = new LinkedList();\n+        for (int i=0; i<100; i++) {\n+            UUID u1 = UUID.randomUUID();\n+            if (4 != u1.version()) {\n+                throw new Exception(\"bad version\");\n@@ -108,2 +67,2 @@\n-            if (!set.add(u)) {\n-                collisions.add(u);\n+            if (2 != u1.variant()) {\n+                throw new Exception(\"bad variant\");\n@@ -111,7 +70,3 @@\n-        }\n-\n-        if (!collisions.isEmpty()) {\n-           \/\/ This is extremely unlikely to happen. If you see this failure,\n-           \/\/ this highly likely points to the implementation bug, rather than\n-           \/\/ the odd chance.\n-           throw new Exception(\"UUID collisions detected: \" + collisions);\n+            if (list.contains(u1))\n+                throw new Exception(\"random UUID collision very unlikely\");\n+            list.add(u1);\n@@ -121,1 +76,0 @@\n-\n@@ -123,2 +77,1 @@\n-        List<UUID> collisions = new ArrayList<>();\n-\n+        Random byteSource = new Random();\n@@ -126,9 +79,6 @@\n-        Set<UUID> set = new HashSet<>();\n-        for (int i = 0; i < COUNT; i++) {\n-            generator.nextBytes(someBytes);\n-            UUID u = UUID.nameUUIDFromBytes(someBytes);\n-            if (u.version() != 3) {\n-                throw new Exception(\"Bad version: \" + u);\n-            }\n-            if (u.variant() != 2) {\n-                throw new Exception(\"Bad variant: \" + u);\n+        List list = new LinkedList();\n+        for (int i=0; i<100; i++) {\n+            byteSource.nextBytes(someBytes);\n+            UUID u1 = UUID.nameUUIDFromBytes(someBytes);\n+            if (3 != u1.version()) {\n+                throw new Exception(\"bad version\");\n@@ -136,2 +86,2 @@\n-            if (!set.add(u)) {\n-                collisions.add(u);\n+            if (2 != u1.variant()) {\n+                throw new Exception(\"bad variant\");\n@@ -139,7 +89,3 @@\n-        }\n-\n-        if (!collisions.isEmpty()) {\n-           \/\/ This is extremely unlikely to happen. If you see this failure,\n-           \/\/ this highly likely points to the implementation bug, rather than\n-           \/\/ the odd chance.\n-           throw new Exception(\"UUID collisions detected: \" + collisions);\n+            if (list.contains(u1))\n+                throw new Exception(\"byte UUID collision very unlikely\");\n+            list.add(u1);\n@@ -150,1 +96,1 @@\n-        for (int i = 0; i < COUNT; i++) {\n+        for (int i=0; i<100; i++) {\n@@ -154,3 +100,2 @@\n-            if (!u1.equals(u2) || !u1.equals(u3)) {\n-                throw new Exception(\"UUID -> string -> UUID failed: \" + u1 + \" -> \" + u2 + \" -> \" + u3);\n-            }\n+            if (!u1.equals(u2) || !u1.equals(u3))\n+                throw new Exception(\"UUID -> string -> UUID failed\");\n@@ -179,4 +124,3 @@\n-        if (test.version() != 4) {\n-            throw new Exception(\"randomUUID not type 4: \" + test);\n-        }\n-\n+        if (test.version() != 4)\n+            throw new Exception(\"randomUUID not type 4\");\n+        Random byteSource = new Random();\n@@ -184,1 +128,1 @@\n-        generator.nextBytes(someBytes);\n+        byteSource.nextBytes(someBytes);\n@@ -186,4 +130,2 @@\n-        if (test.version() != 3) {\n-            throw new Exception(\"nameUUIDFromBytes not type 3: \" + test);\n-        }\n-\n+        if (test.version() != 3)\n+            throw new Exception(\"nameUUIDFromBytes not type 3\");\n@@ -191,1 +133,1 @@\n-        if (test.version() != 1) {\n+        if (test.version() != 1)\n@@ -193,2 +135,0 @@\n-        }\n-\n@@ -196,1 +136,1 @@\n-        if (test.version() != 2) {\n+        if (test.version() != 2)\n@@ -198,2 +138,0 @@\n-        }\n-\n@@ -201,1 +139,1 @@\n-        if (test.version() != 3) {\n+        if (test.version() != 3)\n@@ -203,2 +141,0 @@\n-        }\n-\n@@ -206,1 +142,1 @@\n-        if (test.version() != 4) {\n+        if (test.version() != 4)\n@@ -208,2 +144,0 @@\n-        }\n-\n@@ -211,1 +145,1 @@\n-        if (test.version() != 1) {\n+        if (test.version() != 1)\n@@ -213,2 +147,0 @@\n-        }\n-\n@@ -216,1 +148,1 @@\n-        if (test.version() != 2) {\n+        if (test.version() != 2)\n@@ -218,2 +150,0 @@\n-        }\n-\n@@ -221,1 +151,1 @@\n-        if (test.version() != 3) {\n+        if (test.version() != 3)\n@@ -223,2 +153,0 @@\n-        }\n-\n@@ -226,1 +154,1 @@\n-        if (test.version() != 4) {\n+        if (test.version() != 4)\n@@ -228,1 +156,0 @@\n-        }\n@@ -233,1 +160,1 @@\n-        if (test.variant() != 2) {\n+        if (test.variant() != 2)\n@@ -235,2 +162,1 @@\n-        }\n-\n+        Random byteSource = new Random();\n@@ -238,1 +164,1 @@\n-        generator.nextBytes(someBytes);\n+        byteSource.nextBytes(someBytes);\n@@ -240,1 +166,1 @@\n-        if (test.variant() != 2) {\n+        if (test.variant() != 2)\n@@ -242,2 +168,0 @@\n-        }\n-\n@@ -245,1 +169,1 @@\n-        if (test.variant() != 0) {\n+        if (test.variant() != 0)\n@@ -247,2 +171,0 @@\n-        }\n-\n@@ -250,1 +172,1 @@\n-        if (test.variant() != 2) {\n+        if (test.variant() != 2)\n@@ -252,4 +174,2 @@\n-        }\n-\n-        test = new UUID(55L, 0xc000000000001000L);\n-        if (test.variant() != 6) {\n+       test = new UUID(55L, 0xc000000000001000L);\n+        if (test.variant() != 6)\n@@ -257,4 +177,2 @@\n-        }\n-\n-        test = new UUID(55L, 0xe000000000001000L);\n-        if (test.variant() != 7) {\n+       test = new UUID(55L, 0xe000000000001000L);\n+        if (test.variant() != 7)\n@@ -262,1 +180,0 @@\n-        }\n@@ -273,1 +190,0 @@\n-\n@@ -275,1 +191,1 @@\n-        if (test.timestamp() != 1) {\n+        if (test.timestamp() != 1)\n@@ -277,2 +193,0 @@\n-        }\n-\n@@ -280,1 +194,1 @@\n-        if (test.timestamp() != 1024) {\n+        if (test.timestamp() != 1024)\n@@ -282,2 +196,0 @@\n-        }\n-\n@@ -285,1 +197,1 @@\n-        if (test.timestamp() != (Long.MAX_VALUE >> 3)) {\n+        if (test.timestamp() != Long.MAX_VALUE>>3)\n@@ -287,1 +199,0 @@\n-        }\n@@ -298,1 +209,0 @@\n-\n@@ -300,1 +210,1 @@\n-        if (test.clockSequence() != 1) {\n+        if (test.clockSequence() != 1)\n@@ -302,2 +212,0 @@\n-        }\n-\n@@ -305,1 +213,1 @@\n-        if (test.clockSequence() != 2) {\n+        if (test.clockSequence() != 2)\n@@ -307,2 +215,0 @@\n-        }\n-\n@@ -310,1 +216,1 @@\n-        if (test.clockSequence() != 16) {\n+        if (test.clockSequence() != 16)\n@@ -312,2 +218,0 @@\n-        }\n-\n@@ -315,1 +219,1 @@\n-        if (test.clockSequence() != ((1L << 14) - 1)) {\n+        if (test.clockSequence() != ((2L<<13)-1)) \/\/ 2^14 - 1\n@@ -317,1 +221,0 @@\n-        }\n@@ -328,1 +231,0 @@\n-\n@@ -330,1 +232,1 @@\n-        if (test.node() != 1) {\n+        if (test.node() != 1)\n@@ -332,2 +234,0 @@\n-        }\n-\n@@ -335,1 +235,1 @@\n-        if (test.node() != ((1L << 48) - 1)) {\n+        if (test.node() != ((2L<<47)-1)) \/\/ 2^48 - 1\n@@ -337,1 +237,0 @@\n-        }\n@@ -342,1 +241,1 @@\n-        for (int i = 0; i < COUNT; i++) {\n+        for (int i=0; i<100; i++) {\n@@ -345,4 +244,2 @@\n-            if (u1.hashCode() != u2.hashCode()) {\n-                throw new Exception(\"Equal UUIDs with different hash codes: \" + u1 + \"(\" + u1.hashCode() + \") \" +\n-                                    \"and \" + u2 + \"(\" + u2.hashCode() + \")\");\n-            }\n+            if (u1.hashCode() != u2.hashCode())\n+                throw new Exception(\"Equal UUIDs with different hashcodes\");\n@@ -350,1 +247,0 @@\n-\n@@ -352,1 +248,1 @@\n-        for (int i = 0; i < COUNT; i++) {\n+        for (int i=0; i<1000; i++) {\n@@ -359,3 +255,2 @@\n-            if (u1.equals(u2)) {\n-                throw new Exception(\"UUIDs with different bits equal: \" + u1 + \" and \" + u2);\n-            }\n+            if (u1.equals(u2))\n+                throw new Exception(\"UUIDs with different bits equal\");\n@@ -375,1 +270,1 @@\n-            (id4.compareTo(id5) >= 0)) {\n+            (id4.compareTo(id5) >= 0))\n@@ -377,1 +272,0 @@\n-        }\n@@ -382,1 +276,1 @@\n-            (id2.compareTo(id) <= 0)) {\n+            (id2.compareTo(id) <= 0))\n@@ -384,1 +278,0 @@\n-        }\n@@ -386,1 +279,1 @@\n-        if (id.compareTo(id) != 0) {\n+        if (id.compareTo(id) != 0)\n@@ -388,1 +281,1 @@\n-        }\n+\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":80,"deletions":187,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.x509\n- * @modules java.base\/sun.security.tools.keytool\n@@ -32,14 +29,1 @@\n-import jdk.security.jarsigner.JarSigner;\n-import sun.security.tools.keytool.CertAndKeyGen;\n-import sun.security.x509.X500Name;\n-\n-import java.io.OutputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.security.KeyStore;\n-import java.security.cert.Certificate;\n-import java.security.cert.X509Certificate;\n-import java.util.Collections;\n-import java.util.Objects;\n-import java.util.concurrent.TimeUnit;\n-import java.util.jar.JarEntry;\n+import java.io.File;\n@@ -47,1 +31,1 @@\n-import java.util.jar.JarOutputStream;\n+import java.util.jar.JarEntry;\n@@ -49,4 +33,1 @@\n-import java.util.zip.ZipFile;\n-\n-import static jdk.test.lib.Utils.runAndCheckException;\n-\n+import java.util.Enumeration;\n@@ -55,0 +36,6 @@\n+    private static void Unreached (Object o)\n+        throws Exception\n+    {\n+        \/\/ Should never get here\n+        throw new Exception (\"Expected exception was not thrown\");\n+    }\n@@ -57,0 +44,6 @@\n+        File f = new File(System.getProperty(\"test.src\", \".\"), \"thawjar.jar\");\n+        JarFile jf = new JarFile(f);\n+        try {\n+            \/\/ Read entries via Enumeration\n+            for (Enumeration e = jf.entries(); e.hasMoreElements();)\n+                jf.getInputStream((ZipEntry) e.nextElement());\n@@ -58,4 +51,3 @@\n-        Path j = createJar();\n-        Path s = signJar(j, keyEntry(\"cn=duke\"));\n-\n-        try (JarFile jf = new JarFile(s.toFile())) {\n+            \/\/ Read entry by name\n+            ZipEntry ze = jf.getEntry(\"getprop.class\");\n+            JarEntry je = jf.getJarEntry(\"getprop.class\");\n@@ -63,8 +55,3 @@\n-            for (JarEntry e: Collections.list(jf.entries())) {\n-                \/\/ Reading entry to trigger verification\n-                jf.getInputStream(e).transferTo(OutputStream.nullOutputStream());\n-                \/\/ Check that all regular files are signed by duke\n-                if (!e.getName().startsWith(\"META-INF\/\")) {\n-                    checkSignedBy(e, \"cn=duke\");\n-                }\n-            }\n+            \/\/ Make sure we throw NPE on null objects\n+            try { Unreached (jf.getEntry(null)); }\n+            catch (NullPointerException e) {}\n@@ -72,3 +59,2 @@\n-            \/\/ Read ZIP and JAR entries by name\n-            Objects.requireNonNull(jf.getEntry(\"getprop.class\"));\n-            Objects.requireNonNull(jf.getJarEntry(\"getprop.class\"));\n+            try { Unreached (jf.getJarEntry(null)); }\n+            catch (NullPointerException e) {}\n@@ -76,4 +62,2 @@\n-            \/\/ Make sure we throw NPE on null parameters\n-            runAndCheckException(() -> jf.getEntry(null), NullPointerException.class);\n-            runAndCheckException(() -> jf.getJarEntry(null), NullPointerException.class);\n-            runAndCheckException(() -> jf.getInputStream(null), NullPointerException.class);\n+            try { Unreached (jf.getInputStream(null)); }\n+            catch (NullPointerException e) {}\n@@ -86,56 +70,0 @@\n-\n-    \/\/ Check that a JAR entry is signed by an expected DN\n-    private static void checkSignedBy(JarEntry e, String expectedDn) throws Exception {\n-        Certificate[] certs = e.getCertificates();\n-        if (certs == null || certs.length == 0) {\n-            throw new Exception(\"JarEntry has no certificates: \" + e.getName());\n-        }\n-\n-        if (certs[0] instanceof X509Certificate x) {\n-            String name = x.getSubjectX500Principal().getName();\n-            if (!name.equalsIgnoreCase(expectedDn)) {\n-                throw new Exception(\"Expected entry signed by %s, was %s\".formatted(name, expectedDn));\n-            }\n-        } else {\n-            throw new Exception(\"Expected JarEntry.getCertificate to return X509Certificate\");\n-        }\n-    }\n-\n-    private static Path createJar() throws Exception {\n-        Path j = Path.of(\"unsigned.jar\");\n-        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(j))){\n-            out.putNextEntry(new JarEntry(\"getprop.class\"));\n-            out.write(new byte[] {(byte) 0XCA, (byte) 0XFE, (byte) 0XBA, (byte) 0XBE});\n-        }\n-        return j;\n-    }\n-\n-    private static Path signJar(Path j, KeyStore.PrivateKeyEntry entry) throws Exception {\n-        Path s = Path.of(\"signed.jar\");\n-\n-        JarSigner signer = new JarSigner.Builder(entry)\n-                .signerName(\"zigbert\")\n-                .digestAlgorithm(\"SHA-256\")\n-                .signatureAlgorithm(\"SHA256withRSA\")\n-                .build();\n-\n-        try (ZipFile zip = new ZipFile(j.toFile());\n-            OutputStream out = Files.newOutputStream(s)) {\n-            signer.sign(zip, out);\n-        }\n-\n-        return s;\n-    }\n-\n-    private static KeyStore.PrivateKeyEntry keyEntry(String dname) throws Exception {\n-\n-        CertAndKeyGen gen = new CertAndKeyGen(\"RSA\", \"SHA256withRSA\");\n-\n-        gen.generate(1048); \/\/ Small key size makes test run faster\n-\n-        var oneDay = TimeUnit.DAYS.toSeconds(1);\n-        Certificate cert = gen.getSelfCertificate(new X500Name(dname), oneDay);\n-\n-        return new KeyStore.PrivateKeyEntry(gen.getPrivateKey(),\n-                new Certificate[] {cert});\n-    }\n","filename":"test\/jdk\/java\/util\/jar\/JarFile\/VerifySignedJar.java","additions":26,"deletions":98,"binary":false,"changes":124,"status":"modified"},{"filename":"test\/jdk\/java\/util\/jar\/JarFile\/thawjar.jar","binary":true,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n@@ -64,8 +62,1 @@\n-        \/\/ A structurally valid extra data example\n-        byte[] sampleExtra = new byte[Short.BYTES*3];\n-        ByteBuffer.wrap(sampleExtra).order(ByteOrder.LITTLE_ENDIAN)\n-                .putShort((short) 123)         \/\/ ID:   123\n-                .putShort((short) Short.BYTES) \/\/ Size: 2\n-                .putShort((short) 42);         \/\/ Data: Two bytes\n-\n-        for (byte[] extra : new byte[][] { null, sampleExtra}) {\n+        for (byte[] extra : new byte[][] { null, new byte[] {1, 2, 3}}) {\n","filename":"test\/jdk\/java\/util\/zip\/TestExtraTime.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-        checkZipException(bad, \".*invalid zip64 extra data field size.*\");\n+        checkZipException(bad, \".*bad header size.*\");\n@@ -123,1 +123,1 @@\n-        checkZipException(bad, \".*extra data field size too long.*\");\n+        checkZipException(bad, \".*bad header size.*\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CorruptedZipFiles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n- * The test uses Ctrl+Down Arrow which is a system shortcut on macOS,\n+ * The test uses Ctrl+Down Arrow (↓) which is a system shortcut on macOS,\n","filename":"test\/jdk\/javax\/swing\/Popup\/TaskbarPositionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n- * @build jdk.test.lib.Asserts\n@@ -97,1 +96,0 @@\n-import jdk.test.lib.Asserts;\n@@ -297,1 +295,0 @@\n-        test_context_iterator();\n@@ -1892,42 +1889,0 @@\n-    static boolean test_context_iterator() throws Exception {\n-        System.out.println(\"Testing context iterator() method.\");\n-\n-        Reference ref = fac.newReference(\"#object\",\n-                fac.newDigestMethod(DigestMethod.SHA512, null));\n-        SignedInfo si = fac.newSignedInfo(withoutComments, rsaSha512,\n-                Collections.singletonList(ref));\n-\n-        Document doc = db.newDocument();\n-        XMLObject obj = fac.newXMLObject(Collections.singletonList(\n-                new DOMStructure(doc.createTextNode(\"test text\"))), \"object\",\n-                null, null);\n-\n-        DOMSignContext dsc = new DOMSignContext(signingKey, doc);\n-        Asserts.assertNotNull(dsc.iterator());\n-        Asserts.assertFalse(dsc.iterator().hasNext());\n-\n-        String namespaceURI = \"https:\/\/example.com\/ns\";\n-        String idAttrValue = \"id1\";\n-        String elementQualifiedName = \"test:data\";\n-\n-        Element elm = doc.createElementNS(namespaceURI, elementQualifiedName);\n-        elm.setAttributeNS(namespaceURI, \"test:id\", idAttrValue);\n-        dsc.setIdAttributeNS(elm, namespaceURI, \"id\");\n-\n-        Iterator<Map.Entry<String, Element>> iter = dsc.iterator();\n-        Asserts.assertTrue(dsc.iterator().hasNext());\n-\n-        Map.Entry<String, Element> element = iter.next();\n-        Asserts.assertEquals(element.getKey(), idAttrValue);\n-        Asserts.assertEquals(element.getValue().getNodeName(), elementQualifiedName);\n-\n-        try {\n-            iter.remove();\n-            throw new RuntimeException(\n-                    \"The expected UnsupportedOperationException was not thrown.\");\n-        } catch (UnsupportedOperationException exc) {\n-            \/\/ this is expected\n-        }\n-        return true;\n-    }\n-\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":1,"deletions":46,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Red Hat Inc.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import com.sun.management.OperatingSystemMXBean;\n-import java.lang.management.ManagementFactory;\n-import jdk.internal.platform.Metrics;\n-\n-\n-\/\/ Check dynamic limits updating. Metrics (java) side.\n-public class LimitUpdateChecker {\n-\n-    private static final File UPDATE_FILE = new File(\"\/tmp\", \"limitsUpdated\");\n-    private static final File STARTED_FILE = new File(\"\/tmp\", \"started\");\n-\n-    public static void main(String[] args) throws Exception {\n-        System.out.println(\"Running LimitUpdateChecker...\");\n-        Metrics metrics = jdk.internal.platform.Container.metrics();\n-        OperatingSystemMXBean osBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();\n-        printMetrics(osBean, metrics); \/\/ initial limits\n-        createStartedFile();\n-        while (!UPDATE_FILE.exists()) {\n-            Thread.sleep(200);\n-        }\n-        System.out.println(\"'limitsUpdated' file appeared. Stopped loop.\");\n-        printMetrics(osBean, metrics); \/\/ updated limits\n-        System.out.println(\"LimitUpdateChecker DONE.\");\n-    }\n-\n-    private static void printMetrics(OperatingSystemMXBean osBean, Metrics metrics) {\n-        System.out.println(String.format(\"Runtime.availableProcessors: %d\", Runtime.getRuntime().availableProcessors()));\n-        System.out.println(String.format(\"OperatingSystemMXBean.getAvailableProcessors: %d\", osBean.getAvailableProcessors()));\n-        System.out.println(\"Metrics.getMemoryLimit() == \" + metrics.getMemoryLimit());\n-        System.out.println(String.format(\"OperatingSystemMXBean.getTotalMemorySize: %d\", osBean.getTotalMemorySize()));\n-    }\n-\n-    private static void createStartedFile() throws Exception {\n-        FileOutputStream fout = new FileOutputStream(STARTED_FILE);\n-        fout.close();\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/LimitUpdateChecker.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,156 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Red Hat, Inc.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @bug 8308090\n- * @key cgroups\n- * @summary Test container limits updating as they get updated at runtime without restart\n- * @requires docker.support\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.platform\n- * @build LimitUpdateChecker\n- * @run driver TestLimitsUpdating\n- *\/\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.containers.docker.Common;\n-import jdk.test.lib.containers.docker.DockerRunOptions;\n-import jdk.test.lib.containers.docker.DockerTestUtils;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class TestLimitsUpdating {\n-    private static final long M = 1024 * 1024;\n-    private static final String TARGET_CONTAINER = \"limitsUpdatingJDK_\" + Runtime.getRuntime().version().major();\n-    private static final String imageName = Common.imageName(\"limitsUpdatingJDK\");\n-\n-    public static void main(String[] args) throws Exception {\n-        if (!DockerTestUtils.canTestDocker()) {\n-            return;\n-        }\n-\n-        DockerTestUtils.buildJdkContainerImage(imageName);\n-\n-        try {\n-            testLimitUpdates();\n-        } finally {\n-            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n-                DockerTestUtils.removeDockerImage(imageName);\n-            }\n-        }\n-    }\n-\n-    private static void testLimitUpdates() throws Exception {\n-        File sharedtmpdir = new File(\"jdk-sharedtmp\");\n-        File flag = new File(sharedtmpdir, \"limitsUpdated\"); \/\/ shared with LimitUpdateChecker\n-        File started = new File(sharedtmpdir, \"started\"); \/\/ shared with LimitUpdateChecker\n-        sharedtmpdir.mkdir();\n-        flag.delete();\n-        started.delete();\n-        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"LimitUpdateChecker\");\n-        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n-        opts.addDockerOpts(\"--volume\", sharedtmpdir.getAbsolutePath() + \":\/tmp\");\n-        opts.addDockerOpts(\"--cpu-period\", \"100000\");\n-        opts.addDockerOpts(\"--cpu-quota\", \"200000\");\n-        opts.addDockerOpts(\"--memory\", \"500m\");\n-        opts.addDockerOpts(\"--memory-swap\", \"500m\");\n-        opts.addDockerOpts(\"--name\", TARGET_CONTAINER);\n-        opts.addJavaOpts(\"-cp\", \"\/test-classes\/\");\n-        \/\/ LimitUpdateChecker uses Metrics (jdk.internal.platform) for\n-        \/\/ printing JDK container limits\n-        opts.addJavaOpts(\"--add-exports\");\n-        opts.addJavaOpts(\"java.base\/jdk.internal.platform=ALL-UNNAMED\");\n-        final OutputAnalyzer out[] = new OutputAnalyzer[1];\n-        Thread t1 = new Thread() {\n-                public void run() {\n-                    try {\n-                        out[0] = DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0);\n-                    } catch (Exception e) {\n-                        e.printStackTrace();\n-                    }\n-                }\n-            };\n-        t1.start();\n-\n-       \/\/ Wait for target container (that we later update) to complete its\n-       \/\/ initial starting-up phase. Prints initial container limits using\n-       \/\/ OS MXBean and Metrics API\n-        while (!started.exists()) {\n-            System.out.println(\"Wait for target container to start\");\n-            Thread.sleep(100);\n-        }\n-\n-        final List<String> containerCommand = getContainerUpdate(300_000, 100_000, \"300m\");\n-        \/\/ Run the update command so as to increase resources once the container signaled it has started.\n-        Thread t2 = new Thread() {\n-                public void run() {\n-                    try {\n-                        DockerTestUtils.execute(containerCommand).shouldHaveExitValue(0);\n-                    } catch (Exception e) {\n-                        e.printStackTrace();\n-                    }\n-                }\n-            };\n-        t2.start();\n-        t2.join();\n-\n-        \/\/ Set the flag for the to-get updated container, indicating the update\n-        \/\/ has completed.\n-        FileOutputStream fout = new FileOutputStream(flag);\n-        fout.close();\n-\n-        t1.join();\n-\n-        \/\/ Do assertions based on the output in target container\n-        OutputAnalyzer targetOut = out[0];\n-        targetOut.shouldContain(\"Runtime.availableProcessors: 2\");                  \/\/ initial value\n-        targetOut.shouldContain(\"OperatingSystemMXBean.getAvailableProcessors: 2\"); \/\/ initial value\n-        targetOut.shouldContain(\"Runtime.availableProcessors: 3\");                  \/\/ updated value\n-        targetOut.shouldContain(\"OperatingSystemMXBean.getAvailableProcessors: 3\"); \/\/ updated value\n-        long memoryInBytes = 500 * M;\n-        targetOut.shouldContain(\"Metrics.getMemoryLimit() == \" + memoryInBytes);    \/\/ initial value\n-        targetOut.shouldContain(\"OperatingSystemMXBean.getTotalMemorySize: \" + memoryInBytes); \/\/ initial value\n-        long updatedValue = 300 * M;\n-        targetOut.shouldContain(\"Metrics.getMemoryLimit() == \" + updatedValue);    \/\/ updated value\n-        targetOut.shouldContain(\"OperatingSystemMXBean.getTotalMemorySize: \" + updatedValue); \/\/ updated value\n-    }\n-\n-    private static List<String> getContainerUpdate(int cpuQuota, int cpuPeriod, String memory) {\n-        List<String> cmd = DockerTestUtils.buildContainerCommand();\n-        cmd.add(\"update\");\n-        cmd.add(\"--cpu-period=\" + cpuPeriod);\n-        cmd.add(\"--cpu-quota=\" + cpuQuota);\n-        cmd.add(\"--memory=\" + memory);\n-        cmd.add(\"--memory-swap=\" + memory); \/\/ no swap\n-        cmd.add(TARGET_CONTAINER);\n-        return cmd;\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":0,"deletions":156,"binary":false,"changes":156,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.test.whitebox.code.BlobType;\n+import sun.hotspot.code.BlobType;\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeCacheFull.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-import jdk.test.whitebox.code.BlobType;\n-import jdk.test.whitebox.code.CodeBlob;\n+import sun.hotspot.code.BlobType;\n+import sun.hotspot.code.CodeBlob;\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeSweeper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-import jdk.test.whitebox.code.NMethod;\n+import sun.hotspot.code.NMethod;\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJFRIntrinsic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+        boolean ocspEnabled = false;\n@@ -60,0 +61,1 @@\n+            ocspEnabled = true;\n@@ -62,4 +64,4 @@\n-        new AmazonCA_1().runTest(pathValidator);\n-        new AmazonCA_2().runTest(pathValidator);\n-        new AmazonCA_3().runTest(pathValidator);\n-        new AmazonCA_4().runTest(pathValidator);\n+        new AmazonCA_1().runTest(pathValidator, ocspEnabled);\n+        new AmazonCA_2().runTest(pathValidator, ocspEnabled);\n+        new AmazonCA_3().runTest(pathValidator, ocspEnabled);\n+        new AmazonCA_4().runTest(pathValidator, ocspEnabled);\n@@ -71,1 +73,1 @@\n-    \/\/ Owner: CN=Amazon RSA 2048 M02, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n@@ -73,35 +75,4 @@\n-    \/\/ Serial number: 773124a4bcbd44ec7b53beaf194842d3a0fa1\n-    \/\/ Valid from: Tue Aug 23 15:25:30 PDT 2022 until: Fri Aug 23 15:25:30 PDT 2030\n-    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIEXjCCA0agAwIBAgITB3MSSkvL1E7HtTvq8ZSELToPoTANBgkqhkiG9w0BAQsF\\n\" +\n-            \"ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\\n\" +\n-            \"b24gUm9vdCBDQSAxMB4XDTIyMDgyMzIyMjUzMFoXDTMwMDgyMzIyMjUzMFowPDEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n-            \"QSAyMDQ4IE0wMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALtDGMZa\\n\" +\n-            \"qHneKei1by6+pUPPLljTB143Si6VpEWPc6mSkFhZb\/6qrkZyoHlQLbDYnI2D7hD0\\n\" +\n-            \"sdzEqfnuAjIsuXQLG3A8TvX6V3oFNBFVe8NlLJHvBseKY88saLwufxkZVwk74g4n\\n\" +\n-            \"WlNMXzla9Y5F3wwRHwMVH443xGz6UtGSZSqQ94eFx5X7Tlqt8whi8qCaKdZ5rNak\\n\" +\n-            \"+r9nUThOeClqFd4oXych\/\/Rc7Y0eX1KNWHYSI1Nk31mYgiK3JvH063g+K9tHA63Z\\n\" +\n-            \"eTgKgndlh+WI+zv7i44HepRZjA1FYwYZ9Vv\/9UkC5Yz8\/yU65fgjaE+wVHM4e\/Yy\\n\" +\n-            \"C2osrPWE7gJ+dXMCAwEAAaOCAVowggFWMBIGA1UdEwEB\/wQIMAYBAf8CAQAwDgYD\\n\" +\n-            \"VR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNV\\n\" +\n-            \"HQ4EFgQUwDFSzVpQw4J8dHHOy+mc+XrrguIwHwYDVR0jBBgwFoAUhBjMhTTsvAyU\\n\" +\n-            \"lC4IWZzHshBOCggwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8v\\n\" +\n-            \"b2NzcC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDov\\n\" +\n-            \"L2NydC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8E\\n\" +\n-            \"ODA2MDSgMqAwhi5odHRwOi8vY3JsLnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jv\\n\" +\n-            \"b3RjYTEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IB\\n\" +\n-            \"AQAtTi6Fs0Azfi+iwm7jrz+CSxHH+uHl7Law3MQSXVtR8RV53PtR6r\/6gNpqlzdo\\n\" +\n-            \"Zq4FKbADi1v9Bun8RY8D51uedRfjsbeodizeBB8nXmeyD33Ep7VATj4ozcd31YFV\\n\" +\n-            \"fgRhvTSxNrrTlNpWkUk0m3BMPv8sg381HhA6uEYokE5q9uws\/3YkKqRiEz3TsaWm\\n\" +\n-            \"JqIRZhMbgAfp7O7FUwFIb7UIspogZSKxPIWJpxiPo3TcBambbVtQOcNRWz5qCQdD\\n\" +\n-            \"slI2yayq0n2TXoHyNCLEH8rpsJRVILFsg0jc7BaFrMnF462+ajSehgj12IidNeRN\\n\" +\n-            \"4zl+EoNaWdpnWndvSpAEkq2P\\n\" +\n-            \"-----END CERTIFICATE-----\";\n-\n-    \/\/ Owner: CN=Amazon RSA 2048 M01, O=Amazon, C=US\n-    \/\/ Issuer: CN=Amazon Root CA 1, O=Amazon, C=US\n-    \/\/ Serial number: 77312380b9d6688a33b1ed9bf9ccda68e0e0f\n-    \/\/ Valid from: Tue Aug 23 15:21:28 PDT 2022 until: Fri Aug 23 15:21:28 PDT 2030\n-    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIEXjCCA0agAwIBAgITB3MSOAudZoijOx7Zv5zNpo4ODzANBgkqhkiG9w0BAQsF\\n\" +\n+    \/\/ Serial number: 67f9457508c648c09ca652e71791830e72592\n+    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n+    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIERzCCAy+gAwIBAgITBn+UV1CMZIwJymUucXkYMOclkjANBgkqhkiG9w0BAQsF\\n\" +\n@@ -109,22 +80,21 @@\n-            \"b24gUm9vdCBDQSAxMB4XDTIyMDgyMzIyMjEyOFoXDTMwMDgyMzIyMjEyOFowPDEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n-            \"QSAyMDQ4IE0wMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOtxLKnL\\n\" +\n-            \"H4gokjIwr4pXD3i3NyWVVYesZ1yX0yLI2qIUZ2t88Gfa4gMqs1YSXca1R\/lnCKeT\\n\" +\n-            \"epWSGA+0+fkQNpp\/L4C2T7oTTsddUx7g3ZYzByDTlrwS5HRQQqEFE3O1T5tEJP4t\\n\" +\n-            \"f+28IoXsNiEzl3UGzicYgtzj2cWCB41eJgEmJmcf2T8TzzK6a614ZPyq\/w4CPAff\\n\" +\n-            \"nAV4coz96nW3AyiE2uhuB4zQUIXvgVSycW7sbWLvj5TDXunEpNCRwC4kkZjK7rol\\n\" +\n-            \"jtT2cbb7W2s4Bkg3R42G3PLqBvt2N32e\/0JOTViCk8\/iccJ4sXqrS1uUN4iB5Nmv\\n\" +\n-            \"JK74csVl+0u0UecCAwEAAaOCAVowggFWMBIGA1UdEwEB\/wQIMAYBAf8CAQAwDgYD\\n\" +\n-            \"VR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNV\\n\" +\n-            \"HQ4EFgQUgbgOY4qJEhjl+js7UJWf5uWQE4UwHwYDVR0jBBgwFoAUhBjMhTTsvAyU\\n\" +\n-            \"lC4IWZzHshBOCggwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8v\\n\" +\n-            \"b2NzcC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDov\\n\" +\n-            \"L2NydC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8E\\n\" +\n-            \"ODA2MDSgMqAwhi5odHRwOi8vY3JsLnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jv\\n\" +\n-            \"b3RjYTEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IB\\n\" +\n-            \"AQCtAN4CBSMuBjJitGuxlBbkEUDeK\/pZwTXv4KqPK0G50fOHOQAd8j21p0cMBgbG\\n\" +\n-            \"kfMHVwLU7b0XwZCav0h1ogdPMN1KakK1DT0VwA\/+hFvGPJnMV1Kx2G4S1ZaSk0uU\\n\" +\n-            \"5QfoiYIIano01J5k4T2HapKQmmOhS\/iPtuo00wW+IMLeBuKMn3OLn005hcrOGTad\\n\" +\n-            \"hcmeyfhQP7Z+iKHvyoQGi1C0ClymHETx\/chhQGDyYSWqB\/THwnN15AwLQo0E5V9E\\n\" +\n-            \"SJlbe4mBlqeInUsNYugExNf+tOiybcrswBy8OFsd34XOW3rjSUtsuafd9AWySa3h\\n\" +\n-            \"xRRrwszrzX\/WWGm6wyB+f7C4\\n\" +\n+            \"b24gUm9vdCBDQSAxMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENB\\n\" +\n+            \"IDFBMQ8wDQYDVQQDEwZBbWF6b24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\\n\" +\n+            \"AoIBAQCeQM3XCsIZunv8bSJxOqkc\/ed87uL76FDB7teBNThDRB+1J7aITuadbNfH\\n\" +\n+            \"5ZfZykrdZ1qQLKxP6DwHOmJr9u2b4IxjUX9qUMuq4B02ghD2g6yU3YivEosZ7fpo\\n\" +\n+            \"srD2TBN29JpgPGrOrpOE+ArZuIpBjdKFinemu6fTDD0NCeQlfyHXd1NOYyfYRLTa\\n\" +\n+            \"xlpDqr\/2M41BgSkWQfSPHHyRWNQgWBiGsIQaS8TK0g8OWi1ov78+2K9DWT+AHgXW\\n\" +\n+            \"AanjZK91GfygPXJYSlAGxSiBAwH\/KhAMifhaoFYAbH0Yuohmd85B45G2xVsop4TM\\n\" +\n+            \"Dsl007U7qnS7sdJ4jYGzEvva\/a95AgMBAAGjggE5MIIBNTASBgNVHRMBAf8ECDAG\\n\" +\n+            \"AQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHQ4EFgQUYtRCXoZwdWqQvMa40k1g\\n\" +\n+            \"wjS6UTowHwYDVR0jBBgwFoAUhBjMhTTsvAyUlC4IWZzHshBOCggwewYIKwYBBQUH\\n\" +\n+            \"AQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8vb2NzcC5yb290Y2ExLmFtYXpvbnRy\\n\" +\n+            \"dXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDovL2NydC5yb290Y2ExLmFtYXpvbnRy\\n\" +\n+            \"dXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8EODA2MDSgMqAwhi5odHRwOi8vY3Js\\n\" +\n+            \"LnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jvb3RjYTEuY3JsMBEGA1UdIAQKMAgw\\n\" +\n+            \"BgYEVR0gADANBgkqhkiG9w0BAQsFAAOCAQEAMHbSWHRFMzGNIE0qhN6gnRahTrTU\\n\" +\n+            \"CDPwe7l9\/q0IA+QBlrpUHnlAreetYeH1jB8uF3qXXzy22gpBU7NqulTkqSPByT1J\\n\" +\n+            \"xOhpT2FpO5R3VAdMPdWfSEgtrED0jkmyUQrR1T+\/A+nBLdJZeQcl+OqLgeY790JM\\n\" +\n+            \"JJTsJnnI6FBWeTGhcDI4Y+n3KS3QCVePeWI7jx1dhrHcXH+QDX8Ywe31hV7YENdr\\n\" +\n+            \"HDpUXrjK6eHN8gazy8G6pndXHFwHp4auiZbJbYAk\/q1peOTRagD2JojcLkm+i3cD\\n\" +\n+            \"843t4By6YT\/PVlePU2PCWejkrJQnKQAPOov7IA8kuO2RDWuzE\/zF6Hotdg==\\n\" +\n@@ -133,4 +103,4 @@\n-    \/\/ Owner: CN=valid.rootca1.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon RSA 2048 M02, O=Amazon, C=US\n-    \/\/ Serial number: 60c6e837b2e7586d8464eb34f4a85fe\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=good.sca1a.amazontrust.com\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n+    \/\/ Serial number: 75a5dd4b767bedc94a4239da65ed9dfef8218\n+    \/\/ Valid from: Fri Dec 17 12:21:50 PST 2021 until: Tue Jan 17 12:21:50 PST 2023\n@@ -138,33 +108,23 @@\n-            \"MIIGKDCCBRCgAwIBAgIQBgxug3sudYbYRk6zT0qF\/jANBgkqhkiG9w0BAQsFADA8\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n-            \"UlNBIDIwNDggTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLTEr\\n\" +\n-            \"MCkGA1UEAxMidmFsaWQucm9vdGNhMS5kZW1vLmFtYXpvbnRydXN0LmNvbTCCASIw\\n\" +\n-            \"DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL3hA+omhUcO8nYO8\/+dkpbYz8WI\\n\" +\n-            \"1ms7Y7JA2pPFfp2N\/aWcf6m5ORm1BkyGLOttjTu318Qpa9eahQ1Pi3RNe3BtqjD9\\n\" +\n-            \"jcHncpwAFMsXy1beZA7sZ7AA4vKltA3t6yrU5ruTLUGQwUndeIBBSTW5QpdT9I\/p\\n\" +\n-            \"EM7d+Miwre63kofbJ1lVPAJvN\/udMVqGWNF8V5qscklUUHoSKA3FWWsiCyIgnthg\\n\" +\n-            \"G3u6R1KH66Qionp0ho\/ttvrBCI0C\/bdrdH+wybFv8oFFvAW2U9xn2Azt47\/2kHHm\\n\" +\n-            \"tTRjrgufhDbcz\/MLR6hwBXAJuwVvJZmSqe7B4IILFexu6wjxZfyqVm2FMr8CAwEA\\n\" +\n-            \"AaOCAzMwggMvMB8GA1UdIwQYMBaAFMAxUs1aUMOCfHRxzsvpnPl664LiMB0GA1Ud\\n\" +\n-            \"DgQWBBSkrnsTnjwYhDRAeLy\/9FXm\/7hApDBlBgNVHREEXjBcgiJ2YWxpZC5yb290\\n\" +\n-            \"Y2ExLmRlbW8uYW1hem9udHJ1c3QuY29tghpnb29kLnNjYTBhLmFtYXpvbnRydXN0\\n\" +\n-            \"LmNvbYIaZ29vZC5zY2ExYS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWg\\n\" +\n-            \"MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAs\\n\" +\n-            \"hipodHRwOi8vY3JsLnIybTAyLmFtYXpvbnRydXN0LmNvbS9yMm0wMi5jcmwwEwYD\\n\" +\n-            \"VR0gBAwwCjAIBgZngQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFo\\n\" +\n-            \"dHRwOi8vb2NzcC5yMm0wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0\\n\" +\n-            \"dHA6Ly9jcnQucjJtMDIuYW1hem9udHJ1c3QuY29tL3IybTAyLmNlcjAMBgNVHRMB\\n\" +\n-            \"Af8EAjAAMIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdgDuzdBk1dsazsVct520\\n\" +\n-            \"zROiModGfLzs3sNRSFlGcR+1mwAAAYgHvXWVAAAEAwBHMEUCICAs74qT1f9ufSr5\\n\" +\n-            \"PgQqtQFiXBbmbb3i4xwVV78USU5NAiEA\/iJEfnTG+hZZaHYv2wVbg6tUY8fQgIhI\\n\" +\n-            \"2rbl6PrD9FIAdgBIsONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgH\\n\" +\n-            \"vXWWAAAEAwBHMEUCIQDf2nWyee\/5+vSgk\/O8P0BFvXYu89cyAugZHyd919BdAgIg\\n\" +\n-            \"UnGGpQtZmWnPMmdgpzI7jrCLuC370Tn0i7Aktdzj2X8AdgDatr9rP7W2Ip+bwrtc\\n\" +\n-            \"a+hwkXFsu1GEhTS9pD0wSNf7qwAAAYgHvXVpAAAEAwBHMEUCIGN6cT+6uwDospXe\\n\" +\n-            \"gMa8b38oXouXUT66X2gOiJ0SoRyQAiEAjDMu2vEll5tRpUvU8cD4gR2xV4hqoDxx\\n\" +\n-            \"Q+QGW+PvJxcwDQYJKoZIhvcNAQELBQADggEBACtxC3LlQvULeI3lt7ZYFSWndEhm\\n\" +\n-            \"tNUotoeKSXJXdoIpqSr10bzMPX9SHvemgOUtzP3JNqWPHw1uW9YFyeDE6yWj\/B13\\n\" +\n-            \"Xj1hv1cqYIwyaOZBerU\/9PT5PaCn20AC9DHbc7iBv+zs+DYiqlAFJ1GVaprwLul4\\n\" +\n-            \"8wp3gnC3Hjb8NykydCo6vw0AJ2UzjpjiTyVZ93jITzLOiboOUa1gQGnojzWlYaet\\n\" +\n-            \"sXe+RDylBp\/Wuj1ZS7v\/etltzYm5GanPi4y\/p7Ta3Uky6std\/GM6XbPRdBEFboFR\\n\" +\n-            \"B2IP0divd9c74Q+tLgpsAz5yXm9LtYPMcEPC2YRN2PgBg67c5+A7eIOluuw=\\n\" +\n+            \"MIIEIDCCAwigAwIBAgITB1pd1LdnvtyUpCOdpl7Z3++CGDANBgkqhkiG9w0BAQsF\\n\" +\n+            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n+            \"ZXIgQ0EgMUExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDIxNTBaFw0yMzAx\\n\" +\n+            \"MTcyMDIxNTBaMCUxIzAhBgNVBAMTGmdvb2Quc2NhMWEuYW1hem9udHJ1c3QuY29t\\n\" +\n+            \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5SadXE1HIzUp4ob40roo\\n\" +\n+            \"qBiJy57vLcZklkWoxRU2JtIauuZUl8fLT\/KOjzW71fqMMTxnvEbtKtRtZKDFjrg7\\n\" +\n+            \"uPf8Q1J9tqxme6iFlrBlou+moQQ7Spi3H9q7v08vX19XIREGIwHbicbxVujdeA0w\\n\" +\n+            \"G0fGMlw+Gs8GNiBQplr+oXC7i2CoPmwnR\/T8iHjCEznKQIMxiZL4gOHLwh4EKdBA\\n\" +\n+            \"auirpTq0iXUtC2BcM\/w1Zx1UTLu0idmclcxVSYE8hXfV8e7JGpNI1gCqkgrskof3\\n\" +\n+            \"A6CMCIH\/D1VETFtGKn+gGWenWwnELmKuvHObQGXmcwOV3aXBdNFTmfzcshwqm\/mE\\n\" +\n+            \"zQIDAQABo4IBJjCCASIwDgYDVR0PAQH\/BAQDAgWgMB0GA1UdDgQWBBTURzXdgGMB\\n\" +\n+            \"tNyiP16WXB1oM2qqmzAfBgNVHSMEGDAWgBRi1EJehnB1apC8xrjSTWDCNLpROjAd\\n\" +\n+            \"BgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYIKwYBBQUHAQEEaTBnMC0G\\n\" +\n+            \"CCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2ExYS5hbWF6b250cnVzdC5jb20wNgYI\\n\" +\n+            \"KwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhMWEuYW1hem9udHJ1c3QuY29tL3NjYTFh\\n\" +\n+            \"LmNlcjAlBgNVHREEHjAcghpnb29kLnNjYTFhLmFtYXpvbnRydXN0LmNvbTATBgNV\\n\" +\n+            \"HSAEDDAKMAgGBmeBDAECATANBgkqhkiG9w0BAQsFAAOCAQEAVNyn7lB3IOstAJj+\\n\" +\n+            \"avkPfojb+QaUpFjnkKyb7c5kUBEWaaEl27W58OLoIHoEJvfOypv2bTq1fuIx9P88\\n\" +\n+            \"1HP7DrI7vBtfnAgyIjF2mzL6Jyt7buR7u\/cXTO0fsl\/uk3wfrJBl860\/Nab+WYoj\\n\" +\n+            \"pvJm0b75WVnU30Khy\/xrhNfN2nvCJ5VMoHqV6KnKrMjA5KpdeTvVaIgyxtV6B8vY\\n\" +\n+            \"VsBbtzJ6n8mN7N8YkEkHV6TG7l+FVPHQdJFtD\/qhTd5C4uu4XUehxOta894hLy6z\\n\" +\n+            \"8Mv9BGtmwyUIEd0KQQdkXrWx\/iAq6zo0imAeN\/s8tjqAzxnw6M5F9cDqjqkYqgXZ\\n\" +\n+            \"eIkPBA==\\n\" +\n@@ -173,4 +133,4 @@\n-    \/\/ Owner: CN=revoked.rootca1.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon RSA 2048 M01, O=Amazon, C=US\n-    \/\/ Serial number: e1023665b1268d788cc25bf69a9d05e\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=revoked.sca1a.amazontrust.com\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n+    \/\/ Serial number: 75a5de4434092b2cd6ed81eb5e6248e1e5f2a\n+    \/\/ Valid from: Fri Dec 17 12:25:17 PST 2021 until: Tue Jan 17 12:25:17 PST 2023\n@@ -178,34 +138,23 @@\n-            \"MIIGMjCCBRqgAwIBAgIQDhAjZlsSaNeIzCW\/aanQXjANBgkqhkiG9w0BAQsFADA8\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n-            \"UlNBIDIwNDggTTAxMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLzEt\\n\" +\n-            \"MCsGA1UEAxMkcmV2b2tlZC5yb290Y2ExLmRlbW8uYW1hem9udHJ1c3QuY29tMIIB\\n\" +\n-            \"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxSPd1PWACxZohFCAJT1JWuXK\\n\" +\n-            \"GY29wZZ9yY0zoiq6+qYiUIU0crktytUNNI1ZpW\/3qXpEw2ZQkM6WF1LshXtwGwrA\\n\" +\n-            \"zJwSeX1L9T5rOKhoBvoFeqfX7xu4VBM1\/fDGt5X+NRFfD9Op9UfK5OsnL05TYach\\n\" +\n-            \"rdnfOA5wKGvMgFiN5CeOD0AtumXSuAnTZC85ojJTHjPF+hqV893WvrrUxLyyxtvh\\n\" +\n-            \"lq\/WttFOjhfQu2IkfyDAFiH939uzUi0WSTAdsbsHuko5mDTDnOfMRbaaWZu0At01\\n\" +\n-            \"EgaIPeK+kGdi7EYwVndIwTKLeQ4mjIM8aj8Heg\/y2hZ0kOmfCUZdUmJFlNoCIQID\\n\" +\n-            \"AQABo4IDOzCCAzcwHwYDVR0jBBgwFoAUgbgOY4qJEhjl+js7UJWf5uWQE4UwHQYD\\n\" +\n-            \"VR0OBBYEFMeBhIOkuWUY4DYqFrfgbD2eUeFtMG0GA1UdEQRmMGSCJHJldm9rZWQu\\n\" +\n-            \"cm9vdGNhMS5kZW1vLmFtYXpvbnRydXN0LmNvbYIdcmV2b2tlZC5zY2EwYS5hbWF6\\n\" +\n-            \"b250cnVzdC5jb22CHXJldm9rZWQuc2NhMWEuYW1hem9udHJ1c3QuY29tMA4GA1Ud\\n\" +\n-            \"DwEB\/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0f\\n\" +\n-            \"BDQwMjAwoC6gLIYqaHR0cDovL2NybC5yMm0wMS5hbWF6b250cnVzdC5jb20vcjJt\\n\" +\n-            \"MDEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggr\\n\" +\n-            \"BgEFBQcwAYYhaHR0cDovL29jc3AucjJtMDEuYW1hem9udHJ1c3QuY29tMDYGCCsG\\n\" +\n-            \"AQUFBzAChipodHRwOi8vY3J0LnIybTAxLmFtYXpvbnRydXN0LmNvbS9yMm0wMS5j\\n\" +\n-            \"ZXIwDAYDVR0TAQH\/BAIwADCCAX4GCisGAQQB1nkCBAIEggFuBIIBagFoAHYA7s3Q\\n\" +\n-            \"ZNXbGs7FXLedtM0TojKHRny87N7DUUhZRnEftZsAAAGIB72TggAABAMARzBFAiAZ\\n\" +\n-            \"naLbRHRuaRrE304GSuWX\/79MU\/e+SSlr0cNJ0kNNaAIhAPnz9HayL4txhkTEZiMs\\n\" +\n-            \"nttNnNqD17I0J17JLVOF4i\/4AHYASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/\\n\" +\n-            \"qznYhHMAAAGIB72TmwAABAMARzBFAiEAgEqT7CYGQ\/u36\/3YcxBH78QfknI9kgcY\\n\" +\n-            \"sgJLkurUF6cCIFZZ\/b803+ek6o+bmdV\/uVx2UlskAyyolZ2okBAb6IscAHYA2ra\/\\n\" +\n-            \"az+1tiKfm8K7XGvocJFxbLtRhIU0vaQ9MEjX+6sAAAGIB72TbQAABAMARzBFAiEA\\n\" +\n-            \"6z2RSoK263hvYF71rj1d0TpC70\/6zagSRR4glHOT6IACICYvaMAnrCNSTSiZ20Wz\\n\" +\n-            \"Ju5roTippO3BWKhQYrTKZuu4MA0GCSqGSIb3DQEBCwUAA4IBAQB4S1JGulFpMIaP\\n\" +\n-            \"NtLUJmjWz8eexQdWLDVF+H8dd6xpZgpiYtig\/Ynphzuk1IIF8DkT3CeK\/9vrezgI\\n\" +\n-            \"igNjneN9B4eIuzi\/rJzIKeUwpZ2k5D+36Ab4esseoc+TopmNerw8hidt2g818jER\\n\" +\n-            \"D71ppSMakeQFPGe\/Hs2\/cVa\/G1DNVcU2XAut45yRZ\/+xsZ0\/mcBDVsG9P5uGCN5O\\n\" +\n-            \"7SAp4J959WnKDqgVuU9WowPE5IjmS9BAv2gjniFYdDV2yksyf7+8edHd1KfSVX06\\n\" +\n-            \"pLx6CuCVZGJFG4Q2Aa1YAh1Wvt9hqWeXXpNRO2\/wChL5rhT4GajsrGepsk4bjxYX\\n\" +\n-            \"Wf2iZ8mX\\n\" +\n+            \"MIIEJjCCAw6gAwIBAgITB1pd5ENAkrLNbtgeteYkjh5fKjANBgkqhkiG9w0BAQsF\\n\" +\n+            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n+            \"ZXIgQ0EgMUExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDI1MTdaFw0yMzAx\\n\" +\n+            \"MTcyMDI1MTdaMCgxJjAkBgNVBAMTHXJldm9rZWQuc2NhMWEuYW1hem9udHJ1c3Qu\\n\" +\n+            \"Y29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqYk4ZkF9yJgRa0fL\\n\" +\n+            \"96gmxwlJlyvsQmqumxUGw0u1L+nDgGMFD1bHILOw2AO+feNy8kuTnJVb+zN+2f6l\\n\" +\n+            \"rMGM1sGKh8W\/ZRIdvmcdeZ2kEDyxLotMRXDQ6hJXDj30DSAYNkdqairJItdcev8+\\n\" +\n+            \"t9LRRNRQwL0sXf5FITQPBnlVCrF9Q42p9hhYUhvsS8jSWPIvUbZajOXKs6AfxyPV\\n\" +\n+            \"2Q7TybgnRlawznXxflPzXRMpCSQZ9WdI\/kYbFOjDNtYA05EI4d8IYm+C5U1eJT30\\n\" +\n+            \"dKFeU0xzFsrPirzifFMPIhXKxS5rUELuFRUq4sFTN28Sj7Ij\/rr+O9Im8jJZq0lo\\n\" +\n+            \"bqLoQwIDAQABo4IBKTCCASUwDgYDVR0PAQH\/BAQDAgWgMB0GA1UdDgQWBBRugPQP\\n\" +\n+            \"CWEwQp0pw2dEMw\/gT7F4gzAfBgNVHSMEGDAWgBRi1EJehnB1apC8xrjSTWDCNLpR\\n\" +\n+            \"OjAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYIKwYBBQUHAQEEaTBn\\n\" +\n+            \"MC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2ExYS5hbWF6b250cnVzdC5jb20w\\n\" +\n+            \"NgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhMWEuYW1hem9udHJ1c3QuY29tL3Nj\\n\" +\n+            \"YTFhLmNlcjAoBgNVHREEITAfgh1yZXZva2VkLnNjYTFhLmFtYXpvbnRydXN0LmNv\\n\" +\n+            \"bTATBgNVHSAEDDAKMAgGBmeBDAECATANBgkqhkiG9w0BAQsFAAOCAQEAQF9QvedW\\n\" +\n+            \"gqD5LPsZ5cg+DkGFBVqhWgsvp8so4gmKHklSHvisEek\/Yfi7tvHCUAP2P0MuV\/49\\n\" +\n+            \"O2A+1tXQL1+hVM1auSfDOQdUy4xsKSWV+PofQe82iz+6dwRf+HNgOtyNcQ6aGD3t\\n\" +\n+            \"87DXnJPkBTEPHGxDkjnOwurSffaV1m00bxfb6T1Txvyjs9ClnZf68Jv6oj+2rbs1\\n\" +\n+            \"+TqKXP0Ma3AgXB37Cq2ozYzpAxy9GBIKIahGX2d2qsuZ2aj6XwJwUayIuU0WTOHK\\n\" +\n+            \"eeXvKS2uvY9UaIvTeepSWXyAbBMKagQhgAtf3X6ILodQi5Gk7lCuY48oArKziTgN\\n\" +\n+            \"vB7mK7JqaM2P4g==\\n\" +\n@@ -214,1 +163,8 @@\n-    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n+        \/\/ EE certificates don't have CRLDP extension\n+        if (!ocspEnabled){\n+            pathValidator.validate(new String[]{INT},\n+                    ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+            return;\n+        }\n@@ -217,1 +173,1 @@\n-        pathValidator.validate(new String[]{VALID, INT_VALID},\n+        pathValidator.validate(new String[]{VALID, INT},\n@@ -221,1 +177,1 @@\n-        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n+        pathValidator.validate(new String[]{REVOKED, INT},\n@@ -223,1 +179,1 @@\n-                \"Mon May 15 13:36:57 PDT 2023\", System.out);\n+                \"Fri Dec 17 12:28:05 PST 2021\", System.out);\n@@ -229,1 +185,1 @@\n-    \/\/ Owner: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n@@ -231,2 +187,2 @@\n-    \/\/ Serial number: 773125b0c34c3c940299a9f04a39e5a52ccd9\n-    \/\/ Valid from: Tue Aug 23 15:29:13 PDT 2022 until: Fri Aug 23 15:29:13 PDT 2030\n+    \/\/ Serial number: 67f945755f187a91f8163f3e624620177ff38\n+    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n@@ -234,1 +190,1 @@\n-            \"MIIGXjCCBEagAwIBAgITB3MSWww0w8lAKZqfBKOeWlLM2TANBgkqhkiG9w0BAQwF\\n\" +\n+            \"MIIGRzCCBC+gAwIBAgITBn+UV1Xxh6kfgWPz5iRiAXf\/ODANBgkqhkiG9w0BAQwF\\n\" +\n@@ -236,33 +192,32 @@\n-            \"b24gUm9vdCBDQSAyMB4XDTIyMDgyMzIyMjkxM1oXDTMwMDgyMzIyMjkxM1owPDEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n-            \"QSA0MDk2IE0wMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMGMl\/pZ\\n\" +\n-            \"1OsxHY9gw\/YfdON4mmrANkPwi7z2djHA5ELt\/vRI3Su0le6OoipLf03iyoCnYy4Y\\n\" +\n-            \"rpfTbhyDriE8NJpps2ODJ5W1h0rz6FM1Q5Jt35wfk+4CEfATBTegHVlUJ0rJgzK5\\n\" +\n-            \"Yl\/jrk12ZsC4ZeRn54shszcK6bHj4LZIHXhrYIIfetBMMD8V7hlhd54AclEWutUV\\n\" +\n-            \"eBEjkSCzDSk+pQKIjCL0crqvRSPvUNry\/BV65zfGmceSYxpcLmV7k7Spwpo+1z8w\\n\" +\n-            \"+Odfnx2vsm7olPldfaThqk6fXBtInORl4Ef32xF3VDT13UeXtQPolFhnp8UOci64\\n\" +\n-            \"bW+R8tbtGpUXIA8Dhr8SgYPH6NW4jhUD4+AG8yer8ctA1Hl9tq+6tYr26q3yuCLu\\n\" +\n-            \"5rwJdfMG634fWIRXSj+GJi8SfAdGtPyXwu5799NWesV4vUkrkSXdIBK4TQCuK+jx\\n\" +\n-            \"aJ5Y+Zo2l3GFsWyMPNORLjoQXbjF6KAyjTyICLq9VzoQKhyx4Ll2CNrQv8CxqtDC\\n\" +\n-            \"GvXi9kREJYAF6lscOB0xglAAF5lndcaNkVHEVOMdg9ZZtdJywHWm8Qed1Wty2qr+\\n\" +\n-            \"hmA7booWQNRE12nW1niC5D4cP2ykPK9HSgb7xWdUF32VidUc9tNKM6xKjSd\/R\/tP\\n\" +\n-            \"p+XAybNSwEooPt3\/OvyhpVRjLuWoqqbClTKdAgMBAAGjggFaMIIBVjASBgNVHRMB\\n\" +\n-            \"Af8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\\n\" +\n-            \"AQYIKwYBBQUHAwIwHQYDVR0OBBYEFJ5xHxodk6nZLY7MSFM\/A1TznuZmMB8GA1Ud\\n\" +\n-            \"IwQYMBaAFLAM8Eww9AVYAkj9M+VSr0uE42ZSMHsGCCsGAQUFBwEBBG8wbTAvBggr\\n\" +\n-            \"BgEFBQcwAYYjaHR0cDovL29jc3Aucm9vdGNhMi5hbWF6b250cnVzdC5jb20wOgYI\\n\" +\n-            \"KwYBBQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhMi5hbWF6b250cnVzdC5jb20vcm9v\\n\" +\n-            \"dGNhMi5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2EyLmFt\\n\" +\n-            \"YXpvbnRydXN0LmNvbS9yb290Y2EyLmNybDATBgNVHSAEDDAKMAgGBmeBDAECATAN\\n\" +\n-            \"BgkqhkiG9w0BAQwFAAOCAgEAl1GgKXOn0j1MWT1KJVSewQ28SGbie3UwZj1dMsjJ\\n\" +\n-            \"amCrQPn2ngSNbLm9+ulFiBDU8xKR9Zx3tZps55IUKWLUPkfMC+vkV7asDBqqzzE0\\n\" +\n-            \"F\/MkekgPfOjx1V9S6Wfg3sSg+9KcluurXFElruqKfOm4cqmkV776X1G+AaaQ7mlU\\n\" +\n-            \"giCYi6NqRQSyhn8zrKkNnbO6QL5a9ICC47kiZYRAR\/hRvZOt11QUK5tCMXJXo0iO\\n\" +\n-            \"4XKkMu+jdnehP1kh4xuZhYznIgKK6MJIITFI\/Jj89U4SOPncyuS94sUuE2EqvvO\/\\n\" +\n-            \"t81qeoey6wThz5iRbU\/0CvDFnTMgebWGUZ2UZJ+az\/rb3KYXGfVWasLIonkvYT7z\\n\" +\n-            \"vHOGNAA9oQ8TTgPOmPfSVyfpplKtO\/aybWp5QSH2csIwuvw5dkmpkc42iD57XHob\\n\" +\n-            \"5LbMJg99z3vQBmod\/ipmOpND95\/BeA2mllBZgZ53S0nvDXDzbzR9Fd81PAz9Qruo\\n\" +\n-            \"dOJKcD6plKQjZjkLzNh1v\/RoCFO8kiJGE4UBMTM8FUk0DXH4bALII4wwmDelrSUu\\n\" +\n-            \"lKvDTDxZvPF4dbEXICNPd51EMGPgETxwboOV+bzWFVI0IWQ8PhZ2VuMPDk2taOMp\\n\" +\n-            \"NsuLtlYc2twPb9r\/Hvgv7G6+ItpBHZwOVt1oI3pHbjMp7P3pOZSPr6G1WkNy9mX8\\n\" +\n-            \"rVc=\\n\" +\n+            \"b24gUm9vdCBDQSAyMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENB\\n\" +\n+            \"IDJBMQ8wDQYDVQQDEwZBbWF6b24wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK\\n\" +\n+            \"AoICAQC0P8hSLewmrZ41CCPBQytZs5NBFMq5ztbnMf+kZUp9S25LPfjNW3zgC\/6E\\n\" +\n+            \"qCTWNVMMHhq7ez9IQJk48qbfBTLlZkuKnUWbA9vowrDfcxUN0mRE4B\/TJbveXyTf\\n\" +\n+            \"vE91iDlqDrERecE9D8sdjzURrtHTp27lZdRkXFvfEVCq4hl3sHkzjodisaQthLp1\\n\" +\n+            \"gLsiA7vKt+8zcL4Aeq52UyYb8r4\/jdZ3KaQp8O\/T4VwDCRKm8ey3kttpJWaflci7\\n\" +\n+            \"eRzNjY7gE3NMANVXCeQwOBfH2GjINFCObmPsqiBuoAnsv2k5aQLNoU1OZk08ClXm\\n\" +\n+            \"mEZ2rI5qZUTX1HuefBJnpMkPugFCw8afaHnB13SkLE7wxX8SZRdDIe5WiwyDL1tR\\n\" +\n+            \"2+8lpz4JsMoFopHmD3GaHyjbN+hkOqHgLltwewOsiyM0u3CZphypN2KeD+1FLjnY\\n\" +\n+            \"TgdIAd1FRgK2ZXDDrEdjnsSEfShKf0l4mFPSBs9E3U6sLmubDRXKLLLpa\/dF4eKu\\n\" +\n+            \"LEKS1bXYT28iM6D5gSCnzho5G4d18jQD\/slmc5XmRo5Pig0RyBwDaLuxeIZuiJ0A\\n\" +\n+            \"J6YFhffbrLYF5dEQl0cU+t3VBK5u\/o1WkWXsZawU038lWn\/AXerodT\/pAcrtWA4E\\n\" +\n+            \"NQEN09WEKMhZVPhqdwhF\/Gusr04mQtKt7T2v6UMQvtVglv5E7wIDAQABo4IBOTCC\\n\" +\n+            \"ATUwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYE\\n\" +\n+            \"FNpDStD8AcBLv1gnjHbNCoHzlC70MB8GA1UdIwQYMBaAFLAM8Eww9AVYAkj9M+VS\\n\" +\n+            \"r0uE42ZSMHsGCCsGAQUFBwEBBG8wbTAvBggrBgEFBQcwAYYjaHR0cDovL29jc3Au\\n\" +\n+            \"cm9vdGNhMi5hbWF6b250cnVzdC5jb20wOgYIKwYBBQUHMAKGLmh0dHA6Ly9jcnQu\\n\" +\n+            \"cm9vdGNhMi5hbWF6b250cnVzdC5jb20vcm9vdGNhMi5jZXIwPwYDVR0fBDgwNjA0\\n\" +\n+            \"oDKgMIYuaHR0cDovL2NybC5yb290Y2EyLmFtYXpvbnRydXN0LmNvbS9yb290Y2Ey\\n\" +\n+            \"LmNybDARBgNVHSAECjAIMAYGBFUdIAAwDQYJKoZIhvcNAQEMBQADggIBAEO5W+iF\\n\" +\n+            \"yChjDyyrmiwFupVWQ0Xy2ReFNQiZq7XKVHvsLQe01moSLnxcBxioOPBKt1KkZO7w\\n\" +\n+            \"Gcbmke0+7AxLaG\/F5NPnzRtK1\/pRhXQ0XdU8pVh\/1\/h4GoqRlZ\/eN0JDarUhZPkV\\n\" +\n+            \"kSr96LUYDTxcsAidF7zkzWfmtcJg\/Aw8mi14xKVEa6aVyKu54c8kKkdlt0WaigOv\\n\" +\n+            \"Z\/xYhxp24AfoFKaIraDNdsD8q2N7eDYeN4WGLzNSlil+iFjzflI9mq1hTuI\/ZNjV\\n\" +\n+            \"rbvob6FUQ8Cc524gMjbpZCNuZ1gfXzwwhGp0AnQF6CJsWF9uwPpZEVFnnnfiWH3M\\n\" +\n+            \"oup41EvBhqaAqOlny0sm5pI82nRUCAE3DLkJ1+eAtdQaYblZQkQrRyTuPmJEm+5y\\n\" +\n+            \"QwdDVw6uHc5OsSj\/tyhh8zJ2Xq3zgh3dMONGjJEysxGaCoIb+61PWwMy2dIarVwI\\n\" +\n+            \"r+c+AY+3PrhgBspNdWZ87JzNHii7ksdjUSVGTTy1vGXgPYrv0lp0IMnKaZP58xiw\\n\" +\n+            \"rDx7uTlQuPVWNOZvCaT3ZcoxTsNKNscIUe+WJjWx5hdzpv\/oksDPY5ltZ0j3hlDS\\n\" +\n+            \"D+Itk95\/cNJVRM\/0HpxI1SX9MTZtOSJoEDdUtOpVaOuBAvEK4gvTzdt0r5L+fuI6\\n\" +\n+            \"o5LAuRo\/LO1xVRH49KFRoaznzU3Ch9+kbPb3\\n\" +\n@@ -271,4 +226,4 @@\n-    \/\/ Owner: CN=valid.rootca2.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n-    \/\/ Serial number: 662f7646d76193cbb76946d111e49fa\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=good.sca2a.amazontrust.com\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n+    \/\/ Serial number: 75a5dd7d82269ed466af69794f34050bdffa2\n+    \/\/ Valid from: Fri Dec 17 12:22:32 PST 2021 until: Tue Jan 17 12:22:32 PST 2023\n@@ -276,43 +231,33 @@\n-            \"MIIICzCCBfOgAwIBAgIQBmL3ZG12GTy7dpRtER5J+jANBgkqhkiG9w0BAQwFADA8\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n-            \"UlNBIDQwOTYgTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLTEr\\n\" +\n-            \"MCkGA1UEAxMidmFsaWQucm9vdGNhMi5kZW1vLmFtYXpvbnRydXN0LmNvbTCCAiIw\\n\" +\n-            \"DQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAON5EbEKoBiujI7Ja8mLZLJbaY7f\\n\" +\n-            \"RtoWIjU\/F0l9ueWFogXmEaA1jWsl97F3WTHTyGKz6ChCjPMSyoXXpY+yoE90QUyX\\n\" +\n-            \"w35uWEhNrc40drMJkyN+QXitSrH346GCOKvpYVvu18UD4W8hDhg8vvbOQYhtmSf7\\n\" +\n-            \"Rfrs7\/qUdXpzpvR9VjWktbQAzJT8fB\/jFNjNQJTknynjGiYO5GF51+peOCLK6qw8\\n\" +\n-            \"9kKYEigR4K8\/aWL283rC4xRxZqVioy433VG02l\/Fwdv8o\/vL9YYIqkyspCB9fpFw\\n\" +\n-            \"Q50yYrwEomxuOz7rXhmdfeNaFYuyTtOUSKff6p2oqO0S7pcLujUVMlO4dYBDELQF\\n\" +\n-            \"cabByNjwblviCtGKJMIzD6Thkgamp3iXQgcU498+P5r7N5CYbMmkJEdcuILg+bgJ\\n\" +\n-            \"\/LUUTT+IMt2txYlO\/ld3N0EHlgVt7rztW5mtm6Ba8jN7cLSh7ZWu6Fr1+oK7bl5T\\n\" +\n-            \"wPxSfqT5W3BwQKS3YptIoKEWUb+VNnS\/dYx\/7IspF9+z6kw4g+V2EY9M4ZYNakzM\\n\" +\n-            \"AI7KIj4thMFoWeYrJq0dUMZ297QCBPRdAwh9hhkq2LYi2x8tMUtcBnhb\/q75sO+E\\n\" +\n-            \"icPqFVv7iMDZ\/8Xep+0UoClF3JGmZW3UNtwcbi7Pn\/OqtaMi7E8xnHUgc4ZchtXO\\n\" +\n-            \"v8VtVvDeZAlY5TjVAgMBAAGjggMWMIIDEjAfBgNVHSMEGDAWgBSecR8aHZOp2S2O\\n\" +\n-            \"zEhTPwNU857mZjAdBgNVHQ4EFgQUnGekBRKIZBYgCEajbpCMC24bp2owSQYDVR0R\\n\" +\n-            \"BEIwQIIidmFsaWQucm9vdGNhMi5kZW1vLmFtYXpvbnRydXN0LmNvbYIaZ29vZC5z\\n\" +\n-            \"Y2EyYS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWgMB0GA1UdJQQWMBQG\\n\" +\n-            \"CCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3Js\\n\" +\n-            \"LnI0bTAyLmFtYXpvbnRydXN0LmNvbS9yNG0wMi5jcmwwEwYDVR0gBAwwCjAIBgZn\\n\" +\n-            \"gQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5y\\n\" +\n-            \"NG0wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQucjRt\\n\" +\n-            \"MDIuYW1hem9udHJ1c3QuY29tL3I0bTAyLmNlcjAMBgNVHRMBAf8EAjAAMIIBfQYK\\n\" +\n-            \"KwYBBAHWeQIEAgSCAW0EggFpAWcAdgDuzdBk1dsazsVct520zROiModGfLzs3sNR\\n\" +\n-            \"SFlGcR+1mwAAAYgHvX9QAAAEAwBHMEUCIQD8qPPCLL2Grd+\/YNALWqAq7LC7YBaa\\n\" +\n-            \"dNg5+6Q4kRDEqgIgEkf\/UMsMNfTRaOZvoOgAK9\/F0xX\/CfdcUTjULhmoA+cAdQBI\\n\" +\n-            \"sONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgHvX8UAAAEAwBGMEQC\\n\" +\n-            \"IBVFDtapMMWJOqyu8Cv6XEhFmbU8N33c2owed\/\/pa80xAiAT9T6Wba3B9DFUmrL5\\n\" +\n-            \"cCGKLqciIEUPhPbvjCuUepelrAB2ANq2v2s\/tbYin5vCu1xr6HCRcWy7UYSFNL2k\\n\" +\n-            \"PTBI1\/urAAABiAe9ft8AAAQDAEcwRQIhAP2XDC\/RlmVtH4WrfSwVosR\/f\/WXRhG5\\n\" +\n-            \"mk9Nwq+ZOIriAiAopPXSH7VwXa3bEAIiTwcV1l10QIDZaIPCU5olknU5CjANBgkq\\n\" +\n-            \"hkiG9w0BAQwFAAOCAgEAFuwMIJdP5rgz6cqOIj2EgF2OU8CUGi\/wJ45BomXWv4Rv\\n\" +\n-            \"U5mOKB+jHOGZZC9dncjAMa44RwoF2I7\/8Y3qLVaoNm46ObvvS+6UvzTcyQqXM7JU\\n\" +\n-            \"cSmdlf9DkspjKPDvMBokVrM4ak5AoxUjuru5qaia3nvbxq7XKO9\/FGUaUaU8Xlsd\\n\" +\n-            \"V6Fo8VmNwFc88VCqOp8eI\/IicHxMDLl8TKXMvr3CYh8A9nCeFGcV+4CL+7JF2t5K\\n\" +\n-            \"YvV5r074Wyk0QMlRVYMNDl0t+VAEoDJ7RRE+kEvplWcsX9S2wvr4HhkA4iChpwFm\\n\" +\n-            \"2UDTppHskSWyLsuNQvipn0zTzZ8RIxXd\/ei0qCdhKmkV7x9cgbTiyXgaI7iJEtdo\\n\" +\n-            \"RvYNcXc2RmitWjY5Av8yJGOk0eYpCwRrBv6ughbtJe3NMrqUeTyrKidIEo9KnRSA\\n\" +\n-            \"rMokRbHunkroS97VkoK\/9j9pNJki+qAH9XTLYWcm\/5+cTSGRsN+escRgZwV6KWg\/\\n\" +\n-            \"JQQe5LbwU2HHzNqWuk63GC\/ngVlWXjaVFfbNVmYEKZFFazcZchesN1YyDu+WndOx\\n\" +\n-            \"+rTcuke2feOvQ4EnVviM0k85JZNiqPDH2iafAWyqZFUYTnb7XK3HhJflAniv\/SLq\\n\" +\n-            \"DQfbJmtQtNHdJYgVmC1u2RT9gbJDIAj0ZI4vU2WVB5Hmd9F31un6jundEuG4+S4=\\n\" +\n+            \"MIIGIDCCBAigAwIBAgITB1pd19giae1GavaXlPNAUL3\/ojANBgkqhkiG9w0BAQwF\\n\" +\n+            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n+            \"ZXIgQ0EgMkExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDIyMzJaFw0yMzAx\\n\" +\n+            \"MTcyMDIyMzJaMCUxIzAhBgNVBAMTGmdvb2Quc2NhMmEuYW1hem9udHJ1c3QuY29t\\n\" +\n+            \"MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAsCQonlc6fSTDJbH2y6wC\\n\" +\n+            \"mLeTD3noluSM4LPO53RgLTUvNqrxh\/iy9jDGgYP2xN8GGngRI8C65jZqGpJb0Hcp\\n\" +\n+            \"ADYssYKWcTR5OH8rUVsJ6DkJLx0AUOG+iJcCaqPudkw7WBReFEok7E058gCTbXps\\n\" +\n+            \"kNRT3w92CzzXa+49yxaAP0I6AQ9BqZP6gbAR1hmd9BDMCdak1JIswGVC3wGAKJFi\\n\" +\n+            \"c3FS3YeY7VyuXofeEwutvMH4Iag9DZU2puqskrGSmtrVju8CY6w1E\/cmBWD9kfpu\\n\" +\n+            \"Qet2LBZuzmws8XhCjU5cHOeA8pg2m7ZnyNBeZajg4hrbPq8ACjjDmEHiDgazoOGN\\n\" +\n+            \"1mV1BXZ2qonK+zJAMqE\/L0czEPjdROaF786pPY5Cpi1Rzk0R3KKjGhSHgzfCa2eX\\n\" +\n+            \"cQjBtA7AxLkK+1cI18hYg+okaV+EBrkxXGzeyTjvWbliotIQ9utabXGqJvJtIDeX\\n\" +\n+            \"OQSdSXlBKgwGTE5\/Ju8\/6NkJgSMEku\/Q9SYvfkzPXrj5VAHgPz4KhholeC4A4hRd\\n\" +\n+            \"Y3Xtr\/U5Xr3fTzLdOcLDKYW4\/OGCl8byjwx8bqO7q8YmgDg572Go3gUbNmlm2QN+\\n\" +\n+            \"NaXhBhPrl4KoHzawApTcod3adhSQziIMGjKYoKhV+ZGNoaLe7IUX0jyX3zygRS6k\\n\" +\n+            \"n6yeyeh1unDfqSvne9+hDEsCAwEAAaOCASYwggEiMA4GA1UdDwEB\/wQEAwIFoDAd\\n\" +\n+            \"BgNVHQ4EFgQU71fB1r7\/l2pFd0ydSNEiGaD+9uIwHwYDVR0jBBgwFoAU2kNK0PwB\\n\" +\n+            \"wEu\/WCeMds0KgfOULvQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMHUG\\n\" +\n+            \"CCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDovL29jc3Auc2NhMmEuYW1h\\n\" +\n+            \"em9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8vY3J0LnNjYTJhLmFtYXpv\\n\" +\n+            \"bnRydXN0LmNvbS9zY2EyYS5jZXIwJQYDVR0RBB4wHIIaZ29vZC5zY2EyYS5hbWF6\\n\" +\n+            \"b250cnVzdC5jb20wEwYDVR0gBAwwCjAIBgZngQwBAgEwDQYJKoZIhvcNAQEMBQAD\\n\" +\n+            \"ggIBAKULtBRmu4CtBTfBG6hXkBdFGneJlomw02h8dj7xkXof+DoLYtkuJ6XRp89f\\n\" +\n+            \"9UgYJMBjwKaAFjZzcVYvTd8YKdXzCXy4phxuHTfaV6ZH0WyvOlcTXsfdhJA4oD1G\\n\" +\n+            \"prB4\/PaymwSbv8ZQAE3eg1hytLLlR9+YUS0HfpwaH\/PIa0TzKG8Vuu5zKGSlJjeh\\n\" +\n+            \"Thp\/uMBC4twM558Jv2sxoUA5HjgPUyZW7r2eLFbOM1H4oR1US5zFYgzrEK1W12DO\\n\" +\n+            \"t65mI2YHbDepm5FoizwWYe4uaDCqWjCgzQw8pMGoiDABMaoNQ83Zi8r2sLGibAlb\\n\" +\n+            \"cVLcjsORsF6TNmYTW1KDT\/9hXlOaAhFwfAwKg6cZw51WEg51sPdi5USk\/oszavc5\\n\" +\n+            \"Ft\/IZaWSfkA1Xm0EyFwOwCOvGJIb9PWv5PfGZz4xnZlWhp6LfN31e3TagTUbzLVX\\n\" +\n+            \"XwbDI1cofCl18z6pidXXCASBCAajQ8N4GxNP6qqX9ou0yOBEXxwVqIJLcu3tueCI\\n\" +\n+            \"3Cb3rWfbybAVhuuP2ERKHJMY8XDCt0O\/g8Kj6O69NABOWvNkU3ARzszGzgBfv4IR\\n\" +\n+            \"jJJEskjxX7Q085iXlaRX\/mu+TpTkqK1ZbpBB1Z2PeVMujP+qsWSWGTZBXuI8eqyU\\n\" +\n+            \"dhq+VlyoVtWeMqKYMtakCJxnhwMZnn0sTzZk\/Yno+k9Jn0Rk\\n\" +\n@@ -321,4 +266,4 @@\n-    \/\/ Owner: CN=revoked.rootca2.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n-    \/\/ Serial number: 788baa8f47bc5b1c624424216240fd3\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=revoked.sca2a.amazontrust.com\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n+    \/\/ Serial number: 75a5df2d3387cfe5fd4cad9ff00f8c882b98d\n+    \/\/ Valid from: Fri Dec 17 12:28:31 PST 2021 until: Tue Jan 17 12:28:31 PST 2023\n@@ -326,44 +271,33 @@\n-            \"MIIIEjCCBfqgAwIBAgIQB4i6qPR7xbHGJEJCFiQP0zANBgkqhkiG9w0BAQwFADA8\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n-            \"UlNBIDQwOTYgTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLzEt\\n\" +\n-            \"MCsGA1UEAxMkcmV2b2tlZC5yb290Y2EyLmRlbW8uYW1hem9udHJ1c3QuY29tMIIC\\n\" +\n-            \"IjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzJfddWdrWhA9dSJdmy23veN9\\n\" +\n-            \"oLvSqpM4YaXGZmPtKUmbFMLs2I3vCKrzflRKeOpl3MCc2hh6TH\/3z+Q\/fGugXLsY\\n\" +\n-            \"H8QcjSbiIOd15n+3dUFTLKaoWMyseMcWiOIVaN5rCDVXiAHdt1pc147wyFQIzqNK\\n\" +\n-            \"J\/xiV1u9eT2MFue+4bd7kUNAcmI8M+SXruhto4jtAV8ugpTEChTDlyO\/l8xmaM1Q\\n\" +\n-            \"HkijsHX7Aq72Q\/3PH\/U+wbJ9pmpTp4x2AEJoo45IGfB\/NKDTrv5otLBuiP8Y0M7b\\n\" +\n-            \"K7irRPDFBqMNZw7S7p39SnC+V\/WibJQk5Bo\/8vcwDJX+WnDkw1QD\/uXu3ugDzSDD\\n\" +\n-            \"iBDViMOdN+3K47s4x2kdssoh4WWScMlAVb4vyN7IA3J4TnwA\/1uCWhw4LE1WvY7N\\n\" +\n-            \"etekhVP1eWF8IzNY0oo2u2ie79777xvBtmtp7RnvYLGv7I+xVhjH5qGNzn9fRCUm\\n\" +\n-            \"QDego5HAfJ0PLlMEagdW8asCak1WaC117adnibL6WPtFA2FD2i6gNalTvhXhK2Ex\\n\" +\n-            \"alGxrVd\/BCseT3bMp783jqScJO1g6xRHu0Qx+RyrOGVvcKZa6Y0DcAc8psRpkHaO\\n\" +\n-            \"HZY+lE8O2CIxpAJlwSnD6BoDNo8sg1IqFNkECw3wqfeMPBcg38k6zjAxwRDcIx6U\\n\" +\n-            \"SwDl4d3sjrmy3gOFFXMCAwEAAaOCAxswggMXMB8GA1UdIwQYMBaAFJ5xHxodk6nZ\\n\" +\n-            \"LY7MSFM\/A1TznuZmMB0GA1UdDgQWBBQXpWT7gMHO+HKoHM1gU1VQVnylRzBOBgNV\\n\" +\n-            \"HREERzBFgiRyZXZva2VkLnJvb3RjYTIuZGVtby5hbWF6b250cnVzdC5jb22CHXJl\\n\" +\n-            \"dm9rZWQuc2NhMmEuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\/wQEAwIFoDAdBgNV\\n\" +\n-            \"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQwMjAwoC6gLIYqaHR0\\n\" +\n-            \"cDovL2NybC5yNG0wMi5hbWF6b250cnVzdC5jb20vcjRtMDIuY3JsMBMGA1UdIAQM\\n\" +\n-            \"MAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDov\\n\" +\n-            \"L29jc3AucjRtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n-            \"Y3J0LnI0bTAyLmFtYXpvbnRydXN0LmNvbS9yNG0wMi5jZXIwDAYDVR0TAQH\/BAIw\\n\" +\n-            \"ADCCAX0GCisGAQQB1nkCBAIEggFtBIIBaQFnAHYA7s3QZNXbGs7FXLedtM0TojKH\\n\" +\n-            \"Rny87N7DUUhZRnEftZsAAAGIB72CzgAABAMARzBFAiEA2vPYIPfGJeynPaZHq\/c0\\n\" +\n-            \"GGvyT6MpvFGMW0s0woLRT28CIEFbZbFSCnKugaqw9QDNi7vYmIF3Gyi3s6G2cCxY\\n\" +\n-            \"4RJXAHYASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/qznYhHMAAAGIB72DDgAA\\n\" +\n-            \"BAMARzBFAiAvfNcgtFEwk5C9dvMUYANbIAv0IOdF1new8Umn3cM+JwIhALbs\/3L9\\n\" +\n-            \"0ndF7sRKDZmfronNruptFlrI528P5Qi2P528AHUA2ra\/az+1tiKfm8K7XGvocJFx\\n\" +\n-            \"bLtRhIU0vaQ9MEjX+6sAAAGIB72CxQAABAMARjBEAiBKUns2FPbs0cThb6e7SnyL\\n\" +\n-            \"y4\/qP3V1Q\/ASt\/ZDRTeEQQIgWSQO4Gsz32srtqYuTM9AsFd92WA44kJHincdcGVX\\n\" +\n-            \"XbIwDQYJKoZIhvcNAQEMBQADggIBAAnaNbn2wXylTCS7dtgB3rWdUf6hja1UDuvB\\n\" +\n-            \"uZEL2dUOvyXfVFLNxKdeWBPzqpwEBNNwPQXhoI97TXlyu2x60jLzQamoGoRQ3s0P\\n\" +\n-            \"NLhasLGEIQH\/oYdMV\/yp8EI8fUuRVE3xyw39FRqOrmsUFAnxNQmBO\/09JM7sLcvS\\n\" +\n-            \"wwh14p9dFTTolJHgnL4ZEtmZxSddFG+GBSTJ\/A7dVSmwIudwzd+goA6173BI6yeT\\n\" +\n-            \"hhQumLctQiOM7y1MzFeV8rL+oIpd2xuzyhKKT1EgvU6\/wyt0Ib8QqsFsrXPnUOKk\\n\" +\n-            \"HAq3SeZyq35QUaTKoaH9L1iZMbSCG9Jm6FMb12SdAz53653tYvAiUS76oD8Jot13\\n\" +\n-            \"RZu5NUlWAVLLq0OaEtuGp0bh+cVtzVnCC9m1qa46YpY0SojpvSbakgQMMGIgDlT3\\n\" +\n-            \"wFE7tST4WlsDC1f\/m+H9V5qz\/j0U8D3eNNdowxPqx\/JZq\/sk9ZK5KyMFARrvM+fh\\n\" +\n-            \"YrVYjKt91mu7JaS4pPOyZmJ8OQ14EvrN7BXc7IkNrI1reeaRFe49k5DAETB8VmP5\\n\" +\n-            \"2F0SWou2KkgtJvU4Z7YjlZ2HNHnpjTK5KdPNpRSt7EUy2zn9NCNoyQhnws70FyXv\\n\" +\n-            \"oPFyG92lnUQOKaAUhVRwTr9fvnkdMOzSKg\/spxi2Ogdzym5Jw68eguwi0dVqX2+9\\n\" +\n-            \"3zViP2aH\\n\" +\n+            \"MIIGJjCCBA6gAwIBAgITB1pd8tM4fP5f1MrZ\/wD4yIK5jTANBgkqhkiG9w0BAQwF\\n\" +\n+            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n+            \"ZXIgQ0EgMkExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDI4MzFaFw0yMzAx\\n\" +\n+            \"MTcyMDI4MzFaMCgxJjAkBgNVBAMTHXJldm9rZWQuc2NhMmEuYW1hem9udHJ1c3Qu\\n\" +\n+            \"Y29tMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAu\/9+ky4Z5U24pBYd\\n\" +\n+            \"6xyb1BGQHTXS5nW8QjLWx+xaunRitgIBB8ZZ8OzUmH2mp2S\/9Vq1nqii9TvuzA9K\\n\" +\n+            \"JJQZLK8K+OJX\/ZwFdSxTgLcyeJ9cCswj\/C3SBA1NopZ3DmEWeXlh7aZhl8IXB6kp\\n\" +\n+            \"zI87Tg72F2JJokWNPYdx7xXhf\/WVeDeNRkz1iE5UTwL+qaNuzT7S8BdnFWqa3l4a\\n\" +\n+            \"Q1J\/YVww0XRhsYJulNVGhoKNf71q8KWw8hJ\/zgMxrBFywu7d3OBw6NX3bowZ+jMQ\\n\" +\n+            \"apJEWiwUYOjH3XcOO6TiChwQMypBrcbGgrD\/msTlvIBinHwpWaAgX0kT80+wH1Bq\\n\" +\n+            \"mw72fEjeE\/Y6EL6WIUr1HQdLhvBDxtPgxnAaxptmg126cF4jV\/e+D+IGf6qpN1gR\\n\" +\n+            \"JQC\/0+AnASAJ0cGKjSODbl5miqtc0kFSReMsOJeT7gdoPCMg4gWyo62GSvdaAA0I\\n\" +\n+            \"DA8a0HWLAzXU7SwbytTUTYeVI8QeNm2ZGKvMoHDWSDz69V6gGmNl\/YSvyJ2zPOZL\\n\" +\n+            \"8oRKRUCOA2LPdK0s7nebe0EBXF09FzzE4HdegRe7r86t6FE400W4wxwJjvjdHXcF\\n\" +\n+            \"s9fI+mgofMvVuK2u3wTdHOrEbfm1GXmj3BlFBORUI11A7K0lmIA02M2jkAN13foe\\n\" +\n+            \"rFLYg+28UjT4aN62zkynKD1iNwkCAwEAAaOCASkwggElMA4GA1UdDwEB\/wQEAwIF\\n\" +\n+            \"oDAdBgNVHQ4EFgQUOzuuTB9A8p71qwA3qxqOABf69nkwHwYDVR0jBBgwFoAU2kNK\\n\" +\n+            \"0PwBwEu\/WCeMds0KgfOULvQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMC\\n\" +\n+            \"MHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDovL29jc3Auc2NhMmEu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8vY3J0LnNjYTJhLmFt\\n\" +\n+            \"YXpvbnRydXN0LmNvbS9zY2EyYS5jZXIwKAYDVR0RBCEwH4IdcmV2b2tlZC5zY2Ey\\n\" +\n+            \"YS5hbWF6b250cnVzdC5jb20wEwYDVR0gBAwwCjAIBgZngQwBAgEwDQYJKoZIhvcN\\n\" +\n+            \"AQEMBQADggIBALAPC6I\/k\/WqJ8dxt7yhhSKA5RyGjd16kh+zq57Cjy0Wmj3BtSFJ\\n\" +\n+            \"l0652ULeHZDjhtEAEMFlWdxuuUJ82UhzPzujeVv5e8CLROYWp52Jb9CFPTwF54ow\\n\" +\n+            \"0a6recetYvOHBTeQ0cmo3nY6Z8eHDRUdk\/aGQku1cesntFOIWm+EDj7SDYnUm3Ub\\n\" +\n+            \"ECdMv8entU5yjo\/herVNMT6GGnKfjRxM0FWJWoHKKC\/EPIka34VN6LOZO4Ftl9wI\\n\" +\n+            \"Ms7w3EgweEqLOyaGSAFwzrcQwKkPBm8fW5CefDtB64CtC8NUuo+XOQ2\/JlRnWGLk\\n\" +\n+            \"CHxesJBUNk5c\/IBDPLmyrKCLbGUqwsehQGQdSrLIH0857pTJi30D+\/KDvgQynaay\\n\" +\n+            \"zPWLrSJvXUOQ9Vir+RQtbiMOqUDXX15Vty2mxLqjos1zCAxgrorZ7H2OSBZIWYzE\\n\" +\n+            \"8UgF1\/vOlAtMjYyLLgb2UyqAY2HybKjtYYAyV\/oIPjVRXygaOGkDZseqqXuslq5I\\n\" +\n+            \"ZSDU5hF6Hy6D6gsCVdshswwuRg39248M79qsMDw0Xa7xGcwqdfwTHv4Rb3G\/kTrA\\n\" +\n+            \"8iR2YP\/RdABKkTkUKRXs0kYPFoJ0wQPDD5slkLjdZNeezoNrw1rWEEUh1iildiRA\\n\" +\n+            \"i1p+pwXSyZ+m5Gv0\/W84DDhLmAdvFov5muga8UccNbHuObtt1vHIhHe1\\n\" +\n@@ -372,1 +306,8 @@\n-    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n+        \/\/ EE certificates don't have CRLDP extension\n+        if (!ocspEnabled){\n+            pathValidator.validate(new String[]{INT},\n+                    ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+            return;\n+        }\n@@ -381,1 +322,1 @@\n-                \"Mon May 15 13:38:54 PDT 2023\", System.out);\n+                \"Fri Dec 17 12:29:36 PST 2021\", System.out);\n@@ -387,1 +328,1 @@\n-    \/\/ Owner: CN=Amazon ECDSA 256 M02, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n@@ -389,27 +330,4 @@\n-    \/\/ Serial number: 773126de2c2fafd2c47ad88b1566e0182046d\n-    \/\/ Valid from: Tue Aug 23 15:33:24 PDT 2022 until: Fri Aug 23 15:33:24 PDT 2030\n-    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIC1DCCAnmgAwIBAgITB3MSbeLC+v0sR62IsVZuAYIEbTAKBggqhkjOPQQDAjA5\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\\n\" +\n-            \"Um9vdCBDQSAzMB4XDTIyMDgyMzIyMzMyNFoXDTMwMDgyMzIyMzMyNFowPTELMAkG\\n\" +\n-            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n-            \"IDI1NiBNMDIwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAS9vQLD4W\/Kg4AnFRl8\\n\" +\n-            \"x\/FUbLqtd5ICYjUijGsytF9hmgb\/Dyk+Ebt4cw6rAlGbaiOLapSJKZiZr+UQdh3I\\n\" +\n-            \"QOr+o4IBWjCCAVYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYw\\n\" +\n-            \"HQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBS7eJrXaDMy\\n\" +\n-            \"nRq7bP2xNEwB3svQdTAfBgNVHSMEGDAWgBSrttvXBp43rDCGB5Fwx5zEGbF4wDB7\\n\" +\n-            \"BggrBgEFBQcBAQRvMG0wLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLnJvb3RjYTMu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tMDoGCCsGAQUFBzAChi5odHRwOi8vY3J0LnJvb3RjYTMu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tL3Jvb3RjYTMuY2VyMD8GA1UdHwQ4MDYwNKAyoDCGLmh0\\n\" +\n-            \"dHA6Ly9jcmwucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNhMy5jcmwwEwYD\\n\" +\n-            \"VR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwIDSQAwRgIhAKSYEcDcp3kcPMzh\\n\" +\n-            \"OIYDWZOLu4InPod4fQhRTmc2zBAgAiEAmwdGE4AuNWhw9N8REhf82rJLNm7h9Myg\\n\" +\n-            \"TsR9Wu0bQYU=\\n\" +\n-            \"-----END CERTIFICATE-----\";\n-\n-    \/\/ Owner: CN=Amazon ECDSA 256 M01, O=Amazon, C=US\n-    \/\/ Issuer: CN=Amazon Root CA 3, O=Amazon, C=US\n-    \/\/ Serial number: 773126684d577c0fcf8d3a342bea86f94fc8f\n-    \/\/ Valid from: Tue Aug 23 15:31:46 PDT 2022 until: Fri Aug 23 15:31:46 PDT 2030\n-    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIC0zCCAnmgAwIBAgITB3MSZoTVd8D8+NOjQr6ob5T8jzAKBggqhkjOPQQDAjA5\\n\" +\n+    \/\/ Serial number: 67f945758fe55b9ee3f75831d47f07d226c8a\n+    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n+    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICuzCCAmGgAwIBAgITBn+UV1j+VbnuP3WDHUfwfSJsijAKBggqhkjOPQQDAjA5\\n\" +\n@@ -417,14 +335,13 @@\n-            \"Um9vdCBDQSAzMB4XDTIyMDgyMzIyMzE0NloXDTMwMDgyMzIyMzE0NlowPTELMAkG\\n\" +\n-            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n-            \"IDI1NiBNMDEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAT80w+2RwNHzyXmVUM\/\\n\" +\n-            \"OUKBZpJkTzHyCKDl4sBrUfjzVjot\/lNba9kYzMKSHYv95CUDoMaF2h2KAqx65uLQ\\n\" +\n-            \"Y8ago4IBWjCCAVYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYw\\n\" +\n-            \"HQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBRPWfy8BhYo\\n\" +\n-            \"v6LI2wj7zxMkumlCXDAfBgNVHSMEGDAWgBSrttvXBp43rDCGB5Fwx5zEGbF4wDB7\\n\" +\n-            \"BggrBgEFBQcBAQRvMG0wLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLnJvb3RjYTMu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tMDoGCCsGAQUFBzAChi5odHRwOi8vY3J0LnJvb3RjYTMu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tL3Jvb3RjYTMuY2VyMD8GA1UdHwQ4MDYwNKAyoDCGLmh0\\n\" +\n-            \"dHA6Ly9jcmwucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNhMy5jcmwwEwYD\\n\" +\n-            \"VR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwIDSAAwRQIhALRfxq3SQIhj5xA4\\n\" +\n-            \"S5UAY\/KlKqayZDpnbBdCDH8Kqmf\/AiAUVZddALefnqRe+ifxN2FUp461LL6\/cgVM\\n\" +\n-            \"EH3Ty27f1Q==\\n\" +\n+            \"Um9vdCBDQSAzMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENBIDNB\\n\" +\n+            \"MQ8wDQYDVQQDEwZBbWF6b24wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATYcYsK\\n\" +\n+            \"mYdR0Gj8Xz45E\/lfcTTnXhg2EtAIYBIHyXv\/ZQyyyCas1aptX\/I5T1coT6XK181g\\n\" +\n+            \"nB8hADuKfWlNoIYRo4IBOTCCATUwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8B\\n\" +\n+            \"Af8EBAMCAYYwHQYDVR0OBBYEFATc4JXl6LlrlKHvjFsxHhN+VZfaMB8GA1UdIwQY\\n\" +\n+            \"MBaAFKu229cGnjesMIYHkXDHnMQZsXjAMHsGCCsGAQUFBwEBBG8wbTAvBggrBgEF\\n\" +\n+            \"BQcwAYYjaHR0cDovL29jc3Aucm9vdGNhMy5hbWF6b250cnVzdC5jb20wOgYIKwYB\\n\" +\n+            \"BQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNh\\n\" +\n+            \"My5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2EzLmFtYXpv\\n\" +\n+            \"bnRydXN0LmNvbS9yb290Y2EzLmNybDARBgNVHSAECjAIMAYGBFUdIAAwCgYIKoZI\\n\" +\n+            \"zj0EAwIDSAAwRQIgOl\/vux0qfxNm05W3eofa9lKwz6oKvdu6g6Sc0UlwgRcCIQCS\\n\" +\n+            \"WSQ6F6JHLoeOWLyFFF658eNKEKbkEGMHz34gLX\/N3g==\\n\" +\n@@ -433,4 +350,4 @@\n-    \/\/ Owner: CN=valid.rootca3.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon ECDSA 256 M02, O=Amazon, C=US\n-    \/\/ Serial number: 8e2f14864fb28e4a1da0f15a5118cc8\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=good.sca3a.amazontrust.com\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n+    \/\/ Serial number: 75a5dd9ec12f37f4bbed4bada4b75164a642f\n+    \/\/ Valid from: Fri Dec 17 12:23:00 PST 2021 until: Tue Jan 17 12:23:00 PST 2023\n@@ -438,25 +355,14 @@\n-            \"MIIEfjCCBCWgAwIBAgIQCOLxSGT7KOSh2g8VpRGMyDAKBggqhkjOPQQDAjA9MQsw\\n\" +\n-            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n-            \"U0EgMjU2IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC0xKzAp\\n\" +\n-            \"BgNVBAMTInZhbGlkLnJvb3RjYTMuZGVtby5hbWF6b250cnVzdC5jb20wWTATBgcq\\n\" +\n-            \"hkjOPQIBBggqhkjOPQMBBwNCAAQfWc7gBGBBBmseCb2XWWRQVhCUQDVml3mVgvj5\\n\" +\n-            \"RmnP1y5wpifUTFqu8ELdI7YGZ4JMSnetiKNmLtg5yhTEjzCQo4IDFTCCAxEwHwYD\\n\" +\n-            \"VR0jBBgwFoAUu3ia12gzMp0au2z9sTRMAd7L0HUwHQYDVR0OBBYEFHCE8orvZDUK\\n\" +\n-            \"5TI9MYadzxWR9CZGMEkGA1UdEQRCMECCInZhbGlkLnJvb3RjYTMuZGVtby5hbWF6\\n\" +\n-            \"b250cnVzdC5jb22CGmdvb2Quc2NhM2EuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\\n\" +\n-            \"\/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQw\\n\" +\n-            \"MjAwoC6gLIYqaHR0cDovL2NybC5lMm0wMi5hbWF6b250cnVzdC5jb20vZTJtMDIu\\n\" +\n-            \"Y3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEF\\n\" +\n-            \"BQcwAYYhaHR0cDovL29jc3AuZTJtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUF\\n\" +\n-            \"BzAChipodHRwOi8vY3J0LmUybTAyLmFtYXpvbnRydXN0LmNvbS9lMm0wMi5jZXIw\\n\" +\n-            \"DAYDVR0TAQH\/BAIwADCCAXwGCisGAQQB1nkCBAIEggFsBIIBaAFmAHUA7s3QZNXb\\n\" +\n-            \"Gs7FXLedtM0TojKHRny87N7DUUhZRnEftZsAAAGIB71y\/gAABAMARjBEAiAEAXIb\\n\" +\n-            \"aOVR26HgFaI+qoIasCb8w2sOqVxGAxf5iPgX6QIgdAlMjqeoihi1arnJpzN8Bqxy\\n\" +\n-            \"5ULMUO7GK3JEgcogJHMAdgBIsONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiE\\n\" +\n-            \"cwAAAYgHvXLkAAAEAwBHMEUCIF7wDDmWxTHwBZM7Me8eOCM1aQ\/g1c1rJg\/I+NJa\\n\" +\n-            \"HkZYAiEA8p+IviuY5piHBELjUtVlZLiS9XSSMxpQNhUerqC\/YFoAdQDatr9rP7W2\\n\" +\n-            \"Ip+bwrtca+hwkXFsu1GEhTS9pD0wSNf7qwAAAYgHvXKvAAAEAwBGMEQCIFLskZDs\\n\" +\n-            \"UG4+\/88D\/5\/QbD9zT6ZmZlwXiPZ6H2YR\/KiJAiBvi4vvNsb9KNAhJMgI2T2iCg9U\\n\" +\n-            \"CIru+US6y3ua7dKKDTAKBggqhkjOPQQDAgNHADBEAiAzvgzKV\/kvBbKWCT1NNUBD\\n\" +\n-            \"AF9okIEcJx\/ukFgzmYMwUQIgXeJeVf3izkxsgiEUSknwHsErLFs\/cEme2PSRj2AW\\n\" +\n-            \"dYA=\\n\" +\n+            \"MIIClDCCAjqgAwIBAgITB1pd2ewS839LvtS62kt1FkpkLzAKBggqhkjOPQQDAjBG\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n+            \"Q0EgM0ExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDIzMDBaFw0yMzAxMTcy\\n\" +\n+            \"MDIzMDBaMCUxIzAhBgNVBAMTGmdvb2Quc2NhM2EuYW1hem9udHJ1c3QuY29tMFkw\\n\" +\n+            \"EwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE275wkVMovF+U\/fRduMcuthD8AYpYTUgc\\n\" +\n+            \"qoEHEccF6eZYzoGlufHJCwtLHXk9qXeXtjZV8N90ksYahFV+oGFcpaOCASYwggEi\\n\" +\n+            \"MA4GA1UdDwEB\/wQEAwIHgDAdBgNVHQ4EFgQUS8gTB11XA49gH4IGAD6p3UilrIMw\\n\" +\n+            \"HwYDVR0jBBgwFoAUBNzgleXouWuUoe+MWzEeE35Vl9owHQYDVR0lBBYwFAYIKwYB\\n\" +\n+            \"BQUHAwEGCCsGAQUFBwMCMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0\\n\" +\n+            \"cDovL29jc3Auc2NhM2EuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRw\\n\" +\n+            \"Oi8vY3J0LnNjYTNhLmFtYXpvbnRydXN0LmNvbS9zY2EzYS5jZXIwJQYDVR0RBB4w\\n\" +\n+            \"HIIaZ29vZC5zY2EzYS5hbWF6b250cnVzdC5jb20wEwYDVR0gBAwwCjAIBgZngQwB\\n\" +\n+            \"AgEwCgYIKoZIzj0EAwIDSAAwRQIgRRteTEwQoqw95mKff0ydDMD1+YQbcN6QLw\/a\\n\" +\n+            \"NwDti9ICIQDYMNw6u0d5gaZZo\/zizl1JRVAuSxoO5lNOrleaEOkImA==\\n\" +\n@@ -465,4 +371,4 @@\n-    \/\/ Owner: CN=revoked.rootca3.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon ECDSA 256 M01, O=Amazon, C=US\n-    \/\/ Serial number: c458bfaeedae16a5e61fe64773fc898\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=revoked.sca3a.amazontrust.com\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n+    \/\/ Serial number: 75a5df9c88c0613777baba663000de147a26b\n+    \/\/ Valid from: Fri Dec 17 12:30:04 PST 2021 until: Tue Jan 17 12:30:04 PST 2023\n@@ -470,25 +376,14 @@\n-            \"MIIEhzCCBC2gAwIBAgIQDEWL+u7a4WpeYf5kdz\/ImDAKBggqhkjOPQQDAjA9MQsw\\n\" +\n-            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n-            \"U0EgMjU2IE0wMTAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC8xLTAr\\n\" +\n-            \"BgNVBAMTJHJldm9rZWQucm9vdGNhMy5kZW1vLmFtYXpvbnRydXN0LmNvbTBZMBMG\\n\" +\n-            \"ByqGSM49AgEGCCqGSM49AwEHA0IABAsSs5kW5TZlS0SDrMb9iUQAqEaKa12Fc6SN\\n\" +\n-            \"9UR6qtOFdW\/1UuziDq3Hl5dqsAYZJkbJSPCIsD2HTP\/EGTMKITCjggMbMIIDFzAf\\n\" +\n-            \"BgNVHSMEGDAWgBRPWfy8BhYov6LI2wj7zxMkumlCXDAdBgNVHQ4EFgQUeE55ET2e\\n\" +\n-            \"i8KbY7KHTxOuvCkRpTowTgYDVR0RBEcwRYIkcmV2b2tlZC5yb290Y2EzLmRlbW8u\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tgh1yZXZva2VkLnNjYTNhLmFtYXpvbnRydXN0LmNvbTAO\\n\" +\n-            \"BgNVHQ8BAf8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMDsG\\n\" +\n-            \"A1UdHwQ0MDIwMKAuoCyGKmh0dHA6Ly9jcmwuZTJtMDEuYW1hem9udHJ1c3QuY29t\\n\" +\n-            \"L2UybTAxLmNybDATBgNVHSAEDDAKMAgGBmeBDAECATB1BggrBgEFBQcBAQRpMGcw\\n\" +\n-            \"LQYIKwYBBQUHMAGGIWh0dHA6Ly9vY3NwLmUybTAxLmFtYXpvbnRydXN0LmNvbTA2\\n\" +\n-            \"BggrBgEFBQcwAoYqaHR0cDovL2NydC5lMm0wMS5hbWF6b250cnVzdC5jb20vZTJt\\n\" +\n-            \"MDEuY2VyMAwGA1UdEwEB\/wQCMAAwggF9BgorBgEEAdZ5AgQCBIIBbQSCAWkBZwB2\\n\" +\n-            \"AHb\/iD8KtvuVUcJhzPWHujS0pM27KdxoQgqf5mdMWjp0AAABiAe9lQ8AAAQDAEcw\\n\" +\n-            \"RQIgZVFAX5WPZRBpEOqk620v4Rbzxh\/3wrJ5QBMBJ0Mb8B0CIQC0oxFVLfs+PAv7\\n\" +\n-            \"25wawOu2VgDXG9lJAJtCwk3gN8BshQB2AEiw42vapkc0D+VqAvqdMOscUgHLVt0s\\n\" +\n-            \"gdm7v6s52IRzAAABiAe9lQ4AAAQDAEcwRQIhAIPVMj6IfjAUKeGYbpG9s0DRdWbc\\n\" +\n-            \"b8OzsOf+kRqk03NMAiB777hfoFCUMPrN0g8o5v6zp3T3qOhRnYY0TZN4q4NnMgB1\\n\" +\n-            \"ANq2v2s\/tbYin5vCu1xr6HCRcWy7UYSFNL2kPTBI1\/urAAABiAe9lN4AAAQDAEYw\\n\" +\n-            \"RAIgL0qoVbKLFD+Y3f\/V6Rw+euZrPO6d1HEVPQGo7wLzkl8CIGHp3PQmmrEofl76\\n\" +\n-            \"4da7bY0L+csFW0sB8clN0KziMfe6MAoGCCqGSM49BAMCA0gAMEUCIQC+6VdX9X5g\\n\" +\n-            \"x3NSUmJ7py01Zxf26TNBv1ildxqesvZ\/7wIgIrefriRzPiIFDHCUbdjk0VlmMwZR\\n\" +\n-            \"VzXXHINsGCiCKOs=\\n\" +\n+            \"MIICmzCCAkCgAwIBAgITB1pd+ciMBhN3e6umYwAN4UeiazAKBggqhkjOPQQDAjBG\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n+            \"Q0EgM0ExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDMwMDRaFw0yMzAxMTcy\\n\" +\n+            \"MDMwMDRaMCgxJjAkBgNVBAMTHXJldm9rZWQuc2NhM2EuYW1hem9udHJ1c3QuY29t\\n\" +\n+            \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEbppBP3Dj0qoRHMB9VMTXhw2Fg8ef\\n\" +\n+            \"o32r\/Mu3IzT8T6kWCk3UqVDL3UIn3qVZLCW1nJfVc1d1EeSDvyjCL3u3f6OCASkw\\n\" +\n+            \"ggElMA4GA1UdDwEB\/wQEAwIHgDAdBgNVHQ4EFgQUv8lJ3W7O74zVj+0zhD4+rrqZ\\n\" +\n+            \"yvMwHwYDVR0jBBgwFoAUBNzgleXouWuUoe+MWzEeE35Vl9owHQYDVR0lBBYwFAYI\\n\" +\n+            \"KwYBBQUHAwEGCCsGAQUFBwMCMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYh\\n\" +\n+            \"aHR0cDovL29jc3Auc2NhM2EuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipo\\n\" +\n+            \"dHRwOi8vY3J0LnNjYTNhLmFtYXpvbnRydXN0LmNvbS9zY2EzYS5jZXIwKAYDVR0R\\n\" +\n+            \"BCEwH4IdcmV2b2tlZC5zY2EzYS5hbWF6b250cnVzdC5jb20wEwYDVR0gBAwwCjAI\\n\" +\n+            \"BgZngQwBAgEwCgYIKoZIzj0EAwIDSQAwRgIhAKrA0fOK4NKDKHTY8ESeVW3D\/7NH\\n\" +\n+            \"tbNdfcIXolAoFfmFAiEAylAsKdND8c4w69jlFTId0X8F\/mrXzKfLFCQ+b\/7jTto=\\n\" +\n@@ -497,1 +392,8 @@\n-    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n+        \/\/ EE certificates don't have CRLDP extension\n+        if (!ocspEnabled){\n+            pathValidator.validate(new String[]{INT},\n+                    ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+            return;\n+        }\n@@ -500,1 +402,1 @@\n-        pathValidator.validate(new String[]{VALID, INT_VALID},\n+        pathValidator.validate(new String[]{VALID, INT},\n@@ -504,1 +406,1 @@\n-        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n+        pathValidator.validate(new String[]{REVOKED, INT},\n@@ -506,1 +408,1 @@\n-                \"Mon May 15 13:41:22 PDT 2023\", System.out);\n+                \"Fri Dec 17 12:30:37 PST 2021\", System.out);\n@@ -512,1 +414,1 @@\n-    \/\/ Owner: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n@@ -514,2 +416,2 @@\n-    \/\/ Serial number: 773127dfaa6b9e2b95538aa76dde4307f17c4\n-    \/\/ Valid from: Tue Aug 23 15:36:58 PDT 2022 until: Fri Aug 23 15:36:58 PDT 2030\n+    \/\/ Serial number: 67f94575a8862a9072e3239c37ceba1274e18\n+    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n@@ -517,1 +419,1 @@\n-            \"MIIDETCCApagAwIBAgITB3MSffqmueK5VTiqdt3kMH8XxDAKBggqhkjOPQQDAzA5\\n\" +\n+            \"MIIC+TCCAn6gAwIBAgITBn+UV1qIYqkHLjI5w3zroSdOGDAKBggqhkjOPQQDAzA5\\n\" +\n@@ -519,15 +421,14 @@\n-            \"Um9vdCBDQSA0MB4XDTIyMDgyMzIyMzY1OFoXDTMwMDgyMzIyMzY1OFowPTELMAkG\\n\" +\n-            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n-            \"IDM4NCBNMDIwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATNYzWQDXV0NoNmR0hJPwJq\\n\" +\n-            \"hjYOOS9z0B2Z7MQudxg5x3Vsib6N+tJkq8dljRq5o6K0bbh\/kRVfoi9wfKhB03Yz\\n\" +\n-            \"gkerrwRCH7Z9gU5nbBY+Y5+EtImq4yOB0n7JQgQxWemjggFaMIIBVjASBgNVHRMB\\n\" +\n-            \"Af8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\\n\" +\n-            \"AQYIKwYBBQUHAwIwHQYDVR0OBBYEFKbZqzuHmTP\/6Gj4i2GDbNCyuq+9MB8GA1Ud\\n\" +\n-            \"IwQYMBaAFNPsxzplbszh2naaVvuc84ZtV+WBMHsGCCsGAQUFBwEBBG8wbTAvBggr\\n\" +\n-            \"BgEFBQcwAYYjaHR0cDovL29jc3Aucm9vdGNhNC5hbWF6b250cnVzdC5jb20wOgYI\\n\" +\n-            \"KwYBBQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhNC5hbWF6b250cnVzdC5jb20vcm9v\\n\" +\n-            \"dGNhNC5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2E0LmFt\\n\" +\n-            \"YXpvbnRydXN0LmNvbS9yb290Y2E0LmNybDATBgNVHSAEDDAKMAgGBmeBDAECATAK\\n\" +\n-            \"BggqhkjOPQQDAwNpADBmAjEA2zCG6x0xMlgSXWEGLN8+1XN+OCYF5vj0Z1jtVy+A\\n\" +\n-            \"pdLlzuxNt9HBWn3hvqvO2W8KAjEApNdsZOCmk5uZBYiuCSBnDH3jyKhN6dWyuuHW\\n\" +\n-            \"9Wj7SxKnOU5+wYWZA0BQAv1KT62i\\n\" +\n+            \"Um9vdCBDQSA0MB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENBIDRB\\n\" +\n+            \"MQ8wDQYDVQQDEwZBbWF6b24wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASRP0kIW0Ha\\n\" +\n+            \"7+ORvEVhIS5gIgkH66X5W9vBRTX14oG\/1elIyI6LbFZ+E5KAufL0XoWJGI1WbPRm\\n\" +\n+            \"HW246FKSzF0wOEZZyxEROz6tuaVsnXRHRE76roS\/Wr064uJpKH+Lv+SjggE5MIIB\\n\" +\n+            \"NTASBgNVHRMBAf8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHQ4EFgQU\\n\" +\n+            \"pSHN2+tTIZmqytlnQpQlsnv0wuMwHwYDVR0jBBgwFoAU0+zHOmVuzOHadppW+5zz\\n\" +\n+            \"hm1X5YEwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8vb2NzcC5y\\n\" +\n+            \"b290Y2E0LmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDovL2NydC5y\\n\" +\n+            \"b290Y2E0LmFtYXpvbnRydXN0LmNvbS9yb290Y2E0LmNlcjA\/BgNVHR8EODA2MDSg\\n\" +\n+            \"MqAwhi5odHRwOi8vY3JsLnJvb3RjYTQuYW1hem9udHJ1c3QuY29tL3Jvb3RjYTQu\\n\" +\n+            \"Y3JsMBEGA1UdIAQKMAgwBgYEVR0gADAKBggqhkjOPQQDAwNpADBmAjEA59RAOBaj\\n\" +\n+            \"uh0rT\/OOTWPEv6TBnb9XEadburBaXb8SSrR8il+NdkfS9WXRAzbwrG7LAjEA3ukD\\n\" +\n+            \"1HrQq+WXHBM5sIuViJI\/Zh7MOjsc159Q+dn36PBqLRq03AXqE\/lRjnv8C5nj\\n\" +\n@@ -536,4 +437,4 @@\n-    \/\/ Owner: CN=valid.rootca4.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n-    \/\/ Serial number: f579bed3369f1a147ea5d0e8e6532d3\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=good.sca4a.amazontrust.com\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n+    \/\/ Serial number: 75a5ddc1a4ea5a18110454883269df9409bf5\n+    \/\/ Valid from: Fri Dec 17 12:23:29 PST 2021 until: Tue Jan 17 12:23:29 PST 2023\n@@ -541,26 +442,16 @@\n-            \"MIIEvjCCBESgAwIBAgIQD1eb7TNp8aFH6l0OjmUy0zAKBggqhkjOPQQDAzA9MQsw\\n\" +\n-            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n-            \"U0EgMzg0IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC0xKzAp\\n\" +\n-            \"BgNVBAMTInZhbGlkLnJvb3RjYTQuZGVtby5hbWF6b250cnVzdC5jb20wdjAQBgcq\\n\" +\n-            \"hkjOPQIBBgUrgQQAIgNiAAT6\/95JFuvx5t9MVeRZmBtXq63Q2fXZnSwEy2U2F4Qc\\n\" +\n-            \"ejhDwcYfD2HmT6S6GrKqLNJMa5n2YOvet4LZpKJLFF+BQo6FJt5cXkzHHxZ1I4z3\\n\" +\n-            \"8pGU79CpCgFOFy6QUlF68NajggMXMIIDEzAfBgNVHSMEGDAWgBSm2as7h5kz\/+ho\\n\" +\n-            \"+Ithg2zQsrqvvTAdBgNVHQ4EFgQUR\/GnpQkrUsCj8jF6\/JIE1Rs07zswSQYDVR0R\\n\" +\n-            \"BEIwQIIidmFsaWQucm9vdGNhNC5kZW1vLmFtYXpvbnRydXN0LmNvbYIaZ29vZC5z\\n\" +\n-            \"Y2E0YS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgeAMB0GA1UdJQQWMBQG\\n\" +\n-            \"CCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3Js\\n\" +\n-            \"LmUzbTAyLmFtYXpvbnRydXN0LmNvbS9lM20wMi5jcmwwEwYDVR0gBAwwCjAIBgZn\\n\" +\n-            \"gQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5l\\n\" +\n-            \"M20wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuZTNt\\n\" +\n-            \"MDIuYW1hem9udHJ1c3QuY29tL2UzbTAyLmNlcjAMBgNVHRMBAf8EAjAAMIIBfgYK\\n\" +\n-            \"KwYBBAHWeQIEAgSCAW4EggFqAWgAdgDuzdBk1dsazsVct520zROiModGfLzs3sNR\\n\" +\n-            \"SFlGcR+1mwAAAYgHvZA9AAAEAwBHMEUCIQCmzmQOzunsuAg1GpIcNx0isG6ylbhP\\n\" +\n-            \"y9JP4UFclL2hdwIgBtTM89mE7QJDj7h7xr2eRPio1ehgmeYH1PHXxCqHIGYAdgBI\\n\" +\n-            \"sONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgHvZB1AAAEAwBHMEUC\\n\" +\n-            \"IF9hbi82CLU5umfRze4NpX6u4jlT+N8KSaBe6UbhqjBZAiEAi2Y6PTt2+107LxtM\\n\" +\n-            \"oBpHprph7hQvGfjPE+p+rfM\/X+EAdgDatr9rP7W2Ip+bwrtca+hwkXFsu1GEhTS9\\n\" +\n-            \"pD0wSNf7qwAAAYgHvZBeAAAEAwBHMEUCIAI+m4mVE3HtZOEMC5VI7m0nEPdPPJUq\\n\" +\n-            \"fxUKPpeIVmk5AiEA0scVJy7g3Fv+2nTVhbcwWCwn\/Gvc+0txQrc529juflcwCgYI\\n\" +\n-            \"KoZIzj0EAwMDaAAwZQIxAKV837BpqlNHg35EsCCtrJPoQ6RuY9UoHm1O2CdsCXGR\\n\" +\n-            \"Z3kAnlgIV8A\/waI6wQqfsQIwdCqaC+qN60JCnX09YKRD15eQjq1rN3w+llI+lEbS\\n\" +\n-            \"FSMsnoHJcqMZLo9s+4Rf0zS3\\n\" +\n+            \"MIIC0TCCAlegAwIBAgITB1pd3BpOpaGBEEVIgyad+UCb9TAKBggqhkjOPQQDAzBG\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n+            \"Q0EgNEExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDIzMjlaFw0yMzAxMTcy\\n\" +\n+            \"MDIzMjlaMCUxIzAhBgNVBAMTGmdvb2Quc2NhNGEuYW1hem9udHJ1c3QuY29tMHYw\\n\" +\n+            \"EAYHKoZIzj0CAQYFK4EEACIDYgAE7VpccYyJsD19xB1owlNs9PGkXkjptJZK6eFY\\n\" +\n+            \"q9Tc+CZLaOAhi47uuWsPwyIYB3vEIUXoWWKTvgycHhsmVQDQ2hLYMS+h9tQgnqVN\\n\" +\n+            \"TDYpEnnBa6AUbTKXtJDLG+z+7Kd7o4IBJjCCASIwDgYDVR0PAQH\/BAQDAgeAMB0G\\n\" +\n+            \"A1UdDgQWBBRHzxN3jV4vU1PEmHmTqB8YXXoMYDAfBgNVHSMEGDAWgBSlIc3b61Mh\\n\" +\n+            \"marK2WdClCWye\/TC4zAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYI\\n\" +\n+            \"KwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2E0YS5hbWF6\\n\" +\n+            \"b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhNGEuYW1hem9u\\n\" +\n+            \"dHJ1c3QuY29tL3NjYTRhLmNlcjAlBgNVHREEHjAcghpnb29kLnNjYTRhLmFtYXpv\\n\" +\n+            \"bnRydXN0LmNvbTATBgNVHSAEDDAKMAgGBmeBDAECATAKBggqhkjOPQQDAwNoADBl\\n\" +\n+            \"AjEAyHMRGLsUVEufoih22dPfO5LrLpO4\/2VzeNBbUvP\/mOcwvMrrq1yQjot3CTdm\\n\" +\n+            \"ZwnRAjAj2zmAM5asBZwuEN1pbEFgHdojio0O4oYvUsdMooLOKJsBD7hmgAdhpObO\\n\" +\n+            \"Xv0oNIE=\\n\" +\n@@ -569,4 +460,4 @@\n-    \/\/ Owner: CN=revoked.rootca4.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n-    \/\/ Serial number: 4a5d392936b4decb818b7fb106ebbd8\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=revoked.sca4a.amazontrust.com\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n+    \/\/ Serial number: 75a5e0442d0fed2b11850ed6746a2200bb4af\n+    \/\/ Valid from: Fri Dec 17 12:32:23 PST 2021 until: Tue Jan 17 12:32:23 PST 2023\n@@ -574,26 +465,16 @@\n-            \"MIIExjCCBEygAwIBAgIQBKXTkpNrTey4GLf7EG672DAKBggqhkjOPQQDAzA9MQsw\\n\" +\n-            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n-            \"U0EgMzg0IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC8xLTAr\\n\" +\n-            \"BgNVBAMTJHJldm9rZWQucm9vdGNhNC5kZW1vLmFtYXpvbnRydXN0LmNvbTB2MBAG\\n\" +\n-            \"ByqGSM49AgEGBSuBBAAiA2IABFYfMbv5\/vgqDunZj4ffJiuELtdwfEPXx9QlZnCm\\n\" +\n-            \"rBP3Z4\/GvUVRVmyh5sYdnbCGCEClH\/RxU6BC5SKv+TzhsFLEumhezanljnQXRAIL\\n\" +\n-            \"a1OGbP8zLLP6FuAD0cjY3P3adKOCAx0wggMZMB8GA1UdIwQYMBaAFKbZqzuHmTP\/\\n\" +\n-            \"6Gj4i2GDbNCyuq+9MB0GA1UdDgQWBBSqnGV5pN\/agPCtVdV37CP1z\/DUqjBOBgNV\\n\" +\n-            \"HREERzBFgiRyZXZva2VkLnJvb3RjYTQuZGVtby5hbWF6b250cnVzdC5jb22CHXJl\\n\" +\n-            \"dm9rZWQuc2NhNGEuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\/wQEAwIHgDAdBgNV\\n\" +\n-            \"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQwMjAwoC6gLIYqaHR0\\n\" +\n-            \"cDovL2NybC5lM20wMi5hbWF6b250cnVzdC5jb20vZTNtMDIuY3JsMBMGA1UdIAQM\\n\" +\n-            \"MAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDov\\n\" +\n-            \"L29jc3AuZTNtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n-            \"Y3J0LmUzbTAyLmFtYXpvbnRydXN0LmNvbS9lM20wMi5jZXIwDAYDVR0TAQH\/BAIw\\n\" +\n-            \"ADCCAX8GCisGAQQB1nkCBAIEggFvBIIBawFpAHYAdv+IPwq2+5VRwmHM9Ye6NLSk\\n\" +\n-            \"zbsp3GhCCp\/mZ0xaOnQAAAGIB72QJQAABAMARzBFAiA74zKrlL+y5rYwSLxBL8fs\\n\" +\n-            \"QYRYXF0s0sGoaSEeAg1DkgIhAPu8Z0TLIFoppmyiv+A5z6S+SG+v\/kOsAYmQmiUO\\n\" +\n-            \"5scIAHcASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/qznYhHMAAAGIB72QJgAA\\n\" +\n-            \"BAMASDBGAiEAg+x7JBT3oIaZdnfgGN1G6SAiNUL7zR\/tBhbWIG9tz94CIQDGwBiV\\n\" +\n-            \"Tslt11+W3ZaNsS7UtUIiB45YHUc4qKm5ry2fTAB2ANq2v2s\/tbYin5vCu1xr6HCR\\n\" +\n-            \"cWy7UYSFNL2kPTBI1\/urAAABiAe9kAgAAAQDAEcwRQIgPvKfSpMJKRocGk9+GNr3\\n\" +\n-            \"hUj8x8WySB\/\/0X116TNgA0gCIQDhGRqxnEZmEFGEfj5GY9vjEfm0kKwcL0lCuwBu\\n\" +\n-            \"NZG4dzAKBggqhkjOPQQDAwNoADBlAjEA1PLdsrko3tDs50aAeEU9Gn+0CG8QKy7R\\n\" +\n-            \"fQaXBTjGETDgGJk\/7zGNpGelKPr\/UYV9AjASwdA32S8jIADxA8HrqiMsVYDFMnbU\\n\" +\n-            \"jLLwR6CTLtAcWtwVmoQ2x0usvTvN8YJBPoA=\\n\" +\n+            \"MIIC1zCCAl2gAwIBAgITB1peBELQ\/tKxGFDtZ0aiIAu0rzAKBggqhkjOPQQDAzBG\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n+            \"Q0EgNEExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDMyMjNaFw0yMzAxMTcy\\n\" +\n+            \"MDMyMjNaMCgxJjAkBgNVBAMTHXJldm9rZWQuc2NhNGEuYW1hem9udHJ1c3QuY29t\\n\" +\n+            \"MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEqxQKCDKJYXzA0uR3jyfk\/ZRyPAJolRNI\\n\" +\n+            \"xI3+vlQW7SqVs+MziCLFPuU68kf74a5\/YFWK\/bRdXrVue4IMbM8TKO2FwXIHn\/Iw\\n\" +\n+            \"udkJIG+CdqnL4IlH+tFf+l47vRzMS0TQo4IBKTCCASUwDgYDVR0PAQH\/BAQDAgeA\\n\" +\n+            \"MB0GA1UdDgQWBBR04rEvUxTzLh0OGHyMgrYanP7lqzAfBgNVHSMEGDAWgBSlIc3b\\n\" +\n+            \"61MhmarK2WdClCWye\/TC4zAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIw\\n\" +\n+            \"dQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2E0YS5h\\n\" +\n+            \"bWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhNGEuYW1h\\n\" +\n+            \"em9udHJ1c3QuY29tL3NjYTRhLmNlcjAoBgNVHREEITAfgh1yZXZva2VkLnNjYTRh\\n\" +\n+            \"LmFtYXpvbnRydXN0LmNvbTATBgNVHSAEDDAKMAgGBmeBDAECATAKBggqhkjOPQQD\\n\" +\n+            \"AwNoADBlAjEAgOyeHMBYmO9rfMgCnV4oOQ5PcjSAgotYwEGqFHA5+TuIPBTcdFar\\n\" +\n+            \"J1j1JY+EirQ3AjAuGMJdyiQfAVi1n5wT1\/2nIOIEGtV2\/9CrNmhmjIzKrfu+HUUk\\n\" +\n+            \"bduxD7hNhott7NE=\\n\" +\n@@ -602,1 +483,8 @@\n-    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n+        \/\/ EE certificates don't have CRLDP extension\n+        if (!ocspEnabled){\n+            pathValidator.validate(new String[]{INT},\n+                    ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+            return;\n+        }\n@@ -611,1 +499,1 @@\n-                \"Mon May 15 13:42:48 PDT 2023\", System.out);\n+                \"Fri Dec 17 12:32:59 PST 2021\", System.out);\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/AmazonCA.java","additions":349,"deletions":461,"binary":false,"changes":810,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *      8305975 8304760 8307134 8295894\n+ *      8305975 8304760 8307134\n@@ -50,1 +50,1 @@\n-    private static final int COUNT = 96;\n+    private static final int COUNT = 97;\n@@ -55,1 +55,2 @@\n-            = \"9B:AF:A2:BD:88:C9:74:05:7F:DD:F3:97:85:21:18:4A:52:F0:07:CC:46:FD:2B:90:BA:FB:57:09:18:3B:66:0F\";\n+            = \"72:C7:B8:9E:54:94:D2:D9:C0:E5:9F:F7:C3:8C:3B:18:D7:42:23:82:51:F2:AD:A1:14:26:E0:4A:F2:5F:AE:80\";\n+\n@@ -163,0 +164,2 @@\n+            put(\"secomscrootca1 [jdk]\",\n+                    \"E7:5E:72:ED:9F:56:0E:EC:6E:B4:80:00:73:A4:3F:C3:AD:19:19:5A:39:22:82:01:78:95:97:4A:99:02:6B:6C\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom SpecTest\n+ * @run main SpecTest\n","filename":"test\/jdk\/sun\/security\/provider\/SecureRandom\/AbstractDrbg\/SpecTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-        for (int i = 0; i < bytes.length - greaseBytes.length + 1; i++) {\n+        for (int i = 0; i < bytes.length - greaseBytes.length; i++) {\n","filename":"test\/jdk\/sun\/security\/ssl\/ALPN\/AlpnGreaseTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8164879 8300285\n+ * @bug 8164879\n@@ -29,2 +29,1 @@\n- * @summary Verify AEAD TLS cipher suite limits set in the jdk.tls.keyLimits\n- * property\n+ * @summary Verify AES\/GCM's limits set in the jdk.tls.keyLimits property\n@@ -36,8 +35,2 @@\n- * @run main SSLEngineKeyLimit 0 server TLS_AES_256_GCM_SHA384\n- *      AES\/GCM\/NoPadding keyupdate 1050000\n- * @run main SSLEngineKeyLimit 1 client TLS_AES_256_GCM_SHA384\n- *      AES\/GCM\/NoPadding keyupdate 2^22\n- * @run main SSLEngineKeyLimit 0 server TLS_CHACHA20_POLY1305_SHA256\n- *      AES\/GCM\/NoPadding keyupdate 1050000, ChaCha20-Poly1305 KeyUpdate 1050000\n- * @run main SSLEngineKeyLimit 1 client TLS_CHACHA20_POLY1305_SHA256\n- *      AES\/GCM\/NoPadding keyupdate 2^22, ChaCha20-Poly1305 KeyUpdate 2^22\n+ * @run main SSLEngineKeyLimit 0 server AES\/GCM\/NoPadding keyupdate 1050000\n+ * @run main SSLEngineKeyLimit 1 client AES\/GCM\/NoPadding keyupdate 2^22\n@@ -96,1 +89,1 @@\n-     * args should have two values:  server|client, cipher suite, <limit size>\n+     * args should have two values:  server|client, <limit size>\n@@ -115,1 +108,1 @@\n-            for (int i = 3; i < args.length; i++) {\n+            for (int i = 2; i < args.length; i++) {\n@@ -130,2 +123,1 @@\n-                    Utils.addTestJavaOpts(\"SSLEngineKeyLimit\", \"p\", args[1],\n-                            args[2]));\n+                    Utils.addTestJavaOpts(\"SSLEngineKeyLimit\", \"p\", args[1]));\n@@ -135,2 +127,0 @@\n-                output.shouldContain(String.format(\n-                        \"\\\"cipher suite\\\"        : \\\"%s\", args[2]));\n@@ -184,2 +174,1 @@\n-        Thread ts = new Thread(serverwrite ? new Client() :\n-                new Server(args[2]));\n+        Thread ts = new Thread(serverwrite ? new Client() : new Server());\n@@ -187,1 +176,1 @@\n-        (serverwrite ? new Server(args[2]) : new Client()).run();\n+        (serverwrite ? new Server() : new Client()).run();\n@@ -431,1 +420,1 @@\n-        Server(String cipherSuite) throws Exception {\n+        Server() throws Exception {\n@@ -436,3 +425,0 @@\n-            if (cipherSuite != null && cipherSuite.length() > 0) {\n-                eng.setEnabledCipherSuites(new String[] { cipherSuite });\n-            }\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineKeyLimit.java","additions":11,"deletions":25,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8164879 8300285\n+ * @bug 8164879\n@@ -30,14 +30,4 @@\n- * @summary Verify AEAD TLS cipher suite limits set in the jdk.tls.keyLimits\n- * property\n- * @run main SSLSocketKeyLimit 0 server TLS_AES_256_GCM_SHA384\n- *      AES\/GCM\/NoPadding keyupdate 1000000\n- * @run main SSLSocketKeyLimit 0 client TLS_AES_256_GCM_SHA384\n- *      AES\/GCM\/NoPadding keyupdate 1000000\n- * @run main SSLSocketKeyLimit 1 client TLS_AES_256_GCM_SHA384\n- *      AES\/GCM\/NoPadding keyupdate 2^22\n- * @run main SSLSocketKeyLimit 0 server TLS_CHACHA20_POLY1305_SHA256\n- *      AES\/GCM\/NoPadding keyupdate 1000000, ChaCha20-Poly1305 KeyUpdate 1000000\n- * @run main SSLSocketKeyLimit 0 client TLS_CHACHA20_POLY1305_SHA256\n- *      AES\/GCM\/NoPadding keyupdate 1000000, ChaCha20-Poly1305 KeyUpdate 1000000\n- * @run main SSLSocketKeyLimit 1 client TLS_CHACHA20_POLY1305_SHA256\n- *      AES\/GCM\/NoPadding keyupdate 2^22, ChaCha20-Poly1305 KeyUpdate 2^22\n+ * @summary Verify AES\/GCM's limits set in the jdk.tls.keyLimits property\n+ * @run main SSLSocketKeyLimit 0 server AES\/GCM\/NoPadding keyupdate 1000000\n+ * @run main SSLSocketKeyLimit 0 client AES\/GCM\/NoPadding keyupdate 1000000\n+ * @run main SSLSocketKeyLimit 1 client AES\/GCM\/NoPadding keyupdate 2^22\n@@ -109,1 +99,1 @@\n-     * args should have three values:  server|client, cipher suite, <limit size>\n+     * args should have two values:  server|client, <limit size>\n@@ -123,1 +113,1 @@\n-            for (int i = 3; i < args.length; i++) {\n+            for (int i = 2; i < args.length; i++) {\n@@ -138,2 +128,1 @@\n-                    Utils.addTestJavaOpts(\"SSLSocketKeyLimit\", \"p\", args[1],\n-                            args[2]));\n+                    Utils.addTestJavaOpts(\"SSLSocketKeyLimit\", \"p\", args[1]));\n@@ -143,2 +132,0 @@\n-                output.shouldContain(String.format(\n-                        \"\\\"cipher suite\\\"        : \\\"%s\", args[2]));\n@@ -166,1 +153,1 @@\n-        if (args.length > 0 && args[1].compareToIgnoreCase(\"client\") == 0) {\n+        if (args.length > 0 && args[0].compareToIgnoreCase(\"client\") == 0) {\n@@ -178,1 +165,1 @@\n-        Thread ts = new Thread(new Server(args[2]));\n+        Thread ts = new Thread(new Server());\n@@ -216,2 +203,1 @@\n-            System.out.println(\"Server: connected \" +\n-                    s.getSession().getCipherSuite());\n+            System.out.println(\"Server: connected \" + s.getSession().getCipherSuite());\n@@ -229,2 +215,1 @@\n-                    System.out.println(\"\\nData invalid: \" +\n-                            HexPrinter.minimal().toString(buf));\n+                    System.out.println(\"\\nData invalid: \" + HexPrinter.minimal().toString(buf));\n@@ -255,1 +240,1 @@\n-        Server(String cipherSuite) {\n+        Server() {\n@@ -260,3 +245,0 @@\n-                if (cipherSuite != null && cipherSuite.length() > 0) {\n-                    ss.setEnabledCipherSuites(new String[] { cipherSuite });\n-                }\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketKeyLimit.java","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.*;\n+\n+\/*\n+ * Export a private key from the named keychain entry without supplying a\n+ * password. See JDK-8062264.\n+ *\n+ * NOTE: Keychain access controls must already have been lowered to permit\n+ *       the target entry to be accessed.\n+ *\/\n+public class ExportPrivateKeyNoPwd {\n+\n+    public static final void main(String[] args) throws Exception {\n+\n+        if (args.length != 1) {\n+            throw new Exception(\n+                \"ExportPrivateKeyNoPwd: must supply name of a keystore entry\");\n+        }\n+        String alias = args[0];\n+\n+        KeyStore ks = KeyStore.getInstance(\"KeychainStore\");\n+        System.out.println(\"ExportPrivateKeyNoPwd: loading keychains...\");\n+        ks.load(null, null);\n+\n+        System.out.println(\"ExportPrivateKeyNoPwd: exporting key...\");\n+        Key key = ks.getKey(alias, null);\n+        if (key instanceof PrivateKey) {\n+            System.out.println(\"ExportPrivateKeyNoPwd: exported \" +\n+                key.getAlgorithm() + \" private key from '\" + alias + \"'\");\n+        } else {\n+            throw new Exception(\"Error exporting private key from keychain\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ExportPrivateKeyNoPwd.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -1,202 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 7133495 8062264 8046777 8153005\n- * @summary KeyChain KeyStore implementation retrieves only one private key entry\n- * @requires (os.family == \"mac\")\n- * @library \/test\/lib\n- * @run main\/othervm\/manual ListKeyChainStore\n- *\/\n-\n-import jdk.test.lib.SecurityTools;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.io.*;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.security.Key;\n-import java.security.KeyStore;\n-import java.security.PrivateKey;\n-\n-public class ListKeyChainStore {\n-    private static final String PWD = \"xxxxxx\";\n-    private static final String DEFAULT_KEYTOOL = \"-list -storetype KeychainStore \" +\n-            \"-keystore NONE -storepass \" + PWD;\n-    private static final String USER_DIR = System.getProperty(\"user.dir\", \".\");\n-    private static final String FS = System.getProperty(\"file.separator\");\n-    private static final String PKCS12_KEYSTORE = USER_DIR + FS + \"7133495.p12\";\n-    private static final String KEYCHAIN_FILE = USER_DIR + FS + \"7133495.keychain\";\n-    private static final String TEMPORARY_FILE = USER_DIR + FS + \"7133495.tmp\";\n-    private static final String USER_KEYCHAIN_LIST = USER_DIR + FS + \"user.keychain.list\";\n-    private static final String PRIVATE_KEY_ENTRY = \"PrivateKeyEntry\";\n-\n-    public static void main(String[] args) throws Throwable {\n-        LOG_MSG(\"WARNING: This test doesn't work on macOS virtualized environment. \" +\n-                \"`security list-keychains -s` doesn't update the search order.\");\n-\n-        deleteTestTempFilesIfExists();\n-\n-        \/\/ Get the old security keychain list to restore later\n-        try (PrintStream printStream = new PrintStream(USER_KEYCHAIN_LIST)) {\n-            ProcessTools.executeCommand(\"sh\", \"-c\", \"security list-keychains\")\n-                    .shouldHaveExitValue(0).outputTo(printStream);\n-        }\n-\n-        try {\n-            try (PrintStream printStream = new PrintStream(TEMPORARY_FILE)) {\n-                SecurityTools.keytool(DEFAULT_KEYTOOL).shouldHaveExitValue(0)\n-                        .outputTo(printStream);\n-            }\n-            int oldPrivateKeyCount = countOccurrences(TEMPORARY_FILE, PRIVATE_KEY_ENTRY);\n-            LOG_MSG(\"Found \" + oldPrivateKeyCount + \" private key entries in the \" +\n-                    \"Keychain keystore\");\n-\n-            \/\/ Create the PKCS12 keystore containing 3 public\/private key pairs\n-            LOG_MSG(\"Creating PKCS12 keystore: \" + PKCS12_KEYSTORE);\n-            for (int i = 0; i < 3; i++) {\n-                \/\/ Use legacy encryption and MAC algorithms, refer macOS open radar FB8988319\n-                \/\/ macOS security framework doesn't work with the latest algorithms\n-                SecurityTools.keytool(String.format(\"-J-Dkeystore.pkcs12.legacy -genkeypair\" +\n-                                \" -storetype PKCS12 -keystore %s -storepass %s -keyalg rsa  -dname \" +\n-                                \"CN=CN%d,OU=OU%d,O=O%d,ST=ST%d,C=US -alias 7133495-%d\",\n-                        PKCS12_KEYSTORE, PWD, i, i, i, i, i)).shouldHaveExitValue(0);\n-            }\n-\n-            \/\/ Create the keychain\n-            LOG_MSG(\"Creating keychain: \" + KEYCHAIN_FILE);\n-            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security create-keychain\" +\n-                    \" -p %s %s\", PWD, KEYCHAIN_FILE)).shouldHaveExitValue(0);\n-\n-            \/\/ Unlock the keychain\n-            LOG_MSG(\"Unlock keychain: \" + KEYCHAIN_FILE);\n-            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security unlock-keychain\" +\n-                    \" -p %s %s\", PWD, KEYCHAIN_FILE)).shouldHaveExitValue(0);\n-\n-            \/\/ Import the key pairs from the PKCS12 keystore into the keychain\n-            \/\/ The '-A' option is used to lower the keychain's access controls\n-            LOG_MSG(\"Importing the key pairs from \" + PKCS12_KEYSTORE\n-                    + \" to \" + KEYCHAIN_FILE);\n-            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security import %s -k %s\" +\n-                    \" -f pkcs12 -P %s -A\", PKCS12_KEYSTORE, KEYCHAIN_FILE, PWD)).shouldHaveExitValue(0);\n-\n-            \/\/ Generate a 2048-bit RSA keypair and import into the keychain\n-            \/\/ Its private key is configured with non-default key usage settings\n-            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"certtool ca k=%s \" +\n-                    \"<<EOF\\n\" +\n-                    \"test\\n\" +\n-                    \"r\\n\" +\n-                    \"2048\\n\" +\n-                    \"y\\n\" +\n-                    \"b\\n\" +\n-                    \"s\\n\" +\n-                    \"y\\n\" +\n-                    \"A\\n\" +\n-                    \"US\\n\" +\n-                    \"A\\n\" +\n-                    \"A\\n\" +\n-                    \"\\n\" +\n-                    \"\\n\" +\n-                    \"y\\n\" +\n-                    \"EOF\", KEYCHAIN_FILE)).shouldHaveExitValue(0);\n-\n-            \/\/ Adjust the keychain search order to add KEYCHAIN_FILE to top\n-            try (PrintStream printStream = new PrintStream(TEMPORARY_FILE)) {\n-                printStream.println(\"\\\"\" + KEYCHAIN_FILE + \"\\\"\");\n-                printStream.println(ProcessTools.executeCommand(\"sh\", \"-c\", \"security list-keychains\")\n-                        .shouldHaveExitValue(0).getOutput());\n-            }\n-            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security list-keychains -s %s\",\n-                    ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"xargs < %s\",\n-                            TEMPORARY_FILE)).getOutput()));\n-            LOG_MSG(\"Keychain search order:\");\n-            ProcessTools.executeCommand(\"sh\", \"-c\", \"security list-keychains\");\n-\n-            \/\/ Recount the number of private key entries in the Keychain keystore\n-            \/\/ 3 private keys imported from PKCS12, 1 private key generated by 'certtool'\n-            Files.deleteIfExists(Paths.get(TEMPORARY_FILE));\n-            try (PrintStream printStream = new PrintStream(TEMPORARY_FILE)) {\n-                SecurityTools.keytool(DEFAULT_KEYTOOL).shouldHaveExitValue(0)\n-                        .outputTo(printStream);\n-            }\n-            int newPrivateKeyCount = countOccurrences(TEMPORARY_FILE, PRIVATE_KEY_ENTRY);\n-            LOG_MSG(\"Found \" + newPrivateKeyCount + \" private key entries in \" +\n-                    \"the Keychain keystore\");\n-            if (newPrivateKeyCount < (oldPrivateKeyCount + 4)) {\n-                throw new RuntimeException(\"Error: expected more private key entries in the \" +\n-                        \"Keychain keystore\");\n-            }\n-\n-            \/\/ Export a private key from the keychain (without supplying a password)\n-            \/\/ Access controls have already been lowered (see 'security import ... -A' above)\n-            LOG_MSG(\"Exporting a private key from the keychain\");\n-            KeyStore ks = KeyStore.getInstance(\"KeychainStore\");\n-            ks.load(null, null);\n-            Key key = ks.getKey(\"CN0\", null);\n-            if (key instanceof PrivateKey) {\n-                LOG_MSG(\"Exported \" + key.getAlgorithm() + \" private key from CN0\");\n-            } else {\n-                throw new RuntimeException(\"Error exporting private key from keychain\");\n-            }\n-        } finally {\n-            \/\/ Reset earlier keychain list\n-            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security list-keychains -s %s\",\n-                    ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"xargs < %s\",\n-                            USER_KEYCHAIN_LIST)).getOutput()));\n-\n-            deleteTestTempFilesIfExists();\n-        }\n-    }\n-\n-    private static void deleteTestTempFilesIfExists() throws Throwable {\n-        Files.deleteIfExists(Paths.get(USER_KEYCHAIN_LIST));\n-        Files.deleteIfExists(Paths.get(PKCS12_KEYSTORE));\n-        if (Files.exists(Paths.get(KEYCHAIN_FILE))) {\n-            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security delete-keychain\" +\n-                    \" %s\", KEYCHAIN_FILE)).shouldHaveExitValue(0);\n-        }\n-        Files.deleteIfExists(Paths.get(TEMPORARY_FILE));\n-    }\n-\n-    private static int countOccurrences(String filePath, String word) throws IOException {\n-        int count = 0;\n-        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n-            String line;\n-            while ((line = reader.readLine()) != null) {\n-                if (line.contains(word)) {\n-                    count++;\n-                }\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private static void LOG_MSG(String msg) {\n-        \/\/ ProcessTools and SecurityTools log a lot of messages so pretty format\n-        \/\/ messages logged from this test\n-        System.out.println();\n-        System.out.println(\"==> \" + msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ListKeyChainStore.java","additions":0,"deletions":202,"binary":false,"changes":202,"status":"deleted"},{"patch":"@@ -0,0 +1,188 @@\n+#\n+# Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# @test\n+# @bug 7133495 8041740 8062264 8046777\n+# @summary [macosx] KeyChain KeyStore implementation retrieves only one private key entry\n+\n+if [ \"${TESTJAVA}\" = \"\" ] ; then\n+    JAVAC_CMD=`which javac`\n+    TESTJAVA=`dirname $JAVAC_CMD`\/..\n+fi\n+\n+if [ \"${TESTSRC}\" = \"\" ] ; then\n+    TESTSRC=\".\"\n+fi\n+if [ \"${TESTCLASSES}\" = \"\" ] ; then\n+    TESTCLASSES=`pwd`\n+fi\n+\n+# Only run on MacOS\n+OS=`uname -s`\n+case \"$OS\" in\n+    Darwin )\n+        ;;\n+    * )\n+        echo \"Will not run test on: ${OS}\"\n+        exit 0;\n+        ;;\n+esac\n+\n+PWD=\"xxxxxx\"\n+KEYTOOL=\"${TESTJAVA}\/bin\/keytool ${TESTTOOLVMOPTS} -storetype KeychainStore -keystore NONE -storepass $PWD\"\n+TEMPORARY_P12=\"$TESTCLASSES\/7133495.p12\"\n+TEMPORARY_KC=\"$TESTCLASSES\/7133495.keychain\"\n+TEMPORARY_LIST=\"$TESTCLASSES\/7133495.tmp\"\n+CLEANUP_P12=\"rm -f $TEMPORARY_P12\"\n+CLEANUP_KC=\"security delete-keychain $TEMPORARY_KC\"\n+CLEANUP_LIST=\"rm -f $TEMPORARY_LIST\"\n+\n+# Count the number of private key entries in the Keychain keystores\n+\n+COUNT=`$KEYTOOL -list | grep PrivateKeyEntry | wc -l`\n+echo \"Found $COUNT private key entries in the Keychain keystores\"\n+\n+# Create a temporary PKCS12 keystore containing 3 public\/private keypairs\n+\n+RESULT=`$CLEANUP_P12`\n+\n+for i in X Y Z\n+do\n+    ${TESTJAVA}\/bin\/keytool ${TESTTOOLVMOPTS} -genkeypair \\\n+        -storetype PKCS12 \\\n+        -keystore $TEMPORARY_P12 \\\n+        -storepass $PWD \\\n+        -keyalg rsa \\\n+        -dname \"CN=$i,OU=$i,O=$i,ST=$i,C=US\" \\\n+        -alias 7133495-$i\n+\n+    if [ $? -ne 0 ]; then\n+        echo \"Error: cannot create keypair $i in the temporary PKCS12 keystore\"\n+        RESULT=`$CLEANUP_P12`\n+        exit 1\n+    fi\n+done\n+echo \"Created a temporary PKCS12 keystore: $TEMPORARY_P12\"\n+\n+# Create a temporary keychain\n+\n+security create-keychain -p $PWD $TEMPORARY_KC\n+if [ $? -ne 0 ]; then\n+    echo \"Error: cannot create the temporary keychain\"\n+    RESULT=`$CLEANUP_P12`\n+    exit 2\n+fi\n+echo \"Created a temporary keychain: $TEMPORARY_KC\"\n+\n+# Unlock the temporary keychain\n+\n+security unlock-keychain -p $PWD $TEMPORARY_KC\n+if [ $? -ne 0 ]; then\n+    echo \"Error: cannot unlock the temporary keychain\"\n+    RESULT=`$CLEANUP_P12`\n+    RESULT=`$CLEANUP_KC`\n+    exit 3\n+fi\n+echo \"Unlocked the temporary keychain\"\n+\n+# Import the keypairs from the PKCS12 keystore into the keychain\n+# (The '-A' option is used to lower the temporary keychain's access controls)\n+\n+security import $TEMPORARY_P12 -k $TEMPORARY_KC -f pkcs12 -P $PWD -A\n+if [ $? -ne 0 ]; then\n+    echo \"Error: cannot import keypairs from PKCS12 keystore into the keychain\"\n+    RESULT=`$CLEANUP_P12`\n+    RESULT=`$CLEANUP_KC`\n+    exit 4\n+fi\n+echo \"Imported keypairs from PKCS12 keystore into the keychain\"\n+\n+# Generate a 2048-bit RSA keypair and import into the temporary keychain\n+# (its private key is configured with non-default key usage settings)\n+\n+certtool c k=$TEMPORARY_KC <<EOF\n+test\n+r\n+2048\n+y\n+b\n+s\n+y\n+A\n+US\n+A\n+A\n+\n+\n+y\n+EOF\n+\n+# Adjust the keychain search order\n+\n+echo \"\\\"$TEMPORARY_KC\\\"\" > $TEMPORARY_LIST\n+security list-keychains >> $TEMPORARY_LIST\n+security list-keychains -s `xargs < ${TEMPORARY_LIST}`\n+`$CLEANUP_LIST`\n+echo \"Temporary keychain search order:\"\n+security list-keychains\n+\n+# Recount the number of private key entries in the Keychain keystores\n+# (3 private keys imported from PKCS12, 1 private key generated by 'certtool')\n+\n+RECOUNT=`$KEYTOOL -list | grep PrivateKeyEntry | wc -l`\n+echo \"Found $RECOUNT private key entries in the Keychain keystore\"\n+if [ $RECOUNT -lt `expr $COUNT + 4` ]; then\n+    echo \"Error: expected >$COUNT private key entries in the Keychain keystores\"\n+    RESULT=`$CLEANUP_P12`\n+    RESULT=`$CLEANUP_KC`\n+    exit 5\n+fi\n+\n+# Export a private key from the keychain (without supplying a password)\n+# Access controls have already been lowered (see 'security import ... -A' above)\n+\n+${TESTJAVA}\/bin\/javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d . ${TESTSRC}\/ExportPrivateKeyNoPwd.java || exit 6\n+${TESTJAVA}\/bin\/java ${TESTVMOPTS} ExportPrivateKeyNoPwd x\n+if [ $? -ne 0 ]; then\n+    echo \"Error exporting private key from the temporary keychain\"\n+    RESULT=`$CLEANUP_P12`\n+    RESULT=`$CLEANUP_KC`\n+    exit 6\n+fi\n+echo \"Exported a private key from the temporary keychain\"\n+\n+RESULT=`$CLEANUP_P12`\n+if [ $? -ne 0 ]; then\n+    echo \"Error: cannot remove the temporary PKCS12 keystore\"\n+    exit 7\n+fi\n+echo \"Removed the temporary PKCS12 keystore\"\n+\n+RESULT=`$CLEANUP_KC`\n+if [ $? -ne 0 ]; then\n+    echo \"Error: cannot remove the temporary keychain\"\n+    exit 8\n+fi\n+echo \"Removed the temporary keychain\"\n+\n+exit 0\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ListKeychainStore.sh","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8228969 8244087 8255266 8302182\n+ * @bug 8228969 8244087 8255266\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/ParseNames.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,4 +87,0 @@\n-# in\n-5g.in                   5g.in           null\n-www.5g.in               5g.in           www.5g.in\n-\n@@ -160,4 +156,0 @@\n-# Microsoft\n-1.azurestaticapps.net         1.azurestaticapps.net       null\n-app.1.azurestaticapps.net     1.azurestaticapps.net       app.1.azurestaticapps.net\n-\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/tests.dat","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import java.util.HexFormat;\n-import java.nio.charset.StandardCharsets;\n@@ -71,7 +69,7 @@\n-        execTest(\"\\\"\" + unicodeStr + \"a\" + unicodeStr + \"\\\"\", hexValue + \"0061\" + hexValue);\n-        execTest(\"\\\\\" + unicodeStr + \"a\" + unicodeStr + \"\\\\\", hexValue + \"0061\" + hexValue);\n-        execTest(\" \" + unicodeStr + \"a\" + unicodeStr + \" \", hexValue + \"0061\"+ hexValue);\n-        execTest(\"'\" + unicodeStr + \"a\" + unicodeStr + \"'\", hexValue + \"0061\"+ hexValue);\n-        execTest(\"\\t\" + unicodeStr + \"a\" + unicodeStr + \"\\t\", hexValue + \"0061\"+ hexValue);\n-        execTest(\"*\" + unicodeStr + \"a\" + unicodeStr + \"*\", hexValue + \"0061\"+ hexValue);\n-        execTest(\"?\" + unicodeStr + \"a\" + unicodeStr + \"?\", hexValue + \"0061\"+ hexValue);\n+        execTest(\"\\\"\" + unicodeStr + \"a\" + unicodeStr + \"\\\"\", hexValue + \"61\" + hexValue);\n+        execTest(\"\\\\\" + unicodeStr + \"a\" + unicodeStr + \"\\\\\", hexValue + \"61\" + hexValue);\n+        execTest(\" \" + unicodeStr + \"a\" + unicodeStr + \" \", hexValue + \"61\"+ hexValue);\n+        execTest(\"'\" + unicodeStr + \"a\" + unicodeStr + \"'\", hexValue + \"61\"+ hexValue);\n+        execTest(\"\\t\" + unicodeStr + \"a\" + unicodeStr + \"\\t\", hexValue + \"61\"+ hexValue);\n+        execTest(\"*\" + unicodeStr + \"a\" + unicodeStr + \"*\", hexValue + \"61\"+ hexValue);\n+        execTest(\"?\" + unicodeStr + \"a\" + unicodeStr + \"?\", hexValue + \"61\"+ hexValue);\n@@ -79,7 +77,7 @@\n-        execTest(\"\\\"\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\\"\", hexValue + \"00b1\" + hexValue);\n-        execTest(\"\\\\\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\\\\", hexValue + \"00b1\" + hexValue);\n-        execTest(\" \" + unicodeStr + \"\\u00b1\" + unicodeStr + \" \", hexValue + \"00b1\"+ hexValue);\n-        execTest(\"'\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"'\", hexValue + \"00b1\"+ hexValue);\n-        execTest(\"\\t\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\t\", hexValue + \"00b1\"+ hexValue);\n-        execTest(\"*\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"*\", hexValue + \"00b1\"+ hexValue);\n-        execTest(\"?\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"?\", hexValue + \"00b1\"+ hexValue);\n+        execTest(\"\\\"\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\\"\", hexValue + \"b1\" + hexValue);\n+        execTest(\"\\\\\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\\\\", hexValue + \"b1\" + hexValue);\n+        execTest(\" \" + unicodeStr + \"\\u00b1\" + unicodeStr + \" \", hexValue + \"b1\"+ hexValue);\n+        execTest(\"'\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"'\", hexValue + \"b1\"+ hexValue);\n+        execTest(\"\\t\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\t\", hexValue + \"b1\"+ hexValue);\n+        execTest(\"*\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"*\", hexValue + \"b1\"+ hexValue);\n+        execTest(\"?\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"?\", hexValue + \"b1\"+ hexValue);\n@@ -102,15 +100,6 @@\n-        String sysPropName = \"foo.bar\";\n-        \/\/ When pass \"-Dfoo.bar=<unicodestr>\" via the JDK_JAVA_OPTIONS environment variable,\n-        \/\/ we expect that system property value to be passed along to the main method with the\n-        \/\/ correct encoding\n-        \/\/ If <unicodestr> contains space or tab, it should be enclosed with double quotes.\n-        if (unicodeStr.contains(\" \") || unicodeStr.contains(\"\\t\")) {\n-            unicodeStr = \"\\\"\" + unicodeStr + \"\\\"\";\n-        }\n-        String jdkJavaOpts = \"-D\" + sysPropName + \"=\" + unicodeStr;\n-        env.put(\"JDK_JAVA_OPTIONS\", jdkJavaOpts);\n-        tr = doExec(env,javaCmd,\n-                \"-Dtest.src=\" + TEST_SOURCES_DIR.getAbsolutePath(),\n-                \"-Dtest.classes=\" + TEST_CLASSES_DIR.getAbsolutePath(),\n-                \"-cp\", TEST_CLASSES_DIR.getAbsolutePath(),\n-                \"I18NArgTest\", unicodeStr, hexValue, sysPropName);\n+        String cmd = \"-Dtest.src=\" + TEST_SOURCES_DIR.getAbsolutePath() +\n+                \" -Dtest.classes=\" + TEST_CLASSES_DIR.getAbsolutePath() +\n+                \" -cp \" + TEST_CLASSES_DIR.getAbsolutePath() +\n+                \" I18NArgTest \" + unicodeStr + \" \" + hexValue;\n+        env.put(\"JDK_JAVA_OPTIONS\", cmd);\n+        tr = doExec(env, javaCmd);\n@@ -127,1 +116,4 @@\n-        var hexValue = HexFormat.of().formatHex(input.getBytes(StandardCharsets.UTF_16));\n+        String hexValue = \"\";\n+        for (int i = 0; i < input.length(); i++) {\n+            hexValue = hexValue.concat(Integer.toHexString((int)input.charAt(i)));\n+        }\n@@ -136,15 +128,0 @@\n-        if (args.length == 3) {\n-            \/\/ verify the value of the system property matches the expected value\n-            String sysPropName = args[2];\n-            String sysPropVal = System.getProperty(sysPropName);\n-            if (sysPropVal == null) {\n-                throw new RuntimeException(\"Missing system property \" + sysPropName);\n-            }\n-            var sysPropHexVal = HexFormat.of().formatHex(sysPropVal.getBytes(StandardCharsets.UTF_16));\n-            System.out.println(\"System property \" + sysPropName + \" computed hex value: \"\n-                    + sysPropHexVal);\n-            if (!sysPropHexVal.contains(expected)) {\n-                throw new RuntimeException(\"Unexpected value in system property, expected \"\n-                        + expected + \", but got \" + sysPropHexVal);\n-            }\n-        }\n","filename":"test\/jdk\/tools\/launcher\/I18NArgTest.java","additions":25,"deletions":48,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+tools\/javap\/T6587786.java                                                       8195589    generic-all    T6587786.java failed after JDK-8189997\n","filename":"test\/langtools\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8293177\n- * @summary Verify version numbers in legal files\n- * @library \/test\/lib\n- * @build jtreg.SkippedException\n- * @run main CheckLibraryVersions\n- *\/\n-\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n-\n-import jtreg.SkippedException;\n-\n-\/**\n- * Checks the names and version strings of 3rd party libraries in legal files\n- * against the actual names and versions in library files.\n- *\/\n-public class CheckLibraryVersions {\n-    static class SourceDirNotFound extends Error {}\n-    \/\/ Regex pattern for library name and version in legal Markdown file\n-    static final Pattern versionPattern = Pattern.compile(\"## ([\\\\w\\\\s]+) v(\\\\d+\\\\.\\\\d+\\\\.\\\\d+)\");\n-\n-    \/\/ Map of 3rd party libraries. The keys are the names of files in the legal directory,\n-    \/\/ the values are lists of templates for library files with the following placeholders:\n-    \/\/  %V is replaced with the version string\n-    \/\/  %M is replaced twice, once with an empty string and once with \".min\"\n-    static final Map<String, List<String>> libraries = Map.of(\n-            \"jquery.md\", List.of(\"jquery-%V%M.js\"),\n-            \"jqueryUI.md\", List.of(\"jquery-ui%M.js\", \"jquery-ui%M.css\")\n-    );\n-\n-    public static void main(String... args) throws Exception {\n-        try {\n-            new CheckLibraryVersions().run(args);\n-        } catch (SourceDirNotFound e) {\n-            throw new SkippedException(\"NOTE: Cannot find src directory; test skipped\");\n-        }\n-    }\n-\n-    static final PrintStream out = System.err;\n-\n-    void run(String... args) throws Exception {\n-        var rootDir = args.length == 0 ? findRootDir() : Path.of(args[0]);\n-        var legalDir = rootDir.resolve(\"src\/jdk.javadoc\/share\/legal\");\n-        var scriptDir = rootDir.resolve(\"src\/jdk.javadoc\/share\/classes\")\n-                                     .resolve(\"jdk\/javadoc\/internal\/doclets\/formats\/html\")\n-                                     .resolve(\"resources\/script-dir\");\n-\n-        for (var legalFileName : libraries.keySet()) {\n-            var legalFile = legalDir.resolve(legalFileName);\n-            out.println();\n-            if (!Files.exists(legalFile)) {\n-                error(\"Legal file not found: \" + legalFile);\n-                continue;\n-            }\n-            out.println(\"Checking legal file: \" + legalFile);\n-            var contents = Files.readString(legalFile);\n-            var matcher = versionPattern.matcher(contents);\n-            if (!matcher.find()) {\n-                error(\"Library name and version not found in \" + legalFile);\n-                continue;\n-            }\n-            var libraryName = matcher.group(1);\n-            var versionString = matcher.group(2);\n-            out.println(\"Found name and version: \" + matcher.group(1) + \" \" + matcher.group(2));\n-            var templates = libraries.get(legalFileName);\n-            for (var template : templates) {\n-                checkLibraryFile(scriptDir, template, libraryName, versionString, \"\");\n-                if (template.contains(\"%M\")) {\n-                    checkLibraryFile(scriptDir, template, libraryName, versionString, \".min\");\n-                }\n-            }\n-        }\n-\n-        if (errors > 0) {\n-            out.println(errors + \" errors found\");\n-            throw new Exception(errors + \" errors found\");\n-        }\n-    }\n-\n-    void checkLibraryFile(Path scriptDir, String template, String libraryName,\n-                          String versionString, String minified) throws IOException {\n-        out.println();\n-        var libraryFileName = template\n-                .replaceAll(\"%V\", versionString)\n-                .replaceAll(\"%M\", minified);\n-        var libraryFile = scriptDir.resolve(libraryFileName);\n-        if (!Files.exists(libraryFile)) {\n-            error(\"Library file not found: \" + libraryFile);\n-            return;\n-        }\n-        out.println(\"Checking library file: \" + libraryFile);\n-        var libraryContents = Files.readString(libraryFile);\n-        var pattern = Pattern.compile(\"\\\\b\" + libraryName + \"[^\\\\n]* v\" + versionString + \"\\\\b\");\n-        var matcher = pattern.matcher(libraryContents);\n-        if (!matcher.find()) {\n-            error(\"Matching library name and version not found in \" + libraryFileName);\n-            return;\n-        }\n-        out.println(\"Found matching name and version: \" + matcher.group());\n-    }\n-\n-    int errors = 0;\n-    void error(String message) {\n-        (\"Error: \" + message).lines().forEach(out::println);\n-        errors++;\n-    }\n-\n-    Path findRootDir() {\n-        Path dir = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n-        while (dir != null) {\n-            if (Files.exists(dir.resolve(\"src\").resolve(\"jdk.javadoc\"))) {\n-                return dir;\n-            } else {\n-                Path openDir = dir.resolve(\"open\");\n-                if (Files.exists(openDir.resolve(\"src\").resolve(\"jdk.javadoc\"))) {\n-                    return openDir;\n-                }\n-            }\n-            dir = dir.getParent();\n-        }\n-        throw new SourceDirNotFound();\n-    }\n-}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/checkLibraryVersions\/CheckLibraryVersions.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -39,2 +39,2 @@\n-        javap(\"jdk.javadoc.doclet.Doclet\", \"java.util.List\");\n-        javap(\"java.util.List\", \"jdk.javadoc.doclet.StandardDoclet\");\n+        javap(\"com.sun.javadoc.Doc\", \"com.sun.crypto.provider.ai\");\n+        javap(\"com.sun.crypto.provider.ai\", \"com.sun.javadoc.ClassDoc\");\n@@ -47,8 +47,5 @@\n-        try {\n-            int rc = com.sun.tools.javap.Main.run(args, out);\n-            if (rc != 0)\n-                throw new Error(\"javap failed. rc=\" + rc);\n-        } finally {\n-            out.close();\n-            System.out.println(sw.toString());\n-        }\n+        int rc = com.sun.tools.javap.Main.run(args, out);\n+        if (rc != 0)\n+            throw new Error(\"javap failed. rc=\" + rc);\n+        out.close();\n+        System.out.println(sw.toString());\n","filename":"test\/langtools\/tools\/javap\/T6587786.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=without-inner-class\n+ * @summary verify that sun.hotspot.WhiteBox class still can be used\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI OldWhiteBox\n+ *\/\n+\n+\/*\n+ * @test id=with-inner-class\n+ * @summary verify that sun.hotspot.WhiteBox class still can be used\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI OldWhiteBox\n+ *\/\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class OldWhiteBox {\n+    public static void main(String[] args) {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        if (wb.getHeapOopSize() < 0) {\n+            throw new Error(\"wb.getHeapOopSize() < 0\");\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/OldWhiteBox.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -503,2 +503,0 @@\n-        } else if (Platform.isZero()) {\n-            return \"-zero\";\n","filename":"test\/lib\/jdk\/test\/lib\/cli\/CommandLineOptionTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import sun.hotspot.cpuinfo.CPUInfo;\n","filename":"test\/lib\/jdk\/test\/lib\/cli\/predicate\/CPUSpecificPredicate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,1 +205,3 @@\n-        List<String> cmd = buildContainerCommand();\n+        List<String> cmd = new ArrayList<>();\n+\n+        cmd.add(Container.ENGINE_COMMAND);\n@@ -228,6 +230,0 @@\n-    public static List<String> buildContainerCommand() {\n-        List<String> cmd = new ArrayList<>();\n-        cmd.add(Container.ENGINE_COMMAND);\n-        return cmd;\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerTestUtils.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -105,2 +105,2 @@\n-    \/\/ we support only jdk.test.whitebox.WhiteBox$WhiteBoxPermission.\n-    \/\/ See JDK-8199290\n+    \/\/ we support only jdk.test.whitebox.WhiteBox$WhiteBoxPermission and\n+    \/\/ jdk\/test\/whitebox\/WhiteBox$WhiteBoxPermission. See JDK-8199290\n@@ -110,0 +110,2 @@\n+        boolean seenOldWb = false;\n+        boolean seenOldWbInner = false;\n@@ -112,0 +114,2 @@\n+        final String oldWb = \"sun.hotspot.WhiteBox\";\n+        final String oldWbInner = oldWb + \"$WhiteBoxPermission\";\n@@ -121,0 +125,2 @@\n+            case oldWb:      seenOldWb      = true; break;\n+            case oldWbInner: seenOldWbInner = true; break;\n@@ -126,0 +132,4 @@\n+        if (seenOldWb && !seenOldWbInner) {\n+            list.add(oldWbInner);\n+        }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/helpers\/ClassFileInstaller.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package jdk.test.whitebox;\n+package sun.hotspot;\n@@ -37,0 +37,1 @@\n+@Deprecated\n@@ -61,1 +62,1 @@\n-      sm.checkPermission(new WhiteBoxPermission(\"getInstance\"));\n+      throw new SecurityException(\"can't use old whitebox with SecurityManager, please switch to jdk.test.whitebox.WhiteBox\");\n@@ -312,1 +313,1 @@\n-    return getMethodCompilationLevel(method, false \/*not ost*\/);\n+    return getMethodCompilationLevel(method, false \/*not osr*\/);\n@@ -417,1 +418,1 @@\n-  \/\/ Use jdk.test.whitebox.gc.GC class instead.\n+  \/\/ Use sun.hotspot.gc.GC class instead.\n@@ -460,6 +461,0 @@\n-  \/\/ G1 specific GC breakpoints.\n-  public final String G1_AFTER_REBUILD_STARTED = \"AFTER REBUILD STARTED\";\n-  public final String G1_BEFORE_REBUILD_COMPLETED = \"BEFORE REBUILD COMPLETED\";\n-  public final String G1_AFTER_CLEANUP_STARTED = \"AFTER CLEANUP STARTED\";\n-  public final String G1_BEFORE_CLEANUP_COMPLETED = \"BEFORE CLEANUP COMPLETED\";\n-\n@@ -627,2 +622,0 @@\n-  public native long hostPhysicalMemory();\n-  public native long hostPhysicalSwap();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":6,"deletions":13,"binary":false,"changes":19,"previous_filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package jdk.test.whitebox.code;\n+package sun.hotspot.code;\n","filename":"test\/lib\/sun\/hotspot\/code\/BlobType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/whitebox\/code\/BlobType.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package jdk.test.whitebox.code;\n+package sun.hotspot.code;\n@@ -28,0 +28,1 @@\n+@Deprecated\n","filename":"test\/lib\/sun\/hotspot\/code\/CodeBlob.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"test\/lib\/jdk\/test\/whitebox\/code\/CodeBlob.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package jdk.test.whitebox.code;\n+package sun.hotspot.code;\n","filename":"test\/lib\/sun\/hotspot\/code\/Compiler.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/whitebox\/code\/Compiler.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package jdk.test.whitebox.code;\n+package sun.hotspot.code;\n@@ -29,0 +29,1 @@\n+@Deprecated\n","filename":"test\/lib\/sun\/hotspot\/code\/NMethod.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"test\/lib\/jdk\/test\/whitebox\/code\/NMethod.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package jdk.test.whitebox.cpuinfo;\n+package sun.hotspot.cpuinfo;\n@@ -42,0 +42,1 @@\n+@Deprecated\n","filename":"test\/lib\/sun\/hotspot\/cpuinfo\/CPUInfo.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"test\/lib\/jdk\/test\/whitebox\/cpuinfo\/CPUInfo.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package jdk.test.whitebox.gc;\n+package sun.hotspot.gc;\n","filename":"test\/lib\/sun\/hotspot\/gc\/GC.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/whitebox\/gc\/GC.java","status":"copied"}]}