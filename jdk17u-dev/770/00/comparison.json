{"files":[{"patch":"@@ -1307,1 +1307,2 @@\n-static bool skeleton_follow_inputs(Node* n, int op) {\n+static bool skeleton_follow_inputs(Node* n) {\n+  int op = n->Opcode();\n@@ -1325,0 +1326,14 @@\n+bool PhaseIdealLoop::subgraph_has_opaque(Node* n) {\n+  if (n->Opcode() == Op_OpaqueLoopInit || n->Opcode() == Op_OpaqueLoopStride) {\n+    return true;\n+  }\n+  if (!skeleton_follow_inputs(n)) {\n+    return false;\n+  }\n+  uint init;\n+  uint stride;\n+  count_opaque_loop_nodes(n, init, stride);\n+  return init != 0 || stride != 0;\n+}\n+\n+\n@@ -1326,0 +1341,4 @@\n+  uint init;\n+  uint stride;\n+  count_opaque_loop_nodes(iff->in(1)->in(1), init, stride);\n+#ifdef ASSERT\n@@ -1328,22 +1347,0 @@\n-  wq.push(iff->in(1)->in(1));\n-  uint init = 0;\n-  uint stride = 0;\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    int op = n->Opcode();\n-    if (skeleton_follow_inputs(n, op)) {\n-      for (uint j = 1; j < n->req(); j++) {\n-        Node* m = n->in(j);\n-        if (m != NULL) {\n-          wq.push(m);\n-        }\n-      }\n-      continue;\n-    }\n-    if (n->Opcode() == Op_OpaqueLoopInit) {\n-      init++;\n-    } else if (n->Opcode() == Op_OpaqueLoopStride) {\n-      stride++;\n-    }\n-  }\n-#ifdef ASSERT\n@@ -1378,0 +1375,25 @@\n+void PhaseIdealLoop::count_opaque_loop_nodes(Node* n, uint& init, uint& stride) {\n+  init = 0;\n+  stride = 0;\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(n);\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    if (skeleton_follow_inputs(n)) {\n+      for (uint j = 1; j < n->req(); j++) {\n+        Node* m = n->in(j);\n+        if (m != NULL) {\n+          wq.push(m);\n+        }\n+      }\n+      continue;\n+    }\n+    if (n->Opcode() == Op_OpaqueLoopInit) {\n+      init++;\n+    } else if (n->Opcode() == Op_OpaqueLoopStride) {\n+      stride++;\n+    }\n+  }\n+}\n+\n@@ -1397,2 +1419,1 @@\n-    int op = m->Opcode();\n-    if (skeleton_follow_inputs(m, op)) {\n+    if (skeleton_follow_inputs(m)) {\n@@ -1407,0 +1428,1 @@\n+      int op = m->Opcode();\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":47,"deletions":25,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -927,0 +927,2 @@\n+  static void count_opaque_loop_nodes(Node* n, uint& init, uint& stride);\n+  static bool subgraph_has_opaque(Node* n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  if (n->Opcode() == Op_OpaqueLoopStride || n->Opcode() == Op_OpaqueLoopInit) {\n+  if (subgraph_has_opaque(n)) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8291599\n+ * @summary Assertion in PhaseIdealLoop::skeleton_predicate_has_opaque after JDK-8289127\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:LoopMaxUnroll=0 TestPhiInSkeletonPredicateExpression\n+ *\/\n+\n+public class TestPhiInSkeletonPredicateExpression {\n+    private static int[] array1;\n+    private static int[] array2;\n+    private static int off;\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[2000];\n+        array1 = array;\n+        array2 = array;\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(1000, false);\n+            test1(1000, true);\n+            test2(1000, false);\n+            test2(1000, true);\n+        }\n+    }\n+\n+    private static int test1(int stop, boolean flag) {\n+        int v = 0;\n+\n+        for (int j = 1; j < 10; j *= 2) {\n+            int[] array;\n+            if (flag) {\n+                if (array1 == null) {\n+\n+                }\n+                array = array1;\n+                barrier = 0x42;\n+            } else {\n+                if (array2 == null) {\n+\n+                }\n+                array = array2;\n+                barrier = 0x42;\n+            }\n+\n+            int i = 0;\n+            do {\n+                synchronized (new Object()) {\n+                }\n+                v += array[i + off];\n+                i++;\n+            } while (i < stop);\n+        }\n+        return v;\n+    }\n+\n+    private static int test2(int stop, boolean flag) {\n+        int v = 0;\n+\n+        int[] array;\n+        if (flag) {\n+            if (array1 == null) {\n+\n+            }\n+            array = array1;\n+            barrier = 0x42;\n+        } else {\n+            if (array2 == null) {\n+\n+            }\n+            array = array2;\n+            barrier = 0x42;\n+        }\n+\n+        int i = 0;\n+        do {\n+            synchronized (new Object()) {\n+            }\n+            v += array[i + off];\n+            i++;\n+        } while (i < stop);\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPhiInSkeletonPredicateExpression.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}