{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -297,1 +297,0 @@\n-  \/\/ Is there anything to do?\n@@ -299,1 +298,49 @@\n-  return true;\n+  \/\/ These are reasonable sanity checks\n+  if (fp() == 0 || (intptr_t(fp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (sp() == 0 || (intptr_t(sp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (fp() - (abi_minframe_size + ijava_state_size) < sp()) {\n+    return false;\n+  }\n+  \/\/ These are hacks to keep us out of trouble.\n+  \/\/ The problem with these is that they mask other problems\n+  if (fp() <= sp()) {        \/\/ this attempts to deal with unsigned comparison above\n+    return false;\n+  }\n+\n+  \/\/ do some validation of frame elements\n+\n+  \/\/ first the method\n+\n+  Method* m = *interpreter_frame_method_addr();\n+\n+  \/\/ validate the method we'd find in this potential sender\n+  if (!Method::is_valid_method(m)) return false;\n+\n+  \/\/ stack frames shouldn't be much larger than max_stack elements\n+  \/\/ this test requires the use of unextended_sp which is the sp as seen by\n+  \/\/ the current frame, and not sp which is the \"raw\" pc which could point\n+  \/\/ further because of local variables of the callee method inserted after\n+  \/\/ method arguments\n+  if (fp() - unextended_sp() > 1024 + m->max_stack()*Interpreter::stackElementSize) {\n+    return false;\n+  }\n+\n+  \/\/ validate bci\/bcx\n+\n+  address  bcp    = interpreter_frame_bcp();\n+  if (m->validate_bci_from_bcp(bcp) < 0) {\n+    return false;\n+  }\n+\n+  \/\/ validate constantPoolCache*\n+  ConstantPoolCache* cp = *interpreter_frame_cache_addr();\n+  if (MetaspaceObj::is_valid(cp) == false) return false;\n+\n+  \/\/ validate locals\n+\n+  address locals =  (address) *interpreter_frame_locals_addr();\n+  return thread->is_in_stack_range_incl(locals, (address)fp());\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n@@ -301,1 +301,0 @@\n-  \/\/ Is there anything to do?\n@@ -303,1 +302,49 @@\n-  return true;\n+  \/\/ These are reasonable sanity checks\n+  if (fp() == 0 || (intptr_t(fp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (sp() == 0 || (intptr_t(sp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (fp() - (z_abi_16_size + z_ijava_state_size) < sp()) {\n+    return false;\n+  }\n+  \/\/ These are hacks to keep us out of trouble.\n+  \/\/ The problem with these is that they mask other problems\n+  if (fp() <= sp()) {        \/\/ this attempts to deal with unsigned comparison above\n+    return false;\n+  }\n+\n+  \/\/ do some validation of frame elements\n+\n+  \/\/ first the method\n+\n+  Method* m = *interpreter_frame_method_addr();\n+\n+  \/\/ validate the method we'd find in this potential sender\n+  if (!Method::is_valid_method(m)) return false;\n+\n+  \/\/ stack frames shouldn't be much larger than max_stack elements\n+  \/\/ this test requires the use of unextended_sp which is the sp as seen by\n+  \/\/ the current frame, and not sp which is the \"raw\" pc which could point\n+  \/\/ further because of local variables of the callee method inserted after\n+  \/\/ method arguments\n+  if (fp() - unextended_sp() > 1024 + m->max_stack()*Interpreter::stackElementSize) {\n+    return false;\n+  }\n+\n+  \/\/ validate bci\/bcx\n+\n+  address  bcp    = interpreter_frame_bcp();\n+  if (m->validate_bci_from_bcp(bcp) < 0) {\n+    return false;\n+  }\n+\n+  \/\/ validate constantPoolCache*\n+  ConstantPoolCache* cp = *interpreter_frame_cache_addr();\n+  if (MetaspaceObj::is_valid(cp) == false) return false;\n+\n+  \/\/ validate locals\n+\n+  address locals =  (address) *interpreter_frame_locals_addr();\n+  return thread->is_in_stack_range_incl(locals, (address)fp());\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"}]}