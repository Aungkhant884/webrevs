{"files":[{"patch":"@@ -17,1 +17,1 @@\n- * @see org.jline.keymap.KeyMap\n+ * @see jdk.internal.org.jline.keymap.KeyMap\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    private final int sort;\n@@ -34,1 +35,1 @@\n-        this(value, value, null, null, null, null, true);\n+        this(value, value, null, null, null, null, true, 0);\n@@ -47,0 +48,1 @@\n+     * @param sort the sort flag\n@@ -48,1 +50,1 @@\n-    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n+    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete, int sort) {\n@@ -56,0 +58,16 @@\n+        this.sort = sort;\n+    }\n+\n+    \/**\n+     * Constructs a new Candidate.\n+     *\n+     * @param value the value\n+     * @param displ the display string\n+     * @param group the group\n+     * @param descr the description\n+     * @param suffix the suffix\n+     * @param key the key\n+     * @param complete the complete flag\n+     *\/\n+    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n+        this(value, displ, group, descr, suffix, key, complete, 0);\n@@ -136,0 +154,9 @@\n+    \/**\n+     * Integer used to override default sort logic.\n+     * @return the sort int\n+     *\/\n+    public int sort() {\n+        return sort;\n+    }\n+\n+\n@@ -138,1 +165,19 @@\n-        return value.compareTo(o.value);\n+        \/\/ If both candidates have same sort, use default behavior\n+        if( sort == o.sort() ) {\n+            return value.compareTo(o.value);\n+        } else {\n+            return Integer.compare(sort, o.sort());\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        Candidate candidate = (Candidate) o;\n+        return Objects.equals(value, candidate.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Candidate.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n- * of the {@link org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n+ * of the {@link jdk.internal.org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletingParsedLine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-     * @return a map of candidates that completion matcher matches\n+     * @return a list of candidates that completion matcher matches\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletionMatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -17,0 +17,6 @@\n+    \/**\n+     * Highlight buffer\n+     * @param reader LineReader\n+     * @param buffer the buffer to be highlighted\n+     * @return highlighted buffer\n+     *\/\n@@ -18,2 +24,17 @@\n-    public void setErrorPattern(Pattern errorPattern);\n-    public void setErrorIndex(int errorIndex);\n+\n+    \/**\n+     * Refresh highlight configuration\n+     *\/\n+    default void refresh(LineReader reader) {}\n+\n+    \/**\n+     * Set error pattern to be highlighted\n+     * @param errorPattern error pattern to be highlighted\n+     *\/\n+    void setErrorPattern(Pattern errorPattern);\n+\n+    \/**\n+     * Set error index to be highlighted\n+     * @param errorIndex error index to be highlighted\n+     *\/\n+    void setErrorIndex(int errorIndex);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Highlighter.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-     * Read history from the file. If incremental only the events that are not contained within the internal list are added.\n+     * Read history from the file. If checkDuplicates is <code>true<\/code> only the events that\n+     * are not contained within the internal list are added.\n@@ -66,1 +67,1 @@\n-     * @param  incremental If true incremental read operation is performed.\n+     * @param  checkDuplicates If <code>true<\/code>, duplicate history entries will be discarded\n@@ -69,1 +70,1 @@\n-    void read(Path file, boolean incremental) throws IOException;\n+    void read(Path file, boolean checkDuplicates) throws IOException;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/History.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-     * Columns separated list of patterns that will not be saved in history.\n+     * Colon separated list of patterns that will not be saved in history.\n@@ -470,0 +470,3 @@\n+\n+        \/** Disable the undo feature *\/\n+        DISABLE_UNDO\n@@ -702,1 +705,1 @@\n-     * Read a mouse event when the {@link org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n+     * Read a mouse event when the {@link jdk.internal.org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReader.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -121,0 +121,6 @@\n+\n+        String appName = this.appName;\n+        if (null == appName) {\n+            appName = terminal.getName();\n+        }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReaderBuilder.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -15,2 +15,2 @@\n-    static final String REGEX_VARIABLE = \"[a-zA-Z_]{1,}[a-zA-Z0-9_-]*\";\n-    static final String REGEX_COMMAND = \"[:]{0,1}[a-zA-Z]{1,}[a-zA-Z0-9_-]*\";\n+    String REGEX_VARIABLE = \"[a-zA-Z_]+[a-zA-Z0-9_-]*\";\n+    String REGEX_COMMAND = \"[:]?[a-zA-Z]+[a-zA-Z0-9_-]*\";\n@@ -37,1 +37,1 @@\n-        String out = \"\";\n+        String out;\n@@ -71,1 +71,1 @@\n-         * May throw EOFError in which case we have incomplete input.\n+         * We should tolerate and ignore errors.\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Parser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).collect(Collectors.toList())\n+        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).distinct().collect(Collectors.toList())\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/CompletionMatcherImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,21 @@\n+    public static class BlockCommentDelims {\n+        private final String start;\n+        private final String end;\n+        public BlockCommentDelims(String start, String end) {\n+            if (start == null || end == null\n+              || start.isEmpty() || end.isEmpty() || start.equals(end)) {\n+                throw new IllegalArgumentException(\"Bad block comment delimiter!\");\n+            }\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        public String getStart() {\n+            return start;\n+        }\n+\n+        public String getEnd() {\n+            return end;\n+        }\n+    }\n+\n@@ -42,0 +63,4 @@\n+    private String[] lineCommentDelims = null;\n+\n+    private BlockCommentDelims blockCommentDelims = null;\n+\n@@ -50,0 +75,10 @@\n+    public DefaultParser lineCommentDelims(final String[] lineCommentDelims) {\n+        this.lineCommentDelims = lineCommentDelims;\n+        return this;\n+    }\n+\n+    public DefaultParser blockCommentDelims(final BlockCommentDelims blockCommentDelims) {\n+        this.blockCommentDelims = blockCommentDelims;\n+        return this;\n+    }\n+\n@@ -110,0 +145,16 @@\n+    public void setLineCommentDelims(String[] lineCommentDelims) {\n+        this.lineCommentDelims = lineCommentDelims;\n+    }\n+\n+    public String[] getLineCommentDelims() {\n+        return this.lineCommentDelims;\n+    }\n+\n+    public void setBlockCommentDelims(BlockCommentDelims blockCommentDelims) {\n+        this.blockCommentDelims = blockCommentDelims;\n+    }\n+\n+    public BlockCommentDelims getBlockCommentDelims() {\n+        return blockCommentDelims;\n+    }\n+\n@@ -228,0 +279,5 @@\n+        boolean lineCommented = false;\n+        boolean blockCommented = false;\n+        boolean blockCommentInRightOrder = true;\n+        final String blockCommentEnd = blockCommentDelims == null ? null : blockCommentDelims.end;\n+        final String blockCommentStart = blockCommentDelims == null ? null : blockCommentDelims.start;\n@@ -240,1 +296,1 @@\n-            if (quoteStart < 0 && isQuoteChar(line, i)) {\n+            if (quoteStart < 0 && isQuoteChar(line, i) && !lineCommented && !blockCommented) {\n@@ -261,6 +317,3 @@\n-                \/\/ Delimiter\n-                if (current.length() > 0) {\n-                    words.add(current.toString());\n-                    current.setLength(0); \/\/ reset the arg\n-                    if (rawWordCursor >= 0 && rawWordLength < 0) {\n-                        rawWordLength = i - rawWordStart;\n+                if (lineCommented) {\n+                    if (isCommentDelim(line, i, System.lineSeparator())) {\n+                        lineCommented = false;\n@@ -268,0 +321,8 @@\n+                } else if (blockCommented) {\n+                    if (isCommentDelim(line, i, blockCommentEnd)) {\n+                        blockCommented = false;\n+                    }\n+                } else {\n+                    \/\/ Delimiter\n+                    rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                    rawWordStart = i + 1;\n@@ -269,1 +330,0 @@\n-                rawWordStart = i + 1;\n@@ -271,1 +331,20 @@\n-                if (!isEscapeChar(line, i)) {\n+                if (quoteStart < 0 && !blockCommented && (lineCommented || isLineCommentStarted(line, i))) {\n+                    lineCommented = true;\n+                } else if (quoteStart < 0 && !lineCommented\n+                        && (blockCommented || isCommentDelim(line, i, blockCommentStart))) {\n+                    if (blockCommented) {\n+                        if (blockCommentEnd != null && isCommentDelim(line, i, blockCommentEnd)) {\n+                            blockCommented = false;\n+                            i += blockCommentEnd.length() - 1;\n+                        }\n+                    } else {\n+                        blockCommented = true;\n+                        rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                        i += blockCommentStart == null ? 0 : blockCommentStart.length() - 1;\n+                        rawWordStart = i + 1;\n+                    }\n+                } else if (quoteStart < 0 && !lineCommented\n+                        && isCommentDelim(line, i, blockCommentEnd)) {\n+                    current.append(line.charAt(i));\n+                    blockCommentInRightOrder = false;\n+                } else if (!isEscapeChar(line, i)) {\n@@ -304,0 +383,8 @@\n+            if (blockCommented) {\n+                throw new EOFError(-1, -1, \"Missing closing block comment delimiter\",\n+                        \"add: \" + blockCommentEnd);\n+            }\n+            if (!blockCommentInRightOrder) {\n+                throw new EOFError(-1, -1, \"Missing opening block comment delimiter\",\n+                        \"missing: \" + blockCommentStart);\n+            }\n@@ -336,0 +423,11 @@\n+    private int handleDelimiterAndGetRawWordLength(StringBuilder current, List<String> words, int rawWordStart, int rawWordCursor, int rawWordLength, int pos) {\n+        if (current.length() > 0) {\n+            words.add(current.toString());\n+            current.setLength(0); \/\/ reset the arg\n+            if (rawWordCursor >= 0 && rawWordLength < 0) {\n+                return pos - rawWordStart;\n+            }\n+        }\n+        return rawWordLength;\n+    }\n+\n@@ -354,0 +452,30 @@\n+    private boolean isCommentDelim(final CharSequence buffer, final int pos, final String pattern) {\n+        if (pos < 0) {\n+            return false;\n+        }\n+\n+        if (pattern != null) {\n+            final int length = pattern.length();\n+            if (length <= buffer.length() - pos) {\n+                for (int i = 0; i < length; i++) {\n+                    if (pattern.charAt(i) != buffer.charAt(pos + i)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean isLineCommentStarted(final CharSequence buffer, final int pos) {\n+        if (lineCommentDelims != null) {\n+            for (String comment: lineCommentDelims) {\n+                if (isCommentDelim(buffer, pos, comment)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultParser.java","additions":137,"deletions":9,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2022, the original author or authors.\n@@ -284,1 +284,1 @@\n-        this(terminal, null, null);\n+        this(terminal, terminal.getName(), null);\n@@ -636,1 +636,2 @@\n-                undo.newState(buf.copy());\n+                if (!isSet(Option.DISABLE_UNDO))\n+                    undo.newState(buf.copy());\n@@ -682,1 +683,1 @@\n-                    if (!isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n+                    if (!isSet(Option.DISABLE_UNDO) && !isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n@@ -742,0 +743,1 @@\n+                startedReading.set(false);\n@@ -743,1 +745,0 @@\n-            startedReading.set(false);\n@@ -1085,1 +1086,1 @@\n-        Constructor<?> ctor = Class.forName(\"org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n+        Constructor<?> ctor = Class.forName(\"jdk.internal.org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n@@ -1090,5 +1091,6 @@\n-        BufferedReader br = new BufferedReader(new FileReader(file));\n-        String line;\n-        commandsBuffer.clear();\n-        while ((line = br.readLine()) != null) {\n-            commandsBuffer.add(line);\n+        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n+            String line;\n+            commandsBuffer.clear();\n+            while ((line = br.readLine()) != null) {\n+                commandsBuffer.add(line);\n+            }\n@@ -1096,1 +1098,0 @@\n-        br.close();\n@@ -3598,3 +3599,3 @@\n-            FileWriter writer = new FileWriter(file);\n-            writer.write(buf.toString());\n-            writer.close();\n+            try (FileWriter writer = new FileWriter(file)) {\n+                writer.write(buf.toString());\n+            }\n@@ -3799,0 +3800,3 @@\n+                if (terminal.getType().startsWith(AbstractWindowsTerminal.TYPE_WINDOWS)) {\n+                    status.resize();\n+                }\n@@ -3950,1 +3954,2 @@\n-                     || c == '$' || c == '.' || c == '?' || c == '+') {\n+                     || c == '$' || c == '.' || c == '?' || c == '+' || c == '|' || c == '<' || c == '>' || c == '!'\n+                     || c == '-') {\n@@ -4523,1 +4528,1 @@\n-    private CompletingParsedLine wrap(ParsedLine line) {\n+    protected static CompletingParsedLine wrap(ParsedLine line) {\n@@ -4628,0 +4633,5 @@\n+    private int visibleDisplayRows() {\n+        Status status = Status.getStatus(terminal, false);\n+        return terminal.getSize().getRows() - (status != null ? status.size() : 0);\n+    }\n+\n@@ -5073,0 +5083,1 @@\n+        boolean customOrder = possible.stream().anyMatch(c -> c.sort() != 0);\n@@ -5075,1 +5086,1 @@\n-            Map<String, Map<String, Candidate>> sorted;\n+            Map<String, Map<Object, Candidate>> sorted;\n@@ -5082,1 +5093,1 @@\n-                        .put(cand.value(), cand);\n+                        .put((customOrder ? cand.sort() : cand.value()), cand);\n@@ -5084,1 +5095,1 @@\n-            for (Map.Entry<String, Map<String, Candidate>> entry : sorted.entrySet()) {\n+            for (Map.Entry<String, Map<Object, Candidate>> entry : sorted.entrySet()) {\n@@ -5099,1 +5110,1 @@\n-            TreeMap<String, Candidate> sorted = new TreeMap<>();\n+            TreeMap<Object, Candidate> sorted = new TreeMap<>();\n@@ -5105,1 +5116,1 @@\n-                sorted.put(cand.value(), cand);\n+                sorted.put((customOrder ? cand.sort() : cand.value()), cand);\n@@ -5132,1 +5143,1 @@\n-            while (endLine.length() + (first ? startPos : 0) > width) {\n+            while (endLine.length() + (first ? startPos : 0) > width && width > 0) {\n@@ -5210,1 +5221,1 @@\n-                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), displayRows() - promptLines())) {\n+                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), visibleDisplayRows() - promptLines())) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/LineReaderImpl.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @deprecated use <code>org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n+ * @deprecated use <code>jdk.internal.org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/FileNameCompleter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-            } else if (aliasCommand.containsKey(cmd)) {\n+            } else {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/SystemCompleter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    public void read(Path file, boolean incremental) throws IOException {\n+    public void read(Path file, boolean checkDuplicates) throws IOException {\n@@ -107,1 +107,1 @@\n-                        reader.lines().forEach(line -> addHistoryLine(path, line, incremental));\n+                        reader.lines().forEach(line -> addHistoryLine(path, line, checkDuplicates));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/history\/DefaultHistory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -19,0 +19,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -20,0 +21,4 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n@@ -24,0 +29,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -27,0 +34,1 @@\n+import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n@@ -28,7 +36,1 @@\n-import jdk.internal.org.jline.terminal.impl.ExecPty;\n-import jdk.internal.org.jline.terminal.impl.ExternalTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.JansiSupport;\n-import jdk.internal.org.jline.terminal.spi.JnaSupport;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -55,0 +57,5 @@\n+    public static final String PROP_OUTPUT = \"org.jline.terminal.output\";\n+    public static final String PROP_OUTPUT_OUT = \"out\";\n+    public static final String PROP_OUTPUT_ERR = \"err\";\n+    public static final String PROP_OUTPUT_OUT_ERR = \"out-err\";\n+    public static final String PROP_OUTPUT_ERR_OUT = \"err-out\";\n@@ -64,0 +71,10 @@\n+    \/\/\n+    \/\/ Terminal output control\n+    \/\/\n+    public enum SystemOutput {\n+        SysOut,\n+        SysErr,\n+        SysOutOrSysErr,\n+        SysErrOrSysOut\n+    }\n+\n@@ -100,0 +117,1 @@\n+    private SystemOutput systemOutput;\n@@ -131,0 +149,14 @@\n+    \/**\n+     * Indicates which standard stream should be used when displaying to the terminal.\n+     * The default is to use the system output stream.\n+     * Building a system terminal will fail if one of the stream specified is not linked\n+     * to the controlling terminal.\n+     *\n+     * @param systemOutput The mode to choose the output stream.\n+     * @return The builder.\n+     *\/\n+    public TerminalBuilder systemOutput(SystemOutput systemOutput) {\n+        this.systemOutput = systemOutput;\n+        return this;\n+    }\n+\n@@ -301,5 +333,12 @@\n-        int codepage = this.codepage;\n-        if (codepage <= 0) {\n-            String str = System.getProperty(PROP_CODEPAGE);\n-            if (str != null) {\n-                codepage = Integer.parseInt(str);\n+        if (encoding == null) {\n+            int codepage = this.codepage;\n+            if (codepage <= 0) {\n+                String str = System.getProperty(PROP_CODEPAGE);\n+                if (str != null) {\n+                    codepage = Integer.parseInt(str);\n+                }\n+            }\n+            if (codepage >= 0) {\n+                encoding = getCodepageCharset(codepage);\n+            } else {\n+                encoding = StandardCharsets.UTF_8;\n@@ -331,0 +370,32 @@\n+        IllegalStateException exception = new IllegalStateException(\"Unable to create a terminal\");\n+        List<TerminalProvider> providers = new ArrayList<>();\n+        if (jna) {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"jna\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load JNA support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+        if (jansi) {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"jansi\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load JANSI support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+        if (exec)\n+        {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"exec\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load EXEC support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+\n+        Terminal terminal = null;\n@@ -332,1 +403,2 @@\n-            if (system != null && ((in != null && !in.equals(System.in)) ||  (out != null && !out.equals(System.out)))) {\n+            if (system != null && ((in != null && !in.equals(System.in)) ||\n+                    (out != null && !out.equals(System.out) && !out.equals(System.err)))) {\n@@ -335,4 +407,33 @@\n-            Terminal terminal = null;\n-            IllegalStateException exception = new IllegalStateException(\"Unable to create a system terminal\");\n-            TerminalBuilderSupport tbs = new TerminalBuilderSupport(jna, jansi);\n-            if (tbs.isConsoleInput() && tbs.isConsoleOutput()) {\n+            if (attributes != null || size != null) {\n+                Log.warn(\"Attributes and size fields are ignored when creating a system terminal\");\n+            }\n+            if (out != null) {\n+                if (out.equals(System.out)) {\n+                    systemOutput = SystemOutput.SysOut;\n+                } else if (out.equals(System.err)) {\n+                    systemOutput = SystemOutput.SysErr;\n+                }\n+            }\n+            if (systemOutput == null) {\n+                String str = System.getProperty(PROP_OUTPUT);\n+                if (str != null) {\n+                    switch (str.trim().toLowerCase(Locale.ROOT)) {\n+                        case PROP_OUTPUT_OUT: systemOutput = SystemOutput.SysOut; break;\n+                        case PROP_OUTPUT_ERR: systemOutput = SystemOutput.SysErr; break;\n+                        case PROP_OUTPUT_OUT_ERR: systemOutput = SystemOutput.SysOutOrSysErr; break;\n+                        case PROP_OUTPUT_ERR_OUT: systemOutput = SystemOutput.SysErrOrSysOut; break;\n+                        default:\n+                            Log.debug(\"Unsupported value for \" + PROP_OUTPUT + \": \" + str + \". Supported values are: \"\n+                                    + String.join(\", \", PROP_OUTPUT_OUT, PROP_OUTPUT_ERR, PROP_OUTPUT_OUT_ERR,PROP_OUTPUT_ERR_OUT)\n+                                    + \".\");\n+                    }\n+                }\n+            }\n+            if (systemOutput == null) {\n+                systemOutput = SystemOutput.SysOutOrSysErr;\n+            }\n+            Map<TerminalProvider.Stream, Boolean> system = Stream.of(TerminalProvider.Stream.values())\n+                    .collect(Collectors.toMap(stream -> stream, stream -> providers.stream().anyMatch(p -> p.isSystemStream(stream))));\n+            TerminalProvider.Stream console = select(system, systemOutput);\n+\n+            if (system.get(TerminalProvider.Stream.Input) && console != null) {\n@@ -342,64 +443,9 @@\n-                if (OSUtils.IS_WINDOWS) {\n-                    if (!OSUtils.IS_CYGWIN && !OSUtils.IS_MSYSTEM) {\n-                        boolean ansiPassThrough = OSUtils.IS_CONEMU;\n-                        if (tbs.hasJnaSupport()) {\n-                            try {\n-                                terminal = tbs.getJnaSupport().winSysTerminal(name, type, ansiPassThrough, encoding, codepage\n-                                        , nativeSignals, signalHandler, paused, inputStreamWrapper);\n-                            } catch (Throwable t) {\n-                                Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n-                                exception.addSuppressed(t);\n-                            }\n-                        }\n-                        if (terminal == null && tbs.hasJansiSupport()) {\n-                            try {\n-                                terminal = tbs.getJansiSupport().winSysTerminal(name, type, ansiPassThrough, encoding, codepage\n-                                        , nativeSignals, signalHandler, paused);\n-                            } catch (Throwable t) {\n-                                Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                                exception.addSuppressed(t);\n-                            }\n-                        }\n-                    } else if (exec) {\n-                        \/\/\n-                        \/\/ Cygwin support\n-                        \/\/\n-                        try {\n-                            \/\/ Cygwin defaults to XTERM, but actually supports 256 colors,\n-                            \/\/ so if the value comes from the environment, change it to xterm-256color\n-                            if (\"xterm\".equals(type) && this.type == null && System.getProperty(PROP_TYPE) == null) {\n-                                type = \"xterm-256color\";\n-                            }\n-                            Pty pty = tbs.getExecPty();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (IOException e) {\n-                            \/\/ Ignore if not a tty\n-                            Log.debug(\"Error creating EXEC based terminal: \", e.getMessage(), e);\n-                            exception.addSuppressed(e);\n-                        }\n-                    }\n-                    if (terminal == null && !jna && !jansi && (dumb == null || !dumb)) {\n-                        throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n-                                + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n-                    }\n-                } else {\n-                    if (tbs.hasJnaSupport()) {\n-                        try {\n-                            Pty pty = tbs.getJnaSupport().current();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (Throwable t) {\n-                            \/\/ ignore\n-                            Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n-                            exception.addSuppressed(t);\n-                        }\n-                    }\n-                    if (terminal == null && tbs.hasJansiSupport()) {\n-                        try {\n-                            Pty pty = tbs.getJansiSupport().current();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (Throwable t) {\n-                            Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                            exception.addSuppressed(t);\n-                        }\n-                    }\n-                    if (terminal == null && exec) {\n+                boolean ansiPassThrough = OSUtils.IS_CONEMU;\n+                \/\/ Cygwin defaults to XTERM, but actually supports 256 colors,\n+                \/\/ so if the value comes from the environment, change it to xterm-256color\n+                if ((OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM)  && \"xterm\".equals(type)\n+                        && this.type == null && System.getProperty(PROP_TYPE) == null) {\n+                    type = \"xterm-256color\";\n+                }\n+                for ( TerminalProvider provider : providers) {\n+                    if (terminal == null) {\n@@ -407,2 +453,2 @@\n-                            Pty pty = tbs.getExecPty();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                            terminal = provider.sysTerminal(name, type, ansiPassThrough, encoding,\n+                                    nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n@@ -410,2 +456,1 @@\n-                            \/\/ Ignore if not a tty\n-                            Log.debug(\"Error creating EXEC based terminal: \", t.getMessage(), t);\n+                            Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n@@ -416,11 +461,15 @@\n-                if (terminal instanceof AbstractTerminal) {\n-                    AbstractTerminal t = (AbstractTerminal) terminal;\n-                    if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n-                        t.setOnClose(() -> SYSTEM_TERMINAL.compareAndSet(t, null));\n-                    } else {\n-                        exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n-                                \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n-                                \"or that previously created system Terminals have been correctly closed.\"));\n-                        terminal.close();\n-                        terminal = null;\n-                    }\n+                if (terminal == null && OSUtils.IS_WINDOWS &&  !jna && !jansi && (dumb == null || !dumb)) {\n+                    throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n+                            + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n+                }\n+            }\n+            if (terminal instanceof AbstractTerminal) {\n+                AbstractTerminal t = (AbstractTerminal) terminal;\n+                if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n+                    t.setOnClose(() -> SYSTEM_TERMINAL.compareAndSet(t, null));\n+                } else {\n+                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n+                            \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n+                            \"or that previously created system Terminals have been correctly closed.\"));\n+                    terminal.close();\n+                    terminal = null;\n@@ -436,1 +485,2 @@\n-                        color = System.getenv(\"INSIDE_EMACS\") != null;\n+                        String emacs = System.getenv(\"INSIDE_EMACS\");\n+                        color = emacs != null && emacs.contains(\"comint\");\n@@ -444,1 +494,1 @@\n-                        color = tbs.isConsoleOutput() && System.getenv(\"TERM\") != null;\n+                        color = system.get(TerminalProvider.Stream.Output) && System.getenv(\"TERM\") != null;\n@@ -448,2 +498,3 @@\n-                            Log.warn(\"input is tty: {}\", tbs.isConsoleInput());\n-                            Log.warn(\"output is tty: {}\", tbs.isConsoleOutput());\n+                            Log.warn(\"input is tty: {}\", system.get(TerminalProvider.Stream.Input));\n+                            Log.warn(\"output is tty: {}\", system.get(TerminalProvider.Stream.Output));\n+                            Log.warn(\"error is tty: {}\", system.get(TerminalProvider.Stream.Error));\n@@ -457,2 +508,2 @@\n-                        inputStreamWrapper.apply(new FileInputStream(FileDescriptor.in)),\n-                        new FileOutputStream(FileDescriptor.out),\n+                        new FileInputStream(FileDescriptor.in),\n+                        new FileOutputStream(console == TerminalProvider.Stream.Output ? FileDescriptor.out : FileDescriptor.err),\n@@ -461,4 +512,0 @@\n-            if (terminal == null) {\n-                throw exception;\n-            }\n-            return terminal;\n@@ -466,6 +513,8 @@\n-            if (jna) {\n-                try {\n-                    Pty pty = load(JnaSupport.class).open(attributes, size);\n-                    return new PosixPtyTerminal(name, type, pty, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused);\n-                } catch (Throwable t) {\n-                    Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n+            for ( TerminalProvider provider : providers) {\n+                if (terminal == null) {\n+                    try {\n+                        terminal = provider.newTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n+                    } catch (Throwable t) {\n+                        Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n+                        exception.addSuppressed(t);\n+                    }\n@@ -474,7 +523,25 @@\n-            if (jansi) {\n-                try {\n-                    Pty pty = load(JansiSupport.class).open(attributes, size);\n-                    return new PosixPtyTerminal(name, type, pty, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused);\n-                } catch (Throwable t) {\n-                    Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                }\n+        }\n+        if (terminal == null) {\n+            throw exception;\n+        }\n+        return terminal;\n+    }\n+\n+    private TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, SystemOutput systemOutput) {\n+        switch (systemOutput) {\n+            case SysOut:\n+                return select(system, TerminalProvider.Stream.Output);\n+            case SysErr:\n+                return select(system, TerminalProvider.Stream.Error);\n+            case SysOutOrSysErr:\n+                return select(system, TerminalProvider.Stream.Output, TerminalProvider.Stream.Error);\n+            case SysErrOrSysOut:\n+                return select(system, TerminalProvider.Stream.Error, TerminalProvider.Stream.Output);\n+        }\n+        return null;\n+    }\n+\n+    private static TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, TerminalProvider.Stream... streams) {\n+        for (TerminalProvider.Stream s : streams) {\n+            if (system.get(s)) {\n+                return s;\n@@ -482,1 +549,0 @@\n-            return new ExternalTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n@@ -484,0 +550,1 @@\n+        return null;\n@@ -515,0 +582,18 @@\n+    private static final int UTF8_CODE_PAGE = 65001;\n+\n+    private static Charset getCodepageCharset(int codepage) {\n+        \/\/http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n+        if (codepage == UTF8_CODE_PAGE) {\n+            return StandardCharsets.UTF_8;\n+        }\n+        String charsetMS = \"ms\" + codepage;\n+        if (Charset.isSupported(charsetMS)) {\n+            return Charset.forName(charsetMS);\n+        }\n+        String charsetCP = \"cp\" + codepage;\n+        if (Charset.isSupported(charsetCP)) {\n+            return Charset.forName(charsetCP);\n+        }\n+        return Charset.defaultCharset();\n+    }\n+\n@@ -548,75 +633,0 @@\n-    private static class TerminalBuilderSupport {\n-        private JansiSupport jansiSupport = null;\n-        private JnaSupport jnaSupport = null;\n-        private Pty pty = null;\n-        private boolean consoleOutput;\n-\n-        TerminalBuilderSupport(boolean jna, boolean jansi) {\n-            if (jna) {\n-                try {\n-                    jnaSupport = load(JnaSupport.class);\n-                    consoleOutput = jnaSupport.isConsoleOutput();\n-                } catch (Throwable e) {\n-                    jnaSupport = null;\n-                    Log.debug(\"jnaSupport.isConsoleOutput(): \", e);\n-                }\n-            }\n-            if (jansi) {\n-                try {\n-                    jansiSupport = load(JansiSupport.class);\n-                    consoleOutput = jansiSupport.isConsoleOutput();\n-                } catch (Throwable e) {\n-                    jansiSupport = null;\n-                    Log.debug(\"jansiSupport.isConsoleOutput(): \", e);\n-                }\n-            }\n-            if (jnaSupport == null && jansiSupport == null) {\n-                try {\n-                    pty = ExecPty.current();\n-                    consoleOutput = true;\n-                } catch (Exception e) {\n-                    Log.debug(\"ExecPty.current(): \", e);\n-                }\n-            }\n-        }\n-\n-        public boolean isConsoleOutput() {\n-            return consoleOutput;\n-        }\n-\n-        public boolean isConsoleInput() {\n-            if (pty != null) {\n-                return true;\n-            } else if (hasJnaSupport()) {\n-                return jnaSupport.isConsoleInput();\n-            } else if (hasJansiSupport()) {\n-                return jansiSupport.isConsoleInput();\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        public boolean hasJnaSupport() {\n-            return jnaSupport != null;\n-        }\n-\n-        public boolean hasJansiSupport() {\n-            return jansiSupport != null;\n-        }\n-\n-        public JnaSupport getJnaSupport() {\n-            return jnaSupport;\n-        }\n-\n-        public JansiSupport getJansiSupport() {\n-            return jansiSupport;\n-        }\n-\n-        public Pty getExecPty() throws IOException {\n-            if (pty == null) {\n-                pty = ExecPty.current();\n-            }\n-            return pty;\n-        }\n-\n-    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":206,"deletions":196,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -89,5 +89,0 @@\n-        @Override\n-        public int readBuffered(byte[] b) throws IOException {\n-            return in.read(b);\n-        }\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPty.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        super(name, type, selectCharset(encoding, codepage), signalHandler);\n+    public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        super(name, type, encoding, signalHandler);\n@@ -119,29 +119,0 @@\n-    private static Charset selectCharset(Charset encoding, int codepage) {\n-        if (encoding != null) {\n-            return encoding;\n-        }\n-\n-        if (codepage >= 0) {\n-            return getCodepageCharset(codepage);\n-        }\n-\n-        \/\/ Use UTF-8 as default\n-        return StandardCharsets.UTF_8;\n-    }\n-\n-    private static Charset getCodepageCharset(int codepage) {\n-        \/\/http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n-        if (codepage == UTF8_CODE_PAGE) {\n-            return StandardCharsets.UTF_8;\n-        }\n-        String charsetMS = \"ms\" + codepage;\n-        if (Charset.isSupported(charsetMS)) {\n-            return Charset.forName(charsetMS);\n-        }\n-        String charsetCP = \"cp\" + codepage;\n-        if (Charset.isSupported(charsetCP)) {\n-            return Charset.forName(charsetCP);\n-        }\n-        return Charset.defaultCharset();\n-    }\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsTerminal.java","additions":2,"deletions":31,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl;\n+\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinTask;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class Diag {\n+\n+    public static void main(String[] args) {\n+        diag(System.out);\n+    }\n+\n+    static void diag(PrintStream out) {\n+        out.println(\"System properties\");\n+        out.println(\"=================\");\n+        out.println(\"os.name =         \" + System.getProperty(\"os.name\"));\n+        out.println(\"OSTYPE =          \" + System.getenv(\"OSTYPE\"));\n+        out.println(\"MSYSTEM =         \" + System.getenv(\"MSYSTEM\"));\n+        out.println(\"PWD =             \" + System.getenv(\"PWD\"));\n+        out.println(\"ConEmuPID =       \" + System.getenv(\"ConEmuPID\"));\n+        out.println(\"WSL_DISTRO_NAME = \" + System.getenv(\"WSL_DISTRO_NAME\"));\n+        out.println(\"WSL_INTEROP =     \" + System.getenv(\"WSL_INTEROP\"));\n+        out.println();\n+\n+        out.println(\"OSUtils\");\n+        out.println(\"=================\");\n+        out.println(\"IS_WINDOWS = \" + OSUtils.IS_WINDOWS);\n+        out.println(\"IS_CYGWIN =  \" + OSUtils.IS_CYGWIN);\n+        out.println(\"IS_MSYSTEM = \" + OSUtils.IS_MSYSTEM);\n+        out.println(\"IS_WSL =     \" + OSUtils.IS_WSL);\n+        out.println(\"IS_WSL1 =    \" + OSUtils.IS_WSL1);\n+        out.println(\"IS_WSL2 =    \" + OSUtils.IS_WSL2);\n+        out.println(\"IS_CONEMU =  \" + OSUtils.IS_CONEMU);\n+        out.println(\"IS_OSX =     \" + OSUtils.IS_OSX);\n+        out.println();\n+\n+        out.println(\"JnaSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jna\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"JNA support not available: \" + t);\n+        }\n+        out.println();\n+\n+        out.println(\"JansiSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jansi\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"Jansi support not available: \" + t);\n+        }\n+        out.println();\n+\n+        \/\/ Exec\n+        out.println(\"Exec Support\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"exec\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"Exec support not available: \" + t);\n+        }\n+    }\n+\n+    private static void testProvider(PrintStream out, TerminalProvider provider) {\n+        try {\n+            out.println(\"StdIn stream =    \" + provider.isSystemStream(TerminalProvider.Stream.Input));\n+            out.println(\"StdOut stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Output));\n+            out.println(\"StdErr stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Error));\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to check stream: \" + t2);\n+        }\n+        try {\n+            out.println(\"StdIn stream name =     \" + provider.systemStreamName(TerminalProvider.Stream.Input));\n+            out.println(\"StdOut stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Output));\n+            out.println(\"StdErr stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Error));\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to check stream names: \" + t2);\n+        }\n+        try (Terminal terminal = provider.sysTerminal(\"diag\", \"xterm\", false, StandardCharsets.UTF_8,\n+                false, Terminal.SignalHandler.SIG_DFL, false, TerminalProvider.Stream.Output, input -> input) ) {\n+            if (terminal != null) {\n+                Attributes attr = terminal.enterRawMode();\n+                try {\n+                    out.println(\"Terminal size: \" + terminal.getSize());\n+                    ForkJoinTask<Integer> t = new ForkJoinPool(1).submit(() -> terminal.reader().read(1) );\n+                    int r = t.get(1000, TimeUnit.MILLISECONDS);\n+                    StringBuilder sb = new StringBuilder();\n+                    sb.append(\"The terminal seems to work: \");\n+                    sb.append(\"terminal \").append(terminal.getClass().getName());\n+                    if (terminal instanceof AbstractPosixTerminal) {\n+                        sb.append(\" with pty \").append(((AbstractPosixTerminal) terminal).getPty().getClass().getName());\n+                    }\n+                    out.println(sb);\n+                } catch (Throwable t3) {\n+                    out.println(\"Unable to read from terminal: \" + t3);\n+                    t3.printStackTrace();\n+                } finally {\n+                    terminal.setAttributes(attr);\n+                }\n+            } else {\n+                out.println(\"Not supported by provider\");\n+            }\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to open terminal: \" + t2);\n+            t2.printStackTrace();\n+        }\n+    }\n+\n+    static <S> S load(Class<S> clazz) {\n+        return ServiceLoader.load(clazz, clazz.getClassLoader()).iterator().next();\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/Diag.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -37,1 +38,1 @@\n-    private final boolean system;\n+    private final TerminalProvider.Stream console;\n@@ -39,1 +40,1 @@\n-    public static Pty current() throws IOException {\n+    public static Pty current(TerminalProvider.Stream console) throws IOException {\n@@ -42,1 +43,4 @@\n-            return new ExecPty(result.trim(), true);\n+            if (console != TerminalProvider.Stream.Output && console != TerminalProvider.Stream.Error) {\n+                throw new IllegalArgumentException(\"console should be Output or Error: \" + console);\n+            }\n+            return new ExecPty(result.trim(), console);\n@@ -48,1 +52,1 @@\n-    protected ExecPty(String name, boolean system) {\n+    protected ExecPty(String name, TerminalProvider.Stream console) {\n@@ -50,1 +54,1 @@\n-        this.system = system;\n+        this.console = console;\n@@ -73,1 +77,1 @@\n-        return system\n+        return console != null\n@@ -80,1 +84,1 @@\n-        return system\n+        return console == TerminalProvider.Stream.Output\n@@ -82,1 +86,3 @@\n-                : new FileOutputStream(getName());\n+                : console == TerminalProvider.Stream.Error\n+                    ? new FileOutputStream(FileDescriptor.err)\n+                    : new FileOutputStream(getName());\n@@ -96,1 +102,1 @@\n-            if (!system) {\n+            if (console == null) {\n@@ -100,13 +106,1 @@\n-            try {\n-                exec(system, commands.toArray(new String[commands.size()]));\n-            } catch (IOException e) {\n-                \/\/ Handle partial failures with GNU stty, see #97\n-                if (e.toString().contains(\"unable to perform all requested operations\")) {\n-                    commands = getFlagsToSet(attr, getAttr());\n-                    if (!commands.isEmpty()) {\n-                        throw new IOException(\"Could not set the following flags: \" + String.join(\", \", commands), e);\n-                    }\n-                } else {\n-                    throw e;\n-                }\n-            }\n+            exec(console != null, commands.toArray(new String[0]));\n@@ -174,1 +168,1 @@\n-        return system\n+        return console != null\n@@ -283,1 +277,1 @@\n-        if (system) {\n+        if (console != null) {\n@@ -299,1 +293,1 @@\n-        return \"ExecPty[\" + getName() + (system ? \", system]\" : \"]\");\n+        return \"ExecPty[\" + getName() + (console != null ? \", system]\" : \"]\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ExecPty.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -18,1 +18,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -146,1 +145,1 @@\n-    private class InputStreamWrapper extends NonBlockingInputStream {\n+    private static class InputStreamWrapper extends NonBlockingInputStream {\n@@ -149,1 +148,1 @@\n-        private final AtomicBoolean closed = new AtomicBoolean();\n+        private volatile boolean closed;\n@@ -157,1 +156,1 @@\n-            if (closed.get()) {\n+            if (closed) {\n@@ -165,1 +164,1 @@\n-            closed.set(true);\n+            closed = true;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixPtyTerminal.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+import java.util.function.Function;\n@@ -37,2 +38,3 @@\n-    public PosixSysTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding,\n-                            boolean nativeSignals, SignalHandler signalHandler) throws IOException {\n+    public PosixSysTerminal(String name, String type, Pty pty, Charset encoding,\n+                            boolean nativeSignals, SignalHandler signalHandler,\n+                            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n@@ -40,2 +42,2 @@\n-        this.input = NonBlocking.nonBlocking(getName(), in);\n-        this.output = out;\n+        this.input = NonBlocking.nonBlocking(getName(), inputStreamWrapper.apply(pty.getSlaveInput()));\n+        this.output = pty.getSlaveOutput();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixSysTerminal.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.exec;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.ExecPty;\n+import jdk.internal.org.jline.terminal.impl.ExternalTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.ExecHelper;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class ExecTerminalProvider implements TerminalProvider\n+{\n+\n+    public String name() {\n+        return \"exec\";\n+    }\n+\n+    public Pty current(Stream consoleStream) throws IOException {\n+        return ExecPty.current(consoleStream);\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        } else {\n+            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        }\n+    }\n+\n+    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                    boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                    Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper ) throws IOException {\n+        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n+            Pty pty = current(consoleStream);\n+            return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        Pty pty = current(consoleStream);\n+        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+        return new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused, attributes, size);\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+            return isWindowsSystemStream(stream) || isPosixSystemStream(stream);\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(Stream stream) {\n+        return systemStreamName( stream ) != null;\n+    }\n+\n+    public boolean isPosixSystemStream(Stream stream) {\n+        try {\n+            Process p = new ProcessBuilder(OSUtils.TEST_COMMAND, \"-t\", Integer.toString(stream.ordinal()))\n+                    .inheritIO().start();\n+            return p.waitFor() == 0;\n+        } catch (Throwable t) {\n+            \/\/ ignore\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+        try {\n+            ProcessBuilder.Redirect input = stream == Stream.Input\n+                                ? ProcessBuilder.Redirect.INHERIT\n+                                : getRedirect(stream == Stream.Output ? FileDescriptor.out : FileDescriptor.err);\n+            Process p = new ProcessBuilder(OSUtils.TTY_COMMAND).redirectInput(input).start();\n+            String result = ExecHelper.waitAndCapture(p);\n+            if (p.exitValue() == 0) {\n+                return result.trim();\n+            }\n+        } catch (Throwable t) {\n+            \/\/ ignore\n+        }\n+        return null;\n+    }\n+\n+    private ProcessBuilder.Redirect getRedirect(FileDescriptor fd) throws ReflectiveOperationException {\n+        \/\/ This is not really allowed, but this is the only way to redirect the output or error stream\n+        \/\/ to the input.  This is definitely not something you'd usually want to do, but in the case of\n+        \/\/ the `tty` utility, it provides a way to get\n+        Class<?> rpi = Class.forName(\"java.lang.ProcessBuilder$RedirectPipeImpl\");\n+        Constructor<?> cns = rpi.getDeclaredConstructor();\n+        cns.setAccessible(true);\n+        ProcessBuilder.Redirect input = (ProcessBuilder.Redirect) cns.newInstance();\n+        Field f = rpi.getDeclaredField(\"fd\");\n+        f.setAccessible(true);\n+        f.set(input, fd);\n+        return input;\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/exec\/ExecTerminalProvider.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.spi;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-\n-import java.io.IOException;\n-import java.nio.charset.Charset;\n-\n-public interface JansiSupport {\n-\n-    Pty current() throws IOException;\n-\n-    Pty open(Attributes attributes, Size size) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException;\n-\n-    boolean isWindowsConsole();\n-\n-    boolean isConsoleOutput();\n-\n-    boolean isConsoleInput();\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/JansiSupport.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.spi;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public interface JnaSupport {\n-\n-    Pty current() throws IOException;\n-\n-    Pty open(Attributes attributes, Size size) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n-\n-    boolean isWindowsConsole();\n-\n-    boolean isConsoleOutput();\n-\n-    boolean isConsoleInput();\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/JnaSupport.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.spi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.Properties;\n+import java.util.ServiceLoader;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.exec.ExecTerminalProvider;\n+\n+public interface TerminalProvider\n+{\n+\n+    enum Stream {\n+        Input,\n+        Output,\n+        Error\n+    }\n+\n+    String name();\n+\n+    Terminal sysTerminal(String name, String type, boolean ansiPassThrough,\n+                         Charset encoding, boolean nativeSignals,\n+                         Terminal.SignalHandler signalHandler, boolean paused,\n+                         Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n+\n+    Terminal newTerminal(String name, String type,\n+                         InputStream masterInput, OutputStream masterOutput,\n+                         Charset encoding, Terminal.SignalHandler signalHandler,\n+                         boolean paused, Attributes attributes, Size size) throws IOException;\n+\n+    boolean isSystemStream(Stream stream);\n+\n+    String systemStreamName(Stream stream);\n+\n+    static TerminalProvider load(String name) throws IOException {\n+        switch (name) {\n+            case \"exec\": return new ExecTerminalProvider();\n+            case \"jna\": {\n+                try {\n+                    return (TerminalProvider) Class.forName(\"jdk.internal.org.jline.terminal.impl.jna.JnaTerminalProvider\").getConstructor().newInstance();\n+                } catch (ReflectiveOperationException t) {\n+                    throw new IOException(t);\n+                }\n+            }\n+        }\n+        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+        if (cl == null) {\n+            cl = ClassLoader.getSystemClassLoader();\n+        }\n+        InputStream is = cl.getResourceAsStream( \"META-INF\/services\/org\/jline\/terminal\/provider\/\" + name);\n+        if (is != null) {\n+            Properties props = new Properties();\n+            try {\n+                props.load(is);\n+                String className = props.getProperty(\"class\");\n+                if (className == null) {\n+                    throw new IOException(\"No class defined in terminal provider file \" + name);\n+                }\n+                Class<?> clazz = cl.loadClass( className );\n+                return (TerminalProvider) clazz.getConstructor().newInstance();\n+            } catch ( Exception e ) {\n+                throw new IOException(\"Unable to load terminal provider \" + name, e);\n+            }\n+        } else {\n+            throw new IOException(\"Unable to find terminal provider \" + name);\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/TerminalProvider.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -537,1 +537,1 @@\n-            throw new IllegalArgumentException(\"h outside assumed range 0..360: \" + Double.toString(h));\n+            throw new IllegalArgumentException(\"h outside assumed range 0..360: \" + h);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Colors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-import java.util.Stack;\n+import java.util.ArrayDeque;\n@@ -24,2 +24,2 @@\n-    private static Object[] sv = new Object[26];\n-    private static Object[] dv = new Object[26];\n+    private static final Object[] sv = new Object[26];\n+    private static final Object[] dv = new Object[26];\n@@ -71,1 +71,1 @@\n-        Stack<Object> stack = new Stack<>();\n+        ArrayDeque<Object> stack = new ArrayDeque<>();\n@@ -200,1 +200,1 @@\n-                                int v = Integer.valueOf(str.substring(start, index - 1));\n+                                int v = Integer.parseInt(str.substring(start, index - 1));\n@@ -473,1 +473,1 @@\n-            return Integer.valueOf(pop.toString());\n+            return Integer.parseInt(pop.toString());\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Curses.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-        int numLines = Math.max(oldLines.size(), newLines.size());\n+        int numLines = Math.min(rows, Math.max(oldLines.size(), newLines.size()));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Display.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                    .map(Map.Entry::getValue)\n+                    .map(Map.Entry::getKey)\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InfoCmp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,7 +98,3 @@\n-            boolean isInfinite = (timeout <= 0L);\n-            while (!bytes.hasRemaining() && (isInfinite || timeout > 0L)) {\n-                long start = 0;\n-                if (!isInfinite) {\n-                    start = System.currentTimeMillis();\n-                }\n-                int c = reader.read(timeout);\n+            Timeout t = new Timeout(timeout);\n+            while (!bytes.hasRemaining() && !t.elapsed()) {\n+                int c = reader.read(t.timeout());\n@@ -120,3 +116,0 @@\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n@@ -154,2 +147,2 @@\n-            this.bytes = ByteBuffer.allocate(4);\n-            this.chars = CharBuffer.allocate(2);\n+            this.bytes = ByteBuffer.allocate(2048);\n+            this.chars = CharBuffer.allocate(1024);\n@@ -162,7 +155,3 @@\n-            boolean isInfinite = (timeout <= 0L);\n-            while (!chars.hasRemaining() && (isInfinite || timeout > 0L)) {\n-                long start = 0;\n-                if (!isInfinite) {\n-                    start = System.currentTimeMillis();\n-                }\n-                int b = input.read(timeout);\n+            Timeout t = new Timeout(timeout);\n+            while (!chars.hasRemaining() && !t.elapsed()) {\n+                int b = input.read(t.timeout());\n@@ -184,4 +173,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n@@ -201,1 +186,1 @@\n-        public int readBuffered(char[] b) throws IOException {\n+        public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -204,1 +189,3 @@\n-            } else if (b.length == 0) {\n+            } else if (off < 0 || len < 0 || off + len < b.length) {\n+                throw new IllegalArgumentException();\n+            } else if (len == 0) {\n@@ -206,0 +193,4 @@\n+            } else if (chars.hasRemaining()) {\n+                int r = Math.min(len, chars.remaining());\n+                chars.get(b, off, r);\n+                return r;\n@@ -207,32 +198,10 @@\n-                if (chars.hasRemaining()) {\n-                    int r = Math.min(b.length, chars.remaining());\n-                    chars.get(b);\n-                    return r;\n-                } else {\n-                    byte[] buf = new byte[b.length];\n-                    int l = input.readBuffered(buf);\n-                    if (l < 0) {\n-                        return l;\n-                    } else {\n-                        ByteBuffer currentBytes;\n-                        if (bytes.hasRemaining()) {\n-                            int transfer = bytes.remaining();\n-                            byte[] newBuf = new byte[l + transfer];\n-                            bytes.get(newBuf, 0, transfer);\n-                            System.arraycopy(buf, 0, newBuf, transfer, l);\n-                            currentBytes = ByteBuffer.wrap(newBuf);\n-                            bytes.position(0);\n-                            bytes.limit(0);\n-                        } else {\n-                            currentBytes = ByteBuffer.wrap(buf, 0, l);\n-                        }\n-                        CharBuffer chars = CharBuffer.wrap(b);\n-                        decoder.decode(currentBytes, chars, false);\n-                        chars.flip();\n-                        if (currentBytes.hasRemaining()) {\n-                            int pos = bytes.position();\n-                            bytes.limit(bytes.limit() + currentBytes.remaining());\n-                            bytes.put(currentBytes);\n-                            bytes.position(pos);\n-                        }\n-                        return chars.remaining();\n+                Timeout t = new Timeout(timeout);\n+                while (!chars.hasRemaining() && !t.elapsed()) {\n+                    if (!bytes.hasRemaining()) {\n+                        bytes.position(0);\n+                        bytes.limit(0);\n+                    }\n+                    int nb = input.readBuffered(bytes.array(), bytes.limit(),\n+                                            bytes.capacity() - bytes.limit(), t.timeout());\n+                    if (nb < 0) {\n+                        return nb;\n@@ -240,0 +209,4 @@\n+                    bytes.limit(bytes.limit() + nb);\n+                    chars.clear();\n+                    decoder.decode(bytes, chars, false);\n+                    chars.flip();\n@@ -241,0 +214,3 @@\n+                int nb = Math.min(len, chars.remaining());\n+                chars.get(b, off, nb);\n+                return nb;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlocking.java","additions":33,"deletions":57,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -82,0 +82,8 @@\n+        return readBuffered(b, 0L);\n+    }\n+\n+    public int readBuffered(byte[] b, long timeout) throws IOException {\n+        return readBuffered(b, 0, b.length, timeout);\n+    }\n+\n+    public int readBuffered(byte[] b, int off, int len, long timeout) throws IOException {\n@@ -84,1 +92,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -87,1 +97,13 @@\n-            return super.read(b, 0, b.length);\n+            Timeout t = new Timeout(timeout);\n+            int nb = 0;\n+            while (!t.elapsed()) {\n+                int r = read(nb > 0 ? 1 : t.timeout());\n+                if (r < 0) {\n+                    return nb > 0 ? nb : r;\n+                }\n+                b[off + nb++] = (byte) r;\n+                if (nb >= len || t.isInfinite()) {\n+                    break;\n+                }\n+            }\n+            return nb;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStream.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -126,2 +126,0 @@\n-            boolean isInfinite = (timeout <= 0L);\n-\n@@ -132,3 +130,2 @@\n-            while (isInfinite || timeout > 0L)  {\n-                long start = System.currentTimeMillis ();\n-\n+            Timeout t = new Timeout(timeout);\n+            while (!t.elapsed())  {\n@@ -139,1 +136,1 @@\n-                    wait(timeout);\n+                    wait(t.timeout());\n@@ -158,4 +155,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStreamImpl.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,6 +48,2 @@\n-        boolean isInfinite = (timeout <= 0L);\n-        long end = 0;\n-        if (!isInfinite) {\n-            end = System.currentTimeMillis() + timeout;\n-        }\n-        while (!closed && !buffer.hasRemaining() && (isInfinite || timeout > 0L)) {\n+        Timeout t = new Timeout(timeout);\n+        while (!closed && !buffer.hasRemaining() && !t.elapsed()) {\n@@ -57,1 +53,1 @@\n-                wait(timeout);\n+                wait(t.timeout());\n@@ -63,3 +59,0 @@\n-            if (!isInfinite) {\n-                timeout = end - System.currentTimeMillis();\n-            }\n@@ -110,7 +103,15 @@\n-    public synchronized int readBuffered(byte[] b) throws IOException {\n-        checkIoException();\n-        int res = wait(readBuffer, 0L);\n-        if (res >= 0) {\n-            res = 0;\n-            while (res < b.length && readBuffer.hasRemaining()) {\n-                b[res++] = (byte) (readBuffer.get() & 0x00FF);\n+    public synchronized int readBuffered(byte[] b, int off, int len, long timeout) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n+            return 0;\n+        } else {\n+            checkIoException();\n+            int res = wait(readBuffer, timeout);\n+            if (res >= 0) {\n+                res = 0;\n+                while (res < len && readBuffer.hasRemaining()) {\n+                    b[off + res++] = (byte) (readBuffer.get() & 0x00FF);\n+                }\n@@ -118,0 +119,2 @@\n+            rewind(readBuffer, writeBuffer);\n+            return res;\n@@ -119,2 +122,0 @@\n-        rewind(readBuffer, writeBuffer);\n-        return res;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpInputStream.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-    public int readBuffered(char[] b) throws IOException {\n+    public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -112,1 +112,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -120,1 +122,7 @@\n-                        notEmpty.await();\n+                        if (timeout > 0) {\n+                            if (!notEmpty.await(timeout, TimeUnit.MILLISECONDS)) {\n+                                throw new IOException( \"Timeout reading\" );\n+                            }\n+                        } else {\n+                            notEmpty.await();\n+                        }\n@@ -130,1 +138,1 @@\n-                    int r = Math.min(b.length, count);\n+                    int r = Math.min(len, count);\n@@ -132,1 +140,1 @@\n-                        b[i] = buffer[read++];\n+                        b[off + i] = buffer[read++];\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpReader.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -88,1 +88,9 @@\n-    public abstract int readBuffered(char[] b) throws IOException;\n+    public int readBuffered(char[] b) throws IOException {\n+        return readBuffered(b, 0L);\n+    }\n+\n+    public int readBuffered(char[] b, long timeout) throws IOException {\n+        return readBuffered(b, 0, b.length, timeout);\n+    }\n+\n+    public abstract int readBuffered(char[] b, int off, int len, long timeout) throws IOException;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReader.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    public int readBuffered(char[] b) throws IOException {\n+    public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -97,1 +97,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -108,2 +110,2 @@\n-        } else if (!threadIsReading) {\n-            return in.read(b);\n+        } else if (!threadIsReading && timeout <= 0) {\n+            return in.read(b, off, len);\n@@ -111,1 +113,2 @@\n-            int c = read(-1, false);\n+            \/\/ TODO: rework implementation to read as much as possible\n+            int c = read(timeout, false);\n@@ -113,1 +116,1 @@\n-                b[0] = (char) c;\n+                b[off] = (char) c;\n@@ -116,1 +119,1 @@\n-                return -1;\n+                return c;\n@@ -161,2 +164,0 @@\n-            boolean isInfinite = (timeout <= 0L);\n-\n@@ -167,3 +168,2 @@\n-            while (isInfinite || timeout > 0L)  {\n-                long start = System.currentTimeMillis ();\n-\n+            Timeout t = new Timeout(timeout);\n+            while (!t.elapsed())  {\n@@ -174,1 +174,1 @@\n-                    wait(timeout);\n+                    wait(t.timeout());\n@@ -193,4 +193,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReaderImpl.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -12,0 +12,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n@@ -31,0 +33,6 @@\n+    public static final boolean IS_WSL = System.getenv(\"WSL_DISTRO_NAME\") != null;\n+\n+    public static final boolean IS_WSL1 = IS_WSL && System.getenv(\"WSL_INTEROP\") == null;\n+\n+    public static final boolean IS_WSL2 = IS_WSL && !IS_WSL1;\n+\n@@ -41,0 +49,1 @@\n+    public static String TEST_COMMAND;\n@@ -47,0 +56,1 @@\n+        String test;\n@@ -48,2 +58,2 @@\n-            tty = \"tty.exe\";\n-            stty = \"stty.exe\";\n+            tty = null;\n+            stty = null;\n@@ -51,1 +61,2 @@\n-            infocmp = \"infocmp.exe\";\n+            infocmp = null;\n+            test = null;\n@@ -65,0 +76,3 @@\n+                    if (test == null && new File(p, \"test.exe\").exists()) {\n+                        test = new File(p, \"test.exe\").getAbsolutePath();\n+                    }\n@@ -67,0 +81,12 @@\n+            if (tty == null) {\n+                tty = \"tty.exe\";\n+            }\n+            if (stty == null) {\n+                stty = \"stty.exe\";\n+            }\n+            if (infocmp == null) {\n+                infocmp = \"infocmp.exe\";\n+            }\n+            if (test == null) {\n+                test = \"test.exe\";\n+            }\n@@ -69,1 +95,2 @@\n-            stty = \"stty\";\n+            stty = IS_OSX ? \"\/bin\/stty\" : \"stty\";\n+            sttyfopt = IS_OSX ? \"-f\" : \"-F\";\n@@ -71,6 +98,2 @@\n-            if (IS_OSX) {\n-                sttyfopt = \"-f\";\n-            }\n-            else {\n-                sttyfopt = \"-F\";\n-            }\n+            test = isTestCommandValid(\"\/usr\/bin\/test\") ? \"\/usr\/bin\/test\"\n+                                                       : \"\/bin\/test\";\n@@ -82,0 +105,1 @@\n+        TEST_COMMAND = test;\n@@ -84,0 +108,3 @@\n+    private static boolean isTestCommandValid(String command) {\n+        return Files.isExecutable(Paths.get(command));\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        char[] buf = new char[bufferSize];\n+        char[] buf = new char[Math.max(bufferSize, 2)];\n@@ -56,3 +56,11 @@\n-    private boolean wait(CharBuffer buffer) throws InterruptedIOException {\n-        if (closed) {\n-            return false;\n+    \/**\n+     * Blocks until more input is available, even if {@link #readBuffer} already\n+     * contains some chars; or until the reader is closed.\n+     *\n+     * @return true if more input is available, false if no additional input is\n+     *              available and the reader is closed\n+     * @throws InterruptedIOException If {@link #wait()} is interrupted\n+     *\/\n+    private boolean waitForMoreInput() throws InterruptedIOException {\n+        if (!writeBuffer.hasRemaining()) {\n+            throw new AssertionError(\"No space in write buffer\");\n@@ -61,2 +69,8 @@\n-        while (!buffer.hasRemaining()) {\n-            \/\/ Wake up waiting readers\/writers\n+        int oldRemaining = readBuffer.remaining();\n+\n+        do {\n+            if (closed) {\n+                return false;\n+            }\n+\n+            \/\/ Wake up waiting writers\n@@ -70,0 +84,4 @@\n+        } while (readBuffer.remaining() <= oldRemaining);\n+\n+        return true;\n+    }\n@@ -71,0 +89,9 @@\n+    \/**\n+     * Waits until {@code buffer.hasRemaining() == true}, or it is false and\n+     * the reader is {@link #closed}.\n+     *\n+     * @return true if {@code buffer.hasRemaining() == true}; false otherwise\n+     *         when reader is closed\n+     *\/\n+    private boolean wait(CharBuffer buffer) throws InterruptedIOException {\n+        while (!buffer.hasRemaining()) {\n@@ -74,0 +101,9 @@\n+\n+            \/\/ Wake up waiting readers\/writers\n+            notifyAll();\n+\n+            try {\n+                wait();\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n@@ -80,1 +116,1 @@\n-     * Blocks until more input is available or the reader is closed.\n+     * Blocks until input is available or the reader is closed.\n@@ -82,1 +118,1 @@\n-     * @return true if more input is available, false if the reader is closed\n+     * @return true if input is available, false if no input is available and the reader is closed\n@@ -97,1 +133,2 @@\n-        if (!wait(writeBuffer)) {\n+        \/\/ Check `closed` to throw even if writer buffer has space available\n+        if (!wait(writeBuffer) || closed) {\n@@ -125,1 +162,3 @@\n-        return rewind(readBuffer, writeBuffer) && readBuffer.hasRemaining();\n+        boolean rw = rewind(readBuffer, writeBuffer) && readBuffer.hasRemaining();\n+        notifyAll();\n+        return rw;\n@@ -134,0 +173,1 @@\n+        notifyAll();\n@@ -205,0 +245,1 @@\n+        int oldPos = output.position();\n@@ -206,2 +247,18 @@\n-        if (rewindReadBuffer() && result.isUnderflow()) {\n-            encoder.encode(readBuffer, output, false);\n+        int encodedCount = output.position() - oldPos;\n+\n+        if (result.isUnderflow()) {\n+            boolean hasMoreInput = rewindReadBuffer();\n+            boolean reachedEndOfInput = false;\n+\n+            \/\/ If encoding did not make any progress must block for more input\n+            if (encodedCount == 0 && !hasMoreInput) {\n+                reachedEndOfInput = !waitForMoreInput();\n+            }\n+\n+            result = encoder.encode(readBuffer, output, reachedEndOfInput);\n+            if (result.isError()) {\n+                result.throwException();\n+            }\n+            if (!reachedEndOfInput && output.position() - oldPos == 0) {\n+                throw new AssertionError(\"Failed to encode any chars\");\n+            }\n@@ -209,0 +266,6 @@\n+        } else if (result.isOverflow()) {\n+            if (encodedCount == 0) {\n+                throw new AssertionError(\"Output buffer has not enough space\");\n+            }\n+        } else {\n+            result.throwException();\n@@ -337,1 +400,1 @@\n-            this.buffer = ByteBuffer.allocate((int) Math.ceil(encoder.maxBytesPerChar()));\n+            this.buffer = ByteBuffer.allocate((int) Math.ceil(encoder.maxBytesPerChar() * 2));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/PumpReader.java","additions":76,"deletions":13,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-            String name = spec.substring(1, spec.length());\n+            String name = spec.substring(1);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/StyleResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2002-2018, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.utils;\n+\n+\/**\n+ * Helper class ti use during I\/O operations with an eventual timeout.\n+ *\/\n+public class Timeout {\n+\n+    private final long timeout;\n+    private long cur = 0;\n+    private long end = Long.MAX_VALUE;\n+\n+    public Timeout(long timeout) {\n+        this.timeout = timeout;\n+    }\n+\n+    public boolean isInfinite() {\n+        return timeout <= 0;\n+    }\n+\n+    public boolean isFinite() {\n+        return timeout > 0;\n+    }\n+\n+    public boolean elapsed() {\n+        if (timeout > 0) {\n+            cur = System.currentTimeMillis();\n+            if (end == Long.MAX_VALUE) {\n+                end = cur + timeout;\n+            }\n+            return cur >= end;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public long timeout() {\n+        return timeout > 0 ? Math.max(1, end - cur) : timeout;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Timeout.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -73,0 +73,1 @@\n+                                (ucs >= 0x1f000 && ucs <= 0x1feee) ||\n@@ -126,2 +127,2 @@\n-            new Interval( 0x1D242, 0x1D244 ), new Interval( 0xE0001, 0xE0001 ), new Interval( 0xE0020, 0xE007F ),\n-            new Interval( 0xE0100, 0xE01EF )\n+            new Interval( 0x1D242, 0x1D244 ), new Interval( 0x1F3FB, 0x1F3FF ), new Interval( 0xE0001, 0xE0001 ),\n+            new Interval( 0xE0020, 0xE007F ), new Interval( 0xE0100, 0xE01EF )\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/WCWidth.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-\tcr=^M, cub=\\E[%p1%dD, cub1=\\E[D, cud=\\E[%p1%dB, cud1=\\E[B,\n+\tcr=^M, cub=\\E[%p1%dD, cub1=\\E[D, cud=\\E[%p1%dB, cud1=\\n,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows-vtp.caps","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-\n-    uses jdk.internal.org.jline.terminal.spi.JnaSupport;\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/module-info.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## JLine v3.20.0\n+## JLine v3.22.0\n@@ -44,4 +44,4 @@\n-org.fusesource.jansi version 1.17.1\n-org.apache.sshd 2.1 to 3\n-org.apache.felix.gogo.runtime 1.1.2\n-org.apache.felix.gogo.jline 1.1.4\n+org.fusesource.jansi version 2.4.0\n+org.apache.sshd 2.9.2\n+org.apache.felix.gogo.runtime 1.1.6\n+org.apache.felix.gogo.jline 1.1.8\n@@ -265,1 +265,1 @@\n-Copyright (c) 2004-2017 QOS.ch\n+Copyright (c) 2004-2023 QOS.ch\n","filename":"src\/jdk.internal.le\/share\/legal\/jline.md","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2019, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.JnaSupport;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public class JnaSupportImpl implements JnaSupport {\n-    @Override\n-    public Pty current() throws IOException {\n-\/\/        return JnaNativePty.current();\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Pty open(Attributes attributes, Size size) throws IOException {\n-\/\/        return JnaNativePty.open(attributes, size);\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException {\n-        return winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, false);\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException {\n-        return winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, input -> input);\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, inputStreamWrapper);\n-    }\n-\n-    @Override\n-    public boolean isWindowsConsole() {\n-        return JnaWinSysTerminal.isWindowsConsole();\n-    }\n-\n-    @Override\n-    public boolean isConsoleOutput() {\n-        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n-            throw new UnsupportedOperationException();\n-        } else if (OSUtils.IS_WINDOWS) {\n-            return JnaWinSysTerminal.isConsoleOutput();\n-        }\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public boolean isConsoleInput() {\n-        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n-            throw new UnsupportedOperationException();\n-        } else if (OSUtils.IS_WINDOWS) {\n-            return JnaWinSysTerminal.isConsoleInput();\n-        }\n-        throw new UnsupportedOperationException();\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaSupportImpl.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+public class JnaTerminalProvider implements TerminalProvider\n+{\n+    @Override\n+    public String name() {\n+        return \"jna\";\n+    }\n+\n+\/\/    public Pty current(TerminalProvider.Stream console) throws IOException {\n+\/\/        return JnaNativePty.current(console);\n+\/\/    }\n+\/\/\n+\/\/    public Pty open(Attributes attributes, Size size) throws IOException {\n+\/\/        return JnaNativePty.open(attributes, size);\n+\/\/    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n+    }\n+\n+\/\/    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+\/\/                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+\/\/                                     Stream consoleStream) throws IOException {\n+\/\/        Pty pty = current(consoleStream);\n+\/\/        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler);\n+\/\/    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+\/\/        Pty pty = open(attributes, size);\n+\/\/        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+            if (OSUtils.IS_WINDOWS) {\n+                return isWindowsSystemStream(stream);\n+            } else {\n+\/\/                return isPosixSystemStream(stream);\n+                return false;\n+            }\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(Stream stream) {\n+        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n+    }\n+\n+\/\/    public boolean isPosixSystemStream(Stream stream) {\n+\/\/        return JnaNativePty.isPosixSystemStream(stream);\n+\/\/    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+\/\/        if (OSUtils.IS_WINDOWS) {\n+            return null;\n+\/\/        } else {\n+\/\/            return JnaNativePty.posixSystemStreamName(stream);\n+\/\/        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -20,1 +20,1 @@\n-    private final Pointer consoleHandle;\n+    private final Pointer console;\n@@ -23,2 +23,2 @@\n-    JnaWinConsoleWriter(Pointer consoleHandle) {\n-        this.consoleHandle = consoleHandle;\n+    JnaWinConsoleWriter(Pointer console) {\n+        this.console = console;\n@@ -30,1 +30,1 @@\n-            Kernel32.INSTANCE.WriteConsoleW(this.consoleHandle, text, len, this.writtenChars, null);\n+            Kernel32.INSTANCE.WriteConsoleW(this.console, text, len, this.writtenChars, null);\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinConsoleWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -22,1 +22,0 @@\n-\n@@ -25,1 +24,0 @@\n-import jdk.internal.org.jline.terminal.Terminal;\n@@ -27,0 +25,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -34,0 +33,1 @@\n+    private static final Pointer consoleErr = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_ERROR_HANDLE);\n@@ -35,1 +35,12 @@\n-    public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, boolean paused, TerminalProvider.Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        Pointer console;\n+        switch (consoleStream) {\n+            case Output:\n+                console = JnaWinSysTerminal.consoleOut;\n+                break;\n+            case Error:\n+                console = JnaWinSysTerminal.consoleErr;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n+        }\n@@ -41,1 +52,1 @@\n-            writer = new JnaWinConsoleWriter(consoleOut);\n+            writer = new JnaWinConsoleWriter(console);\n@@ -44,1 +55,1 @@\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n+            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n@@ -46,1 +57,1 @@\n-                Kernel32.INSTANCE.SetConsoleMode(consoleOut, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n+                Kernel32.INSTANCE.SetConsoleMode(console, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n@@ -50,1 +61,1 @@\n-                writer = new JnaWinConsoleWriter(consoleOut);\n+                writer = new JnaWinConsoleWriter(console);\n@@ -56,1 +67,1 @@\n-                    writer = new JnaWinConsoleWriter(consoleOut);\n+                    writer = new JnaWinConsoleWriter(console);\n@@ -61,1 +72,1 @@\n-                    writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(consoleOut)), consoleOut);\n+                    writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(console)), console);\n@@ -65,1 +76,1 @@\n-        JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);\n+        JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n@@ -73,12 +84,1 @@\n-    public static boolean isWindowsConsole() {\n-        try {\n-            IntByReference mode = new IntByReference();\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n-            Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n-            return true;\n-        } catch (LastErrorException e) {\n-            return false;\n-        }\n-    }\n-\n-    public static boolean isConsoleOutput() {\n+    public static boolean isWindowsSystemStream(TerminalProvider.Stream stream) {\n@@ -87,11 +87,8 @@\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n-            return true;\n-        } catch (LastErrorException e) {\n-            return false;\n-        }\n-    }\n-\n-    public static boolean isConsoleInput() {\n-        try {\n-            IntByReference mode = new IntByReference();\n-            Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n+            Pointer console;\n+            switch (stream) {\n+                case Input: console = consoleIn; break;\n+                case Output: console = consoleOut; break;\n+                case Error: console = consoleErr; break;\n+                default: return false;\n+            }\n+            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n@@ -104,2 +101,3 @@\n-    JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        super(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);\n+    JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler,\n+            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        super(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinSysTerminal.java","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-provides jdk.internal.org.jline.terminal.spi.JnaSupport with jdk.internal.org.jline.terminal.impl.jna.JnaSupportImpl;\n","filename":"src\/jdk.internal.le\/windows\/classes\/module-info.java.extra","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -59,1 +59,1 @@\n-        var t = new AbstractWindowsTerminal(out, \"test\", \"vt100\", null, -1, false, SignalHandler.SIG_DFL, isWrapper) {\n+        var t = new AbstractWindowsTerminal(out, \"test\", \"vt100\", null, false, SignalHandler.SIG_DFL, isWrapper) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/AbstractWindowsTerminalTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                                    0, true, SignalHandler.SIG_DFL, in -> in) {\n+                                    true, SignalHandler.SIG_DFL, in -> in) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/KeyConversionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8304498\n+ * @summary Verify the OSUtils class is initialized properly\n+ * @modules jdk.internal.le\/jdk.internal.org.jline.utils\n+ *\/\n+\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class OSUtilsTest {\n+    public static void main(String... args) throws Exception {\n+        new OSUtilsTest().run();\n+    }\n+\n+    void run() throws Exception {\n+        runTestTest();\n+    }\n+\n+    void runTestTest() throws Exception {\n+        if (OSUtils.IS_WINDOWS) {\n+            return ; \/\/skip on Windows\n+        }\n+\n+        Process p = new ProcessBuilder(OSUtils.TEST_COMMAND, \"-z\", \"\").inheritIO().start();\n+        if (p.waitFor() != 0) {\n+            throw new AssertionError(\"Unexpected result!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/OSUtilsTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.spi\n@@ -38,0 +39,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -40,2 +42,2 @@\n-    public ExecPtyGetFlagsToSetTest(String name, boolean system) {\n-        super(name, system);\n+    public ExecPtyGetFlagsToSetTest(String name, TerminalProvider.Stream stream) {\n+        super(name, stream);\n@@ -51,1 +53,1 @@\n-            new ExecPtyGetFlagsToSetTest(\"stty\", true);\n+            new ExecPtyGetFlagsToSetTest(\"stty\", TerminalProvider.Stream.Output);\n","filename":"test\/langtools\/jdk\/jshell\/ExecPtyGetFlagsToSetTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}