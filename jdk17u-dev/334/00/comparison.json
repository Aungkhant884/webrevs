{"files":[{"patch":"@@ -419,2 +419,2 @@\n-        constantTag tag = s.get_constant_pool_tag(index);\n-        if (tag.is_long() || tag.is_double()) {\n+        BasicType con_bt = s.get_basic_type_for_constant_at(index);\n+        if (con_bt == T_LONG || con_bt == T_DOUBLE) {\n@@ -423,1 +423,1 @@\n-        } else if (tag.basic_type() == T_OBJECT) {\n+        } else if (con_bt == T_OBJECT) {\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,0 +130,11 @@\n+\n+  bool is_loaded() const {\n+    if (is_valid()) {\n+      if (is_reference_type(basic_type())) {\n+        return as_object()->is_loaded();\n+      } else {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciConstant.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -435,7 +435,0 @@\n-  \/\/ setup up the proper type to return on OOM\n-  ciKlass* fail_type;\n-  if (sym->char_at(0) == JVM_SIGNATURE_ARRAY) {\n-    fail_type = _unloaded_ciobjarrayklass;\n-  } else {\n-    fail_type = _unloaded_ciinstance_klass;\n-  }\n@@ -523,1 +516,0 @@\n-  EXCEPTION_CONTEXT;\n@@ -531,1 +523,1 @@\n-    klass =  ConstantPool::klass_at_if_loaded(cpool, index);\n+    klass = ConstantPool::klass_at_if_loaded(cpool, index);\n@@ -591,1 +583,0 @@\n-  EXCEPTION_CONTEXT;\n@@ -602,1 +593,1 @@\n-      if (cpool->tag_at(index).is_dynamic_constant())\n+      if (cpool->tag_at(index).is_dynamic_constant()) {\n@@ -604,2 +595,2 @@\n-      if (is_reference_type(bt)) {\n-      } else {\n+      }\n+      if (!is_reference_type(bt)) {\n@@ -607,1 +598,3 @@\n-        if (!is_java_primitive(bt))  return ciConstant();\n+        if (!is_java_primitive(bt)) {\n+          return ciConstant();\n+        }\n@@ -642,0 +635,1 @@\n+    EXCEPTION_CONTEXT;\n@@ -658,1 +652,1 @@\n-    return ciConstant();\n+    return ciConstant(T_OBJECT, get_unloaded_klass_mirror(NULL));\n@@ -660,1 +654,0 @@\n-    \/\/ 4881222: allow ldc to take a class type\n@@ -662,5 +655,0 @@\n-    if (HAS_PENDING_EXCEPTION) {\n-      CLEAR_PENDING_EXCEPTION;\n-      record_out_of_memory_failure();\n-      return ciConstant();\n-    }\n@@ -670,1 +658,1 @@\n-  } else if (tag.is_method_type()) {\n+  } else if (tag.is_method_type() || tag.is_method_type_in_error()) {\n@@ -675,1 +663,1 @@\n-  } else if (tag.is_method_handle()) {\n+  } else if (tag.is_method_handle() || tag.is_method_handle_in_error()) {\n@@ -684,2 +672,2 @@\n-  } else if (tag.is_dynamic_constant()) {\n-    return ciConstant();\n+  } else if (tag.is_dynamic_constant() || tag.is_dynamic_constant_in_error()) {\n+    return ciConstant(); \/\/ not supported\n@@ -687,1 +675,1 @@\n-    ShouldNotReachHere();\n+    assert(false, \"unknown tag: %d (%s)\", tag.value(), tag.internal_name());\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":14,"deletions":26,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -252,0 +252,8 @@\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciBytecodeStream::get_basic_type_for_constant_at\n+\/\/\n+BasicType ciBytecodeStream::get_basic_type_for_constant_at(int index) const {\n+  VM_ENTRY_MARK;\n+  return _method->get_Method()->constants()->basic_type_for_constant_at(index);\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  \/\/ Does this instruction contain an index which refes into the CP cache?\n+  \/\/ Does this instruction contain an index which refers into the CP cache?\n@@ -227,1 +227,1 @@\n-  ciConstant get_constant();\n+  ciConstant  get_constant();\n@@ -229,0 +229,1 @@\n+  BasicType   get_basic_type_for_constant_at(int index) const;\n@@ -236,3 +237,11 @@\n-  bool is_unresolved_klass_in_error() const {\n-    constantTag tag = get_constant_pool_tag(get_klass_index());\n-    return tag.is_unresolved_klass_in_error();\n+  bool is_in_error() const {\n+    assert(cur_bc() == Bytecodes::_ldc    ||\n+           cur_bc() == Bytecodes::_ldc_w  ||\n+           cur_bc() == Bytecodes::_ldc2_w, \"not supported: %s\", Bytecodes::name(cur_bc()));\n+\n+    int index = get_constant_pool_index();\n+    constantTag tag = get_constant_pool_tag(index);\n+    return tag.is_unresolved_klass_in_error() ||\n+           tag.is_method_handle_in_error()    ||\n+           tag.is_method_type_in_error()      ||\n+           tag.is_dynamic_constant_in_error();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -723,0 +723,5 @@\n+  if (str->is_in_error()) {\n+    trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                      Deoptimization::Action_none));\n+    return;\n+  }\n@@ -738,8 +743,4 @@\n-    if (str->is_unresolved_klass_in_error()) {\n-      trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n-                                                        Deoptimization::Action_none));\n-    } else {\n-      \/\/ OutOfMemoryError in the CI while loading constant\n-      push_null();\n-      outer()->record_failure(\"ldc did not link\");\n-    }\n+    \/\/ OutOfMemoryError in the CI while loading constant.\n+    \/\/ Unresolved condy also lands here (not yet supported).\n+    push_null();\n+    outer()->record_failure(\"ldc did not link\");\n@@ -2176,1 +2177,1 @@\n-      return str.is_unresolved_klass_in_error();\n+      return str.is_in_error();\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -887,2 +887,1 @@\n-  if (tag.is_dynamic_constant() ||\n-      tag.is_dynamic_constant_in_error()) {\n+  if (tag.is_dynamic_constant()) {\n@@ -890,2 +889,1 @@\n-    \/\/ dynamic constant could return an array, treat as object\n-    return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);\n+    return constantTag(constantTag::type2tag(bt));\n@@ -978,1 +976,0 @@\n-  case JVM_CONSTANT_UnresolvedClassInError:\n@@ -1046,8 +1043,0 @@\n-  case JVM_CONSTANT_DynamicInError:\n-  case JVM_CONSTANT_MethodHandleInError:\n-  case JVM_CONSTANT_MethodTypeInError:\n-    {\n-      throw_resolution_error(this_cp, index, CHECK_NULL);\n-      break;\n-    }\n-\n@@ -1067,1 +1056,4 @@\n-      Klass* callee = klass_at_impl(this_cp, callee_index, CHECK_NULL);\n+      Klass* callee = klass_at_impl(this_cp, callee_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n+      }\n@@ -1071,1 +1063,1 @@\n-          ((!callee->is_interface() && m_tag.is_interface_method()))) {\n+          (!callee->is_interface() && m_tag.is_interface_method())) {\n@@ -1083,1 +1075,2 @@\n-        THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());\n+        Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \"%s\", ss.as_string());\n+        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n@@ -1090,1 +1083,0 @@\n-      result_oop = value();\n@@ -1094,0 +1086,1 @@\n+      result_oop = value();\n@@ -1138,0 +1131,7 @@\n+  case JVM_CONSTANT_UnresolvedClassInError:\n+  case JVM_CONSTANT_DynamicInError:\n+  case JVM_CONSTANT_MethodHandleInError:\n+  case JVM_CONSTANT_MethodTypeInError:\n+    throw_resolution_error(this_cp, index, CHECK_NULL);\n+    break;\n+\n@@ -1139,3 +1139,1 @@\n-    DEBUG_ONLY( tty->print_cr(\"*** %p: tag at CP[%d\/%d] = %d\",\n-                              this_cp(), index, cache_index, tag.value()));\n-    assert(false, \"unexpected constant tag\");\n+    fatal(\"unexpected constant tag at CP %p[%d\/%d] = %d\", this_cp(), index, cache_index, tag.value());\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1879,0 +1879,1 @@\n+\n@@ -1881,16 +1882,3 @@\n-  case Bytecodes::_ldc2_w:\n-    \/\/ If the constant is unresolved, run this BC once in the interpreter.\n-    {\n-      ciConstant constant = iter().get_constant();\n-      if (!constant.is_valid() ||\n-          (constant.basic_type() == T_OBJECT &&\n-           !constant.as_object()->is_loaded())) {\n-        int index = iter().get_constant_pool_index();\n-        constantTag tag = iter().get_constant_pool_tag(index);\n-        uncommon_trap(Deoptimization::make_trap_request\n-                      (Deoptimization::Reason_unloaded,\n-                       Deoptimization::Action_reinterpret,\n-                       index),\n-                      NULL, tag.internal_name());\n-        break;\n-      }\n+  case Bytecodes::_ldc2_w: {\n+    ciConstant constant = iter().get_constant();\n+    if (constant.is_loaded()) {\n@@ -1903,1 +1891,6 @@\n-    }\n+    } else {\n+      \/\/ If the constant is unresolved or in error state, run this BC in the interpreter.\n+      if (iter().is_in_error()) {\n+        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                        Deoptimization::Action_none),\n+                      NULL, \"constant in error state\", true \/* must_throw *\/);\n@@ -1905,0 +1898,8 @@\n+      } else {\n+        int index = iter().get_constant_pool_index();\n+        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unloaded,\n+                                                        Deoptimization::Action_reinterpret,\n+                                                        index),\n+                      NULL, \"unresolved constant\", false \/* must_throw *\/);\n+      }\n+    }\n@@ -1906,0 +1907,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -89,0 +89,7 @@\n+  bool is_in_error() const {\n+    return is_unresolved_klass_in_error() ||\n+           is_method_handle_in_error()    ||\n+           is_method_type_in_error()      ||\n+           is_dynamic_constant_in_error();\n+  }\n+\n@@ -124,2 +131,7 @@\n-  static constantTag ofBasicType(BasicType bt) {\n-    if (is_subword_type(bt))  bt = T_INT;\n+  static jbyte type2tag(BasicType bt) {\n+    if (is_subword_type(bt)) {\n+      bt = T_INT;\n+    }\n+    if (bt == T_ARRAY) {\n+      bt = T_OBJECT;\n+    }\n@@ -127,6 +139,9 @@\n-      case T_OBJECT: return constantTag(JVM_CONSTANT_String);\n-      case T_INT:    return constantTag(JVM_CONSTANT_Integer);\n-      case T_LONG:   return constantTag(JVM_CONSTANT_Long);\n-      case T_FLOAT:  return constantTag(JVM_CONSTANT_Float);\n-      case T_DOUBLE: return constantTag(JVM_CONSTANT_Double);\n-      default:       break;\n+      case T_INT:    return JVM_CONSTANT_Integer;\n+      case T_LONG:   return JVM_CONSTANT_Long;\n+      case T_FLOAT:  return JVM_CONSTANT_Float;\n+      case T_DOUBLE: return JVM_CONSTANT_Double;\n+      case T_OBJECT: return JVM_CONSTANT_String;\n+\n+      default:\n+        assert(false, \"not supported: %s\", type2name(bt));\n+        return JVM_CONSTANT_Invalid;\n@@ -134,2 +149,0 @@\n-    assert(false, \"bad basic type for tag\");\n-    return constantTag();\n","filename":"src\/hotspot\/share\/utilities\/constantTag.hpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8279822\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *\n+ * @run main compiler.runtime.TestConstantsInError\n+ *\/\n+package compiler.runtime;\n+\n+import jdk.internal.org.objectweb.asm.*;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static jdk.internal.org.objectweb.asm.ClassWriter.*;\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+interface OutputProcessor {\n+    default void process(OutputAnalyzer output, boolean isC1) {}\n+}\n+\n+public abstract class TestConstantsInError implements OutputProcessor {\n+    static final String TEST_PREFIX = class2desc(TestConstantsInError.class) + \"$Test\";\n+\n+    public interface Test extends Runnable {}\n+\n+\n+    interface Generator {\n+        void generate(MethodVisitor mv);\n+    }\n+\n+    static String class2desc(Class<?> cls) {\n+        return cls.getName().replace('.', '\/');\n+    }\n+\n+    public static final String PATH = System.getProperty(\"test.classes\", \".\") + java.io.File.separator;\n+\n+    static byte[] generateClassFile(String suffix, Generator g) throws IOException {\n+        var cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+        String name = TEST_PREFIX + \"_\" + suffix;\n+        cw.visit(V17, ACC_PUBLIC | ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n+\n+        {\n+            var mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"test\", \"()V\", null, null);\n+            mv.visitCode();\n+            g.generate(mv);\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+        }\n+        byte[] classFile = cw.toByteArray();\n+\n+        try (FileOutputStream fos = new FileOutputStream(PATH + name + \".class\")) {\n+            fos.write(classFile);\n+        }\n+\n+        return classFile;\n+    }\n+\n+    static Test generate(String suffix, Class<? extends LinkageError> expectedError, Generator g) {\n+        try {\n+            byte[] classFile = generateClassFile(suffix, g);\n+            MethodHandles.Lookup testLookup = MethodHandles.lookup().defineHiddenClass(classFile, true);\n+            MethodHandle testMH = testLookup.findStatic(testLookup.lookupClass(), \"test\", MethodType.methodType(void.class));\n+\n+            testMH = MethodHandles.filterReturnValue(testMH,\n+                    MethodHandles.insertArguments(\n+                            MethodHandles.throwException(void.class, AssertionError.class),\n+                            0, new AssertionError(\"no exception thrown\")));\n+\n+            \/\/ Install empty handler for linkage exceptions.\n+            testMH = MethodHandles.catchException(testMH, expectedError,\n+                     MethodHandles.empty(MethodType.methodType(void.class, expectedError)));\n+\n+            return MethodHandleProxies.asInterfaceInstance(Test.class, testMH);\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    static void run(String name, Class<? extends LinkageError> expectedError, Generator g) {\n+        Test test = generate(name, expectedError, g);\n+        for (int i = 0; i < 1000; i++) {\n+            test.run();\n+        }\n+    }\n+\n+    static class TestConstantClass extends TestConstantsInError {\n+        public static void main(String[] args) {\n+            run(\"C1\", NoClassDefFoundError.class, mv -> mv.visitLdcInsn(Type.getType(\"LUnknownClass;\")));                \/\/ non-existent class\n+            run(\"C2\",   IllegalAccessError.class, mv -> mv.visitLdcInsn(Type.getType(\"Ljava\/lang\/invoke\/LambdaForm;\"))); \/\/ inaccessible\n+\n+            \/\/ class loader constraints?\n+        }\n+\n+        public void process(OutputAnalyzer results, boolean isC1) {\n+            results.shouldMatch(\"Test_C1\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_C2\/.*::test \\\\(3 bytes\\\\)$\");\n+\n+            if (isC1 && Platform.isAArch64()) { \/\/ no code patching\n+                results.shouldMatch(\"Test_C1\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_C2\/.*::test \\\\(3 bytes\\\\)   made not entrant\");\n+            } else {\n+                results.shouldNotContain(\"made not entrant\");\n+            }\n+        }\n+\n+        public void processC2(OutputAnalyzer results) {\n+            results.shouldNotContain(\"made not entrant\");\n+        }\n+    }\n+\n+    static class TestConstantMethodHandle extends TestConstantsInError {\n+        public static void main(String[] args) {\n+            \/\/ Non-existent holder class\n+            run(\"MH1\", NoClassDefFoundError.class,\n+                mv -> mv.visitLdcInsn(new Handle(H_INVOKESTATIC, \"UnknownClass\", \"ignored\", \"()V\", false)));\n+\n+            \/\/ Inaccessible holder class\n+            run(\"MH2\", IllegalAccessError.class,\n+                    mv -> mv.visitLdcInsn(new Handle(H_INVOKESTATIC, \"java\/lang\/invoke\/LambdaForm\", \"ignored\", \"()V\", false)));\n+\n+            \/\/ Method vs InterfaceMethod mismatch\n+            run(\"MH3\", IncompatibleClassChangeError.class,\n+                mv -> mv.visitLdcInsn(new Handle(H_INVOKESTATIC, \"java\/lang\/Object\", \"ignored\", \"()V\", true)));\n+\n+            \/\/ Non-existent method\n+            run(\"MH4\", NoSuchMethodError.class,\n+                mv -> mv.visitLdcInsn(new Handle(H_INVOKESTATIC, \"java\/lang\/Object\", \"cast\", \"()V\", false)));\n+        }\n+\n+        public void process(OutputAnalyzer results, boolean isC1) {\n+            results.shouldMatch(\"Test_MH1\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_MH2\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_MH3\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_MH4\/.*::test \\\\(3 bytes\\\\)$\");\n+\n+            if (isC1 && Platform.isAArch64()) { \/\/ no code patching\n+                results.shouldMatch(\"Test_MH1\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_MH2\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_MH3\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_MH4\/.*::test \\\\(3 bytes\\\\)   made not entrant\");\n+            } else {\n+                results.shouldNotContain(\"made not entrant\");\n+            }\n+        }\n+    }\n+\n+    static class TestConstantMethodType extends TestConstantsInError {\n+        public static void main(String[] args) {\n+            run(\"MT1\", NoClassDefFoundError.class,\n+                mv -> mv.visitLdcInsn(Type.getMethodType(\"(LUnknownClass;)V\")));\n+            run(\"MT2\", NoClassDefFoundError.class,\n+                mv -> mv.visitLdcInsn(Type.getMethodType(\"()LUnknownClass;\")));\n+        }\n+\n+        public void process(OutputAnalyzer results, boolean isC1) {\n+            results.shouldMatch(\"Test_MT1\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_MT2\/.*::test \\\\(3 bytes\\\\)$\");\n+\n+            if (isC1 && Platform.isAArch64()) { \/\/ no code patching\n+                results.shouldMatch(\"Test_MT1\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_MT2\/.*::test \\\\(3 bytes\\\\)   made not entrant\");\n+            } else {\n+                results.shouldNotContain(\"made not entrant\");\n+            }\n+        }\n+    }\n+\n+    static class TestConstantDynamic extends TestConstantsInError {\n+        static int bsm1() throws Exception {\n+            throw new AssertionError(\"should not be invoked\");\n+        }\n+\n+        static int bsm2(MethodHandles.Lookup lookup, String name, Class c) throws Exception {\n+            throw new Exception(\"expected\");\n+        }\n+\n+        static final Handle BSM1 = new Handle(H_INVOKESTATIC, class2desc(TestConstantDynamic.class), \"bsm1\", \"()I\", false);\n+        static final Handle BSM2 = new Handle(H_INVOKESTATIC, class2desc(TestConstantDynamic.class), \"bsm2\",\n+                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)I\",\n+                false);\n+\n+        public static void main(String[] args) {\n+            run(\"CD1\", NoClassDefFoundError.class,\n+                    mv -> {\n+                        Handle bsm = new Handle(H_INVOKESTATIC, \"UnknownClass\", \"unknown\", \"()LUnknownClass;\", false);\n+                        mv.visitLdcInsn(new ConstantDynamic(\"tmp\", \"LUnknownClass;\", bsm));\n+                    });\n+            run(\"CD2\", NoSuchMethodError.class,\n+                    mv -> {\n+                        Handle bsm = new Handle(H_INVOKESTATIC, class2desc(TestConstantDynamic.class), \"unknown\", \"()I\", false);\n+                        mv.visitLdcInsn(new ConstantDynamic(\"tmp\", \"LUnknownClass;\", bsm));\n+                    });\n+            run(\"CD3\", BootstrapMethodError.class, mv -> mv.visitLdcInsn(new ConstantDynamic(\"tmp\", \"I\", BSM1)));\n+            run(\"CD4\", BootstrapMethodError.class, mv -> mv.visitLdcInsn(new ConstantDynamic(\"tmp\", \"I\", BSM2)));\n+        }\n+\n+        public void process(OutputAnalyzer results, boolean isC1) {\n+            if (isC1) {\n+                results.shouldMatch(\"Test_CD1.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n+                       .shouldMatch(\"Test_CD2.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n+                       .shouldMatch(\"Test_CD3.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n+                       .shouldMatch(\"Test_CD4.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\");\n+            } else {\n+                results.shouldMatch(\"Test_CD1.*::test \\\\(3 bytes\\\\)$\")\n+                       .shouldMatch(\"Test_CD2.*::test \\\\(3 bytes\\\\)$\")\n+                       .shouldMatch(\"Test_CD3.*::test \\\\(3 bytes\\\\)$\")\n+                       .shouldMatch(\"Test_CD4.*::test \\\\(3 bytes\\\\)$\");\n+            }\n+        }\n+    }\n+\n+    static void run(TestConstantsInError test) throws Exception {\n+        List<String> commonArgs = List.of(\n+                \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+                \"-Xbatch\", \"-XX:CompileThreshold=100\",\n+                \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,*::test\",\n+                \"-XX:+PrintCompilation\",\n+                \"-XX:CompileCommand=print,*::test\",\n+                \"-Dtest.classes=\" + System.getProperty(\"test.classes\", \".\"),\n+                \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                test.getClass().getName());\n+\n+        ArrayList<String> c1Args = new ArrayList<>();\n+        c1Args.addAll(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\", \"-XX:+TracePatching\"));\n+        c1Args.addAll(commonArgs);\n+\n+        OutputAnalyzer outputC1 = ProcessTools.executeTestJvm(c1Args)\n+                .shouldHaveExitValue(0);\n+\n+        test.process(outputC1, true);\n+\n+        ArrayList<String> c2Args = new ArrayList<>();\n+        c2Args.add(\"-XX:-TieredCompilation\");\n+        c2Args.addAll(commonArgs);\n+\n+        OutputAnalyzer outputC2 = ProcessTools.executeTestJvm(c2Args)\n+                .shouldHaveExitValue(0);\n+\n+        test.process(outputC2, false);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        run(new TestConstantClass());\n+        run(new TestConstantMethodType());\n+        run(new TestConstantMethodHandle());\n+        run(new TestConstantDynamic());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/TestConstantsInError.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"}]}