{"files":[{"patch":"@@ -76,0 +76,1 @@\n+    unsigned int handlingAppResume : 1;\n@@ -658,1 +659,4 @@\n-                if (!(state & JVMTI_THREAD_STATE_SUSPENDED)) {\n+                \/* !node->handlingAppResume && resumeFrameDepth > 0\n+                 * means the thread has entered Thread.resume() *\/\n+                if (!(state & JVMTI_THREAD_STATE_SUSPENDED) &&\n+                    !node->handlingAppResume) {\n@@ -731,0 +735,5 @@\n+\/*\n+ * The caller is expected to hold threadLock and handlerLock.\n+ * eventHandler_createInternalThreadOnly() can deadlock because of\n+ * wrong lock ordering if the caller does not hold handlerLock.\n+ *\/\n@@ -779,1 +788,0 @@\n-    jthread resumee = getResumee(resumer);\n@@ -782,7 +790,0 @@\n-    if (resumee != NULL) {\n-        \/*\n-         * Hold up any attempt to resume as long as the debugger\n-         * has suspended the resumee.\n-         *\/\n-        blockOnDebuggerSuspend(resumee);\n-    }\n@@ -790,0 +791,5 @@\n+    \/*\n+     * Actual handling has to be deferred. We cannot block right here if the\n+     * target of the resume call is suspended by the debugger since we are\n+     * holding handlerLock which must not be released. See doPendingTasks().\n+     *\/\n@@ -791,10 +797,4 @@\n-        \/*\n-         * Track the resuming thread by marking it as being within\n-         * a resume and by setting up for notification on\n-         * a frame pop or exception. We won't allow the debugger\n-         * to suspend threads while any thread is within a\n-         * call to resume. This (along with the block above)\n-         * ensures that when the debugger\n-         * suspends a thread it will remain suspended.\n-         *\/\n-        trackAppResume(resumer);\n+        ThreadNode* node = findThread(&runningThreads, resumer);\n+        if (node != NULL) {\n+            node->handlingAppResume = JNI_TRUE;\n+        }\n@@ -2158,0 +2158,53 @@\n+    \/* Deferred breakpoint handling for Thread.resume() *\/\n+    if (node->handlingAppResume) {\n+        jthread resumer = node->thread;\n+        jthread resumee = getResumee(resumer);\n+\n+        if (resumer != NULL) {\n+            \/*\n+             * trackAppResume indirectly aquires handlerLock. For proper lock\n+             * ordering handlerLock has to be acquired before threadLock.\n+             *\/\n+            debugMonitorExit(threadLock);\n+            eventHandler_lock();\n+            debugMonitorEnter(threadLock);\n+\n+            \/*\n+             * Track the resuming thread by marking it as being within\n+             * a resume and by setting up for notification on\n+             * a frame pop or exception. We won't allow the debugger\n+             * to suspend threads while any thread is within a\n+             * call to resume. This (along with the block below)\n+             * ensures that when the debugger\n+             * suspends a thread it will remain suspended.\n+             *\/\n+            trackAppResume(resumer);\n+\n+            \/*\n+             * handlerLock is not needed anymore. We must release it before calling\n+             * blockOnDebuggerSuspend() because it is required for resumes done by\n+             * the debugger. If resumee is currently suspended by the debugger, then\n+             * blockOnDebuggerSuspend() will block until a debugger resume is done.\n+             * If it blocks while holding the handlerLock, then the resume will deadlock.\n+             *\/\n+            eventHandler_unlock();\n+        }\n+\n+        if (resumee != NULL) {\n+            \/*\n+             * Hold up any attempt to resume as long as the debugger\n+             * has suspended the resumee.\n+             *\/\n+            blockOnDebuggerSuspend(resumee);\n+        }\n+\n+        node->handlingAppResume = JNI_FALSE;\n+\n+        \/*\n+         * The blocks exit condition: resumee's suspendCount == 0.\n+         *\n+         * Debugger suspends are blocked if any thread is executing\n+         * Thread.resume(), i.e. !handlingAppResume && frameDepth > 0.\n+         *\/\n+    }\n+\n@@ -2458,0 +2511,2 @@\n+    \/* Threads could be waiting in blockOnDebuggerSuspend *\/\n+    debugMonitorNotifyAll(threadLock);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":74,"deletions":19,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8274687\n+ * @summary Test the special handling in the JDWP agent of threads that call\n+ *          j.l.Thread.resume().\n+ *\n+ *          This is the sequence of actions by the debugger and the threads\n+ *          \"main\" and \"resumee\" in the target vm.\n+ *\n+ *          \"resumee\": Reaches breakpoint in methodWithBreakpoint() and is\n+ *                     suspended then.\n+ *\n+ *          \"main\": Calls j.l.Thread.resume() for \"resumee\". There is an internal\n+ *                  breakpoint in Thread.resume() so the JDWP agent receives a\n+ *                  breakpoint event. It finds that \"resumee\" is suspended because\n+ *                  of JDWP actions. The resume() call would interfere with the\n+ *                  debugger therefore \"main\" is blocked.\n+ *\n+ *          Debugger: Tests if the suspended \"resumee\" can be suspended a second\n+ *                    time and resumes it again.\n+ *\n+ *          Debugger: Resumes \"resumee\" by calling ThreadReference.resume().\n+ *                    The JDWP agent notifies \"main\" about it.\n+ *\n+ *          \"resumee\": Continues execution.\n+ *\n+ *          \"main\": Receives the notification, finds that \"resumee\" is not\n+ *                  suspended anymore and continues execution.\n+ *\n+ *          Debugger: Verifies that \"main\" is no longer blocked.\n+ *\n+ * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g ResumeAfterThreadResumeCallTest.java\n+ * @run driver ResumeAfterThreadResumeCallTest\n+ *\/\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import jdk.test.lib.Asserts;\n+\n+import java.util.*;\n+\n+\/\/ Target program for the debugger\n+class ResumeAfterThreadResumeCallTarg extends Thread {\n+\n+    public boolean reachedBreakpoint;\n+    public boolean mainThreadReturnedFromResumeCall;\n+    public boolean testFinished;\n+\n+    public ResumeAfterThreadResumeCallTarg(String name) {\n+        super(name);\n+    }\n+\n+    public static void log(String m) {\n+        String threadName = Thread.currentThread().getName();\n+        System.out.println(\"###(Target,\"+ threadName +\") \" + m);\n+    }\n+\n+    public static void main(String[] args) {\n+        log(\"Entered main()\");\n+\n+        \/\/ Start \"resumee\" thread.\n+        ResumeAfterThreadResumeCallTarg resumee = new ResumeAfterThreadResumeCallTarg(\"resumee\");\n+        resumee.start();\n+\n+        \/\/ Wait for \"resumee\" to reach the breakpoint in methodWithBreakpoint().\n+        while (!resumee.reachedBreakpoint) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) { \/* ignored *\/ }\n+        }\n+\n+        \/\/ \"resumee\" is suspended now because of the breakpoint\n+        \/\/ Calling Thread.resume() will block this thread.\n+        log(\"Calling Thread.resume()\");\n+        resumee.resume();\n+        resumee.mainThreadReturnedFromResumeCall = true;\n+        log(\"Thread.resume() returned\");\n+\n+        \/\/ Wait for debugger\n+        while (!resumee.testFinished) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) { \/* ignored *\/ }\n+        }\n+    }\n+\n+    public void run() {\n+        log(\"up and running.\");\n+        methodWithBreakpoint();\n+    }\n+\n+    public void methodWithBreakpoint() {\n+        log(\"Entered methodWithBreakpoint()\");\n+    }\n+}\n+\n+\n+\/\/ Debugger program\n+\n+public class ResumeAfterThreadResumeCallTest extends TestScaffold {\n+    public static final String TARGET_CLS_NAME = ResumeAfterThreadResumeCallTarg.class.getName();\n+    public static final long UNBLOCK_TIMEOUT = 10000;\n+\n+    ResumeAfterThreadResumeCallTest (String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new ResumeAfterThreadResumeCallTest(args).startTests();\n+    }\n+\n+    \/**\n+     * Set a breakpoint in the given method and resume all threads. The\n+     * breakpoint is configured to suspend just the thread that reaches it\n+     * instead of all threads.\n+     *\/\n+    public BreakpointEvent resumeTo(String clsName, String methodName, String signature) {\n+        boolean suspendThreadOnly = true;\n+        return resumeTo(clsName, methodName, signature, suspendThreadOnly);\n+    }\n+\n+    protected void runTests() throws Exception {\n+        BreakpointEvent bpe = startToMain(TARGET_CLS_NAME);\n+        mainThread = bpe.thread();\n+\n+        log(\"Resuming to methodWithBreakpoint()\");\n+        bpe = resumeTo(TARGET_CLS_NAME, \"methodWithBreakpoint\", \"()V\");\n+\n+        log(\"Thread \\\"resumee\\\" has reached the breakpoint and is suspended now.\");\n+        ThreadReference resumee = bpe.thread();\n+        ObjectReference resumeeThreadObj = resumee.frame(1).thisObject();\n+        printStack(resumee);\n+        mainThread.suspend();\n+        printStack(mainThread);\n+        mainThread.resume();\n+        log(\"resumee.isSuspended() -> \" + resumee.isSuspended());\n+        log(\"mainThread.isSuspended() -> \" + mainThread.isSuspended());\n+        log(\"Notify target main thread to continue by setting reachedBreakpoint = true.\");\n+        setField(resumeeThreadObj, \"reachedBreakpoint\", vm().mirrorOf(true));\n+\n+        log(\"Sleeping 500ms so that the main thread is blocked calling Thread.resume() on \\\"resumee\\\" Thread.\");\n+        Thread.sleep(500);\n+        log(\"After sleep.\");\n+        mainThread.suspend();\n+        printStack(mainThread);\n+        mainThread.resume();\n+\n+        boolean mainThreadReturnedFromResumeCall = false;\n+        boolean resumedResumee = false;\n+        for (long sleepTime = 50; sleepTime < UNBLOCK_TIMEOUT && !mainThreadReturnedFromResumeCall; sleepTime <<= 1) {\n+            log(\"mainThread.isSuspended() -> \" + mainThread.isSuspended());\n+            Value v = getField(resumeeThreadObj, \"mainThreadReturnedFromResumeCall\");\n+            mainThreadReturnedFromResumeCall = ((PrimitiveValue) v).booleanValue();\n+            if (!resumedResumee) {\n+                \/\/ main thread should still be blocked.\n+                Asserts.assertFalse(mainThreadReturnedFromResumeCall, \"main Thread was not blocked\");\n+\n+                \/\/ Test suspending the already suspended resumee thread.\n+                Asserts.assertTrue(resumee.isSuspended(), \"\\\"resumee\\\" is not suspended.\");\n+                log(\"Check if suspended \\\"resumee\\\" can be suspended a 2nd time.\");\n+                resumee.suspend();\n+                log(\"resumee.isSuspended() -> \" + resumee.isSuspended());\n+                log(\"Resuming \\\"resumee\\\"\");\n+                resumee.resume();\n+                Asserts.assertTrue(resumee.isSuspended(), \"\\\"resumee\\\" is not suspended.\");\n+\n+                \/\/ Really resume the resumee thread.\n+                log(\"Resuming \\\"resumee\\\" a 2nd time will unblock the main thread.\");\n+                resumee.resume();\n+                Asserts.assertFalse(resumee.isSuspended(), \"\\\"resumee\\\" is still suspended.\");\n+                resumedResumee = true;\n+            }\n+            log(\"Sleeping \" + sleepTime + \"ms\");\n+            Thread.sleep(sleepTime);\n+        }\n+        Asserts.assertTrue(mainThreadReturnedFromResumeCall, \"main Thread was not unblocked\");\n+\n+        setField(resumeeThreadObj, \"testFinished\", vm().mirrorOf(true));\n+\n+        \/\/ Resume the target listening for events\n+        listenUntilVMDisconnect();\n+    }\n+\n+    public void printStack(ThreadReference thread) throws Exception {\n+        log(\"Stack of thread '\" + thread.name() + \"':\");\n+        List<StackFrame> stack_frames = thread.frames();\n+        int i = 0;\n+        for (StackFrame ff : stack_frames) {\n+            Location loc = ff.location();\n+            String locString = \"bci:\" + loc.codeIndex();\n+            try {\n+                locString = loc.sourceName() + \":\" + loc.lineNumber() + \",\" + locString;\n+            } catch (AbsentInformationException e) {\/* empty *\/};\n+            log(\"  frame[\" + i++ +\"]: \" + ff.location().method() + \" (\" + locString + \")\");\n+        }\n+    }\n+\n+    public void setField(ObjectReference obj, String fName, Value val) throws Exception {\n+        log(\"set field \" + fName + \" = \" + val);\n+        ReferenceType rt = obj.referenceType();\n+        Field fld = rt.fieldByName(fName);\n+        obj.setValue(fld, val);\n+        log(\"ok\");\n+    }\n+\n+    public Value getField(ObjectReference obj, String fName) throws Exception {\n+        log(\"get field \" + fName);\n+        ReferenceType rt = obj.referenceType();\n+        Field fld = rt.fieldByName(fName);\n+        Value val = obj.getValue(fld);\n+        log(\"result : \" + val);\n+        return val;\n+    }\n+\n+    public void log(String m) {\n+        System.out.println(\"###(Debugger) \" + m);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ResumeAfterThreadResumeCallTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"}]}