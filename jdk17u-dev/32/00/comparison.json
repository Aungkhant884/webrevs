{"files":[{"patch":"@@ -1177,0 +1177,10 @@\n+\n+  IfNode* n_if = n->as_If();\n+  if (n_if->proj_out(0)->outcnt() > 1 || n_if->proj_out(1)->outcnt() > 1) {\n+    \/\/ Removing the dominated If node by using the split-if optimization does not work if there are data dependencies.\n+    \/\/ Some data dependencies depend on its immediate dominator If node and should not be separated from it (e.g. null\n+    \/\/ checks, division by zero checks etc.). Bail out for now until data dependencies are correctly handled when\n+    \/\/ optimizing back-to-back ifs.\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @bug 8275610\n+ * @summary Null check for field access of object floats above null check resulting in a segfault.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,compiler.loopopts.TestEliminateNullCheckWithSplitIf::test\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=42 compiler.loopopts.TestEliminateNullCheckWithSplitIf\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,compiler.loopopts.TestEliminateNullCheckWithSplitIf::test\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressIGVN compiler.loopopts.TestEliminateNullCheckWithSplitIf\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestEliminateNullCheckWithSplitIf {\n+    public static int[] iArrFld = new int[20];\n+    public static int[] iArrFld2 = new int[20];\n+    public static int iFld = 10;\n+    public static MyClass obj;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10000; i++) {\n+            obj = (i % 100 == 0 ? null : new MyClass());\n+            test();\n+        }\n+    }\n+\n+    \/\/ The field access obj.iFld requires a null check NC3 and adds a not-null CastPP node on the succeeded projection.\n+    \/\/ In the first IGVN after parsing, the null check NC3 can be subsumed by the explicit null check NC2.\n+    \/\/ (done in IfNode::simple_subsuming()). The Bool node of NC2 is also shared with the same null check NC1 earlier.\n+    \/\/ However, C2 cannot remove the null check NC2, yet, because the IR in between the two checks are too complex\n+    \/\/ (IfNode::search_identical() fails).\n+    \/\/ Now, loopopts are applied:\n+    \/\/ (1) First, the split if optimization is done. It recognizes that NC1 and NC2 are back to back null checks and removes\n+    \/\/ the null check NC2 by splitting it through the region R which is removed afterwards. In this process, control dependent\n+    \/\/ data nodes on the out projections of NC2 end up at the new regions R1\/R2 created for each projection for R. They get\n+    \/\/ the last nodes of the if and else block as input. For this example, R1 is a control input to the CastPP node which\n+    \/\/ will merge both true projections.\n+    \/\/ (2) Later in loop opts, the loop L is transformed into normal code and y will become a constant 1.\n+    \/\/ After loopopts, another round of IGVN is done:\n+    \/\/ (These steps also depend on the order in which they are applied in order to trigger the bug)\n+    \/\/ (1) The region R is removed because one path is dead (a result of the split if optimization).\n+    \/\/ (2) The new If node added by the above split if optimization is also folded. This rewires the CastPP node to\n+    \/\/ the last control node in the If block which is the true projection of range check RC2. Up until now, the CastPP\n+    \/\/ is still after the null check NC1.\n+    \/\/ (3) The range check RC2 is removed because the range check RC1 already covers this range (see RangeCheck::Ideal()).\n+    \/\/ All data nodes which are control dependent on RC2 will be rewired to the dominating range check RC1, including\n+    \/\/ the non-null CastPP node - which now has a control input above the null check NC1. This also means that the field\n+    \/\/ load obj.iFld now has the same early control as the CastPP (CastPP -> AddP -> LoadI). Using StressGCM can\n+    \/\/ now schedule the obj.iFld load before the null check NC1 because the early control allows it which leads to a\n+    \/\/ segmentation fault if obj is null.\n+    public static void test() {\n+        int x = iArrFld[17]; \/\/ Emits range check RC1\n+        if (obj != null) { \/\/ Null check NC1\n+            int y = 0;\n+            for (int i = 0; i < 1; i++) { \/\/ Loop L\n+                y++;\n+            }\n+            \/\/ Use additional loop to keep the rangecheck for iArrFld[y] in before loopopts.\n+            \/\/ y will become constant 1 but only once the loop above is removed in loopopts.\n+            x = iArrFld[y]; \/\/ Emits range check RC2\n+        } else {\n+            x = iArrFld2[18];\n+        }\n+        \/\/ Region R merging the if and else paths above.\n+        if (obj != null) { \/\/ Null check NC2\n+            x = iArrFld2[obj.iFld]; \/\/ Emits Null check NC3 for obj.iFld\n+        }\n+    }\n+}\n+\n+class MyClass {\n+    int iFld;\n+}\n+\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestEliminateNullCheckWithSplitIf.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}