{"files":[{"patch":"@@ -65,1 +65,4 @@\n-  static  int code_size_to_size(int code_size)   { return align_up((int)sizeof(ICStub), CodeEntryAlignment) + code_size; }\n+\n+  \/\/ ICStub_from_destination_address looks up Stub* address from code entry address,\n+  \/\/ which unfortunately means the stub head should be at the same alignment as the code.\n+  static  int alignment()                        { return CodeEntryAlignment; }\n@@ -72,1 +75,1 @@\n-  address code_begin() const                     { return (address)this + align_up(sizeof(ICStub), CodeEntryAlignment); }\n+  address code_begin() const                     { return align_up((address)this + sizeof(ICStub), CodeEntryAlignment); }\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -117,0 +117,6 @@\n+int StubQueue::compute_stub_size(Stub* stub, int code_size) {\n+  address stub_begin = (address) stub;\n+  address code_begin = stub_code_begin(stub);\n+  address code_end = align_up(code_begin + code_size, stub_alignment());\n+  return (int)(code_end - stub_begin);\n+}\n@@ -122,1 +128,1 @@\n-  int requested_size = align_up(stub_code_size_to_size(requested_code_size), CodeEntryAlignment);\n+  int requested_size = compute_stub_size(s, requested_code_size);\n@@ -160,1 +166,0 @@\n-  int committed_size = align_up(stub_code_size_to_size(committed_code_size), CodeEntryAlignment);\n@@ -162,0 +167,1 @@\n+  int committed_size = compute_stub_size(s, committed_code_size);\n@@ -217,4 +223,4 @@\n-  guarantee(_buffer_size  % CodeEntryAlignment == 0, \"_buffer_size  not aligned\");\n-  guarantee(_buffer_limit % CodeEntryAlignment == 0, \"_buffer_limit not aligned\");\n-  guarantee(_queue_begin  % CodeEntryAlignment == 0, \"_queue_begin  not aligned\");\n-  guarantee(_queue_end    % CodeEntryAlignment == 0, \"_queue_end    not aligned\");\n+  guarantee(_buffer_size  % stub_alignment() == 0, \"_buffer_size  not aligned\");\n+  guarantee(_buffer_limit % stub_alignment() == 0, \"_buffer_limit not aligned\");\n+  guarantee(_queue_begin  % stub_alignment() == 0, \"_queue_begin  not aligned\");\n+  guarantee(_queue_end    % stub_alignment() == 0, \"_queue_end    not aligned\");\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -45,2 +45,3 @@\n-\/\/                ________\n-\/\/ stub       -->|        | <--+\n+\/\/\n+\/\/ stub       -->|--------| <--+       <--- aligned by alignment()\n+\/\/               |        |    |\n@@ -48,2 +49,3 @@\n-\/\/               |________|    |\n-\/\/ code_begin -->|        |    |\n+\/\/               |        |    |\n+\/\/ code_begin -->|--------|    |       <--- aligned by CodeEntryAlignment\n+\/\/               |        |    |\n@@ -53,6 +55,3 @@\n-\/\/               |________|    |\n-\/\/ code_end   -->|        |    |\n-\/\/               |  data  |    |\n-\/\/               |________|    |\n-\/\/                          <--+\n-\n+\/\/               |        |    |\n+\/\/ code_end   -->|--------| <--+\n+\/\/\n@@ -69,1 +68,0 @@\n-  static  int code_size_to_size(int code_size)   { ShouldNotCallThis(); return 0; }      \/\/ computes the size given the code size\n@@ -102,2 +100,2 @@\n-  virtual int     size(Stub* self) const                   = 0; \/\/ the total size of the stub in bytes (must be a multiple of CodeEntryAlignment)\n-  virtual int     code_size_to_size(int code_size) const   = 0; \/\/ computes the total stub size in bytes given the code size in bytes\n+  virtual int     size(Stub* self) const                   = 0; \/\/ the total size of the stub in bytes (must be a multiple of HeapWordSize)\n+  virtual int     alignment() const                        = 0; \/\/ computes the alignment\n@@ -132,1 +130,1 @@\n-    virtual int     code_size_to_size(int code_size) const { return stub::code_size_to_size(code_size); } \\\n+    virtual int     alignment() const                      { return stub::alignment(); }           \\\n@@ -159,1 +157,1 @@\n-  void  check_index(int i) const                 { assert(0 <= i && i < _buffer_limit && i % CodeEntryAlignment == 0, \"illegal index\"); }\n+  void  check_index(int i) const                 { assert(0 <= i && i < _buffer_limit && i % stub_alignment() == 0, \"illegal index\"); }\n@@ -167,1 +165,1 @@\n-                        CodeStrings& strings)    { assert(size % CodeEntryAlignment == 0, \"size not aligned\"); _stub_interface->initialize(s, size, strings); }\n+                        CodeStrings& strings)    { assert(size % stub_alignment() == 0, \"size not aligned\"); _stub_interface->initialize(s, size, strings); }\n@@ -171,1 +169,2 @@\n-  int   stub_code_size_to_size(int code_size) const { return _stub_interface->code_size_to_size(code_size); }\n+  int   stub_alignment()                   const { return _stub_interface->alignment(); }\n+  address stub_code_begin(Stub* s)         const { return _stub_interface->code_begin(s); }\n@@ -175,0 +174,3 @@\n+  \/\/ Helpers\n+  int compute_stub_size(Stub* stub, int code_size);\n+\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  static  int code_size_to_size(int code_size)   { return align_up((int)sizeof(InterpreterCodelet), CodeEntryAlignment) + code_size; }\n+  static  int alignment()                        { return HeapWordSize; }\n@@ -67,1 +67,1 @@\n-  address code_begin() const                     { return (address)this + align_up(sizeof(InterpreterCodelet), CodeEntryAlignment); }\n+  address code_begin() const                     { return align_up((address)this + sizeof(InterpreterCodelet), CodeEntryAlignment); }\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  \/\/ 270+ interpreter codelets are generated and each of them is required to be aligned to\n-  \/\/ CodeEntryAlignment twice. So we need additional size due to alignment.\n+  \/\/ 270+ interpreter codelets are generated and each of them is aligned to HeapWordSize,\n+  \/\/ plus their code section is aligned to CodeEntryAlignement. So we need additional size due to alignment.\n@@ -53,1 +53,1 @@\n-  int max_aligned_bytes = max_aligned_codelets * CodeEntryAlignment * 2;\n+  int max_aligned_bytes = max_aligned_codelets * (HeapWordSize + CodeEntryAlignment);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}