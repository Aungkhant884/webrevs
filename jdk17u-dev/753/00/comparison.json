{"files":[{"patch":"@@ -65,1 +65,4 @@\n-  static  int code_size_to_size(int code_size)   { return align_up((int)sizeof(ICStub), CodeEntryAlignment) + code_size; }\n+\n+  \/\/ ICStub_from_destination_address looks up Stub* address from code entry address,\n+  \/\/ which unfortunately means the stub head should be at the same alignment as the code.\n+  static  int alignment()                        { return CodeEntryAlignment; }\n@@ -72,1 +75,1 @@\n-  address code_begin() const                     { return (address)this + align_up(sizeof(ICStub), CodeEntryAlignment); }\n+  address code_begin() const                     { return align_up((address)this + sizeof(ICStub), CodeEntryAlignment); }\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -117,0 +117,6 @@\n+int StubQueue::compute_stub_size(Stub* stub, int code_size) {\n+  address stub_begin = (address) stub;\n+  address code_begin = stub_code_begin(stub);\n+  address code_end = align_up(code_begin + code_size, stub_alignment());\n+  return (int)(code_end - stub_begin);\n+}\n@@ -122,1 +128,1 @@\n-  int requested_size = align_up(stub_code_size_to_size(requested_code_size), CodeEntryAlignment);\n+  int requested_size = compute_stub_size(s, requested_code_size);\n@@ -160,1 +166,0 @@\n-  int committed_size = align_up(stub_code_size_to_size(committed_code_size), CodeEntryAlignment);\n@@ -162,0 +167,1 @@\n+  int committed_size = compute_stub_size(s, committed_code_size);\n@@ -217,4 +223,4 @@\n-  guarantee(_buffer_size  % CodeEntryAlignment == 0, \"_buffer_size  not aligned\");\n-  guarantee(_buffer_limit % CodeEntryAlignment == 0, \"_buffer_limit not aligned\");\n-  guarantee(_queue_begin  % CodeEntryAlignment == 0, \"_queue_begin  not aligned\");\n-  guarantee(_queue_end    % CodeEntryAlignment == 0, \"_queue_end    not aligned\");\n+  guarantee(_buffer_size  % stub_alignment() == 0, \"_buffer_size  not aligned\");\n+  guarantee(_buffer_limit % stub_alignment() == 0, \"_buffer_limit not aligned\");\n+  guarantee(_queue_begin  % stub_alignment() == 0, \"_queue_begin  not aligned\");\n+  guarantee(_queue_end    % stub_alignment() == 0, \"_queue_end    not aligned\");\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-\/\/ stub       -->|        | <--+\n+\/\/ stub       -->|--------| <--+       <--- aligned by alignment()\n+\/\/               |        |    |\n@@ -48,2 +49,3 @@\n-\/\/               |________|    |\n-\/\/ code_begin -->|        |    |\n+\/\/               |        |    |\n+\/\/ code_begin -->|--------|    |       <--- aligned by CodeEntryAlignment\n+\/\/               |        |    |\n@@ -53,6 +55,3 @@\n-\/\/               |________|    |\n-\/\/ code_end   -->|        |    |\n-\/\/               |  data  |    |\n-\/\/               |________|    |\n-\/\/                          <--+\n-\n+\/\/               |        |    |\n+\/\/ code_end   -->|--------| <--+\n+\/\/\n@@ -69,1 +68,0 @@\n-  static  int code_size_to_size(int code_size)   { ShouldNotCallThis(); return 0; }      \/\/ computes the size given the code size\n@@ -102,2 +100,2 @@\n-  virtual int     size(Stub* self) const                   = 0; \/\/ the total size of the stub in bytes (must be a multiple of CodeEntryAlignment)\n-  virtual int     code_size_to_size(int code_size) const   = 0; \/\/ computes the total stub size in bytes given the code size in bytes\n+  virtual int     size(Stub* self) const                   = 0; \/\/ the total size of the stub in bytes (must be a multiple of HeapWordSize)\n+  virtual int     alignment() const                        = 0; \/\/ computes the alignment\n@@ -132,1 +130,1 @@\n-    virtual int     code_size_to_size(int code_size) const { return stub::code_size_to_size(code_size); } \\\n+    virtual int     alignment() const                      { return stub::alignment(); }           \\\n@@ -159,1 +157,1 @@\n-  void  check_index(int i) const                 { assert(0 <= i && i < _buffer_limit && i % CodeEntryAlignment == 0, \"illegal index\"); }\n+  void  check_index(int i) const                 { assert(0 <= i && i < _buffer_limit && i % stub_alignment() == 0, \"illegal index\"); }\n@@ -167,1 +165,1 @@\n-                        CodeStrings& strings)    { assert(size % CodeEntryAlignment == 0, \"size not aligned\"); _stub_interface->initialize(s, size, strings); }\n+                        CodeStrings& strings)    { assert(size % stub_alignment() == 0, \"size not aligned\"); _stub_interface->initialize(s, size, strings); }\n@@ -171,1 +169,2 @@\n-  int   stub_code_size_to_size(int code_size) const { return _stub_interface->code_size_to_size(code_size); }\n+  int   stub_alignment()                   const { return _stub_interface->alignment(); }\n+  address stub_code_begin(Stub* s)         const { return _stub_interface->code_begin(s); }\n@@ -175,0 +174,3 @@\n+  \/\/ Helpers\n+  int compute_stub_size(Stub* stub, int code_size);\n+\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  static  int code_size_to_size(int code_size)   { return align_up((int)sizeof(InterpreterCodelet), CodeEntryAlignment) + code_size; }\n+  static  int alignment()                        { return HeapWordSize; }\n@@ -67,1 +67,1 @@\n-  address code_begin() const                     { return (address)this + align_up(sizeof(InterpreterCodelet), CodeEntryAlignment); }\n+  address code_begin() const                     { return align_up((address)this + sizeof(InterpreterCodelet), CodeEntryAlignment); }\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,5 @@\n-  _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,\n+  \/\/ 270+ interpreter codelets are generated and each of them is aligned to HeapWordSize,\n+  \/\/ plus their code section is aligned to CodeEntryAlignement. So we need additional size due to alignment.\n+  int max_aligned_codelets = 280;\n+  int max_aligned_bytes = max_aligned_codelets * (HeapWordSize + CodeEntryAlignment);\n+  _code = new StubQueue(new InterpreterCodeletInterface, code_size + max_aligned_bytes, NULL,\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,5 @@\n-  _adapter_code = MethodHandlesAdapterBlob::create(adapter_code_size);\n+  \/\/ The adapter entry is required to be aligned to CodeEntryAlignment.\n+  \/\/ So we need additional bytes due to alignment.\n+  int adapter_num = (int)Interpreter::method_handle_invoke_LAST - (int)Interpreter::method_handle_invoke_FIRST + 1;\n+  int max_aligned_bytes = adapter_num * CodeEntryAlignment;\n+  _adapter_code = MethodHandlesAdapterBlob::create(adapter_code_size + max_aligned_bytes);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}