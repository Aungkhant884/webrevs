{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -45,2 +46,30 @@\n-void AsyncLogWriter::enqueue_locked(const AsyncLogMessage& msg) {\n-  if (_buffer.size() >= _buffer_max_size) {\n+\/\/ LogDecorator::None applies to 'constant initialization' because of its constexpr constructor.\n+const LogDecorations& AsyncLogWriter::None = LogDecorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n+                                      LogDecorators::None);\n+\n+bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n+  const size_t sz = Message::calc_size(strlen(msg));\n+  const bool is_token = output == nullptr;\n+  \/\/ Always leave headroom for the flush token. Pushing a token must succeed.\n+  const size_t headroom = (!is_token) ? Message::calc_size(0) : 0;\n+\n+  if (_pos + sz <= (_capacity - headroom)) {\n+    new(_buf + _pos) Message(output, decorations, msg);\n+    _pos += sz;\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void AsyncLogWriter::Buffer::push_flush_token() {\n+  bool result = push_back(nullptr, AsyncLogWriter::None, \"\");\n+  assert(result, \"fail to enqueue the flush token.\");\n+}\n+\n+void AsyncLogWriter::enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n+  \/\/ To save space and streamline execution, we just ignore null message.\n+  \/\/ client should use \"\" instead.\n+  assert(msg != nullptr, \"enqueuing a null message!\");\n+\n+  if (!_buffer->push_back(output, decorations, msg)) {\n@@ -48,1 +77,1 @@\n-    uint32_t* counter = _stats.add_if_absent(msg.output(), 0, &p_created);\n+    uint32_t* counter = _stats.put_if_absent(output, 0, &p_created);\n@@ -50,2 +79,0 @@\n-    \/\/ drop the enqueueing message.\n-    os::free(msg.message());\n@@ -55,1 +82,0 @@\n-  _buffer.push_back(msg);\n@@ -61,6 +87,2 @@\n-  AsyncLogMessage m(&output, decorations, os::strdup(msg));\n-\n-  { \/\/ critical area\n-    AsyncLogLocker locker;\n-    enqueue_locked(m);\n-  }\n+  AsyncLogLocker locker;\n+  enqueue_locked(&output, decorations, msg);\n@@ -75,2 +97,1 @@\n-    AsyncLogMessage m(&output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n-    enqueue_locked(m);\n+    enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n@@ -83,1 +104,6 @@\n-    _stats(17 \/*table_size*\/) {\n+    _stats() {\n+\n+  size_t size = AsyncLogBufferSize \/ 2;\n+  _buffer = new Buffer(size);\n+  _buffer_staging = new Buffer(size);\n+  log_info(logging)(\"AsyncLogBuffer estimates memory use: \" SIZE_FORMAT \" bytes\", size * 2);\n@@ -89,3 +115,0 @@\n-\n-  log_info(logging)(\"The maximum entries of AsyncLogBuffer: \" SIZE_FORMAT \", estimated memory use: \" SIZE_FORMAT \" bytes\",\n-                    _buffer_max_size, AsyncLogBufferSize);\n@@ -94,21 +117,0 @@\n-class AsyncLogMapIterator {\n-  AsyncLogBuffer& _logs;\n-\n- public:\n-  AsyncLogMapIterator(AsyncLogBuffer& logs) :_logs(logs) {}\n-  bool do_entry(LogFileStreamOutput* output, uint32_t* counter) {\n-    using none = LogTagSetMapping<LogTag::__NO_TAG>;\n-\n-    if (*counter > 0) {\n-      LogDecorations decorations(LogLevel::Warning, none::tagset(), LogDecorators::All);\n-      stringStream ss;\n-      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n-      AsyncLogMessage msg(output, decorations, ss.as_string(true \/*c_heap*\/));\n-      _logs.push_back(msg);\n-      *counter = 0;\n-    }\n-\n-    return true;\n-  }\n-};\n-\n@@ -116,7 +118,7 @@\n-  \/\/ Use kind of copy-and-swap idiom here.\n-  \/\/ Empty 'logs' swaps the content with _buffer.\n-  \/\/ Along with logs destruction, all processed messages are deleted.\n-  \/\/\n-  \/\/ The operation 'pop_all()' is done in O(1). All I\/O jobs are then performed without\n-  \/\/ lock protection. This guarantees I\/O jobs don't block logsites.\n-  AsyncLogBuffer logs;\n+  ResourceMark rm;\n+  \/\/ Similar to AsyncLogMap but on resource_area\n+  ResourceHashtable<LogFileStreamOutput*, uint32_t,\n+                    primitive_hash<LogFileStreamOutput*>,\n+                    primitive_equals<LogFileStreamOutput*>,\n+                    17\/*table_size*\/, ResourceObj::RESOURCE_AREA,\n+                    mtLogging> snapshot;\n@@ -124,1 +126,2 @@\n-  { \/\/ critical region\n+  \/\/ lock protection. This guarantees I\/O jobs don't block logsites.\n+  {\n@@ -127,4 +130,12 @@\n-    _buffer.pop_all(&logs);\n-    \/\/ append meta-messages of dropped counters\n-    AsyncLogMapIterator dropped_counters_iter(logs);\n-    _stats.iterate(&dropped_counters_iter);\n+    _buffer_staging->reset();\n+    swap(_buffer, _buffer_staging);\n+\n+    \/\/ move counters to snapshot and reset them.\n+    _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n+      if (counter > 0) {\n+        bool created = snapshot.put(output, counter);\n+        assert(created == true, \"sanity check\");\n+        counter = 0;\n+      }\n+      return true;\n+    });\n@@ -134,2 +145,0 @@\n-  LinkedListIterator<AsyncLogMessage> it(logs.head());\n-\n@@ -137,8 +146,7 @@\n-  while (!it.is_empty()) {\n-    AsyncLogMessage* e = it.next();\n-    char* msg = e->message();\n-\n-    if (msg != nullptr) {\n-      e->output()->write_blocking(e->decorations(), msg);\n-      os::free(msg);\n-    } else if (e->output() == nullptr) {\n+  auto it = _buffer_staging->iterator();\n+  while (it.hasNext()) {\n+    const Message* e = it.next();\n+\n+    if (!e->is_token()){\n+      e->output()->write_blocking(e->decorations(), e->message());\n+    } else {\n@@ -151,0 +159,11 @@\n+  LogDecorations decorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n+                             LogDecorators::All);\n+  snapshot.iterate([&](LogFileStreamOutput* output, uint32_t& counter) {\n+    if (counter > 0) {\n+      stringStream ss;\n+      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", counter);\n+      output->write_blocking(decorations, ss.as_string(false));\n+    }\n+    return true;\n+  });\n+\n@@ -152,1 +171,1 @@\n-    assert(req == 1, \"AsyncLogWriter::flush() is NOT MT-safe!\");\n+    assert(req == 1, \"Only one token is allowed in queue. AsyncLogWriter::flush() is NOT MT-safe!\");\n@@ -189,0 +208,2 @@\n+  } else {\n+    delete self;\n@@ -203,1 +224,0 @@\n-      using none = LogTagSetMapping<LogTag::__NO_TAG>;\n@@ -205,3 +225,0 @@\n-      LogDecorations d(LogLevel::Off, none::tagset(), LogDecorators::None);\n-      AsyncLogMessage token(nullptr, d, nullptr);\n-\n@@ -209,1 +226,1 @@\n-      _instance->_buffer.push_back(token);\n+      _instance->_buffer->push_flush_token();\n@@ -217,0 +234,20 @@\n+\n+AsyncLogWriter::BufferUpdater::BufferUpdater(size_t newsize) {\n+  AsyncLogLocker locker;\n+  auto p = AsyncLogWriter::_instance;\n+\n+  _buf1 = p->_buffer;\n+  _buf2 = p->_buffer_staging;\n+  p->_buffer = new Buffer(newsize);\n+  p->_buffer_staging = new Buffer(newsize);\n+}\n+\n+AsyncLogWriter::BufferUpdater::~BufferUpdater() {\n+  AsyncLogLocker locker;\n+  auto p = AsyncLogWriter::_instance;\n+\n+  delete p->_buffer;\n+  delete p->_buffer_staging;\n+  p->_buffer = _buf1;\n+  p->_buffer_staging = _buf2;\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":104,"deletions":67,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/mutex.hpp\"\n@@ -32,2 +33,1 @@\n-#include \"utilities\/hashtable.hpp\"\n-#include \"utilities\/linkedlist.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -35,59 +35,0 @@\n-template <typename E, MEMFLAGS F>\n-class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, F> {\n- private:\n-  LinkedListNode<E>* _tail;\n-  size_t _size;\n-\n- public:\n-  LinkedListDeque() : _tail(NULL), _size(0) {}\n-  void push_back(const E& e) {\n-    if (!_tail) {\n-      _tail = this->add(e);\n-    } else {\n-      _tail = this->insert_after(e, _tail);\n-    }\n-\n-    ++_size;\n-  }\n-\n-  \/\/ pop all elements to logs.\n-  void pop_all(LinkedList<E>* logs) {\n-    logs->move(static_cast<LinkedList<E>* >(this));\n-    _tail = NULL;\n-    _size = 0;\n-  }\n-\n-  void pop_all(LinkedListDeque<E, F>* logs) {\n-    logs->_size = _size;\n-    logs->_tail = _tail;\n-    pop_all(static_cast<LinkedList<E>* >(logs));\n-  }\n-\n-  void pop_front() {\n-    LinkedListNode<E>* h = this->unlink_head();\n-    if (h == _tail) {\n-      _tail = NULL;\n-    }\n-\n-    if (h != NULL) {\n-      --_size;\n-      this->delete_node(h);\n-    }\n-  }\n-\n-  size_t size() const { return _size; }\n-\n-  const E* front() const {\n-    return this->_head == NULL ? NULL : this->_head->peek();\n-  }\n-\n-  const E* back() const {\n-    return _tail == NULL ? NULL : _tail->peek();\n-  }\n-\n-  LinkedListNode<E>* head() const {\n-    return this->_head;\n-  }\n-};\n-\n-\/\/ Forward declaration\n@@ -95,21 +36,0 @@\n-\n-class AsyncLogMessage {\n-  LogFileStreamOutput* _output;\n-  const LogDecorations _decorations;\n-  char* _message;\n-\n-public:\n-  AsyncLogMessage(LogFileStreamOutput* output, const LogDecorations& decorations, char* msg)\n-    : _output(output), _decorations(decorations), _message(msg) {}\n-\n-  \/\/ placeholder for LinkedListImpl.\n-  bool equals(const AsyncLogMessage& o) const { return false; }\n-\n-  LogFileStreamOutput* output() const { return _output; }\n-  const LogDecorations& decorations() const { return _decorations; }\n-  char* message() const { return _message; }\n-};\n-\n-typedef LinkedListDeque<AsyncLogMessage, mtLogging> AsyncLogBuffer;\n-typedef KVHashtable<LogFileStreamOutput*, uint32_t, mtLogging> AsyncLogMap;\n-\n@@ -138,0 +58,2 @@\n+  friend class AsyncLogTest;\n+  friend class AsyncLogTest_logBuffer_vm_Test;\n@@ -139,0 +61,86 @@\n+  using AsyncLogMap = ResourceHashtable<LogFileStreamOutput*, uint32_t, primitive_hash<LogFileStreamOutput*>,\n+                                        primitive_equals<LogFileStreamOutput*>, 17,\n+                                        ResourceObj::C_HEAP, mtLogging>;\n+\n+  \/\/ Messsage is the envelop of a log line and its associative data.\n+  \/\/ Its length is variable because of the zero-terminated c-str. It is only valid when we create it using placement new\n+  \/\/ within a buffer.\n+  \/\/\n+  \/\/ Example layout:\n+  \/\/ ---------------------------------------------\n+  \/\/ |_output|_decorations|\"a log line\", |pad| <- pointer aligned.\n+  \/\/ |_output|_decorations|\"yet another\",|pad|\n+  \/\/ ...\n+  \/\/ |nullptr|_decorations|\"\",|pad| <- flush token\n+  \/\/ |<- _pos\n+  \/\/ ---------------------------------------------\n+  class Message {\n+    NONCOPYABLE(Message);\n+    ~Message() = delete;\n+    LogFileStreamOutput* const _output;\n+    const LogDecorations _decorations;\n+   public:\n+    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg)\n+      : _output(output), _decorations(decorations) {\n+      assert(msg != nullptr, \"c-str message can not be null!\");\n+      strcpy(reinterpret_cast<char* >(this+1), msg);\n+    }\n+\n+    \/\/ Calculate the size for a prospective Message object depending on its message length including the trailing zero\n+    static constexpr size_t calc_size(size_t message_len) {\n+      return align_up(sizeof(Message) + message_len + 1, sizeof(void*));\n+    }\n+\n+    size_t size() const {\n+      return calc_size(strlen(message()));\n+    }\n+\n+    inline bool is_token() const { return _output == nullptr; }\n+    LogFileStreamOutput* output() const { return _output; }\n+    const LogDecorations& decorations() const { return _decorations; }\n+    const char* message() const { return reinterpret_cast<const char *>(this+1); }\n+  };\n+\n+  class Buffer : public CHeapObj<mtLogging> {\n+    char* _buf;\n+    size_t _pos;\n+    const size_t _capacity;\n+\n+   public:\n+    Buffer(size_t capacity) :  _pos(0), _capacity(capacity) {\n+      _buf = NEW_C_HEAP_ARRAY(char, capacity, mtLogging);\n+      assert(capacity >= Message::calc_size(0), \"capcity must be great a token size\");\n+    }\n+\n+    ~Buffer() {\n+      FREE_C_HEAP_ARRAY(char, _buf);\n+    }\n+\n+    void push_flush_token();\n+    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n+\n+    void reset() { _pos = 0; }\n+\n+    class Iterator {\n+      const Buffer& _buf;\n+      size_t _curr;\n+\n+    public:\n+      Iterator(const Buffer& buffer): _buf(buffer), _curr(0) {}\n+\n+      bool hasNext() const {\n+        return _curr < _buf._pos;\n+      }\n+\n+      const Message* next() {\n+        assert(hasNext(), \"sanity check\");\n+        auto msg = reinterpret_cast<Message*>(_buf._buf + _curr);\n+        _curr = MIN2(_curr + msg->size(), _buf._pos);\n+        return msg;\n+      }\n+    };\n+\n+    Iterator iterator() const {\n+      return Iterator(*this);\n+    }\n+  };\n@@ -147,1 +155,0 @@\n-  AsyncLogBuffer _buffer;\n@@ -149,3 +156,5 @@\n-  \/\/ The memory use of each AsyncLogMessage (payload) consists of itself and a variable-length c-str message.\n-  \/\/ A regular logging message is smaller than vwrite_buffer_size, which is defined in logtagset.cpp\n-  const size_t _buffer_max_size = {AsyncLogBufferSize \/ (sizeof(AsyncLogMessage) + vwrite_buffer_size)};\n+  \/\/ ping-pong buffers\n+  Buffer* _buffer;\n+  Buffer* _buffer_staging;\n+\n+  static const LogDecorations& None;\n@@ -154,1 +163,1 @@\n-  void enqueue_locked(const AsyncLogMessage& msg);\n+  void enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n@@ -168,0 +177,10 @@\n+  \/\/ for testing-only\n+  class BufferUpdater {\n+    Buffer* _buf1;\n+    Buffer* _buf2;\n+\n+   public:\n+    BufferUpdater(size_t newsize);\n+    ~BufferUpdater();\n+  };\n+\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":107,"deletions":88,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-const LogDecorators LogDecorators::None = LogDecorators(0);\n-const LogDecorators LogDecorators::All  = LogDecorators(AllBitmask<time_decorator>::_value);\n+const LogDecorators LogDecorators::None = {0};\n+const LogDecorators LogDecorators::All = {AllBitmask<time_decorator>::_value};\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  LogDecorators(uint mask) : _decorators(mask) {\n+  constexpr LogDecorators(uint mask) : _decorators(mask) {\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,0 +187,8 @@\n+    auto function = [&] (K& k, V& v) {\n+      return iter->do_entry(k, v);\n+    };\n+    iterate(function);\n+  }\n+\n+  template<typename Function>\n+  void iterate(Function function) const { \/\/ lambda enabled API\n@@ -188,0 +196,1 @@\n+\n@@ -191,1 +200,1 @@\n-        bool cont = iter->do_entry(node->_key, node->_value);\n+        bool cont = function(node->_key, node->_value);\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/logFileOutput.hpp\"\n@@ -71,2 +72,3 @@\n-    if (AsyncLogWriter::instance() != nullptr) {\n-      const size_t sz = 100;\n+    auto writer = AsyncLogWriter::instance();\n+    if (writer != nullptr) {\n+      const size_t sz = 2000;\n@@ -75,1 +77,1 @@\n-      AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n+      AsyncLogWriter::BufferUpdater saver(1024);\n@@ -78,2 +80,2 @@\n-      \/\/ write 100x more messages than its capacity in burst\n-      for (size_t i = 0; i < sz * 100; ++i) {\n+      \/\/ write more messages than its capacity in burst\n+      for (size_t i = 0; i < sz; ++i) {\n@@ -103,72 +105,0 @@\n-TEST_VM(AsyncLogBufferTest, fifo) {\n-  LinkedListDeque<int, mtLogging> fifo;\n-  LinkedListImpl<int, ResourceObj::C_HEAP, mtLogging> result;\n-\n-  fifo.push_back(1);\n-  EXPECT_EQ((size_t)1, fifo.size());\n-  EXPECT_EQ(1, *(fifo.back()));\n-\n-  fifo.pop_all(&result);\n-  EXPECT_EQ((size_t)0, fifo.size());\n-  EXPECT_EQ(NULL, fifo.back());\n-  EXPECT_EQ((size_t)1, result.size());\n-  EXPECT_EQ(1, *(result.head()->data()));\n-  result.clear();\n-\n-  fifo.push_back(2);\n-  fifo.push_back(1);\n-  fifo.pop_all(&result);\n-  EXPECT_EQ((size_t)2, result.size());\n-  EXPECT_EQ(2, *(result.head()->data()));\n-  EXPECT_EQ(1, *(result.head()->next()->data()));\n-  result.clear();\n-  const int N = 1000;\n-  for (int i=0; i<N; ++i) {\n-    fifo.push_back(i);\n-  }\n-  fifo.pop_all(&result);\n-\n-  EXPECT_EQ((size_t)N, result.size());\n-  LinkedListIterator<int> it(result.head());\n-  for (int i=0; i<N; ++i) {\n-    int* e = it.next();\n-    EXPECT_EQ(i, *e);\n-  }\n-}\n-\n-TEST_VM(AsyncLogBufferTest, deque) {\n-  LinkedListDeque<int, mtLogging> deque;\n-  const int N = 10;\n-\n-  EXPECT_EQ(NULL, deque.front());\n-  EXPECT_EQ(NULL, deque.back());\n-  for (int i = 0; i < N; ++i) {\n-    deque.push_back(i);\n-  }\n-\n-  EXPECT_EQ(0, *(deque.front()));\n-  EXPECT_EQ(N-1, *(deque.back()));\n-  EXPECT_EQ((size_t)N, deque.size());\n-\n-  deque.pop_front();\n-  EXPECT_EQ((size_t)(N - 1), deque.size());\n-  EXPECT_EQ(1, *(deque.front()));\n-  EXPECT_EQ(N - 1, *(deque.back()));\n-\n-  deque.pop_front();\n-  EXPECT_EQ((size_t)(N - 2), deque.size());\n-  EXPECT_EQ(2, *(deque.front()));\n-  EXPECT_EQ(N - 1, *(deque.back()));\n-\n-\n-  for (int i=2; i < N-1; ++i) {\n-    deque.pop_front();\n-  }\n-  EXPECT_EQ((size_t)1, deque.size());\n-  EXPECT_EQ(N - 1, *(deque.back()));\n-  EXPECT_EQ(deque.back(), deque.front());\n-\n-  deque.pop_front();\n-  EXPECT_EQ((size_t)0, deque.size());\n-}\n-\n@@ -231,0 +161,86 @@\n+TEST_VM_F(AsyncLogTest, logBuffer) {\n+  const auto Default = LogDecorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n+                                      LogDecorators());\n+  size_t len = strlen(TestLogFileName) + strlen(LogFileOutput::Prefix) + 1;\n+  char* name = NEW_C_HEAP_ARRAY(char, len, mtLogging);\n+  snprintf(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n+\n+  LogFileStreamOutput* output = new LogFileOutput(name);\n+  output->initialize(nullptr, nullptr);\n+  auto buffer = new AsyncLogWriter::Buffer(1024);\n+\n+  int line = 0;\n+  int written;\n+  uintptr_t addr;\n+  const uintptr_t mask = (uintptr_t)(sizeof(void*) - 1);\n+  bool res;\n+\n+  res = buffer->push_back(output, Default, \"a log line\");\n+  EXPECT_TRUE(res) << \"first message should succeed.\";\n+  line++;\n+  res = buffer->push_back(output, Default, \"yet another\");\n+  EXPECT_TRUE(res) << \"second message should succeed.\";\n+  line++;\n+\n+  auto it = buffer->iterator();\n+  EXPECT_TRUE(it.hasNext());\n+  const AsyncLogWriter::Message* e = it.next();\n+  addr = reinterpret_cast<uintptr_t>(e);\n+  EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1))); \/\/ returned vaue aligns on sizeof(pointer)\n+  EXPECT_EQ(output, e->output());\n+  EXPECT_EQ(0, memcmp(&Default, &e->decorations(), sizeof(LogDecorations)));\n+  EXPECT_STREQ(\"a log line\", e->message());\n+  written = e->output()->write_blocking(e->decorations(), e->message());\n+  EXPECT_GT(written, 0);\n+\n+  EXPECT_TRUE(it.hasNext());\n+  e = it.next();\n+  addr = reinterpret_cast<uintptr_t>(e);\n+  EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1)));\n+  EXPECT_EQ(output, e->output());\n+  EXPECT_EQ(0, memcmp(&Default, &e->decorations(), sizeof(LogDecorations)));\n+  EXPECT_STREQ(\"yet another\", e->message());\n+  written = e->output()->write_blocking(e->decorations(), e->message());\n+  EXPECT_GT(written, 0);\n+\n+  while (buffer->push_back(output, Default, \"0123456789abcdef\")) {\n+    line++;\n+  }\n+\n+  EXPECT_GT(line, 2);\n+  while (it.hasNext()) {\n+    e = it.next();\n+    addr = reinterpret_cast<uintptr_t>(e);\n+    EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1)));\n+    EXPECT_EQ(output, e->output());\n+    EXPECT_STREQ(\"0123456789abcdef\", e->message());\n+    written = e->output()->write_blocking(e->decorations(), e->message());\n+    EXPECT_GT(written, 0);\n+    line--;\n+  }\n+  EXPECT_EQ(line, 2);\n+\n+  \/\/ last one, flush token. expect to succeed even buffer has been full.\n+  buffer->push_flush_token();\n+  EXPECT_TRUE(it.hasNext());\n+  e = it.next();\n+  EXPECT_EQ(e->output(), nullptr);\n+  EXPECT_TRUE(e->is_token());\n+  EXPECT_STREQ(\"\", e->message());\n+  EXPECT_FALSE(it.hasNext());\n+\n+  \/\/ reset buffer\n+  buffer->reset();\n+  EXPECT_FALSE(buffer->iterator().hasNext());\n+\n+  delete output; \/\/ close file\n+  FREE_C_HEAP_ARRAY(char, name);\n+\n+  const char* strs[4];\n+  strs[0] = \"a log line\";\n+  strs[1] = \"yet another\";\n+  strs[2] = \"0123456789abcdef\";\n+  strs[3] = nullptr; \/\/ sentinel!\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":93,"deletions":77,"binary":false,"changes":170,"status":"modified"}]}