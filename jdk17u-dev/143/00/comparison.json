{"files":[{"patch":"@@ -344,1 +344,1 @@\n-    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, iffast_pred, loop);\n+    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, iffast_pred);\n@@ -346,1 +346,1 @@\n-    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, ifslow_pred, loop);\n+    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, ifslow_pred);\n@@ -400,4 +400,4 @@\n-ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj,\n-                                                                    Deoptimization::DeoptReason reason, ProjNode* output_proj,\n-                                                                    IdealLoopTree* loop) {\n-  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, predicate, uncommon_proj, output_proj, loop);\n+ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n+                                                                        Deoptimization::DeoptReason reason,\n+                                                                        ProjNode* output_proj) {\n+  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, output_proj);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1267,1 +1267,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, opaque_init, NULL, predicate, uncommon_proj,\n+                                                                   current_proj, outer_loop, prev_proj);\n@@ -1270,1 +1271,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, predicate, uncommon_proj,\n+                                                                   current_proj, outer_loop, prev_proj);\n@@ -1347,2 +1349,1 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                    Node* control, IdealLoopTree* outer_loop) {\n+Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control) {\n@@ -1424,3 +1425,3 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                             Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n-  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, predicate, uncommon_proj, control, outer_loop);\n+Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                                     Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, control);\n@@ -1440,2 +1441,2 @@\n-  register_control(new_iff, outer_loop->_parent, input_proj);\n-  register_control(proj, outer_loop->_parent, new_iff);\n+  register_control(new_iff, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, input_proj);\n+  register_control(proj, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, new_iff);\n@@ -1524,1 +1525,2 @@\n-  Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);\n+  Node* post_incr = incr;\n+  Node* main_exit = insert_post_loop(loop, old_new, main_head, main_end, post_incr, limit, post_head);\n@@ -1623,0 +1625,1 @@\n+  copy_skeleton_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n@@ -1745,0 +1748,1 @@\n+  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1791,0 +1795,1 @@\n+  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1807,3 +1812,3 @@\n-Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree *loop, Node_List &old_new,\n-                                       CountedLoopNode *main_head, CountedLoopEndNode *main_end,\n-                                       Node *incr, Node *limit, CountedLoopNode *&post_head) {\n+Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                       CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                                       Node*& incr, Node* limit, CountedLoopNode*& post_head) {\n@@ -1893,2 +1898,2 @@\n-  Node* castii = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n-  assert(castii != NULL, \"no castII inserted\");\n+  incr = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n+  assert(incr != NULL, \"no castII inserted\");\n@@ -1936,1 +1941,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, max_value, entry, proj, ctrl, outer_loop,\n+                                                                   prev_proj);\n@@ -1948,0 +1954,28 @@\n+void PhaseIdealLoop::copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride) {\n+  \/\/ Go over the skeleton predicates of the main loop and make a copy for the post loop with its initial iv value and\n+  \/\/ stride as inputs.\n+  Node* post_loop_entry = post_loop_head->in(LoopNode::EntryControl);\n+  Node* main_loop_entry = main_loop_head->in(LoopNode::EntryControl);\n+  IdealLoopTree* post_loop = get_loop(post_loop_head);\n+\n+  Node* ctrl = main_loop_entry;\n+  Node* prev_proj = post_loop_entry;\n+  while (ctrl != NULL && ctrl->is_Proj() && ctrl->in(0)->is_If()) {\n+    IfNode* iff = ctrl->in(0)->as_If();\n+    ProjNode* proj = iff->proj_out(1 - ctrl->as_Proj()->_con);\n+    if (proj->unique_ctrl_out()->Opcode() != Op_Halt) {\n+      break;\n+    }\n+    if (iff->in(1)->Opcode() == Op_Opaque4 && skeleton_predicate_has_opaque(iff)) {\n+      prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, ctrl, proj, post_loop_entry,\n+                                                                 post_loop, prev_proj);\n+      assert(!skeleton_predicate_has_opaque(prev_proj->in(0)->as_If()), \"unexpected\");\n+    }\n+    ctrl = ctrl->in(0)->in(0);\n+  }\n+  if (prev_proj != post_loop_entry) {\n+    _igvn.replace_input_of(post_loop_head, LoopNode::EntryControl, prev_proj);\n+    set_idom(post_loop_head, prev_proj, dom_depth(post_loop_head));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2153,0 +2153,1 @@\n+  Node* ctrl = in(LoopNode::EntryControl);\n@@ -2154,2 +2155,3 @@\n-    Node* ctrl = skip_strip_mined()->in(LoopNode::EntryControl);\n-\n+    ctrl = skip_strip_mined()->in(LoopNode::EntryControl);\n+  }\n+  if (is_main_loop() || is_post_loop()) {\n@@ -2158,1 +2160,1 @@\n-  return in(LoopNode::EntryControl);\n+  return ctrl;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -918,4 +918,3 @@\n-  Node* clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                               IdealLoopTree* outer_loop, Node* input_proj);\n-  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                      IdealLoopTree* outer_loop);\n+  Node* clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                                       IdealLoopTree* outer_loop, Node* input_proj);\n+  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control);\n@@ -925,0 +924,1 @@\n+  void copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride);\n@@ -1247,3 +1247,3 @@\n-  Node *insert_post_loop(IdealLoopTree *loop, Node_List &old_new,\n-                         CountedLoopNode *main_head, CountedLoopEndNode *main_end,\n-                         Node *incr, Node *limit, CountedLoopNode *&post_head);\n+  Node *insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+                         CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                         Node*& incr, Node* limit, CountedLoopNode*& post_head);\n@@ -1583,2 +1583,3 @@\n-  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj, Deoptimization::DeoptReason reason,\n-                                                          ProjNode* output_proj, IdealLoopTree* loop);\n+  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n+                                                          Deoptimization::DeoptReason reason,\n+                                                          ProjNode* output_proj);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2565,0 +2565,1 @@\n+               n->Opcode() == Op_Opaque4   ||\n@@ -2626,0 +2627,13 @@\n+      } else if (n->Opcode() == Op_Opaque4) {\n+        \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n+        \/\/ is always equal to the constant value of input 2. So we can\n+        \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n+        \/\/ leave the non constant test in instead to sanity check that it\n+        \/\/ never fails (if it does, that subgraph was constructed so, at\n+        \/\/ runtime, a Halt node is executed).\n+#ifdef ASSERT\n+        _igvn.replace_node(n, n->in(1));\n+#else\n+        _igvn.replace_node(n, n->in(2));\n+#endif\n+        success = true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,19 +63,0 @@\n-Node* Opaque4Node::Identity(PhaseGVN* phase) {\n-  if (phase->C->post_loop_opts_phase()) {\n-    \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n-    \/\/ is always equal to the constant value of input 2. So we can\n-    \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n-    \/\/ leave the non constant test in instead to sanity check that it\n-    \/\/ never fails (if it does, that subgraph was constructed so, at\n-    \/\/ runtime, a Halt node is executed).\n-#ifdef ASSERT\n-    return this->in(1);\n-#else\n-    return this->in(2);\n-#endif\n-  } else {\n-    phase->C->record_for_post_loop_opts_igvn(this);\n-  }\n-  return this;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -117,1 +117,4 @@\n-  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {}\n+  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n@@ -121,1 +124,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275330\n+ * @summary C2: assert(n->is_Root() || n->is_Region() || n->is_Phi() || n->is_MachMerge() || def_block->dominates(block)) failed: uses must be dominated by definitions\n+ *\n+ * @run main\/othervm -Xmx512m -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:CompileOnly=TestDeadPostLoopBecausePredicate TestDeadPostLoopBecausePredicate\n+ *\n+ *\/\n+\n+\n+public class TestDeadPostLoopBecausePredicate {\n+\n+    public static final int N = 400;\n+\n+    public static int iFld=54270;\n+    public static int iFld1=-4;\n+    public int iFld2=201;\n+\n+    public int mainTest(String[] strArr1) {\n+\n+        int i=0, i17=8052, i19=22380, i20=60894, iArr[]=new int[N];\n+        init(iArr, 4);\n+\n+        i = 1;\n+        do {\n+            for (i17 = 5; i17 < 114; i17++) {\n+                switch ((i17 % 7) + 126) {\n+                case 126:\n+                    for (i19 = 2; i19 > i; i19 -= 3) {\n+                        try {\n+                            i20 = (iFld2 % TestDeadPostLoopBecausePredicate.iFld1);\n+                            i20 = (iArr[i19 - 1] % TestDeadPostLoopBecausePredicate.iFld);\n+                            TestDeadPostLoopBecausePredicate.iFld = (TestDeadPostLoopBecausePredicate.iFld1 % iArr[i19]);\n+                        } catch (ArithmeticException a_e) {}\n+                    }\n+                    break;\n+                }\n+            }\n+        } while (++i < 220);\n+\n+        return i20;\n+    }\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestDeadPostLoopBecausePredicate _instance = new TestDeadPostLoopBecausePredicate();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadPostLoopBecausePredicate.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}