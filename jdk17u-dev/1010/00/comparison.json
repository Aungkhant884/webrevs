{"files":[{"patch":"@@ -44,0 +44,8 @@\n+\n+\/\/ Checks return code for JNI calls that don't raise exceptions\n+\/\/ and generate fatal error\n+#define CHECK(jniCall) do { \\\n+  if ((jniCall) != 0) { \\\n+    env->FatalError(\"Error invoking JNI method: \" #jniCall); \\\n+  } \\\n+} while (0)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/jnihelper.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    const char **str;\n-    char **checkstr;\n+  const char **str;\n+  char **checkstr;\n@@ -41,3 +41,3 @@\n-    const jchar **str;\n-    char **checkstr;\n-    int *size;\n+  const jchar **str;\n+  char **checkstr;\n+  int *size;\n@@ -48,26 +48,27 @@\n-                    jint nstr, jint printperiod) {\n-\n-    int i,j;\n-    size_t k;\n-    static CHAR_ARRAY *element;\n-    unsigned char digest[DIGESTLENGTH];\n-    static int allocs=0;\n-    static size_t strsize=0;\n-    static unsigned int compared=1;\n-\n-    const char *clsName = \"nsk\/stress\/jni\/JNIter001\";\n-    const char *name=\"setpass\";\n-    const char *sig=\"(Z)V\";\n-    const char *halt=\"halt\";\n-    const char *haltSig=\"()V\";\n-    jstring tmpstr;\n-    jclass clazz;\n-    jmethodID methodID;\n-\n-    env->MonitorEnter(jobj); CE\n-    if (!allocs) {\n-        element = (CHAR_ARRAY *)c_malloc(env, sizeof(CHAR_ARRAY));\n-        element->str = (const char **)c_malloc(env, nstr*sizeof(const char *));\n-        element->checkstr = (char **)c_malloc(env, nstr*sizeof(char *));\n-        for (j=0;j<nstr;j++)\n-            element->checkstr[j] = (char *)c_malloc(env, DIGESTLENGTH*sizeof(char));\n+                                         jint nstr, jint printperiod) {\n+\n+  int i, j;\n+  size_t k;\n+  static CHAR_ARRAY *element;\n+  unsigned char digest[DIGESTLENGTH];\n+  static int allocs = 0;\n+  static size_t strsize = 0;\n+  static unsigned int compared = 1;\n+\n+  const char *clsName = \"nsk\/stress\/jni\/JNIter001\";\n+  const char *name = \"setpass\";\n+  const char *sig = \"(Z)V\";\n+  const char *halt = \"halt\";\n+  const char *haltSig = \"()V\";\n+  jstring tmpstr;\n+  jclass clazz;\n+  jmethodID methodID;\n+\n+  CHECK(env->MonitorEnter(jobj));\n+\n+  if (!allocs) {\n+    element = (CHAR_ARRAY *)c_malloc(env, sizeof(CHAR_ARRAY));\n+    element->str = (const char **)c_malloc(env, nstr * sizeof(const char*));\n+    element->checkstr = (char **)c_malloc(env, nstr * sizeof(char*));\n+    for (j = 0; j < nstr; j++) {\n+      element->checkstr[j] = (char *)c_malloc(env, DIGESTLENGTH * sizeof(char));\n@@ -75,2 +76,19 @@\n-    for (j=0;j<DIGESTLENGTH;j++) {\n-        digest[j]=0;\n+  }\n+  for (j = 0; j < DIGESTLENGTH; j++) {\n+    digest[j] = 0;\n+  }\n+  element->str[allocs] = env->GetStringUTFChars(jstr, 0); CE\n+  if (strlen(element->str[allocs]) != (size_t) env->GetStringUTFLength(jstr)) {\n+    printf(\"Length is wrong in string No. %d\\n\", allocs);\n+  } else {\n+    strsize += strlen(element->str[allocs]) + 1;\n+  }\n+  for (k = 0; k < strlen(element->str[allocs]); k++) {\n+    digest[k % DIGESTLENGTH] += element->str[allocs][k];\n+  }\n+  memcpy(element->checkstr[allocs], digest, DIGESTLENGTH);\n+  allocs++;\n+  if (allocs % printperiod == 0) {\n+    printf(\"Check string for thread %s is \", element->str[allocs - 1]);\n+    for (j = 0; j < DIGESTLENGTH; j++) {\n+      printf(\"%02x\", digest[j]);\n@@ -78,8 +96,27 @@\n-    element->str[allocs] = env->GetStringUTFChars(jstr,0); CE\n-    if (strlen(element->str[allocs]) !=\n-        (size_t) env->GetStringUTFLength(jstr))\n-        printf(\"Length is wrong in string No. %d\\n\",allocs);\n-    else\n-        strsize += strlen(element->str[allocs])+1;\n-    for (k = 0; k < strlen(element->str[allocs]); k++) {\n-       digest[k % DIGESTLENGTH] += element->str[allocs][k];\n+    printf(\"\\n\");\n+  }\n+  if (allocs == nstr) {\n+    printf(\"JNI UTF8 strings memory = %zd\\n\", strsize);\n+    tmpstr = env->NewStringUTF(element->str[allocs - 1]); CE\n+    for (j = 0; j < nstr; j++) {\n+\n+      for (i = 0; i < DIGESTLENGTH; i++) {\n+        digest[i] = 0;\n+      }\n+      for (k = 0; k < strlen(element->str[j]); k++) {\n+        digest[k % DIGESTLENGTH] += element->str[j][k];\n+      }\n+      if (memcmp(digest, element->checkstr[j], DIGESTLENGTH) == 0) {\n+        env->ReleaseStringUTFChars(jstr, element->str[j]); CE\n+        element->str[j] = NULL;\n+        element->checkstr[j] = NULL;\n+      } else {\n+        compared = 0;\n+        printf(\"The element No. %d has been corrupted %s vs %s\\n\", j,\n+               element->str[j], element->checkstr[j]);\n+        printf(\"Digest string  is %s [\", element->str[j]);\n+        for (i = 0; i < DIGESTLENGTH; i++) {\n+          printf(\"ch[%d] = %02x\", i, digest[i]);\n+        }\n+        printf(\"Digest end\\n\");\n+      }\n@@ -87,7 +124,4 @@\n-    memcpy(element->checkstr[allocs],digest,DIGESTLENGTH);\n-    allocs++;\n-    if (allocs % printperiod == 0) {\n-        printf(\"Check string for thread %s is \", element->str[allocs-1]);\n-        for (j=0;j<DIGESTLENGTH;j++)\n-            printf(\"%02x\", digest[j]);\n-        printf(\"\\n\");\n+    allocs = 0;\n+    strsize = 0;\n+    for (j = 0; j < nstr; j++) {\n+      free(element->checkstr[j]);\n@@ -95,40 +129,7 @@\n-    if (allocs == nstr) {\n-        printf(\"JNI UTF8 strings memory=%zd\\n\", strsize);\n-        tmpstr=env->NewStringUTF(element->str[allocs-1]); CE\n-        for (j=0; j<nstr; j++) {\n-\n-            for (i=0;i<DIGESTLENGTH;i++) {\n-                digest[i]=0;\n-            }\n-            for (k=0; k < strlen(element->str[j]); k++) {\n-                digest[k % DIGESTLENGTH] += element->str[j][k];\n-            }\n-            if (memcmp(digest,element->checkstr[j],DIGESTLENGTH) == 0) {\n-                env->ReleaseStringUTFChars(jstr,element->str[j]); CE\n-                element->str[j] = NULL;\n-                element->checkstr[j] = NULL;\n-            }\n-            else {\n-                compared=0;\n-                printf(\"The element No. %d has been corrupted %s vs %s\\n\",j, element->str[j],element->checkstr[j]);\n-                printf(\"Digest string  is %s [\", element->str[j]);\n-                for (i=0;i<DIGESTLENGTH;i++)\n-                    printf(\"ch[%d]=%02x\", i, digest[i]);\n-                printf(\"Digest end\\n\");\n-            }\n-        }\n-        allocs=0;\n-        strsize = 0;\n-        for (j=0;j<nstr;j++)\n-            free(element->checkstr[j]);\n-        free(element->checkstr);\n-        free((void *)(element->str));\n-        free(element);\n-        clazz=env->FindClass(clsName); CE\n-        if (!compared) {\n-            methodID=env->GetStaticMethodID(clazz, name, sig); CE\n-            env->CallStaticVoidMethod(clazz, methodID, JNI_FALSE); CE\n-        }\n-        \/\/methodID=env->GetStaticMethodID(clazz, halt, haltSig); CE\n-        \/\/env->CallStaticVoidMethod(clazz, methodID); CE\n-        return(tmpstr);\n+    free(element->checkstr);\n+    free((void *)(element->str));\n+    free(element);\n+    clazz = env->FindClass(clsName); CE\n+    if (!compared) {\n+      methodID = env->GetStaticMethodID(clazz, name, sig); CE\n+      env->CallStaticVoidMethod(clazz, methodID, JNI_FALSE); CE\n@@ -136,2 +137,6 @@\n-    env->MonitorExit(jobj); CE\n-    return (env->NewStringUTF(element->str[allocs-1]));\n+    \/\/methodID = env->GetStaticMethodID(clazz, halt, haltSig); CE\n+    \/\/env->CallStaticVoidMethod(clazz, methodID); CE\n+    return tmpstr;\n+  }\n+  CHECK(env->MonitorExit(jobj));\n+  return (env->NewStringUTF(element->str[allocs - 1]));\n@@ -142,31 +147,28 @@\n-                    jint nstr, jint printperiod) {\n-\n-    int i,j;\n-    static JCHAR_ARRAY *javachars;\n-    unsigned char digest[DIGESTLENGTH];\n-    static int index=0;\n-    static long len=0;\n-    static unsigned int equal=1;\n-    char *elem;\n-    int elem_len = -1;\n-\n-    const char *clsName = \"nsk\/stress\/jni\/JNIter001\";\n-    const char *name=\"setpass\";\n-    const char *sig=\"(Z)V\";\n-    const char *halt=\"halt\";\n-    const char *haltSig=\"()V\";\n-    jstring tmpstr;\n-    jclass clazz;\n-    jmethodID methodID;\n-\n-    env->MonitorEnter(jobj); CE\n-    if (!index) {\n-        javachars = (JCHAR_ARRAY *)c_malloc(env, sizeof(JCHAR_ARRAY));\n-        javachars->str = (const jchar **)c_malloc(env, nstr*sizeof(const jchar *));\n-        javachars->checkstr = (char **)c_malloc(env, nstr*sizeof(char *));\n-        javachars->size = (int *)c_malloc(env, nstr*sizeof(int));\n-        for (j=0;j<nstr;j++)\n-            javachars->checkstr[j] = (char *)c_malloc(env, DIGESTLENGTH*sizeof(char));\n-    }\n-    for (j=0;j<DIGESTLENGTH;j++) {\n-        digest[j]=0;\n+                                         jint nstr, jint printperiod) {\n+\n+  int i, j;\n+  static JCHAR_ARRAY *javachars;\n+  unsigned char digest[DIGESTLENGTH];\n+  static int index = 0;\n+  static long len = 0;\n+  static unsigned int equal = 1;\n+  char *elem;\n+  int elem_len = -1;\n+\n+  const char *clsName = \"nsk\/stress\/jni\/JNIter001\";\n+  const char *name = \"setpass\";\n+  const char *sig = \"(Z)V\";\n+  const char *halt = \"halt\";\n+  const char *haltSig = \"()V\";\n+  jstring tmpstr;\n+  jclass clazz;\n+  jmethodID methodID;\n+\n+  CHECK(env->MonitorEnter(jobj));\n+  if (!index) {\n+    javachars = (JCHAR_ARRAY *)c_malloc(env, sizeof(JCHAR_ARRAY));\n+    javachars->str = (const jchar **)c_malloc(env, nstr * sizeof(const jchar*));\n+    javachars->checkstr = (char **)c_malloc(env, nstr * sizeof(char*));\n+    javachars->size = (int *)c_malloc(env, nstr * sizeof(int));\n+    for (j = 0; j < nstr; j++) {\n+      javachars->checkstr[j] = (char *)c_malloc(env, DIGESTLENGTH * sizeof(char));\n@@ -174,7 +176,22 @@\n-    javachars->str[index] = env->GetStringChars(jstr,0); CE\n-    javachars->size[index] = env->GetStringUTFLength(jstr); CE\n-    elem_len = javachars->size[index];\n-    len += elem_len;\n-    elem = (char*) c_malloc(env, elem_len*sizeof(char));\n-    for (j=0; j < elem_len; j++) {\n-        elem[j] = (char) javachars->str[index][j];\n+  }\n+  for (j = 0; j < DIGESTLENGTH; j++) {\n+    digest[j] = 0;\n+  }\n+  javachars->str[index] = env->GetStringChars(jstr, 0); CE\n+  javachars->size[index] = env->GetStringUTFLength(jstr); CE\n+  elem_len = javachars->size[index];\n+  len += elem_len;\n+  elem = (char*) c_malloc(env, elem_len * sizeof(char));\n+  for (j = 0; j < elem_len; j++) {\n+    elem[j] = (char) javachars->str[index][j];\n+  }\n+\n+  \/\/memcpy(digest, elem, javachars->size[index]);\n+  for (j = 0; j < elem_len; j++) {\n+    digest[j % DIGESTLENGTH] += elem[j];\n+  }\n+  memcpy(javachars->checkstr[index++], digest, DIGESTLENGTH);\n+  if (index % printperiod == 0) {\n+    printf(\"Check string sum for thread %.*s is \", elem_len, elem);\n+    for (j = 0; j < DIGESTLENGTH; j++) {\n+      printf(\"%02x\", digest[j]);\n@@ -182,4 +199,31 @@\n-\n-    \/\/memcpy(digest, elem, javachars->size[index]);\n-    for (j=0;j<elem_len; j++) {\n-        digest[j % DIGESTLENGTH]+=elem[j];\n+    printf(\"\\n\");\n+  }\n+  free(elem);\n+  if (index == nstr) {\n+    printf(\"JNI Unicode strings memory = %ld\\n\", len);\n+    tmpstr = env->NewString(javachars->str[index - 1], elem_len); CE\n+    for (j = 0; j < nstr; j++) {\n+      elem = (char*) c_malloc(env, javachars->size[j] * sizeof(char));\n+      for (i = 0; i < javachars->size[j]; i++) {\n+        elem[i] = (char) javachars->str[j][i];\n+      }\n+      \/\/memcpy(digest, elem, javachars->size[j]);\n+      for (i = 0; i < DIGESTLENGTH; i++) {\n+        digest[i] = 0;\n+      }\n+      for (i = 0; i < javachars->size[j]; i++) {\n+        digest[i % DIGESTLENGTH] += elem[i];\n+      }\n+      free(elem);\n+      if (memcmp(digest, javachars->checkstr[j], javachars->size[j]) == 0) {\n+        env->ReleaseStringChars(jstr, javachars->str[j]); CE\n+        javachars->str[j] = NULL;\n+        javachars->checkstr[j] = NULL;\n+        javachars->size[j] = 0;\n+      } else {\n+        equal = 0;\n+        printf(\"The Unicode element No. %d has been corrupted\\n\", j);\n+        for (i = 0; i < DIGESTLENGTH; i++) {\n+          printf(\"digest[%d] = %02x checkstr[%d] = %02x\\n\", i, digest[i], i, javachars->checkstr[j][i]);\n+        }\n+      }\n@@ -187,6 +231,4 @@\n-    memcpy(javachars->checkstr[index++],digest,DIGESTLENGTH);\n-    if (index % printperiod == 0) {\n-        printf(\"Check string sum for thread %.*s is \", elem_len, elem);\n-        for (j=0;j<DIGESTLENGTH;j++)\n-            printf(\"%02x\", digest[j]);\n-        printf(\"\\n\");\n+    index = 0;\n+    len = 0;\n+    for (j = 0; j < nstr; j++) {\n+      free(javachars->checkstr[j]);\n@@ -194,47 +236,8 @@\n-    free(elem);\n-    if (index == nstr) {\n-        printf(\"JNI Unicode strings memory=%ld\\n\",len);\n-        tmpstr=env->NewString(javachars->str[index-1],elem_len); CE\n-        for (j=0; j<nstr; j++) {\n-            elem = (char*) c_malloc(env, javachars->size[j]*sizeof(char));\n-            for (i=0; i < javachars->size[j]; i++) {\n-                elem[i] = (char) javachars->str[j][i];\n-            }\n-            \/\/memcpy(digest, elem, javachars->size[j]);\n-            for (i=0;i<DIGESTLENGTH;i++) {\n-                digest[i]=0;\n-            }\n-            for (i=0;i<javachars->size[j]; i++) {\n-                digest[i % DIGESTLENGTH]+=elem[i];\n-            }\n-            free(elem);\n-            if (memcmp(digest,javachars->checkstr[j],javachars->size[j]) == 0) {\n-                env->ReleaseStringChars(jstr,javachars->str[j]); CE\n-                javachars->str[j] = NULL;\n-                javachars->checkstr[j] = NULL;\n-                javachars->size[j] = 0;\n-            }\n-            else {\n-                equal=0;\n-                printf(\"The Unicode element No. %d has been corrupted\\n\",j);\n-                for (i=0;i<DIGESTLENGTH;i++) {\n-                    printf(\"digest[%d]=%02x checkstr[%d]=%02x\\n\",i,digest[i],i,javachars->checkstr[j][i]);\n-                }\n-            }\n-        }\n-        index=0;\n-        len = 0;\n-        for (j=0;j<nstr;j++)\n-            free(javachars->checkstr[j]);\n-        free(javachars->checkstr);\n-        free((void *)(javachars->str));\n-        free(javachars->size);\n-        free(javachars);\n-        clazz=env->FindClass(clsName); CE\n-        if (!equal) {\n-            methodID=env->GetStaticMethodID(clazz, name, sig); CE\n-            env->CallStaticVoidMethod(clazz, methodID, JNI_FALSE); CE\n-        }\n-        \/\/methodID=env->GetStaticMethodID(clazz, halt, haltSig); CE\n-        \/\/env->CallStaticVoidMethod(clazz, methodID); CE\n-        return(tmpstr);\n+    free(javachars->checkstr);\n+    free((void *)(javachars->str));\n+    free(javachars->size);\n+    free(javachars);\n+    clazz = env->FindClass(clsName); CE\n+    if (!equal) {\n+      methodID = env->GetStaticMethodID(clazz, name, sig); CE\n+      env->CallStaticVoidMethod(clazz, methodID, JNI_FALSE); CE\n@@ -242,2 +245,6 @@\n-    env->MonitorExit(jobj); CE\n-    return(env->NewString(javachars->str[index-1],elem_len));\n+    \/\/methodID = env->GetStaticMethodID(clazz, halt, haltSig); CE\n+    \/\/env->CallStaticVoidMethod(clazz, methodID); CE\n+    return tmpstr;\n+  }\n+  CHECK(env->MonitorExit(jobj));\n+  return env->NewString(javachars->str[index - 1], elem_len);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress001.cpp","additions":195,"deletions":188,"binary":false,"changes":383,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-  va_start(ap,methodID);\n-  tmp=env->NewObjectV(clazz, methodID, ap);\n+  va_start(ap, methodID);\n+  tmp = env->NewObjectV(clazz, methodID, ap);\n@@ -42,1 +42,1 @@\n-              jlong lng, jcharArray jChArr, jfloat flt, jdouble dbl) {\n+                                          jlong lng, jcharArray jChArr, jfloat flt, jdouble dbl) {\n@@ -49,8 +49,9 @@\n-  const char *classname=\"nsk\/stress\/jni\/objectsJNI\";\n-  const char *name=\"<init>\";\n-  const char *sig=\"(Ljava\/lang\/String;IJ[CFD)V\";\n-  const char *upperClassName=\"nsk\/stress\/jni\/jnistress002\";\n-  const char *fieldName=\"jniStringAllocSize\";\n-  const char *fieldSig=\"I\";\n-  const char *setpass=\"halt\";\n-  const char *setpassSig=\"()V\";\n+  jfieldID fieldID;\n+  const char *classname = \"nsk\/stress\/jni\/objectsJNI\";\n+  const char *name = \"<init>\";\n+  const char *sig = \"(Ljava\/lang\/String;IJ[CFD)V\";\n+  const char *upperClassName = \"nsk\/stress\/jni\/jnistress002\";\n+  const char *fieldName = \"jniStringAllocSize\";\n+  const char *fieldSig = \"I\";\n+  const char *setpass = \"halt\";\n+  const char *setpassSig = \"()V\";\n@@ -59,1 +60,1 @@\n-  env->MonitorEnter(jobj); CE\n+  CHECK(env->MonitorEnter(jobj));\n@@ -61,7 +62,7 @@\n-  env->MonitorExit(jobj); CE\n-  paramArr[0].l=jstr;\n-  paramArr[1].i=intgr;\n-  paramArr[2].j=lng;\n-  paramArr[3].l=jChArr;\n-  paramArr[4].f=flt;\n-  paramArr[5].d=dbl;\n+  CHECK(env->MonitorExit(jobj));\n+  paramArr[0].l = jstr;\n+  paramArr[1].i = intgr;\n+  paramArr[2].j = lng;\n+  paramArr[3].l = jChArr;\n+  paramArr[4].f = flt;\n+  paramArr[5].d = dbl;\n@@ -69,7 +70,3 @@\n-  clazz=env->FindClass(classname); CE\n-  obj=env->NewObjectArray((jsize)3,clazz,\n-                 env->AllocObject(clazz)); CE\n-  if (obj == NULL) {\n-    fprintf(stderr,\"Can not construct the object Array for  %s\\n\", classname);\n-    return(NULL);\n-  }\n+  clazz = env->FindClass(classname); CE\n+  element = env->AllocObject(clazz); CE\n+  obj = env->NewObjectArray((jsize)3, clazz, element); CE\n@@ -77,5 +74,1 @@\n-  methodID=env->GetMethodID(clazz,name,sig); CE\n-  if (methodID == NULL) {\n-    fprintf(stderr,\"Can not get the ID of <init> for %s\\n\", classname);\n-    return(NULL);\n-  }\n+  methodID = env->GetMethodID(clazz, name, sig); CE\n@@ -83,5 +76,5 @@\n-  element=env->NewObject(clazz,methodID,\n-                jstr, intgr, lng, jChArr, flt, dbl); CE\n-  env->SetObjectArrayElement(obj,0,element); CE\n-  element=env->NewObjectA(clazz,methodID,paramArr); CE\n-  env->SetObjectArrayElement(obj,1,element); CE\n+  element = env->NewObject(clazz, methodID,\n+                           jstr, intgr, lng, jChArr, flt, dbl); CE\n+  env->SetObjectArrayElement(obj, 0, element); CE\n+  element = env->NewObjectA(clazz, methodID, paramArr); CE\n+  env->SetObjectArrayElement(obj, 1, element); CE\n@@ -89,2 +82,2 @@\n-                jstr, intgr, lng, jChArr, flt, dbl); CE\n-  env->SetObjectArrayElement(obj,2,element); CE\n+                            jstr, intgr, lng, jChArr, flt, dbl); CE\n+  env->SetObjectArrayElement(obj, 2, element); CE\n@@ -92,6 +85,6 @@\n-  clazzUp=env->FindClass(upperClassName); CE\n-  if (classCount == env->GetStaticIntField(clazzUp,\n-      env->GetStaticFieldID(clazzUp,fieldName,fieldSig))) {\n-    classname=\"nsk\/stress\/jni\/JNIter002\";\n-    clazz=env->FindClass(classname); CE\n-    methodID=env->GetStaticMethodID(clazz, setpass, setpassSig); CE\n+  clazzUp = env->FindClass(upperClassName); CE\n+  fieldID = env->GetStaticFieldID(clazzUp, fieldName, fieldSig); CE\n+  if (classCount == env->GetStaticIntField(clazzUp, fieldID)) {\n+    classname = \"nsk\/stress\/jni\/JNIter002\";\n+    clazz = env->FindClass(classname); CE\n+    methodID = env->GetStaticMethodID(clazz, setpass, setpassSig); CE\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress002.cpp","additions":38,"deletions":45,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,10 +43,10 @@\n-    jarray *arrayArray;\n-    jboolean *boolBuf;\n-    jbyte *byteBuf;\n-    jchar *charBuf;\n-    jshort *shortBuf;\n-    jint *intBuf;\n-    jlong *longBuf;\n-    jfloat *floatBuf;\n-    jdouble *doubleBuf;\n-    jobjectArray objectsArray;\n+  jarray *arrayArray;\n+  jboolean *boolBuf;\n+  jbyte *byteBuf;\n+  jchar *charBuf;\n+  jshort *shortBuf;\n+  jint *intBuf;\n+  jlong *longBuf;\n+  jfloat *floatBuf;\n+  jdouble *doubleBuf;\n+  jobjectArray objectsArray;\n@@ -54,5 +54,6 @@\n-    int i;\n-    int SIZE=size;\n-    const char *classname=\"java\/lang\/Object\";\n-    jclass clazz = env->FindClass(classname); CE\n-    objectsArray = env->NewObjectArray(8,clazz, env->AllocObject(clazz));\n+  int i;\n+  int SIZE = size;\n+  const char *classname = \"java\/lang\/Object\";\n+  jclass clazz = env->FindClass(classname); CE\n+  jobject obj = env->AllocObject(clazz); CE\n+  objectsArray = env->NewObjectArray(8, clazz, obj); CE\n@@ -60,9 +61,9 @@\n-    arrayArray=(jarray *)malloc(8*sizeof(jarray)); CE\n-    arrayArray[BOOL]=env->NewBooleanArray(SIZE); CE\n-    arrayArray[BYTE]=env->NewByteArray(SIZE); CE\n-    arrayArray[CHAR]=env->NewCharArray(SIZE); CE\n-    arrayArray[SHORT]=env->NewShortArray(SIZE); CE\n-    arrayArray[INT]=env->NewIntArray(SIZE); CE\n-    arrayArray[LONG]=env->NewLongArray(SIZE); CE\n-    arrayArray[FLOAT]=env->NewFloatArray(SIZE); CE\n-    arrayArray[DOUBLE]=env->NewDoubleArray(SIZE); CE\n+  arrayArray = (jarray *)c_malloc(env, 8*sizeof(jarray));\n+  arrayArray[BOOL] = env->NewBooleanArray(SIZE); CE\n+  arrayArray[BYTE] = env->NewByteArray(SIZE); CE\n+  arrayArray[CHAR] = env->NewCharArray(SIZE); CE\n+  arrayArray[SHORT] = env->NewShortArray(SIZE); CE\n+  arrayArray[INT] = env->NewIntArray(SIZE); CE\n+  arrayArray[LONG] = env->NewLongArray(SIZE); CE\n+  arrayArray[FLOAT] = env->NewFloatArray(SIZE); CE\n+  arrayArray[DOUBLE] = env->NewDoubleArray(SIZE); CE\n@@ -70,2 +71,3 @@\n-    for (i=0;i<8;i++)\n-    { env->SetObjectArrayElement(objectsArray,i,arrayArray[i]); CE }\n+  for (i = 0; i < 8; i++) {\n+    env->SetObjectArrayElement(objectsArray, i,arrayArray[i]); CE\n+  }\n@@ -73,8 +75,8 @@\n-    boolBuf=(jboolean *)malloc(SIZE*sizeof(jboolean));\n-    byteBuf=(jbyte *)malloc(SIZE*sizeof(jbyte));\n-    charBuf=(jchar *)malloc(SIZE*sizeof(jchar));\n-    shortBuf=(jshort *)malloc(SIZE*sizeof(jshort));\n-    intBuf=(jint *)malloc(SIZE*sizeof(jint));\n-    longBuf=(jlong *)malloc(SIZE*sizeof(jlong));\n-    floatBuf=(jfloat *)malloc(SIZE*sizeof(jfloat));\n-    doubleBuf=(jdouble *)malloc(SIZE*sizeof(jdouble));\n+  boolBuf = (jboolean *)c_malloc(env, SIZE * sizeof(jboolean));\n+  byteBuf = (jbyte *)c_malloc(env, SIZE * sizeof(jbyte));\n+  charBuf = (jchar *)c_malloc(env, SIZE * sizeof(jchar));\n+  shortBuf = (jshort *)c_malloc(env, SIZE * sizeof(jshort));\n+  intBuf = (jint *)c_malloc(env, SIZE * sizeof(jint));\n+  longBuf = (jlong *)c_malloc(env, SIZE * sizeof(jlong));\n+  floatBuf = (jfloat *)c_malloc(env, SIZE * sizeof(jfloat));\n+  doubleBuf = (jdouble *)c_malloc(env, SIZE * sizeof(jdouble));\n@@ -82,3 +84,2 @@\n-    for (i=0;i<SIZE;i++) {\n-    if (i%2 == 0) boolBuf[i]=JNI_TRUE;\n-    else boolBuf[i]=JNI_FALSE;\n+  for (i = 0; i < SIZE; i++) {\n+    boolBuf[i] = (i % 2 == 0) ? JNI_TRUE : JNI_FALSE;\n@@ -86,7 +87,7 @@\n-      byteBuf[i]=(jbyte)random();\n-      charBuf[i]=(jchar)random();\n-      shortBuf[i]=(jshort)random();\n-      intBuf[i]=(jint)random();\n-      longBuf[i]=(jlong)random();\n-      floatBuf[i]=(jfloat)((random()));\n-      doubleBuf[i]=(jdouble)((random()));\n+      byteBuf[i] = (jbyte)random();\n+      charBuf[i] = (jchar)random();\n+      shortBuf[i] = (jshort)random();\n+      intBuf[i] = (jint)random();\n+      longBuf[i] = (jlong)random();\n+      floatBuf[i] = (jfloat)((random()));\n+      doubleBuf[i] = (jdouble)((random()));\n@@ -94,16 +95,16 @@\n-    byteBuf[i]=(jbyte)109;\n-    charBuf[i]=(jchar)214;\n-    shortBuf[i]=(jshort)9223;\n-    intBuf[i]=(jint)872634;\n-    longBuf[i]=(jlong)276458276;\n-    floatBuf[i]=(jfloat)235.4576284;\n-    doubleBuf[i]=(jdouble)98275.716253567;\n-    }\n-    env->SetBooleanArrayRegion((jbooleanArray) arrayArray[BOOL],0,i,boolBuf); CE\n-    env->SetByteArrayRegion((jbyteArray) arrayArray[BYTE],0,i,byteBuf); CE\n-    env->SetCharArrayRegion((jcharArray) arrayArray[CHAR],0,i,charBuf); CE\n-    env->SetShortArrayRegion((jshortArray) arrayArray[SHORT],0,i,shortBuf); CE\n-    env->SetIntArrayRegion((jintArray) arrayArray[INT],0,i,intBuf); CE\n-    env->SetLongArrayRegion((jlongArray) arrayArray[LONG],0,i,longBuf); CE\n-    env->SetFloatArrayRegion((jfloatArray) arrayArray[FLOAT],0,i,floatBuf); CE\n-    env->SetDoubleArrayRegion((jdoubleArray) arrayArray[DOUBLE],0,i,doubleBuf); CE\n+    byteBuf[i] = (jbyte)109;\n+    charBuf[i] = (jchar)214;\n+    shortBuf[i] = (jshort)9223;\n+    intBuf[i] = (jint)872634;\n+    longBuf[i] = (jlong)276458276;\n+    floatBuf[i] = (jfloat)235.4576284;\n+    doubleBuf[i] = (jdouble)98275.716253567;\n+  }\n+  env->SetBooleanArrayRegion((jbooleanArray) arrayArray[BOOL], 0, i, boolBuf); CE\n+  env->SetByteArrayRegion((jbyteArray) arrayArray[BYTE], 0, i, byteBuf); CE\n+  env->SetCharArrayRegion((jcharArray) arrayArray[CHAR], 0, i, charBuf); CE\n+  env->SetShortArrayRegion((jshortArray) arrayArray[SHORT], 0, i, shortBuf); CE\n+  env->SetIntArrayRegion((jintArray) arrayArray[INT], 0, i, intBuf); CE\n+  env->SetLongArrayRegion((jlongArray) arrayArray[LONG], 0, i, longBuf); CE\n+  env->SetFloatArrayRegion((jfloatArray) arrayArray[FLOAT], 0, i, floatBuf); CE\n+  env->SetDoubleArrayRegion((jdoubleArray) arrayArray[DOUBLE], 0, i, doubleBuf); CE\n@@ -111,9 +112,9 @@\n-    free(doubleBuf);\n-    free(floatBuf);\n-    free(longBuf);\n-    free(intBuf);\n-    free(shortBuf);\n-    free(byteBuf);\n-    free(charBuf);\n-    free(boolBuf);\n-    free(arrayArray);\n+  free(doubleBuf);\n+  free(floatBuf);\n+  free(longBuf);\n+  free(intBuf);\n+  free(shortBuf);\n+  free(byteBuf);\n+  free(charBuf);\n+  free(boolBuf);\n+  free(arrayArray);\n@@ -121,1 +122,1 @@\n-    return objectsArray;\n+  return objectsArray;\n@@ -126,1 +127,1 @@\n-                jobjectArray orig, jobjectArray clone, jint limit) {\n+                                                  jobjectArray orig, jobjectArray clone, jint limit) {\n@@ -128,1 +129,1 @@\n-#define SWAP(param1, param2) tmparr=param2; param2=param1; param1=tmparr;\n+#define SWAP(param1, param2) tmparr = param2; param2 = param1; param1 = tmparr;\n@@ -131,11 +132,11 @@\n-    static volatile long count=0;\n-    jarray *arrayOrig, *arrayClone;\n-    jboolean *boolOrig, *boolClone;\n-    jbyte *byteOrig, *byteClone;\n-    jchar *charOrig, *charClone;\n-    jshort *shortOrig, *shortClone;\n-    jint *intOrig, *intClone;\n-    jlong *longOrig, *longClone;\n-    jfloat *floatOrig, *floatClone;\n-    jdouble *doubleOrig, *doubleClone;\n-    int i;\n+  static volatile long count = 0;\n+  jarray *arrayOrig, *arrayClone;\n+  jboolean *boolOrig, *boolClone;\n+  jbyte *byteOrig, *byteClone;\n+  jchar *charOrig, *charClone;\n+  jshort *shortOrig, *shortClone;\n+  jint *intOrig, *intClone;\n+  jlong *longOrig, *longClone;\n+  jfloat *floatOrig, *floatClone;\n+  jdouble *doubleOrig, *doubleClone;\n+  int i;\n@@ -143,2 +144,2 @@\n-    if ((orig == NULL) || (clone == NULL)) {\n-    fprintf(stderr,\"JNI received a NULL array from Java\\n\");\n+  if ((orig == NULL) || (clone == NULL)) {\n+    fprintf(stderr, \"JNI received a NULL array from Java\\n\");\n@@ -146,2 +147,2 @@\n-    }\n-    if (count == limit) {\n+  }\n+  if (count == limit) {\n@@ -155,3 +156,3 @@\n-    clazz=env->FindClass(classname); CE\n-        jmethod=env->GetMethodID(clazz, setdone, setdonesig); CE\n-        env->CallVoidMethod(jobj, jmethod); CE\n+    clazz = env->FindClass(classname); CE\n+    jmethod = env->GetMethodID(clazz, setdone, setdonesig); CE\n+    env->CallVoidMethod(jobj, jmethod); CE\n@@ -160,10 +161,10 @@\n-    }\n-    env->MonitorEnter(jobj); CE\n-    ++count;\n-    env->MonitorExit(jobj); CE\n-    arrayOrig=(jarray *)malloc(8*sizeof(jarray));\n-    arrayClone=(jarray *)malloc(8*sizeof(jarray));\n-    for (i=0;i<8;i++) {\n-    arrayOrig[i]=(jarray) env->GetObjectArrayElement(orig,i); CE\n-    arrayClone[i]=(jarray) env->GetObjectArrayElement(clone,i); CE\n-    }\n+  }\n+  CHECK(env->MonitorEnter(jobj));\n+  ++count;\n+  CHECK(env->MonitorExit(jobj));\n+  arrayOrig = (jarray *)c_malloc(env, 8 * sizeof(jarray));\n+  arrayClone = (jarray *)c_malloc(env, 8 * sizeof(jarray));\n+  for (i = 0; i < 8; i++) {\n+    arrayOrig[i] = (jarray) env->GetObjectArrayElement(orig, i); CE\n+    arrayClone[i] = (jarray) env->GetObjectArrayElement(clone, i); CE\n+  }\n@@ -171,10 +172,10 @@\n-    \/* Take the elements from Java arrays into native buffers *\/\n-    \/* Use Get<Type>ArrayElements *\/\n-    boolOrig = env->GetBooleanArrayElements((jbooleanArray) arrayOrig[BOOL],0); CE\n-    byteOrig = env->GetByteArrayElements((jbyteArray) arrayOrig[BYTE],0); CE\n-    charOrig = env->GetCharArrayElements((jcharArray) arrayOrig[CHAR],0); CE\n-    shortOrig = env->GetShortArrayElements((jshortArray) arrayOrig[SHORT],0); CE\n-    intOrig = env->GetIntArrayElements((jintArray) arrayOrig[INT],0); CE\n-    longOrig = env->GetLongArrayElements((jlongArray) arrayOrig[LONG],0); CE\n-    floatOrig = env->GetFloatArrayElements((jfloatArray) arrayOrig[FLOAT],0); CE\n-    doubleOrig = env->GetDoubleArrayElements((jdoubleArray) arrayOrig[DOUBLE],0); CE\n+  \/* Take the elements from Java arrays into native buffers *\/\n+  \/* Use Get<Type>ArrayElements *\/\n+  boolOrig = env->GetBooleanArrayElements((jbooleanArray) arrayOrig[BOOL], 0); CE\n+  byteOrig = env->GetByteArrayElements((jbyteArray) arrayOrig[BYTE], 0); CE\n+  charOrig = env->GetCharArrayElements((jcharArray) arrayOrig[CHAR], 0); CE\n+  shortOrig = env->GetShortArrayElements((jshortArray) arrayOrig[SHORT], 0); CE\n+  intOrig = env->GetIntArrayElements((jintArray) arrayOrig[INT], 0); CE\n+  longOrig = env->GetLongArrayElements((jlongArray) arrayOrig[LONG], 0); CE\n+  floatOrig = env->GetFloatArrayElements((jfloatArray) arrayOrig[FLOAT], 0); CE\n+  doubleOrig = env->GetDoubleArrayElements((jdoubleArray) arrayOrig[DOUBLE], 0); CE\n@@ -182,9 +183,9 @@\n-    \/* Alloc some memory for cloned arrays buffers *\/\n-    boolClone=(jboolean *)malloc(SIZE(BOOL)*sizeof(jboolean));\n-    byteClone=(jbyte *)malloc(SIZE(BYTE)*sizeof(jbyte));\n-    charClone=(jchar *)malloc(SIZE(CHAR)*sizeof(jchar));\n-    shortClone=(jshort *)malloc(SIZE(SHORT)*sizeof(jshort));\n-    intClone=(jint *)malloc(SIZE(INT)*sizeof(jint));\n-    longClone=(jlong *)malloc(SIZE(LONG)*sizeof(jlong));\n-    floatClone=(jfloat *)malloc(SIZE(FLOAT)*sizeof(jfloat));\n-    doubleClone=(jdouble *)malloc(SIZE(DOUBLE)*sizeof(jdouble));\n+  \/* Alloc some memory for cloned arrays buffers *\/\n+  boolClone = (jboolean *)c_malloc(env, SIZE(BOOL) * sizeof(jboolean));\n+  byteClone = (jbyte *)c_malloc(env, SIZE(BYTE) * sizeof(jbyte));\n+  charClone = (jchar *)c_malloc(env, SIZE(CHAR) * sizeof(jchar));\n+  shortClone = (jshort *)c_malloc(env, SIZE(SHORT) * sizeof(jshort));\n+  intClone = (jint *)c_malloc(env, SIZE(INT) * sizeof(jint));\n+  longClone = (jlong *)c_malloc(env, SIZE(LONG) * sizeof(jlong));\n+  floatClone = (jfloat *)c_malloc(env, SIZE(FLOAT) * sizeof(jfloat));\n+  doubleClone = (jdouble *)c_malloc(env, SIZE(DOUBLE) * sizeof(jdouble));\n@@ -194,8 +195,8 @@\n-    env->GetBooleanArrayRegion((jbooleanArray) arrayClone[BOOL],0,SIZE(BOOL),boolClone); CE\n-    env->GetByteArrayRegion((jbyteArray) arrayClone[BYTE],0,SIZE(BYTE),byteClone); CE\n-    env->GetCharArrayRegion((jcharArray) arrayClone[CHAR],0,SIZE(CHAR),charClone); CE\n-    env->GetShortArrayRegion((jshortArray) arrayClone[SHORT],0,SIZE(SHORT),shortClone); CE\n-    env->GetIntArrayRegion((jintArray) arrayClone[INT],0,SIZE(INT),intClone); CE\n-    env->GetLongArrayRegion((jlongArray) arrayClone[LONG],0,SIZE(LONG),longClone); CE\n-    env->GetFloatArrayRegion((jfloatArray) arrayClone[FLOAT],0,SIZE(FLOAT),floatClone); CE\n-    env->GetDoubleArrayRegion((jdoubleArray) arrayClone[DOUBLE],0,SIZE(DOUBLE),doubleClone); CE\n+  env->GetBooleanArrayRegion((jbooleanArray) arrayClone[BOOL], 0, SIZE(BOOL), boolClone); CE\n+  env->GetByteArrayRegion((jbyteArray) arrayClone[BYTE], 0, SIZE(BYTE), byteClone); CE\n+  env->GetCharArrayRegion((jcharArray) arrayClone[CHAR], 0, SIZE(CHAR), charClone); CE\n+  env->GetShortArrayRegion((jshortArray) arrayClone[SHORT], 0, SIZE(SHORT), shortClone); CE\n+  env->GetIntArrayRegion((jintArray) arrayClone[INT], 0, SIZE(INT), intClone); CE\n+  env->GetLongArrayRegion((jlongArray) arrayClone[LONG], 0, SIZE(LONG), longClone); CE\n+  env->GetFloatArrayRegion((jfloatArray) arrayClone[FLOAT], 0, SIZE(FLOAT), floatClone); CE\n+  env->GetDoubleArrayRegion((jdoubleArray) arrayClone[DOUBLE], 0, SIZE(DOUBLE), doubleClone); CE\n@@ -206,11 +207,11 @@\n-\/*\n-Can't change the pointer into the Java structure.  It's illegal JNI.\n-    SWAP(boolOrig,boolClone)\n-    SWAP(byteOrig,byteClone)\n-    SWAP(charOrig,charClone)\n-    SWAP(shortOrig,shortClone)\n-    SWAP(intOrig,intClone)\n-    SWAP(longOrig,longClone)\n-    SWAP(floatOrig,floatClone)\n-    SWAP(doubleOrig,doubleClone)\n-*\/\n+  \/*\n+    Can't change the pointer into the Java structure.  It's illegal JNI.\n+    SWAP(boolOrig, boolClone)\n+    SWAP(byteOrig, byteClone)\n+    SWAP(charOrig, charClone)\n+    SWAP(shortOrig, shortClone)\n+    SWAP(intOrig, intClone)\n+    SWAP(longOrig, longClone)\n+    SWAP(floatOrig, floatClone)\n+    SWAP(doubleOrig, doubleClone)\n+  *\/\n@@ -218,21 +219,21 @@\n-    \/* Coping new values of elements back to Java and releasing native buffers *\/\n-    \/* Use Set<Type>ArrayRegion *\/\n-\/*\n-Use Orig pointers to get the original effect of the test.\n-    env->SetBooleanArrayRegion(arrayClone[BOOL],0,SIZE(BOOL),boolClone);\n-    env->SetByteArrayRegion(arrayClone[BYTE],0,SIZE(BYTE),byteClone);\n-    env->SetCharArrayRegion(arrayClone[CHAR],0,SIZE(CHAR),charClone);\n-    env->SetShortArrayRegion(arrayClone[SHORT],0,SIZE(SHORT),shortClone);\n-    env->SetIntArrayRegion(arrayClone[INT],0,SIZE(INT),intClone);\n-    env->SetLongArrayRegion(arrayClone[LONG],0,SIZE(LONG),longClone);\n-    env->SetFloatArrayRegion(arrayClone[FLOAT],0,SIZE(FLOAT),floatClone);\n-    env->SetDoubleArrayRegion(arrayClone[DOUBLE],0,SIZE(DOUBLE),doubleClone);\n-*\/\n-    env->SetBooleanArrayRegion((jbooleanArray) arrayClone[BOOL],0,SIZE(BOOL),boolOrig); CE\n-    env->SetByteArrayRegion((jbyteArray) arrayClone[BYTE],0,SIZE(BYTE),byteOrig); CE\n-    env->SetCharArrayRegion((jcharArray) arrayClone[CHAR],0,SIZE(CHAR),charOrig); CE\n-    env->SetShortArrayRegion((jshortArray) arrayClone[SHORT],0,SIZE(SHORT),shortOrig); CE\n-    env->SetIntArrayRegion((jintArray) arrayClone[INT],0,SIZE(INT),intOrig); CE\n-    env->SetLongArrayRegion((jlongArray) arrayClone[LONG],0,SIZE(LONG),longOrig); CE\n-    env->SetFloatArrayRegion((jfloatArray) arrayClone[FLOAT],0,SIZE(FLOAT),floatOrig); CE\n-    env->SetDoubleArrayRegion((jdoubleArray) arrayClone[DOUBLE],0,SIZE(DOUBLE),doubleOrig); CE\n+  \/* Coping new values of elements back to Java and releasing native buffers *\/\n+  \/* Use Set<Type>ArrayRegion *\/\n+  \/*\n+    Use Orig pointers to get the original effect of the test.\n+    env->SetBooleanArrayRegion(arrayClone[BOOL], 0,SIZE(BOOL), boolClone);\n+    env->SetByteArrayRegion(arrayClone[BYTE], 0,SIZE(BYTE), byteClone);\n+    env->SetCharArrayRegion(arrayClone[CHAR], 0,SIZE(CHAR), charClone);\n+    env->SetShortArrayRegion(arrayClone[SHORT], 0,SIZE(SHORT), shortClone);\n+    env->SetIntArrayRegion(arrayClone[INT], 0,SIZE(INT), intClone);\n+    env->SetLongArrayRegion(arrayClone[LONG], 0,SIZE(LONG), longClone);\n+    env->SetFloatArrayRegion(arrayClone[FLOAT], 0,SIZE(FLOAT), floatClone);\n+    env->SetDoubleArrayRegion(arrayClone[DOUBLE], 0,SIZE(DOUBLE), doubleClone);\n+  *\/\n+  env->SetBooleanArrayRegion((jbooleanArray) arrayClone[BOOL], 0, SIZE(BOOL), boolOrig); CE\n+  env->SetByteArrayRegion((jbyteArray) arrayClone[BYTE], 0, SIZE(BYTE), byteOrig); CE\n+  env->SetCharArrayRegion((jcharArray) arrayClone[CHAR], 0, SIZE(CHAR), charOrig); CE\n+  env->SetShortArrayRegion((jshortArray) arrayClone[SHORT], 0, SIZE(SHORT), shortOrig); CE\n+  env->SetIntArrayRegion((jintArray) arrayClone[INT], 0, SIZE(INT), intOrig); CE\n+  env->SetLongArrayRegion((jlongArray) arrayClone[LONG], 0, SIZE(LONG), longOrig); CE\n+  env->SetFloatArrayRegion((jfloatArray) arrayClone[FLOAT], 0, SIZE(FLOAT), floatOrig); CE\n+  env->SetDoubleArrayRegion((jdoubleArray) arrayClone[DOUBLE], 0, SIZE(DOUBLE), doubleOrig); CE\n@@ -240,10 +241,10 @@\n-    \/* Use Release<Type>ArrayElements *\/\n-    env->ReleaseDoubleArrayElements((jdoubleArray) arrayOrig[DOUBLE],doubleOrig,0); CE\n-    env->ReleaseFloatArrayElements((jfloatArray) arrayOrig[FLOAT],floatOrig,0); CE\n-    env->ReleaseLongArrayElements((jlongArray) arrayOrig[LONG],longOrig,0); CE\n-    env->ReleaseIntArrayElements((jintArray) arrayOrig[INT],intOrig,0); CE\n-    env->ReleaseShortArrayElements((jshortArray) arrayOrig[SHORT],shortOrig,0); CE\n-    env->ReleaseCharArrayElements((jcharArray) arrayOrig[CHAR],charOrig,0); CE\n-    env->ReleaseByteArrayElements((jbyteArray) arrayOrig[BYTE],byteOrig,0); CE\n-    env->ReleaseBooleanArrayElements((jbooleanArray) arrayOrig[BOOL],boolOrig,0); CE\n-    free(arrayOrig);\n+  \/* Use Release<Type>ArrayElements *\/\n+  env->ReleaseDoubleArrayElements((jdoubleArray) arrayOrig[DOUBLE], doubleOrig, 0); CE\n+  env->ReleaseFloatArrayElements((jfloatArray) arrayOrig[FLOAT], floatOrig, 0); CE\n+  env->ReleaseLongArrayElements((jlongArray) arrayOrig[LONG], longOrig, 0); CE\n+  env->ReleaseIntArrayElements((jintArray) arrayOrig[INT], intOrig, 0); CE\n+  env->ReleaseShortArrayElements((jshortArray) arrayOrig[SHORT], shortOrig, 0); CE\n+  env->ReleaseCharArrayElements((jcharArray) arrayOrig[CHAR], charOrig, 0); CE\n+  env->ReleaseByteArrayElements((jbyteArray) arrayOrig[BYTE], byteOrig, 0); CE\n+  env->ReleaseBooleanArrayElements((jbooleanArray) arrayOrig[BOOL], boolOrig, 0); CE\n+  free(arrayOrig);\n@@ -251,9 +252,9 @@\n-    free(doubleClone);\n-    free(floatClone);\n-    free(longClone);\n-    free(intClone);\n-    free(shortClone);\n-    free(byteClone);\n-    free(charClone);\n-    free(boolClone);\n-    free(arrayClone);\n+  free(doubleClone);\n+  free(floatClone);\n+  free(longClone);\n+  free(intClone);\n+  free(shortClone);\n+  free(byteClone);\n+  free(charClone);\n+  free(boolClone);\n+  free(arrayClone);\n@@ -261,1 +262,1 @@\n-    return JNI_TRUE;\n+  return JNI_TRUE;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress003.cpp","additions":181,"deletions":180,"binary":false,"changes":361,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,23 +37,21 @@\n-    unsigned char digest[DIGESTLENGTH];\n-    jchar *tmp;\n-    static jint upper = 0;\n-    jcharArray jArr;\n-    int i;\n-    const jchar *critstr;\n-    char *str;\n-    jint len=env->GetStringUTFLength(jstr); CE\n-\n-    for (i=0;i<DIGESTLENGTH;i++) {\n-      digest[i]=0;\n-    }\n-    str=(char *)malloc(len*sizeof(char));\n-\/*     const char *threadName=env->GetStringUTFChars(jstr, 0); *\/\n-\n-    env->MonitorEnter(jobj); CE\n-    if (upper == 0) tmp = (jchar *) malloc(DIGESTLENGTH*sizeof(char));\n-    if (env->ExceptionOccurred()) {\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n-    critstr=env->GetStringCritical(jstr, 0); CE\n-    for (i=0;i<len;i++)\n+  unsigned char digest[DIGESTLENGTH];\n+  jchar *tmp;\n+  static jint upper = 0;\n+  jcharArray jArr;\n+  int i;\n+  const jchar *critstr;\n+  char *str;\n+  jint len = env->GetStringUTFLength(jstr); CE\n+\n+  for (i = 0; i < DIGESTLENGTH; i++) {\n+    digest[i] = 0;\n+  }\n+  str = (char *)c_malloc(env, len * sizeof(char));\n+  \/*     const char *threadName = env->GetStringUTFChars(jstr, 0); *\/\n+\n+  CHECK(env->MonitorEnter(jobj));\n+  if (upper == 0) {\n+    tmp = (jchar *) c_malloc(env, DIGESTLENGTH * sizeof(char));\n+  }\n+  critstr = env->GetStringCritical(jstr, 0); CE\n+  for (i = 0; i < len; i++) {\n@@ -61,17 +59,13 @@\n-    env->ReleaseStringCritical(jstr,critstr); CE\n-    for (i=0;i<len;i++) {\n-        digest[i % DIGESTLENGTH]+=str[i];\n-    }\n-    free(str);\n-\n-    if (env->ExceptionOccurred()) {\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n-    memcpy(tmp,digest,DIGESTLENGTH);\n-    jArr=env->NewCharArray(DIGESTLENGTH\/sizeof(jchar)); CE\n-    len=env->GetArrayLength(jArr); CE\n-    env->SetCharArrayRegion(jArr,0,len,tmp); CE\n-\/*     ++upper; *\/\n-    env->MonitorExit(jobj); CE\n-    return jArr;\n+  }\n+  env->ReleaseStringCritical(jstr, critstr); CE\n+  for (i = 0; i < len; i++) {\n+    digest[i % DIGESTLENGTH] += str[i];\n+  }\n+  free(str);\n+  memcpy(tmp, digest, DIGESTLENGTH);\n+  jArr = env->NewCharArray(DIGESTLENGTH \/ sizeof(jchar)); CE\n+  len = env->GetArrayLength(jArr); CE\n+  env->SetCharArrayRegion(jArr, 0, len, tmp); CE\n+  \/*     ++upper; *\/\n+  CHECK(env->MonitorExit(jobj));\n+  return jArr;\n@@ -82,25 +76,25 @@\n-            jcharArray cArr, jint limit) {\n-\n-    unsigned char digest[DIGESTLENGTH];\n-    jchar *tmp;\n-\/*     jcharArray jArr; *\/\n-    const jchar *critstr;\n-    jint strlen;\n-    char *str;\n-    jboolean ret=JNI_TRUE;\n-    int i;\n-    static jint upper = 0;\n-    jint len;\n-    jchar *ch;\n-\n-    for (i=0;i<DIGESTLENGTH;i++) {\n-      digest[i]=0;\n-    }\n-    strlen =  env->GetStringUTFLength(jstr); CE\n-    str = (char *)malloc(strlen*sizeof(char));\n-\n-    len =env->GetArrayLength(cArr); CE\n-\n-    env->MonitorEnter(jobj); CE\n-    if (upper>limit) {\n-    env->MonitorExit(jobj); CE\n+                                            jcharArray cArr, jint limit) {\n+\n+  unsigned char digest[DIGESTLENGTH];\n+  jchar *tmp;\n+  \/*     jcharArray jArr; *\/\n+  const jchar *critstr;\n+  jint strlen;\n+  char *str;\n+  jboolean ret = JNI_TRUE;\n+  int i;\n+  static jint upper = 0;\n+  jint len;\n+  jchar *ch;\n+\n+  for (i = 0; i < DIGESTLENGTH; i++) {\n+    digest[i] = 0;\n+  }\n+  strlen =  env->GetStringUTFLength(jstr); CE\n+  str = (char *)c_malloc(env, strlen * sizeof(char));\n+\n+  len =env->GetArrayLength(cArr); CE\n+\n+  CHECK(env->MonitorEnter(jobj));\n+  if (upper > limit) {\n+    CHECK(env->MonitorExit(jobj));\n@@ -108,8 +102,4 @@\n-    }\n-    tmp=(jchar *)malloc(DIGESTLENGTH*sizeof(char));\n-    if (env->ExceptionOccurred()) {\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n-    critstr=env->GetStringCritical(jstr, 0); CE\n-    for (i=0;i<strlen;i++)\n+  }\n+  tmp = (jchar *)c_malloc(env, DIGESTLENGTH * sizeof(char));\n+  critstr = env->GetStringCritical(jstr, 0); CE\n+  for (i = 0; i < strlen; i++) {\n@@ -117,26 +107,21 @@\n-    env->ReleaseStringCritical(jstr,critstr); CE\n-    for (i=0;i<strlen; i++) {\n-      digest[i % DIGESTLENGTH]+=str[i % DIGESTLENGTH];\n-    }\n-\n-    free(str);\n-\n-    if (env->ExceptionOccurred()) {\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n-    memcpy(tmp,digest,DIGESTLENGTH);\n-\n-\/*     jArr=env->NewCharArray(DIGESTLENGTH\/sizeof(jchar)); *\/\n-\/*     len=env->GetArrayLength(jArr); *\/\n-\/*     env->SetCharArrayRegion(jArr,0,len,tmp); *\/\n-\/*     ++upper; *\/\n-\/*     env->MonitorExit(jobj); *\/\n-\n-\/* Compare  *\/\n-\/*     env->MonitorEnter(jobj); *\/\n-\n-    ch=(jchar *)env->GetPrimitiveArrayCritical(cArr,0); CE\n-\n-    printf(\"Comparing: \");\n-    for (i=0;i<len;i++)\n+  }\n+  env->ReleaseStringCritical(jstr, critstr); CE\n+  for (i = 0; i < strlen; i++) {\n+    digest[i % DIGESTLENGTH] += str[i % DIGESTLENGTH];\n+  }\n+  free(str);\n+  memcpy(tmp, digest, DIGESTLENGTH);\n+\n+  \/*     jArr = env->NewCharArray(DIGESTLENGTH\/sizeof(jchar)); *\/\n+  \/*     len = env->GetArrayLength(jArr); *\/\n+  \/*     env->SetCharArrayRegion(jArr, 0, len, tmp); *\/\n+  \/*     ++upper; *\/\n+  \/*     env->MonitorExit(jobj); *\/\n+\n+  \/* Compare  *\/\n+  \/*     env->MonitorEnter(jobj); *\/\n+\n+  ch = (jchar *)env->GetPrimitiveArrayCritical(cArr, 0); CE\n+\n+  printf(\"Comparing: \");\n+  for (i = 0; i < len; i++) {\n@@ -144,3 +129,5 @@\n-        printf(\"Error in %d\\n\",i);\n-        printf(\"ch[%d]=%02x tmp[%d]=%02x\\n\",i,ch[i],i,tmp[i]);\n-        ret=JNI_FALSE;\n+      printf(\"Error in %d\\n\", i);\n+      printf(\"ch[%d] = %02x tmp[%d] = %02x\\n\", i, ch[i], i, tmp[i]);\n+      ret = JNI_FALSE;\n+    } else {\n+      printf(\"ch[%d] = %02x tmp[%d] = %02x\\n\", i, ch[i], i, tmp[i]);\n@@ -148,9 +135,8 @@\n-    else {\n-        printf(\"ch[%d]=%02x tmp[%d]=%02x\\n\",i,ch[i],i,tmp[i]);\n-    }\n-    printf(\"\\n\");\n-    env->ReleasePrimitiveArrayCritical(cArr,ch,0); CE\n-    ++upper;\n-    if (!(upper % 500))\n-    fprintf(stderr,\"There are %d elements now.\\n\", upper);\n-    if (upper == limit) {\n+  }\n+  printf(\"\\n\");\n+  env->ReleasePrimitiveArrayCritical(cArr, ch, 0); CE\n+  ++upper;\n+  if ((upper % 500) == 0) {\n+    fprintf(stderr, \"There are %d elements now.\\n\", upper);\n+  }\n+  if (upper == limit) {\n@@ -159,2 +145,2 @@\n-    char *name = (char*) \"halt\";\n-    char *sig = (char*) \"()V\";\n+    const char* name = \"halt\";\n+    const char* sig = \"()V\";\n@@ -162,2 +148,2 @@\n-    clazz=env->GetObjectClass(jobj); CE\n-    methodID=env->GetStaticMethodID(clazz, name, sig); CE\n+    clazz = env->GetObjectClass(jobj); CE\n+    methodID = env->GetStaticMethodID(clazz, name, sig); CE\n@@ -166,4 +152,4 @@\n-    ret=JNI_TRUE;\n-    }\n-    env->MonitorExit(jobj); CE\n-    return ret;\n+    ret = JNI_TRUE;\n+  }\n+  CHECK(env->MonitorExit(jobj));\n+  return ret;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress004.cpp","additions":106,"deletions":120,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"jnihelper.h\"\n@@ -30,2 +31,0 @@\n-#define CHECK_EXCEPTION     { if (env->ExceptionOccurred()) { fprintf(stderr, \"Unexpected exception:\\n\"); env->ExceptionDescribe(); env->ExceptionClear(); exit(97); } }\n-\n@@ -34,10 +33,16 @@\n-    jclass clazz;\n-    static int Exceptcalls=0;\n-    const char *name;\n-    const char *mess;\n-    jmethodID jmethod;\n-    const char *iter = \"nsk\/stress\/jni\/JNIter005\";\n-\/\/    const char *inc = \"nsk\/stress\/jni\/jnistress005\/incCount\";\n-    const char *incSig = \"()V\";\n-    const char *fldName = \"counts\";\n-    const char *fldSig = \"I\";\n+  jclass clazz;\n+  static int Exceptcalls = 0;\n+  const char *name;\n+  const char *mess;\n+  jmethodID jmethod;\n+  const char *iter = \"nsk\/stress\/jni\/JNIter005\";\n+  \/\/    const char *inc = \"nsk\/stress\/jni\/jnistress005\/incCount\";\n+  const char *incSig = \"()V\";\n+  const char *fldName = \"counts\";\n+  const char *fldSig = \"I\";\n+\n+  \/*     incClazz = env->FindClass(iter); *\/\n+  \/*     jmethod = env->GetStaticMethodID(incClazz, inc, incSig); *\/\n+  \/*     env->CallStaticVoidMethod(incClazz, jmethod); *\/\n+  \/*     jfld = env->GetFieldID(incClazz, fldName, fldSig); *\/\n+  \/*     printf(\"JNI: Count is %d\\n\", env->GetIntField(jobj, jfld)); *\/\n@@ -45,9 +50,1 @@\n-\/*     incClazz = env->FindClass(iter); *\/\n-\/*     CHECK_EXCEPTION *\/\n-\/*     jmethod=env->GetStaticMethodID(incClazz, inc, incSig); *\/\n-\/*     CHECK_EXCEPTION *\/\n-\/*     env->CallStaticVoidMethod(incClazz, jmethod); *\/\n-\/*     CHECK_EXCEPTION *\/\n-\/*     jfld = env->GetFieldID(incClazz, fldName, fldSig); *\/\n-\/*     printf(\"JNI: Count is %d\\n\", env->GetIntField(jobj, jfld)); *\/\n-\/*     CHECK_EXCEPTION *\/\n+  CHECK(env->MonitorEnter(jobj));\n@@ -55,6 +52,6 @@\n-    env->MonitorEnter(jobj);\n-    CHECK_EXCEPTION\n-    if (!env->Throw(tobj)) {\n-    if (env->ExceptionOccurred())\n-        if (Exceptcalls % 1000 == 0)\n-        fprintf(stderr, \"NATIVE: Throw has been catched in native\\n\");\n+  if (env->Throw(tobj) == 0) {\n+    if (env->ExceptionOccurred()) {\n+      if (Exceptcalls % 1000 == 0) {\n+        fprintf(stderr, \"NATIVE: Throw has been caught in native\\n\");\n+      }\n+    }\n@@ -63,1 +60,3 @@\n-    } else fprintf(stderr, \"Throw failed\\n\");\n+  } else {\n+    fprintf(stderr, \"Throw failed\\n\");\n+  }\n@@ -65,2 +64,1 @@\n-    env->MonitorExit(jobj);\n-    CHECK_EXCEPTION\n+  CHECK(env->MonitorExit(jobj));\n@@ -68,27 +66,27 @@\n-    switch (Exceptcalls % 23) {\n-      case 0: name=\"java\/lang\/ArithmeticException\"; break;\n-      case 1: name=\"java\/lang\/ArrayIndexOutOfBoundsException\"; break;\n-      case 2: name=\"java\/lang\/ArrayStoreException\"; break;\n-      case 3: name=\"java\/lang\/ClassCastException\"; break;\n-      case 4: name=\"java\/lang\/ClassNotFoundException\"; break;\n-      case 5: name=\"java\/lang\/CloneNotSupportedException\"; break;\n-      case 6: name=\"java\/lang\/IllegalAccessException\"; break;\n-      case 7: name=\"java\/lang\/IllegalArgumentException\"; break;\n-      case 8: name=\"java\/lang\/IllegalMonitorStateException\"; break;\n-      case 9: name=\"java\/lang\/IllegalStateException\"; break;\n-      case 10: name=\"java\/lang\/IllegalThreadStateException\"; break;\n-      case 11: name=\"java\/lang\/IndexOutOfBoundsException\"; break;\n-      case 12: name=\"java\/lang\/InstantiationException\"; break;\n-      case 13: name=\"java\/lang\/InterruptedException\"; break;\n-      case 14: name=\"java\/lang\/NegativeArraySizeException\"; break;\n-      case 15: name=\"java\/lang\/NoSuchFieldException\"; break;\n-      case 16: name=\"java\/lang\/NoSuchMethodException\"; break;\n-      case 17: name=\"java\/lang\/NullPointerException\"; break;\n-      case 18: name=\"java\/lang\/NumberFormatException\"; break;\n-      case 19: name=\"java\/lang\/RuntimeException\"; break;\n-      case 20: name=\"java\/lang\/SecurityException\"; break;\n-      case 21: name=\"java\/lang\/StringIndexOutOfBoundsException\"; break;\n-      case 22: name=\"java\/lang\/UnsupportedOperationException\"; break;\n-      default: name=\"java\/lang\/Exception\";\n-    }\n-    mess=name;\n+  switch (Exceptcalls % 23) {\n+  case 0: name = \"java\/lang\/ArithmeticException\"; break;\n+  case 1: name = \"java\/lang\/ArrayIndexOutOfBoundsException\"; break;\n+  case 2: name = \"java\/lang\/ArrayStoreException\"; break;\n+  case 3: name = \"java\/lang\/ClassCastException\"; break;\n+  case 4: name = \"java\/lang\/ClassNotFoundException\"; break;\n+  case 5: name = \"java\/lang\/CloneNotSupportedException\"; break;\n+  case 6: name = \"java\/lang\/IllegalAccessException\"; break;\n+  case 7: name = \"java\/lang\/IllegalArgumentException\"; break;\n+  case 8: name = \"java\/lang\/IllegalMonitorStateException\"; break;\n+  case 9: name = \"java\/lang\/IllegalStateException\"; break;\n+  case 10: name = \"java\/lang\/IllegalThreadStateException\"; break;\n+  case 11: name = \"java\/lang\/IndexOutOfBoundsException\"; break;\n+  case 12: name = \"java\/lang\/InstantiationException\"; break;\n+  case 13: name = \"java\/lang\/InterruptedException\"; break;\n+  case 14: name = \"java\/lang\/NegativeArraySizeException\"; break;\n+  case 15: name = \"java\/lang\/NoSuchFieldException\"; break;\n+  case 16: name = \"java\/lang\/NoSuchMethodException\"; break;\n+  case 17: name = \"java\/lang\/NullPointerException\"; break;\n+  case 18: name = \"java\/lang\/NumberFormatException\"; break;\n+  case 19: name = \"java\/lang\/RuntimeException\"; break;\n+  case 20: name = \"java\/lang\/SecurityException\"; break;\n+  case 21: name = \"java\/lang\/StringIndexOutOfBoundsException\"; break;\n+  case 22: name = \"java\/lang\/UnsupportedOperationException\"; break;\n+  default: name = \"java\/lang\/Exception\";\n+  }\n+  mess = name;\n@@ -96,17 +94,13 @@\n-    CHECK_EXCEPTION\n-    clazz = env->FindClass(name);\n-    CHECK_EXCEPTION\n-    if (env->ThrowNew(clazz, mess)) {\n-      const char *pass = \"setpass\";\n-      const char *passSig = \"(Z)V\";\n-      jclass incClazz;\n-      fprintf(stderr, \"ThrowNew failed\\n\");\n-      CHECK_EXCEPTION;\n-      incClazz = env->FindClass(iter);\n-      CHECK_EXCEPTION;\n-      jmethod=env->GetStaticMethodID(incClazz, pass, passSig);\n-      CHECK_EXCEPTION\n-      env->CallStaticVoidMethod(incClazz, jmethod, JNI_FALSE);\n-      CHECK_EXCEPTION\n-    }\n-\/*     printf(\"JNI: count %d\\n\", Exceptcalls); *\/\n+  clazz = env->FindClass(name); CE\n+  if (env->ThrowNew(clazz, mess) != 0) {\n+    const char *pass = \"setpass\";\n+    const char *passSig = \"(Z)V\";\n+    jclass incClazz;\n+    fprintf(stderr, \"ThrowNew failed\\n\");\n+    CE;\n+    \/\/ ThrowNew failed but didn't itself raise an exception\n+    incClazz = env->FindClass(iter); CE\n+    jmethod=env->GetStaticMethodID(incClazz, pass, passSig); CE\n+    env->CallStaticVoidMethod(incClazz, jmethod, JNI_FALSE); CE\n+  }\n+  \/*     printf(\"JNI: count %d\\n\", Exceptcalls); *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress005.cpp","additions":69,"deletions":75,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-    static jobject *globRefsArray = 0;\n-    static int upper = 0;\n+  static jobject *globRefsArray = 0;\n+  static int upper = 0;\n@@ -37,11 +37,11 @@\n-    jclass clazz;\n-    jmethodID jmethod;\n-    jboolean res=JNI_FALSE;\n-    const char *classname = \"nsk\/stress\/jni\/JNIter006\";\n-    const char *getmethodname=\"get_i\";\n-    const char *setmethodname=\"set_i\";\n-    const char *getsig=\"()I\";\n-    const char *setsig=\"(I)V\";\n-    const char *setdone = \"halt\";\n-    const char *setdonesig = \"()V\";\n-    int i = 0;\n+  jclass clazz;\n+  jmethodID jmethod;\n+  jboolean res = JNI_FALSE;\n+  const char *classname = \"nsk\/stress\/jni\/JNIter006\";\n+  const char *getmethodname = \"get_i\";\n+  const char *setmethodname = \"set_i\";\n+  const char *getsig = \"()I\";\n+  const char *setsig = \"(I)V\";\n+  const char *setdone = \"halt\";\n+  const char *setdonesig = \"()V\";\n+  int i = 0;\n@@ -49,1 +49,3 @@\n-    if (upper >= LIMIT) return JNI_TRUE;\n+  if (upper >= LIMIT) {\n+    return JNI_TRUE;\n+  }\n@@ -51,3 +53,3 @@\n-    if (upper == 0) {\n-        globRefsArray=(jobject*)(malloc(LIMIT*sizeof(jobject)));\n-    }\n+  if (upper == 0) {\n+    globRefsArray = (jobject*)c_malloc(env, LIMIT * sizeof(jobject));\n+  }\n@@ -55,2 +57,2 @@\n-    globRefsArray[upper]=env->NewGlobalRef(tobj); CE\n-    if (env->IsSameObject(tobj, globRefsArray[upper])) {\n+  globRefsArray[upper] = env->NewGlobalRef(tobj); CE\n+  if (env->IsSameObject(tobj, globRefsArray[upper])) {\n@@ -58,5 +60,4 @@\n-    clazz=env->GetObjectClass(globRefsArray[upper]); CE\n-    }\n-    else {\n-    fprintf(stderr,\"Objects are different\\n\");\n-    env->MonitorExit(jobj); CE\n+    clazz = env->GetObjectClass(globRefsArray[upper]); CE\n+  } else {\n+    fprintf(stderr, \"Objects are different\\n\");\n+    CHECK(env->MonitorExit(jobj));\n@@ -64,14 +65,14 @@\n-    }\n-    jmethod=env->GetStaticMethodID(clazz, setmethodname, setsig); CE\n-    env->CallStaticVoidMethod(clazz, jmethod, (jint)upper); CE\n-    env->MonitorEnter(jobj); CE\n-    ++upper;\n-    res=JNI_TRUE;\n-    env->MonitorExit(jobj); CE\n-\/* If upper == LIMIT than flush ref's array and set *\/\n-\/* 'done' flag in JNIter006 class to JNI_TRUE *\/\n-    if (upper == LIMIT) {\n-    fprintf(stderr,\"\\n\\tTotal memory allocated: %zd bytes\\n\",\n-        LIMIT*sizeof(jobject));\n-    clazz=env->FindClass(classname); CE\n-    jmethod=env->GetMethodID(clazz, setdone, setdonesig); CE\n+  }\n+  jmethod = env->GetStaticMethodID(clazz, setmethodname, setsig); CE\n+  env->CallStaticVoidMethod(clazz, jmethod, (jint)upper); CE\n+  CHECK(env->MonitorEnter(jobj));\n+  ++upper;\n+  res = JNI_TRUE;\n+  CHECK(env->MonitorExit(jobj));\n+  \/* If upper == LIMIT than flush ref's array and set *\/\n+  \/* 'done' flag in JNIter006 class to JNI_TRUE *\/\n+  if (upper == LIMIT) {\n+    fprintf(stderr, \"\\n\\tTotal memory allocated: %zd bytes\\n\",\n+            LIMIT * sizeof(jobject));\n+    clazz = env->FindClass(classname); CE\n+    jmethod = env->GetMethodID(clazz, setdone, setdonesig); CE\n@@ -80,2 +81,2 @@\n-    for (i=0;i<LIMIT;i++) {\n-        env->DeleteGlobalRef(globRefsArray[i]); CE\n+    for (i = 0; i < LIMIT; i++) {\n+      env->DeleteGlobalRef(globRefsArray[i]); CE\n@@ -83,3 +84,3 @@\n-        free(globRefsArray);\n-    }\n-    return res;\n+    free(globRefsArray);\n+  }\n+  return res;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress006.cpp","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,4 @@\n-    jclass clazz;\n-    jfieldID fld;\n-    jint value;\n-    const char *str = env->GetStringUTFChars(name, 0); CE\n+  jclass clazz;\n+  jfieldID fld;\n+  jint value;\n+  const char *str = env->GetStringUTFChars(name, 0); CE\n@@ -37,9 +37,9 @@\n-    if (env->MonitorEnter(jobj))\n-        printf(\"Error in monitor lock\\n\");\n-    clazz = env->GetObjectClass(jobj); CE\n-    fld = env->GetStaticFieldID(clazz, \"nativeCount\", \"I\"); CE\n-    value = env->GetStaticIntField(clazz, fld); CE\n-    env->SetStaticIntField(clazz, fld, (jint)(++value)); CE\n-    env->MonitorExit(jobj); CE\n-    if (value % 1000 == 0)\n-        printf(\"in %s Count after %u\\n\", str, value);\n+  CHECK(env->MonitorEnter(jobj));\n+  clazz = env->GetObjectClass(jobj); CE\n+  fld = env->GetStaticFieldID(clazz, \"nativeCount\", \"I\"); CE\n+  value = env->GetStaticIntField(clazz, fld); CE\n+  env->SetStaticIntField(clazz, fld, (jint)(++value)); CE\n+  CHECK(env->MonitorExit(jobj));\n+  if (value % 1000 == 0) {\n+    printf(\"in %s Count after %u\\n\", str, value);\n+  }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress007.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"}]}