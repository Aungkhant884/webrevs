{"files":[{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8290850\n+ * @summary Test cloning of pinned phi input nodes in create_new_if_for_predicate().\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestCreateNewIfForPredicateCloning::*\n+ *                   compiler.loopopts.TestCreateNewIfForPredicateCloning\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestCreateNewIfForPredicateCloning {\n+    static int iFld, iFld2, iFld3, nonZero = 2, nonZero2 = 3;\n+    static boolean bFld = true, bFld2 = false;\n+    static int[] iArrFld = new int[100];\n+\n+    public static void main(String[] args) {\n+        try {\n+            testUnswitching();\n+            testLoopPredicatation();\n+            testLoopPredicatationComplex();\n+            testUnswitchingWithPredicates();\n+            testUnswitchingWithPredicatesDiv();\n+            testFuzzer1();\n+            testFuzzer2();\n+            testFuzzer3();\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test case for the already fixed problem in 8271954: Calling create_new_if_for_predicate in\n+    \/\/ clone_predicate_to_unswitched_loop(). This does not crash anymore. But still use it as sanity test here with the\n+    \/\/ new fix.\n+    static void testUnswitching() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            \/\/\n+            \/\/ 8271954 fixes this when calling create_new_if_for_predicate() in\n+            \/\/ clone_predicate_to_unswitched_loop().\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Similar to testUnswitching() but we are calling create_new_if_for_predicate in Loop Predication for:\n+    \/\/ - Creating hoised range check predicate and skeleton predicate\n+    \/\/ - Creating invariant check predicate\n+    \/\/ which leads to a crash.\n+    static void testLoopPredicatation() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Similar to testLoopPredicatation() but we are adding some computations for x such that we sink more nodes which\n+    \/\/ need to be cloned when calling create_new_if_for_predicate().\n+    static void testLoopPredicatationComplex() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            \/\/ Add some more computations such that more nodes are sunk and therefore more nodes need to be cloned in\n+            \/\/ create_new_if_for_predicate().\n+            double d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Combination of testUnswitching() and testLoopPredicatation(): After creating predicates in loop predication,\n+    \/\/ we perform another round of loop unswitching where we additionally call create_new_if_for_predicate in\n+    \/\/ clone_skeleton_predicate_for_unswitched_loops() which currently leads to a crash.\n+    static void testUnswitchingWithPredicates() {\n+        int x = 3;\n+        if (iArrFld == null) {\n+            \/\/ Makes sure to get rid of null check for iArrFld to only create range check predicate\n+            return;\n+        }\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int z = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Same as testUnswitchingWithPredicates() but with a DivI node which has a control input which needs\n+    \/\/ to be rewired as well.\n+    static void testUnswitchingWithPredicatesDiv() {\n+        int x = 3;\n+        if (iArrFld == null) {\n+            \/\/ Makes sure to get rid of null check for iArrFld to only create range check predicate\n+            return;\n+        }\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            double d = 5.5f + (double) x;\n+            int a = (int)d;\n+            x = (a \/ nonZero) - (a \/ nonZero2);\n+\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int z = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    static void testFuzzer1() {\n+        int x = 0;\n+        int[] iArr = new int[400];\n+        boolean b = true;\n+        long[] lArr = new long[400];\n+        for (long l1 : lArr) {\n+            for (int i = 63; i > 1; i -= 3) {\n+                for (int j = 1; j < 4; j++) {\n+                    if (!b) {\n+                        x -= 5;\n+                    }\n+                }\n+                for (int j = 1; j < 4; j++) {\n+                    if (!b) {\n+                        x = iArr[j];\n+                    }\n+                    if (i == 0) {\n+                        l1 += 5;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testFuzzer2() {\n+        int i, i1, i17 = 6, i18;\n+        short s1;\n+        boolean b2 = true;\n+        float f3;\n+        long lArr[][] = new long[400][];\n+        byte byArrFld[] = new byte[4];\n+        i = 1;\n+        do {\n+            for (i1 = 14; 6 < i1; i1--)\n+                ;\n+            i17 -= i18 = 1;\n+            while (i18 < 4) {\n+                i18 <<= i17 = 2;\n+                switch (i1) {\n+                    case 114:\n+                        s1 = byArrFld[1];\n+                        break;\n+                    case 116:\n+                        lArr[1][i18] = iFld;\n+                        if (b2)\n+                            continue;\n+                    case 118:\n+                        f3 = iFld;\n+                }\n+            }\n+            i++;\n+        } while (i < 10000);\n+    }\n+\n+    static void testFuzzer3() {\n+        int x = 8;\n+        int y = 4;\n+        for (int i : iArrFld) {\n+            x += 2;\n+            if (bFld) {\n+                x = 3;\n+            } else {\n+                y = 2;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+                x = 0;\n+                y += 5;\n+                if (!bFld) {\n+                    iArrFld[1] = 5;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCreateNewIfForPredicateCloning.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"}]}