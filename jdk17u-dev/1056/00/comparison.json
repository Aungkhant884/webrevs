{"files":[{"patch":"@@ -111,3 +111,3 @@\n-                                                      Deoptimization::DeoptReason reason, int opcode,\n-                                                      bool if_cont_is_true_proj, Node_List* old_new,\n-                                                      UnswitchingAction unswitching_action) {\n+                                                      Deoptimization::DeoptReason reason,\n+                                                      const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n+                                                      const bool if_cont_is_true_proj) {\n@@ -199,14 +199,13 @@\n-      if (unswitching_action == UnswitchingAction::FastLoopCloning\n-          && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n-        \/\/ There are some control dependent nodes on the uncommon projection and we are currently copying predicates\n-        \/\/ to the fast loop in loop unswitching (first step, slow loop is processed afterwards). For the fast loop,\n-        \/\/ we need to clone all the data nodes in the chain from the phi ('use') up until the node whose control input\n-        \/\/ is the uncommon_proj. The slow loop can reuse the old data nodes and thus only needs to update the control\n-        \/\/ input to the uncommon_proj (done on the next invocation of this method when 'unswitch_is_slow_loop' is true.\n-        assert(LoopUnswitching, \"sanity check\");\n-        phi_input = clone_data_nodes_for_fast_loop(phi_input, uncommon_proj, if_uct, old_new);\n-      } else if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n-        \/\/ Replace phi input for the old predicate path with TOP as the predicate is dying anyways. This avoids the need\n-        \/\/ to clone the data nodes again for the slow loop.\n-        assert(LoopUnswitching, \"sanity check\");\n-        _igvn.replace_input_of(use, proj_index, C->top());\n+\n+      if (uncommon_proj->outcnt() > 1 && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n+        \/\/ There are some control dependent nodes on the uncommon projection. We cannot simply reuse these data nodes.\n+        \/\/ We either need to rewire them from the old uncommon projection to the newly created uncommon proj (if the old\n+        \/\/ If is dying) or clone them and update their control (if the old If is not dying).\n+        if (rewire_uncommon_proj_phi_inputs) {\n+          \/\/ Replace phi input for the old uncommon projection with TOP as the If is dying anyways. Reuse the old data\n+          \/\/ nodes by simply updating control inputs and ctrl.\n+          _igvn.replace_input_of(use, proj_index, C->top());\n+          set_ctrl_of_nodes_with_same_ctrl(phi_input, uncommon_proj, if_uct);\n+        } else {\n+          phi_input = clone_nodes_with_same_ctrl(phi_input, uncommon_proj, if_uct);\n+        }\n@@ -219,13 +218,0 @@\n-  if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n-    \/\/ Rewire the control dependent data nodes for the slow loop from the old to the new uncommon projection.\n-    assert(uncommon_proj->outcnt() > 1 && old_new == NULL, \"sanity\");\n-    for (DUIterator_Fast jmax, j = uncommon_proj->fast_outs(jmax); j < jmax; j++) {\n-      Node* data = uncommon_proj->fast_out(j);\n-      if (!data->is_CFG()) {\n-        _igvn.replace_input_of(data, 0, if_uct);\n-        set_ctrl(data, if_uct);\n-        --j;\n-        --jmax;\n-      }\n-    }\n-  }\n@@ -243,13 +229,19 @@\n-\/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate. Returns the node which is\n-\/\/ used for the uncommon trap phi input.\n-Node* PhaseIdealLoop::clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new) {\n-  \/\/ Step 1: Clone all nodes on the data chain but do not rewire anything, yet. Keep track of the cloned nodes\n-  \/\/ by using the old_new mapping. This mapping is then used in step 2 to rewire the cloned nodes accordingly.\n-  DEBUG_ONLY(uint last_idx = C->unique();)\n-  Unique_Node_List list;\n-  list.push(phi_input);\n-  for (uint j = 0; j < list.size(); j++) {\n-    Node* next = list.at(j);\n-    Node* clone = next->clone();\n-    _igvn.register_new_node_with_optimizer(clone);\n-    old_new->map(next->_idx, clone);\n+\/\/ Update ctrl and control inputs of all data nodes starting from 'node' to 'new_ctrl' which have 'old_ctrl' as\n+\/\/ current ctrl.\n+void PhaseIdealLoop::set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n+  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n+    Node* next = nodes_with_same_ctrl[j];\n+    if (next->in(0) == old_ctrl) {\n+      _igvn.replace_input_of(next, 0, new_ctrl);\n+    }\n+    set_ctrl(next, new_ctrl);\n+  }\n+}\n+\n+\/\/ Recursively find all input nodes with the same ctrl.\n+Unique_Node_List PhaseIdealLoop::find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl) {\n+  Unique_Node_List nodes_with_same_ctrl;\n+  nodes_with_same_ctrl.push(node);\n+  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n+    Node* next = nodes_with_same_ctrl[j];\n@@ -258,2 +250,2 @@\n-      if (!in->is_Phi() && get_ctrl(in) == uncommon_proj) {\n-        list.push(in);\n+      if (!in->is_Phi() && get_ctrl(in) == ctrl) {\n+        nodes_with_same_ctrl.push(in);\n@@ -263,0 +255,2 @@\n+  return nodes_with_same_ctrl;\n+}\n@@ -264,6 +258,32 @@\n-  \/\/ Step 2: All nodes are cloned. Rewire them by using the old_new mapping.\n-  for (uint j = 0; j < list.size(); j++) {\n-    Node* next = list.at(j);\n-    Node* clone = old_new->at(next->_idx);\n-    assert(clone != NULL && clone->_idx >= last_idx, \"must exist and be a proper clone\");\n-    if (next->in(0) == uncommon_proj) {\n+\/\/ Clone all nodes with the same ctrl as 'old_ctrl' starting from 'node' by following its inputs. Rewire the cloned nodes\n+\/\/ to 'new_ctrl'. Returns the clone of 'node'.\n+Node* PhaseIdealLoop::clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+  DEBUG_ONLY(uint last_idx = C->unique();)\n+  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n+  Dict old_new_mapping = clone_nodes(nodes_with_same_ctrl); \/\/ Cloned but not rewired, yet\n+  rewire_cloned_nodes_to_ctrl(old_ctrl, new_ctrl, nodes_with_same_ctrl, old_new_mapping);\n+  Node* clone_phi_input = static_cast<Node*>(old_new_mapping[node]);\n+  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n+  return clone_phi_input;\n+}\n+\n+\/\/ Clone all the nodes on 'list_to_clone' and return an old->new mapping.\n+Dict PhaseIdealLoop::clone_nodes(const Node_List& list_to_clone) {\n+  Dict old_new_mapping(cmpkey, hashkey);\n+  for (uint i = 0; i < list_to_clone.size(); i++) {\n+    Node* next = list_to_clone[i];\n+    Node* clone = next->clone();\n+    _igvn.register_new_node_with_optimizer(clone);\n+    old_new_mapping.Insert(next, clone);\n+  }\n+  return old_new_mapping;\n+}\n+\n+\/\/ Rewire inputs of the unprocessed cloned nodes (inputs are not updated, yet, and still point to the old nodes) by\n+\/\/ using the old_new_mapping.\n+void PhaseIdealLoop::rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl,\n+                                                 const Node_List& nodes_with_same_ctrl, const Dict& old_new_mapping) {\n+  for (uint i = 0; i < nodes_with_same_ctrl.size(); i++) {\n+    Node* next = nodes_with_same_ctrl[i];\n+    Node* clone = static_cast<Node*>(old_new_mapping[next]);\n+    if (next->in(0) == old_ctrl) {\n@@ -272,2 +292,2 @@\n-      _igvn.replace_input_of(clone, 0, if_uct);\n-      set_ctrl(clone, if_uct);\n+      _igvn.replace_input_of(clone, 0, new_ctrl);\n+      set_ctrl(clone, new_ctrl);\n@@ -275,0 +295,3 @@\n+    rewire_inputs_of_clones_to_clones(new_ctrl, clone, old_new_mapping, next);\n+  }\n+}\n@@ -276,11 +299,11 @@\n-    \/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n-    for (uint k = 1; k < next->req(); k++) {\n-      Node* in = next->in(k);\n-      if (!in->is_Phi()) {\n-        assert(!in->is_CFG(), \"must be data node\");\n-        Node* in_clone = old_new->at(in->_idx);\n-        if (in_clone != NULL) {\n-          assert(in_clone->_idx >= last_idx, \"must be a valid clone\");\n-          _igvn.replace_input_of(clone, k, in_clone);\n-          set_ctrl(clone, if_uct);\n-        }\n+\/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n+void PhaseIdealLoop::rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping,\n+                                                       const Node* next) {\n+  for (uint i = 1; i < next->req(); i++) {\n+    Node* in = next->in(i);\n+    if (!in->is_Phi()) {\n+      assert(!in->is_CFG(), \"must be data node\");\n+      Node* in_clone = static_cast<Node*>(old_new_mapping[in]);\n+      if (in_clone != NULL) {\n+        _igvn.replace_input_of(clone, i, in_clone);\n+        set_ctrl(clone, new_ctrl);\n@@ -290,3 +313,0 @@\n-  Node* clone_phi_input = old_new->at(phi_input->_idx);\n-  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n-  return clone_phi_input;\n@@ -294,0 +314,1 @@\n+\n@@ -296,8 +317,1 @@\n-                                                             Deoptimization::DeoptReason reason, Node_List* old_new) {\n-  UnswitchingAction unswitching_action;\n-  if (predicate_proj->other_if_proj()->outcnt() > 1) {\n-    \/\/ There are some data dependencies that need to be taken care of when cloning a predicate.\n-    unswitching_action = old_new == NULL ? UnswitchingAction::SlowLoopRewiring : UnswitchingAction::FastLoopCloning;\n-  } else {\n-    unswitching_action = UnswitchingAction::None;\n-  }\n+                                                             Deoptimization::DeoptReason reason, const bool slow_loop) {\n@@ -306,1 +320,1 @@\n-                                                             true, old_new, unswitching_action);\n+                                                             slow_loop);\n@@ -405,1 +419,2 @@\n-  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(), predicate->is_IfTrue());\n+  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(),\n+                                               false, predicate->is_IfTrue());\n@@ -438,2 +453,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate,false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate,true);\n@@ -447,2 +462,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred, Deoptimization::Reason_profile_predicate, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred, Deoptimization::Reason_profile_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred,Deoptimization::Reason_profile_predicate, false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred,Deoptimization::Reason_profile_predicate, true);\n@@ -458,2 +473,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred, Deoptimization::Reason_loop_limit_check, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred, Deoptimization::Reason_loop_limit_check);\n+    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred,Deoptimization::Reason_loop_limit_check, false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred,Deoptimization::Reason_loop_limit_check, true);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":98,"deletions":83,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -1283,7 +1283,0 @@\n-  \/\/ Enum to determine the action to be performed in create_new_if_for_predicate() when processing phis of UCT regions.\n-  enum class UnswitchingAction {\n-    None,            \/\/ No special action.\n-    FastLoopCloning, \/\/ Need to clone nodes for the fast loop.\n-    SlowLoopRewiring \/\/ Need to rewire nodes for the slow loop.\n-  };\n-\n@@ -1292,2 +1285,2 @@\n-                                        int opcode, bool if_cont_is_true_proj = true, Node_List* old_new = NULL,\n-                                        UnswitchingAction unswitching_action = UnswitchingAction::None);\n+                                        int opcode, bool rewire_uncommon_proj_phi_inputs = false,\n+                                        bool if_cont_is_true_proj = true);\n@@ -1295,2 +1288,9 @@\n-  \/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate.\n-  Node* clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new);\n+ private:\n+  \/\/ Helper functions for create_new_if_for_predicate()\n+  void set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Unique_Node_List find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl);\n+  Node* clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Dict clone_nodes(const Node_List& list_to_clone);\n+  void rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl, const Node_List& nodes_with_same_ctrl,\n+                                   const Dict& old_new_mapping);\n+  void rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping, const Node* next);\n@@ -1298,0 +1298,1 @@\n+ public:\n@@ -1584,2 +1585,2 @@\n-  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                               Node_List* old_new = NULL);\n+  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry,\n+                                               Deoptimization::DeoptReason reason, bool slow_loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"}]}