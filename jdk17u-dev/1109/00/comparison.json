{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -35,0 +37,1 @@\n+    private final Pattern compileIdPatternForTestClass;\n@@ -36,1 +39,1 @@\n-    public AbstractLine(BufferedReader reader) {\n+    public AbstractLine(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n@@ -38,0 +41,1 @@\n+        this.compileIdPatternForTestClass = compileIdPatternForTestClass;\n@@ -51,0 +55,33 @@\n+\n+    \/**\n+     * Is this line a start of a method in the test class? We only care about test class entries. There might be non-class\n+     * entries as well if the user specified additional compile commands. Ignore these.\n+     *\/\n+    public boolean isTestClassCompilation() {\n+        if (isCompilation()) {\n+            Matcher matcher = compileIdPatternForTestClass.matcher(line);\n+            return matcher.find();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Is this header a C2 non-OSR compilation header entry?\n+     *\/\n+    public boolean isCompilation() {\n+        return line.startsWith(\"<task_queued\") && notOSRCompilation() && notC2Compilation();\n+    }\n+\n+    \/**\n+     * OSR compilations have compile_kind set.\n+     *\/\n+    protected boolean notOSRCompilation() {\n+        return !line.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Non-C2 compilations have level set.\n+     *\/\n+    private boolean notC2Compilation() {\n+        return !line.contains(\"level='\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/AbstractLine.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class representing a PrintIdeal or PrintOptoAssembly output block read from the hotspot_pid* file.\n+ *\/\n+record Block(String output, List<String> testClassCompilations) {\n+    public String getOutput() {\n+        return output;\n+    }\n+\n+    public boolean containsTestClassCompilations() {\n+        return !testClassCompilations.isEmpty();\n+    }\n+\n+    public List<String> getTestClassCompilations() {\n+        return testClassCompilations;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/Block.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.regex.Pattern;\n@@ -33,2 +34,2 @@\n-    public BlockLine(BufferedReader reader) {\n-        super(reader);\n+    public BlockLine(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n+        super(reader, compileIdPatternForTestClass);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/BlockLine.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n@@ -33,1 +36,1 @@\n-    private final BufferedReader reader;\n+    private final BlockLine line;\n@@ -35,2 +38,2 @@\n-    public BlockOutputReader(BufferedReader reader) {\n-        this.reader = reader;\n+    public BlockOutputReader(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n+        this.line = new BlockLine(reader, compileIdPatternForTestClass);\n@@ -42,2 +45,1 @@\n-    public String readBlock() throws IOException {\n-        BlockLine line = new BlockLine(reader);\n+    public Block readBlock() throws IOException {\n@@ -45,0 +47,1 @@\n+        List<String> testClassCompilations = new ArrayList<>();\n@@ -46,0 +49,6 @@\n+            if (line.isTestClassCompilation()) {\n+                \/\/ Could have safepointed while writing the block (see IRMatcher.SAFEPOINT_WHILE_PRINTING_MESSAGE)\n+                \/\/ and enqueuing the next test class method for compilation during the interruption. Record this\n+                \/\/ method to ensure that we read the PrintIdeal\/PrintOptoAssembly blocks for that method later.\n+                testClassCompilations.add(line.getLine());\n+            }\n@@ -48,1 +57,1 @@\n-        return builder.toString();\n+        return new Block(builder.toString(), testClassCompilations);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/BlockOutputReader.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -78,1 +79,1 @@\n-            BlockOutputReader blockOutputReader = new BlockOutputReader(reader);\n+            BlockOutputReader blockOutputReader = new BlockOutputReader(reader, compileIdPatternForTestClass);\n@@ -83,2 +84,1 @@\n-                    String blockOutput = blockOutputReader.readBlock();\n-                    setIRMethodOutput(blockOutput, line, compileIdMap);\n+                    processMethodBlock(compileIdMap, line, blockOutputReader);\n@@ -90,0 +90,11 @@\n+    private void processMethodBlock(Map<Integer, IRMethod> compileIdMap, Line line, BlockOutputReader blockOutputReader)\n+            throws IOException {\n+        Block block = blockOutputReader.readBlock();\n+        if (block.containsTestClassCompilations()) {\n+            \/\/ Register all test method compilations that could have been emitted during a rare safepoint while\n+            \/\/ dumping the PrintIdeal\/PrintOptoAssembly output.\n+            block.getTestClassCompilations().forEach(l -> parseTestMethodCompileId(compileIdMap, l));\n+        }\n+        setIRMethodOutput(block.getOutput(), line, compileIdMap);\n+    }\n+\n@@ -104,0 +115,3 @@\n+    \/**\n+     * Is this a @Test method?\n+     *\/\n@@ -112,2 +126,0 @@\n-\n-\n@@ -122,0 +134,3 @@\n+    \/**\n+     * Is this line the start of a PrintIdeal\/PrintOptoAssembly output block of a @Test method?\n+     *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/HotSpotPidFileParser.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-    private final Pattern compileIdPatternForTestClass;\n-\n@@ -37,35 +35,1 @@\n-        super(reader);\n-        this.compileIdPatternForTestClass = compileIdPatternForTestClass;\n-    }\n-\n-    \/**\n-     * Is this line a start of a @Test annotated method? We only care about test class entries. There might be non-class\n-     * entries as well if user specified additional compile commands. Ignore these.\n-     *\/\n-    public boolean isTestClassCompilation() {\n-        if (isCompilation()) {\n-            Matcher matcher = compileIdPatternForTestClass.matcher(line);\n-            return matcher.find();\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Is this header a C2 non-OSR compilation header entry?\n-     *\/\n-    public boolean isCompilation() {\n-        return line.startsWith(\"<task_queued\") && notOSRCompilation() && notC2Compilation();\n-    }\n-\n-    \/**\n-     * OSR compilations have compile_kind set.\n-     *\/\n-    private boolean notOSRCompilation() {\n-        return !line.contains(\"compile_kind='\");\n-    }\n-\n-    \/**\n-     * Non-C2 compilations have level set.\n-     *\/\n-    private boolean notC2Compilation() {\n-        return !line.contains(\"level='\");\n+        super(reader, compileIdPatternForTestClass);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/Line.java","additions":1,"deletions":37,"binary":false,"changes":38,"status":"modified"}]}