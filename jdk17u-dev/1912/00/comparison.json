{"files":[{"patch":"@@ -69,0 +69,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libGetXSpace := $(WIN_LIB_JAVA)\n@@ -72,0 +73,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libGetXSpace := -ljava\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main\/othervm -Djava.security.manager=allow GetXSpace\n+ * @run main\/othervm\/native -Djava.security.manager=allow GetXSpace\n@@ -55,0 +55,3 @@\n+    static {\n+        System.loadLibrary(\"GetXSpace\");\n+    }\n@@ -59,3 +62,0 @@\n-    \/\/ FileSystem Total Used Available Use% MountedOn\n-    private static final Pattern DF_PATTERN = Pattern.compile(\"([^\\\\s]+)\\\\s+(\\\\d+)\\\\s+\\\\d+\\\\s+(\\\\d+)\\\\s+\\\\d+%\\\\s+([^\\\\s].*)\\n\");\n-\n@@ -103,1 +103,0 @@\n-        private static final long KSIZE = 1024;\n@@ -105,0 +104,1 @@\n+        private final long size;\n@@ -107,0 +107,1 @@\n+        private final long available;\n@@ -108,7 +109,1 @@\n-        Space(String total, String free, String name) {\n-            try {\n-                this.total = Long.parseLong(total) * KSIZE;\n-                this.free = Long.parseLong(free) * KSIZE;\n-            } catch (NumberFormatException x) {\n-                throw new RuntimeException(\"the regex should have caught this\", x);\n-            }\n+        Space(String name) {\n@@ -116,0 +111,7 @@\n+            long[] sizes = new long[4];\n+            if (getSpace0(name, sizes))\n+                System.err.println(\"WARNING: total space is estimated\");\n+            this.size = sizes[0];\n+            this.total = sizes[1];\n+            this.free = sizes[2];\n+            this.available = sizes[3];\n@@ -119,0 +121,1 @@\n+        long size() { return size; }\n@@ -120,0 +123,1 @@\n+        long available() { return available; }\n@@ -121,0 +125,1 @@\n+\n@@ -122,1 +127,2 @@\n-            return ((freeSpace >= (free \/ 10)) && (freeSpace <= (free * 10)));\n+            return ((freeSpace >= (available \/ 10)) &&\n+                    (freeSpace <= (available * 10)));\n@@ -124,0 +130,1 @@\n+\n@@ -125,1 +132,1 @@\n-            return String.format(\"%s (%d\/%d)\", name, free, total);\n+            return String.format(\"%s (%d\/%d\/%d)\", name, total, free, available);\n@@ -129,1 +136,1 @@\n-    private static ArrayList<Space> space(String f) throws IOException {\n+    private static void diskFree() throws IOException {\n@@ -132,1 +139,1 @@\n-        String cmd = \"df -k -P\" + (f == null ? \"\" : \" \" + f);\n+        String cmd = \"fsutil volume diskFree C:\\\\\";\n@@ -135,1 +142,1 @@\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+        try (BufferedReader in = p.inputReader()) {\n@@ -145,0 +152,1 @@\n+    }\n@@ -146,20 +154,2 @@\n-        Matcher m = DF_PATTERN.matcher(sb);\n-        int j = 0;\n-        while (j < sb.length()) {\n-            if (m.find(j)) {\n-                \/\/ swap can change while this test is running\n-                if (!m.group(1).equals(\"swap\")) {\n-                    String name = f;\n-                    if (name == null) {\n-                        \/\/ cygwin's df lists windows path as FileSystem (1st group)\n-                        name = Platform.isWindows() ? m.group(1) : m.group(4);\n-                    }\n-                    al.add(new Space(m.group(2), m.group(3), name));;\n-                }\n-                j = m.end();\n-            } else {\n-                throw new RuntimeException(\"unrecognized df output format: \"\n-                                           + \"charAt(\" + j + \") = '\"\n-                                           + sb.charAt(j) + \"'\");\n-            }\n-        }\n+    private static ArrayList<String> paths() throws IOException {\n+        ArrayList<String> al = new ArrayList<>();\n@@ -167,4 +157,5 @@\n-        if (al.size() == 0) {\n-            \/\/ df did not produce output\n-            String name = (f == null ? \"\" : f);\n-            al.add(new Space(\"0\", \"0\", name));\n+        File[] roots = File.listRoots();\n+        long[] space = new long[4];\n+        for (File root : roots) {\n+            String path = root.toString();\n+            al.add(path);\n@@ -172,0 +163,1 @@\n+\n@@ -211,4 +203,4 @@\n-        out.format(\"%s:%n\", s.name());\n-        String fmt = \"  %-4s total= %12d free = %12d usable = %12d%n\";\n-        out.format(fmt, \"df\", s.total(), 0, s.free());\n-        out.format(fmt, \"getX\", ts, fs, us);\n+        out.format(\"%s (%d):%n\", s.name(), s.size());\n+        String fmt = \"  %-4s total = %12d free = %12d usable = %12d%n\";\n+        out.format(fmt, \"getSpace0\", s.total(), s.free(), s.available());\n+        out.format(fmt, \"getXSpace\", ts, fs, us);\n@@ -218,1 +210,2 @@\n-        if (ts != s.total() && (!Platform.isOSX() || !s.name().equals(\"\/dev\"))) {\n+        if (ts != s.total()\n+            && (!Platform.isOSX() || !s.name().equals(\"\/dev\"))) {\n@@ -235,7 +228,6 @@\n-            \/\/ On macOS, the number of 1024 byte blocks might be incorrectly\n-            \/\/ calculated by 'df' using integer division by 2 of the number of\n-            \/\/ 512 byte blocks, resulting in a size smaller than the actual\n-            \/\/ value when the number of blocks is odd.\n-            if (!Platform.isOSX() || blockSize != 512 || numBlocks % 2 == 0\n-                || ts - s.total() != 512) {\n-                fail(s.name(), s.total(), \"!=\", ts);\n+            if (Platform.isWindows()) {\n+                if (ts > s.total()) {\n+                    fail(s.name() + \" total space\", ts, \">\", s.total());\n+                }\n+            } else if (ts != s.total()) {\n+                fail(s.name() + \" total space\", ts, \"!=\", s.total());\n@@ -247,1 +239,1 @@\n-        \/\/ unix df returns statvfs.f_bavail\n+        \/\/ unix usable space is from statvfs.f_bavail\n@@ -250,1 +242,1 @@\n-            fail(s.name(), s.free(), \"??\", tsp);\n+            fail(s.name(), s.available(), \"??\", tsp);\n@@ -255,2 +247,13 @@\n-        if (fs > s.total()) {\n-            fail(s.name(), s.total(), \">\", fs);\n+        \/\/\n+        \/\/ Invariants are:\n+        \/\/ total space <= size\n+        \/\/ total space == size (Unix)\n+        \/\/ free space <= total space (if no quotas in effect) (Windows)\n+        \/\/ free space < size (if quotas in effect) (Windows)\n+        \/\/ usable space <= total space\n+        \/\/ usable space <= free space\n+        \/\/\n+\n+        \/\/ total space <= size\n+        if (ts > s.size()) {\n+            fail(s.name() + \" size\", ts, \">\", s.size());\n@@ -261,0 +264,19 @@\n+        \/\/ On Unix the total space should always be the volume size\n+        if (Platform.isWindows()) {\n+            \/\/ ts != s.size() indicates that quotas are in effect\n+            if (ts == s.size() && fs > s.total()) {\n+                fail(s.name() + \" free space\", fs, \">\", s.total());\n+            } else if (ts < s.size() && fs > s.size()) {\n+                fail(s.name() + \" free space (quota)\", fs, \">\", s.size());\n+            } else {\n+                pass();\n+            }\n+        } else { \/\/ not Windows\n+            if (ts != s.size()) {\n+                fail(s.name() + \" total space\", ts, \"!=\", s.size());\n+            } else {\n+                pass();\n+            }\n+        }\n+\n+        \/\/ usable space <= total space\n@@ -262,1 +284,14 @@\n-            fail(s.name(), s.total(), \">\", us);\n+            fail(s.name() + \" usable space\", us, \">\", s.total());\n+        } else {\n+            pass();\n+        }\n+\n+        \/\/ usable space <= free space\n+        if (us > s.free()) {\n+            \/\/ free and usable change dynamically\n+            System.err.println(\"Warning: us > s.free()\");\n+            if (1.0 - Math.abs((double)s.free()\/(double)us) > 0.01) {\n+                fail(s.name() + \" usable vs. free space\", us, \">\", s.free());\n+            } else {\n+                pass();\n+            }\n@@ -319,1 +354,1 @@\n-              return;\n+                return;\n@@ -326,1 +361,1 @@\n-              return;\n+                return;\n@@ -358,7 +393,1 @@\n-        ArrayList<Space> l;\n-        try {\n-            l = space(dirName);\n-        } catch (IOException x) {\n-            throw new RuntimeException(dirName + \" can't get file system information\", x);\n-        }\n-        compare(l.get(0));\n+        compare(new Space(dir.getRoot().toString()));\n@@ -368,1 +397,1 @@\n-                fail + pass, fail, first);\n+                       fail + pass, fail, first);\n@@ -376,5 +405,5 @@\n-    private static int testDF() {\n-        out.println(\"--- Testing df\");\n-        \/\/ Find all of the partitions on the machine and verify that the size\n-        \/\/ returned by \"df\" is equivalent to File.getXSpace() values.\n-        ArrayList<Space> l;\n+    private static int testVolumes() {\n+        out.println(\"--- Testing volumes\");\n+        \/\/ Find all of the partitions on the machine and verify that the sizes\n+        \/\/ returned by File::getXSpace are equivalent to those from getSpace0\n+        ArrayList<String> l;\n@@ -382,1 +411,4 @@\n-            l = space(null);\n+            l = paths();\n+            if (Platform.isWindows()) {\n+                diskFree();\n+            }\n@@ -398,1 +430,2 @@\n-            for (var s : l) {\n+            for (var p : l) {\n+                Space s = new Space(p);\n@@ -413,1 +446,1 @@\n-                fail + pass, fail, first);\n+                       fail + pass, fail, first);\n@@ -436,1 +469,1 @@\n-        int failedTests = testDF();\n+        int failedTests = testVolumes();\n@@ -455,0 +488,9 @@\n+\n+    \/\/\n+    \/\/ root     the root of the volume\n+    \/\/ size[0]  total size:   number of bytes in the volume\n+    \/\/ size[1]  total space:  number of bytes visible to the caller\n+    \/\/ size[2]  free space:   number of free bytes in the volume\n+    \/\/ size[3]  usable space: number of bytes available to the caller\n+    \/\/\n+    private static native boolean getSpace0(String root, long[] space);\n","filename":"test\/jdk\/java\/io\/File\/GetXSpace.java","additions":120,"deletions":78,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdlib.h>\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#ifdef _WIN64\n+#include <windows.h>\n+#include <fileapi.h>\n+#include <winerror.h>\n+#else\n+#include <errno.h>\n+#include <string.h>\n+#if __APPLE__\n+#include <sys\/param.h>\n+#include <sys\/mount.h>\n+#else\n+#include <sys\/statfs.h>\n+#endif\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifdef _WIN64\n+jboolean initialized = JNI_FALSE;\n+BOOL(WINAPI * pfnGetDiskSpaceInformation)(LPCWSTR, LPVOID) = NULL;\n+#endif\n+\n+\/\/\n+\/\/ root      the root of the volume\n+\/\/ sizes[0]  total size:   number of bytes in the volume\n+\/\/ sizes[1]  total space:  number of bytes visible to the caller\n+\/\/ sizes[2]  free space:   number of free bytes in the volume\n+\/\/ sizes[3]  usable space: number of bytes available to the caller\n+\/\/\n+JNIEXPORT jboolean JNICALL\n+Java_GetXSpace_getSpace0\n+    (JNIEnv *env, jclass cls, jstring root, jlongArray sizes)\n+{\n+    jboolean totalSpaceIsEstimated = JNI_FALSE;\n+    jlong array[4];\n+    const jchar* strchars = (*env)->GetStringChars(env, root, NULL);\n+    if (strchars == NULL) {\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     \"GetStringChars\");\n+        return JNI_FALSE;\n+    }\n+\n+#ifdef _WIN64\n+    if (initialized == JNI_FALSE) {\n+        initialized = JNI_TRUE;\n+        HMODULE hmod = GetModuleHandleW(L\"kernel32\");\n+        if (hmod != NULL) {\n+            *(FARPROC*)&pfnGetDiskSpaceInformation =\n+                GetProcAddress(hmod, \"GetDiskSpaceInformationW\");\n+        }\n+    }\n+\n+    LPCWSTR path = (LPCWSTR)strchars;\n+\n+    if (pfnGetDiskSpaceInformation != NULL) {\n+        \/\/ use GetDiskSpaceInformationW\n+        DISK_SPACE_INFORMATION diskSpaceInfo;\n+        BOOL hres = pfnGetDiskSpaceInformation(path, &diskSpaceInfo);\n+        (*env)->ReleaseStringChars(env, root, strchars);\n+        if (FAILED(hres)) {\n+            JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                         \"GetDiskSpaceInformationW\");\n+            return totalSpaceIsEstimated;\n+        }\n+\n+        ULONGLONG bytesPerAllocationUnit =\n+            diskSpaceInfo.SectorsPerAllocationUnit*diskSpaceInfo.BytesPerSector;\n+        array[0] = (jlong)(diskSpaceInfo.ActualTotalAllocationUnits*\n+                           bytesPerAllocationUnit);\n+        array[1] = (jlong)(diskSpaceInfo.CallerTotalAllocationUnits*\n+                           bytesPerAllocationUnit);\n+        array[2] = (jlong)(diskSpaceInfo.ActualAvailableAllocationUnits*\n+                           bytesPerAllocationUnit);\n+        array[3] = (jlong)(diskSpaceInfo.CallerAvailableAllocationUnits*\n+                           bytesPerAllocationUnit);\n+    } else {\n+        totalSpaceIsEstimated = JNI_TRUE;\n+\n+        \/\/ if GetDiskSpaceInformationW is unavailable (\"The specified\n+        \/\/ procedure could not be found\"), fall back to GetDiskFreeSpaceExW\n+        ULARGE_INTEGER freeBytesAvailable;\n+        ULARGE_INTEGER totalNumberOfBytes;\n+        ULARGE_INTEGER totalNumberOfFreeBytes;\n+\n+        BOOL hres = GetDiskFreeSpaceExW(path, &freeBytesAvailable,\n+            &totalNumberOfBytes, &totalNumberOfFreeBytes);\n+        (*env)->ReleaseStringChars(env, root, strchars);\n+        if (FAILED(hres)) {\n+            JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                         \"GetDiskFreeSpaceExW\");\n+            return totalSpaceIsEstimated;\n+        }\n+\n+        \/\/ If quotas are in effect, it is impossible to obtain the volume size,\n+        \/\/ so estimate it as free + used = free + (visible - available)\n+        ULONGLONG used = totalNumberOfBytes.QuadPart - freeBytesAvailable.QuadPart;\n+        array[0] = (jlong)(totalNumberOfFreeBytes.QuadPart + used);\n+        array[1] = (jlong)totalNumberOfBytes.QuadPart;\n+        array[2] = (jlong)totalNumberOfFreeBytes.QuadPart;\n+        array[3] = (jlong)freeBytesAvailable.QuadPart;\n+    }\n+#else\n+    int len = (int)(*env)->GetStringLength(env, root);\n+    char* chars = (char*)malloc((len + 1)*sizeof(char));\n+    if (chars == NULL) {\n+        (*env)->ReleaseStringChars(env, root, strchars);\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     \"malloc\");\n+        return JNI_FALSE;\n+    }\n+\n+    for (int i = 0; i < len; i++) {\n+        chars[i] = (char)strchars[i];\n+    }\n+    chars[len] = '\\0';\n+    (*env)->ReleaseStringChars(env, root, strchars);\n+\n+    struct statfs buf;\n+    int result = statfs((const char*)chars, &buf);\n+    free(chars);\n+    if (result < 0) {\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     strerror(errno));\n+        return totalSpaceIsEstimated;\n+    }\n+\n+    array[0] = (jlong)(buf.f_blocks*buf.f_bsize);\n+    array[1] = array[0]; \/\/ number visible is the same as the total size\n+    array[2] = (jlong)(buf.f_bfree*buf.f_bsize);\n+    array[3] = (jlong)(buf.f_bavail*buf.f_bsize);\n+#endif\n+    (*env)->SetLongArrayRegion(env, sizes, 0, 4, array);\n+    return totalSpaceIsEstimated;\n+}\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/jdk\/java\/io\/File\/libGetXSpace.c","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}