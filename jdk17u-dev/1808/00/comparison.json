{"files":[{"patch":"@@ -91,1 +91,1 @@\n-                    NativeCallStack(0) : NativeCallStack::empty_stack())\n+                    NativeCallStack(0) : FAKE_CALLSTACK)\n@@ -93,1 +93,1 @@\n-                    NativeCallStack(1) : NativeCallStack::empty_stack())\n+                    NativeCallStack(1) : FAKE_CALLSTACK)\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  DEBUG_ONLY(assert_not_fake();)\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+\n@@ -61,0 +62,21 @@\n+\n+  enum class FakeMarker { its_fake };\n+#ifdef ASSERT\n+  static constexpr uintptr_t _fake_address = -2; \/\/ 0xFF...FE\n+  inline void assert_not_fake() const {\n+    assert(_stack[0] != (address)_fake_address, \"Must not be a fake stack\");\n+  }\n+#endif\n+\n+  \/\/ This \"fake\" constructor is only used in the CALLER_PC and CURRENT_PC macros\n+  \/\/ when NMT is off or in summary mode. In these cases, it does not need a\n+  \/\/ callstack, and we can leave the constructed object uninitialized. That will\n+  \/\/ cause the constructor call to be optimized away (see JDK-8296437).\n+  explicit NativeCallStack(FakeMarker dummy) {\n+#ifdef ASSERT\n+    for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+      _stack[i] = (address)_fake_address;\n+    }\n+#endif\n+  }\n+\n@@ -68,1 +90,1 @@\n-  NativeCallStack(address* pc, int frameCount);\n+  explicit NativeCallStack(address* pc, int frameCount);\n@@ -74,0 +96,1 @@\n+    DEBUG_ONLY(assert_not_fake();)\n@@ -95,0 +118,1 @@\n+    DEBUG_ONLY(assert_not_fake();)\n@@ -106,0 +130,2 @@\n+#define FAKE_CALLSTACK NativeCallStack(NativeCallStack::FakeMarker::its_fake)\n+\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"}]}