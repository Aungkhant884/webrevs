{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,0 +4,1 @@\n+ * Copyright (c) 2022, IBM Corp.\n@@ -27,0 +28,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -37,2 +39,5 @@\n-  if (pc == NULL)\n-    pc =  (address) *(sp + 2);\n+  \/\/ Assume spill slot for link register contains a suitable pc.\n+  \/\/ Should have been filled by method entry code.\n+  if (pc == NULL) {\n+    pc = (address) *(sp + 2);\n+  }\n@@ -44,4 +49,62 @@\n-  ucontext_t* uc = (ucontext_t*) ucontext;\n-  *fr_addr = frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/],\n-                   (address)uc->uc_mcontext.jmp_context.iar);\n-  return true;\n+\n+  \/\/ If we have a last_Java_frame, then we should use it even if\n+  \/\/ isInJava == true.  It should be more reliable than ucontext info.\n+  if (has_last_Java_frame() && frame_anchor()->walkable()) {\n+    frame last_frame = pd_last_frame();\n+    if (last_frame.pc() == nullptr) return false;\n+    *fr_addr = last_frame;\n+    return true;\n+  }\n+\n+  \/\/ At this point, we don't have a last_Java_frame, so\n+  \/\/ we try to glean some information out of the ucontext\n+  \/\/ if we were running Java code when SIGPROF came in.\n+  if (isInJava) {\n+    ucontext_t* uc = (ucontext_t*) ucontext;\n+    address pc = (address)uc->uc_mcontext.jmp_context.iar;\n+\n+    if (pc == NULL) {\n+      \/\/ ucontext wasn't useful\n+      return false;\n+    }\n+\n+    frame ret_frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/], pc);\n+\n+    if (ret_frame.fp() == NULL) {\n+      \/\/ The found frame does not have a valid frame pointer.\n+      \/\/ Bail out because this will create big trouble later on, either\n+      \/\/  - when using istate, calculated as (NULL - ijava_state_size) or\n+      \/\/  - when using fp() directly in safe_for_sender()\n+      \/\/\n+      \/\/ There is no conclusive description (yet) how this could happen, but it does.\n+      \/\/ For more details on what was observed, see thread_linux_s390.cpp\n+      return false;\n+    }\n+\n+    if (ret_frame.is_interpreted_frame()) {\n+      frame::ijava_state *istate = ret_frame.get_ijava_state();\n+      const Method *m = (const Method*)(istate->method);\n+      if (!Method::is_valid_method(m)) return false;\n+      if (!Metaspace::contains(m->constMethod())) return false;\n+\n+      uint64_t reg_bcp = uc->uc_mcontext.jmp_context.gpr[14\/*R14_bcp*\/];\n+      uint64_t istate_bcp = istate->bcp;\n+      uint64_t code_start = (uint64_t)(m->code_base());\n+      uint64_t code_end = (uint64_t)(m->code_base() + m->code_size());\n+      if (istate_bcp >= code_start && istate_bcp < code_end) {\n+        \/\/ we have a valid bcp, don't touch it, do nothing\n+      } else if (reg_bcp >= code_start && reg_bcp < code_end) {\n+        istate->bcp = reg_bcp;\n+      } else {\n+        return false;\n+      }\n+    }\n+    if (!ret_frame.safe_for_sender(this)) {\n+      \/\/ nothing else to try if the frame isn't good\n+      return false;\n+    }\n+    *fr_addr = ret_frame;\n+    return true;\n+  }\n+  \/\/ nothing else to try\n+  return false;\n@@ -50,1 +113,1 @@\n-\/\/ Forte Analyzer AsyncGetCallTrace profiling support is not implemented on Aix\/PPC.\n+\/\/ Forte Analyzer AsyncGetCallTrace profiling support.\n@@ -52,2 +115,1 @@\n-  Unimplemented();\n-  return false;\n+  return pd_get_top_frame_for_profiling(fr_addr, ucontext, isInJava);\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/thread_aix_ppc.cpp","additions":72,"deletions":10,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-    *fr_addr = pd_last_frame();\n+    frame last_frame = pd_last_frame();\n+    if (last_frame.pc() == nullptr) return false;\n+    *fr_addr = last_frame;\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/thread_linux_ppc.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}