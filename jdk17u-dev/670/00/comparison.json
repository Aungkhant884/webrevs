{"files":[{"patch":"@@ -7207,1 +7207,1 @@\n-void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register key, Register pos,\n+void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register table, Register pos,\n@@ -7220,1 +7220,1 @@\n-  movdqu(xmm10, Address(key, 1 * 16));    \/\/rk1 and rk2 in xmm10\n+  movdqu(xmm10, Address(table, 1 * 16));    \/\/rk1 and rk2 in xmm10\n@@ -7247,1 +7247,1 @@\n-  movdqu(xmm10, Address(key, 1 * 16));    \/\/ rk1 and rk2 in xmm10\n+  movdqu(xmm10, Address(table, 1 * 16));    \/\/ rk1 and rk2 in xmm10\n@@ -7367,0 +7367,1 @@\n+* param table address of crc or crc32c table\n@@ -7370,0 +7371,4 @@\n+*\n+* This routine is identical for crc32c with the exception of the precomputed constant\n+* table which will be passed as the table argument.  The calculation steps are\n+* the same for both variants.\n@@ -7371,2 +7376,2 @@\n-void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register key, Register tmp1, Register tmp2) {\n-  assert_different_registers(crc, buf, len, key, tmp1, tmp2, rax);\n+void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register table, Register tmp1, Register tmp2) {\n+  assert_different_registers(crc, buf, len, table, tmp1, tmp2, rax, r12);\n@@ -7387,2 +7392,0 @@\n-  lea(key, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));\n-  notl(crc);\n@@ -7402,1 +7405,1 @@\n-  evbroadcasti32x4(xmm10, Address(key, 2 * 16), Assembler::AVX_512bit); \/\/zmm10 has rk3 and rk4\n+  evbroadcasti32x4(xmm10, Address(table, 2 * 16), Assembler::AVX_512bit); \/\/zmm10 has rk3 and rk4\n@@ -7410,1 +7413,1 @@\n-  evbroadcasti32x4(xmm16, Address(key, 0 * 16), Assembler::AVX_512bit); \/\/zmm16 has rk-1 and rk-2\n+  evbroadcasti32x4(xmm16, Address(table, 0 * 16), Assembler::AVX_512bit); \/\/zmm16 has rk-1 and rk-2\n@@ -7456,2 +7459,2 @@\n-  evmovdquq(xmm16, Address(key, 5 * 16), Assembler::AVX_512bit); \/\/ multiply by rk9-rk16\n-  evmovdquq(xmm11, Address(key, 9 * 16), Assembler::AVX_512bit); \/\/ multiply by rk17-rk20, rk1,rk2, 0,0\n+  evmovdquq(xmm16, Address(table, 5 * 16), Assembler::AVX_512bit); \/\/ multiply by rk9-rk16\n+  evmovdquq(xmm11, Address(table, 9 * 16), Assembler::AVX_512bit); \/\/ multiply by rk17-rk20, rk1,rk2, 0,0\n@@ -7466,1 +7469,1 @@\n-  movdqu(xmm10, Address(key, 1 * 16));\n+  movdqu(xmm10, Address(table, 1 * 16));\n@@ -7482,1 +7485,1 @@\n-  vpclmulqdq(xmm8, xmm7, xmm10, 0x1);\n+  vpclmulqdq(xmm8, xmm7, xmm10, 0x01);\n@@ -7513,1 +7516,1 @@\n-  vpclmulqdq(xmm8, xmm7, xmm10, 0x1);\n+  vpclmulqdq(xmm8, xmm7, xmm10, 0x01);\n@@ -7520,1 +7523,1 @@\n-  movdqu(xmm10, Address(key, 3 * 16));\n+  movdqu(xmm10, Address(table, 3 * 16));\n@@ -7536,1 +7539,1 @@\n-  kernel_crc32_avx512_256B(crc, buf, len, key, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);\n+  kernel_crc32_avx512_256B(crc, buf, len, table, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);\n@@ -7543,1 +7546,1 @@\n-  movdqu(xmm10, Address(key, 4 * 16));\n+  movdqu(xmm10, Address(table, 4 * 16));\n@@ -7555,1 +7558,0 @@\n-  notl(crc); \/\/ ~c\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -5721,0 +5721,5 @@\n+        \/\/ The constants used in the CRC32 algorithm requires the 1's compliment of the initial crc value.\n+        \/\/ However, the constant table for CRC32-C assumes the original crc value.  Account for this\n+        \/\/ difference before calling and after returning.\n+      __ lea(table, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));\n+      __ notl(crc);\n@@ -5722,0 +5727,1 @@\n+      __ notl(crc);\n@@ -5773,0 +5779,6 @@\n+      if (VM_Version::supports_sse4_1() && VM_Version::supports_avx512_vpclmulqdq() &&\n+          VM_Version::supports_avx512bw() &&\n+          VM_Version::supports_avx512vl()) {\n+        __ lea(j, ExternalAddress(StubRoutines::x86::crc32c_table_avx512_addr()));\n+        __ kernel_crc32_avx512(crc, buf, len, j, l, k);\n+      } else {\n@@ -5774,2 +5786,2 @@\n-      __ push(y);\n-      __ push(z);\n+        __ push(y);\n+        __ push(z);\n@@ -5777,6 +5789,5 @@\n-      __ crc32c_ipl_alg2_alt2(crc, buf, len,\n-                              a, j, k,\n-                              l, y, z,\n-                              c_farg0, c_farg1, c_farg2,\n-                              is_pclmulqdq_supported);\n-      __ movl(rax, crc);\n+        __ crc32c_ipl_alg2_alt2(crc, buf, len,\n+                                a, j, k,\n+                                l, y, z,\n+                                c_farg0, c_farg1, c_farg2,\n+                                is_pclmulqdq_supported);\n@@ -5784,2 +5795,2 @@\n-      __ pop(z);\n-      __ pop(y);\n+        __ pop(z);\n+        __ pop(y);\n@@ -5787,0 +5798,2 @@\n+      }\n+      __ movl(rax, crc);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -215,0 +215,17 @@\n+juint StubRoutines::x86::_crc32c_table_avx512[] =\n+{\n+    0xb9e02b86UL, 0x00000000UL, 0xdcb17aa4UL, 0x00000000UL,\n+    0x493c7d27UL, 0x00000000UL, 0xc1068c50UL, 0x0000000eUL,\n+    0x06e38d70UL, 0x00000002UL, 0x6992cea2UL, 0x00000000UL,\n+    0x493c7d27UL, 0x00000000UL, 0xdd45aab8UL, 0x00000000UL,\n+    0xdea713f0UL, 0x00000000UL, 0x05ec76f0UL, 0x00000001UL,\n+    0x47db8317UL, 0x00000000UL, 0x2ad91c30UL, 0x00000000UL,\n+    0x0715ce53UL, 0x00000000UL, 0xc49f4f67UL, 0x00000000UL,\n+    0x39d3b296UL, 0x00000000UL, 0x083a6eecUL, 0x00000000UL,\n+    0x9e4addf8UL, 0x00000000UL, 0x740eef02UL, 0x00000000UL,\n+    0xddc0152bUL, 0x00000000UL, 0x1c291d04UL, 0x00000000UL,\n+    0xba4fc28eUL, 0x00000000UL, 0x3da6d0cbUL, 0x00000000UL,\n+    0x493c7d27UL, 0x00000000UL, 0xc1068c50UL, 0x0000000eUL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL\n+};\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  static juint    _crc32c_table_avx512[];\n@@ -250,0 +251,1 @@\n+  static address crc32c_table_avx512_addr()  { return (address)_crc32c_table_avx512; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.zip.CRC32C;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 2)\n+\n+public class TestCRC32C {\n+\n+    private CRC32C crc32c;\n+    private Random random;\n+    private byte[] bytes;\n+\n+    @Param({\"64\", \"128\", \"256\", \"512\", \"1024\", \"2048\", \"4096\", \"8192\", \"16384\", \"32768\", \"65536\"})\n+    private int count;\n+\n+    public TestCRC32C() {\n+        crc32c = new CRC32C();\n+        random = new Random(2147483648L);\n+        bytes = new byte[1000000];\n+        random.nextBytes(bytes);\n+    }\n+\n+    @Setup(Level.Iteration)\n+    public void setupBytes() {\n+        crc32c.reset();\n+    }\n+\n+    @Benchmark\n+    public void testCRC32CUpdate() {\n+        crc32c.update(bytes, 0, count);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/TestCRC32C.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}