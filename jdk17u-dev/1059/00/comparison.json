{"files":[{"patch":"@@ -1012,1 +1012,1 @@\n-                    && (if_ctrl->in(0)->is_MultiBranch() && if_ctrl->in(0)->Opcode() == Op_NeverBranch)) {\n+                    && if_ctrl->in(0)->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1031,1 +1031,1 @@\n-                      && (if_ctrl->in(0)->is_MultiBranch() && if_ctrl->in(0)->Opcode() == Op_NeverBranch)) {\n+                      && if_ctrl->in(0)->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-      } else if (c->Opcode() == Op_CProj && next->Opcode() == Op_NeverBranch) {\n+      } else if (c->Opcode() == Op_CProj && next->is_NeverBranch()) {\n@@ -2128,1 +2128,1 @@\n-    if (in != NULL && in->Opcode() == Op_Halt && in->in(0)->is_Proj() && in->in(0)->in(0)->Opcode() == Op_NeverBranch) {\n+    if (in != NULL && in->Opcode() == Op_Halt && in->in(0)->is_Proj() && in->in(0)->in(0)->is_NeverBranch()) {\n@@ -2159,1 +2159,1 @@\n-              assert(r->in(j)->Opcode() != Op_NeverBranch, \"\");\n+              assert(!r->in(j)->is_NeverBranch(), \"\");\n@@ -2165,1 +2165,1 @@\n-            assert(in->is_CallStaticJava() || in->Opcode() == Op_NeverBranch || in->Opcode() == Op_Catch || proj->is_IfProj(), \"\");\n+            assert(in->is_CallStaticJava() || in->is_NeverBranch() || in->Opcode() == Op_Catch || proj->is_IfProj(), \"\");\n@@ -2172,1 +2172,1 @@\n-            } else if (in->Opcode() == Op_NeverBranch) {\n+            } else if (in->is_NeverBranch()) {\n@@ -2644,1 +2644,1 @@\n-                     !(u->Opcode() == Op_CProj && u->in(0)->Opcode() == Op_NeverBranch && u->as_Proj()->_con == 1)) {\n+                     !(u->Opcode() == Op_CProj && u->in(0)->is_NeverBranch() && u->as_Proj()->_con == 1)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -623,1 +623,0 @@\n-  \/\/ Find true target\n@@ -625,2 +624,6 @@\n-  int idx = b->get_node(end_idx+1)->as_Proj()->_con;\n-  Block *succ = b->_succs[idx];\n+  NeverBranchNode* never_branch = b->get_node(end_idx)->as_NeverBranch();\n+  Block* succ = get_block_for_node(never_branch->proj_out(0)->unique_ctrl_out_or_null());\n+  Block* dead = get_block_for_node(never_branch->proj_out(1)->unique_ctrl_out_or_null());\n+  assert(succ == b->_succs[0] || succ == b->_succs[1], \"succ is a successor\");\n+  assert(dead == b->_succs[0] || dead == b->_succs[1], \"dead is a successor\");\n+\n@@ -645,1 +648,0 @@\n-  Block* dead = b->_succs[1 - idx];\n@@ -743,1 +745,1 @@\n-    if (block->get_node(block->end_idx())->Opcode() == Op_NeverBranch) {\n+    if (block->get_node(block->end_idx())->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -605,1 +605,4 @@\n-  NeverBranchNode( Node *ctrl ) : MultiBranchNode(1) { init_req(0,ctrl); }\n+  NeverBranchNode(Node* ctrl) : MultiBranchNode(1) {\n+    init_req(0, ctrl);\n+    init_class_id(Class_NeverBranch);\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1423,1 +1423,1 @@\n-  if (head->unique_ctrl_out()->Opcode() == Op_NeverBranch) {\n+  if (head->unique_ctrl_out()->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3696,2 +3696,2 @@\n-\/\/ Goes over all children of the root of the loop tree, collects all controls for the loop and its inner loops then\n-\/\/ checks whether any control is a branch out of the loop and if it is, whether it's not a NeverBranch.\n+\/\/ Goes over all children of the root of the loop tree. Check if any of them have a path\n+\/\/ down to Root, that does not go via a NeverBranch exit.\n@@ -3699,0 +3699,3 @@\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  \/\/ start traversal at all loop heads of first-level loops\n@@ -3700,1 +3703,0 @@\n-    Unique_Node_List wq;\n@@ -3703,28 +3705,20 @@\n-    for (uint i = 1; i < head->req(); ++i) {\n-      Node* in = head->in(i);\n-      if (get_loop(in) != _ltree_root) {\n-        wq.push(in);\n-      }\n-    }\n-    for (uint i = 0; i < wq.size(); ++i) {\n-      Node* c = wq.at(i);\n-      if (c == head) {\n-        continue;\n-      } else if (c->is_Region()) {\n-        for (uint j = 1; j < c->req(); ++j) {\n-          wq.push(c->in(j));\n-        }\n-      } else {\n-        wq.push(c->in(0));\n-      }\n-    }\n-    assert(wq.member(head), \"\");\n-    for (uint i = 0; i < wq.size(); ++i) {\n-      Node* c = wq.at(i);\n-      if (c->is_MultiBranch()) {\n-        for (DUIterator_Fast jmax, j = c->fast_outs(jmax); j < jmax; j++) {\n-          Node* u = c->fast_out(j);\n-          assert(u->is_CFG(), \"\");\n-          if (!wq.member(u) && c->Opcode() != Op_NeverBranch) {\n-            return false;\n-          }\n+    worklist.push(head);\n+  }\n+  \/\/ BFS traversal down the CFG, except through NeverBranch exits\n+  for (uint i = 0; i < worklist.size(); ++i) {\n+    Node* n = worklist.at(i);\n+    assert(n->is_CFG(), \"only traverse CFG\");\n+    if (n->is_Root()) {\n+      \/\/ Found root -> there was an exit!\n+      return false;\n+    } else if (n->is_NeverBranch()) {\n+      \/\/ Only follow the loop-internal projection, not the NeverBranch exit\n+      ProjNode* proj = n->as_NeverBranch()->proj_out_or_null(0);\n+      assert(proj != nullptr, \"must find loop-internal projection of NeverBranch\");\n+      worklist.push(proj);\n+    } else {\n+      \/\/ Traverse all CFG outputs\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node* use = n->fast_out(i);\n+        if (use->is_CFG()) {\n+          worklist.push(use);\n@@ -3735,0 +3729,1 @@\n+  \/\/ No exit found for any loop -> all are infinite\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -777,2 +777,2 @@\n-      if (u->Opcode() == Op_NeverBranch) {\n-        u = ((NeverBranchNode*)u)->proj_out(0);\n+      if (u->is_NeverBranch()) {\n+        u = u->as_NeverBranch()->proj_out(0);\n@@ -961,1 +961,1 @@\n-            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->Opcode() == Op_NeverBranch, \"must not be moved into inner loop\");\n+            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch(), \"must not be moved into inner loop\");\n@@ -1162,1 +1162,1 @@\n-        (dom->Opcode() == Op_NeverBranch && loop->is_member(get_loop(dom->in(0))))) {\n+        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -917,0 +917,1 @@\n+  DEFINE_CLASS_QUERY(NeverBranch)\n@@ -1073,0 +1074,2 @@\n+  \/\/ Placeholder until 8281732 is backported.\n+  Node* unique_ctrl_out_or_null() const { return unique_ctrl_out(); }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+super public class TestOnlyInfiniteLoops\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static Method test_simple:\"(III)I\"\n+    stack 200 locals 10\n+    {\n+    \/\/ Nested infinite loop, where inner loop eventually\n+    \/\/ looses exit to outer loop. Then, the inner loop\n+    \/\/ floats outside the inner loop. The entry from\n+    \/\/ outer to inner loop now becomes an exit for the\n+    \/\/ outer loop, where it now enters the next loop, that\n+    \/\/ used to be the inner loop.\n+        iconst_0;\n+        istore     9;\n+\n+        iload      0;\n+        ifeq LEND; \/\/ skip\n+\n+    LOOP1:\n+        iload      1;\n+        ifeq LOOP1; \/\/ dominates\n+    LOOP2:\n+        \/\/ SKIP: prevent loop-exit from becoming zero-trip guard\n+        iload      2;\n+        ifeq SKIP;\n+        iinc       9, 1;\n+    SKIP:\n+        iload      1;\n+        ifeq LOOP1; \/\/ is dominated\n+        goto LOOP2;\n+\n+    LEND:\n+        iload      9;\n+        ireturn;\n+    }\n+    static Method test_irreducible:\"(IIII)V\"\n+    stack 200 locals 200\n+    {\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+    L1:\n+        iload      1;\n+        ifgt MERGE;\n+    L2:\n+        iload      2;\n+        ifge MERGE;\n+        goto L1;\n+\n+    MERGE:\n+        nop;\n+    LOOP:\n+        iload      3;\n+        ifle L2;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+    INFTY:\n+        goto INFTY; \/\/ infinite loop\n+\n+    LEND:\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOnlyInfiniteLoops.jasm","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297642\n+ * @compile TestOnlyInfiniteLoops.jasm\n+ * @summary Nested irreducible loops, where the inner loop floats out of the outer\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestOnlyInfiniteLoops::test*\n+ *      -XX:-TieredCompilation -Xcomp\n+ *      TestOnlyInfiniteLoopsMain\n+ *\n+ * @test\n+ * @bug 8297642\n+ * @compile TestOnlyInfiniteLoops.jasm\n+ * @summary Nested irreducible loops, where the inner loop floats out of the outer\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestOnlyInfiniteLoops::test*\n+ *      -XX:-TieredCompilation -Xcomp\n+ *      -XX:PerMethodTrapLimit=0\n+ *      TestOnlyInfiniteLoopsMain\n+*\/\n+\n+public class TestOnlyInfiniteLoopsMain {\n+    public static void main(String[] args) {\n+        TestOnlyInfiniteLoops t = new TestOnlyInfiniteLoops();\n+        System.out.println(\"test_simple\");\n+        t.test_simple(0, 0, 0);\n+        System.out.println(\"test_irreducible\");\n+        t.test_irreducible(0, 0, 0, 0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOnlyInfiniteLoopsMain.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"}]}