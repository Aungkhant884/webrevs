{"files":[{"patch":"@@ -4716,0 +4716,12 @@\n+void Assembler::evpshufb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x00, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1856,0 +1856,1 @@\n+  void evpshufb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3872,0 +3872,46 @@\n+void C2_MacroAssembler::rearrange_bytes(XMMRegister dst, XMMRegister shuffle, XMMRegister src, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, KRegister ktmp,\n+                                        int vlen_enc) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  \/\/ Byte shuffles are inlane operations and indices are determined using\n+  \/\/ lower 4 bit of each shuffle lane, thus all shuffle indices are\n+  \/\/ normalized to index range 0-15. This makes sure that all the multiples\n+  \/\/ of an index value are placed at same relative position in 128 bit\n+  \/\/ lane i.e. elements corresponding to shuffle indices 16, 32 and 64\n+  \/\/ will be 16th element in their respective 128 bit lanes.\n+  movl(rtmp, 16);\n+  evpbroadcastb(xtmp1, rtmp, vlen_enc);\n+\n+  \/\/ Compute a mask for shuffle vector by comparing indices with expression INDEX < 16,\n+  \/\/ Broadcast first 128 bit lane across entire vector, shuffle the vector lanes using\n+  \/\/ original shuffle indices and move the shuffled lanes corresponding to true\n+  \/\/ mask to destination vector.\n+  evpcmpb(ktmp, k0, shuffle, xtmp1, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp2, src, src, 0x0, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp2, shuffle, false, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 16 && INDEX < 32\n+  \/\/ and broadcasting second 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp1, Assembler::nlt, true, vlen_enc);\n+  vpsllq(xtmp2, xtmp1, 0x1, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle, xtmp2, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0x55, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 32 && INDEX < 48\n+  \/\/ and broadcasting third 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp2, Assembler::nlt, true, vlen_enc);\n+  vpaddb(xtmp1, xtmp1, xtmp2, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle,  xtmp1, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0xAA, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 48 && INDEX < 64\n+  \/\/ and broadcasting third 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp1, Assembler::nlt, true, vlen_enc);\n+  vpsllq(xtmp2, xtmp2, 0x1, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle,  xtmp2, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0xFF, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -277,0 +277,2 @@\n+  void rearrange_bytes(XMMRegister dst, XMMRegister shuffle, XMMRegister src, XMMRegister xtmp1,\n+                       XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, KRegister ktmp, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1791,4 +1791,0 @@\n-      } else if (bt == T_BYTE && size_in_bits > 256 && !VM_Version::supports_avx512_vbmi())  {\n-        return false; \/\/ Implementation limitation\n-      } else if (bt == T_SHORT && size_in_bits > 256 && !VM_Version::supports_avx512bw())  {\n-        return false; \/\/ Implementation limitation\n@@ -7724,1 +7720,17 @@\n-instruct rearrangeB_evex(vec dst, vec src, vec shuffle) %{\n+\n+instruct rearrangeB_evex(vec dst, vec src, vec shuffle, vec xtmp1, vec xtmp2, vec xtmp3, kReg ktmp, rRegI rtmp) %{\n+  predicate(vector_element_basic_type(n) == T_BYTE &&\n+            vector_length(n) > 32 && !VM_Version::supports_avx512_vbmi());\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP ktmp, TEMP rtmp);\n+  format %{ \"vector_rearrange $dst, $shuffle, $src!\\t using $xtmp1, $xtmp2, $xtmp3, $rtmp and $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ rearrange_bytes($dst$$XMMRegister, $shuffle$$XMMRegister, $src$$XMMRegister,\n+                       $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister,\n+                       $rtmp$$Register, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct rearrangeB_evex_vbmi(vec dst, vec src, vec shuffle) %{\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class RearrangeBytesBenchmark {\n+    @Param({\"256\", \"512\", \"1024\"})\n+    int size;\n+\n+    int [][] shuffles;\n+    byte[] byteinp;\n+    byte[] byteres;\n+\n+    static final VectorSpecies<Byte> bspecies64 = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> bspecies128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Byte> bspecies256 = ByteVector.SPECIES_256;\n+    static final VectorSpecies<Byte> bspecies512 = ByteVector.SPECIES_512;\n+\n+    static final byte[] specialvalsbyte = {0, -0, Byte.MIN_VALUE, Byte.MAX_VALUE};\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        int [] bits = {64, 128, 256, 512};\n+        byteinp = new byte[size];\n+        byteres = new byte[size];\n+\n+        for (int i = 4; i < size; i++) {\n+            byteinp[i] = (byte)i;\n+        }\n+        for (int i = 0; i < specialvalsbyte.length; i++) {\n+            byteinp[i] = specialvalsbyte[i];\n+        }\n+\n+        shuffles = new int[4][];\n+        for (int i = 0; i < bits.length; i++) {\n+           int bytes = bits[i] >> 3;\n+           shuffles[i] = new int[bytes];\n+           for (int j = 0; j < bytes ; j++) {\n+              shuffles[i][j] = r.nextInt(bytes - 1);\n+           }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRearrangeBytes64() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspecies512, shuffles[3], 0);\n+        for (int j = 0; j < bspecies512.loopBound(size); j += bspecies512.length()) {\n+            ByteVector.fromArray(bspecies512, byteinp, j)\n+                .rearrange(shuffle)\n+                .intoArray(byteres, j);\n+        }\n+    }\n+    @Benchmark\n+    public void testRearrangeBytes32() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspecies256, shuffles[2], 0);\n+        for (int j = 0; j < bspecies256.loopBound(size); j += bspecies256.length()) {\n+            ByteVector.fromArray(bspecies256, byteinp, j)\n+                .rearrange(shuffle)\n+                .intoArray(byteres, j);\n+        }\n+    }\n+    @Benchmark\n+    public void testRearrangeBytes16() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspecies128, shuffles[1], 0);\n+        for (int j = 0; j < bspecies128.loopBound(size); j += bspecies128.length()) {\n+            ByteVector.fromArray(bspecies128, byteinp, j)\n+                .rearrange(shuffle)\n+                .intoArray(byteres, j);\n+        }\n+    }\n+    @Benchmark\n+    public void testRearrangeBytes8() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspecies64, shuffles[0], 0);\n+        for (int j = 0; j < bspecies64.loopBound(size); j += bspecies64.length()) {\n+            ByteVector.fromArray(bspecies64, byteinp, j)\n+                .rearrange(shuffle)\n+                .intoArray(byteres, j);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/RearrangeBytesBenchmark.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}