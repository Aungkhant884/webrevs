{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,9 @@\n-\/**\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+\/*\n@@ -29,1 +37,3 @@\n- * @run main\/othervm -Xmx100m AwtListGarbageCollectionTest\n+ * @library \/test\/lib\/\n+ * @build jdk.test.lib.util.ForceGC\n+ * @run main\/othervm -Xmx100m -Xlog:gc=debug AwtListGarbageCollectionTest\n@@ -31,0 +41,1 @@\n+public class AwtListGarbageCollectionTest {\n@@ -32,4 +43,1 @@\n-import java.awt.*;\n-import java.awt.event.WindowAdapter;\n-import java.awt.event.WindowEvent;\n-import java.lang.ref.WeakReference;\n+    private static final long ENQUEUE_TIMEOUT = 50;\n@@ -37,2 +45,1 @@\n-public class AwtListGarbageCollectionTest {\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws InterruptedException {\n@@ -48,4 +55,2 @@\n-        WeakReference<List> weakListRef = null;\n-        try {\n-            frame.setSize(300, 200);\n-            frame.setVisible(true);\n+        frame.setSize(300, 200);\n+        frame.setVisible(true);\n@@ -53,6 +58,4 @@\n-            List strongListRef = new List();\n-            frame.add(strongListRef);\n-            strongListRef.setMultipleMode(true);\n-            frame.remove(strongListRef);\n-            weakListRef = new WeakReference<List>(strongListRef);\n-            strongListRef = null;\n+        List strongListRef = new List();\n+        frame.add(strongListRef);\n+        strongListRef.setMultipleMode(true);\n+        frame.remove(strongListRef);\n@@ -60,11 +63,18 @@\n-            \/\/make out of memory to force gc\n-            String veryLongString = new String(new char[100]);\n-            while (true) {\n-                veryLongString += veryLongString;\n-            }\n-        } catch (OutOfMemoryError e) {\n-            if (weakListRef == null) {\n-                throw new RuntimeException(\"Weak list ref wasn't created\");\n-            } else if (weakListRef.get() != null) {\n-                throw new RuntimeException(\"List wasn't garbage collected\");\n-            }\n+        final ReferenceQueue<List> referenceQueue = new ReferenceQueue<>();\n+        final PhantomReference<List> phantomListRef =\n+                new PhantomReference<>(strongListRef, referenceQueue);\n+        System.out.println(\"phantomListRef: \" + phantomListRef);\n+\n+        strongListRef = null; \/\/ Clear the strong reference\n+\n+        System.out.println(\"Waiting for the reference to be cleared\");\n+        if (!ForceGC.wait(() -> phantomListRef == remove(referenceQueue))) {\n+            throw new RuntimeException(\"List wasn't garbage collected\");\n+        }\n+    }\n+\n+    private static Reference<?> remove(ReferenceQueue<?> queue) {\n+        try {\n+            return queue.remove(ENQUEUE_TIMEOUT);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n","filename":"test\/jdk\/java\/awt\/List\/ListGarbageCollectionTest\/AwtListGarbageCollectionTest.java","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import static org.testng.Assert.assertNotNull;\n@@ -35,0 +34,1 @@\n+import static org.testng.Assert.assertFalse;\n@@ -57,1 +57,1 @@\n-        assertNotNull(myOwnClassLoaderWeakReference.get());\n+        assertFalse(myOwnClassLoaderWeakReference.refersTo(null));\n@@ -62,1 +62,1 @@\n-        assertNotNull(myOwnClassLoaderWeakReference.get());\n+        assertFalse(myOwnClassLoaderWeakReference.refersTo(null));\n@@ -64,2 +64,1 @@\n-        ForceGC gc = new ForceGC();\n-        assertTrue(gc.await(() -> myOwnClassLoaderWeakReference.get() == null));\n+        assertTrue(ForceGC.wait(() -> myOwnClassLoaderWeakReference.refersTo(null)));\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/TestOSCClassLoaderLeak.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,0 @@\n-            ForceGC gc = new ForceGC();\n@@ -71,1 +70,1 @@\n-            if (!gc.await(() -> finalCount == unloadedCount)) {\n+            if (!ForceGC.wait(() -> finalCount == unloadedCount)) {\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/nativeLibrary\/NativeLibraryTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,5 +217,3 @@\n-            \/\/ Force garbage collection to trigger unloading of class loader and native library\n-            ForceGC gc = new ForceGC();\n-            assertTrue(gc.await(() -> weakRef.get() == null));\n-\n-            if (weakRef.get() != null) {\n+            \/\/ Force garbage collection to trigger unloading of class loader\n+            \/\/ and native library.\n+            if (!ForceGC.wait(() -> weakRef.refersTo(null))) {\n@@ -227,2 +225,1 @@\n-            ForceGC gc = new ForceGC();\n-            return gc.await(() -> weakRef.get() == null);\n+            return ForceGC.wait(() -> weakRef.refersTo(null));\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/UnloadingTest.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,3 +110,1 @@\n-        new ForceGC().await(() -> weakLoader.get() == null);\n-\n-        if (weakLoader.get() != null) {\n+        if (!ForceGC.wait(() -> weakLoader.refersTo(null))) {\n","filename":"test\/jdk\/java\/lang\/reflect\/callerCache\/ReflectionCallerCacheTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-            ForceGC gc = new ForceGC();\n@@ -94,2 +93,1 @@\n-            gc.await(() -> weakRef[finalI].get() == null);\n-            if (!weakRef[i].refersTo(null)) {\n+            if (!ForceGC.wait(() -> weakRef[finalI].refersTo(null))) {\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,3 +26,3 @@\n-import java.lang.ref.Cleaner;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n@@ -35,22 +35,3 @@\n-    private final CountDownLatch cleanerInvoked = new CountDownLatch(1);\n-    private final Cleaner cleaner = Cleaner.create();\n-    private Object o;\n-\n-    public ForceGC() {\n-        this.o = new Object();\n-        cleaner.register(o, () -> cleanerInvoked.countDown());\n-    }\n-\n-    private void doit(int iter) {\n-        try {\n-            for (int i = 0; i < 10; i++) {\n-                System.gc();\n-                System.out.println(\"doit() iter: \" + iter + \", gc \" + i);\n-                if (cleanerInvoked.await(1L, TimeUnit.SECONDS)) {\n-                    return;\n-                }\n-            }\n-        } catch (InterruptedException unexpected) {\n-            throw new AssertionError(\"unexpected InterruptedException\");\n-        }\n-    }\n+    \/\/ The jtreg testing timeout factor.\n+    private static final double TIMEOUT_FACTOR = Double.valueOf(\n+            System.getProperty(\"test.timeout.factor\", \"1.0\"));\n@@ -59,2 +40,3 @@\n-     * Causes the current thread to wait until the {@code BooleanSupplier} returns true,\n-     * unless the thread is interrupted or a predefined waiting time elapses.\n+     * Causes the current thread to wait until the {@code booleanSupplier}\n+     * returns true, or a specific waiting time elapses.  The waiting time\n+     * is 1 second scaled with the jtreg testing timeout factor.\n@@ -62,4 +44,3 @@\n-     * @param s boolean supplier\n-     * @return true if the {@code BooleanSupplier} returns true and false if\n-     *         the predefined waiting time elapsed before the count reaches zero.\n-     * @throws InterruptedException if the current thread is interrupted while waiting\n+     * @param booleanSupplier boolean supplier\n+     * @return true if the {@code booleanSupplier} returns true, or false\n+     *     if did not complete after the specific waiting time.\n@@ -67,8 +48,24 @@\n-    public boolean await(BooleanSupplier s) {\n-        o = null; \/\/ Keep reference to Object until now, to ensure the Cleaner\n-                  \/\/ doesn't count down the latch before await() is called.\n-        for (int i = 0; i < 10; i++) {\n-            if (s.getAsBoolean()) return true;\n-            doit(i);\n-            try { Thread.sleep(1000); } catch (InterruptedException e) {\n-                throw new AssertionError(\"unexpected interrupted sleep\", e);\n+    public static boolean wait(BooleanSupplier booleanSupplier) {\n+        ReferenceQueue<Object> queue = new ReferenceQueue<>();\n+        Object obj = new Object();\n+        PhantomReference<Object> ref = new PhantomReference<>(obj, queue);\n+        obj = null;\n+        Reference.reachabilityFence(obj);\n+        Reference.reachabilityFence(ref);\n+\n+        int retries = (int)(Math.round(1000L * TIMEOUT_FACTOR) \/ 200);\n+        for (; retries >= 0; retries--) {\n+            if (booleanSupplier.getAsBoolean()) {\n+                return true;\n+            }\n+\n+            System.gc();\n+\n+            try {\n+                \/\/ The remove() will always block for the specified milliseconds\n+                \/\/ if the reference has already been removed from the queue.\n+                \/\/ But it is fine.  For most cases, the 1st GC is sufficient\n+                \/\/ to trigger and complete the cleanup.\n+                queue.remove(200L);\n+            } catch (InterruptedException ie) {\n+                \/\/ ignore, the loop will try again\n@@ -77,1 +74,2 @@\n-        return false;\n+\n+        return booleanSupplier.getAsBoolean();\n@@ -80,0 +78,1 @@\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ForceGC.java","additions":39,"deletions":40,"binary":false,"changes":79,"status":"modified"}]}