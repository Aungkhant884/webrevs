{"files":[{"patch":"@@ -1786,3 +1786,0 @@\n-  \/\/ Ensure class is linked\n-  iklass->link_class(CHECK_NULL);\n-\n@@ -1816,3 +1813,0 @@\n-  \/\/ Ensure class is linked\n-  iklass->link_class(CHECK_NULL);\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  \/\/ Offset (in words) of field from start of instanceOop \/ Klass*\n+  \/\/ Offset (in bytes) of field from start of instanceOop \/ Klass*\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,1 +248,3 @@\n-            assert index < 0 : \"not an invokedynamic constant pool index \" + index;\n+            if (index >= 0) {\n+                throw new IllegalArgumentException(\"not an invokedynamic constant pool index \" + index);\n+            }\n@@ -250,3 +252,13 @@\n-            assert opcode == Bytecodes.GETFIELD || opcode == Bytecodes.PUTFIELD || opcode == Bytecodes.GETSTATIC || opcode == Bytecodes.PUTSTATIC || opcode == Bytecodes.INVOKEINTERFACE ||\n-                            opcode == Bytecodes.INVOKEVIRTUAL || opcode == Bytecodes.INVOKESPECIAL || opcode == Bytecodes.INVOKESTATIC : \"unexpected invoke opcode \" + opcode;\n-            index = rawIndex + config().constantPoolCpCacheIndexTag;\n+            if (opcode == Bytecodes.GETFIELD ||\n+                            opcode == Bytecodes.PUTFIELD ||\n+                            opcode == Bytecodes.GETSTATIC ||\n+                            opcode == Bytecodes.PUTSTATIC ||\n+                            opcode == Bytecodes.INVOKEINTERFACE ||\n+                            opcode == Bytecodes.INVOKEVIRTUAL ||\n+                            opcode == Bytecodes.INVOKESPECIAL ||\n+                            opcode == Bytecodes.INVOKESTATIC) {\n+                index = rawIndex + config().constantPoolCpCacheIndexTag;\n+            } else {\n+                throw new IllegalArgumentException(\"unexpected opcode \" + opcode);\n+\n+            }\n@@ -284,1 +296,3 @@\n-        assert isInvokedynamicIndex(i) : i;\n+        if (!isInvokedynamicIndex(i)) {\n+            throw new IllegalArgumentException(\"not an invokedynamic index: \" + i);\n+        }\n@@ -304,1 +318,1 @@\n-        assert checkBounds(index);\n+        checkBounds(index);\n@@ -321,1 +335,1 @@\n-        assert checkBounds(index);\n+        checkBounds(index);\n@@ -333,1 +347,1 @@\n-        assert checkTag(index, constants.jvmInteger);\n+        checkTag(index, constants.jvmInteger);\n@@ -345,1 +359,1 @@\n-        assert checkTag(index, constants.jvmLong);\n+        checkTag(index, constants.jvmLong);\n@@ -357,1 +371,1 @@\n-        assert checkTag(index, constants.jvmFloat);\n+        checkTag(index, constants.jvmFloat);\n@@ -369,1 +383,1 @@\n-        assert checkTag(index, constants.jvmDouble);\n+        checkTag(index, constants.jvmDouble);\n@@ -381,1 +395,1 @@\n-        assert checkTag(index, constants.jvmNameAndType);\n+        checkTag(index, constants.jvmNameAndType);\n@@ -463,1 +477,1 @@\n-        assert checkTagIsFieldOrMethod(index);\n+        checkTagIsFieldOrMethod(index);\n@@ -474,1 +488,1 @@\n-     * @throws AssertionError if the check fails\n+     * @throws IndexOutOfBoundsException if the check fails\n@@ -476,3 +490,4 @@\n-    private boolean checkBounds(int index) {\n-        assert 0 <= index && index < length() : \"index \" + index + \" not between 0 and \" + length();\n-        return true;\n+    private void checkBounds(int index) {\n+        if (index < 1 || index >= length()) {\n+            throw new IndexOutOfBoundsException(\"index \" + index + \" not between 1 and \" + length());\n+        }\n@@ -486,1 +501,1 @@\n-     * @throws AssertionError if the check fails\n+     * @throws IllegalArgumentException if the check fails\n@@ -488,1 +503,1 @@\n-    private boolean checkTag(int index, JvmConstant tag) {\n+    private void checkTag(int index, JvmConstant tag) {\n@@ -490,2 +505,3 @@\n-        assert tagAt == tag : \"constant pool tag at index \" + index + \" is \" + tagAt + \" but expected \" + tag;\n-        return true;\n+        if (tagAt != tag) {\n+            throw new IllegalArgumentException(\"constant pool tag at index \" + index + \" is \" + tagAt + \" but expected \" + tag);\n+        }\n@@ -500,1 +516,1 @@\n-     * @throws AssertionError if the check fails\n+     * @throws IllegalArgumentException if the check fails\n@@ -502,1 +518,1 @@\n-    private boolean checkTagIsFieldOrMethod(int index) {\n+    private void checkTagIsFieldOrMethod(int index) {\n@@ -504,2 +520,3 @@\n-        assert tagAt == constants.jvmFieldref || tagAt == constants.jvmMethodref || tagAt == constants.jvmInterfaceMethodref : tagAt;\n-        return true;\n+        if (tagAt != constants.jvmFieldref && tagAt != constants.jvmMethodref && tagAt != constants.jvmInterfaceMethodref) {\n+            throw new IllegalArgumentException(\"constant pool tag at index \" + index + \" is \" + tagAt);\n+        }\n@@ -523,1 +540,0 @@\n-        assert cpi != 0;\n@@ -560,1 +576,1 @@\n-        assert checkTag(cpi, constants.jvmUtf8);\n+        checkTag(cpi, constants.jvmUtf8);\n@@ -571,1 +587,4 @@\n-        assert Bytecodes.isInvoke(opcode);\n+        if (!Bytecodes.isInvoke(opcode)) {\n+            throw new IllegalArgumentException(\"expected an invoke bytecode at \" + cpi + \", got \" + opcode);\n+        }\n+\n@@ -705,1 +724,3 @@\n-            assert opcode == Bytecodes.INVOKEDYNAMIC;\n+            if (opcode != Bytecodes.INVOKEDYNAMIC) {\n+                throw new IllegalArgumentException(\"expected INVOKEDYNAMIC at \" + rawIndex + \", got \" + opcode);\n+            }\n@@ -708,1 +729,3 @@\n-            assert opcode != Bytecodes.INVOKEDYNAMIC;\n+            if (opcode == Bytecodes.INVOKEDYNAMIC) {\n+                throw new IllegalArgumentException(\"unexpected INVOKEDYNAMIC at \" + rawIndex);\n+            }\n@@ -781,1 +804,1 @@\n-                        assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);\n+                        checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);\n@@ -833,1 +856,1 @@\n-            assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);\n+            checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,3 @@\n+        if (!method.getDeclaringClass().isLinked()) {\n+            throw new IllegalArgumentException(method.format(\"%H.%n(%p) must be linked\"));\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import static jdk.internal.misc.Unsafe.ADDRESS_SIZE;\n@@ -28,1 +29,0 @@\n-import static jdk.internal.misc.Unsafe.ADDRESS_SIZE;\n@@ -48,1 +48,2 @@\n-     * Value of {@code fieldDescriptor::access_flags()}.\n+     * Offset (in bytes) of field from start of its storage container (i.e. {@code instanceOop} or\n+     * {@code Klass*}).\n@@ -55,1 +56,1 @@\n-    private final short index;\n+    private final int index;\n@@ -62,1 +63,1 @@\n-    HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, long offset, int modifiers, int index) {\n+    HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, int offset, int modifiers, int index) {\n@@ -65,5 +66,2 @@\n-        this.index = (short) index;\n-        assert this.index == index;\n-        assert offset != -1;\n-        assert offset == (int) offset : \"offset larger than int\";\n-        this.offset = (int) offset;\n+        this.index = index;\n+        this.offset = offset;\n@@ -146,0 +144,4 @@\n+    \/**\n+     * Gets the offset (in bytes) of field from start of its storage container (i.e.\n+     * {@code instanceOop} or {@code Klass*}).\n+     *\/\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,1 +261,5 @@\n-        return UNSAFE.getChar(getConstMethod() + config().constMethodCodeSizeOffset);\n+        int codeSize = UNSAFE.getChar(getConstMethod() + config().constMethodCodeSizeOffset);\n+        if (codeSize > 0 && !getDeclaringClass().isLinked()) {\n+            return -1;\n+        }\n+        return codeSize;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-    HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {\n+    HotSpotResolvedJavaField createField(JavaType type, int offset, int rawFlags, int index) {\n@@ -981,0 +981,9 @@\n+        link();\n+        return runtime().compilerToVm.getDeclaredConstructors(this);\n+    }\n+\n+    @Override\n+    public ResolvedJavaMethod[] getDeclaredConstructors(boolean forceLink) {\n+        if (forceLink) {\n+            link();\n+        }\n@@ -986,0 +995,8 @@\n+        return getDeclaredMethods(true);\n+    }\n+\n+    @Override\n+    public ResolvedJavaMethod[] getDeclaredMethods(boolean forceLink) {\n+        if (forceLink) {\n+            link();\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+    \/**\n+     * Returns the offset of the field relative to the base of its storage container (e.g.,\n+     * {@code instanceOop} for an instance field or {@code Klass*} for a static field on HotSpot).\n+     *\/\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaField.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,4 +39,3 @@\n-     * Returns the bytecode of this method, if the method has code. The returned byte array does not\n-     * contain breakpoints or non-Java bytecodes. This may return null if the\n-     * {@linkplain #getDeclaringClass() declaring class} is not\n-     * {@linkplain ResolvedJavaType#isLinked() linked}.\n+     * Returns the method's bytecode. The returned bytecode does not contain breakpoints or non-Java\n+     * bytecodes. This will return {@code null} if {@link #getCodeSize()} returns {@code <= 0} or if\n+     * {@link #hasBytecodes()} returns {@code false}.\n@@ -44,1 +43,1 @@\n-     * The contained constant pool indices may not be the ones found in the original class file but\n+     * The contained constant pool indexes may not be the ones found in the original class file but\n@@ -47,2 +46,2 @@\n-     * @return the bytecode of the method, or {@code null} if {@code getCodeSize() == 0} or if the\n-     *         code is not ready.\n+     * @return {@code null} if {@code getLinkedCodeSize() <= 0} otherwise the bytecode of the method\n+     *         whose length is guaranteed to be {@code > 0}\n@@ -53,2 +52,2 @@\n-     * Returns the size of the bytecode of this method, if the method has code. This is equivalent\n-     * to {@link #getCode()}. {@code length} if the method has code.\n+     * Returns the size of the method's bytecode. If this method returns a value {@code > 0} then\n+     * {@link #getCode()} will not return {@code null}.\n@@ -56,1 +55,4 @@\n-     * @return the size of the bytecode in bytes, or 0 if no bytecode is available\n+     * @return 0 if the method has no bytecode, {@code -1} if the method does have bytecode but its\n+     *         {@linkplain #getDeclaringClass() declaring class} is not\n+     *         {@linkplain ResolvedJavaType#isLinked() linked} otherwise the size of the bytecode in\n+     *         bytes (guaranteed to be {@code > 0})\n@@ -442,6 +444,2 @@\n-     * Checks whether the method has bytecodes associated with it. Note that even if this method\n-     * returns {@code true}, {@link #getCode} can return {@code null} if\n-     * {@linkplain #getDeclaringClass() declaring class} is not\n-     * {@linkplain ResolvedJavaType#isLinked() linked}.\n-     *\n-     * @return {@code this.getCodeSize() != 0}\n+     * @see #getCodeSize()\n+     * @return {@code getCodeSize() > 0}\n@@ -450,1 +448,1 @@\n-        return getCodeSize() != 0;\n+        return getCodeSize() > 0;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -342,0 +342,10 @@\n+    \/**\n+     * Returns an array reflecting all the constructors declared by this type. This method is\n+     * similar to {@link Class#getDeclaredConstructors()} in terms of returned constructors.\n+     *\n+     * @param forceLink if {@code true}, forces this type to be {@link #link linked}\n+     *\/\n+    default ResolvedJavaMethod[] getDeclaredConstructors(boolean forceLink) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n@@ -349,0 +359,10 @@\n+    \/**\n+     * Returns an array reflecting all the methods declared by this type. This method is similar to\n+     * {@link Class#getDeclaredMethods()} in terms of returned methods.\n+     *\n+     * @param forceLink if {@code true}, forces this type to be {@link #link linked}\n+     *\/\n+    default ResolvedJavaMethod[] getDeclaredMethods(boolean forceLink) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.vm.ci.hotspot;\n+\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+\n+public class HotSpotResolvedJavaFieldHelper {\n+    public static ResolvedJavaField createField(HotSpotResolvedObjectTypeImpl holder, JavaType type, int offset, int modifiers, int index) {\n+        return new HotSpotResolvedJavaFieldImpl(holder, type, offset, modifiers, index);\n+    }\n+\n+    public static int getIndex(ResolvedJavaField field) {\n+        return ((HotSpotResolvedJavaFieldImpl) field).getIndex();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldHelper.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.test;\n+\n+import static java.lang.reflect.Modifier.FINAL;\n+import static java.lang.reflect.Modifier.PRIVATE;\n+import static java.lang.reflect.Modifier.PROTECTED;\n+import static java.lang.reflect.Modifier.PUBLIC;\n+import static java.lang.reflect.Modifier.STATIC;\n+import static java.lang.reflect.Modifier.TRANSIENT;\n+import static java.lang.reflect.Modifier.VOLATILE;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n+import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;\n+import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.runtime.JVMCI;\n+\n+\/**\n+ * Tests {@link HotSpotResolvedJavaField} functionality.\n+ *\/\n+public class HotSpotResolvedJavaFieldTest {\n+\n+    private static final Class<?>[] classesWithInternalFields = {Class.class, ClassLoader.class};\n+\n+    private static final Method createFieldMethod;\n+    private static final Field indexField;\n+\n+    static {\n+        Method m = null;\n+        Field f = null;\n+        try {\n+            Class<?> typeImpl = Class.forName(\"jdk.vm.ci.hotspot.HotSpotResolvedObjectTypeImpl\");\n+            m = typeImpl.getDeclaredMethod(\"createField\", JavaType.class, long.class, int.class, int.class);\n+            m.setAccessible(true);\n+            Class<?> fieldImpl = Class.forName(\"jdk.vm.ci.hotspot.HotSpotResolvedJavaFieldImpl\");\n+            f = fieldImpl.getDeclaredField(\"index\");\n+            f.setAccessible(true);\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+\n+        createFieldMethod = m;\n+        indexField = f;\n+    }\n+\n+    \/**\n+     * Same as {@code HotSpotModifiers.jvmFieldModifiers()} but works when using a JVMCI version\n+     * prior to the introduction of that method.\n+     *\/\n+    private int jvmFieldModifiers() {\n+        HotSpotJVMCIRuntime runtime = runtime();\n+        HotSpotVMConfigAccess access = new HotSpotVMConfigAccess(runtime.getConfigStore());\n+        int accEnum = access.getConstant(\"JVM_ACC_ENUM\", Integer.class, 0x4000);\n+        int accSynthetic = access.getConstant(\"JVM_ACC_SYNTHETIC\", Integer.class, 0x1000);\n+        return PUBLIC | PRIVATE | PROTECTED | STATIC | FINAL | VOLATILE | TRANSIENT | accEnum | accSynthetic;\n+    }\n+\n+    HotSpotJVMCIRuntime runtime() {\n+        return (HotSpotJVMCIRuntime) JVMCI.getRuntime();\n+    }\n+\n+    MetaAccessProvider getMetaAccess() {\n+        return runtime().getHostJVMCIBackend().getMetaAccess();\n+    }\n+\n+    \/**\n+     * Tests that {@link HotSpotResolvedJavaField#getModifiers()} only includes the modifiers\n+     * returned by {@link Field#getModifiers()}. Namely, it must not include\n+     * {@code HotSpotResolvedJavaField#FIELD_INTERNAL_FLAG}.\n+     *\/\n+    @Test\n+    public void testModifiersForInternal() {\n+        for (Class<?> c : classesWithInternalFields) {\n+            ResolvedJavaType type = getMetaAccess().lookupJavaType(c);\n+            for (ResolvedJavaField field : type.getInstanceFields(false)) {\n+                if (field.isInternal()) {\n+                    Assert.assertEquals(0, ~jvmFieldModifiers() & field.getModifiers());\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@code HotSpotResolvedObjectTypeImpl#createField(String, JavaType, long, int)}\n+     * always returns an {@linkplain ResolvedJavaField#equals(Object) equivalent} object for an\n+     * internal field.\n+     *\n+     * @throws InvocationTargetException\n+     * @throws IllegalArgumentException\n+     * @throws IllegalAccessException\n+     *\/\n+    @Test\n+    public void testEquivalenceForInternalFields() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+        for (Class<?> c : classesWithInternalFields) {\n+            ResolvedJavaType type = getMetaAccess().lookupJavaType(c);\n+            for (ResolvedJavaField field : type.getInstanceFields(false)) {\n+                if (field.isInternal()) {\n+                    HotSpotResolvedJavaField expected = (HotSpotResolvedJavaField) field;\n+                    int index = indexField.getInt(expected);\n+                    ResolvedJavaField actual = (ResolvedJavaField) createFieldMethod.invoke(type, expected.getType(), expected.getOffset(), expected.getModifiers(), index);\n+                    Assert.assertEquals(expected, actual);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testIsInObject() {\n+        for (Field f : String.class.getDeclaredFields()) {\n+            HotSpotResolvedJavaField rf = (HotSpotResolvedJavaField) getMetaAccess().lookupJavaField(f);\n+            Assert.assertEquals(rf.toString(), rf.isInObject(runtime().getHostJVMCIBackend().getConstantReflection().forString(\"a string\")), !rf.isStatic());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/HotSpotResolvedJavaFieldTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.jvmci\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ * @library \/compiler\/jvmci\/common\/patches\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotResolvedJavaFieldHelper\n+ * @run testng\/othervm\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n+ *      jdk.vm.ci.hotspot.test.TestHotSpotResolvedJavaField\n+ *\/\n+\n+package jdk.vm.ci.hotspot.test;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import jdk.vm.ci.hotspot.HotSpotResolvedJavaFieldHelper;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+\n+public class TestHotSpotResolvedJavaField {\n+\n+    @Test\n+    public void testIndex() {\n+        int max = Character.MAX_VALUE;\n+        int[] valid = {0, 1, max - 1, max};\n+        for (int index : valid) {\n+            ResolvedJavaField field = HotSpotResolvedJavaFieldHelper.createField(null, null, 0, 0, index);\n+            Assert.assertEquals(HotSpotResolvedJavaFieldHelper.getIndex(field), index);\n+        }\n+    }\n+\n+    @Test\n+    public void testOffset() {\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+        int[] valid = {min, min + 1, -2, 0, 1, max - 1, max};\n+        for (int offset : valid) {\n+            ResolvedJavaField field = HotSpotResolvedJavaFieldHelper.createField(null, null, offset, 0, 0);\n+            Assert.assertEquals(field.getOffset(), offset);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotResolvedJavaField.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.lang.reflect.Executable;\n@@ -53,0 +54,1 @@\n+import java.util.ArrayList;\n@@ -56,0 +58,1 @@\n+import java.util.List;\n@@ -81,2 +84,2 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n+        for (ResolvedJavaMethod m : joinValues(methods, constructors)) {\n+            String ms = m.toString();\n@@ -85,1 +88,1 @@\n-                assertTrue(m.getCodeSize() == 0);\n+                assertEquals(ms, m.getCodeSize(), 0);\n@@ -87,5 +90,1 @@\n-                if (m.isAbstract()) {\n-                    assertTrue(code.length == 0);\n-                } else if (!m.isNative()) {\n-                    assertTrue(code.length > 0);\n-                }\n+                assertTrue(ms, code.length > 0);\n@@ -101,2 +100,3 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n+        ResolvedJavaType unlinkedType = metaAccess.lookupJavaType(UnlinkedType.class);\n+        assertTrue(!unlinkedType.isLinked());\n+        for (ResolvedJavaMethod m : addExecutables(joinValues(methods, constructors), unlinkedType, false)) {\n@@ -104,4 +104,7 @@\n-            if (m.isAbstract()) {\n-                assertTrue(codeSize == 0);\n-            } else if (!m.isNative()) {\n-                assertTrue(codeSize > 0);\n+            String ms = m.toString();\n+            if (m.isAbstract() || m.isNative()) {\n+                assertEquals(ms, codeSize, 0);\n+            } else if (!m.getDeclaringClass().isLinked()) {\n+                assertEquals(ms, -1, codeSize);\n+            } else {\n+                assertTrue(ms, codeSize > 0);\n@@ -110,0 +113,1 @@\n+        assertTrue(!unlinkedType.isLinked());\n@@ -114,7 +118,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            int expected = e.getKey().getModifiers();\n-            int actual = m.getModifiers();\n-            assertEquals(String.format(\"%s: 0x%x != 0x%x\", m, expected, actual), expected, actual);\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -133,1 +131,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -138,4 +136,0 @@\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertFalse(m.isClassInitializer());\n-        }\n@@ -158,5 +152,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertEquals(e.getKey().isSynthetic(), m.isSynthetic());\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -182,5 +172,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertEquals(e.getKey().isVarArgs(), m.isVarArgs());\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -194,5 +180,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertEquals(Modifier.isSynchronized(e.getKey().getModifiers()), m.isSynchronized());\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -265,1 +247,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -402,0 +384,6 @@\n+    public static List<ResolvedJavaMethod> addExecutables(List<ResolvedJavaMethod> to, ResolvedJavaType declaringType, boolean forceLink) {\n+        to.addAll(List.of(declaringType.getDeclaredMethods(forceLink)));\n+        to.addAll(List.of(declaringType.getDeclaredConstructors(forceLink)));\n+        return to;\n+    }\n+\n@@ -404,7 +392,6 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertTrue(m.hasBytecodes() == (m.isConcrete() && !m.isNative()));\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertTrue(m.hasBytecodes());\n+        ResolvedJavaType unlinkedType = metaAccess.lookupJavaType(UnlinkedType.class);\n+        assertTrue(!unlinkedType.isLinked());\n+        for (ResolvedJavaMethod m : addExecutables(joinValues(methods, constructors), unlinkedType, false)) {\n+            boolean expect = m.getDeclaringClass().isLinked() && m.isConcrete() && !m.isNative();\n+            boolean actual = m.hasBytecodes();\n+            assertEquals(m.toString(), expect, actual);\n@@ -412,0 +399,1 @@\n+        assertTrue(!unlinkedType.isLinked());\n@@ -433,1 +421,7 @@\n-    static class UnlinkedType {\n+    abstract static class UnlinkedType {\n+        abstract void abstractMethod();\n+\n+        void concreteMethod() {\n+        }\n+\n+        native void nativeMethod();\n@@ -516,0 +510,18 @@\n+\n+    @SafeVarargs\n+    public static <K, V> Map<K, V> join(Map<? extends K, V>... maps) {\n+        Map<K, V> res = new HashMap<>();\n+        for (Map<? extends K, V> e : maps) {\n+            res.putAll(e);\n+        }\n+        return res;\n+    }\n+\n+    @SafeVarargs\n+    public static <V> List<V> joinValues(Map<?, V>... maps) {\n+        List<V> res = new ArrayList<>();\n+        for (Map<?, V> e : maps) {\n+            res.addAll(e.values());\n+        }\n+        return res;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":63,"deletions":51,"binary":false,"changes":114,"status":"modified"}]}