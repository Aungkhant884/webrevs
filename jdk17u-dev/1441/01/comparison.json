{"files":[{"patch":"@@ -1632,1 +1632,1 @@\n-    _gc_tracer_cm->report_object_count_after_gc(&is_alive);\n+    _gc_tracer_cm->report_object_count_after_gc(&is_alive, _g1h->workers());\n@@ -1635,1 +1635,1 @@\n-    _gc_tracer_cm->report_object_count_after_gc(&is_alive);\n+    _gc_tracer_cm->report_object_count_after_gc(&is_alive, _g1h->workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-    scope()->tracer()->report_object_count_after_gc(&_is_alive);\n+    scope()->tracer()->report_object_count_after_gc(&_is_alive, _heap->workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2142,1 +2142,1 @@\n-    _gc_tracer.report_object_count_after_gc(is_alive_closure());\n+    _gc_tracer.report_object_count_after_gc(is_alive_closure(), &ParallelScavengeHeap::heap()->workers());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-    gc_tracer()->report_object_count_after_gc(&is_alive);\n+    gc_tracer()->report_object_count_after_gc(&is_alive, nullptr);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-void GCTracer::report_object_count_after_gc(BoolObjectClosure* is_alive_cl) {\n+void GCTracer::report_object_count_after_gc(BoolObjectClosure* is_alive_cl, WorkGang* workers) {\n@@ -104,1 +104,1 @@\n-      hi.populate_table(&cit, is_alive_cl);\n+      hi.populate_table(&cit, is_alive_cl, workers);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/workgroup.hpp\"\n@@ -104,1 +105,1 @@\n-  void report_object_count_after_gc(BoolObjectClosure* object_filter) NOT_SERVICES_RETURN;\n+  void report_object_count_after_gc(BoolObjectClosure* object_filter, WorkGang* workers) NOT_SERVICES_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,1 +169,10 @@\n-  inspect.heap_inspection(_out, _parallel_thread_num);\n+  WorkGang* workers = Universe::heap()->safepoint_workers();\n+  if (workers != nullptr) {\n+    \/\/ The GC provided a WorkGang to be used during a safepoint.\n+    \/\/ Can't run with more threads than provided by the WorkGang.\n+    const uint capped_parallel_thread_num = MIN2(_parallel_thread_num, workers->total_workers());\n+    WithUpdatedActiveWorkers with_active_workers(workers, capped_parallel_thread_num);\n+    inspect.heap_inspection(_out, workers);\n+  } else {\n+    inspect.heap_inspection(_out, nullptr);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -574,2 +574,1 @@\n-uintx HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter, uint parallel_thread_num) {\n-\n+uintx HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter, WorkGang* workers) {\n@@ -577,1 +576,1 @@\n-  if (parallel_thread_num > 1) {\n+  if (workers != nullptr) {\n@@ -579,15 +578,6 @@\n-\n-    WorkGang* gang = Universe::heap()->safepoint_workers();\n-    if (gang != NULL) {\n-      \/\/ The GC provided a WorkGang to be used during a safepoint.\n-\n-      \/\/ Can't run with more threads than provided by the WorkGang.\n-      WithUpdatedActiveWorkers update_and_restore(gang, parallel_thread_num);\n-\n-      ParallelObjectIterator poi(gang->active_workers());\n-      ParHeapInspectTask task(&poi, cit, filter);\n-      \/\/ Run task with the active workers.\n-      gang->run_task(&task);\n-      if (task.success()) {\n-        return task.missed_count();\n-      }\n+    ParallelObjectIterator poi(workers->active_workers());\n+    ParHeapInspectTask task(&poi, cit, filter);\n+    \/\/ Run task with the active workers.\n+    workers->run_task(&task);\n+    if (task.success()) {\n+      return task.missed_count();\n@@ -604,1 +594,1 @@\n-void HeapInspection::heap_inspection(outputStream* st, uint parallel_thread_num) {\n+void HeapInspection::heap_inspection(outputStream* st, WorkGang* workers) {\n@@ -610,1 +600,1 @@\n-    uintx missed_count = populate_table(&cit, NULL, parallel_thread_num);\n+    uintx missed_count = populate_table(&cit, NULL, workers);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -219,2 +219,2 @@\n-  void heap_inspection(outputStream* st, uint parallel_thread_num = 1) NOT_SERVICES_RETURN;\n-  uintx populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL, uint parallel_thread_num = 1) NOT_SERVICES_RETURN_(0);\n+  void heap_inspection(outputStream* st, WorkGang* workers) NOT_SERVICES_RETURN;\n+  uintx populate_table(KlassInfoTable* cit, BoolObjectClosure* filter, WorkGang* workers) NOT_SERVICES_RETURN_(0);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}