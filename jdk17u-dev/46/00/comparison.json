{"files":[{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.imageio.ImageIO;\n+import javax.swing.JEditorPane;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.text.AbstractDocument;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Position;\n+import javax.swing.text.View;\n+import javax.swing.text.html.HTMLEditorKit;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/*\n+ * @test\n+ * @bug 6364882 8273634\n+ * @summary tests if broken and last lines in paragraph are not justified\n+ * @run main bug6364882\n+ *\/\n+public class bug6364882 {\n+    private static final String TEXT =\n+            \"<html><body><p style=\\\"text-align: justify\\\">\"\n+            + \"should be justified should be justified should be justified \"\n+            + \"should be justified should be justified should be justified \"\n+            + \"should be justified should be justified should be justified \"\n+            + \"should be justified should be justified should be justified \"\n+            + \"should be justified should be justified should be justified \"\n+            + \"should be justified should be justified should be justified \"\n+            + \"<br>\"\n+            + \"should not be justified <br>\"\n+            + \"should not be justified\"\n+            + \"<\/body><\/html>\";\n+\n+    private static final int WIDTH = 580;\n+    private static final int HEIGHT = 600;\n+\n+    public static final String IMAGE_FILENAME = \"editorPane.png\";\n+\n+    private static JEditorPane editorPane;\n+\n+    private static volatile List<Error> errors;\n+\n+    public static void main(String[] args) throws Exception {\n+        List<String> argList = Arrays.asList(args);\n+        \/\/ Show frame for visual inspection\n+        final boolean showFrame = argList.contains(\"-show\");\n+        \/\/ Save the rendered image even if the test passes\n+        \/\/ If the test fails, the image is always saved\n+        final boolean saveImage = argList.contains(\"-save\");\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            createUI(showFrame);\n+\n+            BufferedImage image = paintToImage();\n+            errors = checkJustification();\n+\n+            if (errors.size() > 0 || saveImage) {\n+                saveImage(image);\n+                dumpViews();\n+            }\n+        });\n+\n+        if (errors != null && errors.size() > 0) {\n+            String message = \"Test failed: \" + errors.size() + \" error(s)\";\n+            System.err.println(message);\n+            for (Error e : errors) {\n+                e.printStackTrace();\n+            }\n+            throw new RuntimeException(message + \" - \" + errors.get(0).getMessage());\n+        }\n+\n+        System.out.println(\"Test passed\");\n+    }\n+\n+    private static void createUI(boolean showFrame) {\n+        editorPane = new JEditorPane();\n+        editorPane.setEditorKit(new HTMLEditorKit());\n+        ((AbstractDocument) editorPane.getDocument()).setAsynchronousLoadPriority(-1);\n+        editorPane.setText(TEXT);\n+\n+        editorPane.setSize(WIDTH, HEIGHT);\n+\n+        if (showFrame) {\n+            JFrame frame = new JFrame(\"bug6364882\");\n+            frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+\n+            frame.getContentPane().add(editorPane);\n+\n+            frame.setSize(WIDTH, HEIGHT);\n+            frame.setLocationRelativeTo(null);\n+            frame.setVisible(true);\n+        }\n+    }\n+\n+    private static List<Error> checkJustification() {\n+        final List<Error> errors = new ArrayList<>(15);\n+        try {\n+            final View rootView = editorPane.getUI().getRootView(editorPane);\n+            final View blockView = rootView.getView(0);\n+            assert blockView.getViewCount() == 2\n+                   : \"blockView doesn't have 2 child views\";\n+            final View bodyView = blockView.getView(1);\n+            final View paragraphView = bodyView.getView(0);\n+            \/\/ Expected to have 6 rows in the paragraph\n+            assert paragraphView.getViewCount() == 6\n+                   : \"paragraph doesn't have 6 rows of text\";\n+\n+            final Rectangle bounds = editorPane.getBounds();\n+\n+            \/\/ Three rows should be justified\n+            final int oneX = getEndOfLineX(paragraphView.getView(0), bounds);\n+            if (oneX < bounds.width - 15) {\n+                errors.add(new Error(\"Text is not justified at line \" + 0 + \": \"\n+                                     + oneX + \" < \" + (bounds.width - 15)));\n+            }\n+            for (int i = 1; i < 2; i++) {\n+                int lineX = getEndOfLineX(paragraphView.getView(i),\n+                                          bounds);\n+                if (oneX != lineX) {\n+                    errors.add(new Error(\"Text is not justified at line \" + i\n+                                         + \": \" + oneX + \" != \" + lineX));\n+                }\n+            }\n+\n+            \/\/ Fourth row should not be justified\n+            final int fourX = getEndOfLineX(paragraphView.getView(3), bounds);\n+            if (oneX == fourX) {\n+                errors.add(new Error(\"Fourth line is justified: \"\n+                                     + oneX + \" vs \" + fourX));\n+            }\n+            if (fourX > (bounds.width - bounds.width \/ 4)) {\n+                errors.add(new Error(\"Fourth line is justified: \"\n+                                     + fourX + \" > \"\n+                                     + (bounds.width - bounds.width \/ 4)));\n+            }\n+\n+            \/\/ Fifth and sixth lines should not be justified\n+            final int fiveX = getEndOfLineX(paragraphView.getView(4), bounds);\n+            if (oneX == fiveX) {\n+                errors.add(new Error(\"Fifth line is justified: \"\n+                                     + oneX + \"==\" + fiveX));\n+            }\n+            if (fiveX > bounds.width \/ 2) {\n+                errors.add(new Error(\"Fifth line is justified: \"\n+                                     + fiveX + \" > \" + (bounds.width \/ 2)));\n+            }\n+            if (fiveX > fourX) {\n+                errors.add(new Error(\"Fifth line is justified: \"\n+                                     + fiveX + \" > \" + fourX));\n+            }\n+            final int sixX = getEndOfLineX(paragraphView.getView(5), bounds);\n+            if (fiveX != sixX) {\n+                errors.add(new Error(\"Fifth and sixth lines aren't of  the \"\n+                                     + \"same width: \" + fiveX + \" != \" + sixX));\n+            }\n+\n+            return errors;\n+        } catch (BadLocationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static int getEndOfLineX(final View rowView,\n+                                     final Rectangle bounds)\n+            throws BadLocationException {\n+        final View inlineView = rowView.getView(0);\n+        Shape loc = inlineView.modelToView(inlineView.getEndOffset() - 1,\n+                                           bounds,\n+                                           Position.Bias.Backward);\n+        return loc instanceof Rectangle\n+               ? ((Rectangle) loc).x\n+               : loc.getBounds().x;\n+    }\n+\n+    private static BufferedImage paintToImage() {\n+        Dimension bounds = editorPane.getSize();\n+        BufferedImage im = new BufferedImage(bounds.width, bounds.height,\n+                                             TYPE_INT_RGB);\n+        Graphics g = im.getGraphics();\n+        editorPane.paint(g);\n+        g.dispose();\n+        return im;\n+    }\n+\n+    private static void saveImage(BufferedImage image) {\n+        try {\n+            ImageIO.write(image, \"png\", new File(IMAGE_FILENAME));\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void dumpViews() {\n+        final View view = editorPane.getUI().getRootView(editorPane);\n+        dumpViews(view, \"\");\n+    }\n+\n+    private static void dumpViews(final View view, final String indent) {\n+        System.out.println(indent + view.getClass().getName() + \": \"\n+                           + view.getStartOffset() + \", \" + view.getEndOffset()\n+                           + \"; span: \" + view.getPreferredSpan(View.X_AXIS));\n+        final String nestedIndent = indent + \"    \";\n+        for (int i = 0; i < view.getViewCount(); i++) {\n+            dumpViews(view.getView(i), nestedIndent);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/ParagraphView\/6364882\/bug6364882.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"}]}