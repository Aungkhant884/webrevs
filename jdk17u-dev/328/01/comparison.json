{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"services\/memTracker.hpp\"\n@@ -420,0 +421,6 @@\n+\n+  \/\/ With NMT enabled, this will trigger JDK-8263464. For now disable the test if NMT=on.\n+  if (MemTracker::tracking_level() > NMT_off) {\n+    return;\n+  }\n+\n@@ -421,2 +428,20 @@\n-  const size_t stripe_len = 4 * M;\n-  const int num_stripes = 4;\n+  \/\/ What we do:\n+  \/\/ A) we reserve 6 small segments (stripes) adjacent to each other. We commit\n+  \/\/    them with alternating permissions to prevent the kernel from folding them into\n+  \/\/    a single segment.\n+  \/\/    -stripe-stripe-stripe-stripe-stripe-stripe-\n+  \/\/ B) we release the middle four stripes with a single os::release_memory call. This\n+  \/\/    tests that os::release_memory indeed works across multiple segments created with\n+  \/\/    multiple os::reserve calls.\n+  \/\/    -stripe-___________________________-stripe-\n+  \/\/ C) Into the now vacated address range between the first and the last stripe, we\n+  \/\/    re-reserve a new memory range. We expect this to work as a proof that the address\n+  \/\/    range was really released by the single release call (B).\n+  \/\/\n+  \/\/ Note that this is inherently racy. Between (B) and (C), some other thread may have\n+  \/\/  reserved something into the hole in the meantime. Therefore we keep that range small and\n+  \/\/  entrenched between the first and last stripe, which reduces the chance of some concurrent\n+  \/\/  thread grabbing that memory.\n+\n+  const size_t stripe_len = os::vm_allocation_granularity();\n+  const int num_stripes = 6;\n@@ -430,1 +455,3 @@\n-  \/\/ .. release it...\n+  \/\/ .. release the middle stripes...\n+  address p_middle_stripes = p + stripe_len;\n+  const size_t middle_stripe_len = (num_stripes - 2) * stripe_len;\n@@ -432,3 +459,2 @@\n-    \/\/ On Windows, use UseNUMAInterleaving=1 which makes\n-    \/\/  os::release_memory accept multi-map-ranges.\n-    \/\/  Otherwise we would assert (see below for death test).\n+    \/\/ On Windows, temporarily switch on UseNUMAInterleaving to allow release_memory to release\n+    \/\/  multiple mappings in one go (otherwise we assert, which we test too, see death test below).\n@@ -436,1 +462,1 @@\n-    ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+    ASSERT_TRUE(os::release_memory((char*)p_middle_stripes, middle_stripe_len));\n@@ -440,3 +466,3 @@\n-  \/\/ re-reserve it. This should work unless release failed.\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)p, total_range_len);\n-  ASSERT_EQ(p2, p);\n+  \/\/ ...re-reserve the middle stripes. This should work unless release silently failed.\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, middle_stripe_len);\n+  ASSERT_EQ(p2, p_middle_stripes);\n@@ -445,1 +471,5 @@\n-  ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  \/\/ Clean up. Release all mappings.\n+  {\n+    WINDOWS_ONLY(NUMASwitcher b(true);) \/\/ allow release_memory to release multiple regions\n+    ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  }\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":41,"deletions":11,"binary":false,"changes":52,"status":"modified"}]}