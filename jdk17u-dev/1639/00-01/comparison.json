{"files":[{"patch":"@@ -28,3 +28,3 @@\n- * @library \/test\/lib\n- * @requires os.family == \"linux\"\n- * @run main\/othervm\/timeout=120 -Djdk.net.usePlainSocketImpl B8312065\n+ * @requires (os.family != \"windows\")\n+ * @compile NativeThread.java\n+ * @run main\/othervm\/native\/timeout=120 -Djdk.net.usePlainSocketImpl B8312065\n@@ -33,5 +33,0 @@\n-import jdk.jfr.Configuration;\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.jfr.consumer.RecordedThread;\n-import jdk.jfr.consumer.RecordingFile;\n@@ -40,2 +35,0 @@\n-import java.io.Closeable;\n-import java.io.IOException;\n@@ -45,3 +38,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.ParseException;\n@@ -49,1 +39,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -52,6 +41,0 @@\n-    private static volatile boolean success = false;\n-    private static Recording recording = null;\n-    private static volatile boolean isSendSignal = true;\n-    private static volatile boolean signalReceived = false;\n-    private static final boolean debug = true;\n-\n@@ -59,36 +42,1 @@\n-        \/\/ If the thread executing java.net.PlainSocketImpl.socketConnect receives continuous signals,\n-        \/\/ the thread will be blocked for a long time (about 2 minutes).\n-        \/\/ To test in the sub-thread, the main thread can detect the execution time of the sub-thread to avoid the\n-        \/\/ test duration being too long.\n-        Thread t = new Thread(() -> {\n-            try {\n-                task();\n-            } catch (Exception e) {\n-                error(e.getMessage(), e);\n-            }\n-        });\n-        t.setDaemon(true);\n-        t.start();\n-\n-        int timeoutSeconds = 10;\n-        t.join(timeoutSeconds * 1000);\n-        if (t.isAlive()) {\n-            throw new RuntimeException(\"Test Failed: \" + timeoutSeconds +\n-                    \" seconds have passed and it has not timed out\");\n-        }\n-\n-        if (!success) {\n-            throw new RuntimeException(\"Test Failed\");\n-        }\n-    }\n-\n-    private static void task() throws IOException, ParseException, InterruptedException {\n-        Thread.currentThread().setName(\"B8312065\");\n-\n-        \/\/ Find OS thread ID of the current thread\n-        long osThreadId = getOSThreadId();\n-        if (osThreadId == 0) {\n-            throw new RuntimeException(\"Failed to get operating system thread id\");\n-        }\n-\n-        Thread t = startSendingSignalToThread(osThreadId);\n+        System.loadLibrary(\"NativeThread\");\n@@ -96,5 +44,2 @@\n-        test();\n-\n-        isSendSignal = false;\n-        t.join();\n-    }\n+        \/\/ Setup SIGPIPE handler\n+        Signal.handle(new Signal(\"PIPE\"), System.out::println);\n@@ -102,5 +47,1 @@\n-    private static Thread startSendingSignalToThread(long osThreadId) throws InterruptedException {\n-        \/\/ Setup SIGPROF handler\n-        Signal.handle(new Signal(\"PROF\"), (signal) -> {\n-            signalReceived = true;\n-        });\n+        long osThreadId = NativeThread.getID();\n@@ -110,1 +51,0 @@\n-        \/\/ Send SIGPROF to the thread every second\n@@ -112,3 +52,8 @@\n-            while (isSendSignal) {\n-                try {\n-                    Runtime.getRuntime().exec(\"kill -SIGPROF \" + osThreadId).waitFor();\n+            latch.countDown();\n+            try {\n+                \/\/ Send SIGPIPE to the thread every second\n+                for (int i = 0; i < 10; i++) {\n+                    if (NativeThread.signal(osThreadId, NativeThread.SIGPIPE) != 0) {\n+                        System.out.println(\"Failed to send signal\");\n+                        System.exit(1);\n+                    }\n@@ -116,4 +61,0 @@\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                } finally {\n-                    latch.countDown();\n@@ -121,0 +62,5 @@\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            } finally {\n+                System.out.println(\"Test FAILED\");\n+                System.exit(1);\n@@ -127,32 +73,0 @@\n-        if (!signalReceived) {\n-            throw new RuntimeException(\"failed to send signal\");\n-        }\n-        return t;\n-    }\n-\n-    static void test() {\n-        Socket socket = null;\n-        long startMillis = millisTime();\n-        int timeoutMillis = 2000;\n-        try {\n-            socket = new Socket();\n-            connectWithTimeout(socket, timeoutMillis);\n-            error(\"connected successfully!\");\n-        } catch (SocketTimeoutException socketTimeout) {\n-            long duration = millisTime() - startMillis;\n-            long min = timeoutMillis - 100;\n-            long max = timeoutMillis + 2000;\n-            if (duration < min) {\n-                error(\"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n-            } else if (duration > max) {\n-                error(\"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n-            } else {\n-                debug(\"Passed: Received: \" + socketTimeout + \", duration \" + duration + \" millis\");\n-                passed();\n-            }\n-        } catch (Exception exception) {\n-            error(\"Connect timeout test failed\", exception);\n-        } finally {\n-            close(socket);\n-        }\n-    }\n@@ -160,56 +74,0 @@\n-    static void connectWithTimeout(Socket socket, int timeout) throws IOException {\n-        \/\/ There is no good way to mock SocketTimeoutException, just assume 192.168.255.255 is not in use.\n-        socket.connect(new InetSocketAddress(\"192.168.255.255\", 8080), timeout);\n-    }\n-\n-    \/**\n-     * Returns the current time in milliseconds.\n-     *\/\n-    private static long millisTime() {\n-        long now = System.nanoTime();\n-        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n-    }\n-\n-    \/**\n-     * The JFR event records the OS thread ID, which is a reliable way.\n-     * Another way is use \/proc\/thread-self, but unfortunately, it's not supported until linux 3.17\n-     * @return Operating System Thread id\n-     * @throws IOException\n-     * @throws ParseException\n-     *\/\n-    private static long getOSThreadId() throws IOException, ParseException {\n-        startJFR();\n-\n-        sleep(); \/\/ trigger jdk.ThreadSleep Event\n-\n-        Path jfrPath = null;\n-        try {\n-            jfrPath = Files.createTempFile(\"B8312065\", \".jfr\");\n-            recording.dump(jfrPath);\n-            RecordingFile file = new RecordingFile(jfrPath);\n-            while (file.hasMoreEvents()) {\n-                RecordedEvent event = file.readEvent();\n-                if (\"jdk.ThreadSleep\".equals(event.getEventType().getName())) {\n-                    RecordedThread thread = event.getThread();\n-                    if (thread.getJavaName().equals(\"B8312065\")) {\n-                        return thread.getOSThreadId();\n-                    }\n-                }\n-            }\n-        } finally {\n-            if (jfrPath != null) {\n-                jfrPath.toFile().delete();\n-            }\n-            recording.stop();\n-        }\n-\n-        return 0L;\n-    }\n-\n-    private static void startJFR() throws IOException, ParseException {\n-        Configuration recordingConfig = Configuration.getConfiguration(\"default\");\n-        recording = new Recording(recordingConfig);\n-        recording.start();\n-    }\n-\n-    private static void sleep() {\n@@ -217,9 +75,5 @@\n-            Thread.sleep(1000);\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    static void debug(String message) {\n-        if (debug) {\n-            System.out.println(message);\n+            Socket socket = new Socket();\n+            \/\/ There is no good way to mock SocketTimeoutException, just assume 192.168.255.255 is not in use.\n+            socket.connect(new InetSocketAddress(\"192.168.255.255\", 8080), 2000);\n+        } catch (SocketTimeoutException e) {\n+            System.out.println(\"Test passed\");\n@@ -228,22 +82,1 @@\n-\n-    static void unexpected(Exception e ) {\n-        System.out.println(\"Unexpected Exception: \" + e);\n-    }\n-\n-    static void close(Closeable closeable) {\n-        if (closeable != null) try { closeable.close(); } catch (IOException e) {unexpected(e);}\n-    }\n-\n-    static void error(String message) {\n-        System.out.println(message);\n-    }\n-\n-    static void error(String message, Exception e) {\n-        System.out.println(message);\n-        e.printStackTrace();\n-    }\n-\n-    static void passed() {\n-        success = true;\n-    }\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/B8312065.java","additions":26,"deletions":193,"binary":false,"changes":219,"status":"modified"}]}