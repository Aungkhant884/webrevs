{"files":[{"patch":"@@ -492,1 +492,11 @@\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n+    int ret;\n+    threadEntry_t self;\n+    fdEntry_t *fdEntry = getFdEntry(ufds[0].fd);\n+    if (fdEntry == NULL) {\n+        errno = EBADF;\n+        return -1;\n+    }\n+    startOp(fdEntry, &self);\n+    ret = poll(ufds, nfds, timeout);\n+    endOp(fdEntry, &self);\n+    return ret;\n","filename":"src\/java.base\/aix\/native\/libnet\/aix_close.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -399,1 +399,11 @@\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n+    int ret;\n+    threadEntry_t self;\n+    fdEntry_t *fdEntry = getFdEntry(ufds[0].fd);\n+    if (fdEntry == NULL) {\n+        errno = EBADF;\n+        return -1;\n+    }\n+    startOp(fdEntry, &self);\n+    ret = poll(ufds, nfds, timeout);\n+    endOp(fdEntry, &self);\n+    return ret;\n","filename":"src\/java.base\/linux\/native\/libnet\/linux_close.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -403,1 +403,11 @@\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n+    int ret;\n+    threadEntry_t self;\n+    fdEntry_t *fdEntry = getFdEntry(ufds[0].fd);\n+    if (fdEntry == NULL) {\n+        errno = EBADF;\n+        return -1;\n+    }\n+    startOp(fdEntry, &self);\n+    ret = poll(ufds, nfds, timeout);\n+    endOp(fdEntry, &self);\n+    return ret;\n","filename":"src\/java.base\/macosx\/native\/libnet\/bsd_close.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8312065\n+ * @summary Socket.connect does not timeout as expected when profiling (i.e. keep receiving signal)\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @run main\/othervm\/timeout=120 -Djdk.net.usePlainSocketImpl B8312065\n+ *\/\n+\n+import jdk.jfr.Configuration;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+import sun.misc.Signal;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class B8312065 {\n+    private static volatile boolean success = false;\n+    private static Recording recording = null;\n+    private static volatile boolean isSendSignal = true;\n+    private static volatile boolean signalReceived = false;\n+    private static final boolean debug = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ If the thread executing java.net.PlainSocketImpl.socketConnect receives continuous signals,\n+        \/\/ the thread will be blocked for a long time (about 2 minutes).\n+        \/\/ To test in the sub-thread, the main thread can detect the execution time of the sub-thread to avoid the\n+        \/\/ test duration being too long.\n+        Thread t = new Thread(() -> {\n+            try {\n+                task();\n+            } catch (Exception e) {\n+                error(e.getMessage(), e);\n+            }\n+        });\n+        t.setDaemon(true);\n+        t.start();\n+\n+        int timeoutSeconds = 10;\n+        t.join(timeoutSeconds * 1000);\n+        if (t.isAlive()) {\n+            throw new RuntimeException(\"Test Failed: \" + timeoutSeconds +\n+                    \" seconds have passed and it has not timed out\");\n+        }\n+\n+        if (!success) {\n+            throw new RuntimeException(\"Test Failed\");\n+        }\n+    }\n+\n+    private static void task() throws IOException, ParseException, InterruptedException {\n+        Thread.currentThread().setName(\"B8312065\");\n+\n+        \/\/ Find OS thread ID of the current thread\n+        long osThreadId = getOSThreadId();\n+        if (osThreadId == 0) {\n+            throw new RuntimeException(\"Failed to get operating system thread id\");\n+        }\n+\n+        Thread t = startSendingSignalToThread(osThreadId);\n+\n+        test();\n+\n+        isSendSignal = false;\n+        t.join();\n+    }\n+\n+    private static Thread startSendingSignalToThread(long osThreadId) throws InterruptedException {\n+        \/\/ Setup SIGPROF handler\n+        Signal.handle(new Signal(\"PROF\"), (signal) -> {\n+            signalReceived = true;\n+        });\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+\n+        \/\/ Send SIGPROF to the thread every second\n+        Thread t = new Thread(() -> {\n+            while (isSendSignal) {\n+                try {\n+                    Runtime.getRuntime().exec(\"kill -SIGPROF \" + osThreadId).waitFor();\n+                    Thread.sleep(1000);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                } finally {\n+                    latch.countDown();\n+                }\n+            }\n+        });\n+        t.setDaemon(true);\n+        t.start();\n+\n+        latch.await();\n+        if (!signalReceived) {\n+            throw new RuntimeException(\"failed to send signal\");\n+        }\n+        return t;\n+    }\n+\n+    static void test() {\n+        Socket socket = null;\n+        long startMillis = millisTime();\n+        int timeoutMillis = 2000;\n+        try {\n+            socket = new Socket();\n+            connectWithTimeout(socket, timeoutMillis);\n+            error(\"connected successfully!\");\n+        } catch (SocketTimeoutException socketTimeout) {\n+            long duration = millisTime() - startMillis;\n+            long min = timeoutMillis - 100;\n+            long max = timeoutMillis + 2000;\n+            if (duration < min) {\n+                error(\"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+            } else if (duration > max) {\n+                error(\"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+            } else {\n+                debug(\"Passed: Received: \" + socketTimeout + \", duration \" + duration + \" millis\");\n+                passed();\n+            }\n+        } catch (Exception exception) {\n+            error(\"Connect timeout test failed\", exception);\n+        } finally {\n+            close(socket);\n+        }\n+    }\n+\n+    static void connectWithTimeout(Socket socket, int timeout) throws IOException {\n+        \/\/ There is no good way to mock SocketTimeoutException, just assume 192.168.255.255 is not in use.\n+        socket.connect(new InetSocketAddress(\"192.168.255.255\", 8080), timeout);\n+    }\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private static long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * The JFR event records the OS thread ID, which is a reliable way.\n+     * Another way is use \/proc\/thread-self, but unfortunately, it's not supported until linux 3.17\n+     * @return Operating System Thread id\n+     * @throws IOException\n+     * @throws ParseException\n+     *\/\n+    private static long getOSThreadId() throws IOException, ParseException {\n+        startJFR();\n+\n+        sleep(); \/\/ trigger jdk.ThreadSleep Event\n+\n+        Path jfrPath = null;\n+        try {\n+            jfrPath = Files.createTempFile(\"B8312065\", \".jfr\");\n+            recording.dump(jfrPath);\n+            RecordingFile file = new RecordingFile(jfrPath);\n+            while (file.hasMoreEvents()) {\n+                RecordedEvent event = file.readEvent();\n+                if (\"jdk.ThreadSleep\".equals(event.getEventType().getName())) {\n+                    RecordedThread thread = event.getThread();\n+                    if (thread.getJavaName().equals(\"B8312065\")) {\n+                        return thread.getOSThreadId();\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (jfrPath != null) {\n+                jfrPath.toFile().delete();\n+            }\n+            recording.stop();\n+        }\n+\n+        return 0L;\n+    }\n+\n+    private static void startJFR() throws IOException, ParseException {\n+        Configuration recordingConfig = Configuration.getConfiguration(\"default\");\n+        recording = new Recording(recordingConfig);\n+        recording.start();\n+    }\n+\n+    private static void sleep() {\n+        try {\n+            Thread.sleep(1000);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    static void debug(String message) {\n+        if (debug) {\n+            System.out.println(message);\n+        }\n+    }\n+\n+    static void unexpected(Exception e ) {\n+        System.out.println(\"Unexpected Exception: \" + e);\n+    }\n+\n+    static void close(Closeable closeable) {\n+        if (closeable != null) try { closeable.close(); } catch (IOException e) {unexpected(e);}\n+    }\n+\n+    static void error(String message) {\n+        System.out.println(message);\n+    }\n+\n+    static void error(String message, Exception e) {\n+        System.out.println(message);\n+        e.printStackTrace();\n+    }\n+\n+    static void passed() {\n+        success = true;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/net\/Socket\/B8312065.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"}]}