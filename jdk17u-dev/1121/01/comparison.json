{"files":[{"patch":"@@ -230,5 +230,5 @@\n-static const juint starttime_offset = sizeof(jlong);\n-static const juint duration_offset = starttime_offset + sizeof(jlong);\n-static const juint checkpoint_type_offset = duration_offset + sizeof(jlong);\n-static const juint types_offset = checkpoint_type_offset + sizeof(juint);\n-static const juint payload_offset = types_offset + sizeof(juint);\n+static const size_t starttime_offset = sizeof(int64_t);\n+static const size_t duration_offset = starttime_offset + sizeof(int64_t);\n+static const size_t checkpoint_type_offset = duration_offset + sizeof(int64_t);\n+static const size_t types_offset = checkpoint_type_offset + sizeof(uint32_t);\n+static const size_t payload_offset = types_offset + sizeof(uint32_t);\n@@ -241,2 +241,4 @@\n-static jlong total_size(const u1* data) {\n-  return read_data<jlong>(data);\n+static size_t total_size(const u1* data) {\n+  const int64_t size = read_data<int64_t>(data);\n+  assert(size > 0, \"invariant\");\n+  return static_cast<size_t>(size);\n@@ -245,2 +247,2 @@\n-static jlong starttime(const u1* data) {\n-  return read_data<jlong>(data + starttime_offset);\n+static int64_t starttime(const u1* data) {\n+  return read_data<int64_t>(data + starttime_offset);\n@@ -249,2 +251,2 @@\n-static jlong duration(const u1* data) {\n-  return read_data<jlong>(data + duration_offset);\n+static int64_t duration(const u1* data) {\n+  return read_data<int64_t>(data + duration_offset);\n@@ -253,2 +255,2 @@\n-static u1 checkpoint_type(const u1* data) {\n-  return read_data<u1>(data + checkpoint_type_offset);\n+static uint8_t checkpoint_type(const u1* data) {\n+  return read_data<uint8_t>(data + checkpoint_type_offset);\n@@ -257,2 +259,2 @@\n-static juint number_of_types(const u1* data) {\n-  return read_data<juint>(data + types_offset);\n+static uint32_t number_of_types(const u1* data) {\n+  return read_data<uint32_t>(data + types_offset);\n@@ -261,8 +263,2 @@\n-static void write_checkpoint_header(JfrChunkWriter& cw, int64_t delta_to_last_checkpoint, const u1* data) {\n-  cw.reserve(sizeof(u4));\n-  cw.write<u8>(EVENT_CHECKPOINT);\n-  cw.write(starttime(data));\n-  cw.write(duration(data));\n-  cw.write(delta_to_last_checkpoint);\n-  cw.write(checkpoint_type(data));\n-  cw.write(number_of_types(data));\n+static size_t payload_size(const u1* data) {\n+  return total_size(data) - sizeof(JfrCheckpointEntry);\n@@ -271,3 +267,10 @@\n-static void write_checkpoint_content(JfrChunkWriter& cw, const u1* data, size_t size) {\n-  assert(data != NULL, \"invariant\");\n-  cw.write_unbuffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));\n+static uint64_t calculate_event_size_bytes(JfrChunkWriter& cw, const u1* data, int64_t event_begin, int64_t delta_to_last_checkpoint) {\n+  assert(data != nullptr, \"invariant\");\n+  size_t bytes = cw.size_in_bytes(EVENT_CHECKPOINT);\n+  bytes += cw.size_in_bytes(starttime(data));\n+  bytes += cw.size_in_bytes(duration(data));\n+  bytes += cw.size_in_bytes(delta_to_last_checkpoint);\n+  bytes += cw.size_in_bytes(checkpoint_type(data));\n+  bytes += cw.size_in_bytes(number_of_types(data));\n+  bytes += payload_size(data); \/\/ in bytes already.\n+  return bytes + cw.size_in_bytes(bytes + cw.size_in_bytes(bytes));\n@@ -280,6 +283,0 @@\n-  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n-  const int64_t checkpoint_size = total_size(data);\n-  write_checkpoint_header(cw, delta_to_last_checkpoint, data);\n-  write_checkpoint_content(cw, data, checkpoint_size);\n-  const int64_t event_size = cw.current_offset() - event_begin;\n-  cw.write_padded_at_offset<u4>(event_size, event_begin);\n@@ -287,1 +284,12 @@\n-  return (size_t)checkpoint_size;\n+  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n+  const uint64_t event_size = calculate_event_size_bytes(cw, data, event_begin, delta_to_last_checkpoint);\n+  cw.write(event_size);\n+  cw.write(EVENT_CHECKPOINT);\n+  cw.write(starttime(data));\n+  cw.write(duration(data));\n+  cw.write(delta_to_last_checkpoint);\n+  cw.write(checkpoint_type(data));\n+  cw.write(number_of_types(data));\n+  cw.write_unbuffered(data + payload_offset, payload_size(data));\n+  assert(static_cast<uint64_t>(cw.current_offset() - event_begin) == event_size, \"invariant\");\n+  return total_size(data);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -132,0 +135,11 @@\n+template <typename T>\n+inline size_t BigEndianEncoderImpl::size_in_bytes(T value) {\n+  switch (sizeof(T)) {\n+    case 1: return 1;\n+    case 2: return 2;\n+    case 4: return 4;\n+    case 8:return 8;\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n@@ -163,0 +177,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -298,0 +315,30 @@\n+template <typename T>\n+inline size_t Varint128EncoderImpl::size_in_bytes(T value) {\n+  const u8 v = to_u8(value);\n+  if (LESS_THAN_128(v)) {\n+    return 1;\n+  }\n+  if (LESS_THAN_128(v >> 7)) {\n+    return 2;\n+  }\n+  if (LESS_THAN_128(v >> 14)) {\n+    return 3;\n+  }\n+  if (LESS_THAN_128(v >> 21)) {\n+    return 4;\n+  }\n+  if (LESS_THAN_128(v >> 28)) {\n+    return 5;\n+  }\n+  if (LESS_THAN_128(v >> 35)) {\n+    return 6;\n+  }\n+  if (LESS_THAN_128(v >> 42)) {\n+    return 7;\n+  }\n+  if (LESS_THAN_128(v >> 49)) {\n+    return 8;\n+  }\n+  return 9;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoders.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -72,0 +72,5 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value) {\n+    return IntegerEncoder::size_in_bytes(value);\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoding.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+  template <typename T>\n+  size_t size_in_bytes(T value);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -361,0 +361,6 @@\n+template <typename BE, typename IE, typename WriterPolicyImpl>\n+template <typename T>\n+inline size_t WriterHost<BE, IE, WriterPolicyImpl>::size_in_bytes(T value) {\n+  return IE::size_in_bytes(value);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-            int size = input.readInt();\n+            long size = input.readLong();\n@@ -308,1 +308,1 @@\n-            int size = input.readInt(); \/\/ size\n+            long size = input.readLong(); \/\/ size\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    private int payLoadSize;\n+    private long payLoadSize;\n@@ -225,1 +225,1 @@\n-            index += payLoadSize;\n+            index = index + (int)payLoadSize;\n@@ -261,1 +261,1 @@\n-        long v = (b & 0x7FL);\n+        long v = (b & 0x7F);\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}