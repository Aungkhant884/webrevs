{"files":[{"patch":"@@ -248,2 +248,1 @@\n-      \/\/ alias_idx correct??\n-      pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx);\n+      pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx, false, MemNode::unordered, LoadNode::Pinned);\n@@ -615,1 +614,0 @@\n-  Node* load = CardTableBarrierSetC2::load_at_resolved(access, val_type);\n@@ -627,1 +625,1 @@\n-    return load;\n+    return CardTableBarrierSetC2::load_at_resolved(access, val_type);\n@@ -631,0 +629,1 @@\n+\n@@ -633,0 +632,13 @@\n+  Node* load;\n+\n+  Node* control =  kit->control();\n+  const TypePtr* adr_type = access.addr().type();\n+  MemNode::MemOrd mo = access.mem_node_mo();\n+  bool requires_atomic_access = (decorators & MO_UNORDERED) == 0;\n+  bool unaligned = (decorators & C2_UNALIGNED) != 0;\n+  bool unsafe = (decorators & C2_UNSAFE_ACCESS) != 0;\n+  \/\/ Pinned control dependency is the strictest. So it's ok to substitute it for any other.\n+  load = kit->make_load(control, adr, val_type, access.type(), adr_type, mo,\n+      LoadNode::Pinned, requires_atomic_access, unaligned, mismatched, unsafe,\n+      access.barrier_data());\n+\n@@ -784,0 +796,129 @@\n+bool G1BarrierSetC2::has_cas_in_use_chain(Node *n) const {\n+  Unique_Node_List visited;\n+  Node_List worklist;\n+  worklist.push(n);\n+  while (worklist.size() > 0) {\n+    Node* x = worklist.pop();\n+    if (visited.member(x)) {\n+      continue;\n+    } else {\n+      visited.push(x);\n+    }\n+\n+    if (x->is_LoadStore()) {\n+      int op = x->Opcode();\n+      if (op == Op_CompareAndExchangeP || op == Op_CompareAndExchangeN ||\n+          op == Op_CompareAndSwapP     || op == Op_CompareAndSwapN     ||\n+          op == Op_WeakCompareAndSwapP || op == Op_WeakCompareAndSwapN) {\n+        return true;\n+      }\n+    }\n+    if (!x->is_CFG()) {\n+      for (SimpleDUIterator iter(x); iter.has_next(); iter.next()) {\n+        Node* use = iter.get();\n+        worklist.push(use);\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+void G1BarrierSetC2::verify_pre_load(Node* marking_if, Unique_Node_List& loads \/*output*\/) const {\n+  assert(loads.size() == 0, \"Loads list should be empty\");\n+  Node* pre_val_if = marking_if->find_out_with(Op_IfTrue)->find_out_with(Op_If);\n+  if (pre_val_if != NULL) {\n+    Unique_Node_List visited;\n+    Node_List worklist;\n+    Node* pre_val = pre_val_if->in(1)->in(1)->in(1);\n+\n+    worklist.push(pre_val);\n+    while (worklist.size() > 0) {\n+      Node* x = worklist.pop();\n+      if (visited.member(x)) {\n+        continue;\n+      } else {\n+        visited.push(x);\n+      }\n+\n+      if (has_cas_in_use_chain(x)) {\n+        loads.clear();\n+        return;\n+      }\n+\n+      if (x->is_Con()) {\n+        continue;\n+      }\n+      if (x->is_EncodeP() || x->is_DecodeN()) {\n+        worklist.push(x->in(1));\n+        continue;\n+      }\n+      if (x->is_Load() || x->is_LoadStore()) {\n+        assert(x->in(0) != NULL, \"Pre-val load has to have a control\");\n+        loads.push(x);\n+        continue;\n+      }\n+      if (x->is_Phi()) {\n+        for (uint i = 1; i < x->req(); i++) {\n+          worklist.push(x->in(i));\n+        }\n+        continue;\n+      }\n+      assert(false, \"Pre-val anomaly\");\n+    }\n+  }\n+}\n+\n+void G1BarrierSetC2::verify_no_safepoints(Compile* compile, Node* marking_check_if, const Unique_Node_List& loads) const {\n+  if (loads.size() == 0) {\n+    return;\n+  }\n+\n+  if (loads.size() == 1) { \/\/ Handle the typical situation when there a single pre-value load\n+                           \/\/ that is dominated by the marking_check_if, that's true when the\n+                           \/\/ barrier itself does the pre-val load.\n+    Node *pre_val = loads.at(0);\n+    if (pre_val->in(0)->in(0) == marking_check_if) { \/\/ IfTrue->If\n+      return;\n+    }\n+  }\n+\n+  \/\/ All other cases are when pre-value loads dominate the marking check.\n+  Unique_Node_List controls;\n+  for (uint i = 0; i < loads.size(); i++) {\n+    Node *c = loads.at(i)->in(0);\n+    controls.push(c);\n+  }\n+\n+  Unique_Node_List visited;\n+  Unique_Node_List safepoints;\n+  Node_List worklist;\n+  uint found = 0;\n+\n+  worklist.push(marking_check_if);\n+  while (worklist.size() > 0 && found < controls.size()) {\n+    Node* x = worklist.pop();\n+    if (x == NULL || x == compile->top()) continue;\n+    if (visited.member(x)) {\n+      continue;\n+    } else {\n+      visited.push(x);\n+    }\n+\n+    if (controls.member(x)) {\n+      found++;\n+    }\n+    if (x->is_Region()) {\n+      for (uint i = 1; i < x->req(); i++) {\n+        worklist.push(x->in(i));\n+      }\n+    } else {\n+      if (!x->is_SafePoint()) {\n+        worklist.push(x->in(0));\n+      } else {\n+        safepoints.push(x);\n+      }\n+    }\n+  }\n+  assert(found == controls.size(), \"Pre-barrier structure anomaly or possible safepoint\");\n+}\n+\n@@ -838,0 +979,4 @@\n+\n+              Unique_Node_List loads;\n+              verify_pre_load(iff, loads);\n+              verify_no_safepoints(compile, iff, loads);\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":149,"deletions":4,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -87,1 +87,7 @@\n- public:\n+#ifdef ASSERT\n+  bool has_cas_in_use_chain(Node* x) const;\n+  void verify_pre_load(Node* marking_check_if, Unique_Node_List& loads \/*output*\/) const;\n+  void verify_no_safepoints(Compile* compile, Node* marking_load, const Unique_Node_List& loads) const;\n+#endif\n+\n+public:\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -355,1 +355,2 @@\n-                     MemNode::MemOrd mo) {\n+                     MemNode::MemOrd mo,\n+                     LoadNode::ControlDependency control_dependency) {\n@@ -361,1 +362,1 @@\n-  Node* ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, LoadNode::DependsOnlyOnTest, require_atomic_access);\n+  Node* ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, require_atomic_access);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -223,1 +223,3 @@\n-             bool require_atomic_access = false, MemNode::MemOrd mo = MemNode::unordered);\n+             bool require_atomic_access = false,\n+             MemNode::MemOrd mo = MemNode::unordered,\n+             LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -826,1 +826,1 @@\n-  return true;\n+  return !has_pinned_control_dependency();\n@@ -844,1 +844,11 @@\n-    st->print(\" (does not depend only on test)\");\n+    st->print(\" (does not depend only on test, \");\n+    if (control_dependency() == UnknownControl) {\n+      st->print(\"unknown control\");\n+    } else if (control_dependency() == Pinned) {\n+      st->print(\"pinned\");\n+    } else if (adr_type() == TypeRawPtr::BOTTOM) {\n+      st->print(\"raw access\");\n+    } else {\n+      st->print(\"unknown reason\");\n+    }\n+    st->print(\")\");\n@@ -1189,0 +1199,3 @@\n+  if (has_pinned_control_dependency()) {\n+    return this;\n+  }\n@@ -1686,0 +1699,3 @@\n+  if (has_pinned_control_dependency()) {\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -289,1 +289,3 @@\n-  bool has_unknown_control_dependency() const { return _control_dependency == UnknownControl; }\n+  ControlDependency control_dependency() const { return _control_dependency; }\n+  bool has_unknown_control_dependency() const  { return _control_dependency == UnknownControl; }\n+  bool has_pinned_control_dependency() const   { return _control_dependency == Pinned; }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}