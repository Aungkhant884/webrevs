{"files":[{"patch":"@@ -3287,1 +3287,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);    \\\n+    __ addw(rscratch4, rscratch4, rscratch1);    \\\n@@ -3293,1 +3293,2 @@\n-    __ eorw(rscratch2, r2, r3);                  \\\n+    __ andw(rscratch3, r2, r4);                  \\\n+    __ bicw(rscratch4, r3, r4);                  \\\n@@ -3295,2 +3296,1 @@\n-    __ andw(rscratch3, rscratch2, r4);           \\\n-    __ eorw(rscratch3, rscratch3, r3);           \\\n+    __ orrw(rscratch3, rscratch3, rscratch4);    \\\n@@ -3299,1 +3299,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);    \\\n+    __ addw(rscratch4, rscratch4, rscratch1);    \\\n@@ -3310,1 +3310,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);    \\\n+    __ addw(rscratch4, rscratch4, rscratch1);    \\\n@@ -3321,1 +3321,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);    \\\n+    __ addw(rscratch4, rscratch4, rscratch1);    \\\n@@ -4024,40 +4024,0 @@\n-  \/\/ Safefetch stubs.\n-  void generate_safefetch(const char* name, int size, address* entry,\n-                          address* fault_pc, address* continuation_pc) {\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue);\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);\n-    \/\/\n-    \/\/ arguments:\n-    \/\/   c_rarg0 = adr\n-    \/\/   c_rarg1 = errValue\n-    \/\/\n-    \/\/ result:\n-    \/\/   PPC_RET  = *adr or errValue\n-\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ Entry point, pc or function descriptor.\n-    *entry = __ pc();\n-\n-    \/\/ Load *adr into c_rarg1, may fault.\n-    *fault_pc = __ pc();\n-    switch (size) {\n-      case 4:\n-        \/\/ int32_t\n-        __ ldrw(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      case 8:\n-        \/\/ int64_t\n-        __ ldr(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ return errValue or *adr\n-    *continuation_pc = __ pc();\n-    __ mov(r0, c_rarg1);\n-    __ ret(lr);\n-  }\n-\n@@ -5004,0 +4964,1 @@\n+  \/\/ Clobbers: v0-v7 when UseSIMDForArrayEquals, rscratch1, rscratch2\n@@ -5450,0 +5411,2 @@\n+  \/\/ Clobbers: rscratch1, rscratch2, v0, v1, rflags\n+  \/\/\n@@ -5764,0 +5727,1 @@\n+  \/\/ Clobbers: r0, r1, r3, rscratch1, rflags, v0-v6\n@@ -7581,8 +7545,0 @@\n-\n-    \/\/ Safefetch stubs.\n-    generate_safefetch(\"SafeFetch32\", sizeof(int),     &StubRoutines::_safefetch32_entry,\n-                                                       &StubRoutines::_safefetch32_fault_pc,\n-                                                       &StubRoutines::_safefetch32_continuation_pc);\n-    generate_safefetch(\"SafeFetchN\", sizeof(intptr_t), &StubRoutines::_safefetchN_entry,\n-                                                       &StubRoutines::_safefetchN_fault_pc,\n-                                                       &StubRoutines::_safefetchN_continuation_pc);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":11,"deletions":55,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -221,0 +221,11 @@\n+void Assembler::set_attributes(InstructionAttr* attributes) {\n+  \/\/ Record the assembler in the attributes, so the attributes destructor can\n+  \/\/ clear the assembler's attributes, cleaning up the otherwise dangling\n+  \/\/ pointer.  gcc13 has a false positive warning, because it doesn't tie that\n+  \/\/ cleanup to the assignment of _attributes here.\n+  attributes->set_current_assembler(this);\n+  PRAGMA_DIAG_PUSH\n+  PRAGMA_DANGLING_POINTER_IGNORED\n+  _attributes = attributes;\n+  PRAGMA_DIAG_POP\n+}\n@@ -8992,1 +9003,0 @@\n-  attributes->set_current_assembler(this);\n@@ -9039,1 +9049,0 @@\n-  attributes->set_current_assembler(this);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -681,1 +681,2 @@\n-  class InstructionAttr *_attributes;\n+  InstructionAttr *_attributes;\n+  void set_attributes(InstructionAttr* attributes);\n@@ -899,2 +900,0 @@\n-\n-  void set_attributes(InstructionAttr *attributes) { _attributes = attributes; }\n@@ -2598,1 +2597,0 @@\n-    _current_assembler = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3832,40 +3832,0 @@\n-  \/\/ Safefetch stubs.\n-  void generate_safefetch(const char* name, int size, address* entry,\n-                          address* fault_pc, address* continuation_pc) {\n-    \/\/ safefetch signatures:\n-    \/\/   int      SafeFetch32(int*      adr, int      errValue);\n-    \/\/   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);\n-    \/\/\n-    \/\/ arguments:\n-    \/\/   c_rarg0 = adr\n-    \/\/   c_rarg1 = errValue\n-    \/\/\n-    \/\/ result:\n-    \/\/   PPC_RET  = *adr or errValue\n-\n-    StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-    \/\/ Entry point, pc or function descriptor.\n-    *entry = __ pc();\n-\n-    \/\/ Load *adr into c_rarg1, may fault.\n-    *fault_pc = __ pc();\n-    switch (size) {\n-      case 4:\n-        \/\/ int32_t\n-        __ movl(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      case 8:\n-        \/\/ int64_t\n-        __ movq(c_rarg1, Address(c_rarg0, 0));\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ return errValue or *adr\n-    *continuation_pc = __ pc();\n-    __ movq(rax, c_rarg1);\n-    __ ret(0);\n-  }\n-\n@@ -6509,0 +6469,2 @@\n+      Label L_continue;\n+\n@@ -6512,0 +6474,5 @@\n+        Label L_doSmall;\n+\n+        __ cmpl(len, 384);\n+        __ jcc(Assembler::lessEqual, L_doSmall);\n+\n@@ -6514,1 +6481,5 @@\n-      } else {\n+\n+        __ jmp(L_continue);\n+\n+        __ bind(L_doSmall);\n+      }\n@@ -6516,2 +6487,2 @@\n-        __ push(y);\n-        __ push(z);\n+      __ push(y);\n+      __ push(z);\n@@ -6519,5 +6490,5 @@\n-        __ crc32c_ipl_alg2_alt2(crc, buf, len,\n-                                a, j, k,\n-                                l, y, z,\n-                                c_farg0, c_farg1, c_farg2,\n-                                is_pclmulqdq_supported);\n+      __ crc32c_ipl_alg2_alt2(crc, buf, len,\n+                              a, j, k,\n+                              l, y, z,\n+                              c_farg0, c_farg1, c_farg2,\n+                              is_pclmulqdq_supported);\n@@ -6525,2 +6496,2 @@\n-        __ pop(z);\n-        __ pop(y);\n+      __ pop(z);\n+      __ pop(y);\n@@ -6528,1 +6499,2 @@\n-      }\n+\n+      __ bind(L_continue);\n@@ -7572,8 +7544,0 @@\n-\n-    \/\/ Safefetch stubs.\n-    generate_safefetch(\"SafeFetch32\", sizeof(int),     &StubRoutines::_safefetch32_entry,\n-                                                       &StubRoutines::_safefetch32_fault_pc,\n-                                                       &StubRoutines::_safefetch32_continuation_pc);\n-    generate_safefetch(\"SafeFetchN\", sizeof(intptr_t), &StubRoutines::_safefetchN_entry,\n-                                                       &StubRoutines::_safefetchN_fault_pc,\n-                                                       &StubRoutines::_safefetchN_continuation_pc);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":23,"deletions":59,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-\/\/ EXPERIMENTAL flags are in support of features that are not\n-\/\/    part of the officially supported product, but are available\n+\/\/ EXPERIMENTAL flags are in support of features that may not be\n+\/\/    an officially supported part of a product, but may be available\n@@ -78,0 +78,2 @@\n+\/\/    Refer to the documentation of any products using this code for details\n+\/\/    on support and fitness for production.\n@@ -83,2 +85,1 @@\n-\/\/    and they are not supported on production loads, except under explicit\n-\/\/    direction from support engineers.\n+\/\/    Refer to the documentation of any products using this code for details.\n@@ -919,4 +920,0 @@\n-                                                                            \\\n-  notproduct(bool, CheckMemoryInitialization, false,                        \\\n-          \"Check memory initialization\")                                    \\\n-                                                                            \\\n@@ -1382,0 +1379,4 @@\n+  product(int, ErrorLogPrintCodeLimit, 3, DIAGNOSTIC,                       \\\n+          \"max number of compiled code units to print in error log\")        \\\n+          range(0, VMError::max_error_log_print_code)                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"}]}