{"files":[{"patch":"@@ -357,1 +357,1 @@\n-  } else if (Arguments::is_interpreter_only()) {\n+  } else if (CompilerConfig::is_interpreter_only()) {\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,1 +319,0 @@\n-\n@@ -526,0 +525,4 @@\n+    if (SegmentedCodeCache) {\n+      warning(\"SegmentedCodeCache has no meaningful effect with -Xint\");\n+      FLAG_SET_DEFAULT(SegmentedCodeCache, false);\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+    private static final String[] XINT_EXPECTED_MESSAGE = new String[] {\n+            \"SegmentedCodeCache has no meaningful effect with -Xint\"\n+    };\n@@ -89,1 +92,1 @@\n-                        + \"without any errors.\";\n+                        + \"but it produces a warning that it is ignored.\";\n@@ -92,1 +95,2 @@\n-                        \/* expected messages *\/ null, UNEXPECTED_MESSAGES,\n+                        XINT_EXPECTED_MESSAGE,\n+                        \/* unexpected messages *\/ null,\n@@ -120,8 +124,0 @@\n-                \/\/ SCC could be explicitly enabled w\/ Xint\n-                errorMessage = String.format(\"It should be possible to \"\n-                                + \"explicitly enable %s in interpreted mode.\",\n-                        SEGMENTED_CODE_CACHE);\n-\n-                CommandLineOptionTest.verifyOptionValue(SEGMENTED_CODE_CACHE,\n-                        \"true\", errorMessage, false, INT_MODE,\n-                        USE_SEGMENTED_CODE_CACHE);\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/TestSegmentedCodeCacheOption.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,3 +66,0 @@\n-                new CodeCacheCLITestCase(CodeCacheCLITestCase\n-                        .CommonDescriptions.INT_MODE.description,\n-                        GENERIC_RUNNER),\n@@ -72,3 +69,0 @@\n-                new CodeCacheCLITestCase(CodeCacheCLITestCase\n-                        .CommonDescriptions.TIERED_LEVEL_0.description,\n-                        GENERIC_RUNNER),\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/TestCodeHeapSizeOptions.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-         * only NonNMethod code heap.\n+         * the whole code cache. Int mode disables SegmentedCodeCache with a warning.\n@@ -71,1 +71,1 @@\n-        INT_MODE(ONLY_SEGMENTED, EnumSet.of(BlobType.NonNMethod), USE_INT_MODE),\n+        INT_MODE(ONLY_SEGMENTED, EnumSet.of(BlobType.All), USE_INT_MODE),\n@@ -90,1 +90,1 @@\n-         * contain information about non-nmethods and non-profiled nmethods\n+         * warn about SegmentedCodeCache and contain information about all\n@@ -94,1 +94,1 @@\n-                EnumSet.of(BlobType.NonNMethod, BlobType.MethodNonProfiled),\n+                EnumSet.of(BlobType.All),\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheCLITestCase.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}