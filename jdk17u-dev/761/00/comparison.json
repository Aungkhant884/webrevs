{"files":[{"patch":"@@ -1778,0 +1778,4 @@\n+    if (n->is_SafePoint()) {\n+      \/\/ Keep track of SafePoint nodes for PhaseCCP::transform()\n+      _safepoints.push(n);\n+    }\n@@ -1894,0 +1898,17 @@\n+\n+  \/\/ This CCP pass may prove that no exit test for a loop ever succeeds (i.e. the loop is infinite). In that case,\n+  \/\/ the logic below doesn't follow any path from Root to the loop body: there's at least one such path but it's proven\n+  \/\/ never taken (its type is TOP). As a consequence the node on the exit path that's input to Root (let's call it n) is\n+  \/\/ replaced by the top node and the inputs of that node n are not enqueued for further processing. If CCP only works\n+  \/\/ through the graph from Root, this causes the loop body to never be processed here even when it's not dead (that\n+  \/\/ is reachable from Root following its uses). To prevent that issue, transform() starts walking the graph from Root\n+  \/\/ and all safepoints.\n+  for (uint i = 0; i < _safepoints.size(); ++i) {\n+    Node* nn = _safepoints.at(i);\n+    Node* new_node = _nodes[nn->_idx];\n+    assert(new_node == NULL, \"\");\n+    new_node = transform_once(nn);\n+    _nodes.map(nn->_idx, new_node);\n+    trstack.push(new_node);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -568,0 +568,1 @@\n+  Unique_Node_List _safepoints;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}