{"files":[{"patch":"@@ -65,1 +65,1 @@\n-  \/\/ Offset (in words) of field from start of instanceOop \/ Klass*\n+  \/\/ Offset (in bytes) of field from start of instanceOop \/ Klass*\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,1 +248,3 @@\n-            assert index < 0 : \"not an invokedynamic constant pool index \" + index;\n+            if (index >= 0) {\n+                throw new IllegalArgumentException(\"not an invokedynamic constant pool index \" + index);\n+            }\n@@ -250,3 +252,13 @@\n-            assert opcode == Bytecodes.GETFIELD || opcode == Bytecodes.PUTFIELD || opcode == Bytecodes.GETSTATIC || opcode == Bytecodes.PUTSTATIC || opcode == Bytecodes.INVOKEINTERFACE ||\n-                            opcode == Bytecodes.INVOKEVIRTUAL || opcode == Bytecodes.INVOKESPECIAL || opcode == Bytecodes.INVOKESTATIC : \"unexpected invoke opcode \" + opcode;\n-            index = rawIndex + config().constantPoolCpCacheIndexTag;\n+            if (opcode == Bytecodes.GETFIELD ||\n+                            opcode == Bytecodes.PUTFIELD ||\n+                            opcode == Bytecodes.GETSTATIC ||\n+                            opcode == Bytecodes.PUTSTATIC ||\n+                            opcode == Bytecodes.INVOKEINTERFACE ||\n+                            opcode == Bytecodes.INVOKEVIRTUAL ||\n+                            opcode == Bytecodes.INVOKESPECIAL ||\n+                            opcode == Bytecodes.INVOKESTATIC) {\n+                index = rawIndex + config().constantPoolCpCacheIndexTag;\n+            } else {\n+                throw new IllegalArgumentException(\"unexpected opcode \" + opcode);\n+\n+            }\n@@ -284,1 +296,3 @@\n-        assert isInvokedynamicIndex(i) : i;\n+        if (!isInvokedynamicIndex(i)) {\n+            throw new IllegalArgumentException(\"not an invokedynamic index: \" + i);\n+        }\n@@ -304,1 +318,1 @@\n-        assert checkBounds(index);\n+        checkBounds(index);\n@@ -321,1 +335,1 @@\n-        assert checkBounds(index);\n+        checkBounds(index);\n@@ -333,1 +347,1 @@\n-        assert checkTag(index, constants.jvmInteger);\n+        checkTag(index, constants.jvmInteger);\n@@ -345,1 +359,1 @@\n-        assert checkTag(index, constants.jvmLong);\n+        checkTag(index, constants.jvmLong);\n@@ -357,1 +371,1 @@\n-        assert checkTag(index, constants.jvmFloat);\n+        checkTag(index, constants.jvmFloat);\n@@ -369,1 +383,1 @@\n-        assert checkTag(index, constants.jvmDouble);\n+        checkTag(index, constants.jvmDouble);\n@@ -381,1 +395,1 @@\n-        assert checkTag(index, constants.jvmNameAndType);\n+        checkTag(index, constants.jvmNameAndType);\n@@ -463,1 +477,1 @@\n-        assert checkTagIsFieldOrMethod(index);\n+        checkTagIsFieldOrMethod(index);\n@@ -474,1 +488,1 @@\n-     * @throws AssertionError if the check fails\n+     * @throws IndexOutOfBoundsException if the check fails\n@@ -476,3 +490,4 @@\n-    private boolean checkBounds(int index) {\n-        assert 0 <= index && index < length() : \"index \" + index + \" not between 0 and \" + length();\n-        return true;\n+    private void checkBounds(int index) {\n+        if (index < 1 || index >= length()) {\n+            throw new IndexOutOfBoundsException(\"index \" + index + \" not between 1 and \" + length());\n+        }\n@@ -486,1 +501,1 @@\n-     * @throws AssertionError if the check fails\n+     * @throws IllegalArgumentException if the check fails\n@@ -488,1 +503,1 @@\n-    private boolean checkTag(int index, JvmConstant tag) {\n+    private void checkTag(int index, JvmConstant tag) {\n@@ -490,2 +505,3 @@\n-        assert tagAt == tag : \"constant pool tag at index \" + index + \" is \" + tagAt + \" but expected \" + tag;\n-        return true;\n+        if (tagAt != tag) {\n+            throw new IllegalArgumentException(\"constant pool tag at index \" + index + \" is \" + tagAt + \" but expected \" + tag);\n+        }\n@@ -500,1 +516,1 @@\n-     * @throws AssertionError if the check fails\n+     * @throws IllegalArgumentException if the check fails\n@@ -502,1 +518,1 @@\n-    private boolean checkTagIsFieldOrMethod(int index) {\n+    private void checkTagIsFieldOrMethod(int index) {\n@@ -504,2 +520,3 @@\n-        assert tagAt == constants.jvmFieldref || tagAt == constants.jvmMethodref || tagAt == constants.jvmInterfaceMethodref : tagAt;\n-        return true;\n+        if (tagAt != constants.jvmFieldref && tagAt != constants.jvmMethodref && tagAt != constants.jvmInterfaceMethodref) {\n+            throw new IllegalArgumentException(\"constant pool tag at index \" + index + \" is \" + tagAt);\n+        }\n@@ -523,1 +540,0 @@\n-        assert cpi != 0;\n@@ -560,1 +576,1 @@\n-        assert checkTag(cpi, constants.jvmUtf8);\n+        checkTag(cpi, constants.jvmUtf8);\n@@ -571,1 +587,4 @@\n-        assert Bytecodes.isInvoke(opcode);\n+        if (!Bytecodes.isInvoke(opcode)) {\n+            throw new IllegalArgumentException(\"expected an invoke bytecode at \" + cpi + \", got \" + opcode);\n+        }\n+\n@@ -705,1 +724,3 @@\n-            assert opcode == Bytecodes.INVOKEDYNAMIC;\n+            if (opcode != Bytecodes.INVOKEDYNAMIC) {\n+                throw new IllegalArgumentException(\"expected INVOKEDYNAMIC at \" + rawIndex + \", got \" + opcode);\n+            }\n@@ -708,1 +729,3 @@\n-            assert opcode != Bytecodes.INVOKEDYNAMIC;\n+            if (opcode == Bytecodes.INVOKEDYNAMIC) {\n+                throw new IllegalArgumentException(\"unexpected INVOKEDYNAMIC at \" + rawIndex);\n+            }\n@@ -781,1 +804,1 @@\n-                        assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);\n+                        checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);\n@@ -833,1 +856,1 @@\n-            assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);\n+            checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import static jdk.internal.misc.Unsafe.ADDRESS_SIZE;\n@@ -28,1 +29,0 @@\n-import static jdk.internal.misc.Unsafe.ADDRESS_SIZE;\n@@ -48,1 +48,2 @@\n-     * Value of {@code fieldDescriptor::access_flags()}.\n+     * Offset (in bytes) of field from start of its storage container (i.e. {@code instanceOop} or\n+     * {@code Klass*}).\n@@ -55,1 +56,1 @@\n-    private final short index;\n+    private final int index;\n@@ -62,1 +63,1 @@\n-    HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, long offset, int modifiers, int index) {\n+    HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, int offset, int modifiers, int index) {\n@@ -65,5 +66,2 @@\n-        this.index = (short) index;\n-        assert this.index == index;\n-        assert offset != -1;\n-        assert offset == (int) offset : \"offset larger than int\";\n-        this.offset = (int) offset;\n+        this.index = index;\n+        this.offset = offset;\n@@ -146,0 +144,4 @@\n+    \/**\n+     * Gets the offset (in bytes) of field from start of its storage container (i.e.\n+     * {@code instanceOop} or {@code Klass*}).\n+     *\/\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-    HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {\n+    HotSpotResolvedJavaField createField(JavaType type, int offset, int rawFlags, int index) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+    \/**\n+     * Returns the offset of the field relative to the base of its storage container (e.g.,\n+     * {@code instanceOop} for an instance field or {@code Klass*} for a static field on HotSpot).\n+     *\/\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaField.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.vm.ci.hotspot;\n+\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+\n+public class HotSpotResolvedJavaFieldHelper {\n+    public static ResolvedJavaField createField(HotSpotResolvedObjectTypeImpl holder, JavaType type, int offset, int modifiers, int index) {\n+        return new HotSpotResolvedJavaFieldImpl(holder, type, offset, modifiers, index);\n+    }\n+\n+    public static int getIndex(ResolvedJavaField field) {\n+        return ((HotSpotResolvedJavaFieldImpl) field).getIndex();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldHelper.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.jvmci\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ * @library \/compiler\/jvmci\/common\/patches\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotResolvedJavaFieldHelper\n+ * @run testng\/othervm\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n+ *      jdk.vm.ci.hotspot.test.TestHotSpotResolvedJavaField\n+ *\/\n+\n+package jdk.vm.ci.hotspot.test;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import jdk.vm.ci.hotspot.HotSpotResolvedJavaFieldHelper;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+\n+public class TestHotSpotResolvedJavaField {\n+\n+    @Test\n+    public void testIndex() {\n+        int max = Character.MAX_VALUE;\n+        int[] valid = {0, 1, max - 1, max};\n+        for (int index : valid) {\n+            ResolvedJavaField field = HotSpotResolvedJavaFieldHelper.createField(null, null, 0, 0, index);\n+            Assert.assertEquals(HotSpotResolvedJavaFieldHelper.getIndex(field), index);\n+        }\n+    }\n+\n+    @Test\n+    public void testOffset() {\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+        int[] valid = {min, min + 1, -2, 0, 1, max - 1, max};\n+        for (int offset : valid) {\n+            ResolvedJavaField field = HotSpotResolvedJavaFieldHelper.createField(null, null, offset, 0, 0);\n+            Assert.assertEquals(field.getOffset(), offset);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotResolvedJavaField.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}