{"files":[{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package xpath;\n+\n+\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+\/*\n+ * @test\n+ * @bug 8289509\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm xpath.XPathExpDescendantTest\n+ * @summary Tests for XPath descendant\/descendant-or-self axis specifier.\n+ *\/\n+public class XPathExpDescendantTest extends XPathTestBase {\n+\n+    \/*\n+     * DataProvider: provides XPath Axis descendant expressions and equivalent xpath expression.\n+     *\/\n+    @DataProvider(name = \"descendantXpath\")\n+    public Object[][] getDescendantXpathExpression() {\n+        return new Object[][] {\n+                {\"\/Customers\/descendant::*\", \"\/Customers\/\/*\"},\n+                {\"\/Customers\/descendant::Customer\", \"\/\/Customer\"},\n+                {\"\/Customers\/descendant::foo:Customer\", \"\/\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::Address\",\n+                        \"\/Customers\/Customer[@id='x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::*\",\n+                        \"\/Customers\/Customer[@id='x1']\/\/*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Address\/\/*\"},\n+                {\"\/Customers\/descendant::Name\", \"\/Customers\/\/Name\"},\n+                {\"\/Customers\/descendant::Street\", \"\/Customers\/\/Street\"},\n+                {\"\/Customers\/descendant::Street[2]\", \"Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/descendant::Street[2]\", \"(Customers\/\/Street)[2]\"},\n+                {\"\/Customers\/descendant::Street[position() = 2]\",\n+                        \"Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/descendant-or-self::*\", \"\/\/*\"},\n+                {\"\/Customers\/descendant-or-self::Customer\", \"\/Customers\/Customer\"},\n+                {\"\/Customers\/descendant-or-self::foo:Customer\", \"\/Customers\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::Address\",\n+                        \"\/Customers\/Customer[@id = 'x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::*\",\n+                        \"\/Customers\/Customer[@id='x1'] | \/Customers\/Customer[@id = 'x1']\/\/*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant-or-self::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Address | \/Customers\/foo:Customer\/foo:Address\/\/*\"},\n+                {\"\/Customers\/Customer\/*[descendant::Street]\", \"\/Customers\/Customer\/Address\"},\n+                {\"\/Customers\/Customer\/*[not(descendant::Street)]\", \"\/Customers\/Customer\/*[name() != \\\"Address\\\"]\"},\n+                {\"\/Customers\/Customer\/*[descendant-or-self::Street]\", \"\/Customers\/Customer\/Address\"},\n+                {\"\/Customers\/Customer\/*[not(descendant-or-self::Street)]\",\n+                        \"\/Customers\/Customer\/*[name() != \\\"Address\\\"]\"}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath descendant expressions and expected number of descendant nodes returned\n+     *\/\n+    @DataProvider(name = \"descendantXpathNodeCount\")\n+    public Object[][] getDescendantXpathExpressionNodeCount() {\n+        return new Object[][] {\n+                {\"\/Customers\/descendant::*\", 40},\n+                {\"\/Customers\/descendant::Customer\", 3},\n+                {\"\/Customers\/descendant::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::*\", 9},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant::*\", 3},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/descendant::Address\", 0},\n+                {\"\/Customers\/descendant-or-self::*\", 41},\n+                {\"\/Customers\/descendant-or-self::Customer\", 3},\n+                {\"\/Customers\/descendant-or-self::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/descendant-or-self::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::*\", 10},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant-or-self::*\", 4},\n+                {\"\/Customers\/*[descendant::Name]\", 3},\n+                {\"\/Customers\/foo:Customer\/*[descendant-or-self::foo:Street]\", 1}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath descendant expressions which should return null.\n+     *\/\n+    @DataProvider(name = \"descendantXpathEmpty\")\n+    public Object[][] getDescendantXpathExpressionEmpty() {\n+        return new Object[][] {\n+                {\"\/Customers\/Customer\/Name\/descendant::*\"},\n+                {\"\/Customers\/foo:Customer\/descendant::Name\"},\n+                {\"\/Customers\/Customer\/descendant::foo:Name\"},\n+                {\"\/Customers\/descendant::id\"},\n+                {\"\/Customers\/Customer\/Name\/descendant-or-self::id\"},\n+                {\"\/Customers\/foo:Customer\/descendant-or-self::Name\"},\n+                {\"\/Customers\/Customer\/descendant-or-self::foo:Name\"},\n+                {\"\/Customers\/descendant-or-self::id\"}\n+        };\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression returns same nodes as returns when used normal xpath expression\n+     * @param  descexp  descendant XPath expression.\n+     * @param  expath   normal xPath expression\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpath\")\n+    public void descendantExpTests(String descexp, String expath) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList actualNodeList = (NodeList) xPath.evaluate(descexp, doc, XPathConstants.NODESET);\n+        NodeList expectedNodeList = (NodeList) xPath.evaluate(expath, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(actualNodeList.getLength(), expectedNodeList.getLength());\n+\n+        for(int i = 0; i < actualNodeList.getLength(); i++) {\n+            actualNodeList.item(i).equals(expectedNodeList.item(i));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression return descendant nodes list with correct number of nodes.\n+     * @param  exp       XPath expression.\n+     * @param  nodeCount number of descendant nodes in nodelist.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpathNodeCount\")\n+    public void descendantNodesCountTests(String exp, int nodeCount) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList nodeList = (NodeList) xPath.evaluate(exp, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(nodeList.getLength(), nodeCount);\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression return no nodes if descendant expression context nodes don't have matching descendants\n+     * @param  exp     XPath expression.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpathEmpty\")\n+    public void DescendantScopeTests(String exp) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node node = xPath.evaluateExpression(exp, doc, Node.class);\n+        Assert.assertNull(node);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathExpDescendantTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package xpath;\n+\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+\/*\n+ * @test\n+ * @bug 8289509\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm xpath.XPathExpFollowingTest\n+ * @summary Tests for XPath following\/following-sibling axis specifier.\n+ *\/\n+public class XPathExpFollowingTest extends XPathTestBase {\n+    \/*\n+     * DataProvider: provides XPath Axis following expressions and equivalent xpath expression.\n+     *\/\n+    @DataProvider(name = \"followingXpath\")\n+    public Object[][] getFollowingXpathExpression() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\", \"\/None\"},\n+                {\"\/Customers\/Customer\/following::Customer\", \"\/\/Customer[@id != 'x1']\"},\n+                {\"\/Customers\/Customer\/following::foo:Customer\", \"\/\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Address\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Street\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/Address\/Street\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Street[2]\",\n+                        \"\/Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::*\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/descendant-or-self::*\" +\n+                                \" | \/Customers\/foo:Customer\/descendant-or-self::*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Age | \/Customers\/foo:Customer\/foo:ClubMember\"},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following::Street]\", \"\/Customers\/Customer[@id = 'x1']\/*\"},\n+                {\"\/Customers\/foo:Customer\/*[following::foo:Name]\", \"\/None\"},\n+                {\"\/Customers\/foo:Customer\/*[not(following::foo:Name)]\", \"\/Customers\/foo:Customer\/*\"},\n+                {\"\/Customers\/following-sibling::*\", \"\/None\"},\n+                {\"\/Customers\/Customer\/following-sibling::Customer\",\n+                        \"\/Customers\/Customer[@id != 'x1']\"},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Customer\",\n+                        \"\/Customers\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following-sibling::Address\",\n+                        \"\/Customers\/Customer[@id='x1']\/Address\"},\n+                {\"\/Customers\/Customer\/Name\/following-sibling::Address\",\n+                        \"\/Customers\/\/Address\"},\n+                {\"(\/Customers\/Customer\/Address\/Street\/following-sibling::State)[3]\",\n+                        \"\/Customers\/Customer[@id='x3']\/Address\/State\"},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/Street\/following-sibling::*[2]\",\n+                        \"\/Customers\/Customer[@id='x3']\/Address\/State\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following-sibling::*\",\n+                        \"\/Customers\/Customer[@id != 'x1'] | \/Customers\/foo:Customer\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following-sibling::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Age | \/Customers\/foo:Customer\/foo:ClubMember\"},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following-sibling::Street]\", \"\/None\"},\n+                {\"\/Customers\/foo:Customer\/*[following-sibling::foo:Address]\", \"\/Customers\/foo:Customer\/foo:Name |\" +\n+                        \"\/Customers\/foo:Customer\/foo:Phone | \/Customers\/foo:Customer\/foo:Email\"},\n+                {\"\/Customers\/foo:Customer\/*[not(following-sibling::foo:Address)]\", \"\/Customers\/foo:Customer\/foo:Age | \" +\n+                        \"\/Customers\/foo:Customer\/foo:ClubMember | \/Customers\/foo:Customer\/foo:Address\"}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath following expressions and expected number of following nodes returned\n+     *\/\n+    @DataProvider(name = \"followingXpathNodeCount\")\n+    public Object[][] getFollowingXpathExpressionNodeCount() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\", 0},\n+                {\"\/Customers\/Customer\/following::*\", 30},\n+                {\"\/Customers\/Customer\/following::Customer\", 2},\n+                {\"\/Customers\/Customer\/following::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following::*\", 38},\n+                {\"\/Customers\/Customer\/Address\/following::*\", 32},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following::*\", 2},\n+                {\"\/Customers\/foo:Customer\/foo:Name\/following::*\", 8},\n+                {\"\/Customers\/foo:Customer\/*[following::foo:Name]\", 0},\n+                {\"\/Customers\/foo:Customer\/*[not(following::foo:Name)]\", 6},\n+                {\"\/Customers\/following-sibling::*\", 0},\n+                {\"\/Customers\/Customer\/following-sibling::*\", 3},\n+                {\"\/Customers\/Customer\/following-sibling::Customer\", 2},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following-sibling::*\", 5},\n+                {\"\/Customers\/Customer\/Address\/following-sibling::*\", 6},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/following-sibling::*\", 2},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following-sibling::*\", 2},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following-sibling::Street]\", 0},\n+                {\"\/Customers\/foo:Customer\/*[following-sibling::foo:Address]\", 3},\n+                {\"\/Customers\/foo:Customer\/*[not(following-sibling::foo:Address)]\", 3}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath following expressions which should not return any node.\n+     *\/\n+    @DataProvider(name = \"followingXpathEmpty\")\n+    public Object[][] getFollowingXpathExpressionEmpty() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\"},\n+                {\"\/Customers\/foo:Customer\/following::*\"},\n+                {\"\/Customers\/Customer[@id = 'x3' ]\/following::Customer\"},\n+                {\"\/Customers\/following::id\"},\n+                {\"\/Customers\/Customer[@id = 'x3' ]\/following-sibling::Customer\"},\n+                {\"\/Customers\/foo:Customer\/following-sibling::*\"},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Name\"},\n+                {\"\/Customers\/following-sibling::id\"}\n+        };\n+    }\n+\n+    \/**\n+     * Verifies Axis following xpath expression returns same nodes as returns when used normal xpath expression\n+     * @param  descexp  Axis following XPath expression.\n+     * @param  expath   normal xPath expression\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpath\")\n+    public void followingExpTests(String descexp, String expath) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList actualNodeList = (NodeList) xPath.evaluate(descexp, doc, XPathConstants.NODESET);\n+        NodeList expectedNodeList = (NodeList) xPath.evaluate(expath, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(actualNodeList.getLength(), expectedNodeList.getLength());\n+\n+        for(int i = 0; i < actualNodeList.getLength(); i++) {\n+            actualNodeList.item(i).equals(expectedNodeList.item(i));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies following xpath expression return following nodes list with correct number of nodes.\n+     * @param  exp       XPath expression.\n+     * @param  nodeCount number of following nodes in nodelist.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpathNodeCount\")\n+    public void followingNodesCountTests(String exp, int nodeCount) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList nodeList = (NodeList) xPath.evaluate(exp, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(nodeList.getLength(), nodeCount);\n+    }\n+\n+    \/**\n+     * Verifies following xpath expression return no nodes if following expression context nodes don't have matching following elements.\n+     * @param  exp     XPath expression.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpathEmpty\")\n+    public void FollowingScopeTests(String exp) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node node = xPath.evaluateExpression(exp, doc, Node.class);\n+        Assert.assertNull(node);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathExpFollowingTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"}]}