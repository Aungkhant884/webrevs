{"files":[{"patch":"@@ -189,1 +189,5 @@\n-      BytecodeInterpreter::run<true>(istate);\n+      if (RewriteBytecodes) {\n+        BytecodeInterpreter::run<true, true>(istate);\n+      } else {\n+        BytecodeInterpreter::run<true, false>(istate);\n+      }\n@@ -191,1 +195,5 @@\n-      BytecodeInterpreter::run<false>(istate);\n+      if (RewriteBytecodes) {\n+        BytecodeInterpreter::run<false, true>(istate);\n+      } else {\n+        BytecodeInterpreter::run<false, false>(istate);\n+      }\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -296,0 +296,2 @@\n+#define REWRITE_AT_PC(val) \\\n+    *pc = val;\n@@ -392,0 +394,75 @@\n+#define MAYBE_POST_FIELD_ACCESS(obj) {                              \\\n+  if (JVMTI_ENABLED) {                                              \\\n+    int* count_addr;                                                \\\n+    \/* Check to see if a field modification watch has been set *\/   \\\n+    \/* before we take the time to call into the VM. *\/              \\\n+    count_addr = (int*)JvmtiExport::get_field_access_count_addr();  \\\n+    if (*count_addr > 0) {                                          \\\n+      oop target;                                                   \\\n+      if ((Bytecodes::Code)opcode == Bytecodes::_getstatic) {       \\\n+        target = NULL;                                              \\\n+      } else {                                                      \\\n+        target = obj;                                               \\\n+      }                                                             \\\n+      CALL_VM(InterpreterRuntime::post_field_access(THREAD,         \\\n+                                  target, cache),                   \\\n+                                  handle_exception);                \\\n+    }                                                               \\\n+  }                                                                 \\\n+}\n+\n+#define MAYBE_POST_FIELD_MODIFICATION(obj) {                        \\\n+  if (JVMTI_ENABLED) {                                              \\\n+    int* count_addr;                                                \\\n+    \/* Check to see if a field modification watch has been set *\/   \\\n+    \/* before we take the time to call into the VM.            *\/   \\\n+    count_addr = (int*)JvmtiExport::get_field_modification_count_addr(); \\\n+    if (*count_addr > 0) {                                          \\\n+      oop target;                                                   \\\n+      if ((Bytecodes::Code)opcode == Bytecodes::_putstatic) {       \\\n+        target = NULL;                                              \\\n+      } else {                                                      \\\n+        target = obj;                                               \\\n+      }                                                             \\\n+      CALL_VM(InterpreterRuntime::post_field_modification(THREAD,   \\\n+                                  target, cache,                    \\\n+                                  (jvalue*)STACK_SLOT(-1)),         \\\n+                                  handle_exception);                \\\n+    }                                                               \\\n+  }                                                                 \\\n+}\n+\n+static inline int fast_get_type(TosState tos) {\n+  switch (tos) {\n+    case ztos:\n+    case btos: return Bytecodes::_fast_bgetfield;\n+    case ctos: return Bytecodes::_fast_cgetfield;\n+    case stos: return Bytecodes::_fast_sgetfield;\n+    case itos: return Bytecodes::_fast_igetfield;\n+    case ltos: return Bytecodes::_fast_lgetfield;\n+    case ftos: return Bytecodes::_fast_fgetfield;\n+    case dtos: return Bytecodes::_fast_dgetfield;\n+    case atos: return Bytecodes::_fast_agetfield;\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n+  }\n+}\n+\n+static inline int fast_put_type(TosState tos) {\n+  switch (tos) {\n+    case ztos: return Bytecodes::_fast_zputfield;\n+    case btos: return Bytecodes::_fast_bputfield;\n+    case ctos: return Bytecodes::_fast_cputfield;\n+    case stos: return Bytecodes::_fast_sputfield;\n+    case itos: return Bytecodes::_fast_iputfield;\n+    case ltos: return Bytecodes::_fast_lputfield;\n+    case ftos: return Bytecodes::_fast_fputfield;\n+    case dtos: return Bytecodes::_fast_dputfield;\n+    case atos: return Bytecodes::_fast_aputfield;\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n+  }\n+}\n+\n@@ -400,3 +477,5 @@\n-\/\/ Instantiate two variants of the method for future linking.\n-template void BytecodeInterpreter::run<true>(interpreterState istate);\n-template void BytecodeInterpreter::run<false>(interpreterState istate);\n+\/\/ Instantiate variants of the method for future linking.\n+template void BytecodeInterpreter::run<false, false>(interpreterState istate);\n+template void BytecodeInterpreter::run<false,  true>(interpreterState istate);\n+template void BytecodeInterpreter::run< true, false>(interpreterState istate);\n+template void BytecodeInterpreter::run< true,  true>(interpreterState istate);\n@@ -404,1 +483,1 @@\n-template<bool JVMTI_ENABLED>\n+template<bool JVMTI_ENABLED, bool REWRITE_BYTECODES>\n@@ -500,2 +579,2 @@\n-\/* 0xC8 *\/ &&opc_goto_w,        &&opc_jsr_w,            &&opc_breakpoint,     &&opc_default,\n-\/* 0xCC *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n+\/* 0xC8 *\/ &&opc_goto_w,        &&opc_jsr_w,            &&opc_breakpoint,     &&opc_fast_agetfield,\n+\/* 0xCC *\/ &&opc_fast_bgetfield,&&opc_fast_cgetfield,   &&opc_fast_dgetfield, &&opc_fast_fgetfield,\n@@ -503,4 +582,4 @@\n-\/* 0xD0 *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n-\/* 0xD4 *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n-\/* 0xD8 *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n-\/* 0xDC *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n+\/* 0xD0 *\/ &&opc_fast_igetfield,&&opc_fast_lgetfield,   &&opc_fast_sgetfield, &&opc_fast_aputfield,\n+\/* 0xD4 *\/ &&opc_fast_bputfield,&&opc_fast_zputfield,   &&opc_fast_cputfield, &&opc_fast_dputfield,\n+\/* 0xD8 *\/ &&opc_fast_fputfield,&&opc_fast_iputfield,   &&opc_fast_lputfield, &&opc_fast_sputfield,\n+\/* 0xDC *\/ &&opc_fast_aload_0,  &&opc_fast_iaccess_0,   &&opc_fast_aaccess_0, &&opc_fast_faccess_0,\n@@ -508,1 +587,1 @@\n-\/* 0xE0 *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n+\/* 0xE0 *\/ &&opc_fast_iload,    &&opc_fast_iload2,      &&opc_fast_icaload,   &&opc_fast_invokevfinal,\n@@ -755,0 +834,26 @@\n+      {\n+        if (REWRITE_BYTECODES) {\n+          \/\/ Attempt to rewrite iload, iload -> fast_iload2\n+          \/\/                    iload, caload -> fast_icaload\n+          \/\/ Normal iloads will be rewritten to fast_iload to avoid checking again.\n+          switch (*(pc + 2)) {\n+            case Bytecodes::_fast_iload:\n+              REWRITE_AT_PC(Bytecodes::_fast_iload2);\n+              break;\n+            case Bytecodes::_caload:\n+              REWRITE_AT_PC(Bytecodes::_fast_icaload);\n+              break;\n+            case Bytecodes::_iload:\n+              \/\/ Wait until rewritten to _fast_iload.\n+              break;\n+            default:\n+              \/\/ Last iload in a (potential) series, don't check again.\n+              REWRITE_AT_PC(Bytecodes::_fast_iload);\n+          }\n+        }\n+        \/\/ Normal iload handling.\n+        SET_STACK_SLOT(LOCALS_SLOT(pc[1]), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(2, 1);\n+      }\n+\n+      CASE(_fast_iload):\n@@ -759,0 +864,5 @@\n+      CASE(_fast_iload2):\n+          SET_STACK_SLOT(LOCALS_SLOT(pc[1]), 0);\n+          SET_STACK_SLOT(LOCALS_SLOT(pc[3]), 1);\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(4, 2);\n+\n@@ -769,5 +879,0 @@\n-      CASE(_aload_##num):                                               \\\n-          VERIFY_OOP(LOCALS_OBJECT(num));                               \\\n-          SET_STACK_OBJECT(LOCALS_OBJECT(num), 0);                      \\\n-          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);                         \\\n-                                                                        \\\n@@ -786,4 +891,47 @@\n-          OPC_LOAD_n(0);\n-          OPC_LOAD_n(1);\n-          OPC_LOAD_n(2);\n-          OPC_LOAD_n(3);\n+      OPC_LOAD_n(0);\n+      OPC_LOAD_n(1);\n+      OPC_LOAD_n(2);\n+      OPC_LOAD_n(3);\n+\n+#undef  OPC_ALOAD_n\n+#define OPC_ALOAD_n(num)                                                \\\n+      CASE(_aload_##num): {                                             \\\n+          oop obj = LOCALS_OBJECT(num);                                 \\\n+          VERIFY_OOP(obj);                                              \\\n+          SET_STACK_OBJECT(obj, 0);                                     \\\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);                         \\\n+      }\n+\n+      CASE(_aload_0):\n+      {\n+        \/* Maybe rewrite if following bytecode is one of the supported _fast_Xgetfield bytecodes. *\/\n+        if (REWRITE_BYTECODES) {\n+          switch (*(pc + 1)) {\n+            case Bytecodes::_fast_agetfield:\n+              REWRITE_AT_PC(Bytecodes::_fast_aaccess_0);\n+              break;\n+            case Bytecodes::_fast_fgetfield:\n+              REWRITE_AT_PC(Bytecodes::_fast_faccess_0);\n+              break;\n+            case Bytecodes::_fast_igetfield:\n+              REWRITE_AT_PC(Bytecodes::_fast_iaccess_0);\n+              break;\n+            case Bytecodes::_getfield: {\n+              \/* Otherwise, do nothing here, wait until it gets rewritten to _fast_Xgetfield.\n+               * Unfortunately, this punishes volatile field access, because it never gets\n+               * rewritten. *\/\n+              break;\n+            }\n+            default:\n+              REWRITE_AT_PC(Bytecodes::_fast_aload_0);\n+              break;\n+          }\n+        }\n+        VERIFY_OOP(LOCALS_OBJECT(0));\n+        SET_STACK_OBJECT(LOCALS_OBJECT(0), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);\n+      }\n+\n+      OPC_ALOAD_n(1);\n+      OPC_ALOAD_n(2);\n+      OPC_ALOAD_n(3);\n@@ -1321,5 +1469,1 @@\n-      \/* Every array access byte-code starts out like this *\/\n-\/\/        arrayOopDesc* arrObj = (arrayOopDesc*)STACK_OBJECT(arrayOff);\n-#define ARRAY_INTRO(arrayOff)                                                  \\\n-      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \\\n-      jint     index  = STACK_INT(arrayOff + 1);                               \\\n+#define ARRAY_INDEX_CHECK(arrObj, index)                                       \\\n@@ -1337,0 +1481,7 @@\n+      \/* Every array access byte-code starts out like this *\/\n+\/\/        arrayOopDesc* arrObj = (arrayOopDesc*)STACK_OBJECT(arrayOff);\n+#define ARRAY_INTRO(arrayOff)                                                  \\\n+      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \\\n+      jint     index  = STACK_INT(arrayOff + 1);                               \\\n+      ARRAY_INDEX_CHECK(arrObj, index)\n+\n@@ -1376,0 +1527,9 @@\n+      CASE(_fast_icaload): {\n+          \/\/ Custom fast access for iload,caload pair.\n+          arrayOop arrObj = (arrayOop) STACK_OBJECT(-1);\n+          jint index = LOCALS_INT(pc[1]);\n+          ARRAY_INDEX_CHECK(arrObj, index);\n+          SET_STACK_INT(*(jchar *)(((address) arrObj->base(T_CHAR)) + index * sizeof(jchar)), -1);\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(3, 0);\n+      }\n+\n@@ -1549,20 +1709,0 @@\n-          if (JVMTI_ENABLED) {\n-            int *count_addr;\n-            oop obj;\n-            \/\/ Check to see if a field modification watch has been set\n-            \/\/ before we take the time to call into the VM.\n-            count_addr = (int *)JvmtiExport::get_field_access_count_addr();\n-            if ( *count_addr > 0 ) {\n-              if ((Bytecodes::Code)opcode == Bytecodes::_getstatic) {\n-                obj = NULL;\n-              } else {\n-                obj = STACK_OBJECT(-1);\n-                VERIFY_OOP(obj);\n-              }\n-              CALL_VM(InterpreterRuntime::post_field_access(THREAD,\n-                                          obj,\n-                                          cache),\n-                                          handle_exception);\n-            }\n-          }\n-\n@@ -1577,0 +1717,5 @@\n+            \/\/ Check if we can rewrite non-volatile _getfield to one of the _fast_Xgetfield.\n+            if (REWRITE_BYTECODES && !cache->is_volatile()) {\n+              \/\/ Rewrite current BC to _fast_Xgetfield.\n+              REWRITE_AT_PC(fast_get_type(cache->flag_state()));\n+            }\n@@ -1579,0 +1724,2 @@\n+          MAYBE_POST_FIELD_ACCESS(obj);\n+\n@@ -1673,27 +1820,0 @@\n-          if (JVMTI_ENABLED) {\n-            int *count_addr;\n-            oop obj;\n-            \/\/ Check to see if a field modification watch has been set\n-            \/\/ before we take the time to call into the VM.\n-            count_addr = (int *)JvmtiExport::get_field_modification_count_addr();\n-            if ( *count_addr > 0 ) {\n-              if ((Bytecodes::Code)opcode == Bytecodes::_putstatic) {\n-                obj = NULL;\n-              }\n-              else {\n-                if (cache->is_long() || cache->is_double()) {\n-                  obj = STACK_OBJECT(-3);\n-                } else {\n-                  obj = STACK_OBJECT(-2);\n-                }\n-                VERIFY_OOP(obj);\n-              }\n-\n-              CALL_VM(InterpreterRuntime::post_field_modification(THREAD,\n-                                          obj,\n-                                          cache,\n-                                          (jvalue *)STACK_SLOT(-1)),\n-                                          handle_exception);\n-            }\n-          }\n-\n@@ -1718,0 +1838,6 @@\n+\n+            \/\/ Check if we can rewrite non-volatile _putfield to one of the _fast_Xputfield.\n+            if (REWRITE_BYTECODES && !cache->is_volatile()) {\n+              \/\/ Rewrite current BC to _fast_Xputfield.\n+              REWRITE_AT_PC(fast_put_type(cache->flag_state()));\n+            }\n@@ -1720,0 +1846,2 @@\n+          MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n@@ -2279,0 +2407,4 @@\n+              if (REWRITE_BYTECODES) {\n+                \/\/ Rewrite to _fast_invokevfinal.\n+                REWRITE_AT_PC(Bytecodes::_fast_invokevfinal);\n+              }\n@@ -2413,0 +2545,323 @@\n+      CASE(_fast_agetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        VERIFY_OOP(obj->obj_field(field_offset));\n+        SET_STACK_OBJECT(obj->obj_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_bgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->byte_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_cgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->char_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_dgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_DOUBLE(obj->double_field(field_offset), 0);\n+        MORE_STACK(1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_fgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_FLOAT(obj->float_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_igetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->int_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_lgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_LONG(obj->long_field(field_offset), 0);\n+        MORE_STACK(1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_sgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->short_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_aputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->obj_field_put(field_offset, STACK_OBJECT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_bputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->byte_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_zputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->byte_field_put(field_offset, (STACK_INT(-1) & 1)); \/\/ only store LSB\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_cputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->char_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_dputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-3);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->double_field_put(field_offset, STACK_DOUBLE(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -3);\n+      }\n+\n+      CASE(_fast_fputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->float_field_put(field_offset, STACK_FLOAT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_iputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->int_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_lputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-3);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->long_field_put(field_offset, STACK_LONG(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -3);\n+      }\n+\n+      CASE(_fast_sputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->short_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_aload_0): {\n+        oop obj = LOCALS_OBJECT(0);\n+        VERIFY_OOP(obj);\n+        SET_STACK_OBJECT(obj, 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);\n+      }\n+\n+      CASE(_fast_aaccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        VERIFY_OOP(obj->obj_field(field_offset));\n+        SET_STACK_OBJECT(obj->obj_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_faccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->int_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_iaccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_FLOAT(obj->float_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_invokevfinal): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        assert(cache->is_resolved(Bytecodes::_invokevirtual), \"Should be resolved before rewriting\");\n+\n+        istate->set_msg(call_method);\n+\n+        CHECK_NULL(STACK_OBJECT(-(cache->parameter_size())));\n+        Method* callee = cache->f2_as_vfinal_method();\n+        istate->set_callee(callee);\n+        if (JVMTI_ENABLED && THREAD->is_interp_only_mode()) {\n+          istate->set_callee_entry_point(callee->interpreter_entry());\n+        } else {\n+          istate->set_callee_entry_point(callee->from_interpreted_entry());\n+        }\n+        istate->set_bcp_advance(3);\n+        UPDATE_PC_AND_RETURN(0);\n+      }\n+\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":527,"deletions":72,"binary":false,"changes":599,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-template<bool JVMTI_ENABLED>\n+template<bool JVMTI_ENABLED, bool REWRITE_BYTECODES>\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -329,0 +329,6 @@\n+#ifdef ZERO\n+    \/\/ The BytecodeInterpreter is specialized only with RewriteBytecodes\n+    \/\/ for simplicity. If we want to disable RewriteFrequentPairs, we\n+    \/\/ need to disable RewriteBytecodes as well.\n+    RewriteBytecodes = false;\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}