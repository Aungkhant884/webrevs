{"files":[{"patch":"@@ -924,1 +924,2 @@\n-  inline void       record_for_igvn(Node* n);   \/\/ Body is after class Unique_Node_List.\n+  inline void       record_for_igvn(Node* n);   \/\/ Body is after class Unique_Node_List in node.hpp.\n+  inline void       remove_for_igvn(Node* n);   \/\/ Body is after class Unique_Node_List in node.hpp.\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -741,0 +741,23 @@\n+\/\/-----------------------------destruct_map_clone------------------------------\n+\/\/\n+\/\/ Order of destruct is important to increase the likelyhood that memory can be re-used. We need\n+\/\/ to destruct\/free\/delete in the exact opposite order as clone_map().\n+void GraphKit::destruct_map_clone(SafePointNode* sfp) {\n+  if (sfp == nullptr) return;\n+\n+  Node* mem = sfp->memory();\n+  JVMState* jvms = sfp->jvms();\n+\n+  if (jvms != nullptr) {\n+    delete jvms;\n+  }\n+\n+  remove_for_igvn(sfp);\n+  gvn().clear_type(sfp);\n+  sfp->destruct(&_gvn);\n+\n+  if (mem != nullptr) {\n+    gvn().clear_type(mem);\n+    mem->destruct(&_gvn);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+  void remove_for_igvn(Node* n) const { C->remove_for_igvn(n); }\n@@ -173,0 +174,5 @@\n+  \/\/ Reverses the work done by clone_map(). Should only be used when the node returned by\n+  \/\/ clone_map() is ultimately not used. Calling Node::destruct directly in the previously\n+  \/\/ mentioned circumstance instead of this method may result in use-after-free.\n+  void destruct_map_clone(SafePointNode* sfp);\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1566,1 +1566,1 @@\n-  old_map->destruct(&_gvn);\n+  destruct_map_clone(old_map);\n@@ -2349,1 +2349,1 @@\n-  old_map->destruct(&_gvn);\n+  destruct_map_clone(old_map);\n@@ -2600,1 +2600,1 @@\n-  old_map->destruct(&_gvn);\n+  destruct_map_clone(old_map);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1650,0 +1650,5 @@\n+\/\/ Inline definition of Compile::remove_for_igvn must be deferred to this point.\n+inline void Compile::remove_for_igvn(Node* n) {\n+  _for_igvn->remove(n);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -241,0 +241,5 @@\n+  void    clear_type(const Node* n) {\n+    if (n->_idx < _types.Size()) {\n+      _types.map(n->_idx, NULL);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -871,1 +871,1 @@\n-  old_map->destruct(&_gvn);\n+  destruct_map_clone(old_map);\n@@ -1009,1 +1009,1 @@\n-  old_map->destruct(&_gvn);\n+  destruct_map_clone(old_map);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}