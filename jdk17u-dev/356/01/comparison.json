{"files":[{"patch":"@@ -15,0 +15,4 @@\n+concurrency:\n+  group: ${{ github.workflow }}-${{ github.ref }}\n+  cancel-in-progress: true\n+\n@@ -22,0 +26,1 @@\n+      jdk_version: ${{ steps.check_jdk_versions.outputs.jdk_version }}\n@@ -69,0 +74,17 @@\n+      - name: Determine full JDK versions\n+        id: check_jdk_versions\n+        shell: bash\n+        run: |\n+          FEATURE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\n+          INTERIM=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_INTERIM }}\n+          UPDATE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\n+          if [ \"x${UPDATE}\" != \"x0\" ]; then\n+             V=${FEATURE}.${INTERIM}.${UPDATE}\n+          elif [ \"x${INTERIM}\" != \"x0\" ]; then\n+             V={FEATURE}.${INTERIM}\n+          else\n+             V=${FEATURE}\n+          fi\n+          echo \"::set-output name=jdk_version::${V}\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n@@ -124,1 +146,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -253,1 +275,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -325,0 +347,1 @@\n+        id: run_tests\n@@ -340,1 +363,1 @@\n-        if: always()\n+        if: steps.run_tests.outcome != 'skipped'\n@@ -435,1 +458,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -583,1 +606,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -720,1 +743,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -792,0 +815,1 @@\n+        id: run_tests\n@@ -807,1 +831,1 @@\n-        if: always()\n+        if: steps.run_tests.outcome != 'skipped'\n@@ -871,1 +895,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -878,0 +902,13 @@\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n@@ -887,2 +924,0 @@\n-          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n-          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n@@ -960,1 +995,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -967,0 +1002,13 @@\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n@@ -976,2 +1024,0 @@\n-          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n-          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n@@ -1112,1 +1158,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1139,0 +1185,13 @@\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n@@ -1148,2 +1207,0 @@\n-          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n-          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n@@ -1201,0 +1258,1 @@\n+        id: run_tests\n@@ -1219,1 +1277,1 @@\n-        if: always()\n+        if: steps.run_tests.outcome != 'skipped'\n@@ -1287,1 +1345,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1389,1 +1447,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1520,1 +1578,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1598,0 +1656,1 @@\n+        id: run_tests\n@@ -1613,1 +1672,1 @@\n-        if: always()\n+        if: steps.run_tests.outcome != 'skipped'\n","filename":".github\/workflows\/submit.yml","additions":80,"deletions":21,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-version=17.0.3\n+version=17.0.4\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,0 +224,7 @@\n+# For reproducible builds specify the jmod --date using SOURCE_DATE in ISO-8601\n+ifeq ($(ENABLE_REPRODUCIBLE_BUILD), true)\n+  JMOD_SOURCE_DATE := --date $(SOURCE_DATE_ISO_8601)\n+else\n+  JMOD_SOURCE_DATE :=\n+endif\n+\n@@ -235,0 +242,1 @@\n+        $(JMOD_SOURCE_DATE) \\\n","filename":"make\/CreateJmods.gmk","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -316,0 +316,9 @@\n+    ifeq ($$(IS_GNU_DATE), yes)\n+      export SOURCE_DATE_ISO_8601 := $$(shell $$(DATE) --utc \\\n+                                                       --date=\"@$$(SOURCE_DATE_EPOCH)\" \\\n+                                                       +\"%Y-%m-%dT%H:%M:%SZ\" 2> \/dev\/null)\n+    else\n+      export SOURCE_DATE_ISO_8601 := $$(shell $$(DATE) -u \\\n+                                                       -j -f \"%s\" \"$$(SOURCE_DATE_EPOCH)\" \\\n+                                                       +\"%Y-%m-%dT%H:%M:%SZ\" 2> \/dev\/null)\n+    endif\n","filename":"make\/InitSupport.gmk","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-\t$(ECHO) \"build.workspace.root=$(call FixPath, $(WORKSPACE_ROOT))\" >> $@\n-\t$(ECHO) \"build.output.root=$(call FixPath, $(OUTPUTDIR))\" >> $@\n+\t$(ECHO) 'build.workspace.root=$(call FixPath, $(WORKSPACE_ROOT))' >> $@\n+\t$(ECHO) 'build.output.root=$(call FixPath, $(OUTPUTDIR))' >> $@\n","filename":"make\/TestImage.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,0 +359,12 @@\n+  # Check if it's a GNU date compatible version\n+  AC_MSG_CHECKING([if date is a GNU compatible version])\n+  check_date=`$DATE --version 2>&1 | $GREP \"GNU\\|BusyBox\"`\n+  if test \"x$check_date\" != x; then\n+    AC_MSG_RESULT([yes])\n+    IS_GNU_DATE=yes\n+  else\n+    AC_MSG_RESULT([no])\n+    IS_GNU_DATE=no\n+  fi\n+  AC_SUBST(IS_GNU_DATE)\n+\n","filename":"make\/autoconf\/basic_tools.m4","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -360,0 +360,10 @@\n+  # Determine if the boot jdk jar supports the --date option\n+  if $JAR --help 2>&1 | $GREP -q \"\\-\\-date=TIMESTAMP\"; then\n+    BOOT_JDK_JAR_SUPPORTS_DATE=true\n+  else\n+    BOOT_JDK_JAR_SUPPORTS_DATE=false\n+  fi\n+  AC_MSG_CHECKING([if Boot JDK jar supports --date=TIMESTAMP])\n+  AC_MSG_RESULT([$BOOT_JDK_JAR_SUPPORTS_DATE])\n+  AC_SUBST(BOOT_JDK_JAR_SUPPORTS_DATE)\n+\n","filename":"make\/autoconf\/boot-jdk.m4","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -785,1 +785,0 @@\n-      workspace_root_win=`$FIXPATH_BASE print \"${WORKSPACE_ROOT%\/}\"`\n@@ -787,2 +786,1 @@\n-      PATHMAP_FLAGS=\"-pathmap:${workspace_root_win\/\/\\\/\/\\\\\\\\}=s \\\n-          -pathmap:${workspace_root_win}=s\"\n+      PATHMAP_FLAGS=\"-pathmap:${WORKSPACE_ROOT}=s\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-  UTIL_LOOKUP_PROGS(PKGHANDLER, zypper apt-get yum brew port pkgutil pkgadd pacman)\n+  UTIL_LOOKUP_PROGS(PKGHANDLER, zypper apt-get yum brew port pkgutil pkgadd pacman apk)\n@@ -61,0 +61,2 @@\n+      *apk)\n+        apk_help     $MISSING_DEPENDENCY ;;\n@@ -187,0 +189,21 @@\n+apk_help() {\n+  case $1 in\n+    devkit)\n+      PKGHANDLER_COMMAND=\"sudo apk add alpine-sdk linux-headers\" ;;\n+    alsa)\n+      PKGHANDLER_COMMAND=\"sudo apk add alsa-lib-dev\" ;;\n+    cups)\n+      PKGHANDLER_COMMAND=\"sudo apk add cups-dev\" ;;\n+    fontconfig)\n+      PKGHANDLER_COMMAND=\"sudo apk add fontconfig-dev\" ;;\n+    freetype)\n+      PKGHANDLER_COMMAND=\"sudo apk add freetype-dev\" ;;\n+    harfbuzz)\n+      PKGHANDLER_COMMAND=\"sudo apk add harfbuzz-dev\" ;;\n+    x11)\n+      PKGHANDLER_COMMAND=\"sudo apk add libxtst-dev libxt-dev libxrender-dev libxrandr-dev\" ;;\n+    ccache)\n+      PKGHANDLER_COMMAND=\"sudo apk add ccache\" ;;\n+  esac\n+}\n+\n","filename":"make\/autoconf\/help.m4","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -219,0 +219,6 @@\n+  elif test \"x$SOURCE_DATE_EPOCH\" != x; then\n+    if test \"x$IS_GNU_DATE\" = xyes; then\n+      COPYRIGHT_YEAR=`date --date=@$SOURCE_DATE_EPOCH +%Y`\n+    else\n+      COPYRIGHT_YEAR=`date -j -f %s $SOURCE_DATE_EPOCH +%Y`\n+    fi\n","filename":"make\/autoconf\/jdk-options.m4","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -367,0 +367,3 @@\n+# Whether the boot jdk jar supports --date=TIMESTAMP\n+BOOT_JDK_JAR_SUPPORTS_DATE:=@BOOT_JDK_JAR_SUPPORTS_DATE@\n+\n@@ -703,0 +706,1 @@\n+IS_GNU_DATE:=@IS_GNU_DATE@\n","filename":"make\/autoconf\/spec.gmk.in","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,4 +239,6 @@\n-  timestamp=$($DATE --utc --date=$2 +\"%s\" 2> \/dev\/null)\n-  if test \"x$timestamp\" = x; then\n-    # GNU date format did not work, try BSD date options\n-    timestamp=$($DATE -j -f \"%F %T\" \"$2\" \"+%s\" 2> \/dev\/null)\n+  if test \"x$IS_GNU_DATE\" = xyes; then\n+    # GNU date\n+    timestamp=$($DATE --utc --date=$2 +\"%s\" 2> \/dev\/null)\n+  else\n+    # BSD date\n+    timestamp=$($DATE -u -j -f \"%F %T\" \"$2\" \"+%s\" 2> \/dev\/null)\n@@ -245,1 +247,1 @@\n-      timestamp=$($DATE -j -f \"%F %T\" \"$2 00:00:00\" \"+%s\" 2> \/dev\/null)\n+      timestamp=$($DATE -u -j -f \"%F %T\" \"$2 00:00:00\" \"+%s\" 2> \/dev\/null)\n","filename":"make\/autoconf\/util.m4","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,1 @@\n-        $$($1_JAR_CMD) $$($1_JAR_UPDATE_OPTIONS) $$@ @$$($1_BIN)\/_the.$$($1_JARNAME)_contents; \\\n+        $$($1_JAR_CMD) --update $$($1_JAR_OPTIONS) --file $$@ @$$($1_BIN)\/_the.$$($1_JARNAME)_contents; \\\n@@ -215,1 +215,1 @@\n-  $1_SUPDATE_CONTENTS=$$($1_JAR_CMD) $$($1_JAR_UPDATE_OPTIONS) $$@ @$$($1_BIN)\/_the.$$($1_JARNAME)_contents $$(NEWLINE)\n+  $1_SUPDATE_CONTENTS=$$($1_JAR_CMD) --update $$($1_JAR_OPTIONS) --file $$@ @$$($1_BIN)\/_the.$$($1_JARNAME)_contents $$(NEWLINE)\n@@ -220,0 +220,8 @@\n+  # If reproducible build and the boot jdk jar supports --date option\n+  # then specify the --date using SOURCE_DATE in ISO-8601\n+  $1_JAR_OPTIONS :=\n+  ifeq ($$(ENABLE_REPRODUCIBLE_BUILD), true)\n+    ifeq ($$(BOOT_JDK_JAR_SUPPORTS_DATE), true)\n+      $1_JAR_OPTIONS += --date $(SOURCE_DATE_ISO_8601)\n+    endif\n+  endif\n@@ -221,5 +229,2 @@\n-    $1_JAR_CREATE_OPTIONS := c0fm\n-    $1_JAR_UPDATE_OPTIONS := u0f\n-    ifeq ($(COMPRESS_JARS), true)\n-      $1_JAR_CREATE_OPTIONS := cfm\n-      $1_JAR_UPDATE_OPTIONS := uf\n+    ifneq ($(COMPRESS_JARS), true)\n+      $1_JAR_OPTIONS += --no-compress\n@@ -227,3 +232,0 @@\n-  else\n-    $1_JAR_CREATE_OPTIONS := cfm\n-    $1_JAR_UPDATE_OPTIONS := uf\n@@ -233,1 +235,1 @@\n-  $1_VARDEPS := $$($1_JAR_CMD) $$($1_JAR_CREATE_OPTIONS) $$($1_MANIFEST) \\\n+  $1_VARDEPS := $$($1_JAR_CMD) $$($1_JAR_OPTIONS) $$($1_MANIFEST) \\\n@@ -258,1 +260,1 @@\n-\t  $$($1_JAR_CMD) $$($1_JAR_CREATE_OPTIONS) $$@ $$($1_MANIFEST_FILE) $$(NEWLINE) \\\n+\t  $$($1_JAR_CMD) --create $$($1_JAR_OPTIONS) --file $$@ --manifest $$($1_MANIFEST_FILE) $$(NEWLINE) \\\n","filename":"make\/common\/JarArchive.gmk","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-BOOT_JDK_VERSION=16\n+BOOT_JDK_VERSION=17\n@@ -33,3 +33,3 @@\n-LINUX_X64_BOOT_JDK_FILENAME=openjdk-17.0.1_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17.0.1\/2a2082e5a09d4267845be086888add4f\/12\/GPL\/openjdk-17.0.1_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=1c0a73cbb863aad579b967316bf17673b8f98a9bb938602a140ba2e5c38f880a\n+LINUX_X64_BOOT_JDK_FILENAME=openjdk-17.0.2_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin17-binaries\/releases\/download\/jdk-17.0.2%2B8\/OpenJDK17U-jdk_x64_linux_hotspot_17.0.2_8.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=288f34e3ba8a4838605636485d0365ce23e57d5f2f68997ac4c2e4c01967cd48\n@@ -37,3 +37,3 @@\n-WINDOWS_X64_BOOT_JDK_FILENAME=openjdk-17.0.1_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17.0.1\/2a2082e5a09d4267845be086888add4f\/12\/GPL\/openjdk-17.0.1_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=329900a6673b237b502bdcf77bc334da34bc91355c5fd2d457fc00f53fd71ef1\n+WINDOWS_X64_BOOT_JDK_FILENAME=openjdk-17.0.2_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin17-binaries\/releases\/download\/jdk-17.0.2%2B8\/OpenJDK17U-jdk_x64_windows_hotspot_17.0.2_8.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=d083479ca927dce2f586f779373d895e8bf668c632505740279390384edf03fa\n@@ -41,3 +41,3 @@\n-MACOS_X64_BOOT_JDK_FILENAME=openjdk-17.0.1_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17.0.1\/2a2082e5a09d4267845be086888add4f\/12\/GPL\/openjdk-17.0.1_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=6ccb35800e723cabe15af60e67099d1a07c111d2d3208aa75523614dde68bee1\n+MACOS_X64_BOOT_JDK_FILENAME=openjdk-17.0.2_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin17-binaries\/releases\/download\/jdk-17.0.2%2B8\/OpenJDK17U-jdk_x64_mac_hotspot_17.0.2_8.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=3630e21a571b7180876bf08f85d0aac0bdbb3267b2ae9bd242f4933b21f9be32\n","filename":"make\/conf\/test-dependencies","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=3\n+DEFAULT_VERSION_UPDATE=4\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2022-04-19\n+DEFAULT_VERSION_DATE=2022-07-19\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/cbbba1d234670453df9c930dfbf510c0474d4301\/public_suffix_list.dat\n-Date: 2020-04-24\n+Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/3c213aab32b3c014f171b1673d4ce9b5cd72bf1c\/public_suffix_list.dat\n+Date: 2021-11-27\n","filename":"make\/data\/publicsuffixlist\/VERSION","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-\/\/ ar : https:\/\/nic.ar\/nic-argentina\/normativa-vigente\n+\/\/ ar : https:\/\/nic.ar\/es\/nic-argentina\/normativa\n@@ -180,0 +180,1 @@\n+bet.ar\n@@ -181,0 +182,1 @@\n+coop.ar\n@@ -187,0 +189,1 @@\n+mutual.ar\n@@ -189,0 +192,1 @@\n+senasa.ar\n@@ -261,1 +265,1 @@\n-education.tas.edu.au\n+\/\/ education.tas.edu.au - Removed at the request of the Department of Education Tasmania\n@@ -459,0 +463,1 @@\n+app.br\n@@ -466,0 +471,1 @@\n+bib.br\n@@ -480,0 +486,1 @@\n+coz.br\n@@ -484,0 +491,3 @@\n+des.br\n+det.br\n+dev.br\n@@ -488,0 +498,1 @@\n+enf.br\n@@ -503,0 +514,1 @@\n+geo.br\n@@ -546,0 +558,1 @@\n+log.br\n@@ -578,0 +591,1 @@\n+rep.br\n@@ -588,0 +602,1 @@\n+seg.br\n@@ -595,0 +610,1 @@\n+tec.br\n@@ -725,1 +741,0 @@\n-aprendemas.cl\n@@ -830,0 +845,1 @@\n+\/\/ cv : http:\/\/www.dns.cv\/tldcv_portal\/do?com=DS;5446457100;111;+PAGE(4000018)+K-CAT-CODIGO(RDOM)+RCNT(100); <- registration rules\n@@ -831,0 +847,5 @@\n+com.cv\n+edu.cv\n+int.cv\n+nome.cv\n+org.cv\n@@ -898,1 +919,1 @@\n-\/\/ dz : https:\/\/en.wikipedia.org\/wiki\/.dz\n+\/\/ dz : http:\/\/www.nic.dz\/images\/pdf_nic\/charte.pdf\n@@ -900,0 +921,2 @@\n+art.dz\n+asso.dz\n@@ -901,0 +924,2 @@\n+edu.dz\n+gov.dz\n@@ -903,3 +928,0 @@\n-gov.dz\n-edu.dz\n-asso.dz\n@@ -907,1 +929,2 @@\n-art.dz\n+soc.dz\n+tm.dz\n@@ -1005,0 +1028,4 @@\n+com.fm\n+edu.fm\n+net.fm\n+org.fm\n@@ -1044,0 +1071,2 @@\n+edu.gd\n+gov.gd\n@@ -1135,1 +1164,1 @@\n-\/\/ gt : http:\/\/www.gt\/politicas_de_registro.html\n+\/\/ gt : https:\/\/www.gt\/sitio\/registration_policy.php?lang=en\n@@ -1159,0 +1188,1 @@\n+\/\/ gw : https:\/\/nic.gw\/regras\/\n@@ -3788,1 +3818,1 @@\n-\/\/ lk : http:\/\/www.nic.lk\/seclevpr.html\n+\/\/ lk : https:\/\/www.nic.lk\/index.php\/domain-registration\/lk-domain-naming-structure\n@@ -4577,1 +4607,2 @@\n-\/\/ my : http:\/\/www.mynic.net.my\/\n+\/\/ my : http:\/\/www.mynic.my\/\n+\/\/ Available strings: https:\/\/mynic.my\/resources\/domains\/buying-a-domain\/\n@@ -4579,0 +4610,1 @@\n+biz.my\n@@ -4580,3 +4612,0 @@\n-net.my\n-org.my\n-gov.my\n@@ -4584,0 +4613,1 @@\n+gov.my\n@@ -4586,0 +4616,2 @@\n+net.my\n+org.my\n@@ -4682,5 +4714,5 @@\n-\/\/ no : http:\/\/www.norid.no\/regelverk\/index.en.html\n-\/\/ The Norwegian registry has declined to notify us of updates. The web pages\n-\/\/ referenced below are the official source of the data. There is also an\n-\/\/ announce mailing list:\n-\/\/ https:\/\/postlister.uninett.no\/sympa\/info\/norid-diskusjon\n+\/\/ no : https:\/\/www.norid.no\/en\/om-domenenavn\/regelverk-for-no\/\n+\/\/ Norid geographical second level domains : https:\/\/www.norid.no\/en\/om-domenenavn\/regelverk-for-no\/vedlegg-b\/\n+\/\/ Norid category second level domains : https:\/\/www.norid.no\/en\/om-domenenavn\/regelverk-for-no\/vedlegg-c\/\n+\/\/ Norid category second-level domains managed by parties other than Norid : https:\/\/www.norid.no\/en\/om-domenenavn\/regelverk-for-no\/vedlegg-d\/\n+\/\/ RSS feed: https:\/\/teknisk.norid.no\/en\/feed\/\n@@ -4688,1 +4720,1 @@\n-\/\/ Norid generic domains : http:\/\/www.norid.no\/regelverk\/vedlegg-c.en.html\n+\/\/ Norid category second level domains : https:\/\/www.norid.no\/en\/om-domenenavn\/regelverk-for-no\/vedlegg-c\/\n@@ -4696,1 +4728,1 @@\n-\/\/ Non-Norid generic domains : http:\/\/www.norid.no\/regelverk\/vedlegg-d.en.html\n+\/\/ Norid category second-level domains managed by parties other than Norid : https:\/\/www.norid.no\/en\/om-domenenavn\/regelverk-for-no\/vedlegg-d\/\n@@ -4702,1 +4734,1 @@\n-\/\/ no geographical names : http:\/\/www.norid.no\/regelverk\/vedlegg-b.en.html\n+\/\/ Norid geographical second level domains : https:\/\/www.norid.no\/en\/om-domenenavn\/regelverk-for-no\/vedlegg-b\/\n@@ -5831,1 +5863,1 @@\n-\/\/ pt : http:\/\/online.dns.pt\/dns\/start_dns\n+\/\/ pt : https:\/\/www.dns.pt\/en\/domain\/pt-terms-and-conditions-registration-rules\/\n@@ -6068,0 +6100,1 @@\n+me.ss\n@@ -6070,0 +6103,1 @@\n+sch.ss\n@@ -6078,1 +6112,0 @@\n-gov.st\n@@ -6183,2 +6216,2 @@\n-\/\/ tn : https:\/\/en.wikipedia.org\/wiki\/.tn\n-\/\/ http:\/\/whois.ati.tn\/\n+\/\/ tn : http:\/\/www.registre.tn\/fr\/\n+\/\/ https:\/\/whois.ati.tn\/\n@@ -6191,0 +6224,1 @@\n+info.tn\n@@ -6192,0 +6226,1 @@\n+mincom.tn\n@@ -6195,1 +6230,0 @@\n-info.tn\n@@ -6198,8 +6232,0 @@\n-edunet.tn\n-rnrt.tn\n-rns.tn\n-rnu.tn\n-mincom.tn\n-agrinet.tn\n-defense.tn\n-turen.tn\n@@ -6330,1 +6356,0 @@\n-dominic.ua\n@@ -6696,1 +6721,1 @@\n-\/\/ Submitted by registry\n+\/\/ Submitted by registry nic@nic.ve and nicve@conatel.gob.ve\n@@ -6699,0 +6724,1 @@\n+bib.ve\n@@ -6710,0 +6736,1 @@\n+nom.ve\n@@ -6711,0 +6738,1 @@\n+rar.ve\n@@ -6789,0 +6817,3 @@\n+\/\/ xn--mgbcpq6gpa1a (\"albahrain\", Arabic) : BH\n+البحرين\n+\n@@ -6921,0 +6952,3 @@\n+\/\/ xn--q7ce6a (\"Lao\", Lao) : LA\n+ລາວ\n+\n@@ -6922,1 +6956,1 @@\n-\/\/ http:\/\/nic.lk\n+\/\/ https:\/\/nic.lk\n@@ -6926,1 +6960,1 @@\n-\/\/ http:\/\/nic.lk\n+\/\/ https:\/\/nic.lk\n@@ -7046,1 +7080,7 @@\n-*.ye\n+ye\n+com.ye\n+edu.ye\n+gov.ye\n+net.ye\n+mil.ye\n+org.ye\n@@ -7095,1 +7135,1 @@\n-\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2020-04-02T18:20:31Z\n+\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2021-11-13T15:12:42Z\n@@ -7121,1 +7161,1 @@\n-\/\/ abogado : 2014-04-24 Minds + Machines Group Limited\n+\/\/ abogado : 2014-04-24 Registry Services, LLC\n@@ -7178,3 +7218,0 @@\n-\/\/ aigo : 2015-08-06 aigo Digital Technology Co,Ltd.\n-aigo\n-\n@@ -7244,1 +7281,1 @@\n-\/\/ anquan : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.\n+\/\/ anquan : 2015-01-08 Beijing Qihu Keji Co., Ltd.\n@@ -7304,1 +7341,1 @@\n-\/\/ audio : 2014-03-20 Uniregistry, Corp.\n+\/\/ audio : 2014-03-20 UNR Corp.\n@@ -7313,1 +7350,1 @@\n-\/\/ auto : 2014-11-13 Cars Registry Limited\n+\/\/ auto : 2014-11-13 XYZ.COM LLC\n@@ -7316,1 +7353,1 @@\n-\/\/ autos : 2014-01-09 DERAutos, LLC\n+\/\/ autos : 2014-01-09 XYZ.COM LLC\n@@ -7322,1 +7359,1 @@\n-\/\/ aws : 2015-06-25 Amazon Registry Services, Inc.\n+\/\/ aws : 2015-06-25 AWS Registry LLC\n@@ -7325,1 +7362,1 @@\n-\/\/ axa : 2013-12-19 AXA SA\n+\/\/ axa : 2013-12-19 AXA Group Operations SAS\n@@ -7400,1 +7437,1 @@\n-\/\/ beer : 2014-01-09 Minds + Machines Group Limited\n+\/\/ beer : 2014-01-09 Registry Services, LLC\n@@ -7442,1 +7479,1 @@\n-\/\/ blackfriday : 2014-01-16 Uniregistry, Corp.\n+\/\/ blackfriday : 2014-01-16 UNR Corp.\n@@ -7466,1 +7503,1 @@\n-\/\/ boats : 2014-12-04 DERBoats, LLC\n+\/\/ boats : 2014-12-04 XYZ.COM LLC\n@@ -7505,1 +7542,1 @@\n-\/\/ box : 2015-11-12 .BOX INC.\n+\/\/ box : 2015-11-12 Intercap Registry Inc.\n@@ -7517,1 +7554,1 @@\n-\/\/ broker : 2014-12-11 Dotbroker Registry Limited\n+\/\/ broker : 2014-12-11 Dog Beach, LLC\n@@ -7589,1 +7626,1 @@\n-\/\/ car : 2015-01-22 Cars Registry Limited\n+\/\/ car : 2015-01-22 XYZ.COM LLC\n@@ -7607,1 +7644,1 @@\n-\/\/ cars : 2014-11-13 Cars Registry Limited\n+\/\/ cars : 2014-11-13 XYZ.COM LLC\n@@ -7610,1 +7647,1 @@\n-\/\/ casa : 2013-11-21 Minds + Machines Group Limited\n+\/\/ casa : 2013-11-21 Registry Services, LLC\n@@ -7613,1 +7650,1 @@\n-\/\/ case : 2015-09-03 CNH Industrial N.V.\n+\/\/ case : 2015-09-03 Helium TLDs Ltd\n@@ -7616,3 +7653,0 @@\n-\/\/ caseih : 2015-09-03 CNH Industrial N.V.\n-caseih\n-\n@@ -7643,3 +7677,0 @@\n-\/\/ ceb : 2015-04-09 The Corporate Executive Board Company\n-ceb\n-\n@@ -7658,1 +7689,1 @@\n-\/\/ cfd : 2014-12-11 DotCFD Registry Limited\n+\/\/ cfd : 2014-12-11 ShortDot SA\n@@ -7682,1 +7713,1 @@\n-\/\/ christmas : 2013-11-21 Uniregistry, Corp.\n+\/\/ christmas : 2013-11-21 UNR Corp.\n@@ -7721,1 +7752,1 @@\n-\/\/ click : 2014-06-05 Uniregistry, Corp.\n+\/\/ click : 2014-06-05 UNR Corp.\n@@ -7736,1 +7767,1 @@\n-\/\/ club : 2013-11-08 .CLUB DOMAINS, LLC\n+\/\/ club : 2013-11-08 Registry Services, LLC\n@@ -7793,1 +7824,1 @@\n-\/\/ cooking : 2013-11-21 Minds + Machines Group Limited\n+\/\/ cooking : 2013-11-21 Registry Services, LLC\n@@ -7826,1 +7857,1 @@\n-\/\/ creditunion : 2015-01-22 CUNA Performance Resources, LLC\n+\/\/ creditunion : 2015-01-22 DotCooperation LLC\n@@ -7883,1 +7914,1 @@\n-\/\/ dds : 2015-05-07 Minds + Machines Group Limited\n+\/\/ dds : 2015-05-07 Registry Services, LLC\n@@ -7922,1 +7953,1 @@\n-\/\/ design : 2014-11-07 Top Level Design, LLC\n+\/\/ design : 2014-11-07 Registry Services, LLC\n@@ -7934,1 +7965,1 @@\n-\/\/ diet : 2014-06-26 Uniregistry, Corp.\n+\/\/ diet : 2014-06-26 UNR Corp.\n@@ -7994,1 +8025,1 @@\n-\/\/ dupont : 2015-06-25 E. I. du Pont de Nemours and Company\n+\/\/ dupont : 2015-06-25 DuPont Specialty Products USA, LLC\n@@ -8057,3 +8088,0 @@\n-\/\/ esurance : 2015-07-23 Esurance Insurance Company\n-esurance\n-\n@@ -8114,1 +8142,1 @@\n-\/\/ fashion : 2014-07-03 Minds + Machines Group Limited\n+\/\/ fashion : 2014-07-03 Registry Services, LLC\n@@ -8165,1 +8193,1 @@\n-\/\/ fishing : 2013-11-21 Minds + Machines Group Limited\n+\/\/ fishing : 2013-11-21 Registry Services, LLC\n@@ -8168,1 +8196,1 @@\n-\/\/ fit : 2014-11-07 Minds + Machines Group Limited\n+\/\/ fit : 2014-11-07 Registry Services, LLC\n@@ -8174,1 +8202,1 @@\n-\/\/ flickr : 2015-04-02 Yahoo! Domain Services Inc.\n+\/\/ flickr : 2015-04-02 Flickr, Inc.\n@@ -8186,1 +8214,1 @@\n-\/\/ flowers : 2014-10-09 Uniregistry, Corp.\n+\/\/ flowers : 2014-10-09 UNR Corp.\n@@ -8207,1 +8235,1 @@\n-\/\/ forex : 2014-12-11 Dotforex Registry Limited\n+\/\/ forex : 2014-12-11 Dog Beach, LLC\n@@ -8246,4 +8274,1 @@\n-\/\/ fujixerox : 2015-07-23 Xerox DNHC LLC\n-fujixerox\n-\n-\/\/ fun : 2016-01-14 DotSpace Inc.\n+\/\/ fun : 2016-01-14 Radix FZC\n@@ -8276,1 +8301,1 @@\n-\/\/ game : 2015-05-28 Uniregistry, Corp.\n+\/\/ game : 2015-05-28 UNR Corp.\n@@ -8285,1 +8310,1 @@\n-\/\/ garden : 2014-06-26 Minds + Machines Group Limited\n+\/\/ garden : 2014-06-26 Registry Services, LLC\n@@ -8414,1 +8439,1 @@\n-\/\/ guitars : 2013-11-14 Uniregistry, Corp.\n+\/\/ guitars : 2013-11-14 UNR Corp.\n@@ -8447,1 +8472,1 @@\n-\/\/ help : 2014-06-26 Uniregistry, Corp.\n+\/\/ help : 2014-06-26 UNR Corp.\n@@ -8462,1 +8487,1 @@\n-\/\/ hiphop : 2014-03-06 Uniregistry, Corp.\n+\/\/ hiphop : 2014-03-06 UNR Corp.\n@@ -8471,1 +8496,1 @@\n-\/\/ hiv : 2014-03-13 Uniregistry, Corp.\n+\/\/ hiv : 2014-03-13 UNR Corp.\n@@ -8492,1 +8517,1 @@\n-\/\/ homes : 2014-01-09 DERHomes, LLC\n+\/\/ homes : 2014-01-09 XYZ.COM LLC\n@@ -8501,1 +8526,1 @@\n-\/\/ horse : 2013-11-21 Minds + Machines Group Limited\n+\/\/ horse : 2013-11-21 Registry Services, LLC\n@@ -8507,1 +8532,1 @@\n-\/\/ host : 2014-04-17 DotHost Inc.\n+\/\/ host : 2014-04-17 Radix FZC\n@@ -8510,1 +8535,1 @@\n-\/\/ hosting : 2014-05-29 Uniregistry, Corp.\n+\/\/ hosting : 2014-05-29 UNR Corp.\n@@ -8600,3 +8625,0 @@\n-\/\/ intel : 2015-08-06 Intel Corporation\n-intel\n-\n@@ -8633,3 +8655,0 @@\n-\/\/ iveco : 2015-09-03 CNH Industrial N.V.\n-iveco\n-\n@@ -8645,3 +8664,0 @@\n-\/\/ jcp : 2015-04-23 JCP Media, Inc.\n-jcp\n-\n@@ -8684,1 +8700,1 @@\n-\/\/ juegos : 2014-03-20 Uniregistry, Corp.\n+\/\/ juegos : 2014-03-20 UNR Corp.\n@@ -8711,0 +8727,3 @@\n+\/\/ kids : 2021-08-13 DotKids Foundation Limited\n+kids\n+\n@@ -8789,1 +8808,1 @@\n-\/\/ law : 2015-01-22 LW TLD Limited\n+\/\/ law : 2015-01-22 Registry Services, LLC\n@@ -8795,1 +8814,1 @@\n-\/\/ lds : 2014-03-20 IRI Domain Management, LLC (\"Applicant\")\n+\/\/ lds : 2014-03-20 IRI Domain Management, LLC\n@@ -8852,1 +8871,1 @@\n-\/\/ link : 2013-11-14 Uniregistry, Corp.\n+\/\/ link : 2013-11-14 UNR Corp.\n@@ -8870,1 +8889,1 @@\n-\/\/ llp : 2019-08-26 Dot Registry LLC\n+\/\/ llp : 2019-08-26 UNR Corp.\n@@ -8888,1 +8907,1 @@\n-\/\/ lol : 2015-01-30 Uniregistry, Corp.\n+\/\/ lol : 2015-01-30 UNR Corp.\n@@ -8918,4 +8937,1 @@\n-\/\/ lupin : 2014-11-07 LUPIN LIMITED\n-lupin\n-\n-\/\/ luxe : 2014-01-09 Minds + Machines Group Limited\n+\/\/ luxe : 2014-01-09 Registry Services, LLC\n@@ -8960,1 +8976,1 @@\n-\/\/ markets : 2014-12-11 Dotmarkets Registry Limited\n+\/\/ markets : 2014-12-11 Dog Beach, LLC\n@@ -9008,3 +9024,0 @@\n-\/\/ metlife : 2015-05-07 MetLife Services and Solutions, LLC\n-metlife\n-\n@@ -9050,1 +9063,1 @@\n-\/\/ mom : 2015-04-16 Uniregistry, Corp.\n+\/\/ mom : 2015-04-16 UNR Corp.\n@@ -9062,1 +9075,1 @@\n-\/\/ mormon : 2013-12-05 IRI Domain Management, LLC (\"Applicant\")\n+\/\/ mormon : 2013-12-05 IRI Domain Management, LLC\n@@ -9074,1 +9087,1 @@\n-\/\/ motorcycles : 2014-01-09 DERMotorcycles, LLC\n+\/\/ motorcycles : 2014-01-09 XYZ.COM LLC\n@@ -9092,0 +9105,3 @@\n+\/\/ music : 2021-05-04 DotMusic Limited\n+music\n+\n@@ -9101,3 +9117,0 @@\n-\/\/ nationwide : 2015-07-23 Nationwide Mutual Insurance Company\n-nationwide\n-\n@@ -9125,1 +9138,1 @@\n-\/\/ neustar : 2013-12-05 Registry Services, LLC\n+\/\/ neustar : 2013-12-05 NeuStar, Inc.\n@@ -9131,3 +9144,0 @@\n-\/\/ newholland : 2015-09-03 CNH Industrial N.V.\n-newholland\n-\n@@ -9179,1 +9189,1 @@\n-\/\/ norton : 2014-12-04 Symantec Corporation\n+\/\/ norton : 2014-12-04 NortonLifeLock Inc.\n@@ -9206,1 +9216,1 @@\n-\/\/ observer : 2015-04-30 Top Level Spectrum, Inc.\n+\/\/ observer : 2015-04-30 Dog Beach, LLC\n@@ -9239,1 +9249,1 @@\n-\/\/ onl : 2013-09-16 I-Registry Ltd.\n+\/\/ onl : 2013-09-16 iRegistry GmbH\n@@ -9242,1 +9252,1 @@\n-\/\/ online : 2015-01-15 DotOnline Inc.\n+\/\/ online : 2015-01-15 Radix FZC\n@@ -9245,3 +9255,0 @@\n-\/\/ onyourside : 2015-07-23 Nationwide Mutual Insurance Company\n-onyourside\n-\n@@ -9326,1 +9333,1 @@\n-\/\/ photo : 2013-11-14 Uniregistry, Corp.\n+\/\/ photo : 2013-11-14 UNR Corp.\n@@ -9338,1 +9345,1 @@\n-\/\/ pics : 2013-11-14 Uniregistry, Corp.\n+\/\/ pics : 2013-11-14 UNR Corp.\n@@ -9401,1 +9408,1 @@\n-\/\/ press : 2014-04-03 DotPress Inc.\n+\/\/ press : 2014-04-03 Radix FZC\n@@ -9425,1 +9432,1 @@\n-\/\/ property : 2014-05-22 Uniregistry, Corp.\n+\/\/ property : 2014-05-22 UNR Corp.\n@@ -9452,3 +9459,0 @@\n-\/\/ qvc : 2015-07-30 QVC, Inc.\n-qvc\n-\n@@ -9473,1 +9477,1 @@\n-\/\/ realty : 2015-03-19 Fegistry, LLC\n+\/\/ realty : 2015-03-19 Dog Beach, LLC\n@@ -9536,1 +9540,1 @@\n-\/\/ rich : 2013-11-21 I-Registry Ltd.\n+\/\/ rich : 2013-11-21 iRegistry GmbH\n@@ -9545,3 +9549,0 @@\n-\/\/ rightathome : 2015-07-23 Johnson Shareholdings, Inc.\n-rightathome\n-\n@@ -9557,3 +9558,0 @@\n-\/\/ rmit : 2015-11-19 Royal Melbourne Institute of Technology\n-rmit\n-\n@@ -9566,1 +9564,1 @@\n-\/\/ rodeo : 2013-12-19 Minds + Machines Group Limited\n+\/\/ rodeo : 2013-12-19 Registry Services, LLC\n@@ -9644,1 +9642,1 @@\n-\/\/ sbs : 2014-11-07 SPECIAL BROADCASTING SERVICE CORPORATION\n+\/\/ sbs : 2014-11-07 ShortDot SA\n@@ -9677,3 +9675,0 @@\n-\/\/ scor : 2014-10-31 SCOR SE\n-scor\n-\n@@ -9719,1 +9714,1 @@\n-\/\/ sexy : 2013-09-11 Uniregistry, Corp.\n+\/\/ sexy : 2013-09-11 UNR Corp.\n@@ -9752,1 +9747,1 @@\n-\/\/ shouji : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.\n+\/\/ shouji : 2015-01-08 Beijing Qihu Keji Co., Ltd.\n@@ -9761,3 +9756,0 @@\n-\/\/ shriram : 2014-01-23 Shriram Capital Ltd.\n-shriram\n-\n@@ -9773,1 +9765,1 @@\n-\/\/ site : 2015-01-15 DotSite Inc.\n+\/\/ site : 2015-01-15 Radix FZC\n@@ -9833,1 +9825,1 @@\n-\/\/ space : 2014-04-03 DotSpace Inc.\n+\/\/ space : 2014-04-03 Radix FZC\n@@ -9842,3 +9834,0 @@\n-\/\/ spreadbetting : 2014-12-11 Dotspreadbetting Registry Limited\n-spreadbetting\n-\n@@ -9875,1 +9864,1 @@\n-\/\/ store : 2015-04-09 DotStore Inc.\n+\/\/ store : 2015-04-09 Radix FZC\n@@ -9902,1 +9891,1 @@\n-\/\/ surf : 2014-01-09 Minds + Machines Group Limited\n+\/\/ surf : 2014-01-09 Registry Services, LLC\n@@ -9914,3 +9903,0 @@\n-\/\/ swiftcover : 2015-07-23 Swiftcover Insurance Services Limited\n-swiftcover\n-\n@@ -9923,3 +9909,0 @@\n-\/\/ symantec : 2014-12-04 Symantec Corporation\n-symantec\n-\n@@ -9950,1 +9933,1 @@\n-\/\/ tattoo : 2013-08-30 Uniregistry, Corp.\n+\/\/ tattoo : 2013-08-30 UNR Corp.\n@@ -9968,1 +9951,1 @@\n-\/\/ tech : 2015-01-30 Personals TLD Inc.\n+\/\/ tech : 2015-01-30 Radix FZC\n@@ -9995,1 +9978,1 @@\n-\/\/ tickets : 2015-02-05 Accent Media Limited\n+\/\/ tickets : 2015-02-05 XYZ.COM LLC\n@@ -10061,1 +10044,1 @@\n-\/\/ trading : 2014-12-11 Dottrading Registry Limited\n+\/\/ trading : 2014-12-11 Dog Beach, LLC\n@@ -10079,1 +10062,1 @@\n-\/\/ trust : 2014-10-16 NCC Group Inc.\n+\/\/ trust : 2014-10-16 UNR Corp.\n@@ -10112,1 +10095,1 @@\n-\/\/ uno : 2013-09-11 DotSite Inc.\n+\/\/ uno : 2013-09-11 Radix FZC\n@@ -10163,1 +10146,1 @@\n-\/\/ vip : 2015-01-22 Minds + Machines Group Limited\n+\/\/ vip : 2015-01-22 Registry Services, LLC\n@@ -10184,1 +10167,1 @@\n-\/\/ vodka : 2013-12-19 Minds + Machines Group Limited\n+\/\/ vodka : 2013-12-19 Registry Services, LLC\n@@ -10226,1 +10209,1 @@\n-\/\/ watches : 2014-12-22 Richemont DNS Inc.\n+\/\/ watches : 2014-12-22 Afilias Limited\n@@ -10241,1 +10224,1 @@\n-\/\/ website : 2014-04-03 DotWebsite Inc.\n+\/\/ website : 2014-04-03 Radix FZC\n@@ -10244,4 +10227,1 @@\n-\/\/ wed : 2013-10-01 Atgron, Inc.\n-wed\n-\n-\/\/ wedding : 2014-04-24 Minds + Machines Group Limited\n+\/\/ wedding : 2014-04-24 Registry Services, LLC\n@@ -10289,1 +10269,1 @@\n-\/\/ work : 2013-12-19 Minds + Machines Group Limited\n+\/\/ work : 2013-12-19 Registry Services, LLC\n@@ -10316,1 +10296,1 @@\n-\/\/ xihuan : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.\n+\/\/ xihuan : 2015-01-08 Beijing Qihu Keji Co., Ltd.\n@@ -10340,3 +10320,0 @@\n-\/\/ xn--3oq18vl8pn36a : 2015-07-02 Volkswagen (China) Investment Co., Ltd.\n-大众汽车\n-\n@@ -10352,1 +10329,1 @@\n-\/\/ xn--4gbrim : 2013-10-04 Fans TLD Limited\n+\/\/ xn--4gbrim : 2013-10-04 Helium TLDs Ltd\n@@ -10457,1 +10434,1 @@\n-\/\/ xn--g2xx48c : 2015-01-30 Minds + Machines Group Limited\n+\/\/ xn--g2xx48c : 2015-01-30 Nawang Heli(Xiamen) Network Service Co., LTD.\n@@ -10493,3 +10470,0 @@\n-\/\/ xn--kpu716f : 2014-12-22 Richemont DNS Inc.\n-手表\n-\n@@ -10550,3 +10524,0 @@\n-\/\/ xn--pbt977c : 2014-12-22 Richemont DNS Inc.\n-珠宝\n-\n@@ -10610,1 +10581,1 @@\n-\/\/ yachts : 2014-01-09 DERYachts, LLC\n+\/\/ yachts : 2014-01-09 XYZ.COM LLC\n@@ -10613,1 +10584,1 @@\n-\/\/ yahoo : 2015-04-02 Yahoo! Domain Services Inc.\n+\/\/ yahoo : 2015-04-02 Oath Inc.\n@@ -10625,1 +10596,1 @@\n-\/\/ yoga : 2014-05-29 Minds + Machines Group Limited\n+\/\/ yoga : 2014-05-29 Registry Services, LLC\n@@ -10637,1 +10608,1 @@\n-\/\/ yun : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.\n+\/\/ yun : 2015-01-08 Beijing Qihu Keji Co., Ltd.\n@@ -10669,0 +10640,11 @@\n+\/\/ 611coin : https:\/\/611project.org\/\n+611.to\n+\n+\/\/ Aaron Marais' Gitlab pages: https:\/\/lab.aaronleem.co.za\n+\/\/ Submitted by Aaron Marais <its_me@aaronleem.co.za>\n+graphox.us\n+\n+\/\/ accesso Technology Group, plc. : https:\/\/accesso.com\/\n+\/\/ Submitted by accesso Team <accessoecommerce@accesso.com>\n+*.devcdnaccesso.com\n+\n@@ -10670,1 +10652,1 @@\n-\/\/ Submitted by Ian Boston <boston@adobe.com>\n+\/\/ Submitted by Ian Boston <boston@adobe.com> and Lars Trieloff <trieloff@adobe.com>\n@@ -10672,1 +10654,0 @@\n-adobeaemcloud.net\n@@ -10674,0 +10655,4 @@\n+hlx.live\n+adobeaemcloud.net\n+hlx.page\n+hlx3.page\n@@ -10688,0 +10673,4 @@\n+\/\/ all-inkl.com : https:\/\/all-inkl.com\n+\/\/ Submitted by Werner Kaltofen <wk@all-inkl.com>\n+kasserver.com\n+\n@@ -10735,0 +10724,4 @@\n+\/\/ Amazon Global Accelerator : https:\/\/aws.amazon.com\/global-accelerator\/\n+\/\/ Submitted by Daniel Massaguer <psl-maintainers@amazon.com>\n+awsglobalaccelerator.com\n+\n@@ -10792,4 +10785,0 @@\n-\/\/ Amsterdam Wireless: https:\/\/www.amsterdamwireless.nl\/\n-\/\/ Submitted by Imre Jonk <hostmaster@amsterdamwireless.nl>\n-amsw.nl\n-\n@@ -10805,0 +10794,13 @@\n+\/\/ Apphud : https:\/\/apphud.com\n+\/\/ Submitted by Alexander Selivanov <alex@apphud.com>\n+siiites.com\n+\n+\/\/ Appspace : https:\/\/www.appspace.com\n+\/\/ Submitted by Appspace Security Team <security@appspace.com>\n+appspacehosted.com\n+appspaceusercontent.com\n+\n+\/\/ Appudo UG (haftungsbeschränkt) : https:\/\/www.appudo.com\n+\/\/ Submitted by Alexander Hochbaum <admin@appudo.com>\n+appudo.net\n+\n@@ -10830,0 +10832,4 @@\n+\/\/ Atlassian : https:\/\/atlassian.com\n+\/\/ Submitted by Sam Smyth <devloop@atlassian.com>\n+cdn.prod.atlassian-dev.net\n+\n@@ -10834,0 +10840,4 @@\n+\/\/ AVStack Pte. Ltd. : https:\/\/avstack.io\n+\/\/ Submitted by Jasper Hugo <jasper@avstack.io>\n+onavstack.net\n+\n@@ -10839,0 +10849,4 @@\n+\/\/ AZ.pl sp. z.o.o: https:\/\/az.pl\n+\/\/ Submited by Krzysztof Wolski <krzysztof.wolski@home.eu>\n+ecommerce-shop.pl\n+\n@@ -10851,0 +10865,5 @@\n+\/\/ University of Banja Luka : https:\/\/unibl.org\n+\/\/ Domains for Republic of Srpska administrative entity.\n+\/\/ Submitted by Marko Ivanovic <kormang@hotmail.rs>\n+rs.ba\n+\n@@ -10852,1 +10871,2 @@\n-\/\/ Submitted by Gabor Kozma <info@banzaicloud.com>\n+\/\/ Submitted by Janos Matyas <info@banzaicloud.com>\n+*.banzai.cloud\n@@ -10854,0 +10874,2 @@\n+*.backyards.banzaicloud.io\n+\n@@ -10863,0 +10885,4 @@\n+\/\/ Bitbucket : http:\/\/bitbucket.org\n+\/\/ Submitted by Andy Ortlieb <aortlieb@atlassian.com>\n+bitbucket.io\n+\n@@ -10867,0 +10893,8 @@\n+\/\/ Blatech : http:\/\/www.blatech.net\n+\/\/ Submitted by Luke Bratch <luke@bratch.co.uk>\n+of.je\n+\n+\/\/ Blue Bite, LLC : https:\/\/bluebite.com\n+\/\/ Submitted by Joshua Weiss <admin.engineering@bluebite.com>\n+bluebite.io\n+\n@@ -10871,0 +10905,4 @@\n+\/\/ Boutir : https:\/\/www.boutir.com\n+\/\/ Submitted by Eric Ng Ka Ka <ngkaka@boutir.com>\n+boutir.com\n+\n@@ -10884,0 +10922,4 @@\n+\/\/ Brendly : https:\/\/brendly.rs\n+\/\/ Submitted by Dusan Radovanovic <dusan.radovanovic@brendly.rs>\n+shop.brendly.rs\n+\n@@ -10894,0 +10936,4 @@\n+\/\/ Caf.js Labs LLC : https:\/\/www.cafjs.com\n+\/\/ Submitted by Antonio Lain <antlai@cafjs.com>\n+cafjs.com\n+\n@@ -10900,0 +10946,2 @@\n+drr.ac\n+uwu.ai\n@@ -10902,1 +10950,1 @@\n-uwu.ai\n+ju.mp\n@@ -10907,1 +10955,0 @@\n-ar.com\n@@ -10914,1 +10961,0 @@\n-gb.com\n@@ -10916,1 +10962,0 @@\n-hu.com\n@@ -10920,1 +10965,0 @@\n-kr.com\n@@ -10922,2 +10966,0 @@\n-no.com\n-qc.com\n@@ -10930,1 +10972,0 @@\n-uy.com\n@@ -10934,0 +10975,9 @@\n+\/\/ No longer operated by CentralNic, these entries should be adopted and\/or removed by current operators\n+\/\/ Submitted by Gavin Brown <gavin.brown@centralnic.com>\n+ar.com\n+hu.com\n+kr.com\n+no.com\n+qc.com\n+uy.com\n+\n@@ -10945,0 +10995,1 @@\n+web.in\n@@ -10954,0 +11005,10 @@\n+\/\/ Roar Domains LLC : https:\/\/roar.basketball\/\n+\/\/ Submitted by Gavin Brown <gavin.brown@centralnic.com>\n+aus.basketball\n+nz.basketball\n+\n+\/\/ BRS Media : https:\/\/brsmedia.com\/\n+\/\/ Submitted by Gavin Brown <gavin.brown@centralnic.com>\n+radio.am\n+radio.fm\n+\n@@ -10961,3 +11022,3 @@\n-\/\/ Citrix : https:\/\/citrix.com\n-\/\/ Submitted by Alex Stoddard <alex.stoddard@citrix.com>\n-xenapponazure.com\n+\/\/ Cityhost LLC  : https:\/\/cityhost.ua\n+\/\/ Submitted by Maksym Rivtin <support@cityhost.net.ua>\n+cx.ua\n@@ -10970,4 +11031,0 @@\n-\/\/ ClearVox : http:\/\/www.clearvox.nl\/\n-\/\/ Submitted by Leon Rowland <leon@clearvox.nl>\n-virtueeldomein.nl\n-\n@@ -10979,1 +11036,3 @@\n-\/\/ Submitted by Colin Sidoti <colin@clerk.dev>\n+\/\/ Submitted by Colin Sidoti <systems@clerk.dev>\n+clerk.app\n+clerkstage.app\n@@ -10981,0 +11040,1 @@\n+*.lclstage.dev\n@@ -10982,0 +11042,1 @@\n+*.stgstage.dev\n@@ -10983,3 +11044,3 @@\n-\/\/ Clic2000 : https:\/\/clic2000.fr\n-\/\/ Submitted by Mathilde Blanchemanche <mathilde@clic2000.fr>\n-clic2000.net\n+\/\/ ClickRising : https:\/\/clickrising.com\/\n+\/\/ Submitted by Umut Gumeli <infrastructure-publicsuffixlist@clickrising.com>\n+clickrising.net\n@@ -11007,2 +11068,2 @@\n-\/\/ Submitted by Philip Langdale <security@cloudera.com>\n-cloudera.site\n+\/\/ Submitted by Kedarnath Waikar <security@cloudera.com>\n+*.cloudera.site\n@@ -11011,1 +11072,2 @@\n-\/\/ Submitted by Jake Riesterer <publicsuffixlist@cloudflare.com>\n+\/\/ Submitted by Cloudflare Team <publicsuffixlist@cloudflare.com>\n+pages.dev\n@@ -11052,4 +11114,0 @@\n-\/\/ Cloudeity Inc : https:\/\/cloudeity.com\n-\/\/ Submitted by Stefan Dimitrov <contact@cloudeity.com>\n-cloudeity.net\n-\n@@ -11119,0 +11177,6 @@\n+\/\/ Danger Science Group: https:\/\/dangerscience.com\/\n+\/\/ Submitted by Skylar MacDonald <skylar@dangerscience.com>\n+fnwk.site\n+folionetwork.site\n+platform0.app\n+\n@@ -11154,0 +11218,5 @@\n+\/\/ DataDetect, LLC. : https:\/\/datadetect.com\n+\/\/ Submitted by Andrew Banchich <abanchich@sceven.com>\n+demo.datadetect.com\n+instance.datadetect.com\n+\n@@ -11158,0 +11227,4 @@\n+\/\/ DDNS5 : https:\/\/ddns5.com\n+\/\/ Submitted by Cameron Elliott <cameron@cameronelliott.com>\n+ddns5.com\n+\n@@ -11162,0 +11235,5 @@\n+\/\/ Deno Land Inc : https:\/\/deno.com\/\n+\/\/ Submitted by Luca Casonato <hostmaster@deno.com>\n+deno.dev\n+deno-staging.dev\n+\n@@ -11166,0 +11244,9 @@\n+\/\/ Diher Solutions : https:\/\/diher.solutions\n+\/\/ Submitted by Didi Hermawan <mail@diher.solutions>\n+*.rss.my.id\n+*.diher.solutions\n+\n+\/\/ DNS Africa Ltd https:\/\/dns.business\n+\/\/ Submitted by Calvin Browne <calvin@dns.business>\n+jozi.biz\n+\n@@ -11179,0 +11266,4 @@\n+\/\/ DreamCommerce : https:\/\/shoper.pl\/\n+\/\/ Submitted by Konrad Kotarba <konrad.kotarba@dreamcommerce.com>\n+shoparena.pl\n+\n@@ -11196,0 +11287,7 @@\n+\/\/ Bip : https:\/\/bip.sh\n+\/\/ Submitted by Joel Kennedy <joel@bip.sh>\n+bip.sh\n+\n+\/\/ bitbridge.net : Submitted by Craig Welch, abeliidev@gmail.com\n+bitbridge.net\n+\n@@ -11499,0 +11597,8 @@\n+\/\/ DigitalOcean App Platform : https:\/\/www.digitalocean.com\/products\/app-platform\/\n+\/\/ Submitted by Braxton Huggins <psl-maintainers@digitalocean.com>\n+ondigitalocean.app\n+\n+\/\/ DigitalOcean Spaces : https:\/\/www.digitalocean.com\/products\/spaces\/\n+\/\/ Submitted by Robin H. Johnson <psl-maintainers@digitalocean.com>\n+*.digitaloceanspaces.com\n+\n@@ -11531,0 +11637,10 @@\n+\/\/ eero : https:\/\/eero.com\/\n+\/\/ Submitted by Yue Kang <eero-dynamic-dns@amazon.com>\n+eero.online\n+eero-stage.online\n+\n+\/\/ Elementor : Elementor Ltd.\n+\/\/ Submitted by Anton Barkan <antonb@elementor.com>\n+elementor.cloud\n+elementor.cool\n+\n@@ -11538,0 +11654,1 @@\n+tuleap-partners.com\n@@ -11544,5 +11661,0 @@\n-\/\/ Enonic : http:\/\/enonic.com\/\n-\/\/ Submitted by Erik Kaareng-Sunde <esu@enonic.com>\n-enonic.io\n-customer.enonic.io\n-\n@@ -11608,0 +11720,4 @@\n+\/\/ Eurobyte : https:\/\/eurobyte.ru\n+\/\/ Submitted by Evgeniy Subbotin <e.subbotin@eurobyte.ru>\n+eurodir.ru\n+\n@@ -11718,0 +11834,1 @@\n+edgecompute.app\n@@ -11731,1 +11848,0 @@\n-fastpanel.direct\n@@ -11733,1 +11849,1 @@\n-myfast.space\n+fastvps.host\n@@ -11736,5 +11852,1 @@\n-fastvps.host\n-\n-\/\/ Featherhead : https:\/\/featherhead.xyz\/\n-\/\/ Submitted by Simon Menke <simon@featherhead.xyz>\n-fhapp.xyz\n+myfast.space\n@@ -11752,2 +11864,0 @@\n-conn.uk\n-copro.uk\n@@ -11756,0 +11866,3 @@\n+conn.uk\n+copro.uk\n+hosp.uk\n@@ -11761,0 +11874,4 @@\n+\/\/ FH Muenster : https:\/\/www.fh-muenster.de\n+\/\/ Submitted by Robin Naundorf <r.naundorf@fh-muenster.de>\n+fh-muenster.io\n+\n@@ -11775,0 +11892,19 @@\n+\/\/ Firewebkit : https:\/\/www.firewebkit.com\n+\/\/ Submitted by Majid Qureshi <mqureshi@amrayn.com>\n+fireweb.app\n+\n+\/\/ FLAP : https:\/\/www.flap.cloud\n+\/\/ Submitted by Louis Chemineau <louis@chmn.me>\n+flap.id\n+\n+\/\/ FlashDrive : https:\/\/flashdrive.io\n+\/\/ Submitted by Eric Chan <support@flashdrive.io>\n+onflashdrive.app\n+fldrv.com\n+\n+\/\/ fly.io: https:\/\/fly.io\n+\/\/ Submitted by Kurt Mackey <kurt@fly.io>\n+fly.dev\n+edgeapp.net\n+shw.io\n+\n@@ -11779,0 +11915,18 @@\n+\/\/ Forgerock : https:\/\/www.forgerock.com\n+\/\/ Submitted by Roderick Parr <roderick.parr@forgerock.com>\n+forgeblocks.com\n+id.forgerock.io\n+\n+\/\/ Framer : https:\/\/www.framer.com\n+\/\/ Submitted by Koen Rouwhorst <koenrh@framer.com>\n+framer.app\n+framercanvas.com\n+\n+\/\/ Frusky MEDIA&PR : https:\/\/www.frusky.de\n+\/\/ Submitted by Victor Pupynin <hallo@frusky.de>\n+*.frusky.de\n+\n+\/\/ RavPage : https:\/\/www.ravpage.co.il\n+\/\/ Submitted by Roni Horowitz <roni@responder.co.il>\n+ravpage.co.il\n+\n@@ -11796,0 +11950,8 @@\n+\/\/ freemyip.com : https:\/\/freemyip.com\n+\/\/ Submitted by Cadence <contact@freemyip.com>\n+freemyip.com\n+\n+\/\/ FunkFeuer - Verein zur Förderung freier Netze : https:\/\/www.funkfeuer.at\n+\/\/ Submitted by Daniel A. Maierhofer <vorstand@funkfeuer.at>\n+wien.funkfeuer.at\n+\n@@ -11819,0 +11981,1 @@\n+gentlentapis.com\n@@ -11820,0 +11983,9 @@\n+cdn-edges.net\n+\n+\/\/ Ghost Foundation : https:\/\/ghost.org\n+\/\/ Submitted by Matt Hanley <security@ghost.org>\n+ghost.io\n+\n+\/\/ GignoSystemJapan: http:\/\/gsj.bz\n+\/\/ Submitted by GignoSystemJapan <kakutou-ec@gsj.bz>\n+gsj.bz\n@@ -11823,1 +11995,0 @@\n-github.io\n@@ -11825,0 +11996,2 @@\n+githubpreview.dev\n+github.io\n@@ -11830,0 +12003,5 @@\n+\/\/ Gitplac.si - https:\/\/gitplac.si\n+\/\/ Submitted by Aljaž Starc <me@aljaxus.eu>\n+gitapp.si\n+gitpage.si\n+\n@@ -11834,0 +12012,9 @@\n+\/\/ Global NOG Alliance : https:\/\/nogalliance.org\/\n+\/\/ Submitted by Sander Steffann <sander@nogalliance.org>\n+nog.community\n+\n+\/\/ Globe Hosting SRL : https:\/\/www.globehosting.com\/\n+\/\/ Submitted by Gavin Brown <gavin.brown@centralnic.com>\n+co.ro\n+shop.ro\n+\n@@ -11839,1 +12026,1 @@\n-\/\/ Submitted by Tom Whitwell <tom.whitwell@digital.cabinet-office.gov.uk>\n+\/\/ Submitted by Tom Whitwell <gov-uk-paas-support@digital.cabinet-office.gov.uk>\n@@ -11843,0 +12030,4 @@\n+\/\/ GOV.UK Pay : https:\/\/www.payments.service.gov.uk\/\n+\/\/ Submitted by Richard Baker <richard.baker@digital.cabinet-office.gov.uk>\n+pymnt.uk\n+\n@@ -11850,1 +12041,0 @@\n-shop.ro\n@@ -11864,0 +12054,12 @@\n+codespot.com\n+googleapis.com\n+googlecode.com\n+pagespeedmobilizer.com\n+publishproxy.com\n+withgoogle.com\n+withyoutube.com\n+*.gateway.dev\n+cloud.goog\n+translate.goog\n+*.usercontent.goog\n+cloudfunctions.net\n@@ -11938,9 +12140,0 @@\n-cloudfunctions.net\n-cloud.goog\n-codespot.com\n-googleapis.com\n-googlecode.com\n-pagespeedmobilizer.com\n-publishproxy.com\n-withgoogle.com\n-withyoutube.com\n@@ -11948,3 +12141,3 @@\n-\/\/ Aaron Marais' Gitlab pages: https:\/\/lab.aaronleem.co.za\n-\/\/ Submitted by Aaron Marais <its_me@aaronleem.co.za>\n-graphox.us\n+\/\/ Goupile : https:\/\/goupile.fr\n+\/\/ Submitted by Niels Martignene <hello@goupile.fr>\n+goupile.fr\n@@ -11956,0 +12149,5 @@\n+\/\/ GünstigBestellen : https:\/\/günstigbestellen.de\n+\/\/ Submitted by Furkan Akkoc <info@hendelzon.de>\n+günstigbestellen.de\n+günstigliefern.de\n+\n@@ -11977,0 +12175,4 @@\n+\/\/ Heilbronn University of Applied Sciences - Faculty Informatics (GitLab Pages): https:\/\/www.hs-heilbronn.de\n+\/\/ Submitted by Richard Zowalla <mi-admin@hs-heilbronn.de>\n+pages.it.hs-heilbronn.de\n+\n@@ -11994,0 +12196,8 @@\n+\/\/ home.pl S.A.: https:\/\/home.pl\n+\/\/ Submited by Krzysztof Wolski <krzysztof.wolski@home.eu>\n+homesklep.pl\n+\n+\/\/ Hong Kong Productivity Council: https:\/\/www.hkpc.org\/\n+\/\/ Submitted by SECaaS Team <summchan@hkpc.org>\n+secaas.hk\n+\n@@ -11996,1 +12206,0 @@\n-bpl.biz\n@@ -11998,1 +12207,0 @@\n-ng.city\n@@ -12000,1 +12208,0 @@\n-ng.ink\n@@ -12006,1 +12213,1 @@\n-ng.school\n+edu.scot\n@@ -12008,0 +12215,4 @@\n+org.yt\n+\n+\/\/ HostyHosting (hostyhosting.com)\n+hostyhosting.io\n@@ -12022,0 +12233,13 @@\n+\/\/ Impertrix Solutions : <https:\/\/impertrixcdn.com>\n+\/\/ Submitted by Zhixiang Zhao <csuite@impertrix.com>\n+impertrixcdn.com\n+impertrix.com\n+\n+\/\/ Incsub, LLC: https:\/\/incsub.com\/\n+\/\/ Submitted by Aaron Edwards <sysadmins@incsub.com>\n+smushcdn.com\n+wphostedmail.com\n+wpmucdn.com\n+tempurl.host\n+wpmudev.host\n+\n@@ -12077,0 +12301,8 @@\n+\/\/ Internet-Pro, LLP: https:\/\/netangels.ru\/\n+\/\/ Submited by Vasiliy Sheredeko <piphon@gmail.com>\n+na4u.ru\n+\n+\/\/ iopsys software solutions AB : https:\/\/iopsys.eu\/\n+\/\/ Submitted by Roman Azarenko <roman.azarenko@iopsys.eu>\n+iopsys.se\n+\n@@ -12092,0 +12324,86 @@\n+\/\/ Jelastic, Inc. : https:\/\/jelastic.com\/\n+\/\/ Submited by Ihor Kolodyuk <ik@jelastic.com>\n+mel.cloudlets.com.au\n+cloud.interhostsolutions.be\n+users.scale.virtualcloud.com.br\n+mycloud.by\n+alp1.ae.flow.ch\n+appengine.flow.ch\n+es-1.axarnet.cloud\n+diadem.cloud\n+vip.jelastic.cloud\n+jele.cloud\n+it1.eur.aruba.jenv-aruba.cloud\n+it1.jenv-aruba.cloud\n+keliweb.cloud\n+cs.keliweb.cloud\n+oxa.cloud\n+tn.oxa.cloud\n+uk.oxa.cloud\n+primetel.cloud\n+uk.primetel.cloud\n+ca.reclaim.cloud\n+uk.reclaim.cloud\n+us.reclaim.cloud\n+ch.trendhosting.cloud\n+de.trendhosting.cloud\n+jele.club\n+amscompute.com\n+clicketcloud.com\n+dopaas.com\n+hidora.com\n+paas.hosted-by-previder.com\n+rag-cloud.hosteur.com\n+rag-cloud-ch.hosteur.com\n+jcloud.ik-server.com\n+jcloud-ver-jpc.ik-server.com\n+demo.jelastic.com\n+kilatiron.com\n+paas.massivegrid.com\n+jed.wafaicloud.com\n+lon.wafaicloud.com\n+ryd.wafaicloud.com\n+j.scaleforce.com.cy\n+jelastic.dogado.eu\n+fi.cloudplatform.fi\n+demo.datacenter.fi\n+paas.datacenter.fi\n+jele.host\n+mircloud.host\n+paas.beebyte.io\n+sekd1.beebyteapp.io\n+jele.io\n+cloud-fr1.unispace.io\n+jc.neen.it\n+cloud.jelastic.open.tim.it\n+jcloud.kz\n+upaas.kazteleport.kz\n+cloudjiffy.net\n+fra1-de.cloudjiffy.net\n+west1-us.cloudjiffy.net\n+jls-sto1.elastx.net\n+jls-sto2.elastx.net\n+jls-sto3.elastx.net\n+faststacks.net\n+fr-1.paas.massivegrid.net\n+lon-1.paas.massivegrid.net\n+lon-2.paas.massivegrid.net\n+ny-1.paas.massivegrid.net\n+ny-2.paas.massivegrid.net\n+sg-1.paas.massivegrid.net\n+jelastic.saveincloud.net\n+nordeste-idc.saveincloud.net\n+j.scaleforce.net\n+jelastic.tsukaeru.net\n+sdscloud.pl\n+unicloud.pl\n+mircloud.ru\n+jelastic.regruhosting.ru\n+enscaled.sg\n+jele.site\n+jelastic.team\n+orangecloud.tn\n+j.layershift.co.uk\n+phx.enscaled.us\n+mircloud.us\n+\n@@ -12100,0 +12418,4 @@\n+\/\/ Jotelulu S.L. : https:\/\/jotelulu.com\n+\/\/ Submitted by Daniel Fariña <ingenieria@jotelulu.com>\n+jotelulu.cloud\n+\n@@ -12131,0 +12453,5 @@\n+\/\/ Katholieke Universiteit Leuven: https:\/\/www.kuleuven.be\n+\/\/ Submitted by Abuse KU Leuven <abuse@kuleuven.be>\n+kuleuven.cloud\n+ezproxy.kuleuven.be\n+\n@@ -12135,0 +12462,5 @@\n+\/\/ Krellian Ltd. : https:\/\/krellian.com\n+\/\/ Submitted by Ben Francis <ben@krellian.com>\n+krellian.net\n+webthings.io\n+\n@@ -12165,4 +12497,0 @@\n-\/\/ Linki Tools UG : https:\/\/linki.tools\n-\/\/ Submitted by Paulo Matos <pmatos@linki.tools>\n-linkitools.space\n-\n@@ -12177,1 +12505,3 @@\n-nodebalancer.linode.com\n+*.nodebalancer.linode.com\n+*.linodeobjects.com\n+ip.linodeusercontent.com\n@@ -12183,0 +12513,4 @@\n+\/\/ localzone.xyz\n+\/\/ Submitted by Kenny Niehage <hello@yahe.sh>\n+localzone.xyz\n+\n@@ -12191,0 +12525,8 @@\n+\/\/ Lokalized : https:\/\/lokalized.nl\n+\/\/ Submitted by Noah Taheij <noah@lokalized.nl>\n+servers.run\n+\n+\/\/ Lõhmus Family, The\n+\/\/ Submitted by Heiki Lõhmus <hostmaster at lohmus dot me>\n+lohmus.me\n+\n@@ -12202,1 +12544,0 @@\n-uklugs.org\n@@ -12228,0 +12569,1 @@\n+barsy.ro\n@@ -12246,0 +12588,28 @@\n+\/\/ Mail Transfer Platform : https:\/\/www.neupeer.com\n+\/\/ Submitted by Li Hui <lihui@neupeer.com>\n+cn.vu\n+\n+\/\/ Maze Play: https:\/\/www.mazeplay.com\n+\/\/ Submitted by Adam Humpherys <adam@mws.dev>\n+mazeplay.com\n+\n+\/\/ mcpe.me : https:\/\/mcpe.me\n+\/\/ Submitted by Noa Heyl <hi@noa.dev>\n+mcpe.me\n+\n+\/\/ McHost : https:\/\/mchost.ru\n+\/\/ Submitted by Evgeniy Subbotin <e.subbotin@mchost.ru>\n+mcdir.me\n+mcdir.ru\n+mcpre.ru\n+vps.mcdir.ru\n+\n+\/\/ Mediatech : https:\/\/mediatech.by\n+\/\/ Submitted by Evgeniy Kozhuhovskiy <ugenk@mediatech.by>\n+mediatech.by\n+mediatech.dev\n+\n+\/\/ Medicom Health : https:\/\/medicomhealth.com\n+\/\/ Submitted by Michael Olson <molson@medicomhealth.com>\n+hra.health\n+\n@@ -12253,1 +12623,1 @@\n-cloud.metacentrum.cz\n+*.cloud.metacentrum.cz\n@@ -12270,1 +12640,1 @@\n-\/\/ Submitted by Mostafa Elzeiny <moelzein@microsoft.com>\n+\/\/ Submitted by Mitch Webster <miwebst@microsoft.com>\n@@ -12275,0 +12645,18 @@\n+azurestaticapps.net\n+centralus.azurestaticapps.net\n+eastasia.azurestaticapps.net\n+eastus2.azurestaticapps.net\n+westeurope.azurestaticapps.net\n+westus2.azurestaticapps.net\n+\n+\/\/ minion.systems : http:\/\/minion.systems\n+\/\/ Submitted by Robert Böttinger <r@minion.systems>\n+csx.cc\n+\n+\/\/ Mintere : https:\/\/mintere.com\/\n+\/\/ Submitted by Ben Aubin <security@mintere.com>\n+mintere.site\n+\n+\/\/ MobileEducation, LLC : https:\/\/joinforte.com\n+\/\/ Submitted by Grayson Martin <grayson.martin@mobileeducation.us>\n+forte.id\n@@ -12290,0 +12678,16 @@\n+\/\/ Mythic Beasts : https:\/\/www.mythic-beasts.com\n+\/\/ Submitted by Paul Cammish <kelduum@mythic-beasts.com>\n+hostedpi.com\n+customer.mythic-beasts.com\n+caracal.mythic-beasts.com\n+fentiger.mythic-beasts.com\n+lynx.mythic-beasts.com\n+ocelot.mythic-beasts.com\n+oncilla.mythic-beasts.com\n+onza.mythic-beasts.com\n+sphinx.mythic-beasts.com\n+vs.mythic-beasts.com\n+x.mythic-beasts.com\n+yali.mythic-beasts.com\n+cust.retrosnub.co.uk\n+\n@@ -12295,1 +12699,1 @@\n-\/\/ Submitted by James Stevens <registry@names.of.london> or <james@jrcs.net>\n+\/\/ Submitted by James Stevens <registry[at]names.of.london> or <publiclist[at]jrcs.net>\n@@ -12298,2 +12702,0 @@\n-on.fashion\n-of.football\n@@ -12302,0 +12704,2 @@\n+from.marketing\n+with.marketing\n@@ -12303,0 +12707,1 @@\n+repair.men\n@@ -12306,0 +12711,1 @@\n+under.one\n@@ -12307,1 +12713,2 @@\n-of.work\n+that.win\n+from.work\n@@ -12310,4 +12717,0 @@\n-\/\/ NCTU.ME : https:\/\/nctu.me\/\n-\/\/ Submitted by Tocknicsu <admin@nctu.me>\n-nctu.me\n-\n@@ -12316,1 +12719,0 @@\n-bitballoon.com\n@@ -12318,1 +12720,0 @@\n-netlify.com\n@@ -12336,0 +12737,14 @@\n+\/\/ Noop : https:\/\/noop.app\n+\/\/ Submitted by Nathaniel Schweinberg <noop@rearc.io>\n+*.developer.app\n+noop.app\n+\n+\/\/ Northflank Ltd. : https:\/\/northflank.com\/\n+\/\/ Submitted by Marco Suter <marco@northflank.com>\n+*.northflank.app\n+*.code.run\n+\n+\/\/ Noticeable : https:\/\/noticeable.io\n+\/\/ Submitted by Laurent Pellegrino <security@noticeable.io>\n+noticeable.news\n+\n@@ -12474,54 +12889,0 @@\n-\/\/ NymNom : https:\/\/nymnom.com\/\n-\/\/ Submitted by NymNom <psl@nymnom.com>\n-nom.ae\n-nom.af\n-nom.ai\n-nom.al\n-nym.by\n-nom.bz\n-nym.bz\n-nom.cl\n-nym.ec\n-nom.gd\n-nom.ge\n-nom.gl\n-nym.gr\n-nom.gt\n-nym.gy\n-nym.hk\n-nom.hn\n-nym.ie\n-nom.im\n-nom.ke\n-nym.kz\n-nym.la\n-nym.lc\n-nom.li\n-nym.li\n-nym.lt\n-nym.lu\n-nom.lv\n-nym.me\n-nom.mk\n-nym.mn\n-nym.mx\n-nom.nu\n-nym.nz\n-nym.pe\n-nym.pt\n-nom.pw\n-nom.qa\n-nym.ro\n-nom.rs\n-nom.si\n-nym.sk\n-nom.st\n-nym.su\n-nym.sx\n-nom.tj\n-nym.tw\n-nom.ug\n-nom.uy\n-nom.vc\n-nom.vg\n-\n@@ -12536,0 +12897,4 @@\n+\/\/ OMG.LOL : <https:\/\/omg.lol>\n+\/\/ Submitted by Adam Newbold <adam@omg.lol>\n+omg.lol\n+\n@@ -12540,0 +12905,8 @@\n+\/\/ OmniWe Limited: https:\/\/omniwe.com\n+\/\/ Submitted by Vicary Archangel <vicary@omniwe.com>\n+omniwe.site\n+\n+\/\/ One.com: https:\/\/www.one.com\/\n+\/\/ Submitted by Jacob Bunk Nielsen <jbn@one.com>\n+service.one\n+\n@@ -12544,0 +12917,4 @@\n+\/\/ Open Social : https:\/\/www.getopensocial.com\/\n+\/\/ Submitted by Alexander Varwijk <security@getopensocial.com>\n+opensocial.site\n+\n@@ -12548,0 +12925,4 @@\n+\/\/ OpenResearch GmbH: https:\/\/openresearch.com\/\n+\/\/ Submitted by Philipp Schmid <ops@openresearch.com>\n+orsites.com\n+\n@@ -12552,2 +12933,4 @@\n-\/\/ Oursky Limited : https:\/\/skygear.io\/\n-\/\/ Submited by Skygear Developer <hello@skygear.io>\n+\/\/ Oursky Limited : https:\/\/authgear.com\/, https:\/\/skygear.io\/\n+\/\/ Submited by Authgear Team <hello@authgear.com>, Skygear Developer <hello@skygear.io>\n+authgear-staging.com\n+authgearapps.com\n@@ -12560,0 +12943,5 @@\n+\/\/ OVHcloud: https:\/\/ovhcloud.com\n+\/\/ Submitted by Vincent Cassé <vincent.casse@ovhcloud.com>\n+*.webpaas.ovh.net\n+*.hosting.ovh.net\n+\n@@ -12565,0 +12953,4 @@\n+\/\/ OwO : https:\/\/whats-th.is\/\n+\/\/ Submitted by Dean Sheather <dean@deansheather.com>\n+*.owo.codes\n+\n@@ -12581,0 +12973,15 @@\n+\/\/ PageXL : https:\/\/pagexl.com\n+\/\/ Submitted by Yann Guichard <yann@pagexl.com>\n+pagexl.com\n+\n+\/\/ Paywhirl, Inc : https:\/\/paywhirl.com\/\n+\/\/ Submitted by Daniel Netzer <dan@paywhirl.com>\n+*.paywhirl.com\n+\n+\/\/ pcarrier.ca Software Inc: https:\/\/pcarrier.ca\/\n+\/\/ Submitted by Pierre Carrier <pc@rrier.ca>\n+bar0.net\n+bar1.net\n+bar2.net\n+rdv.to\n+\n@@ -12602,0 +13009,4 @@\n+\/\/ PE Ulyanov Kirill Sergeevich : https:\/\/airy.host\n+\/\/ Submitted by Kirill Ulyanov <k.ulyanov@airy.host>\n+lk3.ru\n+\n@@ -12608,1 +13019,4 @@\n-*.platform.sh\n+bc.platform.sh\n+ent.platform.sh\n+eu.platform.sh\n+us.platform.sh\n@@ -12610,0 +13024,1 @@\n+*.tst.site\n@@ -12617,0 +13032,6 @@\n+\/\/ Plesk : https:\/\/www.plesk.com\/\n+\/\/ Submitted by Anton Akhtyamov <program-managers@plesk.com>\n+pdns.page\n+plesk.page\n+pleskns.com\n+\n@@ -12625,0 +13046,11 @@\n+\/\/ Postman, Inc : https:\/\/postman.com\n+\/\/ Submitted by Rahul Dhawan <security@postman.com>\n+postman-echo.com\n+pstmn.io\n+mock.pstmn.io\n+httpbin.org\n+\n+\/\/prequalifyme.today : https:\/\/prequalifyme.today\n+\/\/Submitted by DeepakTiwari deepak@ivylead.io\n+prequalifyme.today\n+\n@@ -12654,0 +13086,9 @@\n+\/\/ PythonAnywhere LLP: https:\/\/www.pythonanywhere.com\n+\/\/ Submitted by Giles Thomas <giles@pythonanywhere.com>\n+pythonanywhere.com\n+eu.pythonanywhere.com\n+\n+\/\/ QOTO, Org.\n+\/\/ Submitted by Jeffrey Phillips Freeman <jeffrey.freeman@qoto.org>\n+qoto.io\n+\n@@ -12662,0 +13103,8 @@\n+\/\/ Rad Web Hosting: https:\/\/radwebhosting.com\n+\/\/ Submitted by Scott Claeys <s.claeys@radwebhosting.com>\n+cloudsite.builders\n+\n+\/\/ Redgate Software: https:\/\/red-gate.com\n+\/\/ Submitted by Andrew Farries <andrew.farries@red-gate.com>\n+instances.spawn.cc\n+\n@@ -12699,0 +13148,4 @@\n+\/\/ Rakuten Games, Inc : https:\/\/dev.viberplay.io\n+\/\/ Submitted by Joshua Zhang <public-suffix@rgames.jp>\n+g.vbrplsbx.io\n+\n@@ -12721,0 +13174,1 @@\n+id.repl.co\n@@ -12735,1 +13189,0 @@\n-ptplus.fit\n@@ -12738,0 +13191,8 @@\n+\/\/ Rico Developments Limited : https:\/\/adimo.co\n+\/\/ Submitted by Colin Brown <hello@adimo.co>\n+adimo.co.uk\n+\n+\/\/ Riseup Networks : https:\/\/riseup.net\n+\/\/ Submitted by Micah Anderson <micah@riseup.net>\n+itcouldbewor.se\n+\n@@ -12742,0 +13203,13 @@\n+\/\/ Rusnames Limited: http:\/\/rusnames.ru\/\n+\/\/ Submitted by Sergey Zotov <admin@rusnames.ru>\n+биз.рус\n+ком.рус\n+крым.рус\n+мир.рус\n+мск.рус\n+орг.рус\n+самара.рус\n+сочи.рус\n+спб.рус\n+я.рус\n+\n@@ -12758,0 +13232,1 @@\n+service.gov.scot\n@@ -12776,0 +13251,8 @@\n+\/\/ Seidat : https:\/\/www.seidat.com\n+\/\/ Submitted by Artem Kondratev <accounts@seidat.com>\n+seidat.net\n+\n+\/\/ Sellfy : https:\/\/sellfy.com\n+\/\/ Submitted by Yuriy Romadin <contact@sellfy.com>\n+sellfy.store\n+\n@@ -12780,0 +13263,8 @@\n+\/\/ Sendmsg: https:\/\/www.sendmsg.co.il\n+\/\/ Submitted by Assaf Stern <domains@comstar.co.il>\n+minisite.ms\n+\n+\/\/ Service Magnet : https:\/\/myservicemagnet.com\n+\/\/ Submitted by Dave Sanders <dave@myservicemagnet.com>\n+magnet.page\n+\n@@ -12786,0 +13277,5 @@\n+\/\/ Shift Crypto AG : https:\/\/shiftcrypto.ch\n+\/\/ Submitted by alex <alex@shiftcrypto.ch>\n+shiftcrypto.dev\n+shiftcrypto.io\n+\n@@ -12794,0 +13290,4 @@\n+\/\/ Shopify : https:\/\/www.shopify.com\n+\/\/ Submitted by Alex Richter <alex.richter@shopify.com>\n+myshopify.com\n+\n@@ -12824,0 +13324,16 @@\n+\/\/ Small Technology Foundation : https:\/\/small-tech.org\n+\/\/ Submitted by Aral Balkan <aral@small-tech.org>\n+small-web.org\n+\n+\/\/ Smoove.io : https:\/\/www.smoove.io\/\n+\/\/ Submitted by Dan Kozak <dan@smoove.io>\n+vp4.me\n+\n+\/\/ Snowplow Analytics : https:\/\/snowplowanalytics.com\/\n+\/\/ Submitted by Ian Streeter <ian@snowplowanalytics.com>\n+try-snowplow.com\n+\n+\/\/ SourceHut : https:\/\/sourcehut.org\n+\/\/ Submitted by Drew DeVault <sir@cmpwn.com>\n+srht.site\n+\n@@ -12828,0 +13344,4 @@\n+\/\/ Staclar : https:\/\/staclar.com\n+\/\/ Submitted by Matthias Merkel <matthias.merkel@staclar.com>\n+novecore.site\n+\n@@ -12834,0 +13354,11 @@\n+\/\/ Storebase : https:\/\/www.storebase.io\n+\/\/ Submitted by Tony Schirmer <tony@storebase.io>\n+storebase.store\n+\n+\/\/ Strategic System Consulting (eApps Hosting): https:\/\/www.eapps.com\/\n+\/\/ Submitted by Alex Oancea <aoancea@cloudscale365.com>\n+vps-host.net\n+atl.jelastic.vps-host.net\n+njs.jelastic.vps-host.net\n+ric.jelastic.vps-host.net\n+\n@@ -12851,0 +13382,22 @@\n+\/\/ Spreadshop (sprd.net AG) : https:\/\/www.spreadshop.com\/\n+\/\/ Submitted by Martin Breest <security@spreadshop.com>\n+myspreadshop.at\n+myspreadshop.com.au\n+myspreadshop.be\n+myspreadshop.ca\n+myspreadshop.ch\n+myspreadshop.com\n+myspreadshop.de\n+myspreadshop.dk\n+myspreadshop.es\n+myspreadshop.fi\n+myspreadshop.fr\n+myspreadshop.ie\n+myspreadshop.it\n+myspreadshop.net\n+myspreadshop.nl\n+myspreadshop.no\n+myspreadshop.pl\n+myspreadshop.se\n+myspreadshop.co.uk\n+\n@@ -12872,4 +13425,6 @@\n-\/\/ Swisscom Application Cloud: https:\/\/developer.swisscom.com\n-\/\/ Submitted by Matthias.Winzeler <matthias.winzeler@swisscom.com>\n-applicationcloud.io\n-scapp.io\n+\/\/ Supabase : https:\/\/supabase.io\n+\/\/ Submitted by Inian Parameshwaran <security@supabase.io>\n+supabase.co\n+supabase.in\n+supabase.net\n+su.paba.se\n@@ -12904,0 +13459,4 @@\n+\/\/ Tabit Technologies Ltd. : https:\/\/tabit.cloud\/\n+\/\/ Submitted by Oren Agiv <oren@tabit.cloud>\n+tabitorder.co.il\n+\n@@ -12908,0 +13467,5 @@\n+\/\/ Tailscale Inc. : https:\/\/www.tailscale.com\n+\/\/ Submitted by David Anderson <danderson@tailscale.com>\n+beta.tailscale.net\n+ts.net\n+\n@@ -12931,0 +13495,3 @@\n+*.firenet.ch\n+*.svc.firenet.ch\n+reservd.com\n@@ -12936,0 +13503,7 @@\n+reservd.dev.thingdust.io\n+reservd.disrec.thingdust.io\n+reservd.testing.thingdust.io\n+\n+\/\/ ticket i\/O GmbH : https:\/\/ticket.io\n+\/\/ Submitted by Christian Franke <it@ticket.io>\n+tickets.io\n@@ -12941,0 +13515,6 @@\n+tlon.network\n+\n+\/\/ Tor Project, Inc. : https:\/\/torproject.org\n+\/\/ Submitted by Antoine Beaupré <anarcat@torproject.org\n+torproject.net\n+pages.torproject.net\n@@ -12947,0 +13527,4 @@\n+\/\/ TradableBits: https:\/\/tradablebits.com\n+\/\/ Submitted by Dmitry Khrisanov dmitry@tradablebits.com\n+tbits.me\n+\n@@ -13012,0 +13596,4 @@\n+\/\/ Upli : https:\/\/upli.io\n+\/\/ Submitted by Lenny Bakkalian <lenny.bakkalian@gmail.com>\n+upli.io\n+\n@@ -13025,0 +13613,6 @@\n+\/\/ Vercel, Inc : https:\/\/vercel.com\/\n+\/\/ Submitted by Connor Davis <security@vercel.com>\n+vercel.app\n+vercel.dev\n+now.sh\n+\n@@ -13037,0 +13631,42 @@\n+\/\/ Voxel.sh DNS : https:\/\/voxel.sh\/dns\/\n+\/\/ Submitted by Mia Rehlinger <dns@voxel.sh>\n+neko.am\n+nyaa.am\n+be.ax\n+cat.ax\n+es.ax\n+eu.ax\n+gg.ax\n+mc.ax\n+us.ax\n+xy.ax\n+nl.ci\n+xx.gl\n+app.gp\n+blog.gt\n+de.gt\n+to.gt\n+be.gy\n+cc.hn\n+blog.kg\n+io.kg\n+jp.kg\n+tv.kg\n+uk.kg\n+us.kg\n+de.ls\n+at.md\n+de.md\n+jp.md\n+to.md\n+indie.porn\n+vxl.sh\n+ch.tc\n+me.tc\n+we.tc\n+nyan.to\n+at.vg\n+blog.vu\n+dev.vu\n+me.vu\n+\n@@ -13045,0 +13681,9 @@\n+\/\/ WapBlog.ID : https:\/\/www.wapblog.id\n+\/\/ Submitted by Fajar Sodik <official@wapblog.id>\n+idnblogger.com\n+indowapblog.com\n+bloger.id\n+wblog.id\n+wbq.me\n+fastblog.net\n+\n@@ -13049,0 +13694,7 @@\n+\/\/ WebHotelier Technologies Ltd: https:\/\/www.webhotelier.net\/\n+\/\/ Submitted by Apostolos Tsakpinis <apostolos.tsakpinis@gmail.com>\n+reserve-online.net\n+reserve-online.com\n+bookonline.app\n+hotelwithflight.com\n+\n@@ -13059,0 +13711,4 @@\n+\/\/ WIARD Enterprises : https:\/\/wiardweb.com\n+\/\/ Submitted by Kidd Hustle <kiddhustle@wiardweb.com>\n+pages.wiardweb.com\n+\n@@ -13072,0 +13728,1 @@\n+woltlab-demo.com\n@@ -13078,0 +13735,17 @@\n+\/\/ Woods Valldata : https:\/\/www.woodsvalldata.co.uk\/\n+\/\/ Submitted by Chris Whittle <chris.whittle@woodsvalldata.co.uk>\n+affinitylottery.org.uk\n+raffleentry.org.uk\n+weeklylottery.org.uk\n+\n+\/\/ WP Engine : https:\/\/wpengine.com\/\n+\/\/ Submitted by Michael Smith <michael.smith@wpengine.com>\n+\/\/ Submitted by Brandon DuRette <brandon.durette@wpengine.com>\n+wpenginepowered.com\n+js.wpenginepowered.com\n+\n+\/\/ Wix.com, Inc. : https:\/\/www.wix.com\n+\/\/ Submitted by Shahar Talmi <shahar@wix.com>\n+wixsite.com\n+editorx.io\n+\n@@ -13120,0 +13794,1 @@\n+ynh.fr\n@@ -13128,4 +13803,0 @@\n-\/\/ Zeit, Inc. : https:\/\/zeit.domains\/\n-\/\/ Submitted by Olli Vanhoja <olli@zeit.co>\n-now.sh\n-\n@@ -13142,4 +13813,0 @@\n-\/\/ Mintere : https:\/\/mintere.com\/\n-\/\/ Submitted by Ben Aubin <security@mintere.com>\n-mintere.site\n-\n","filename":"make\/data\/publicsuffixlist\/public_suffix_list.dat","additions":1029,"deletions":362,"binary":false,"changes":1391,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2021e\n+tzdata2022a\n","filename":"make\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -944,0 +944,4 @@\n+#\n+# From Milamber (2021-03-31, 2022-03-10), confirming these predictions:\n+# https:\/\/www.mmsp.gov.ma\/fr\/actualites.aspx?id=2076\n+# https:\/\/www.ecoactu.ma\/horaires-administration-ramadan-gmtheure-gmt-a-partir-de-dimanche-27-mars\/\n","filename":"make\/data\/tzdata\/africa","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3432,2 +3432,6 @@\n-# From Paul Eggert (2021-10-20):\n-# Guess future fall transitions on October's last Friday at 01:00.\n+# From Tim Parenti (2021-10-25), per Paul Eggert (2021-10-24):\n+# Guess future fall transitions at 01:00 on the Friday preceding October's\n+# last Sunday (i.e., Fri>=23), as this is more consistent with recent practice.\n+\n+# From Heba Hamad (2022-03-10):\n+# summer time will begin in Palestine from Sunday 03-27-2022, 00:00 AM.\n@@ -3469,1 +3473,1 @@\n-Rule Palestine\t2020\tmax\t-\tMar\tSat>=24\t0:00\t1:00\tS\n+Rule Palestine\t2020\t2021\t-\tMar\tSat>=24\t0:00\t1:00\tS\n@@ -3471,1 +3475,2 @@\n-Rule Palestine\t2021\tmax\t-\tOct\tlastFri\t1:00\t0\t-\n+Rule Palestine\t2021\tmax\t-\tOct\tFri>=23\t1:00\t0\t-\n+Rule Palestine\t2022\tmax\t-\tMar\tSun>=25\t0:00\t1:00\tS\n","filename":"make\/data\/tzdata\/asia","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2811,2 +2811,20 @@\n-#\n-# From Paul Eggert (2016-03-18):\n+# From Alois Treindl (2022-02-15):\n+# the Russian wikipedia page\n+# https:\/\/ru.wikipedia.org\/wiki\/Московское_время#Перемещение_границы_применения_московского_времени_на_восток\n+# contains the sentence (in Google translation) \"In the autumn of\n+# 1981, Arkhangelsk, Vologda, Yaroslavl, Ivanovo, Vladimir, Ryazan,\n+# Lipetsk, Voronezh, Rostov-on-Don, Krasnodar and regions to the east\n+# of those named (about 30 in total) parted ways with Moscow time.\n+# However, the convenience of common time with Moscow turned out to be\n+# decisive - in 1982, these regions again switched to Moscow time.\"\n+# Shanks International atlas has similar information, and also the\n+# Russian book Zaitsev A., Kutalev D. A new astrologer's reference\n+# book. Coordinates of cities and time corrections, - The World of\n+# Urania, 2012 (Russian: Зайцев А., Куталёв Д., Новый справочник\n+# астролога. Координаты городов и временные поправки).\n+# To me it seems that an extra zone is needed, which starts with LMT\n+# util 1919, later follows Moscow since 1930, but deviates from it\n+# between 1 October 1981 until 1 April 1982.\n+#\n+#\n+# From Paul Eggert (2022-02-15):\n@@ -2859,1 +2877,1 @@\n-\t\t\t 2:00\t-\tEET\t1992\n+\t\t\t 2:00\t-\tEET\t1992 Mar 20\n@@ -2869,1 +2887,1 @@\n-\t\t\t 2:00\tE-Eur\tEE%sT\t1994 May\n+\t\t\t 2:00\tC-Eur\tEE%sT\t1994 May\n@@ -4036,0 +4054,21 @@\n+# From Alois Triendl (2014-03-01):\n+# REGULATION A N O V A on March 20, 1992 N 139 ...  means that from\n+# 1992 on, Ukraine had DST with begin time at 02:00 am, on last Sunday\n+# in March, and end time 03:00 am, last Sunday in September....\n+# CABINET OF MINISTERS OF UKRAINE RESOLUTION on May 13, 1996 N 509\n+# \"On the order of computation time on the territory of Ukraine\" ....\n+# As this cabinet decision is from May 1996, it seems likely that the\n+# transition in March 1996, which predates it, was still at 2:00 am\n+# and not at 3:00 as would have been under EU rules.\n+# This is why I have set the change to EU rules into May 1996,\n+# so that the change in March is stil covered by the Ukraine rule.\n+# The next change in October 1996 happened under EU rules....\n+# TZ database holds three other zones for Ukraine.... I have not yet\n+# worked out the consequences for these three zones, as we (me and my\n+# US colleague David Cochrane) are still trying to get more\n+# information upon these local deviations from Kiev rules.\n+#\n+# From Paul Eggert (2022-02-08):\n+# For now, assume that Ukraine's other three zones followed the same rules,\n+# except that Crimea switched to Moscow time in 1994 as described elsewhere.\n+\n@@ -4125,1 +4164,1 @@\n-\t\t\t2:00\tE-Eur\tEE%sT\t1995\n+\t\t\t2:00\tC-Eur\tEE%sT\t1996 May 13\n@@ -4138,2 +4177,2 @@\n-\t\t\t2:00\t-\tEET\t1992\n-\t\t\t2:00\tE-Eur\tEE%sT\t1995\n+\t\t\t2:00\t-\tEET\t1992 Mar 20\n+\t\t\t2:00\tC-Eur\tEE%sT\t1996 May 13\n@@ -4152,1 +4191,2 @@\n-\t\t\t2:00\tE-Eur\tEE%sT\t1995\n+\t\t\t2:00\tE-Eur\tEE%sT\t1992 Mar 20\n+\t\t\t2:00\tC-Eur\tEE%sT\t1996 May 13\n","filename":"make\/data\/tzdata\/europe","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-#Expires 2022\tJun\t28\t00:00:00\n+#Expires 2022\tDec\t28\t00:00:00\n@@ -102,1 +102,1 @@\n-#expires 1656374400 (2022-06-28 00:00:00 UTC)\n+#expires 1672185600 (2022-12-28 00:00:00 UTC)\n@@ -104,2 +104,2 @@\n-#\tUpdated through IERS Bulletin C62\n-#\tFile expires on:  28 June 2022\n+#\tUpdated through IERS Bulletin C63\n+#\tFile expires on:  28 December 2022\n","filename":"make\/data\/tzdata\/leapseconds","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1112,1 +1112,1 @@\n-# From Paul Eggert (2015-04-03):\n+# From Paul Eggert (2022-03-15):\n@@ -1135,1 +1135,1 @@\n-# http:\/\/www.horaoficial.cl\/historia_hora.html\n+# http:\/\/www.horaoficial.cl\/historia_hora.php\n@@ -1144,1 +1144,2 @@\n-#    Quinta Normal in Santiago.  Go with [2], rounding it to -4:42:46.\n+#    Quinta Normal in Santiago.  Go with [1], as this matches the meridian\n+#    referred to by the relevant Chilean laws to this day.\n@@ -1166,0 +1167,26 @@\n+# From Tim Parenti (2022-03-15):\n+# For a brief period of roughly six weeks in 1946, DST was only observed on an\n+# emergency basis in specific regions of central Chile; namely, \"the national\n+# territory between the provinces of Coquimbo and Concepción, inclusive\".\n+# This was enacted by Decree 3,891, dated 1946-07-13, and took effect\n+# 1946-07-14 24:00, advancing these central regions to -03.\n+# https:\/\/www.diariooficial.interior.gob.cl\/versiones-anteriores\/do-h\/19460715\/#page\/1\n+# The decree contemplated \"[t]hat this advancement of the Official Time, even\n+# though it has been proposed for the cities of Santiago and Valparaíso only,\n+# must be agreed with that of other cities, due to the connection of various\n+# activities that require it, such as, for example, the operation of rail\n+# services\".  It was originally set to expire after 30 days but was extended\n+# through 1946-08-31 by Decree 4,506, dated 1946-08-13.\n+# https:\/\/www.diariooficial.interior.gob.cl\/versiones-anteriores\/do-h\/19460814\/#page\/1\n+#\n+# Law Number 8,522, promulgated 1946-08-27, reunified Chilean clocks at their\n+# new \"Summer Time\" of -04, reckoned as that of \"the meridian of the\n+# Astronomical Observatory of Lo Espejo, advanced by 42 minutes and 45\n+# seconds\".\n+# https:\/\/www.diariooficial.interior.gob.cl\/versiones-anteriores\/do-h\/19460828\/#page\/1\n+# After a brief \"Winter Time\" stint at -05 beginning 1947-04-01, Law Number\n+# 8,777, promulgated 1947-05-17, established year-round -04 \"from 23:00 on the\n+# second day after it is published in the 'Diario Oficial'.\"  It was published\n+# on Monday 1947-05-19 and so took effect from Wednesday 1947-05-21 23:00.\n+# https:\/\/www.diariooficial.interior.gob.cl\/versiones-anteriores\/do-h\/19470519\/#page\/1\n+\n@@ -1324,2 +1351,2 @@\n-Zone America\/Santiago\t-4:42:46 -\tLMT\t1890\n-\t\t\t-4:42:46 -\tSMT\t1910 Jan 10 # Santiago Mean Time\n+Zone America\/Santiago\t-4:42:45 -\tLMT\t1890\n+\t\t\t-4:42:45 -\tSMT\t1910 Jan 10 # Santiago Mean Time\n@@ -1327,1 +1354,1 @@\n-\t\t\t-4:42:46 -\tSMT\t1918 Sep 10\n+\t\t\t-4:42:45 -\tSMT\t1918 Sep 10\n@@ -1329,1 +1356,1 @@\n-\t\t\t-4:42:46 -\tSMT\t1927 Sep  1\n+\t\t\t-4:42:45 -\tSMT\t1927 Sep  1\n@@ -1339,1 +1366,1 @@\n-\t\t\t-4:42:46 -\tSMT\t1910 Jan 10\n+\t\t\t-4:42:45 -\tSMT\t1910 Jan 10\n@@ -1341,1 +1368,1 @@\n-\t\t\t-4:42:46 -\tSMT\t1918 Sep 10\n+\t\t\t-4:42:45 -\tSMT\t1918 Sep 10\n@@ -1343,1 +1370,1 @@\n-\t\t\t-4:42:46 -\tSMT\t1927 Sep  1\n+\t\t\t-4:42:45 -\tSMT\t1927 Sep  1\n","filename":"make\/data\/tzdata\/southamerica","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+    static int copyrightYear;\n@@ -220,0 +221,4 @@\n+                    case \"-year\":\n+                        copyrightYear = Integer.parseInt(args[++i]);\n+                        break;\n+\n@@ -238,1 +243,1 @@\n-                severe(\"unknown or imcomplete arg(s): \" + currentArg);\n+                severe(\"unknown or incomplete arg(s): \" + currentArg);\n@@ -263,0 +268,4 @@\n+        if (copyrightYear == 0) {\n+            copyrightYear = ZonedDateTime.now(ZoneId.of(\"America\/Los_Angeles\")).getYear();\n+        }\n+\n@@ -295,0 +304,1 @@\n+                + \"\\t-year year     copyright year in output%n\"\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Date;\n@@ -134,2 +135,1 @@\n-    static String getOracleCopyright() {\n-        int year = getYear();\n+    static String getOracleCopyright(int year) {\n@@ -143,2 +143,1 @@\n-    static String getOpenJDKCopyright() {\n-        int year = getYear();\n+    static String getOpenJDKCopyright(int year) {\n@@ -148,5 +147,0 @@\n-    private static int getYear() {\n-        return new GregorianCalendar(TimeZone.getTimeZone(\"America\/Los_Angeles\"),\n-                                         Locale.US).get(Calendar.YEAR);\n-    }\n-\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CopyrightHeaders.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-            out.println(CopyrightHeaders.getOpenJDKCopyright());\n+            out.println(CopyrightHeaders.getOpenJDKCopyright(CLDRConverter.copyrightYear));\n@@ -269,1 +269,1 @@\n-            out.printf(CopyrightHeaders.getOpenJDKCopyright());\n+            out.printf(CopyrightHeaders.getOpenJDKCopyright(CLDRConverter.copyrightYear));\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/ResourceBundleGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.time.ZoneId;\n-import java.time.ZonedDateTime;\n@@ -37,0 +35,3 @@\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n@@ -40,0 +41,1 @@\n+import java.util.TimeZone;\n@@ -55,1 +57,1 @@\n-        if (args.length != 2) {\n+        if (args.length != 3) {\n@@ -57,1 +59,1 @@\n-                    + \" language-subtag-registry.txt LocaleEquivalentMaps.java\");\n+                    + \" language-subtag-registry.txt LocaleEquivalentMaps.java copyrightYear\");\n@@ -60,0 +62,1 @@\n+        copyrightYear = Integer.parseInt(args[2]);\n@@ -66,0 +69,1 @@\n+    private static int copyrightYear;\n@@ -249,3 +253,1 @@\n-        int year = ZonedDateTime.now(ZoneId\n-                .of(\"America\/Los_Angeles\")).getYear();\n-        return String.format(Locale.US, COPYRIGHT, year);\n+        return String.format(Locale.US, COPYRIGHT, copyrightYear);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatelsrequivmaps\/EquivMapsGenerator.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.LocalDateTime;\n@@ -42,1 +45,2 @@\n- * and also supports SOURCE_DATE_EPOCH timestamps.\n+ * and also supports SOURCE_DATE_EPOCH timestamps which will set the ZipEntry\n+ * local time in UTC.\n@@ -48,1 +52,1 @@\n-    long   timestamp = -1L;\n+    LocalDateTime timestamp = null;\n@@ -120,1 +124,3 @@\n-                        timestamp = Long.parseLong(args[++count]) * 1000;\n+                        long epochSeconds = Long.parseLong(args[++count]);\n+                        Instant instant = Instant.ofEpochSecond(epochSeconds);\n+                        timestamp = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n@@ -197,2 +203,2 @@\n-        if (timestamp != -1L) {\n-            entry.setTime(timestamp);\n+        if (timestamp != null) {\n+            entry.setTimeLocal(timestamp);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/makezipreproducible\/MakeZipReproducible.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+\t    -year $(COPYRIGHT_YEAR) \\\n@@ -102,1 +103,1 @@\n-\t$(TOOL_GENERATELSREQUIVMAPS) $< $@\n+\t$(TOOL_GENERATELSREQUIVMAPS) $< $@ $(COPYRIGHT_YEAR)\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+\t    -year $(COPYRIGHT_YEAR) \\\n","filename":"make\/modules\/jdk.localedata\/Gensrc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,0 +132,10 @@\n+  assert(count > 0, \"must be\");\n+  assert(nbits > 0, \"must be\");\n+  assert(count * nbits <= 64, \"must be\");\n+\n+  \/\/ Special case nbits == 64 since the shift below with that nbits value\n+  \/\/ would result in undefined behavior.\n+  if (nbits == 64) {\n+    return bits;\n+  }\n+\n@@ -133,1 +143,0 @@\n-  \/\/ nbits may be 64 in which case we want mask to be -1\n","filename":"src\/hotspot\/cpu\/aarch64\/immediate_aarch64.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Red Hat Inc. All rights reserved.\n@@ -5106,12 +5106,0 @@\n-  \/\/ code for comparing 16 bytes of strings with same encoding\n-  void compare_string_16_bytes_same(Label &DIFF1, Label &DIFF2) {\n-    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, tmp1 = r10, tmp2 = r11;\n-    __ ldr(rscratch1, Address(__ post(str1, 8)));\n-    __ eor(rscratch2, tmp1, tmp2);\n-    __ ldr(cnt1, Address(__ post(str2, 8)));\n-    __ cbnz(rscratch2, DIFF1);\n-    __ ldr(tmp1, Address(__ post(str1, 8)));\n-    __ eor(rscratch2, rscratch1, cnt1);\n-    __ ldr(tmp2, Address(__ post(str2, 8)));\n-    __ cbnz(rscratch2, DIFF2);\n-  }\n@@ -5324,4 +5312,4 @@\n-        tmp1 = r10, tmp2 = r11;\n-    Label SMALL_LOOP, LARGE_LOOP_PREFETCH, CHECK_LAST, DIFF2, TAIL,\n-        LENGTH_DIFF, DIFF, LAST_CHECK_AND_LENGTH_DIFF,\n-        DIFF_LAST_POSITION, DIFF_LAST_POSITION2;\n+        tmp1 = r10, tmp2 = r11, tmp1h = rscratch1, tmp2h = rscratch2;\n+\n+    Label LARGE_LOOP_PREFETCH, LOOP_COMPARE16, DIFF, LESS16, LESS8, CAL_DIFFERENCE, LENGTH_DIFF;\n+\n@@ -5331,2 +5319,5 @@\n-    \/\/ cnt1\/cnt2 contains amount of characters to compare. cnt1 can be re-used\n-    \/\/ update cnt2 counter with already loaded 8 bytes\n+\n+    \/\/ before jumping to stub, pre-load 8 bytes already, so do comparison directly\n+    __ eor(rscratch2, tmp1, tmp2);\n+    __ cbnz(rscratch2, CAL_DIFFERENCE);\n+\n@@ -5338,0 +5329,1 @@\n+      __ align(OptoLoopAlignment);\n@@ -5341,2 +5333,8 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n+\n+        for (int i = 0; i < 4; i++) {\n+          __ ldp(tmp1, tmp1h, Address(str1, i * 16));\n+          __ ldp(tmp2, tmp2h, Address(str2, i * 16));\n+          __ cmp(tmp1, tmp2);\n+          __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+          __ br(Assembler::NE, DIFF);\n+        }\n@@ -5344,1 +5342,2 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n+        __ add(str1, str1, 64);\n+        __ add(str2, str2, 64);\n@@ -5346,3 +5345,2 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n-        __ br(__ GT, LARGE_LOOP_PREFETCH);\n-        __ cbz(cnt2, LAST_CHECK_AND_LENGTH_DIFF); \/\/ no more chars left?\n+        __ br(Assembler::GE, LARGE_LOOP_PREFETCH);\n+        __ cbz(cnt2, LENGTH_DIFF); \/\/ no more chars left?\n@@ -5350,3 +5348,3 @@\n-    \/\/ less than 16 bytes left?\n-    __ subs(cnt2, cnt2, isLL ? 16 : 8);\n-    __ br(__ LT, TAIL);\n+\n+    __ subs(rscratch1, cnt2, isLL ? 16 : 8);\n+    __ br(Assembler::LE, LESS16);\n@@ -5354,7 +5352,22 @@\n-    __ bind(SMALL_LOOP);\n-      compare_string_16_bytes_same(DIFF, DIFF2);\n-      __ subs(cnt2, cnt2, isLL ? 16 : 8);\n-      __ br(__ GE, SMALL_LOOP);\n-    __ bind(TAIL);\n-      __ adds(cnt2, cnt2, isLL ? 16 : 8);\n-      __ br(__ EQ, LAST_CHECK_AND_LENGTH_DIFF);\n+    __ bind(LOOP_COMPARE16);\n+      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n+      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(Assembler::NE, DIFF);\n+      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n+      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n+      __ br(Assembler::LT, LESS16);\n+\n+      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n+      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(Assembler::NE, DIFF);\n+      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n+      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n+      __ br(Assembler::GE, LOOP_COMPARE16);\n+      __ cbz(cnt2, LENGTH_DIFF);\n+\n+    __ bind(LESS16);\n+      \/\/ each 8 compare\n@@ -5362,3 +5375,1 @@\n-      __ br(__ LE, CHECK_LAST);\n-      __ eor(rscratch2, tmp1, tmp2);\n-      __ cbnz(rscratch2, DIFF);\n+      __ br(Assembler::LE, LESS8);\n@@ -5367,0 +5378,2 @@\n+      __ eor(rscratch2, tmp1, tmp2);\n+      __ cbnz(rscratch2, CAL_DIFFERENCE);\n@@ -5368,1 +5381,2 @@\n-    __ bind(CHECK_LAST);\n+\n+    __ bind(LESS8); \/\/ directly load last 8 bytes\n@@ -5370,1 +5384,1 @@\n-        __ add(cnt2, cnt2, cnt2); \/\/ now in bytes\n+        __ add(cnt2, cnt2, cnt2);\n@@ -5372,0 +5386,2 @@\n+      __ ldr(tmp1, Address(str1, cnt2));\n+      __ ldr(tmp2, Address(str2, cnt2));\n@@ -5373,4 +5389,0 @@\n-      __ cbnz(rscratch2, DIFF);\n-      __ ldr(rscratch1, Address(str1, cnt2));\n-      __ ldr(cnt1, Address(str2, cnt2));\n-      __ eor(rscratch2, rscratch1, cnt1);\n@@ -5378,18 +5390,2 @@\n-      \/\/ Find the first different characters in the longwords and\n-      \/\/ compute their difference.\n-    __ bind(DIFF2);\n-      __ rev(rscratch2, rscratch2);\n-      __ clz(rscratch2, rscratch2);\n-      __ andr(rscratch2, rscratch2, isLL ? -8 : -16);\n-      __ lsrv(rscratch1, rscratch1, rscratch2);\n-      if (isLL) {\n-        __ lsrv(cnt1, cnt1, rscratch2);\n-        __ uxtbw(rscratch1, rscratch1);\n-        __ uxtbw(cnt1, cnt1);\n-      } else {\n-        __ lsrv(cnt1, cnt1, rscratch2);\n-        __ uxthw(rscratch1, rscratch1);\n-        __ uxthw(cnt1, cnt1);\n-      }\n-      __ subw(result, rscratch1, cnt1);\n-      __ b(LENGTH_DIFF);\n+      __ b(CAL_DIFFERENCE);\n+\n@@ -5397,0 +5393,7 @@\n+      __ cmp(tmp1, tmp2);\n+      __ csel(tmp1, tmp1, tmp1h, Assembler::NE);\n+      __ csel(tmp2, tmp2, tmp2h, Assembler::NE);\n+      \/\/ reuse rscratch2 register for the result of eor instruction\n+      __ eor(rscratch2, tmp1, tmp2);\n+\n+    __ bind(CAL_DIFFERENCE);\n@@ -5401,0 +5404,1 @@\n+      __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5402,1 +5406,0 @@\n-        __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5406,1 +5409,0 @@\n-        __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5411,4 +5413,1 @@\n-      __ b(LENGTH_DIFF);\n-    __ bind(LAST_CHECK_AND_LENGTH_DIFF);\n-      __ eor(rscratch2, tmp1, tmp2);\n-      __ cbnz(rscratch2, DIFF);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":68,"deletions":69,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -2945,0 +2945,1 @@\n+  beq(flag, cont);\n@@ -2946,1 +2947,2 @@\n-# ifdef ASSERT\n+  \/\/ Check for recursive locking.\n+  cmpd(flag, current_header, R16_thread);\n@@ -2948,7 +2950,6 @@\n-  \/\/ We have acquired the monitor, check some invariants.\n-  addi(\/*monitor=*\/temp, temp, -ObjectMonitor::owner_offset_in_bytes());\n-  \/\/ Invariant 1: _recursions should be 0.\n-  \/\/assert(ObjectMonitor::recursions_size_in_bytes() == 8, \"unexpected size\");\n-  asm_assert_mem8_is_zero(ObjectMonitor::recursions_offset_in_bytes(), temp,\n-                            \"monitor->_recursions should be 0\");\n-# endif\n+\n+  \/\/ Current thread already owns the lock. Just increment recursions.\n+  Register recursions = displaced_header;\n+  ld(recursions, ObjectMonitor::recursions_offset_in_bytes()-ObjectMonitor::owner_offset_in_bytes(), temp);\n+  addi(recursions, recursions, 1);\n+  std(recursions, ObjectMonitor::recursions_offset_in_bytes()-ObjectMonitor::owner_offset_in_bytes(), temp);\n@@ -2970,2 +2971,1 @@\n-  Label cont;\n-  Label object_has_monitor;\n+  Label cont, object_has_monitor, notRecursive;\n@@ -3042,3 +3042,2 @@\n-  xorr(temp, R16_thread, temp);      \/\/ Will be 0 if we are the owner.\n-  orr(temp, temp, displaced_header); \/\/ Will be 0 if there are 0 recursions.\n-  cmpdi(flag, temp, 0);\n+\n+  cmpd(flag, temp, R16_thread);\n@@ -3047,0 +3046,6 @@\n+  addic_(displaced_header, displaced_header, -1);\n+  blt(CCR0, notRecursive); \/\/ Not recursive if negative after decrement.\n+  std(displaced_header, ObjectMonitor::recursions_offset_in_bytes(), current_header);\n+  b(cont); \/\/ flag is already EQ here.\n+\n+  bind(notRecursive);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -7331,0 +7331,3 @@\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+         vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+         vector_len == AVX_512bit ? VM_Version::supports_evex() : 0, \"\");\n@@ -7338,0 +7341,3 @@\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+         vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+         vector_len == AVX_512bit ? VM_Version::supports_evex() : 0, \"\");\n@@ -7950,1 +7956,1 @@\n-  assert(VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -7955,1 +7961,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T2, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T4, \/* input_size_in_bits *\/ EVEX_32bit);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-    __ kmovql(Address(rsp, _spill_offset), reg);\n+    __ kmov(Address(rsp, _spill_offset), reg);\n@@ -464,1 +464,1 @@\n-    __ kmovql(reg, Address(rsp, _spill_offset));\n+    __ kmov(reg, Address(rsp, _spill_offset));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1428,2 +1428,8 @@\n-  void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }\n-  void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }\n+  void vpxor(XMMRegister dst, XMMRegister src) {\n+    assert(UseAVX >= 2, \"Should be at least AVX2\");\n+    Assembler::vpxor(dst, dst, src, AVX_256bit);\n+  }\n+  void vpxor(XMMRegister dst, Address src) {\n+    assert(UseAVX >= 2, \"Should be at least AVX2\");\n+    Assembler::vpxor(dst, dst, src, AVX_256bit);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,0 @@\n-               lzcnt_intel  : 1,\n@@ -156,1 +155,1 @@\n-                            : 22;\n+                            : 23;\n@@ -640,1 +639,1 @@\n-      if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)\n+      if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0) {\n@@ -642,2 +641,2 @@\n-      \/\/ for Intel, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw\n-      if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {\n+      }\n+      if (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0) {\n@@ -653,1 +652,1 @@\n-      if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)\n+      if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0) {\n@@ -655,2 +654,2 @@\n-      \/\/ for ZX, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw\n-      if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {\n+      }\n+      if (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1808,4 +1808,0 @@\n-      if (size_in_bits == 256 && UseAVX < 2) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      break;\n@@ -1813,4 +1809,0 @@\n-      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n-        return false;\n-      }\n-      break;\n@@ -1818,1 +1810,1 @@\n-      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n+      if (bt != T_DOUBLE && size_in_bits == 256 && UseAVX < 2) {\n@@ -4336,1 +4328,2 @@\n-    __ insertps($dst$$XMMRegister, $val$$XMMRegister, $idx$$constant);\n+    uint x_idx = $idx$$constant & right_n_bits(2);\n+    __ insertps($dst$$XMMRegister, $val$$XMMRegister, x_idx << 4);\n@@ -4356,1 +4349,1 @@\n-      __ vinsertps($vtmp$$XMMRegister, $vtmp$$XMMRegister, $val$$XMMRegister, x_idx);\n+      __ vinsertps($vtmp$$XMMRegister, $vtmp$$XMMRegister, $val$$XMMRegister, x_idx << 4);\n@@ -4362,1 +4355,1 @@\n-      __ vinsertps($vtmp$$XMMRegister, $vtmp$$XMMRegister, $val$$XMMRegister, x_idx);\n+      __ vinsertps($vtmp$$XMMRegister, $vtmp$$XMMRegister, $val$$XMMRegister, x_idx << 4);\n@@ -6608,2 +6601,3 @@\n-      case T_DOUBLE:\n-        __ vpmovsxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+      case T_DOUBLE: {\n+        int mid_vlen_enc = (vlen_enc == Assembler::AVX_512bit) ? Assembler::AVX_256bit : Assembler::AVX_128bit;\n+        __ vpmovsxbd($dst$$XMMRegister, $src$$XMMRegister, mid_vlen_enc);\n@@ -6612,1 +6606,1 @@\n-\n+      }\n@@ -6679,2 +6673,3 @@\n-      case T_DOUBLE:\n-        __ vpmovsxwd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+      case T_DOUBLE: {\n+        int mid_vlen_enc = (vlen_enc == Assembler::AVX_512bit) ? Assembler::AVX_256bit : Assembler::AVX_128bit;\n+        __ vpmovsxwd($dst$$XMMRegister, $src$$XMMRegister, mid_vlen_enc);\n@@ -6683,0 +6678,1 @@\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -7813,1 +7813,1 @@\n-instruct divL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{\n+instruct divL_eReg(eADXRegL dst, eRegL src1, eRegL src2) %{\n@@ -7815,1 +7815,1 @@\n-  effect( KILL cr, KILL cx, KILL bx );\n+  effect(CALL);\n@@ -7861,1 +7861,1 @@\n-instruct modL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{\n+instruct modL_eReg(eADXRegL dst, eRegL src1, eRegL src2) %{\n@@ -7863,1 +7863,1 @@\n-  effect( KILL cr, KILL cx, KILL bx );\n+  effect(CALL);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022 SAP SE. All rights reserved.\n@@ -2174,0 +2175,28 @@\n+#ifdef __GLIBC__\n+\/\/ For Glibc, print a one-liner with the malloc tunables.\n+\/\/ Most important and popular is MALLOC_ARENA_MAX, but we are\n+\/\/ thorough and print them all.\n+static void print_glibc_malloc_tunables(outputStream* st) {\n+  static const char* var[] = {\n+      \/\/ the new variant\n+      \"GLIBC_TUNABLES\",\n+      \/\/ legacy variants\n+      \"MALLOC_CHECK_\", \"MALLOC_TOP_PAD_\", \"MALLOC_PERTURB_\",\n+      \"MALLOC_MMAP_THRESHOLD_\", \"MALLOC_TRIM_THRESHOLD_\",\n+      \"MALLOC_MMAP_MAX_\", \"MALLOC_ARENA_TEST\", \"MALLOC_ARENA_MAX\",\n+      NULL};\n+  st->print(\"glibc malloc tunables: \");\n+  bool printed = false;\n+  for (int i = 0; var[i] != NULL; i ++) {\n+    const char* const val = ::getenv(var[i]);\n+    if (val != NULL) {\n+      st->print(\"%s%s=%s\", (printed ? \", \" : \"\"), var[i], val);\n+      printed = true;\n+    }\n+  }\n+  if (!printed) {\n+    st->print(\"(default)\");\n+  }\n+}\n+#endif \/\/ __GLIBC__\n+\n@@ -2196,2 +2225,3 @@\n-  \/\/ Print glibc outstanding allocations.\n-  \/\/ (note: there is no implementation of mallinfo for muslc)\n+  \/\/ glibc only:\n+  \/\/ - Print outstanding allocations using mallinfo\n+  \/\/ - Print glibc tunables\n@@ -2205,3 +2235,4 @@\n-    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are int.\n-    \/\/ So values may have wrapped around. Still useful enough to see how much glibc thinks\n-    \/\/ we allocated.\n+    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are 32-bit signed.\n+    \/\/ So for larger footprints the values may have wrapped around. We try to detect this here: if the\n+    \/\/ process whole resident set size is smaller than 4G, malloc footprint has to be less than that\n+    \/\/ and the numbers are reliable.\n@@ -2218,2 +2249,4 @@\n-#endif \/\/ __GLIBC__\n-\n+  \/\/ Tunables\n+  print_glibc_malloc_tunables(st);\n+  st->cr();\n+#endif\n@@ -2256,1 +2289,5 @@\n-    st->print_cr(\"%d\", i);\n+    if (ActiveProcessorCount > 0) {\n+      st->print_cr(\"%d, but overridden by -XX:ActiveProcessorCount %d\", i, ActiveProcessorCount);\n+    } else {\n+      st->print_cr(\"%d\", i);\n+    }\n@@ -5469,0 +5506,1 @@\n+  \/\/ Note: all ranges are \"[..)\"\n@@ -5474,1 +5512,1 @@\n-    st->print(\"Range [%llx-%llx) contains: \", start, end);\n+    st->print_cr(\"Range [%llx-%llx) contains: \", start, end);\n@@ -5477,3 +5515,3 @@\n-      unsigned long long a1 = 0;\n-      unsigned long long a2 = 0;\n-      if (::sscanf(line, \"%llx-%llx\", &a1, &a2) == 2) {\n+      unsigned long long segment_start = 0;\n+      unsigned long long segment_end = 0;\n+      if (::sscanf(line, \"%llx-%llx\", &segment_start, &segment_end) == 2) {\n@@ -5481,3 +5519,1 @@\n-        if ((a1 >= start && a1 < end) || \/\/ left leg in\n-            (a2 >= start && a2 < end) || \/\/ right leg in\n-            (a1 < start && a2 >= end)) { \/\/ superimposition\n+        if (segment_start < end && segment_end > start) {\n@@ -5491,1 +5527,1 @@\n-      st->print(\"nothing.\");\n+      st->print_cr(\"nothing.\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":53,"deletions":17,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"adlc.hpp\"\n+\n+void* AdlAllocateHeap(size_t size) {\n+  unsigned char* ptr = (unsigned char*) malloc(size);\n+  if (ptr == NULL && size != 0) {\n+    fprintf(stderr, \"Error: Out of memory in ADLC\\n\"); \/\/ logging can cause crash!\n+    fflush(stderr);\n+    exit(1);\n+  }\n+  return ptr;\n+}\n+\n+void* AdlReAllocateHeap(void* old_ptr, size_t size) {\n+  unsigned char* ptr = (unsigned char*) realloc(old_ptr, size);\n+  if (ptr == NULL && size != 0) {\n+    fprintf(stderr, \"Error: Out of memory in ADLC\\n\"); \/\/ logging can cause crash!\n+    fflush(stderr);\n+    exit(1);\n+  }\n+  return ptr;\n+}\n+\n+void* AdlChunk::operator new(size_t requested_size, size_t length) throw() {\n+  return AdlCHeapObj::operator new(requested_size + length);\n+}\n+\n+void  AdlChunk::operator delete(void* p, size_t length) {\n+  AdlCHeapObj::operator delete(p);\n+}\n+\n+AdlChunk::AdlChunk(size_t length) {\n+  _next = NULL;         \/\/ Chain on the linked list\n+  _len  = length;       \/\/ Save actual size\n+}\n+\n+\/\/------------------------------chop-------------------------------------------\n+void AdlChunk::chop() {\n+  AdlChunk *k = this;\n+  while( k ) {\n+    AdlChunk *tmp = k->_next;\n+    \/\/ clear out this chunk (to detect allocation bugs)\n+    memset(k, 0xBE, k->_len);\n+    free(k);                    \/\/ Free chunk (was malloc'd)\n+    k = tmp;\n+  }\n+}\n+\n+void AdlChunk::next_chop() {\n+  _next->chop();\n+  _next = NULL;\n+}\n+\n+\/\/------------------------------AdlArena------------------------------------------\n+AdlArena::AdlArena( size_t init_size ) {\n+  init_size = (init_size+3) & ~3;\n+  _first = _chunk = new (init_size) AdlChunk(init_size);\n+  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n+  _max = _chunk->top();\n+  set_size_in_bytes(init_size);\n+}\n+\n+AdlArena::AdlArena() {\n+  _first = _chunk = new (AdlChunk::init_size) AdlChunk(AdlChunk::init_size);\n+  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n+  _max = _chunk->top();\n+  set_size_in_bytes(AdlChunk::init_size);\n+}\n+\n+AdlArena::AdlArena( AdlArena *a )\n+: _chunk(a->_chunk), _hwm(a->_hwm), _max(a->_max), _first(a->_first) {\n+  set_size_in_bytes(a->size_in_bytes());\n+}\n+\n+\/\/------------------------------used-------------------------------------------\n+\/\/ Total of all AdlChunks in arena\n+size_t AdlArena::used() const {\n+  size_t sum = _chunk->_len - (_max-_hwm); \/\/ Size leftover in this AdlChunk\n+  AdlChunk *k = _first;\n+  while( k != _chunk) {         \/\/ Whilst have AdlChunks in a row\n+    sum += k->_len;             \/\/ Total size of this AdlChunk\n+    k = k->_next;               \/\/ Bump along to next AdlChunk\n+  }\n+  return sum;                   \/\/ Return total consumed space.\n+}\n+\n+\/\/------------------------------grow-------------------------------------------\n+\/\/ Grow a new AdlChunk\n+void* AdlArena::grow( size_t x ) {\n+  \/\/ Get minimal required size.  Either real big, or even bigger for giant objs\n+  size_t len = max(x, AdlChunk::size);\n+\n+  AdlChunk *k = _chunk;         \/\/ Get filled-up chunk address\n+  _chunk = new (len) AdlChunk(len);\n+\n+  if( k ) k->_next = _chunk;    \/\/ Append new chunk to end of linked list\n+  else _first = _chunk;\n+  _hwm  = _chunk->bottom();     \/\/ Save the cached hwm, max\n+  _max =  _chunk->top();\n+  set_size_in_bytes(size_in_bytes() + len);\n+  void* result = _hwm;\n+  _hwm += x;\n+  return result;\n+}\n+\n+\/\/------------------------------calloc-----------------------------------------\n+\/\/ Allocate zeroed storage in AdlArena\n+void *AdlArena::Acalloc( size_t items, size_t x ) {\n+  size_t z = items*x;   \/\/ Total size needed\n+  void *ptr = Amalloc(z);       \/\/ Get space\n+  memset( ptr, 0, z );          \/\/ Zap space\n+  return ptr;                   \/\/ Return space\n+}\n+\n+\/\/------------------------------realloc----------------------------------------\n+\/\/ Reallocate storage in AdlArena.\n+void *AdlArena::Arealloc( void *old_ptr, size_t old_size, size_t new_size ) {\n+  char *c_old = (char*)old_ptr; \/\/ Handy name\n+  \/\/ Stupid fast special case\n+  if( new_size <= old_size ) {  \/\/ Shrink in-place\n+    if( c_old+old_size == _hwm) \/\/ Attempt to free the excess bytes\n+      _hwm = c_old+new_size;    \/\/ Adjust hwm\n+    return c_old;\n+  }\n+\n+  \/\/ See if we can resize in-place\n+  if( (c_old+old_size == _hwm) &&       \/\/ Adjusting recent thing\n+      (c_old+new_size <= _max) ) {      \/\/ Still fits where it sits\n+    _hwm = c_old+new_size;      \/\/ Adjust hwm\n+    return c_old;               \/\/ Return old pointer\n+  }\n+\n+  \/\/ Oops, got to relocate guts\n+  void *new_ptr = Amalloc(new_size);\n+  memcpy( new_ptr, c_old, old_size );\n+  Afree(c_old,old_size);        \/\/ Mostly done to keep stats accurate\n+  return new_ptr;\n+}\n+\n+\/\/------------------------------reset------------------------------------------\n+\/\/ Reset this AdlArena to empty, and return this AdlArenas guts in a new AdlArena.\n+AdlArena *AdlArena::reset(void) {\n+  AdlArena *a = new AdlArena(this);   \/\/ New empty arena\n+  _first = _chunk = NULL;       \/\/ Normal, new-arena initialization\n+  _hwm = _max = NULL;\n+  return a;                     \/\/ Return AdlArena with guts\n+}\n+\n+\/\/------------------------------contains---------------------------------------\n+\/\/ Determine if pointer belongs to this AdlArena or not.\n+bool AdlArena::contains( const void *ptr ) const {\n+  if( (void*)_chunk->bottom() <= ptr && ptr < (void*)_hwm )\n+    return true;                \/\/ Check for in this chunk\n+  for( AdlChunk *c = _first; c; c = c->_next )\n+    if( (void*)c->bottom() <= ptr && ptr < (void*)c->top())\n+      return true;              \/\/ Check for every chunk in AdlArena\n+  return false;                 \/\/ Not in any AdlChunk, so not in AdlArena\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ CHeapObj\n+\n+void* AdlCHeapObj::operator new(size_t size) throw() {\n+  return (void *) AdlAllocateHeap(size);\n+}\n+\n+void AdlCHeapObj::operator delete(void* p){\n+ free(p);\n+}\n","filename":"src\/hotspot\/share\/adlc\/adlArena.cpp","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_ADLC_ADLARENA_HPP\n+#define SHARE_ADLC_ADLARENA_HPP\n+\n+void* AdlAllocateHeap(size_t size);\n+void* AdlReAllocateHeap(void* old_ptr, size_t size);\n+\n+\/\/ All classes in adlc may be derived\n+\/\/ from one of the following allocation classes:\n+\/\/\n+\/\/ For objects allocated in the C-heap (managed by: malloc & free).\n+\/\/ - CHeapObj\n+\/\/\n+\/\/ For classes used as name spaces.\n+\/\/ - AdlAllStatic\n+\/\/\n+\n+class AdlCHeapObj {\n+ public:\n+  void* operator new(size_t size) throw();\n+  void  operator delete(void* p);\n+  void* new_array(size_t size);\n+};\n+\n+\/\/ Base class for classes that constitute name spaces.\n+\n+class AdlAllStatic {\n+ public:\n+  void* operator new(size_t size) throw();\n+  void operator delete(void* p);\n+};\n+\n+\n+\/\/------------------------------AdlChunk------------------------------------------\n+\/\/ Linked list of raw memory chunks\n+class AdlChunk: public AdlCHeapObj {\n+ private:\n+  \/\/ This ordinary operator delete is needed even though not used, so the\n+  \/\/ below two-argument operator delete will be treated as a placement\n+  \/\/ delete rather than an ordinary sized delete; see C++14 3.7.4.2\/p2.\n+  void operator delete(void* p);\n+ public:\n+  void* operator new(size_t size, size_t length) throw();\n+  void  operator delete(void* p, size_t length);\n+  AdlChunk(size_t length);\n+\n+  enum {\n+      init_size =  1*1024,      \/\/ Size of first chunk\n+      size      = 32*1024       \/\/ Default size of an AdlArena chunk (following the first)\n+  };\n+  AdlChunk*       _next;        \/\/ Next AdlChunk in list\n+  size_t       _len;            \/\/ Size of this AdlChunk\n+\n+  void chop();                  \/\/ Chop this chunk\n+  void next_chop();             \/\/ Chop next chunk\n+\n+  \/\/ Boundaries of data area (possibly unused)\n+  char* bottom() const { return ((char*) this) + sizeof(AdlChunk);  }\n+  char* top()    const { return bottom() + _len; }\n+};\n+\n+\n+\/\/------------------------------AdlArena------------------------------------------\n+\/\/ Fast allocation of memory\n+class AdlArena: public AdlCHeapObj {\n+protected:\n+  friend class ResourceMark;\n+  friend class HandleMark;\n+  friend class NoHandleMark;\n+  AdlChunk *_first;             \/\/ First chunk\n+  AdlChunk *_chunk;             \/\/ current chunk\n+  char *_hwm, *_max;            \/\/ High water mark and max in current chunk\n+  void* grow(size_t x);         \/\/ Get a new AdlChunk of at least size x\n+  size_t _size_in_bytes;          \/\/ Size of arena (used for memory usage tracing)\n+public:\n+  AdlArena();\n+  AdlArena(size_t init_size);\n+  AdlArena(AdlArena *old);\n+  ~AdlArena()                   { _first->chop(); }\n+  char* hwm() const             { return _hwm; }\n+\n+  \/\/ Fast allocate in the arena.  Common case is: pointer test + increment.\n+  void* Amalloc(size_t x) {\n+#ifdef _LP64\n+    x = (x + (8-1)) & ((unsigned)(-8));\n+#else\n+    x = (x + (4-1)) & ((unsigned)(-4));\n+#endif\n+    if (_hwm + x > _max) {\n+      return grow(x);\n+    } else {\n+      char *old = _hwm;\n+      _hwm += x;\n+      return old;\n+    }\n+  }\n+  \/\/ Further assume size is padded out to words\n+  \/\/ Warning:  in LP64, Amalloc_4 is really Amalloc_8\n+  void *Amalloc_4(size_t x) {\n+    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n+    if (_hwm + x > _max) {\n+      return grow(x);\n+    } else {\n+      char *old = _hwm;\n+      _hwm += x;\n+      return old;\n+    }\n+  }\n+\n+  \/\/ Fast delete in area.  Common case is: NOP (except for storage reclaimed)\n+  void Afree(void *ptr, size_t size) {\n+    if (((char*)ptr) + size == _hwm) _hwm = (char*)ptr;\n+  }\n+\n+  void *Acalloc( size_t items, size_t x );\n+  void *Arealloc( void *old_ptr, size_t old_size, size_t new_size );\n+\n+  \/\/ Reset this AdlArena to empty, and return this AdlArenas guts in a new AdlArena.\n+  AdlArena *reset(void);\n+\n+  \/\/ Determine if pointer belongs to this AdlArena or not.\n+  bool contains( const void *ptr ) const;\n+\n+  \/\/ Total of all chunks in use (not thread-safe)\n+  size_t used() const;\n+\n+  \/\/ Total # of bytes used\n+  size_t size_in_bytes() const         {  return _size_in_bytes; }\n+  void   set_size_in_bytes(size_t size)  { _size_in_bytes = size;   }\n+};\n+\n+#endif \/\/ SHARE_ADLC_ADLARENA_HPP\n","filename":"src\/hotspot\/share\/adlc\/adlArena.hpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -96,1 +96,1 @@\n-#include \"arena.hpp\"\n+#include \"adlArena.hpp\"\n","filename":"src\/hotspot\/share\/adlc\/adlc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-          char* buf = (char*) AllocateHeap(strlen(instr->_ident) + 4);\n+          char* buf = (char*) AdlAllocateHeap(strlen(instr->_ident) + 4);\n@@ -2808,1 +2808,1 @@\n-  char* ec_name = (char*) AllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n+  char* ec_name = (char*) AdlAllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n@@ -3279,1 +3279,1 @@\n-  char* ec_name = (char*) AllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n+  char* ec_name = (char*) AdlAllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n@@ -4412,1 +4412,1 @@\n-      char* result = (char *)AllocateHeap(strlen(location) + strlen(cppBlock) + strlen(end_loc) + 1);\n+      char* result = (char *)AdlAllocateHeap(strlen(location) + strlen(cppBlock) + strlen(end_loc) + 1);\n@@ -4501,1 +4501,1 @@\n-    char* result = (char *)AllocateHeap(strlen(location) + strlen(token2) + strlen(end_loc) + 1);\n+    char* result = (char *)AdlAllocateHeap(strlen(location) + strlen(token2) + strlen(end_loc) + 1);\n@@ -4599,1 +4599,1 @@\n-      char* buf = (char*) AllocateHeap(strlen(param) + 3);\n+      char* buf = (char*) AdlAllocateHeap(strlen(param) + 3);\n@@ -5207,1 +5207,1 @@\n-  char* location = (char *)AllocateHeap(strlen(file) + 100);\n+  char* location = (char *)AdlAllocateHeap(strlen(file) + 100);\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,192 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"adlc.hpp\"\n-\n-void* AllocateHeap(size_t size) {\n-  unsigned char* ptr = (unsigned char*) malloc(size);\n-  if (ptr == NULL && size != 0) {\n-    fprintf(stderr, \"Error: Out of memory in ADLC\\n\"); \/\/ logging can cause crash!\n-    fflush(stderr);\n-    exit(1);\n-  }\n-  return ptr;\n-}\n-\n-void* ReAllocateHeap(void* old_ptr, size_t size) {\n-  unsigned char* ptr = (unsigned char*) realloc(old_ptr, size);\n-  if (ptr == NULL && size != 0) {\n-    fprintf(stderr, \"Error: Out of memory in ADLC\\n\"); \/\/ logging can cause crash!\n-    fflush(stderr);\n-    exit(1);\n-  }\n-  return ptr;\n-}\n-\n-void* Chunk::operator new(size_t requested_size, size_t length) throw() {\n-  return CHeapObj::operator new(requested_size + length);\n-}\n-\n-void  Chunk::operator delete(void* p, size_t length) {\n-  CHeapObj::operator delete(p);\n-}\n-\n-Chunk::Chunk(size_t length) {\n-  _next = NULL;         \/\/ Chain on the linked list\n-  _len  = length;       \/\/ Save actual size\n-}\n-\n-\/\/------------------------------chop-------------------------------------------\n-void Chunk::chop() {\n-  Chunk *k = this;\n-  while( k ) {\n-    Chunk *tmp = k->_next;\n-    \/\/ clear out this chunk (to detect allocation bugs)\n-    memset(k, 0xBE, k->_len);\n-    free(k);                    \/\/ Free chunk (was malloc'd)\n-    k = tmp;\n-  }\n-}\n-\n-void Chunk::next_chop() {\n-  _next->chop();\n-  _next = NULL;\n-}\n-\n-\/\/------------------------------Arena------------------------------------------\n-Arena::Arena( size_t init_size ) {\n-  init_size = (init_size+3) & ~3;\n-  _first = _chunk = new (init_size) Chunk(init_size);\n-  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n-  _max = _chunk->top();\n-  set_size_in_bytes(init_size);\n-}\n-\n-Arena::Arena() {\n-  _first = _chunk = new (Chunk::init_size) Chunk(Chunk::init_size);\n-  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n-  _max = _chunk->top();\n-  set_size_in_bytes(Chunk::init_size);\n-}\n-\n-Arena::Arena( Arena *a )\n-: _chunk(a->_chunk), _hwm(a->_hwm), _max(a->_max), _first(a->_first) {\n-  set_size_in_bytes(a->size_in_bytes());\n-}\n-\n-\/\/------------------------------used-------------------------------------------\n-\/\/ Total of all Chunks in arena\n-size_t Arena::used() const {\n-  size_t sum = _chunk->_len - (_max-_hwm); \/\/ Size leftover in this Chunk\n-  Chunk *k = _first;\n-  while( k != _chunk) {         \/\/ Whilst have Chunks in a row\n-    sum += k->_len;             \/\/ Total size of this Chunk\n-    k = k->_next;               \/\/ Bump along to next Chunk\n-  }\n-  return sum;                   \/\/ Return total consumed space.\n-}\n-\n-\/\/------------------------------grow-------------------------------------------\n-\/\/ Grow a new Chunk\n-void* Arena::grow( size_t x ) {\n-  \/\/ Get minimal required size.  Either real big, or even bigger for giant objs\n-  size_t len = max(x, Chunk::size);\n-\n-  Chunk *k = _chunk;            \/\/ Get filled-up chunk address\n-  _chunk = new (len) Chunk(len);\n-\n-  if( k ) k->_next = _chunk;    \/\/ Append new chunk to end of linked list\n-  else _first = _chunk;\n-  _hwm  = _chunk->bottom();     \/\/ Save the cached hwm, max\n-  _max =  _chunk->top();\n-  set_size_in_bytes(size_in_bytes() + len);\n-  void* result = _hwm;\n-  _hwm += x;\n-  return result;\n-}\n-\n-\/\/------------------------------calloc-----------------------------------------\n-\/\/ Allocate zeroed storage in Arena\n-void *Arena::Acalloc( size_t items, size_t x ) {\n-  size_t z = items*x;   \/\/ Total size needed\n-  void *ptr = Amalloc(z);       \/\/ Get space\n-  memset( ptr, 0, z );          \/\/ Zap space\n-  return ptr;                   \/\/ Return space\n-}\n-\n-\/\/------------------------------realloc----------------------------------------\n-\/\/ Reallocate storage in Arena.\n-void *Arena::Arealloc( void *old_ptr, size_t old_size, size_t new_size ) {\n-  char *c_old = (char*)old_ptr; \/\/ Handy name\n-  \/\/ Stupid fast special case\n-  if( new_size <= old_size ) {  \/\/ Shrink in-place\n-    if( c_old+old_size == _hwm) \/\/ Attempt to free the excess bytes\n-      _hwm = c_old+new_size;    \/\/ Adjust hwm\n-    return c_old;\n-  }\n-\n-  \/\/ See if we can resize in-place\n-  if( (c_old+old_size == _hwm) &&       \/\/ Adjusting recent thing\n-      (c_old+new_size <= _max) ) {      \/\/ Still fits where it sits\n-    _hwm = c_old+new_size;      \/\/ Adjust hwm\n-    return c_old;               \/\/ Return old pointer\n-  }\n-\n-  \/\/ Oops, got to relocate guts\n-  void *new_ptr = Amalloc(new_size);\n-  memcpy( new_ptr, c_old, old_size );\n-  Afree(c_old,old_size);        \/\/ Mostly done to keep stats accurate\n-  return new_ptr;\n-}\n-\n-\/\/------------------------------reset------------------------------------------\n-\/\/ Reset this Arena to empty, and return this Arenas guts in a new Arena.\n-Arena *Arena::reset(void) {\n-  Arena *a = new Arena(this);   \/\/ New empty arena\n-  _first = _chunk = NULL;       \/\/ Normal, new-arena initialization\n-  _hwm = _max = NULL;\n-  return a;                     \/\/ Return Arena with guts\n-}\n-\n-\/\/------------------------------contains---------------------------------------\n-\/\/ Determine if pointer belongs to this Arena or not.\n-bool Arena::contains( const void *ptr ) const {\n-  if( (void*)_chunk->bottom() <= ptr && ptr < (void*)_hwm )\n-    return true;                \/\/ Check for in this chunk\n-  for( Chunk *c = _first; c; c = c->_next )\n-    if( (void*)c->bottom() <= ptr && ptr < (void*)c->top())\n-      return true;              \/\/ Check for every chunk in Arena\n-  return false;                 \/\/ Not in any Chunk, so not in Arena\n-}\n-\n-\/\/-----------------------------------------------------------------------------\n-\/\/ CHeapObj\n-\n-void* CHeapObj::operator new(size_t size) throw() {\n-  return (void *) AllocateHeap(size);\n-}\n-\n-void CHeapObj::operator delete(void* p){\n- free(p);\n-}\n","filename":"src\/hotspot\/share\/adlc\/arena.cpp","additions":0,"deletions":192,"binary":false,"changes":192,"status":"deleted"},{"patch":"@@ -1,155 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_ADLC_ARENA_HPP\n-#define SHARE_ADLC_ARENA_HPP\n-\n-void* AllocateHeap(size_t size);\n-void* ReAllocateHeap(void* old_ptr, size_t size);\n-\n-\/\/ All classes in adlc may be derived\n-\/\/ from one of the following allocation classes:\n-\/\/\n-\/\/ For objects allocated in the C-heap (managed by: malloc & free).\n-\/\/ - CHeapObj\n-\/\/\n-\/\/ For classes used as name spaces.\n-\/\/ - AllStatic\n-\/\/\n-\n-class CHeapObj {\n- public:\n-  void* operator new(size_t size) throw();\n-  void  operator delete(void* p);\n-  void* new_array(size_t size);\n-};\n-\n-\/\/ Base class for classes that constitute name spaces.\n-\n-class AllStatic {\n- public:\n-  void* operator new(size_t size) throw();\n-  void operator delete(void* p);\n-};\n-\n-\n-\/\/------------------------------Chunk------------------------------------------\n-\/\/ Linked list of raw memory chunks\n-class Chunk: public CHeapObj {\n- private:\n-  \/\/ This ordinary operator delete is needed even though not used, so the\n-  \/\/ below two-argument operator delete will be treated as a placement\n-  \/\/ delete rather than an ordinary sized delete; see C++14 3.7.4.2\/p2.\n-  void operator delete(void* p);\n- public:\n-  void* operator new(size_t size, size_t length) throw();\n-  void  operator delete(void* p, size_t length);\n-  Chunk(size_t length);\n-\n-  enum {\n-      init_size =  1*1024,      \/\/ Size of first chunk\n-      size      = 32*1024       \/\/ Default size of an Arena chunk (following the first)\n-  };\n-  Chunk*       _next;           \/\/ Next Chunk in list\n-  size_t       _len;            \/\/ Size of this Chunk\n-\n-  void chop();                  \/\/ Chop this chunk\n-  void next_chop();             \/\/ Chop next chunk\n-\n-  \/\/ Boundaries of data area (possibly unused)\n-  char* bottom() const { return ((char*) this) + sizeof(Chunk);  }\n-  char* top()    const { return bottom() + _len; }\n-};\n-\n-\n-\/\/------------------------------Arena------------------------------------------\n-\/\/ Fast allocation of memory\n-class Arena: public CHeapObj {\n-protected:\n-  friend class ResourceMark;\n-  friend class HandleMark;\n-  friend class NoHandleMark;\n-  Chunk *_first;                \/\/ First chunk\n-  Chunk *_chunk;                \/\/ current chunk\n-  char *_hwm, *_max;            \/\/ High water mark and max in current chunk\n-  void* grow(size_t x);         \/\/ Get a new Chunk of at least size x\n-  size_t _size_in_bytes;          \/\/ Size of arena (used for memory usage tracing)\n-public:\n-  Arena();\n-  Arena(size_t init_size);\n-  Arena(Arena *old);\n-  ~Arena()                      { _first->chop(); }\n-  char* hwm() const             { return _hwm; }\n-\n-  \/\/ Fast allocate in the arena.  Common case is: pointer test + increment.\n-  void* Amalloc(size_t x) {\n-#ifdef _LP64\n-    x = (x + (8-1)) & ((unsigned)(-8));\n-#else\n-    x = (x + (4-1)) & ((unsigned)(-4));\n-#endif\n-    if (_hwm + x > _max) {\n-      return grow(x);\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n-  }\n-  \/\/ Further assume size is padded out to words\n-  \/\/ Warning:  in LP64, Amalloc_4 is really Amalloc_8\n-  void *Amalloc_4(size_t x) {\n-    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n-    if (_hwm + x > _max) {\n-      return grow(x);\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n-  }\n-\n-  \/\/ Fast delete in area.  Common case is: NOP (except for storage reclaimed)\n-  void Afree(void *ptr, size_t size) {\n-    if (((char*)ptr) + size == _hwm) _hwm = (char*)ptr;\n-  }\n-\n-  void *Acalloc( size_t items, size_t x );\n-  void *Arealloc( void *old_ptr, size_t old_size, size_t new_size );\n-\n-  \/\/ Reset this Arena to empty, and return this Arenas guts in a new Arena.\n-  Arena *reset(void);\n-\n-  \/\/ Determine if pointer belongs to this Arena or not.\n-  bool contains( const void *ptr ) const;\n-\n-  \/\/ Total of all chunks in use (not thread-safe)\n-  size_t used() const;\n-\n-  \/\/ Total # of bytes used\n-  size_t size_in_bytes() const         {  return _size_in_bytes; }\n-  void   set_size_in_bytes(size_t size)  { _size_in_bytes = size;   }\n-};\n-\n-#endif \/\/ SHARE_ADLC_ARENA_HPP\n","filename":"src\/hotspot\/share\/adlc\/arena.hpp","additions":0,"deletions":155,"binary":false,"changes":155,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-  ProductionState(Arena *arena) : _production(cmpstr, hashstr, arena) { initialize(); };\n+  ProductionState(AdlArena *arena) : _production(cmpstr, hashstr, arena) { initialize(); };\n@@ -820,1 +820,1 @@\n-ExprDict::ExprDict( CmpKey cmp, Hash hash, Arena *arena )\n+ExprDict::ExprDict( CmpKey cmp, Hash hash, AdlArena *arena )\n","filename":"src\/hotspot\/share\/adlc\/dfa.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-Dict::Dict(CmpKey initcmp, Hash inithash, Arena *arena) : _hash(inithash), _cmp(initcmp), _arena(arena) {\n+Dict::Dict(CmpKey initcmp, Hash inithash, AdlArena *arena) : _hash(inithash), _cmp(initcmp), _arena(arena) {\n","filename":"src\/hotspot\/share\/adlc\/dict2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  class Arena *_arena;          \/\/ Where to draw storage from\n+  class AdlArena *_arena;       \/\/ Where to draw storage from\n@@ -59,1 +59,1 @@\n-  Dict( CmpKey cmp, Hash hash, Arena *arena );\n+  Dict( CmpKey cmp, Hash hash, AdlArena *arena );\n","filename":"src\/hotspot\/share\/adlc\/dict2.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,3 @@\n-Arena  *Form::arena = Form::generate_arena(); \/\/  = Form::generate_arena();\n-Arena *Form::generate_arena() {\n-  return (new Arena);\n+AdlArena  *Form::arena = Form::generate_arena(); \/\/  = Form::generate_arena();\n+AdlArena *Form::generate_arena() {\n+  return (new AdlArena);\n@@ -43,1 +43,1 @@\n-  _names = (const char**) AllocateHeap(_max*sizeof(char*));\n+  _names = (const char**) AdlAllocateHeap(_max*sizeof(char*));\n@@ -52,1 +52,1 @@\n-    _names = (const char**) ReAllocateHeap(_names, (_max *=2)*sizeof(char*));\n+    _names = (const char**) AdlReAllocateHeap(_names, (_max *=2)*sizeof(char*));\n@@ -313,1 +313,1 @@\n-FormDict::FormDict( CmpKey cmp, Hash hash, Arena *arena )\n+FormDict::FormDict( CmpKey cmp, Hash hash, AdlArena *arena )\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-  FormDict( CmpKey cmp, Hash hash, Arena *arena );\n+  FormDict( CmpKey cmp, Hash hash, AdlArena *arena );\n@@ -122,1 +122,1 @@\n-  static Arena  *arena;            \/\/ arena used by forms\n+  static AdlArena  *arena;         \/\/ arena used by forms\n@@ -124,1 +124,1 @@\n-  static Arena  *generate_arena(); \/\/ allocate arena used by forms\n+  static AdlArena  *generate_arena(); \/\/ allocate arena used by forms\n@@ -576,1 +576,1 @@\n-  ExprDict( CmpKey cmp, Hash hash, Arena *arena );\n+  ExprDict( CmpKey cmp, Hash hash, AdlArena *arena );\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,1 +209,1 @@\n-  \/\/ Chunk and register mask are determined by the register number\n+  \/\/ AdlChunk and register mask are determined by the register number\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-    uniq_idx = (uint*) AllocateHeap(sizeof(uint) * _uniq_idx_length);\n+    uniq_idx = (uint*) AdlAllocateHeap(sizeof(uint) * _uniq_idx_length);\n@@ -3478,1 +3478,1 @@\n-  subtree = (char *)AllocateHeap(len);\n+  subtree = (char *)AdlAllocateHeap(len);\n@@ -3901,1 +3901,1 @@\n-  char* buf = (char*) AllocateHeap(strlen(instr_ident) + 4);\n+  char* buf = (char*) AdlAllocateHeap(strlen(instr_ident) + 4);\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1868,12 +1868,0 @@\n-  \/\/ invoke-special-super\n-  if (bc_raw == Bytecodes::_invokespecial && !target->is_object_initializer()) {\n-    ciInstanceKlass* sender_klass = calling_klass;\n-    if (sender_klass->is_interface()) {\n-      int index = state()->stack_size() - (target->arg_size_no_receiver() + 1);\n-      Value receiver = state()->stack_at(index);\n-      CheckCast* c = new CheckCast(sender_klass, receiver, copy_state_before());\n-      c->set_invokespecial_receiver_check();\n-      state()->stack_at_put(index, append_split(c));\n-    }\n-  }\n-\n@@ -1884,0 +1872,7 @@\n+    case Bytecodes::_invokeinterface:\n+      \/\/ convert to invokespecial if the target is the private interface method.\n+      if (target->is_private()) {\n+        assert(holder->is_interface(), \"How did we get a non-interface method here!\");\n+        code = Bytecodes::_invokespecial;\n+      }\n+      break;\n@@ -1900,0 +1895,20 @@\n+  if (code == Bytecodes::_invokespecial) {\n+    \/\/ Additional receiver subtype checks for interface calls via invokespecial or invokeinterface.\n+    ciKlass* receiver_constraint = nullptr;\n+\n+    if (bc_raw == Bytecodes::_invokeinterface) {\n+      receiver_constraint = holder;\n+    } else if (bc_raw == Bytecodes::_invokespecial && !target->is_object_initializer() && calling_klass->is_interface()) {\n+      receiver_constraint = calling_klass;\n+    }\n+\n+    if (receiver_constraint != nullptr) {\n+      int index = state()->stack_size() - (target->arg_size_no_receiver() + 1);\n+      Value receiver = state()->stack_at(index);\n+      CheckCast* c = new CheckCast(receiver_constraint, receiver, copy_state_before());\n+      \/\/ go to uncommon_trap when checkcast fails\n+      c->set_invokespecial_receiver_check();\n+      state()->stack_at_put(index, append_split(c));\n+    }\n+  }\n+\n@@ -2028,1 +2043,3 @@\n-  if (!PatchALot && Inline && target->is_loaded() && callee_holder->is_linked() && !patch_for_appendix) {\n+  if (!PatchALot && Inline && target->is_loaded() && !patch_for_appendix &&\n+      callee_holder->is_loaded()) { \/\/ the effect of symbolic reference resolution\n+\n@@ -2030,1 +2047,1 @@\n-    if ((code == Bytecodes::_invokestatic && callee_holder->is_initialized()) || \/\/ invokestatic involves an initialization barrier on resolved klass\n+    if ((code == Bytecodes::_invokestatic && klass->is_initialized()) || \/\/ invokestatic involves an initialization barrier on declaring class\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":31,"deletions":14,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -368,1 +368,6 @@\n-  return instruction->dominator_depth() < loop_header->dominator_depth();\n+  for (BlockBegin *d = loop_header->dominator(); d != NULL; d = d->dominator()) {\n+    if (d == instruction->block()) {\n+      return true;\n+    }\n+  }\n+  return false;\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -419,2 +419,2 @@\n-        constantTag tag = s.get_constant_pool_tag(index);\n-        if (tag.is_long() || tag.is_double()) {\n+        BasicType con_bt = s.get_basic_type_for_constant_at(index);\n+        if (con_bt == T_LONG || con_bt == T_DOUBLE) {\n@@ -423,1 +423,1 @@\n-        } else if (tag.basic_type() == T_OBJECT) {\n+        } else if (con_bt == T_OBJECT) {\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,0 +130,11 @@\n+\n+  bool is_loaded() const {\n+    if (is_valid()) {\n+      if (is_reference_type(basic_type())) {\n+        return as_object()->is_loaded();\n+      } else {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciConstant.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -435,7 +435,0 @@\n-  \/\/ setup up the proper type to return on OOM\n-  ciKlass* fail_type;\n-  if (sym->char_at(0) == JVM_SIGNATURE_ARRAY) {\n-    fail_type = _unloaded_ciobjarrayklass;\n-  } else {\n-    fail_type = _unloaded_ciinstance_klass;\n-  }\n@@ -523,1 +516,0 @@\n-  EXCEPTION_CONTEXT;\n@@ -531,1 +523,1 @@\n-    klass =  ConstantPool::klass_at_if_loaded(cpool, index);\n+    klass = ConstantPool::klass_at_if_loaded(cpool, index);\n@@ -591,1 +583,0 @@\n-  EXCEPTION_CONTEXT;\n@@ -602,1 +593,1 @@\n-      if (cpool->tag_at(index).is_dynamic_constant())\n+      if (cpool->tag_at(index).is_dynamic_constant()) {\n@@ -604,2 +595,2 @@\n-      if (is_reference_type(bt)) {\n-      } else {\n+      }\n+      if (!is_reference_type(bt)) {\n@@ -607,1 +598,3 @@\n-        if (!is_java_primitive(bt))  return ciConstant();\n+        if (!is_java_primitive(bt)) {\n+          return ciConstant();\n+        }\n@@ -642,0 +635,1 @@\n+    EXCEPTION_CONTEXT;\n@@ -658,1 +652,1 @@\n-    return ciConstant();\n+    return ciConstant(T_OBJECT, get_unloaded_klass_mirror(NULL));\n@@ -660,1 +654,0 @@\n-    \/\/ 4881222: allow ldc to take a class type\n@@ -662,5 +655,0 @@\n-    if (HAS_PENDING_EXCEPTION) {\n-      CLEAR_PENDING_EXCEPTION;\n-      record_out_of_memory_failure();\n-      return ciConstant();\n-    }\n@@ -670,1 +658,1 @@\n-  } else if (tag.is_method_type()) {\n+  } else if (tag.is_method_type() || tag.is_method_type_in_error()) {\n@@ -675,1 +663,1 @@\n-  } else if (tag.is_method_handle()) {\n+  } else if (tag.is_method_handle() || tag.is_method_handle_in_error()) {\n@@ -684,2 +672,2 @@\n-  } else if (tag.is_dynamic_constant()) {\n-    return ciConstant();\n+  } else if (tag.is_dynamic_constant() || tag.is_dynamic_constant_in_error()) {\n+    return ciConstant(); \/\/ not supported\n@@ -687,1 +675,1 @@\n-    ShouldNotReachHere();\n+    assert(false, \"unknown tag: %d (%s)\", tag.value(), tag.internal_name());\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":14,"deletions":26,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -254,0 +254,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciBytecodeStream::get_basic_type_for_constant_at\n+\/\/\n+BasicType ciBytecodeStream::get_basic_type_for_constant_at(int index) const {\n+  VM_ENTRY_MARK;\n+  return _method->get_Method()->constants()->basic_type_for_constant_at(index);\n+}\n+\n@@ -479,2 +487,3 @@\n-  if (cur_bc() == Bytecodes::_invokedynamic)\n-    return CURRENT_ENV->get_klass_by_name(_holder, ciSymbols::java_lang_invoke_MethodHandle(), false);\n+  if (cur_bc() == Bytecodes::_invokedynamic) {\n+    return CURRENT_ENV->MethodHandle_klass();\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  \/\/ Does this instruction contain an index which refes into the CP cache?\n+  \/\/ Does this instruction contain an index which refers into the CP cache?\n@@ -227,1 +227,1 @@\n-  ciConstant get_constant();\n+  ciConstant  get_constant();\n@@ -229,0 +229,1 @@\n+  BasicType   get_basic_type_for_constant_at(int index) const;\n@@ -236,3 +237,11 @@\n-  bool is_unresolved_klass_in_error() const {\n-    constantTag tag = get_constant_pool_tag(get_klass_index());\n-    return tag.is_unresolved_klass_in_error();\n+  bool is_in_error() const {\n+    assert(cur_bc() == Bytecodes::_ldc    ||\n+           cur_bc() == Bytecodes::_ldc_w  ||\n+           cur_bc() == Bytecodes::_ldc2_w, \"not supported: %s\", Bytecodes::name(cur_bc()));\n+\n+    int index = get_constant_pool_index();\n+    constantTag tag = get_constant_pool_tag(index);\n+    return tag.is_unresolved_klass_in_error() ||\n+           tag.is_method_handle_in_error()    ||\n+           tag.is_method_type_in_error()      ||\n+           tag.is_dynamic_constant_in_error();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -723,0 +723,5 @@\n+  if (str->is_in_error()) {\n+    trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                      Deoptimization::Action_none));\n+    return;\n+  }\n@@ -738,8 +743,4 @@\n-    if (str->is_unresolved_klass_in_error()) {\n-      trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n-                                                        Deoptimization::Action_none));\n-    } else {\n-      \/\/ OutOfMemoryError in the CI while loading constant\n-      push_null();\n-      outer()->record_failure(\"ldc did not link\");\n-    }\n+    \/\/ OutOfMemoryError in the CI while loading constant.\n+    \/\/ Unresolved condy also lands here (not yet supported).\n+    push_null();\n+    outer()->record_failure(\"ldc did not link\");\n@@ -2176,1 +2177,1 @@\n-      return str.is_unresolved_klass_in_error();\n+      return str.is_in_error();\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -4122,2 +4122,6 @@\n-  for (int i = 0, limit = pts->length(); i < limit; i++) {\n-    java_lang_Class::print_signature(pts->obj_at(i), st);\n+  if (pts != NULL) {\n+    for (int i = 0, limit = pts->length(); i < limit; i++) {\n+      java_lang_Class::print_signature(pts->obj_at(i), st);\n+    }\n+  } else {\n+    st->print(\"NULL\");\n@@ -4126,1 +4130,6 @@\n-  java_lang_Class::print_signature(rtype(mt), st);\n+  oop rt = rtype(mt);\n+  if (rt != NULL) {\n+    java_lang_Class::print_signature(rt, st);\n+  } else {\n+    st->print(\"NULL\");\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2016,1 +2016,1 @@\n-    if (!Arguments::is_interpreter_only()) {\n+    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n@@ -2018,0 +2018,1 @@\n+      \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n@@ -2080,3 +2081,3 @@\n-                                                          Klass* accessing_klass,\n-                                                          Handle *appendix_result,\n-                                                          TRAPS) {\n+                                                     Klass* accessing_klass,\n+                                                     Handle* appendix_result,\n+                                                     TRAPS) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -490,1 +490,1 @@\n-  NMethodSweeper::report_allocation(code_blob_type);\n+  NMethodSweeper::report_allocation();\n@@ -515,1 +515,1 @@\n-        \/\/ and force stack scanning if less than 10% of the code heap are free.\n+        \/\/ and force stack scanning if less than 10% of the entire code cache are free.\n@@ -892,9 +892,0 @@\n-\/**\n- * Returns the reverse free ratio. E.g., if 25% (1\/4) of the code heap\n- * is free, reverse_free_ratio() returns 4.\n- *\/\n-double CodeCache::reverse_free_ratio(int code_blob_type) {\n-  CodeHeap* heap = get_code_heap(code_blob_type);\n-  if (heap == NULL) {\n-    return 0;\n-  }\n@@ -902,4 +893,10 @@\n-  double unallocated_capacity = MAX2((double)heap->unallocated_capacity(), 1.0); \/\/ Avoid division by 0;\n-  double max_capacity = (double)heap->max_capacity();\n-  double result = max_capacity \/ unallocated_capacity;\n-  assert (max_capacity >= unallocated_capacity, \"Must be\");\n+\/\/ Returns the reverse free ratio. E.g., if 25% (1\/4) of the code cache\n+\/\/ is free, reverse_free_ratio() returns 4.\n+\/\/ Since code heap for each type of code blobs falls forward to the next\n+\/\/ type of code heap, return the reverse free ratio for the entire\n+\/\/ code cache.\n+double CodeCache::reverse_free_ratio() {\n+  double unallocated = MAX2((double)unallocated_capacity(), 1.0); \/\/ Avoid division by 0;\n+  double max = (double)max_capacity();\n+  double result = max \/ unallocated;\n+  assert (max >= unallocated, \"Must be\");\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-  static double reverse_free_ratio(int code_blob_type);\n+  static double reverse_free_ratio();\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,1 +318,1 @@\n-      double current_reverse_free_ratio = CodeCache::reverse_free_ratio(CodeCache::get_code_blob_type(level));\n+      double current_reverse_free_ratio = CodeCache::reverse_free_ratio();\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -227,0 +227,2 @@\n+    \/\/ Note: This method can be called from non-Java\/compiler threads to\n+    \/\/ log the global metaspace failure that might affect profiling.\n@@ -231,1 +233,1 @@\n-    log(JavaThread::current(), \"%s\", (const char*)lm);\n+    log(Thread::current(), \"%s\", (const char*)lm);\n@@ -1993,0 +1995,2 @@\n+      } else {\n+        task->set_failure_reason(\"breakpoints are present\");\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  assert(threshold >= 0, \"must be\");\n@@ -130,1 +131,7 @@\n-    return (intx)(threshold * scale);\n+    double v = threshold * scale;\n+    assert(v >= 0, \"must be\");\n+    if (v > max_intx) {\n+      return max_intx;\n+    } else {\n+      return (intx)(v);\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    result.set_handle(method, appendix, THREAD);\n+    result.set_handle(vmClasses::MethodHandle_klass(), method, appendix, THREAD);\n@@ -224,1 +224,1 @@\n-  result.set_handle(resolved_method(), resolved_appendix(), CHECK);\n+  result.set_handle(vmClasses::MethodHandle_klass(), resolved_method(), resolved_appendix(), CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/bootstrapInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,5 +97,0 @@\n-void CallInfo::set_handle(const methodHandle& resolved_method,\n-                          Handle resolved_appendix, TRAPS) {\n-  set_handle(vmClasses::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);\n-}\n-\n@@ -479,8 +474,6 @@\n-      Handle method_type;\n-      Method* result = SystemDictionary::find_method_handle_invoker(\n-                                                            klass,\n-                                                            name,\n-                                                            full_signature,\n-                                                            link_info.current_klass(),\n-                                                            &appendix,\n-                                                            CHECK_NULL);\n+      Method* result = SystemDictionary::find_method_handle_invoker(klass,\n+                                                                    name,\n+                                                                    full_signature,\n+                                                                    link_info.current_klass(),\n+                                                                    &appendix,\n+                                                                    CHECK_NULL);\n@@ -624,1 +617,1 @@\n-      || (resolved_klass == vmClasses::MethodHandle_klass() &&\n+      || ((resolved_klass == vmClasses::MethodHandle_klass() || resolved_klass == vmClasses::VarHandle_klass()) &&\n@@ -1682,0 +1675,13 @@\n+bool LinkResolver::resolve_previously_linked_invokehandle(CallInfo& result, const LinkInfo& link_info, const constantPoolHandle& pool, int index, TRAPS) {\n+  int cache_index = ConstantPool::decode_cpcache_index(index, true);\n+  ConstantPoolCacheEntry* cpce = pool->cache()->entry_at(cache_index);\n+  if (!cpce->is_f1_null()) {\n+    Klass* resolved_klass = link_info.resolved_klass();\n+    methodHandle method(THREAD, cpce->f1_as_method());\n+    Handle     appendix(THREAD, cpce->appendix_if_resolved(pool));\n+    result.set_handle(resolved_klass, method, appendix, CHECK_false);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n@@ -1684,1 +1690,0 @@\n-  \/\/ This guy is reached from InterpreterRuntime::resolve_invokehandle.\n@@ -1691,0 +1696,4 @@\n+  { \/\/ Check if the call site has been bound already, and short circuit:\n+    bool is_done = resolve_previously_linked_invokehandle(result, link_info, pool, index, CHECK);\n+    if (is_done) return;\n+  }\n@@ -1702,1 +1711,1 @@\n-  Handle       resolved_appendix;\n+  Handle resolved_appendix;\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -69,2 +69,0 @@\n-  void set_handle(const methodHandle& resolved_method,\n-                  Handle resolved_appendix, TRAPS);\n@@ -252,0 +250,5 @@\n+  static bool resolve_previously_linked_invokehandle(CallInfo& result,\n+                                                     const LinkInfo& link_info,\n+                                                     const constantPoolHandle& pool,\n+                                                     int index, TRAPS);\n+\n@@ -340,1 +343,0 @@\n- public:\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2342,1 +2342,1 @@\n-C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))\n+C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle, jboolean callPostTranslation))\n@@ -2393,1 +2393,3 @@\n-      if (nm == NULL) {\n+      if (result.is_null()) {\n+        \/\/ exception occurred (e.g. OOME) creating a new HotSpotNmethod\n+      } else if (nm == NULL) {\n@@ -2416,0 +2418,7 @@\n+  if (callPostTranslation) {\n+    peerEnv->call_HotSpotJVMCIRuntime_postTranslation(result, JVMCI_CHECK_0);\n+  }\n+  \/\/ Propagate any exception that occurred while creating the translated object\n+  if (peerEnv->transfer_pending_exception(thread, thisEnv)) {\n+    return 0L;\n+  }\n@@ -2713,1 +2722,1 @@\n-  {CC \"translate\",                                    CC \"(\" OBJECT \")J\",                                                                   FN_PTR(translate)},\n+  {CC \"translate\",                                    CC \"(\" OBJECT \"Z)J\",                                                                  FN_PTR(translate)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,14 +281,62 @@\n-void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle& throwable) {\n-  assert(!is_hotspot(), \"must_be\");\n-  \/\/ Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets\n-  \/\/ may not have been called.\n-  Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);\n-  JavaCallArguments jargs;\n-  jargs.push_oop(throwable);\n-  JavaValue result(T_OBJECT);\n-  JavaCalls::call_static(&result,\n-                          runtimeKlass,\n-                          vmSymbols::encodeThrowable_name(),\n-                          vmSymbols::encodeThrowable_signature(), &jargs, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    JVMCIRuntime::fatal_exception(this, \"HotSpotJVMCIRuntime.encodeThrowable should not throw an exception\");\n+\/\/ Shared code for translating an exception from HotSpot to libjvmci or vice versa.\n+class ExceptionTranslation: public StackObj {\n+ protected:\n+  JVMCIEnv*  _from_env; \/\/ Source of translation. Can be nullptr.\n+  JVMCIEnv*  _to_env;   \/\/ Destination of translation. Never nullptr.\n+\n+  ExceptionTranslation(JVMCIEnv* from_env, JVMCIEnv* to_env) : _from_env(from_env), _to_env(to_env) {}\n+\n+  \/\/ Encodes the exception in `_from_env` into `buffer`.\n+  \/\/ Where N is the number of bytes needed for the encoding, returns N if N <= `buffer_size`\n+  \/\/ and the encoding was written to `buffer` otherwise returns -N.\n+  virtual int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) = 0;\n+\n+  \/\/ Decodes the exception in `buffer` in `_to_env` and throws it.\n+  virtual void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) = 0;\n+\n+ public:\n+  void doit(JavaThread* THREAD) {\n+    \/\/ Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets\n+    \/\/ may not have been called.\n+    Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);\n+\n+    int buffer_size = 2048;\n+    while (true) {\n+      ResourceMark rm;\n+      jlong buffer = (jlong) NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, jbyte, buffer_size);\n+      int res = encode(THREAD, runtimeKlass, buffer, buffer_size);\n+      if ((_from_env != nullptr && _from_env->has_pending_exception()) || HAS_PENDING_EXCEPTION) {\n+        JVMCIRuntime::fatal_exception(_from_env, \"HotSpotJVMCIRuntime.encodeThrowable should not throw an exception\");\n+      }\n+      if (res < 0) {\n+        int required_buffer_size = -res;\n+        if (required_buffer_size > buffer_size) {\n+          buffer_size = required_buffer_size;\n+        }\n+      } else {\n+        decode(THREAD, runtimeKlass, buffer);\n+        if (!_to_env->has_pending_exception()) {\n+          JVMCIRuntime::fatal_exception(_to_env, \"HotSpotJVMCIRuntime.decodeAndThrowThrowable should throw an exception\");\n+        }\n+        return;\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Translates an exception on the HotSpot heap to an exception on the shared library heap.\n+class HotSpotToSharedLibraryExceptionTranslation : public ExceptionTranslation {\n+ private:\n+  const Handle& _throwable;\n+\n+  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+    JavaCallArguments jargs;\n+    jargs.push_oop(_throwable);\n+    jargs.push_long(buffer);\n+    jargs.push_int(buffer_size);\n+    JavaValue result(T_INT);\n+    JavaCalls::call_static(&result,\n+                            runtimeKlass,\n+                            vmSymbols::encodeThrowable_name(),\n+                            vmSymbols::encodeThrowable_signature(), &jargs, THREAD);\n+    return result.get_jint();\n@@ -297,1 +345,10 @@\n-  oop encoded_throwable_string = result.get_oop();\n+  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+    JNIAccessMark jni(_to_env, THREAD);\n+    jni()->CallStaticVoidMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                JNIJVMCI::HotSpotJVMCIRuntime::decodeAndThrowThrowable_method(),\n+                                buffer);\n+  }\n+ public:\n+  HotSpotToSharedLibraryExceptionTranslation(JVMCIEnv* hotspot_env, JVMCIEnv* jni_env, const Handle& throwable) :\n+    ExceptionTranslation(hotspot_env, jni_env), _throwable(throwable) {}\n+};\n@@ -299,2 +356,4 @@\n-  ResourceMark rm;\n-  const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);\n+\/\/ Translates an exception on the shared library heap to an exception on the HotSpot heap.\n+class SharedLibraryToHotSpotExceptionTranslation : public ExceptionTranslation {\n+ private:\n+  jthrowable _throwable;\n@@ -302,6 +361,23 @@\n-  JNIAccessMark jni(this, THREAD);\n-  jobject jni_encoded_throwable_string = jni()->NewStringUTF(encoded_throwable_chars);\n-  jthrowable jni_throwable = (jthrowable) jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),\n-                                jni_encoded_throwable_string);\n-  jni()->Throw(jni_throwable);\n+  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+    JNIAccessMark jni(_from_env, THREAD);\n+    return jni()->CallStaticIntMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                      JNIJVMCI::HotSpotJVMCIRuntime::encodeThrowable_method(),\n+                                      _throwable, buffer, buffer_size);\n+  }\n+\n+  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+    JavaCallArguments jargs;\n+    jargs.push_long(buffer);\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result,\n+                            runtimeKlass,\n+                            vmSymbols::decodeAndThrowThrowable_name(),\n+                            vmSymbols::long_void_signature(), &jargs, THREAD);\n+  }\n+ public:\n+  SharedLibraryToHotSpotExceptionTranslation(JVMCIEnv* hotspot_env, JVMCIEnv* jni_env, jthrowable throwable) :\n+    ExceptionTranslation(jni_env, hotspot_env), _throwable(throwable) {}\n+};\n+\n+void JVMCIEnv::translate_to_jni_exception(JavaThread* THREAD, const Handle& throwable, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env) {\n+  HotSpotToSharedLibraryExceptionTranslation(hotspot_env, jni_env, throwable).doit(THREAD);\n@@ -310,0 +386,30 @@\n+void JVMCIEnv::translate_from_jni_exception(JavaThread* THREAD, jthrowable throwable, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env) {\n+  SharedLibraryToHotSpotExceptionTranslation(hotspot_env, jni_env, throwable).doit(THREAD);\n+}\n+\n+jboolean JVMCIEnv::transfer_pending_exception(JavaThread* THREAD, JVMCIEnv* peer_env) {\n+  if (is_hotspot()) {\n+    if (HAS_PENDING_EXCEPTION) {\n+      Handle throwable = Handle(THREAD, PENDING_EXCEPTION);\n+      CLEAR_PENDING_EXCEPTION;\n+      translate_to_jni_exception(THREAD, throwable, this, peer_env);\n+      return true;\n+    }\n+  } else {\n+    jthrowable ex = nullptr;\n+    {\n+      JNIAccessMark jni(this, THREAD);\n+      ex = jni()->ExceptionOccurred();\n+      if (ex != nullptr) {\n+        jni()->ExceptionClear();\n+      }\n+    }\n+    if (ex != nullptr) {\n+      translate_from_jni_exception(THREAD, ex, peer_env, this);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\n@@ -321,1 +427,1 @@\n-          translate_hotspot_exception_to_jni_exception(THREAD, throwable);\n+          translate_to_jni_exception(THREAD, throwable, nullptr, this);\n@@ -804,0 +910,17 @@\n+void JVMCIEnv::call_HotSpotJVMCIRuntime_postTranslation(JVMCIObject object, JVMCIEnv* JVMCIENV) {\n+  JavaThread* THREAD = JVMCI::compilation_tick(JavaThread::current()); \/\/ For exception macros.\n+  if (is_hotspot()) {\n+    JavaCallArguments jargs;\n+    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result,\n+                           HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n+                           vmSymbols::postTranslation_name(),\n+                           vmSymbols::object_void_signature(), &jargs, CHECK);\n+  } else {\n+    JNIAccessMark jni(this, THREAD);\n+    jni()->CallStaticVoidMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                JNIJVMCI::HotSpotJVMCIRuntime::postTranslation_method(),\n+                                object.as_jobject());\n+  }\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":148,"deletions":25,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,5 +174,9 @@\n-  \/\/ Translates an exception on the HotSpot heap to an exception on\n-  \/\/ the shared library heap. The translation includes the stack and\n-  \/\/ causes of `throwable`. The translated exception is pending in the\n-  \/\/ shared library thread upon returning.\n-  void translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle& throwable);\n+  \/\/ Translates an exception on the HotSpot heap (i.e., hotspot_env) to an exception on\n+  \/\/ the shared library heap (i.e., jni_env). The translation includes the stack and cause(s) of `throwable`.\n+  \/\/ The translated exception is pending in jni_env upon returning.\n+  static void translate_to_jni_exception(JavaThread* THREAD, const Handle& throwable, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env);\n+\n+  \/\/ Translates an exception on the shared library heap (i.e., jni_env) to an exception on\n+  \/\/ the HotSpot heap (i.e., hotspot_env). The translation includes the stack and cause(s) of `throwable`.\n+  \/\/ The translated exception is pending in hotspot_env upon returning.\n+  static void translate_from_jni_exception(JavaThread* THREAD, jthrowable throwable, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env);\n@@ -228,0 +232,5 @@\n+  \/\/ If this env has a pending exception, it is translated to be a pending\n+  \/\/ exception in `peer_env` and is cleared from this env. Returns true\n+  \/\/ if a pending exception was transferred, false otherwise.\n+  jboolean transfer_pending_exception(JavaThread* THREAD, JVMCIEnv* peer_env);\n+\n@@ -314,0 +323,2 @@\n+  void call_HotSpotJVMCIRuntime_postTranslation(JVMCIObject object, JVMCI_TRAPS);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -352,2 +352,2 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, decodeThrowable, decodeThrowable_signature, (JVMCIObject encodedThrowable)) \\\n+    jvmci_method(CallStaticBooleanMethod, GetStaticMethodID, call_static, bool, HotSpotJVMCIRuntime, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, decodeAndThrowThrowable, long_void_signature, (jlong buffer)) \\\n@@ -359,0 +359,1 @@\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, postTranslation, object_void_signature, (JVMCIObject object, JVMCI_TRAPS)) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,3 +108,2 @@\n-  template(encodeThrowable_signature,                             \"(Ljava\/lang\/Throwable;)Ljava\/lang\/String;\")                            \\\n-  template(decodeThrowable_name,                                  \"decodeThrowable\")                                                      \\\n-  template(decodeThrowable_signature,                             \"(Ljava\/lang\/String;)Ljava\/lang\/Throwable;\")                            \\\n+  template(encodeThrowable_signature,                             \"(Ljava\/lang\/Throwable;JI)I\")                                           \\\n+  template(decodeAndThrowThrowable_name,                          \"decodeAndThrowThrowable\")                                              \\\n@@ -126,0 +125,1 @@\n+  template(postTranslation_name,                                  \"postTranslation\")                                                      \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,3 +368,3 @@\n-    \/\/ Skip over Windows paths such as \"C:\\...\"\n-    \/\/ Handle both C:\\... and file=C:\\...\"\n-    if (next != NULL && next[0] == ':' && next[1] == '\\\\') {\n+    \/\/ Skip over Windows paths such as \"C:\\...\" and \"C:\/...\".\n+    \/\/ Handles both \"C:\\...\" and \"file=C:\\...\".\n+    if (next != NULL && next[0] == ':' && (next[1] == '\\\\' || next[1] == '\/')) {\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,0 +337,5 @@\n+\n+    if (n_deviates == 1 && n_selections == 0) {\n+      \/\/ we're done as we couldn't reduce things any further\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/logging\/logOutput.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1239,0 +1239,1 @@\n+      _fullgc_alot_dummy_array = OopHandle(); \/\/ NULL out OopStorage pointer.\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -887,2 +887,1 @@\n-  if (tag.is_dynamic_constant() ||\n-      tag.is_dynamic_constant_in_error()) {\n+  if (tag.is_dynamic_constant()) {\n@@ -890,2 +889,1 @@\n-    \/\/ dynamic constant could return an array, treat as object\n-    return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);\n+    return constantTag(constantTag::type2tag(bt));\n@@ -978,1 +976,0 @@\n-  case JVM_CONSTANT_UnresolvedClassInError:\n@@ -1046,8 +1043,0 @@\n-  case JVM_CONSTANT_DynamicInError:\n-  case JVM_CONSTANT_MethodHandleInError:\n-  case JVM_CONSTANT_MethodTypeInError:\n-    {\n-      throw_resolution_error(this_cp, index, CHECK_NULL);\n-      break;\n-    }\n-\n@@ -1067,1 +1056,4 @@\n-      Klass* callee = klass_at_impl(this_cp, callee_index, CHECK_NULL);\n+      Klass* callee = klass_at_impl(this_cp, callee_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n+      }\n@@ -1071,1 +1063,1 @@\n-          ((!callee->is_interface() && m_tag.is_interface_method()))) {\n+          (!callee->is_interface() && m_tag.is_interface_method())) {\n@@ -1083,1 +1075,2 @@\n-        THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());\n+        Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \"%s\", ss.as_string());\n+        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n@@ -1090,1 +1083,0 @@\n-      result_oop = value();\n@@ -1094,0 +1086,1 @@\n+      result_oop = value();\n@@ -1138,0 +1131,7 @@\n+  case JVM_CONSTANT_UnresolvedClassInError:\n+  case JVM_CONSTANT_DynamicInError:\n+  case JVM_CONSTANT_MethodHandleInError:\n+  case JVM_CONSTANT_MethodTypeInError:\n+    throw_resolution_error(this_cp, index, CHECK_NULL);\n+    break;\n+\n@@ -1139,3 +1139,1 @@\n-    DEBUG_ONLY( tty->print_cr(\"*** %p: tag at CP[%d\/%d] = %d\",\n-                              this_cp(), index, cache_index, tag.value()));\n-    assert(false, \"unexpected constant tag\");\n+    fatal(\"unexpected constant tag at CP %p[%d\/%d] = %d\", this_cp(), index, cache_index, tag.value());\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1189,1 +1189,1 @@\n-  if (_i2i_entry != NULL) {\n+  if (adapter() != NULL) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -192,3 +192,2 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-  if (igvn != NULL) {\n-    igvn->_worklist.push(mem);\n+  if (can_reshape) {\n+    phase->is_IterGVN()->_worklist.push(mem);\n@@ -297,0 +296,4 @@\n+    if (src_offset->is_top()) {\n+      \/\/ Offset is out of bounds (the ArrayCopyNode will be removed)\n+      return false;\n+    }\n@@ -298,1 +301,1 @@\n-    if (src_offset->is_top() || dest_offset->is_top()) {\n+    if (dest_offset->is_top()) {\n@@ -300,0 +303,4 @@\n+      if (can_reshape) {\n+        \/\/ record src_offset, so it can be deleted later (if it is dead)\n+        phase->is_IterGVN()->_worklist.push(src_offset);\n+      }\n@@ -319,3 +326,0 @@\n-    adr_src  = phase->transform(new AddPNode(base_src, base_src, src_offset));\n-    adr_dest = phase->transform(new AddPNode(base_dest, base_dest, dest_offset));\n-\n@@ -332,0 +336,3 @@\n+    adr_src  = phase->transform(new AddPNode(base_src, base_src, src_offset));\n+    adr_dest = phase->transform(new AddPNode(base_dest, base_dest, dest_offset));\n+\n@@ -569,0 +576,2 @@\n+    assert(adr_src == NULL, \"no node can be left behind\");\n+    assert(adr_dest == NULL, \"no node can be left behind\");\n@@ -632,0 +641,4 @@\n+    if (can_reshape) {\n+      \/\/ put in worklist, so that if it happens to be dead it is removed\n+      phase->is_IterGVN()->_worklist.push(mem);\n+    }\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -419,0 +419,7 @@\n+  \/\/ When inlining a virtual call, the null check at the call and the call itself can throw. These 2 paths have different\n+  \/\/ expression stacks which causes late inlining to break. The MH invoker is not expected to be called from a method wih\n+  \/\/ exception handlers. When there is no exception handler, GraphKit::builtin_throw() pops the stack which solves the issue\n+  \/\/ of late inlining with exceptions.\n+  assert(!jvms->method()->has_exception_handlers() ||\n+         (method()->intrinsic_id() != vmIntrinsics::_linkToVirtual &&\n+          method()->intrinsic_id() != vmIntrinsics::_linkToInterface), \"no exception handler expected\");\n@@ -522,0 +529,4 @@\n+    if (C->print_inlining() || C->print_intrinsics()) {\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(),\n+                        \"late call devirtualization failed (receiver may be null)\");\n+    }\n@@ -528,0 +539,4 @@\n+    if (C->print_inlining() || C->print_intrinsics()) {\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(),\n+                        \"late call devirtualization failed (interface call)\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1657,0 +1657,1 @@\n+  init_req( ValidLengthTest    , topnode);\n@@ -1689,48 +1690,0 @@\n-\/\/=============================================================================\n-Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (remove_dead_region(phase, can_reshape))  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if (in(0) && in(0)->is_top())  return NULL;\n-\n-  const Type* type = phase->type(Ideal_length());\n-  if (type->isa_int() && type->is_int()->_hi < 0) {\n-    if (can_reshape) {\n-      PhaseIterGVN *igvn = phase->is_IterGVN();\n-      \/\/ Unreachable fall through path (negative array length),\n-      \/\/ the allocation can only throw so disconnect it.\n-      Node* proj = proj_out_or_null(TypeFunc::Control);\n-      Node* catchproj = NULL;\n-      if (proj != NULL) {\n-        for (DUIterator_Fast imax, i = proj->fast_outs(imax); i < imax; i++) {\n-          Node *cn = proj->fast_out(i);\n-          if (cn->is_Catch()) {\n-            catchproj = cn->as_Multi()->proj_out_or_null(CatchProjNode::fall_through_index);\n-            break;\n-          }\n-        }\n-      }\n-      if (catchproj != NULL && catchproj->outcnt() > 0 &&\n-          (catchproj->outcnt() > 1 ||\n-           catchproj->unique_out()->Opcode() != Op_Halt)) {\n-        assert(catchproj->is_CatchProj(), \"must be a CatchProjNode\");\n-        Node* nproj = catchproj->clone();\n-        igvn->register_new_node_with_optimizer(nproj);\n-\n-        Node *frame = new ParmNode( phase->C->start(), TypeFunc::FramePtr );\n-        frame = phase->transform(frame);\n-        \/\/ Halt & Catch Fire\n-        Node* halt = new HaltNode(nproj, frame, \"unexpected negative array length\");\n-        phase->C->root()->add_req(halt);\n-        phase->transform(halt);\n-\n-        igvn->replace_node(catchproj, phase->C->top());\n-        return this;\n-      }\n-    } else {\n-      \/\/ Can't correct it during regular GVN so register for IGVN\n-      phase->C->record_for_igvn(this);\n-    }\n-  }\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":48,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -916,0 +916,1 @@\n+    ValidLengthTest,\n@@ -925,0 +926,1 @@\n+    fields[ValidLengthTest] = TypeInt::BOOL;\n@@ -1019,4 +1021,2 @@\n-  AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,\n-                    Node* size, Node* klass_node, Node* initial_test,\n-                    Node* count_val\n-                    )\n+  AllocateArrayNode(Compile* C, const TypeFunc* atype, Node* ctrl, Node* mem, Node* abio, Node* size, Node* klass_node,\n+                    Node* initial_test, Node* count_val, Node* valid_length_test)\n@@ -1028,0 +1028,1 @@\n+    set_req(AllocateNode::ValidLengthTest, valid_length_test);\n@@ -1030,1 +1031,0 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2634,0 +2634,11 @@\n+      } else if (call->is_AllocateArray()) {\n+        Node* klass_node = call->in(AllocateNode::KlassNode);\n+        Node* length = call->in(AllocateNode::ALength);\n+        const Type* length_type = phase->type(length);\n+        const Type* klass_type = phase->type(klass_node);\n+        Node* valid_length_test = call->in(AllocateNode::ValidLengthTest);\n+        const Type* valid_length_test_t = phase->type(valid_length_test);\n+        if (length_type == Type::TOP || klass_type == Type::TOP || valid_length_test_t == Type::TOP ||\n+            valid_length_test_t->is_int()->is_con(0)) {\n+          f[CatchProjNode::fall_through_index] = Type::TOP;\n+        }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3743,1 +3743,1 @@\n-          CallNode *call = n->in(0)->in(0)->as_Call();\n+          CallNode* call = n->in(0)->in(0)->as_Call();\n@@ -3752,1 +3752,1 @@\n-            Node *arg0 = call->in(TypeFunc::Parms);\n+            Node* arg0 = call->in(TypeFunc::Parms);\n@@ -3757,4 +3757,3 @@\n-          } else if (call->entry_point() == OptoRuntime::new_array_Java() &&\n-                     call->req() > TypeFunc::Parms+1 &&\n-                     call->is_CallStaticJava()) {\n-            \/\/ Check for negative array length. In such case, the optimizer has\n+          } else if (call->entry_point() == OptoRuntime::new_array_Java() ||\n+                     call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n+            \/\/ Check for illegal array length. In such case, the optimizer has\n@@ -3763,3 +3762,5 @@\n-            Node *arg1 = call->in(TypeFunc::Parms+1);\n-            if (arg1->is_Type() &&\n-                arg1->as_Type()->type()->join(TypeInt::POS)->empty()) {\n+            assert(call->is_CallStaticJava(), \"static call expected\");\n+            assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n+            Node* valid_length_test = call->in(call->req()-1);\n+            call->del_req(call->req()-1);\n+            if (valid_length_test->find_int_con(1) == 0) {\n@@ -3768,0 +3769,2 @@\n+            assert(n->outcnt() == required_outcnt, \"malformed control flow\");\n+            continue;\n@@ -3776,0 +3779,8 @@\n+    } else if (n->is_PCTable() && n->in(0) && n->in(0)->in(0) && n->in(0)->in(0)->is_Call()) {\n+      CallNode* call = n->in(0)->in(0)->as_Call();\n+      if (call->entry_point() == OptoRuntime::new_array_Java() ||\n+          call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n+        assert(call->is_CallStaticJava(), \"static call expected\");\n+        assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n+        call->del_req(call->req()-1); \/\/ valid length test useless now\n+      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,4 +70,6 @@\n-  ciMethod*       caller   = jvms->method();\n-  int             bci      = jvms->bci();\n-  Bytecodes::Code bytecode = caller->java_code_at_bci(bci);\n-  guarantee(callee != NULL, \"failed method resolution\");\n+  assert(callee != NULL, \"failed method resolution\");\n+\n+  ciMethod*       caller      = jvms->method();\n+  int             bci         = jvms->bci();\n+  Bytecodes::Code bytecode    = caller->java_code_at_bci(bci);\n+  ciMethod*       orig_callee = caller->get_method_at_bci(bci);\n@@ -76,1 +78,3 @@\n-                                       (bytecode == Bytecodes::_invokeinterface);\n+                                       (bytecode == Bytecodes::_invokeinterface) ||\n+                                       (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual) ||\n+                                       (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -618,0 +618,7 @@\n+      if (!method()->has_exception_handlers()) {\n+        \/\/ We don't need to preserve the stack if there's no handler as the entire frame is going to be popped anyway.\n+        \/\/ This prevents issues with exception handling and late inlining.\n+        set_sp(0);\n+        clean_stack(0);\n+      }\n+\n@@ -2740,1 +2747,3 @@\n-  Node* norm = _gvn.transform( new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci) );\n+  Node* norm = new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci);\n+  _gvn.set_type_bottom(norm);\n+  C->record_for_igvn(norm);\n@@ -3979,0 +3988,9 @@\n+  const TypeOopPtr* ary_type = _gvn.type(klass_node)->is_klassptr()->as_instance_type();\n+  Node* valid_length_test = _gvn.intcon(1);\n+  if (ary_type->klass()->is_array_klass()) {\n+    BasicType bt = ary_type->klass()->as_array_klass()->element_type()->basic_type();\n+    jint max = TypeAryPtr::max_array_length(bt);\n+    Node* valid_length_cmp  = _gvn.transform(new CmpUNode(length, intcon(max)));\n+    valid_length_test = _gvn.transform(new BoolNode(valid_length_cmp, BoolTest::le));\n+  }\n+\n@@ -3985,1 +4003,1 @@\n-                            length);\n+                            length, valid_length_test);\n@@ -3992,1 +4010,0 @@\n-  const TypeOopPtr* ary_type = _gvn.type(klass_node)->is_klassptr()->as_instance_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1724,0 +1724,10 @@\n+    if (in(0)->is_BaseCountedLoopEnd()) {\n+      \/\/ CountedLoopEndNode may be eliminated by if subsuming, replace CountedLoopNode with LoopNode to\n+      \/\/ avoid mismatching between CountedLoopNode and CountedLoopEndNode in the following optimization.\n+      Node* head = unique_ctrl_out();\n+      if (head != NULL && head->is_BaseCountedLoop() && head->in(LoopNode::LoopBackControl) == this) {\n+        Node* new_head = new LoopNode(head->in(LoopNode::EntryControl), this);\n+        phase->is_IterGVN()->register_new_node_with_optimizer(new_head);\n+        phase->is_IterGVN()->replace_node(head, new_head);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1076,1 +1076,0 @@\n-  clear_upper_avx();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1015,7 +1015,9 @@\n-  void set_rounding(int mode) {\n-    \/\/ fesetround is broken on windows\n-    NOT_WINDOWS(fesetround(mode);)\n-  }\n-\n-  void check_frequency(float f) {\n-    NOT_WINDOWS(assert(f <= 1 && f >= 0, \"Incorrect frequency\");)\n+  float check_and_truncate_frequency(float f) {\n+    assert(f >= 0, \"Incorrect frequency\");\n+    \/\/ We do not perform an exact (f <= 1) check\n+    \/\/ this would be error prone with rounding of floats.\n+    \/\/ Performing a check like (f <= 1+eps) would be of benefit,\n+    \/\/ however, it is not evident how to determine such an eps,\n+    \/\/ given that an arbitrary number of add\/mul operations\n+    \/\/ are performed on these frequencies.\n+    return (f > 1) ? 1 : f;\n@@ -1031,1 +1033,0 @@\n-    set_rounding(FE_TOWARDZERO); \/\/ make sure rounding doesn't push frequency above 1\n@@ -1058,1 +1059,0 @@\n-              set_rounding(FE_UPWARD);  \/\/ make sure rounding doesn't push frequency above 1\n@@ -1065,1 +1065,0 @@\n-              set_rounding(FE_TOWARDZERO);\n@@ -1085,1 +1084,1 @@\n-              check_frequency(this_exit_f);\n+              this_exit_f = check_and_truncate_frequency(this_exit_f);\n@@ -1087,1 +1086,1 @@\n-              check_frequency(f);\n+              f = check_and_truncate_frequency(f);\n@@ -1100,1 +1099,1 @@\n-              check_frequency(f);\n+              f = check_and_truncate_frequency(f);\n@@ -1108,1 +1107,1 @@\n-            check_frequency(f);\n+            f = check_and_truncate_frequency(f);\n@@ -1121,3 +1120,1 @@\n-          set_rounding(FE_TONEAREST);\n-          check_frequency(f);\n-          return f;\n+          return check_and_truncate_frequency(f);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1200,1 +1200,1 @@\n-  Node* castii = new CastIINode(incr, TypeInt::INT, ConstraintCastNode::StrongDependency);\n+  Node* castii = new CastIINode(incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n@@ -1913,0 +1913,6 @@\n+  if (init->Opcode() == Op_CastII) {\n+    \/\/ skip over the cast added by PhaseIdealLoop::cast_incr_before_loop() when pre\/post\/main loops are created because\n+    \/\/ it can get in the way of type propagation\n+    assert(((CastIINode*)init)->carry_dependency() && loop_head->skip_predicates() == init->in(0), \"casted iv phi from pre loop expected\");\n+    init = init->in(1);\n+  }\n@@ -3373,0 +3379,5 @@\n+  if (!_head->is_Loop()) {\n+    \/\/ Head could be a region with a NeverBranch that was added in beautify loops but the region was not\n+    \/\/ yet transformed into a LoopNode. Bail out and wait until beautify loops turns it into a Loop node.\n+    return false;\n+  }\n@@ -3852,3 +3863,1 @@\n-  index = new AddPNode(base, base, index);\n-  _igvn.register_new_node_with_optimizer(index);\n-  Node* from = new AddPNode(base, index, offset);\n+  Node* from = new AddPNode(base, base, index);\n@@ -3856,0 +3865,9 @@\n+  \/\/ For normal array fills, C2 uses two AddP nodes for array element\n+  \/\/ addressing. But for array fills with Unsafe call, there's only one\n+  \/\/ AddP node adding an absolute offset, so we do a NULL check here.\n+  assert(offset != NULL || C->has_unsafe_access(),\n+         \"Only array fills with unsafe have no extra offset\");\n+  if (offset != NULL) {\n+    from = new AddPNode(base, from, offset);\n+    _igvn.register_new_node_with_optimizer(from);\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -686,2 +686,1 @@\n-    \/\/ We can only use that safepoint if there's not side effect\n-    \/\/ between the backedge and the safepoint.\n+    \/\/ We can only use that safepoint if there's no side effect between the backedge and the safepoint.\n@@ -1244,10 +1243,0 @@\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint &&\n-          ((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n-           iv_bt == T_LONG)) {\n-    \/\/ Leaving the safepoint on the backedge and creating a\n-    \/\/ CountedLoop will confuse optimizations. We can't move the\n-    \/\/ safepoint around because its jvm state wouldn't match a new\n-    \/\/ location. Give up on that loop.\n-    return false;\n-  }\n-\n@@ -1482,0 +1471,31 @@\n+  Node* sfpt = NULL;\n+  if (loop->_child == NULL) {\n+    sfpt = find_safepoint(back_control, x, loop);\n+  } else {\n+    sfpt = iff->in(0);\n+    if (sfpt->Opcode() != Op_SafePoint) {\n+      sfpt = NULL;\n+    }\n+  }\n+\n+  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    Node* backedge_sfpt = x->in(LoopNode::LoopBackControl);\n+    if (((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n+         iv_bt == T_LONG) &&\n+        sfpt == NULL) {\n+      \/\/ Leaving the safepoint on the backedge and creating a\n+      \/\/ CountedLoop will confuse optimizations. We can't move the\n+      \/\/ safepoint around because its jvm state wouldn't match a new\n+      \/\/ location. Give up on that loop.\n+      return false;\n+    }\n+    if (is_deleteable_safept(backedge_sfpt)) {\n+      lazy_replace(backedge_sfpt, iftrue);\n+      if (loop->_safepts != NULL) {\n+        loop->_safepts->yank(backedge_sfpt);\n+      }\n+      loop->_tail = iftrue;\n+    }\n+  }\n+\n+\n@@ -1520,12 +1540,0 @@\n-  if (iv_bt == T_INT && LoopStripMiningIter == 0) {\n-    \/\/ Check for SafePoint on backedge and remove\n-    Node *sfpt = x->in(LoopNode::LoopBackControl);\n-    if (sfpt->Opcode() == Op_SafePoint && is_deleteable_safept(sfpt)) {\n-      lazy_replace( sfpt, iftrue );\n-      if (loop->_safepts != NULL) {\n-        loop->_safepts->yank(sfpt);\n-      }\n-      loop->_tail = iftrue;\n-    }\n-  }\n-\n@@ -1603,2 +1611,0 @@\n-  Node *sfpt2 = le->in(0);\n-\n@@ -1609,1 +1615,1 @@\n-                         sfpt2->Opcode() == Op_SafePoint &&\n+                         sfpt != NULL &&\n@@ -1635,1 +1641,1 @@\n-    if (sfpt2->Opcode() == Op_SafePoint && (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt2))) {\n+    if (sfpt != NULL && (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt))) {\n@@ -1638,3 +1644,3 @@\n-        Node* sfpt = sfpt2->clone();\n-        sfpt->set_req(0, iffalse);\n-        outer_le->set_req(0, sfpt);\n+        Node* sfpt_clone = sfpt->clone();\n+        sfpt_clone->set_req(0, iffalse);\n+        outer_le->set_req(0, sfpt_clone);\n@@ -1642,1 +1648,1 @@\n-        Node* polladdr = sfpt->in(TypeFunc::Parms);\n+        Node* polladdr = sfpt_clone->in(TypeFunc::Parms);\n@@ -1649,1 +1655,1 @@\n-          sfpt->set_req(TypeFunc::Parms, new_polladdr);\n+          sfpt_clone->set_req(TypeFunc::Parms, new_polladdr);\n@@ -1653,2 +1659,2 @@\n-        register_control(sfpt, outer_ilt, iffalse, body_populated);\n-        set_idom(outer_le, sfpt, dom_depth(sfpt));\n+        register_control(sfpt_clone, outer_ilt, iffalse, body_populated);\n+        set_idom(outer_le, sfpt_clone, dom_depth(sfpt_clone));\n@@ -1656,1 +1662,1 @@\n-      lazy_replace( sfpt2, sfpt2->in(TypeFunc::Control));\n+      lazy_replace(sfpt, sfpt->in(TypeFunc::Control));\n@@ -1658,1 +1664,1 @@\n-        loop->_safepts->yank(sfpt2);\n+        loop->_safepts->yank(sfpt);\n@@ -3291,1 +3297,1 @@\n-    if (LoopStripMiningIter == 0 || (LoopStripMiningIter > 1 && _child == NULL)) {\n+    if (LoopStripMiningIter == 0 || _head->as_CountedLoop()->is_strip_mined()) {\n@@ -3717,1 +3723,1 @@\n-void PhaseIdealLoop::build_and_optimize(LoopOptsMode mode) {\n+void PhaseIdealLoop::build_and_optimize() {\n@@ -3720,2 +3726,2 @@\n-  bool do_split_ifs = (mode == LoopOptsDefault);\n-  bool skip_loop_opts = (mode == LoopOptsNone);\n+  bool do_split_ifs = (_mode == LoopOptsDefault);\n+  bool skip_loop_opts = (_mode == LoopOptsNone);\n@@ -3792,1 +3798,1 @@\n-    !bs->is_gc_specific_loop_opts_pass(mode);\n+    !bs->is_gc_specific_loop_opts_pass(_mode);\n@@ -3794,1 +3800,1 @@\n-  bool strip_mined_loops_expanded = bs->strip_mined_loops_expanded(mode);\n+  bool strip_mined_loops_expanded = bs->strip_mined_loops_expanded(_mode);\n@@ -3886,1 +3892,1 @@\n-    assert(C->unique() == unique, \"verification mode made Nodes? ? ?\");\n+    assert(C->unique() == unique, \"verification _mode made Nodes? ? ?\");\n@@ -3916,2 +3922,2 @@\n-    \/\/ Check to see if the verify mode is broken\n-    assert(C->unique() == unique, \"non-optimize mode made Nodes? ? ?\");\n+    \/\/ Check to see if the verify _mode is broken\n+    assert(C->unique() == unique, \"non-optimize _mode made Nodes? ? ?\");\n@@ -3931,1 +3937,1 @@\n-  if (mode == LoopOptsMaxUnroll) {\n+  if (_mode == LoopOptsMaxUnroll) {\n@@ -3952,1 +3958,1 @@\n-  if (bs->optimize_loops(this, mode, visited, nstack, worklist)) {\n+  if (bs->optimize_loops(this, _mode, visited, nstack, worklist)) {\n@@ -4093,1 +4099,8 @@\n-          sw.transform_loop(lpt, true);\n+          if (!sw.transform_loop(lpt, true)) {\n+            \/\/ Instigate more unrolling for optimization when vectorization fails.\n+            if (cl->has_passed_slp()) {\n+              C->set_major_progress();\n+              cl->set_notpassed_slp();\n+              cl->mark_do_unroll_only();\n+            }\n+          }\n@@ -5356,0 +5369,28 @@\n+  if (least != early) {\n+    \/\/ Move the node above predicates as far up as possible so a\n+    \/\/ following pass of loop predication doesn't hoist a predicate\n+    \/\/ that depends on it above that node.\n+    Node* new_ctrl = least;\n+    for (;;) {\n+      if (!new_ctrl->is_Proj()) {\n+        break;\n+      }\n+      CallStaticJavaNode* call = new_ctrl->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      if (call == NULL) {\n+        break;\n+      }\n+      int req = call->uncommon_trap_request();\n+      Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);\n+      if (trap_reason != Deoptimization::Reason_loop_limit_check &&\n+          trap_reason != Deoptimization::Reason_predicate &&\n+          trap_reason != Deoptimization::Reason_profile_predicate) {\n+        break;\n+      }\n+      Node* c = new_ctrl->in(0)->in(0);\n+      if (is_dominator(c, early) && c != early) {\n+        break;\n+      }\n+      new_ctrl = c;\n+    }\n+    least = new_ctrl;\n+  }\n@@ -5358,1 +5399,1 @@\n-  if (least != early) {\n+  if (least != early && !BarrierSet::barrier_set()->barrier_set_c2()->is_gc_specific_loop_opts_pass(_mode)) {\n@@ -5361,25 +5402,5 @@\n-        least == ctrl_out->in(LoopNode::EntryControl)) {\n-      \/\/ Move the node above predicates as far up as possible so a\n-      \/\/ following pass of loop predication doesn't hoist a predicate\n-      \/\/ that depends on it above that node.\n-      Node* new_ctrl = least;\n-      for (;;) {\n-        if (!new_ctrl->is_Proj()) {\n-          break;\n-        }\n-        CallStaticJavaNode* call = new_ctrl->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n-        if (call == NULL) {\n-          break;\n-        }\n-        int req = call->uncommon_trap_request();\n-        Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);\n-        if (trap_reason != Deoptimization::Reason_loop_limit_check &&\n-            trap_reason != Deoptimization::Reason_predicate &&\n-            trap_reason != Deoptimization::Reason_profile_predicate) {\n-          break;\n-        }\n-        Node* c = new_ctrl->in(0)->in(0);\n-        if (is_dominator(c, early) && c != early) {\n-          break;\n-        }\n-        new_ctrl = c;\n+        least == ctrl_out->in(LoopNode::EntryControl) &&\n+        (ctrl_out->is_CountedLoop() || ctrl_out->is_OuterStripMinedLoop())) {\n+      Node* least_dom = idom(least);\n+      if (get_loop(least_dom)->is_member(get_loop(least))) {\n+        least = least_dom;\n@@ -5387,1 +5408,0 @@\n-      least = new_ctrl;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":96,"deletions":76,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -1053,0 +1053,1 @@\n+  LoopOptsMode _mode;\n@@ -1055,1 +1056,1 @@\n-  void build_and_optimize(LoopOptsMode mode);\n+  void build_and_optimize();\n@@ -1066,0 +1067,1 @@\n+    _mode(mode),\n@@ -1068,1 +1070,1 @@\n-    build_and_optimize(mode);\n+    build_and_optimize();\n@@ -1079,0 +1081,1 @@\n+    _mode(LoopOptsVerify),\n@@ -1080,1 +1083,1 @@\n-    build_and_optimize(LoopOptsVerify);\n+    build_and_optimize();\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3731,0 +3731,2 @@\n+      post = new CastIINode(post, phi->bottom_type()); \/\/ preserve the iv phi's type\n+      register_new_node(post, c);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1211,1 +1211,2 @@\n-            address slow_call_address  \/\/ Address of slow call\n+            address slow_call_address,  \/\/ Address of slow call\n+            Node* valid_length_test \/\/ whether length is valid or not\n@@ -1397,0 +1398,6 @@\n+  \/\/ For array allocations, copy the valid length check to the call node so Compile::final_graph_reshaping() can verify\n+  \/\/ that the call has the expected number of CatchProj nodes (in case the allocation always fails and the fallthrough\n+  \/\/ path dies).\n+  if (valid_length_test != NULL) {\n+    call->add_req(valid_length_test);\n+  }\n@@ -1878,1 +1885,1 @@\n-                         OptoRuntime::new_instance_Java());\n+                         OptoRuntime::new_instance_Java(), NULL);\n@@ -1883,0 +1890,1 @@\n+  Node* valid_length_test = alloc->in(AllocateNode::ValidLengthTest);\n@@ -1897,1 +1905,1 @@\n-                         slow_call_address);\n+                         slow_call_address, valid_length_test);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-                              address slow_call_address);\n-  void yank_initalize_node(InitializeNode* node);\n+                              address slow_call_address,\n+                              Node* valid_length_test);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,3 @@\n-  if( in(0) && remove_dead_region(phase, can_reshape) ) return this;\n+  if (in(0) != NULL && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n@@ -80,1 +82,3 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if (in(0) != NULL && in(0)->is_top()) {\n+    return NULL;\n+  }\n@@ -82,11 +86,11 @@\n-         in(IfFalse) != this &&\n-         in(IfTrue) != this, \"dead loop in CMoveNode::Ideal\" );\n-  if( phase->type(in(Condition)) == Type::TOP )\n-  return NULL; \/\/ return NULL when Condition is dead\n-\n-  if( in(IfFalse)->is_Con() && !in(IfTrue)->is_Con() ) {\n-    if( in(Condition)->is_Bool() ) {\n-      BoolNode* b  = in(Condition)->as_Bool();\n-      BoolNode* b2 = b->negate(phase);\n-      return make(in(Control), phase->transform(b2), in(IfTrue), in(IfFalse), _type);\n-    }\n+         in(IfFalse)   != this &&\n+         in(IfTrue)    != this, \"dead loop in CMoveNode::Ideal\");\n+  if (phase->type(in(Condition)) == Type::TOP ||\n+      phase->type(in(IfFalse))   == Type::TOP ||\n+      phase->type(in(IfTrue))    == Type::TOP) {\n+    return NULL;\n+  }\n+  \/\/ Canonicalize the node by moving constants to the right input.\n+  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n+    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n+    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n@@ -194,8 +198,4 @@\n-  \/\/ have moved the constant to the right).  This situation is bad for Intel\n-  \/\/ and a don't-care for Sparc.  It's bad for Intel because the zero has to\n-  \/\/ be manifested in a register with a XOR which kills flags, which are live\n-  \/\/ on input to the CMoveI, leading to a situation which causes excessive\n-  \/\/ spilling on Intel.  For Sparc, if the zero in on the left the Sparc will\n-  \/\/ zero a register via G0 and conditionally-move the other constant.  If the\n-  \/\/ zero is on the right, the Sparc will load the first constant with a\n-  \/\/ 13-bit set-lo and conditionally move G0.  See bug 4677505.\n+  \/\/ have moved the constant to the right). This situation is bad for x86 because\n+  \/\/ the zero has to be manifested in a register with a XOR which kills flags,\n+  \/\/ which are live on input to the CMoveI, leading to a situation which causes\n+  \/\/ excessive spilling. See bug 4677505.\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1879,0 +1879,1 @@\n+\n@@ -1881,16 +1882,3 @@\n-  case Bytecodes::_ldc2_w:\n-    \/\/ If the constant is unresolved, run this BC once in the interpreter.\n-    {\n-      ciConstant constant = iter().get_constant();\n-      if (!constant.is_valid() ||\n-          (constant.basic_type() == T_OBJECT &&\n-           !constant.as_object()->is_loaded())) {\n-        int index = iter().get_constant_pool_index();\n-        constantTag tag = iter().get_constant_pool_tag(index);\n-        uncommon_trap(Deoptimization::make_trap_request\n-                      (Deoptimization::Reason_unloaded,\n-                       Deoptimization::Action_reinterpret,\n-                       index),\n-                      NULL, tag.internal_name());\n-        break;\n-      }\n+  case Bytecodes::_ldc2_w: {\n+    ciConstant constant = iter().get_constant();\n+    if (constant.is_loaded()) {\n@@ -1903,1 +1891,6 @@\n-    }\n+    } else {\n+      \/\/ If the constant is unresolved or in error state, run this BC in the interpreter.\n+      if (iter().is_in_error()) {\n+        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                        Deoptimization::Action_none),\n+                      NULL, \"constant in error state\", true \/* must_throw *\/);\n@@ -1905,0 +1898,8 @@\n+      } else {\n+        int index = iter().get_constant_pool_index();\n+        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unloaded,\n+                                                        Deoptimization::Action_reinterpret,\n+                                                        index),\n+                      NULL, \"unresolved constant\", false \/* must_throw *\/);\n+      }\n+    }\n@@ -1906,0 +1907,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1513,1 +1513,1 @@\n-static PhiNode* countedloop_phi_from_cmp(CmpINode* cmp, Node* n) {\n+static PhiNode* countedloop_phi_from_cmp(CmpNode* cmp, Node* n) {\n@@ -1518,2 +1518,2 @@\n-      if (iff->is_CountedLoopEnd()) {\n-        CountedLoopEndNode* cle = iff->as_CountedLoopEnd();\n+      if (iff->is_BaseCountedLoopEnd()) {\n+        BaseCountedLoopEndNode* cle = iff->as_BaseCountedLoopEnd();\n@@ -1696,1 +1696,1 @@\n-      if (n->in(2)->is_top()) {\n+      if (type(n->in(2)) == Type::TOP) {\n@@ -1706,1 +1706,1 @@\n-      if (n->in(2)->is_top()) {\n+      if (type(n->in(2)) == Type::TOP) {\n@@ -1837,2 +1837,2 @@\n-        if (m_op == Op_CmpI) {\n-          PhiNode* phi = countedloop_phi_from_cmp((CmpINode*)m, n);\n+        if (m_op == Op_CmpI || m_op == Op_CmpL) {\n+          PhiNode* phi = countedloop_phi_from_cmp(m->as_Cmp(), n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1, \"unexpected node type\");\n-              Node *use_c = use->is_If() ? use->in(0) : get_ctrl(use);\n+              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1 || use->is_AllocateArray(), \"unexpected node type\");\n+              Node *use_c = (use->is_If() || use->is_AllocateArray()) ? use->in(0) : get_ctrl(use);\n@@ -169,2 +169,3 @@\n-                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1, \"unexpected node type\");\n-                assert(u->in(1) == bol, \"\");\n+                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1 || u->is_AllocateArray(), \"unexpected node type\");\n+                assert(u->is_AllocateArray() || u->in(1) == bol, \"\");\n+                assert(!u->is_AllocateArray() || u->in(AllocateNode::ValidLengthTest) == bol, \"wrong input to AllocateArray\");\n@@ -172,1 +173,1 @@\n-                Node *u_ctrl = u->is_If() ? u->in(0) : get_ctrl(u);\n+                Node *u_ctrl = (u->is_If() || u->is_AllocateArray()) ? u->in(0) : get_ctrl(u);\n@@ -176,1 +177,1 @@\n-                _igvn.replace_input_of(u, 1, x);\n+                _igvn.replace_input_of(u, u->is_AllocateArray() ? AllocateNode::ValidLengthTest : 1, x);\n@@ -203,0 +204,18 @@\n+  if (n->Opcode() == Op_OpaqueLoopStride || n->Opcode() == Op_OpaqueLoopInit) {\n+    Unique_Node_List wq;\n+    wq.push(n);\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* m = wq.at(i);\n+      if (m->is_If()) {\n+        assert(skeleton_predicate_has_opaque(m->as_If()), \"opaque node not reachable from if?\");\n+        Node* bol = clone_skeleton_predicate_bool(m, NULL, NULL, m->in(0));\n+        _igvn.replace_input_of(m, 1, bol);\n+      } else {\n+        assert(!m->is_CFG(), \"not CFG expected\");\n+        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n+          Node* u = m->fast_out(j);\n+          wq.push(u);\n+        }\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-      set_req(ObjOrSubKlass, obj);\n+      set_req_X(ObjOrSubKlass, obj, phase);\n@@ -147,1 +147,1 @@\n-    set_req(ObjOrSubKlass, allocated_klass);\n+    set_req_X(ObjOrSubKlass, allocated_klass, phase);\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-void SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {\n+bool SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {\n@@ -103,1 +103,1 @@\n-    return;\n+    return false;\n@@ -109,1 +109,3 @@\n-  if (!cl->is_valid_counted_loop(T_INT)) return; \/\/ skip malformed counted loop\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n+    return false; \/\/ skip malformed counted loop\n+  }\n@@ -113,1 +115,3 @@\n-    if (cl->is_reduction_loop()) return; \/\/ no predication mapping\n+    if (cl->is_reduction_loop()) {\n+      return false; \/\/ no predication mapping\n+    }\n@@ -115,1 +119,3 @@\n-    if (limit->is_Con()) return; \/\/ non constant limits only\n+    if (limit->is_Con()) {\n+      return false; \/\/ non constant limits only\n+    }\n@@ -122,1 +128,3 @@\n-        if (val < 0) return;\n+        if (val < 0) {\n+          return false;\n+        }\n@@ -129,1 +137,3 @@\n-    if (SuperWordLoopUnrollAnalysis && cl->slp_max_unroll() == 0) return;\n+    if (SuperWordLoopUnrollAnalysis && cl->slp_max_unroll() == 0) {\n+      return false;\n+    }\n@@ -144,1 +154,1 @@\n-    return;\n+    return false;\n@@ -149,1 +159,1 @@\n-    return;\n+    return false;\n@@ -153,1 +163,3 @@\n-  if (cl->is_vectorized_loop()) return;\n+  if (cl->is_vectorized_loop()) {\n+    return false;\n+  }\n@@ -155,1 +167,3 @@\n-  if (cl->is_unroll_only()) return;\n+  if (cl->is_unroll_only()) {\n+    return false;\n+  }\n@@ -161,1 +175,1 @@\n-      return;\n+      return false;\n@@ -165,1 +179,1 @@\n-      return;\n+      return false;\n@@ -178,0 +192,1 @@\n+  bool success = true;\n@@ -180,1 +195,1 @@\n-    SLP_extract();\n+    success = SLP_extract();\n@@ -195,0 +210,1 @@\n+  return success;\n@@ -454,1 +470,1 @@\n-void SuperWord::SLP_extract() {\n+bool SuperWord::SLP_extract() {\n@@ -469,1 +485,1 @@\n-    return; \/\/ Exit if no interesting nodes or complex graph.\n+    return false; \/\/ Exit if no interesting nodes or complex graph.\n@@ -486,1 +502,1 @@\n-          return; \/\/ Exit if no interesting nodes or complex graph.\n+          return false; \/\/ Exit if no interesting nodes or complex graph.\n@@ -514,1 +530,1 @@\n-      return; \/\/ Did not find memory reference to align vectors\n+      return false; \/\/ Did not find memory reference to align vectors\n@@ -566,1 +582,1 @@\n-        return;\n+        return false;\n@@ -570,1 +586,1 @@\n-      return;\n+      return false;\n@@ -574,1 +590,1 @@\n-  output();\n+  return output();\n@@ -2388,1 +2404,1 @@\n-void SuperWord::output() {\n+bool SuperWord::output() {\n@@ -2392,7 +2408,1 @@\n-    if (cl->is_main_loop()) {\n-      \/\/ Instigate more unrolling for optimization when vectorization fails.\n-      C->set_major_progress();\n-      cl->set_notpassed_slp();\n-      cl->mark_do_unroll_only();\n-    }\n-    return;\n+    return false;\n@@ -2432,1 +2442,1 @@\n-    return;\n+    return false;\n@@ -2477,1 +2487,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2521,1 +2531,1 @@\n-              return; \/\/and reverse to backup IG\n+              return false; \/\/and reverse to backup IG\n@@ -2530,1 +2540,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2564,1 +2574,1 @@\n-          return;\n+          return false;\n@@ -2581,1 +2591,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2597,1 +2607,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2605,1 +2615,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2629,1 +2639,1 @@\n-          return; \/\/and reverse to backup IG\n+          return false; \/\/and reverse to backup IG\n@@ -2638,1 +2648,1 @@\n-          return; \/\/and reverse to backup IG\n+          return false; \/\/and reverse to backup IG\n@@ -2656,1 +2666,1 @@\n-          return;\n+          return false;\n@@ -2729,1 +2739,1 @@\n-  return;\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":51,"deletions":41,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-  void transform_loop(IdealLoopTree* lpt, bool do_optimization);\n+  bool transform_loop(IdealLoopTree* lpt, bool do_optimization);\n@@ -425,1 +425,1 @@\n-  void SLP_extract();\n+  bool SLP_extract();\n@@ -512,1 +512,1 @@\n-  void output();\n+  bool output();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -318,0 +318,15 @@\n+  } else if (vbox->is_Phi() && (vect->is_Vector() || vect->is_LoadVector())) {\n+    \/\/ Handle the case when the allocation input to VectorBoxNode is a phi\n+    \/\/ but the vector input is not, which can definitely be the case if the\n+    \/\/ vector input has been value-numbered. It seems to be safe to do by\n+    \/\/ construction because VectorBoxNode and VectorBoxAllocate come in a\n+    \/\/ specific order as a result of expanding an intrinsic call. After that, if\n+    \/\/ any of the inputs to VectorBoxNode are value-numbered they can only\n+    \/\/ move up and are guaranteed to dominate.\n+    Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);\n+    for (uint i = 1; i < vbox->req(); i++) {\n+      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect, box_type, vect_type);\n+      new_phi->set_req(i, new_box);\n+    }\n+    new_phi = C->initial_gvn()->transform(new_phi);\n+    return new_phi;\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,1 +174,1 @@\n-    \/\/ Other payload values are: 'oop' type location and Scalar-replaced boxed vector representation.\n+    \/\/ Other payload values are: 'oop' type location and scalar-replaced boxed vector representation.\n@@ -181,1 +181,1 @@\n-  } else if (!payload->is_object()) {\n+  } else if (!payload->is_object() && !payload->is_constant_oop()) {\n@@ -184,1 +184,1 @@\n-    assert(payload->is_object(), \"expected 'object' value for scalar-replaced boxed vector but got: %s\", ss.as_string());\n+    assert(false, \"expected 'object' value for scalar-replaced boxed vector but got: %s\", ss.as_string());\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2009,0 +2009,8 @@\n+WB_ENTRY(jboolean, WB_IsDTraceIncluded(JNIEnv* env))\n+#if defined(DTRACE_ENABLED)\n+  return true;\n+#else\n+  return false;\n+#endif \/\/ DTRACE_ENABLED\n+WB_END\n+\n@@ -2589,0 +2597,1 @@\n+  {CC\"isDTraceIncluded\",                  CC\"()Z\",    (void*)&WB_IsDTraceIncluded },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,5 +201,1 @@\n-      #if _MSC_VER == 1600\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 10.0 (VS2010)\"\n-      #elif _MSC_VER == 1700\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 11.0 (VS2012)\"\n-      #elif _MSC_VER == 1800\n+      #if _MSC_VER == 1800\n@@ -241,0 +237,4 @@\n+      #elif _MSC_VER == 1930\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.0 (VS2022)\"\n+      #elif _MSC_VER == 1931\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.1 (VS2022)\"\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2884,0 +2884,12 @@\n+    } else if (match_option(option, \"-XX:+DTraceMethodProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceMethodProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n+    } else if (match_option(option, \"-XX:+DTraceAllocProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceAllocProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n+    } else if (match_option(option, \"-XX:+DTraceMonitorProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceMonitorProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -686,0 +686,15 @@\n+#ifndef PRODUCT\n+static bool falls_through(Bytecodes::Code bc) {\n+  switch (bc) {\n+    \/\/ List may be incomplete.  Here we really only care about bytecodes where compiled code\n+    \/\/ can deoptimize.\n+    case Bytecodes::_goto:\n+    case Bytecodes::_goto_w:\n+    case Bytecodes::_athrow:\n+      return false;\n+    default:\n+      return true;\n+  }\n+}\n+#endif\n+\n@@ -794,1 +809,1 @@\n-          if (!Bytecodes::is_invoke(cur_code) && cur_code != Bytecodes::_athrow) {\n+          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,13 +236,0 @@\n-void* ObjectMonitor::operator new (size_t size) throw() {\n-  return AllocateHeap(size, mtInternal);\n-}\n-void* ObjectMonitor::operator new[] (size_t size) throw() {\n-  return operator new (size);\n-}\n-void ObjectMonitor::operator delete(void* p) {\n-  FreeHeap(p);\n-}\n-void ObjectMonitor::operator delete[] (void *p) {\n-  operator delete(p);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,5 +206,0 @@\n-  void* operator new (size_t size) throw();\n-  void* operator new[] (size_t size) throw();\n-  void operator delete(void* p);\n-  void operator delete[] (void* p);\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,2 +232,2 @@\n-void NMethodSweeper::report_allocation(int code_blob_type) {\n-  if (should_start_aggressive_sweep(code_blob_type)) {\n+void NMethodSweeper::report_allocation() {\n+  if (should_start_aggressive_sweep()) {\n@@ -240,1 +240,1 @@\n-bool NMethodSweeper::should_start_aggressive_sweep(int code_blob_type) {\n+bool NMethodSweeper::should_start_aggressive_sweep() {\n@@ -244,1 +244,1 @@\n-  return (CodeCache::reverse_free_ratio(code_blob_type) >= aggressive_sweep_threshold);\n+  return (CodeCache::reverse_free_ratio() >= aggressive_sweep_threshold);\n@@ -549,2 +549,1 @@\n-      int code_blob_type = CodeCache::get_code_blob_type(nm);\n-      double threshold = -reset_val + (CodeCache::reverse_free_ratio(code_blob_type) * NmethodSweepActivity);\n+      double threshold = -reset_val + (CodeCache::reverse_free_ratio() * NmethodSweepActivity);\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-  static bool should_start_aggressive_sweep(int code_blob_type);\n+  static bool should_start_aggressive_sweep();\n@@ -120,1 +120,1 @@\n-  static void report_allocation(int code_blob_type);  \/\/ Possibly start the sweeper thread.\n+  static void report_allocation();  \/\/ Possibly start the sweeper thread.\n","filename":"src\/hotspot\/share\/runtime\/sweeper.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -117,5 +118,1 @@\n-    ResourceMark rm;\n-\n-    char* buf = NEW_RESOURCE_ARRAY(char, len + 1);\n-    strncpy(buf, str, len);\n-    buf[len] = '\\0';\n+    const int maxprint = 64;\n@@ -123,1 +120,4 @@\n-      \"Integer parsing error in command argument '%s'. Could not parse: %s.\\n\", _name, buf);\n+      \"Integer parsing error in command argument '%s'. Could not parse: %.*s%s.\\n\", _name,\n+      MIN2((int)len, maxprint),\n+      (str == NULL ? \"<null>\" : str),\n+      (len > maxprint ? \"...\" : \"\"));\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -89,0 +89,7 @@\n+  bool is_in_error() const {\n+    return is_unresolved_klass_in_error() ||\n+           is_method_handle_in_error()    ||\n+           is_method_type_in_error()      ||\n+           is_dynamic_constant_in_error();\n+  }\n+\n@@ -124,2 +131,7 @@\n-  static constantTag ofBasicType(BasicType bt) {\n-    if (is_subword_type(bt))  bt = T_INT;\n+  static jbyte type2tag(BasicType bt) {\n+    if (is_subword_type(bt)) {\n+      bt = T_INT;\n+    }\n+    if (bt == T_ARRAY) {\n+      bt = T_OBJECT;\n+    }\n@@ -127,6 +139,9 @@\n-      case T_OBJECT: return constantTag(JVM_CONSTANT_String);\n-      case T_INT:    return constantTag(JVM_CONSTANT_Integer);\n-      case T_LONG:   return constantTag(JVM_CONSTANT_Long);\n-      case T_FLOAT:  return constantTag(JVM_CONSTANT_Float);\n-      case T_DOUBLE: return constantTag(JVM_CONSTANT_Double);\n-      default:       break;\n+      case T_INT:    return JVM_CONSTANT_Integer;\n+      case T_LONG:   return JVM_CONSTANT_Long;\n+      case T_FLOAT:  return JVM_CONSTANT_Float;\n+      case T_DOUBLE: return JVM_CONSTANT_Double;\n+      case T_OBJECT: return JVM_CONSTANT_String;\n+\n+      default:\n+        assert(false, \"not supported: %s\", type2name(bt));\n+        return JVM_CONSTANT_Invalid;\n@@ -134,2 +149,0 @@\n-    assert(false, \"bad basic type for tag\");\n-    return constantTag();\n","filename":"src\/hotspot\/share\/utilities\/constantTag.hpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  \"OS\", \"PROCESSOR_IDENTIFIER\", \"_ALT_JAVA_HOME_DIR\",\n+  \"OS\", \"PROCESSOR_IDENTIFIER\", \"_ALT_JAVA_HOME_DIR\", \"TMP\", \"TEMP\",\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.util.Objects;\n+\n+\/\/ Maps Class instances to values of type T. Under memory pressure, the\n+\/\/ mapping is released (under soft references GC policy) and would be\n+\/\/ recomputed the next time it is queried. The mapping is bound to the\n+\/\/ lifetime of the class: when the class is unloaded, the mapping is\n+\/\/ removed too.\n+abstract class ClassCache<T> {\n+\n+    private static class CacheRef<T> extends SoftReference<T> {\n+        private final Class<?> type;\n+        private T strongReferent;\n+\n+        CacheRef(T referent, ReferenceQueue<T> queue, Class<?> type) {\n+            super(referent, queue);\n+            this.type = type;\n+            this.strongReferent = referent;\n+        }\n+\n+        Class<?> getType() {\n+            return type;\n+        }\n+\n+        T getStrong() {\n+            return strongReferent;\n+        }\n+\n+        void clearStrong() {\n+            strongReferent = null;\n+        }\n+    }\n+\n+    private final ReferenceQueue<T> queue;\n+    private final ClassValue<CacheRef<T>> map;\n+\n+    protected abstract T computeValue(Class<?> cl);\n+\n+    protected ClassCache() {\n+        queue = new ReferenceQueue<>();\n+        map = new ClassValue<>() {\n+            @Override\n+            protected CacheRef<T> computeValue(Class<?> type) {\n+                T v = ClassCache.this.computeValue(type);\n+                Objects.requireNonNull(v);\n+                return new CacheRef<>(v, queue, type);\n+            }\n+        };\n+    }\n+\n+    T get(Class<?> cl) {\n+        while (true) {\n+            processQueue();\n+\n+            CacheRef<T> ref = map.get(cl);\n+\n+            \/\/ Case 1: A recently created CacheRef.\n+            \/\/ We might still have strong referent, and can return it.\n+            \/\/ This guarantees progress for at least one thread on every CacheRef.\n+            \/\/ Clear the strong referent before returning to make the cache soft.\n+            T strongVal = ref.getStrong();\n+            if (strongVal != null) {\n+                ref.clearStrong();\n+                return strongVal;\n+            }\n+\n+            \/\/ Case 2: Older or recently cleared CacheRef.\n+            \/\/ Check if its soft referent is still available, and return it.\n+            T val = ref.get();\n+            if (val != null) {\n+                return val;\n+            }\n+\n+            \/\/ Case 3: The reference was cleared.\n+            \/\/ Clear the mapping and retry.\n+            map.remove(cl);\n+        }\n+    }\n+\n+    private void processQueue() {\n+        Reference<? extends T> ref;\n+        while((ref = queue.poll()) != null) {\n+            CacheRef<? extends T> cacheRef = (CacheRef<? extends T>)ref;\n+            map.remove(cacheRef.getType());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ClassCache.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.ObjectStreamClass.WeakClassKey;\n@@ -33,1 +32,0 @@\n-import java.lang.ref.ReferenceQueue;\n@@ -46,4 +44,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-import static java.io.ObjectStreamClass.processQueue;\n@@ -279,6 +273,7 @@\n-        static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to audited subclasses *\/\n-        static final ReferenceQueue<Class<?>> subclassAuditsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassValue<Boolean> subclassAudits =\n+            new ClassValue<>() {\n+                @Override\n+                protected Boolean computeValue(Class<?> type) {\n+                    return auditSubclass(type);\n+                }\n+            };\n@@ -1619,7 +1614,1 @@\n-        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);\n-        Boolean result = Caches.subclassAudits.get(key);\n-        if (result == null) {\n-            result = auditSubclass(cl);\n-            Caches.subclassAudits.putIfAbsent(key, result);\n-        }\n+        boolean result = Caches.subclassAudits.get(cl);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.ObjectStreamClass.WeakClassKey;\n-import java.lang.ref.ReferenceQueue;\n@@ -36,3 +34,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import static java.io.ObjectStreamClass.processQueue;\n@@ -172,6 +167,7 @@\n-        static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to audited subclasses *\/\n-        static final ReferenceQueue<Class<?>> subclassAuditsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassValue<Boolean> subclassAudits =\n+            new ClassValue<>() {\n+                @Override\n+                protected Boolean computeValue(Class<?> type) {\n+                    return auditSubclass(type);\n+                }\n+            };\n@@ -1063,7 +1059,1 @@\n-        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);\n-        Boolean result = Caches.subclassAudits.get(key);\n-        if (result == null) {\n-            result = auditSubclass(cl);\n-            Caches.subclassAudits.putIfAbsent(key, result);\n-        }\n+        boolean result = Caches.subclassAudits.get(cl);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,4 +31,0 @@\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.lang.ref.WeakReference;\n@@ -62,1 +58,0 @@\n-import java.util.concurrent.ConcurrentMap;\n@@ -111,2 +106,7 @@\n-        static final ConcurrentMap<WeakClassKey,Reference<?>> localDescs =\n-            new ConcurrentHashMap<>();\n+        static final ClassCache<ObjectStreamClass> localDescs =\n+            new ClassCache<>() {\n+                @Override\n+                protected ObjectStreamClass computeValue(Class<?> type) {\n+                    return new ObjectStreamClass(type);\n+                }\n+            };\n@@ -115,9 +115,7 @@\n-        static final ConcurrentMap<FieldReflectorKey,Reference<?>> reflectors =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to local classes *\/\n-        private static final ReferenceQueue<Class<?>> localDescsQueue =\n-            new ReferenceQueue<>();\n-        \/** queue for WeakReferences to field reflectors keys *\/\n-        private static final ReferenceQueue<Class<?>> reflectorsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassCache<Map<FieldReflectorKey, FieldReflector>> reflectors =\n+            new ClassCache<>() {\n+                @Override\n+                protected Map<FieldReflectorKey, FieldReflector> computeValue(Class<?> type) {\n+                    return new ConcurrentHashMap<>();\n+                }\n+            };\n@@ -365,130 +363,1 @@\n-        processQueue(Caches.localDescsQueue, Caches.localDescs);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);\n-        Reference<?> ref = Caches.localDescs.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new SoftReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.localDescs.remove(key, ref);\n-                }\n-                ref = Caches.localDescs.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {  \/\/ check common case first\n-            return (ObjectStreamClass) entry;\n-        }\n-        if (entry instanceof EntryFuture) {\n-            future = (EntryFuture) entry;\n-            if (future.getOwner() == Thread.currentThread()) {\n-                \/*\n-                 * Handle nested call situation described by 4803747: waiting\n-                 * for future value to be set by a lookup() call further up the\n-                 * stack will result in deadlock, so calculate and set the\n-                 * future value here instead.\n-                 *\/\n-                entry = null;\n-            } else {\n-                entry = future.get();\n-            }\n-        }\n-        if (entry == null) {\n-            try {\n-                entry = new ObjectStreamClass(cl);\n-            } catch (Throwable th) {\n-                entry = th;\n-            }\n-            if (future.set(entry)) {\n-                Caches.localDescs.put(key, new SoftReference<>(entry));\n-            } else {\n-                \/\/ nested lookup call already set future\n-                entry = future.get();\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {\n-            return (ObjectStreamClass) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n-        }\n-    }\n-\n-    \/**\n-     * Placeholder used in class descriptor and field reflector lookup tables\n-     * for an entry in the process of being initialized.  (Internal) callers\n-     * which receive an EntryFuture belonging to another thread as the result\n-     * of a lookup should call the get() method of the EntryFuture; this will\n-     * return the actual entry once it is ready for use and has been set().  To\n-     * conserve objects, EntryFutures synchronize on themselves.\n-     *\/\n-    private static class EntryFuture {\n-\n-        private static final Object unset = new Object();\n-        private final Thread owner = Thread.currentThread();\n-        private Object entry = unset;\n-\n-        \/**\n-         * Attempts to set the value contained by this EntryFuture.  If the\n-         * EntryFuture's value has not been set already, then the value is\n-         * saved, any callers blocked in the get() method are notified, and\n-         * true is returned.  If the value has already been set, then no saving\n-         * or notification occurs, and false is returned.\n-         *\/\n-        synchronized boolean set(Object entry) {\n-            if (this.entry != unset) {\n-                return false;\n-            }\n-            this.entry = entry;\n-            notifyAll();\n-            return true;\n-        }\n-\n-        \/**\n-         * Returns the value contained by this EntryFuture, blocking if\n-         * necessary until a value is set.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        synchronized Object get() {\n-            boolean interrupted = false;\n-            while (entry == unset) {\n-                try {\n-                    wait();\n-                } catch (InterruptedException ex) {\n-                    interrupted = true;\n-                }\n-            }\n-            if (interrupted) {\n-                AccessController.doPrivileged(\n-                    new PrivilegedAction<>() {\n-                        public Void run() {\n-                            Thread.currentThread().interrupt();\n-                            return null;\n-                        }\n-                    }\n-                );\n-            }\n-            return entry;\n-        }\n-\n-        \/**\n-         * Returns the thread that created this EntryFuture.\n-         *\/\n-        Thread getOwner() {\n-            return owner;\n-        }\n+        return Caches.localDescs.get(cl);\n@@ -2253,26 +2122,1 @@\n-            localDesc.cl : null;\n-        processQueue(Caches.reflectorsQueue, Caches.reflectors);\n-        FieldReflectorKey key = new FieldReflectorKey(cl, fields,\n-                                                      Caches.reflectorsQueue);\n-        Reference<?> ref = Caches.reflectors.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new SoftReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.reflectors.remove(key, ref);\n-                }\n-                ref = Caches.reflectors.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n-            }\n-        }\n+            localDesc.cl : Void.class;\n@@ -2280,9 +2124,8 @@\n-        if (entry instanceof FieldReflector) {  \/\/ check common case first\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof EntryFuture) {\n-            entry = ((EntryFuture) entry).get();\n-        } else if (entry == null) {\n-            try {\n-                entry = new FieldReflector(matchFields(fields, localDesc));\n-            } catch (Throwable th) {\n-                entry = th;\n+        var clReflectors = Caches.reflectors.get(cl);\n+        var key = new FieldReflectorKey(fields);\n+        var reflector = clReflectors.get(key);\n+        if (reflector == null) {\n+            reflector = new FieldReflector(matchFields(fields, localDesc));\n+            var oldReflector = clReflectors.putIfAbsent(key, reflector);\n+            if (oldReflector != null) {\n+                reflector = oldReflector;\n@@ -2290,14 +2133,0 @@\n-            future.set(entry);\n-            Caches.reflectors.put(key, new SoftReference<>(entry));\n-        }\n-\n-        if (entry instanceof FieldReflector) {\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof InvalidClassException) {\n-            throw (InvalidClassException) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n@@ -2305,0 +2134,1 @@\n+        return reflector;\n@@ -2309,1 +2139,1 @@\n-     * refer to the same class and equivalent field formats.\n+     * refer to equivalent field formats.\n@@ -2311,1 +2141,1 @@\n-    private static class FieldReflectorKey extends WeakReference<Class<?>> {\n+    private static class FieldReflectorKey {\n@@ -2315,1 +2145,0 @@\n-        private final boolean nullClass;\n@@ -2317,2 +2146,1 @@\n-        FieldReflectorKey(Class<?> cl, ObjectStreamField[] fields,\n-                          ReferenceQueue<Class<?>> queue)\n+        FieldReflectorKey(ObjectStreamField[] fields)\n@@ -2320,2 +2148,0 @@\n-            super(cl, queue);\n-            nullClass = (cl == null);\n@@ -2328,1 +2154,1 @@\n-            hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);\n+            hash = Arrays.hashCode(sigs);\n@@ -2336,13 +2162,3 @@\n-            if (obj == this) {\n-                return true;\n-            }\n-\n-            if (obj instanceof FieldReflectorKey other) {\n-                Class<?> referent;\n-                return (nullClass ? other.nullClass\n-                                  : ((referent = get()) != null) &&\n-                                    (other.refersTo(referent))) &&\n-                        Arrays.equals(sigs, other.sigs);\n-            } else {\n-                return false;\n-            }\n+            return obj == this ||\n+                   obj instanceof FieldReflectorKey other &&\n+                   Arrays.equals(sigs, other.sigs);\n@@ -2412,62 +2228,0 @@\n-    \/**\n-     * Removes from the specified map any keys that have been enqueued\n-     * on the specified reference queue.\n-     *\/\n-    static void processQueue(ReferenceQueue<Class<?>> queue,\n-                             ConcurrentMap<? extends\n-                             WeakReference<Class<?>>, ?> map)\n-    {\n-        Reference<? extends Class<?>> ref;\n-        while((ref = queue.poll()) != null) {\n-            map.remove(ref);\n-        }\n-    }\n-\n-    \/**\n-     *  Weak key for Class objects.\n-     *\n-     **\/\n-    static class WeakClassKey extends WeakReference<Class<?>> {\n-        \/**\n-         * saved value of the referent's identity hash code, to maintain\n-         * a consistent hash code after the referent has been cleared\n-         *\/\n-        private final int hash;\n-\n-        \/**\n-         * Create a new WeakClassKey to the given object, registered\n-         * with a queue.\n-         *\/\n-        WeakClassKey(Class<?> cl, ReferenceQueue<Class<?>> refQueue) {\n-            super(cl, refQueue);\n-            hash = System.identityHashCode(cl);\n-        }\n-\n-        \/**\n-         * Returns the identity hash code of the original referent.\n-         *\/\n-        public int hashCode() {\n-            return hash;\n-        }\n-\n-        \/**\n-         * Returns true if the given object is this identical\n-         * WeakClassKey instance, or, if this object's referent has not\n-         * been cleared, if the given object is another WeakClassKey\n-         * instance with the identical non-null referent as this one.\n-         *\/\n-        public boolean equals(Object obj) {\n-            if (obj == this) {\n-                return true;\n-            }\n-\n-            if (obj instanceof WeakClassKey) {\n-                Class<?> referent = get();\n-                return (referent != null) &&\n-                        (((WeakClassKey) obj).refersTo(referent));\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":32,"deletions":278,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -685,0 +685,1 @@\n+        assert(!UNSAFE.shouldBeInitialized(holder)) : holder + \"not initialized\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,1 +112,3 @@\n-        MemberName mn = getMemberNameOrNull(mode);\n+        \/\/ Can be simplified by calling getMemberNameOrNull, but written in this\n+        \/\/ form to improve interpreter\/coldpath performance.\n+        MemberName mn = memberName_table[mode];\n@@ -114,1 +116,4 @@\n-            throw new UnsupportedOperationException();\n+            mn = resolveMemberName(mode);\n+            if (mn == null) {\n+                throw new UnsupportedOperationException();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarForm.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,4 @@\n+    \/* A cache mapping code signers to the algorithms used to digest jar\n+       entries, and whether or not the algorithms are permitted. *\/\n+    private Map<CodeSigner[], Map<String, Boolean>> signersToAlgs;\n+\n@@ -108,0 +112,1 @@\n+        signersToAlgs = new HashMap<>();\n@@ -247,1 +252,2 @@\n-                je.signers = mev.verify(verifiedSigners, sigFileSigners);\n+                je.signers = mev.verify(verifiedSigners, sigFileSigners,\n+                                        signersToAlgs);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,3 @@\n-            for (int i = 0; i < index; i++) sb.append(' ');\n+            for (int i = 0; i < index; i++) {\n+                sb.append((pattern.charAt(i) == '\\t') ? '\\t' : ' ');\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/PatternSyntaxException.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -900,0 +900,10 @@\n+\n+    \/**\n+     * Returns the value of 'finish' flag.\n+     * 'finish' will be set to true if def.finish() method is called.\n+     *\/\n+    boolean shouldFinish() {\n+        synchronized (zsRef) {\n+            return finish;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,3 +223,9 @@\n-            def.finish();\n-            while (!def.finished()) {\n-                deflate();\n+            try{\n+                def.finish();\n+                while (!def.finished()) {\n+                    deflate();\n+                }\n+            } catch(IOException e) {\n+                if (usesDefaultDeflater)\n+                    def.end();\n+                throw e;\n@@ -237,3 +243,6 @@\n-            finish();\n-            if (usesDefaultDeflater)\n-                def.end();\n+            try {\n+                finish();\n+            } finally {\n+                if (usesDefaultDeflater)\n+                    def.end();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/DeflaterOutputStream.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -160,9 +160,13 @@\n-            def.finish();\n-            while (!def.finished()) {\n-                int len = def.deflate(buf, 0, buf.length);\n-                if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n-                    \/\/ last deflater buffer. Fit trailer at the end\n-                    writeTrailer(buf, len);\n-                    len = len + TRAILER_SIZE;\n-                    out.write(buf, 0, len);\n-                    return;\n+            try {\n+                def.finish();\n+                while (!def.finished()) {\n+                    int len = def.deflate(buf, 0, buf.length);\n+                    if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n+                        \/\/ last deflater buffer. Fit trailer at the end\n+                        writeTrailer(buf, len);\n+                        len = len + TRAILER_SIZE;\n+                        out.write(buf, 0, len);\n+                        return;\n+                    }\n+                    if (len > 0)\n+                        out.write(buf, 0, len);\n@@ -170,2 +174,9 @@\n-                if (len > 0)\n-                    out.write(buf, 0, len);\n+                \/\/ if we can't fit the trailer at the end of the last\n+                \/\/ deflater buffer, we write it separately\n+                byte[] trailer = new byte[TRAILER_SIZE];\n+                writeTrailer(trailer, 0);\n+                out.write(trailer);\n+            } catch (IOException e) {\n+                if (usesDefaultDeflater)\n+                    def.end();\n+                throw e;\n@@ -173,5 +184,0 @@\n-            \/\/ if we can't fit the trailer at the end of the last\n-            \/\/ deflater buffer, we write it separately\n-            byte[] trailer = new byte[TRAILER_SIZE];\n-            writeTrailer(trailer, 0);\n-            out.write(trailer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPOutputStream.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,1 @@\n+        byte[] bytes = null;\n@@ -148,3 +149,4 @@\n-            this.comment = zc.getBytes(comment);\n-            if (this.comment.length > 0xffff)\n-                throw new IllegalArgumentException(\"ZIP file comment too long.\");\n+            bytes = zc.getBytes(comment);\n+            if (bytes.length > 0xffff) {\n+                throw new IllegalArgumentException(\"ZIP file comment too long\");\n+            }\n@@ -152,0 +154,1 @@\n+        this.comment = bytes;\n@@ -259,13 +262,34 @@\n-            ZipEntry e = current.entry;\n-            switch (e.method) {\n-            case DEFLATED -> {\n-                def.finish();\n-                while (!def.finished()) {\n-                    deflate();\n-                }\n-                if ((e.flag & 8) == 0) {\n-                    \/\/ verify size, compressed size, and crc-32 settings\n-                    if (e.size != def.getBytesRead()) {\n-                        throw new ZipException(\n-                            \"invalid entry size (expected \" + e.size +\n-                            \" but got \" + def.getBytesRead() + \" bytes)\");\n+            try {\n+                ZipEntry e = current.entry;\n+                switch (e.method) {\n+                    case DEFLATED -> {\n+                        def.finish();\n+                        while (!def.finished()) {\n+                            deflate();\n+                        }\n+                        if ((e.flag & 8) == 0) {\n+                            \/\/ verify size, compressed size, and crc-32 settings\n+                            if (e.size != def.getBytesRead()) {\n+                                throw new ZipException(\n+                                    \"invalid entry size (expected \" + e.size +\n+                                    \" but got \" + def.getBytesRead() + \" bytes)\");\n+                            }\n+                            if (e.csize != def.getBytesWritten()) {\n+                                throw new ZipException(\n+                                    \"invalid entry compressed size (expected \" +\n+                                    e.csize + \" but got \" + def.getBytesWritten() + \" bytes)\");\n+                            }\n+                            if (e.crc != crc.getValue()) {\n+                                throw new ZipException(\n+                                    \"invalid entry CRC-32 (expected 0x\" +\n+                                    Long.toHexString(e.crc) + \" but got 0x\" +\n+                                    Long.toHexString(crc.getValue()) + \")\");\n+                            }\n+                        } else {\n+                            e.size = def.getBytesRead();\n+                            e.csize = def.getBytesWritten();\n+                            e.crc = crc.getValue();\n+                            writeEXT(e);\n+                        }\n+                        def.reset();\n+                        written += e.csize;\n@@ -273,4 +297,13 @@\n-                    if (e.csize != def.getBytesWritten()) {\n-                        throw new ZipException(\n-                            \"invalid entry compressed size (expected \" +\n-                            e.csize + \" but got \" + def.getBytesWritten() + \" bytes)\");\n+                    case STORED -> {\n+                        \/\/ we already know that both e.size and e.csize are the same\n+                        if (e.size != written - locoff) {\n+                            throw new ZipException(\n+                                \"invalid entry size (expected \" + e.size +\n+                                \" but got \" + (written - locoff) + \" bytes)\");\n+                        }\n+                        if (e.crc != crc.getValue()) {\n+                            throw new ZipException(\n+                                \"invalid entry crc-32 (expected 0x\" +\n+                                Long.toHexString(e.crc) + \" but got 0x\" +\n+                                Long.toHexString(crc.getValue()) + \")\");\n+                        }\n@@ -278,11 +311,1 @@\n-                    if (e.crc != crc.getValue()) {\n-                        throw new ZipException(\n-                            \"invalid entry CRC-32 (expected 0x\" +\n-                            Long.toHexString(e.crc) + \" but got 0x\" +\n-                            Long.toHexString(crc.getValue()) + \")\");\n-                    }\n-                } else {\n-                    e.size = def.getBytesRead();\n-                    e.csize = def.getBytesWritten();\n-                    e.crc = crc.getValue();\n-                    writeEXT(e);\n+                    default -> throw new ZipException(\"invalid compression method\");\n@@ -290,18 +313,6 @@\n-                def.reset();\n-                written += e.csize;\n-            }\n-            case STORED -> {\n-                \/\/ we already know that both e.size and e.csize are the same\n-                if (e.size != written - locoff) {\n-                    throw new ZipException(\n-                        \"invalid entry size (expected \" + e.size +\n-                        \" but got \" + (written - locoff) + \" bytes)\");\n-                }\n-                if (e.crc != crc.getValue()) {\n-                    throw new ZipException(\n-                        \"invalid entry crc-32 (expected 0x\" +\n-                        Long.toHexString(e.crc) + \" but got 0x\" +\n-                        Long.toHexString(crc.getValue()) + \")\");\n-                }\n-            }\n-            default -> throw new ZipException(\"invalid compression method\");\n+                crc.reset();\n+                current = null;\n+            } catch (IOException e) {\n+                if (def.shouldFinish() && usesDefaultDeflater && !(e instanceof ZipException))\n+                    def.end();\n+                throw e;\n@@ -309,2 +320,0 @@\n-            crc.reset();\n-            current = null;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":61,"deletions":52,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -666,0 +666,1 @@\n+        String separator = dir.getFileSystem().getSeparator();\n@@ -670,1 +671,1 @@\n-                    .map(this::toPackageName)\n+                    .map(path -> toPackageName(path, separator))\n@@ -741,1 +742,1 @@\n-    private Optional<String> toPackageName(Path file) {\n+    private Optional<String> toPackageName(Path file, String separator) {\n@@ -755,1 +756,1 @@\n-        String pn = parent.toString().replace(File.separatorChar, '.');\n+        String pn = parent.toString().replace(separator, \".\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModulePath.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1189,1 +1189,3 @@\n-                for (;; U1 = (rng.nextLong() >>> 1)) {\n+                \/\/ At this point, the high-order bits of U1 have not been used yet,\n+                \/\/ but we need the value in U1 to be positive.\n+                for (U1 = (U1 >>> 1);; U1 = (rng.nextLong() >>> 1)) {\n@@ -1191,2 +1193,0 @@\n-                    \/\/ Compute the actual x-coordinate of the randomly chosen point.\n-                    double x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n@@ -1203,0 +1203,2 @@\n+                    \/\/ Compute the actual x-coordinate of the randomly chosen point.\n+                    double x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n@@ -1207,1 +1209,1 @@\n-                    double y = (Y[j] * 0x1.0p63) + ((Y[j] - Y[j-1]) * (double)U2);\n+                    double y = (Y[j] * 0x1.0p63) + ((Y[j-1] - Y[j]) * (double)U2);\n@@ -1326,1 +1328,1 @@\n-                double y = (Y[j] * 0x1.0p63) + ((Y[j] - Y[j-1]) * (double)U2);\n+                double y = (Y[j] * 0x1.0p63) + ((Y[j-1] - Y[j]) * (double)U2);\n@@ -1351,2 +1353,0 @@\n-                \/\/ Compute the actual x-coordinate of the randomly chosen point.\n-                x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n@@ -1363,0 +1363,2 @@\n+                \/\/ Compute the actual x-coordinate of the randomly chosen point.\n+                x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n@@ -1367,1 +1369,1 @@\n-                double y = (Y[j] * 0x1.0p63) + ((Y[j] - Y[j-1]) * (double)U2);\n+                double y = (Y[j] * 0x1.0p63) + ((Y[j-1] - Y[j]) * (double)U2);\n@@ -1387,1 +1389,1 @@\n-                double y = (Y[j] * 0x1.0p63) + ((Y[j] - Y[j-1]) * (double)U2);\n+                double y = (Y[j] * 0x1.0p63) + ((Y[j-1] - Y[j]) * (double)U2);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,1 +195,2 @@\n-                Hashtable<String, CodeSigner[]> sigFileSigners)\n+                Hashtable<String, CodeSigner[]> sigFileSigners,\n+                Map<CodeSigner[], Map<String, Boolean>> signersToAlgs)\n@@ -210,2 +211,3 @@\n-        JarConstraintsParameters params =\n-            getParams(verifiedSigners, sigFileSigners);\n+        CodeSigner[] entrySigners = sigFileSigners.get(name);\n+        Map<String, Boolean> algsPermittedStatus =\n+            algsPermittedStatusForSigners(signersToAlgs, entrySigners);\n@@ -213,0 +215,4 @@\n+        \/\/ Flag that indicates if only disabled algorithms are used and jar\n+        \/\/ entry should be treated as unsigned.\n+        boolean disabledAlgs = true;\n+        JarConstraintsParameters params = null;\n@@ -215,9 +221,8 @@\n-            if (params != null) {\n-                try {\n-                    params.setExtendedExceptionMsg(JarFile.MANIFEST_NAME,\n-                        name + \" entry\");\n-                    DisabledAlgorithmConstraints.jarConstraints()\n-                           .permits(digest.getAlgorithm(), params);\n-                } catch (GeneralSecurityException e) {\n-                    if (debug != null) {\n-                        debug.println(\"Digest algorithm is restricted: \" + e);\n+            String digestAlg = digest.getAlgorithm();\n+\n+            \/\/ Check if this algorithm is permitted, skip if false.\n+            if (algsPermittedStatus != null) {\n+                Boolean permitted = algsPermittedStatus.get(digestAlg);\n+                if (permitted == null) {\n+                    if (params == null) {\n+                        params = new JarConstraintsParameters(entrySigners);\n@@ -225,1 +230,8 @@\n-                    return null;\n+                    if (!checkConstraints(digestAlg, params)) {\n+                        algsPermittedStatus.put(digestAlg, Boolean.FALSE);\n+                        continue;\n+                    } else {\n+                        algsPermittedStatus.put(digestAlg, Boolean.TRUE);\n+                    }\n+                } else if (!permitted) {\n+                    continue;\n@@ -228,0 +240,4 @@\n+\n+            \/\/ A non-disabled algorithm was used.\n+            disabledAlgs = false;\n+\n@@ -233,1 +249,1 @@\n-                                   name + \" digest=\" + digest.getAlgorithm());\n+                                   name + \" digest=\" + digestAlg);\n@@ -239,2 +255,2 @@\n-            if (!MessageDigest.isEqual(theHash, manHash))\n-                throw new SecurityException(digest.getAlgorithm()+\n+            if (!MessageDigest.isEqual(theHash, manHash)) {\n+                throw new SecurityException(digestAlg +\n@@ -242,0 +258,7 @@\n+            }\n+        }\n+\n+        \/\/ If there were only disabled algorithms used, return null and jar\n+        \/\/ entry will be treated as unsigned.\n+        if (disabledAlgs) {\n+            return null;\n@@ -252,22 +275,10 @@\n-    \/**\n-     * Get constraints parameters for JAR. The constraints should be\n-     * checked against all code signers. Returns the parameters,\n-     * or null if the signers for this entry have already been checked\n-     * or there are no signers for this entry.\n-     *\/\n-    private JarConstraintsParameters getParams(\n-            Map<String, CodeSigner[]> verifiedSigners,\n-            Map<String, CodeSigner[]> sigFileSigners) {\n-\n-        \/\/ verifiedSigners is usually preloaded with the Manifest's signers.\n-        \/\/ If verifiedSigners contains the Manifest, then it will have all of\n-        \/\/ the signers of the JAR. But if it doesn't then we need to fallback\n-        \/\/ and check verifiedSigners to see if the signers of this entry have\n-        \/\/ been checked already.\n-        if (verifiedSigners.containsKey(manifestFileName)) {\n-            if (verifiedSigners.size() > 1) {\n-                \/\/ this means we already checked it previously\n-                return null;\n-            } else {\n-                return new JarConstraintsParameters(\n-                    verifiedSigners.get(manifestFileName));\n+    \/\/ Gets the algorithms permitted status for the signers of this entry.\n+    private static Map<String, Boolean> algsPermittedStatusForSigners(\n+            Map<CodeSigner[], Map<String, Boolean>> signersToAlgs,\n+            CodeSigner[] signers) {\n+        if (signers != null) {\n+            Map<String, Boolean> algs = signersToAlgs.get(signers);\n+            \/\/ create new HashMap if absent\n+            if (algs == null) {\n+                algs = new HashMap<>();\n+                signersToAlgs.put(signers, algs);\n@@ -275,1 +286,15 @@\n-        } else {\n+            return algs;\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Checks the algorithm constraints against the signers of this entry.\n+    private boolean checkConstraints(String algorithm,\n+        JarConstraintsParameters params) {\n+        try {\n+            params.setExtendedExceptionMsg(JarFile.MANIFEST_NAME,\n+                name + \" entry\");\n+            DisabledAlgorithmConstraints.jarConstraints()\n+                   .permits(algorithm, params);\n+            return true;\n+        } catch (GeneralSecurityException e) {\n@@ -277,7 +302,1 @@\n-                debug.println(manifestFileName + \" not present in verifiedSigners\");\n-            }\n-            CodeSigner[] signers = sigFileSigners.get(name);\n-            if (signers == null || verifiedSigners.containsValue(signers)) {\n-                return null;\n-            } else {\n-                return new JarConstraintsParameters(signers);\n+                debug.println(\"Digest algorithm is restricted: \" + e);\n@@ -285,0 +304,1 @@\n+            return false;\n@@ -288,1 +308,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ManifestEntryVerifier.java","additions":67,"deletions":48,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/cbbba1d234670453df9c930dfbf510c0474d4301\/public_suffix_list.dat.\n+https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/3c213aab32b3c014f171b1673d4ce9b5cd72bf1c\/public_suffix_list.dat.\n","filename":"src\/java.base\/share\/legal\/public_suffix.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1081,2 +1081,4 @@\n-purposes only and may cause intermittent failures due to the use of\n-address space layout randomization by the operation system.\n+purposes only.\n+It may cause the VM to unexpectedly exit during start\\-up when the CDS\n+archive cannot be used (for example, when certain VM parameters are\n+changed, or when a different JDK is used).\n@@ -5290,2 +5292,7 @@\n-Application Class Data Sharing (AppCDS) extends class data sharing (CDS)\n-to enable application classes to be placed in a shared archive.\n+Application Class Data Sharing (AppCDS) stores classes used by your\n+applications in an archive file.\n+Since these classes are stored in a format that can be loaded very\n+quickly (compared to classes stored in a JAR file), AppCDS can improve\n+the start\\-up time of your applications.\n+In addition, AppCDS can reduce the runtime memory footprint by sharing\n+parts of these classes across multiple processes.\n@@ -5293,12 +5300,9 @@\n-In addition to the core library classes, AppCDS supports \\f[B]Class Data\n-Sharing\\f[R]\n-[https:\/\/docs.oracle.com\/en\/java\/javase\/12\/vm\/class\\-data\\-sharing.html#GUID\\-7EAA3411\\-8CF0\\-4D19\\-BD05\\-DF5E1780AA91]\n-from the following locations:\n-.IP \\[bu] 2\n-Platform classes from the runtime image\n-.IP \\[bu] 2\n-Application classes from the runtime image\n-.IP \\[bu] 2\n-Application classes from the class path\n-.IP \\[bu] 2\n-Application classes from the module path\n+Classes in the CDS archive are stored in an optimized format that\\[aq]s\n+about 2 to 5 times larger than classes stored in JAR files or the JDK\n+runtime image.\n+Therefore, it\\[aq]s a good idea to archive only those classes that are\n+actually used by your application.\n+These usually are just a small portion of all available classes.\n+For example, your application may use only a few APIs provided by a\n+large library.\n+.SS Using CDS Archives\n@@ -5306,3 +5310,6 @@\n-Archiving application classes provides better start up time at runtime.\n-When running multiple JVM processes, AppCDS also reduces the runtime\n-footprint with memory sharing for read\\-only metadata.\n+By default, in most JDK distributions, unless \\f[CB]\\-Xshare:off\\f[R] is\n+specified, the JVM starts up with a default CDS archive, which is\n+usually located in \\f[CB]JAVA_HOME\/lib\/server\/classes.jsa\\f[R] (or\n+\\f[CB]JAVA_HOME\\\\bin\\\\server\\\\classes.jsa\\f[R] on Windows).\n+This archive contains about 1300 core library classes that are used by\n+most applications.\n@@ -5310,1 +5317,4 @@\n-CDS\/AppCDS supports archiving classes from JAR files only.\n+To use CDS for the exact set of classes used by your application, you\n+can use the \\f[CB]\\-XX:SharedArchiveFile\\f[R] option, which has the\n+general form:\n+.RS\n@@ -5312,5 +5322,2 @@\n-Prior to JDK 11, a non\\-empty directory was reported as a fatal error in\n-the following conditions:\n-.IP \\[bu] 2\n-For base CDS, a non\\-empty directory cannot exist in the\n-\\f[CB]\\-Xbootclasspath\/a\\f[R] path\n+\\f[CB]\\-XX:SharedArchiveFile=<static_archive>:<dynamic_archive>\\f[R]\n+.RE\n@@ -5318,8 +5325,1 @@\n-With \\f[CB]\\-XX:+UseAppCDS\\f[R], a non\\-empty directory could not exist in\n-the \\f[CB]\\-Xbootclasspath\/a\\f[R] path, class path, and module path.\n-.PP\n-In JDK 11 and later, \\f[CB]\\-XX:+UseAppCDS\\f[R] is obsolete and the\n-behavior for a non\\-empty directory is based on the class types in the\n-classlist.\n-A non\\-empty directory is reported as a fatal error in the following\n-conditions:\n+The \\f[CB]<static_archive>\\f[R] overrides the default CDS archive.\n@@ -5327,3 +5327,2 @@\n-If application classes or platform classes are not loaded, dump time\n-only reports an error if a non\\-empty directory exists in\n-\\f[CB]\\-Xbootclasspath\/a\\f[R] path\n+The \\f[CB]<dynamic_archive>\\f[R] provides additional classes that can be\n+loaded on top of those in the \\f[CB]<static_archive>\\f[R].\n@@ -5331,10 +5330,2 @@\n-If application classes or platform classes are loaded, dump time reports\n-an error for a non\\-empty directory that exists in\n-\\f[CB]\\-Xbootclasspath\/a\\f[R] path, class path, or module path\n-.PP\n-In JDK 11 and later, using\n-\\f[CB]\\-XX:DumpLoadedClassList=\\f[R]\\f[I]class_list_file\\f[R] results a\n-generated classlist with all classes (both system library classes and\n-application classes) included.\n-You no longer have to specify \\f[CB]\\-XX:+UseAppCDS\\f[R] with\n-\\f[CB]\\-XX:DumpLoadedClassList\\f[R] to produce a complete class list.\n+On Windows, the above path delimiter \\f[CB]:\\f[R] should be replaced with\n+\\f[CB];\\f[R]\n@@ -5342,4 +5333,3 @@\n-In JDK 11 and later, because \\f[CB]UseAppCDS\\f[R] is obsolete,\n-\\f[CB]SharedArchiveFile\\f[R] becomes a product flag by default.\n-Specifying \\f[CB]+UnlockDiagnosticVMOptions\\f[R] for\n-\\f[CB]SharedArchiveFile\\f[R] is no longer needed in any configuration.\n+(The names \"static\" and \"dyanmic\" are used for historical reasons.\n+The only significance is that the \"static\" archive is loaded first and\n+the \"dynamic\" archive is loaded second).\n@@ -5347,4 +5337,3 @@\n-Class Data Sharing (CDS)\/AppCDS does not support archiving array classes\n-in a class list.\n-When an array in the class list is encountered, CDS dump time gives the\n-explicit error message:\n+The JVM can use up to two archives.\n+To use only a single \\f[CB]<static_archive>\\f[R], you can omit the\n+\\f[CB]<dynamic_archive>\\f[R] portion:\n@@ -5353,1 +5342,1 @@\n-\\f[CB]Preload\\ Warning:\\ Cannot\\ find\\f[R] \\f[I]array_name\\f[R]\n+\\f[CB]\\-XX:SharedArchiveFile=<static_archive>\\f[R]\n@@ -5356,26 +5345,3 @@\n-Although an array in the class list is not allowed, some array classes\n-can still be created at CDS\/AppCDS dump time.\n-Those arrays are created during the execution of the Java code used by\n-the Java class loaders (\\f[CB]PlatformClassLoader\\f[R] and the system\n-class loader) to load classes at dump time.\n-The created arrays are archived with the rest of the loaded classes.\n-.SS Extending Class Data Sharing to Support the Module Path\n-.PP\n-In JDK 11, Class Data Sharing (CDS) has been improved to support\n-archiving classes from the module path.\n-.IP \\[bu] 2\n-To create a CDS archive using the \\f[CB]\\-\\-module\\-path\\f[R] VM option,\n-use the following command line syntax:\n-.RS 2\n-.RS\n-.PP\n-\\f[CB]java\\ \\-Xshare:dump\\ \\-XX:SharedClassListFile=\\f[R]\\f[I]class_list_file\\f[R]\n-\\f[CB]\\-XX:SharedArchiveFile=\\f[R]\\f[I]shared_archive_file\\f[R]\n-\\f[CB]\\-\\-module\\-path=\\f[R]\\f[I]path_to_modular_jar\\f[R] \\f[CB]\\-m\\f[R]\n-\\f[I]module_name\\f[R]\n-.RE\n-.RE\n-.IP \\[bu] 2\n-To run with a CDS archive using the \\f[CB]\\-\\-module\\-path\\f[R] VM option,\n-use the following the command line syntax:\n-.RS 2\n+For convenience, the \\f[CB]<dynamic_archive>\\f[R] records the location of\n+the \\f[CB]<static_archive>\\f[R].\n+Therefore, you can omit the \\f[CB]<static_archive>\\f[R] by saying only:\n@@ -5384,4 +5350,1 @@\n-\\f[CB]java\\ \\-XX:SharedArchiveFile=\\f[R]\\f[I]shared_archive_file\\f[R]\n-\\f[CB]\\-\\-module\\-path=\\f[R]\\f[I]path_to_modular_jar\\f[R] \\f[CB]\\-m\\f[R]\n-\\f[I]module_name\\f[R]\n-.RE\n+\\f[CB]\\-XX:SharedArchiveFile=<dynamic_archive>\\f[R]\n@@ -5389,0 +5352,1 @@\n+.SS Creating CDS Archives\n@@ -5390,119 +5354,1 @@\n-The following table describes how the VM options related to module paths\n-can be used along with the \\f[CB]\\-Xshare\\f[R] option.\n-.PP\n-.TS\n-tab(@);\n-l l l.\n-T{\n-Option\n-T}@T{\n-\\-Xshare:dump\n-T}@T{\n-\\-Xshare:{on,auto}\n-T}\n-_\n-T{\n-\\f[CB]\\-\\-module\\-path\\f[R][1] \\f[I]mp\\f[R]\n-T}@T{\n-Allowed\n-T}@T{\n-Allowed[2]\n-T}\n-T{\n-\\f[CB]\\-\\-module\\f[R]\n-T}@T{\n-Allowed\n-T}@T{\n-Allowed\n-T}\n-T{\n-\\f[CB]\\-\\-add\\-module\\f[R]\n-T}@T{\n-Allowed\n-T}@T{\n-Allowed\n-T}\n-T{\n-\\f[CB]\\-\\-upgrade\\-module\\-path\\f[R][3]\n-T}@T{\n-Disallowed (exits if specified)\n-T}@T{\n-Allowed (disables CDS)\n-T}\n-T{\n-\\f[CB]\\-\\-patch\\-module\\f[R][4]\n-T}@T{\n-Disallowed (exits if specified)\n-T}@T{\n-Allowed (disables CDS)\n-T}\n-T{\n-\\f[CB]\\-\\-limit\\-modules\\f[R][5]\n-T}@T{\n-Disallowed (exits if specified)\n-T}@T{\n-Allowed (disables CDS)\n-T}\n-.TE\n-.PP\n-[1] Although there are two ways of specifying a module in a\n-\\f[CB]\\-\\-module\\-path\\f[R], that is, modular JAR or exploded module, only\n-modular JARs are supported.\n-.PP\n-[2] Different \\f[I]mp\\f[R] can be specified during dump time versus run\n-time.\n-If an archived class K was loaded from \\f[CB]mp1.jar\\f[R] at dump time,\n-but changes in \\f[I]mp\\f[R] cause it to be available from a different\n-\\f[CB]mp2.jar\\f[R] at run time, then the archived version of K will be\n-disregarded at run time; K will be loaded dynamically.\n-.PP\n-[3] Currently, only two system modules are upgradeable\n-(\\f[CB]java.compiler\\f[R] and \\f[CB]jdk.internal.vm.compiler\\f[R]).\n-However, these modules are seldom upgraded in production software.\n-.PP\n-[4] As documented in JEP 261, using \\f[CB]\\-\\-patch\\-module\\f[R] is\n-strongly discouraged for production use.\n-.PP\n-[5] \\f[CB]\\-\\-limit\\-modules\\f[R] is intended for testing purposes.\n-It is seldom used in production software.\n-.PP\n-If \\f[CB]\\-\\-upgrade\\-module\\-path\\f[R], \\f[CB]\\-\\-patch\\-module\\f[R], or\n-\\f[CB]\\-\\-limit\\-modules\\f[R] is specified at dump time, an error will be\n-printed and the JVM will exit.\n-For example, if the \\f[CB]\\-\\-limit\\-modules\\f[R] option is specified at\n-dump time, the user will see the following error:\n-.IP\n-.nf\n-\\f[CB]\n-Error\\ occurred\\ during\\ initialization\\ of\\ VM\n-Cannot\\ use\\ the\\ following\\ option\\ when\\ dumping\\ the\\ shared\\ archive:\\ \\-\\-limit\\-modules\n-\\f[R]\n-.fi\n-.PP\n-If \\f[CB]\\-\\-upgrade\\-module\\-path\\f[R], \\f[CB]\\-\\-patch\\-module\\f[R], or\n-\\f[CB]\\-\\-limit\\-modules\\f[R] is specified at run time, a warning message\n-will be printed indicating that CDS is disabled.\n-For example, if the \\f[CB]\\-\\-limit\\-modules\\f[R] options is specified at\n-run time, the user will see the following warning:\n-.IP\n-.nf\n-\\f[CB]\n-Java\\ HotSpot(TM)\\ 64\\-Bit\\ Server\\ VM\\ warning:\\ CDS\\ is\\ disabled\\ when\\ the\\ \\-\\-limit\\-modules\\ option\\ is\\ specified.\n-\\f[R]\n-.fi\n-.PP\n-Several other noteworthy things include:\n-.IP \\[bu] 2\n-Any valid combinations of \\f[CB]\\-cp\\f[R] and \\f[CB]\\-\\-module\\-path\\f[R]\n-are supported.\n-.IP \\[bu] 2\n-A non\\-empty directory in the module path causes a fatal error.\n-The user will see the following error messages:\n-.RS 2\n-.IP\n-.nf\n-\\f[CB]\n-Error:\\ non\\-empty\\ directory\\ <directory>\\ Hint:\\ enable\\ \\-Xlog:class+path=info\\ to\\ diagnose\\ the\\ failure\\ Error\\ occurred\\ during\\ initialization\\ of\\ VM\\ Cannot\\ have\\ non\\-empty\\ directory\\ in\\ paths\n-\\f[R]\n-.fi\n-.RE\n+CDS archives can be created with several methods:\n@@ -5510,3 +5356,1 @@\n-Unlike the class path, there\\[aq]s no restriction that the module path\n-at dump time must be equal to or be a prefix of the module path at run\n-time.\n+\\f[CB]\\-Xshare:dump\\f[R]\n@@ -5514,2 +5358,1 @@\n-The archive is invalidated if an existing JAR in the module path is\n-updated after archive generation.\n+\\f[CB]\\-XX:ArchiveClassesAtExit\\f[R]\n@@ -5517,16 +5360,1 @@\n-Removing a JAR from the module path does not invalidate the shared\n-archive.\n-Archived classes from the removed JAR are not used at runtime.\n-.SS Dynamic CDS archive\n-.PP\n-Dynamic CDS archive extends AppCDS to allow archiving of classes when a\n-Java application exits.\n-It improves the usability of AppCDS by eliminating the trial run step\n-for creating a class list for each application.\n-The archived classes include all loaded application classes and library\n-classes that are not present in the default CDS archive which is\n-included in the JDK.\n-.PP\n-A base archive is required when creating a dynamic archive.\n-If the base archive is not specified, the default CDS archive is used as\n-the base archive.\n+\\f[CB]jcmd\\ VM.cds\\f[R]\n@@ -5534,4 +5362,4 @@\n-To create a dynamic CDS archive with the default CDS archive as the base\n-archive, just add the\n-\\f[CB]\\-XX:ArchiveClassesAtExit=<dynamic\\ archive>\\f[R] option to the\n-command line for running the Java application.\n+One common operation in all these methods is a \"trial run\", where you\n+run the application once to determine the classes that should be stored\n+in the archive.\n+.SS Creating a Static CDS Archive File with \\-Xshare:dump\n@@ -5539,38 +5367,2 @@\n-If the default CDS archive does not exist, the VM will exit with the\n-following error:\n-.IP\n-.nf\n-\\f[CB]\n-ArchiveClassesAtExit\\ not\\ supported\\ when\\ base\\ CDS\\ archive\\ is\\ not\\ loaded\n-\\f[R]\n-.fi\n-.PP\n-To run the Java application using a dynamic CDS archive, just add the\n-\\f[CB]\\-XX:SharedArchiveFile=<dynamic\\ archive>\\f[R] option to the command\n-line for running the Java application.\n-.PP\n-The base archive is not required to be specified in the command line.\n-The base archive information, including its name and full path, will be\n-retrieved from the dynamic archive header.\n-Note that the user could also use the \\f[CB]\\-XX:SharedArchiveFile\\f[R]\n-option for specifying a regular AppCDS archive.\n-Therefore, the specified archive in the \\f[CB]\\-XX:SharedArchiveFile\\f[R]\n-option could be either a regular or dynamic archive.\n-During VM start up the specified archive header will be read.\n-If \\f[CB]\\-XX:SharedArchiveFile\\f[R] refers to a regular archive, then the\n-behavior will be unchanged.\n-If \\f[CB]\\-XX:SharedArchiveFile\\f[R] refers to a dynamic archive, the VM\n-will retrieve the base archive location from the dynamic archive.\n-If the dynamic archive was created with the default CDS archive, then\n-the current default CDS archive will be used, and will be found relative\n-to the current run time environment.\n-.PP\n-Please refer to \\f[B]JDK\\-8221706\\f[R]\n-[https:\/\/bugs.openjdk.java.net\/browse\/JDK\\-8221706] for details on error\n-checking during dynamic CDS archive dump time and run time.\n-.SS Creating a Shared Archive File and Using It to Run an Application\n-.SS AppCDS archive\n-.PP\n-The following steps create a shared archive file that contains all the\n-classes used by the \\f[CB]test.Hello\\f[R] application.\n-The last step runs the application with the shared archive file.\n+The following steps create a static CDS archive file that contains all\n+the classes used by the \\f[CB]test.Hello\\f[R] application.\n@@ -5588,2 +5380,2 @@\n-Note that the classpath specified by the \\f[CB]\\-cp\\f[R] parameter must\n-contain only JAR files.\n+The classpath specified by the \\f[CB]\\-cp\\f[R] parameter must contain only\n+JAR files.\n@@ -5592,1 +5384,1 @@\n-Create a shared archive, named \\f[CB]hello.jsa\\f[R], that contains all the\n+Create a static archive, named \\f[CB]hello.jsa\\f[R], that contains all the\n@@ -5599,3 +5391,0 @@\n-.PP\n-Note that the classpath used at archive creation time must be the same\n-as (or a prefix of) the classpath used at run time.\n@@ -5604,1 +5393,1 @@\n-Run the application \\f[CB]test.Hello\\f[R] with the shared archive\n+Run the application \\f[CB]test.Hello\\f[R] with the archive\n@@ -5618,1 +5407,1 @@\n-\\f[CB]java\\ \\-XX:SharedArchiveFile=hello.jsa\\ \\-cp\\ hello.jar\\ \\-verbose:class\\ test.Hello\\f[R]\n+\\f[CB]java\\ \\-XX:SharedArchiveFile=hello.jsa\\ \\-cp\\ hello.jar\\ \\-Xlog:class+load\\ test.Hello\\f[R]\n@@ -5622,6 +5411,4 @@\n-.IP\n-.nf\n-\\f[CB]\n-Loaded\\ test.Hello\\ from\\ shared\\ objects\\ file\\ by\\ sun\/misc\/Launcher$AppClassLoader\n-\\f[R]\n-.fi\n+.RS\n+.PP\n+\\f[CB][info][class,load]\\ test.Hello\\ source:\\ shared\\ objects\\ file\\f[R]\n+.RE\n@@ -5629,1 +5416,8 @@\n-.SS Dynamic CDS archive\n+.SS Creating a Dynamic CDS Archive File with \\-XX:SharedArchiveFile\n+.PP\n+Advantages of dynamic CDS archives are:\n+.IP \\[bu] 2\n+They usually use less disk space, since they don\\[aq]t need to store the\n+classes that are already in the static archive.\n+.IP \\[bu] 2\n+They are created with one fewer step than the comparable static archive.\n@@ -5632,3 +5426,2 @@\n-classes used by the \\f[CB]test.Hello\\f[R] application and are not included\n-in the default CDS archive.\n-The second step runs the application with the dynamic CDS archive.\n+classes that are used by the \\f[CB]test.Hello\\f[R] application, excluding\n+those that are already in the default CDS archive.\n@@ -5644,3 +5437,0 @@\n-.PP\n-Note that the classpath used at archive creation time must be the same\n-as (or a prefix of) the classpath used at run time.\n@@ -5662,41 +5452,3 @@\n-To automate the above steps 1 and 2, one can write a script such as the\n-following:\n-.IP\n-.nf\n-\\f[CB]\n-\\ \\ \\ \\ ARCHIVE=hello.jsa\n-\\ \\ \\ \\ if\\ test\\ \\-f\\ $ARCHIVE;\\ then\n-\\ \\ \\ \\ \\ \\ \\ \\ FLAG=\"\\-XX:SharedArchiveFile=$ARCHIVE\"\n-\\ \\ \\ \\ else\n-\\ \\ \\ \\ \\ \\ \\ \\ FLAG=\"\\-XX:ArchiveClassesAtExit=$ARCHIVE\"\n-\\ \\ \\ \\ fi\n-\\ \\ \\ \\ $JAVA_HOME\/bin\/java\\ \\-cp\\ hello.jar\\ $FLAG\\ test.Hello\n-\\f[R]\n-.fi\n-.PP\n-Like an AppCDS archive, the archive needs to be re\\-generated if the\n-Java version has changed.\n-The above script could be adjusted to account for the Java version as\n-follows:\n-.IP\n-.nf\n-\\f[CB]\n-\\ \\ \\ \\ ARCHIVE=hello.jsa\n-\\ \\ \\ \\ VERSION=foo.version\n-\\ \\ \\ \\ if\\ test\\ \\-f\\ $ARCHIVE\\ \\-a\\ \\-f\\ $VERSION\\ &&\\ cmp\\ \\-s\\ $VERSION\\ $JAVA_HOME\/release;\\ then\n-\\ \\ \\ \\ \\ \\ \\ \\ FLAG=\"\\-XX:SharedArchiveFile=$ARCHIVE\"\n-\\ \\ \\ \\ else\n-\\ \\ \\ \\ \\ \\ \\ \\ FLAG=\"\\-XX:ArchiveClassesAtExit=$ARCHIVE\"\n-\\ \\ \\ \\ \\ \\ \\ \\ cp\\ \\-f\\ $JAVA_HOME\/release\\ $VERSION\n-\\ \\ \\ \\ fi\n-\\ \\ \\ \\ $JAVA_HOME\/bin\/java\\ \\-cp\\ hello.jar\\ $FLAG\\ test.Hello\n-\\f[R]\n-.fi\n-.PP\n-Currently, we don\\[aq]t support concurrent dumping operations to the\n-same CDS archive.\n-Care should be taken to avoid multiple writers to the same CDS archive.\n-.PP\n-The user could also create a dynamic CDS archive with a specific base\n-archive, e.g.\n-named as \\f[CB]base.jsa\\f[R] as follows:\n+It\\[aq]s also possible to create a dynamic CDS archive with a\n+non\\-default static CDS archive.\n+E.g.,\n@@ -5708,2 +5460,1 @@\n-To run the application using the dynamic CDS archive \\f[CB]hello.jsa\\f[R]\n-and a specific base CDS archive \\f[CB]base.jsa\\f[R]:\n+To run the application using this dynamic CDS archive:\n@@ -5715,42 +5466,2 @@\n-Note that on Windows, the above path delimiter \\f[CB]:\\f[R] should be\n-replaced with \\f[CB];\\f[R].\n-.PP\n-The above command for specifying a base archive is useful if the base\n-archive used for creating the dynamic archive has been moved.\n-Normally, just specifying the dynamic archive should be sufficient since\n-the base archive info can be retrieved from the dynamic archive header.\n-.SS Sharing a Shared Archive Across Multiple Application Processes\n-.PP\n-You can share the same archive file across multiple applications\n-processes.\n-This reduces memory usage because the archive is memory\\-mapped into the\n-address space of the processes.\n-The operating system automatically shares the read\\-only pages across\n-these processes.\n-.PP\n-The following steps demonstrate how to create a common archive that can\n-be shared by different applications.\n-Classes from \\f[CB]common.jar\\f[R], \\f[CB]hello.jar\\f[R] and \\f[CB]hi.jar\\f[R]\n-are archived in the \\f[CB]common.jsa\\f[R] because they are all in the\n-classpath during the archiving step (step 3).\n-.PP\n-To include classes from \\f[CB]hello.jar\\f[R] and \\f[CB]hi.jar\\f[R], the\n-\\f[CB]\\&.jar\\f[R] files must be added to the classpath specified by the\n-\\f[CB]\\-cp\\f[R] parameter.\n-.IP \"1.\" 3\n-Create a list of all classes used by the \\f[CB]Hello\\f[R] application and\n-another list for the \\f[CB]Hi\\f[R] application:\n-.RS 4\n-.RS\n-.PP\n-\\f[CB]java\\ \\-XX:DumpLoadedClassList=hello.classlist\\ \\-cp\\ common.jar:hello.jar\\ Hello\\f[R]\n-.RE\n-.RS\n-.PP\n-\\f[CB]java\\ \\-XX:DumpLoadedClassList=hi.classlist\\ \\-cp\\ common.jar:hi.jar\\ Hi\\f[R]\n-.RE\n-.RE\n-.IP \"2.\" 3\n-Create a single list of classes used by all the applications that will\n-share the shared archive file.\n-.RS 4\n+(On Windows, the above path delimiter \\f[CB]:\\f[R] should be replaced with\n+\\f[CB];\\f[R])\n@@ -5758,3 +5469,1 @@\n-\\f[B]Linux and macOS\\f[R] The following commands combine the files\n-\\f[CB]hello.classlist\\f[R] and \\f[CB]hi.classlist\\f[R] into one file,\n-\\f[CB]common.classlist\\f[R]:\n+As mention above, the name of the static archive can be skipped:\n@@ -5763,1 +5472,1 @@\n-\\f[CB]cat\\ hello.classlist\\ hi.classlist\\ >\\ common.classlist\\f[R]\n+\\f[CB]java\\ \\-XX:SharedArchiveFile=hello.jsa\\ \\-cp\\ hello.jar\\ Hello\\f[R]\n@@ -5765,0 +5474,1 @@\n+.SS Creating CDS Archive Files with jcmd\n@@ -5766,4 +5476,4 @@\n-\\f[B]Windows\\f[R] The following commands combine the files\n-\\f[CB]hello.classlist\\f[R] and \\f[CB]hi.classlist\\f[R] into one file,\n-\\f[CB]common.classlist\\f[R]:\n-.RS\n+The previous two sections require you to modify the application\\[aq]s\n+start\\-up script in order to create a CDS archive.\n+Sometimes this could be difficult, for example, if the application\\[aq]s\n+class path is set up by complex routines.\n@@ -5771,7 +5481,3 @@\n-\\f[CB]type\\ hello.classlist\\ hi.classlist\\ >\\ common.classlist\\f[R]\n-.RE\n-.RE\n-.IP \"3.\" 3\n-Create a shared archive named \\f[CB]common.jsa\\f[R] that contains all the\n-classes in \\f[CB]common.classlist\\f[R]:\n-.RS 4\n+The \\f[CB]jcmd\\ VM.cds\\f[R] command provides a less intrusive way for\n+creating a CDS archive by connecting to a running JVM process.\n+You can create either a static:\n@@ -5780,1 +5486,1 @@\n-\\f[CB]java\\ \\-Xshare:dump\\ \\-XX:SharedArchiveFile=common.jsa\\ \\-XX:SharedClassListFile=common.classlist\\ \\-cp\\ common.jar:hello.jar:hi.jar\\f[R]\n+\\f[CB]jcmd\\ <pid>\\ VM.cds\\ static_dump\\ my_static_archive.jsa\\f[R]\n@@ -5783,11 +5489,1 @@\n-The classpath parameter used is the common class path prefix shared by\n-the \\f[CB]Hello\\f[R] and \\f[CB]Hi\\f[R] applications.\n-.RE\n-.IP \"4.\" 3\n-Run the \\f[CB]Hello\\f[R] and \\f[CB]Hi\\f[R] applications with the same shared\n-archive:\n-.RS 4\n-.RS\n-.PP\n-\\f[CB]java\\ \\-XX:SharedArchiveFile=common.jsa\\ \\-cp\\ common.jar:hello.jar:hi.jar\\ Hello\\f[R]\n-.RE\n+or a dynamic archive:\n@@ -5796,2 +5492,1 @@\n-\\f[CB]java\\ \\-XX:SharedArchiveFile=common.jsa\\ \\-cp\\ common.jar:hello.jar:hi.jar\\ Hi\\f[R]\n-.RE\n+\\f[CB]jcmd\\ <pid>\\ VM.cds\\ dynamic_dump\\ my_dynamic_archive.jsa\\f[R]\n@@ -5799,1 +5494,0 @@\n-.SS Specifying Additional Shared Data Added to an Archive File\n@@ -5801,2 +5495,3 @@\n-The \\f[CB]SharedArchiveConfigFile\\f[R] option is used to specify\n-additional shared data to add to the archive file.\n+To use the resulting archive file in a subsequent run of the application\n+without modifying the application\\[aq]s start\\-up script, you can use\n+the following technique:\n@@ -5805,1 +5500,1 @@\n-\\f[CB]\\-XX:SharedArchiveConfigFile=\\f[R]\\f[I]shared_config_file\\f[R]\n+\\f[CB]env\\ JAVA_TOOL_OPTIONS=\\-XX:SharedArchiveFile=my_static_archive.jsa\\ bash\\ app_start.sh\\f[R]\n@@ -5808,28 +5503,4 @@\n-JDK 9 and later supports adding both symbols and string objects to an\n-archive for memory sharing when you have multiple JVM processes running\n-on the same host.\n-An example of this is having multiple JVM processes that use the same\n-set of Java EE classes.\n-When these common classes are loaded and used, new symbols and strings\n-may be created and added to the JVM\\[aq]s internal \"symbol\" and \"string\"\n-tables.\n-At runtime, the symbols or string objects mapped from the archive file\n-can be shared across multiple JVM processes, resulting in a reduction of\n-overall memory usage.\n-In addition, archiving strings also provides added performance benefits\n-in both startup time and runtime execution.\n-.PP\n-In JDK 10 and later, CONSTANT_String entries in archived classes are\n-resolved to interned String objects at dump time, and all interned\n-String objects are archived.\n-However, even though all CONSTANT_String literals in all archived\n-classes are resolved, it might still beneficial to add additional\n-strings that are not string literals in class files, but are likely to\n-be used by your application at run time.\n-.PP\n-Symbol data should be generated by the \\f[CB]jcmd\\f[R] tool attaching to a\n-running JVM process.\n-See \\f[B]jcmd\\f[R].\n-.PP\n-The following is an example of the symbol dumping command in\n-\\f[CB]jcmd\\f[R]:\n+Note: to use \\f[CB]jcmd\\ <pid>\\ VM.cds\\ dynamic_dump\\f[R], the JVM process\n+identified by \\f[CB]<pid>\\f[R] must be started with\n+\\f[CB]\\-XX:+RecordDynamicDumpInfo\\f[R], which can also be passed to the\n+application start\\-up script with the same technique:\n@@ -5838,1 +5509,1 @@\n-\\f[CB]jcmd\\f[R] \\f[I]pid\\f[R] \\f[CB]VM.symboltable\\ \\-verbose\\f[R]\n+\\f[CB]env\\ JAVA_TOOL_OPTIONS=\\-XX:+RecordDynamicDumpInfo\\ bash\\ app_start.sh\\f[R]\n@@ -5840,34 +5511,22 @@\n-.RS\n-.PP\n-\\f[B]Note:\\f[R] The first line (process ID) and the second line\n-(\\f[CB]\\@VERSION\\ ...\\f[R]) of this \\f[CB]jcmd\\f[R] output should be\n-excluded from the configuration file.\n-.RE\n-.SS Example of a Configuration File\n-.PP\n-The following is an example of a configuration file:\n-.IP\n-.nf\n-\\f[CB]\n-VERSION:\\ 1.0\n-\\@SECTION:\\ Symbol\n-10\\ \\-1:\\ linkMethod\n-\\f[R]\n-.fi\n-.PP\n-In the configuration file example, the \\f[CB]\\@SECTION:\\ Symbol\\f[R] entry\n-uses the following format:\n-.RS\n-.PP\n-\\f[I]length\\f[R] \\f[I]refcount\\f[R]\\f[CB]:\\f[R] \\f[I]symbol\\f[R]\n-.RE\n-.PP\n-The \\f[I]refcount\\f[R] for a shared symbol is always \\f[CB]\\-1\\f[R].\n-.PP\n-\\f[CB]\\@SECTION\\f[R] specifies the type of the section that follows it.\n-All data within the section must be the same type that\\[aq]s specified\n-by \\f[CB]\\@SECTION\\f[R].\n-Different types of data can\\[aq]t be mixed.\n-Multiple separated data sections for the same type specified by\n-different \\f[CB]\\@SECTION\\f[R] are allowed within one\n-\\f[CB]shared_config_file\\f[R] .\n+.SS Restrictions on Class Path and Module Path\n+.IP \\[bu] 2\n+Neither the class path (\\f[CB]\\-classpath\\f[R] and\n+\\f[CB]\\-Xbootclasspath\/a\\f[R]) nor the module path\n+(\\f[CB]\\-\\-module\\-path\\f[R]) can contain non\\-empty directories.\n+.IP \\[bu] 2\n+Only modular JAR files are supported in \\f[CB]\\-\\-module\\-path\\f[R].\n+Exploded modules are not supported.\n+.IP \\[bu] 2\n+The class path used at archive creation time must be the same as (or a\n+prefix of) the class path used at run time.\n+(There\\[aq]s no such requirement for the module path.)\n+.IP \\[bu] 2\n+The CDS archive cannot be loaded if any JAR files in the class path or\n+module path are modified after the archive is generated.\n+.IP \\[bu] 2\n+If any of the VM options \\f[CB]\\-\\-upgrade\\-module\\-path\\f[R],\n+\\f[CB]\\-\\-patch\\-module\\f[R] or \\f[CB]\\-\\-limit\\-modules\\f[R] are specified,\n+CDS is disabled.\n+This means that the JVM will execute without loading any CDS archives.\n+In addition, if you try to create a CDS archive with any of these 3\n+options specified, the JVM will report an error.\n","filename":"src\/java.base\/share\/man\/java.1","additions":129,"deletions":470,"binary":false,"changes":599,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-    jstring ret;\n+    jstring ret = NULL;\n@@ -368,2 +368,4 @@\n-    CHECK_NULL_RETURN(pattern, NULL);\n-\n+    if (!IS_NULL(pattern)) {\n+        ret = (*env)->NewString(env, pattern, (jsize)wcslen(pattern));\n+        free(pattern);\n+    }\n@@ -371,3 +373,0 @@\n-    ret = (*env)->NewString(env, pattern, (jsize)wcslen(pattern));\n-    free(pattern);\n-\n","filename":"src\/java.base\/windows\/native\/libjava\/HostLocaleProviderAdapter_md.c","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,1 +173,1 @@\n-            if (b.isFocusOwner()) {\n+            if (b.isFocusOwner() && b.isFocusPainted()) {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaButtonLabeledUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,3 +171,3 @@\n-        int[] c = new int[1];\n-        double scale = fDevice.getScaleFactor();\n-        getScreenPixels(new Rectangle(x, y, (int) scale, (int) scale), c);\n+        int scale = fDevice.getScaleFactor();\n+        int[] c = new int[scale * scale];\n+        getScreenPixels(new Rectangle(x, y, scale, scale), c);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CRobot.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,0 +324,5 @@\n+    jsize size = (*env)->GetArrayLength(env, pixels);\n+    if (size < (long) picWidth * picHeight || picWidth < 0 || picHeight < 0) {\n+        JNU_ThrowInternalError(env, \"Invalid arguments to get screen pixels\");\n+        return;\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CRobot.m","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -164,2 +164,2 @@\n-    [sActions setObject:NSAccessibilityShowMenuAction forKey:@\"togglePopup\"];\n-    [sActions setObject:NSAccessibilityPressAction forKey:@\"toggleExpand\"];\n+    [sActions setObject:NSAccessibilityShowMenuAction forKey:@\"toggle popup\"];\n+    [sActions setObject:NSAccessibilityPressAction forKey:@\"toggleexpand\"];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaAccessibilityAction.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/CellAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/CellAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ColumnAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ColumnAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ComboBoxAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ComboBoxAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1095,0 +1095,1 @@\n+    GET_CACCESSIBILITY_CLASS_RETURN(nil);\n@@ -1099,1 +1100,0 @@\n-    GET_CACCESSIBILITY_CLASS_RETURN(nil);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/CommonComponentAccessibility.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ComponentWrapperAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ComponentWrapperAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ListAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ListAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ListRowAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ListRowAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/NavigableTextAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/NavigableTextAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/OutlineAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/OutlineAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/OutlineRowAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/OutlineRowAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TabButtonAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TabButtonAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TabGroupAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TabGroupAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TableAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TableAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TableRowAccessibility.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TableRowAccessibility.m","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5484,0 +5484,15 @@\n+\n+        @Override\n+        public AccessibleContext getAccessibleContext() {\n+            if (accessibleContext == null) {\n+                accessibleContext = new AccessibleBooleanRenderer();\n+            }\n+            return accessibleContext;\n+        }\n+\n+        class AccessibleBooleanRenderer extends JCheckBox.AccessibleJCheckBox {\n+            @Override\n+            public AccessibleAction getAccessibleAction() {\n+                return null;\n+            }\n+        }\n@@ -8405,1 +8420,5 @@\n-                return getCurrentAccessibleContext().getAccessibleAction();\n+                AccessibleContext ac = getCurrentAccessibleContext();\n+                if (ac != null) {\n+                    return ac.getAccessibleAction();\n+                }\n+                return null;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-make_sgn_ordered_dither_array(char* oda, int minerr, int maxerr)\n+make_sgn_ordered_dither_array(signed char* oda, int minerr, int maxerr)\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/cvutils\/img_globals.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-typedef char sgn_ordered_dither_array[8][8];\n+typedef signed char sgn_ordered_dither_array[8][8];\n@@ -151,1 +151,1 @@\n-extern void make_sgn_ordered_dither_array(char* oda, int errmin, int errmax);\n+extern void make_sgn_ordered_dither_array(signed char* oda, int errmin, int errmax);\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/cvutils\/img_globals.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,3 +132,3 @@\n- *      char *redErrTable;\n- *      char *grnErrTable;\n- *      char *bluErrTable;\n+ *      signed char *redErrTable;\n+ *      signed char *grnErrTable;\n+ *      signed char *bluErrTable;\n@@ -162,3 +162,3 @@\n-    char                *redErrTable;           \/* Red ordered dither table *\/\n-    char                *grnErrTable;           \/* Green ordered dither table *\/\n-    char                *bluErrTable;           \/* Blue ordered dither table *\/\n+    signed char         *redErrTable;           \/* Red ordered dither table *\/\n+    signed char         *grnErrTable;           \/* Green ordered dither table *\/\n+    signed char         *bluErrTable;           \/* Blue ordered dither table *\/\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/SurfaceData.h","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    char *PREFIX ## rerr, *PREFIX ## gerr, *PREFIX ## berr; \\\n+    signed char *PREFIX ## rerr, *PREFIX ## gerr, *PREFIX ## berr; \\\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/ByteIndexed.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    char *PREFIX ## rerr, *PREFIX ## gerr, *PREFIX ## berr; \\\n+    signed char *PREFIX ## rerr, *PREFIX ## gerr, *PREFIX ## berr; \\\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/UshortIndexed.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,0 +297,6 @@\n+    private String extractOsInfo(String s) {\n+        if (s.startsWith(\"\\\"\")) s = s.substring(1);\n+        if (s.endsWith(\"\\\"\")) s = s.substring(0, s.length()-1);\n+        return s;\n+    }\n+\n@@ -331,0 +337,10 @@\n+            } else if ((f = new File(\"\/etc\/os-release\")).canRead()) {\n+                Properties props = new Properties();\n+                try (FileInputStream fis = new FileInputStream(f)) {\n+                    props.load(fis);\n+                }\n+                osName = props.getProperty(\"NAME\");\n+                osVersion = props.getProperty(\"VERSION_ID\");\n+                osName = extractOsInfo(osName);\n+                if (osName.equals(\"SLES\")) osName = \"SuSE\";\n+                osVersion = extractOsInfo(osVersion);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/FcFontConfiguration.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,10 @@\n+                } else if ((f = new File(\"\/etc\/os-release\")).canRead()) {\n+                    Properties props = new Properties();\n+                    try (FileInputStream fis = new FileInputStream(f)) {\n+                        props.load(fis);\n+                    }\n+                    osName = props.getProperty(\"NAME\");\n+                    osVersion = props.getProperty(\"VERSION_ID\");\n+                    osName = extractOsInfo(osName);\n+                    if (osName.equals(\"SLES\")) osName = \"SuSE\";\n+                    osVersion = extractOsInfo(osVersion);\n@@ -135,0 +145,6 @@\n+    private String extractOsInfo(String s) {\n+        if (s.startsWith(\"\\\"\")) s = s.substring(1);\n+        if (s.endsWith(\"\\\"\")) s = s.substring(0, s.length()-1);\n+        return s;\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/MFontConfiguration.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n-    char* img_oda_red;\n-    char* img_oda_green;\n-    char* img_oda_blue;\n+    signed char* img_oda_red;\n+    signed char* img_oda_green;\n+    signed char* img_oda_blue;\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/colordata.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -499,0 +499,1 @@\n+typedef void (*FcObjectSetDestroyFuncType)(FcObjectSet *os);\n@@ -545,0 +546,1 @@\n+    FcObjectSetDestroyFuncType FcObjectSetDestroy;\n@@ -574,0 +576,2 @@\n+    FcObjectSetDestroy =\n+        (FcObjectSetDestroyFuncType)dlsym(libfontconfig, \"FcObjectSetDestroy\");\n@@ -583,0 +587,1 @@\n+        FcObjectSetDestroy == NULL ||\n@@ -639,0 +644,1 @@\n+    (*FcObjectSetDestroy)(objset);\n@@ -938,2 +944,4 @@\n-                JNU_CHECK_EXCEPTION(env);\n-\n+                if (IS_NULL(jstr)) {\n+                    (*FcStrListDone)(cacheDirs);\n+                    return;\n+                }\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/fontpath.c","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3920,1 +3920,1 @@\n-        cf.dwStyle = CFS_POINT;\n+        cf.dwStyle = CFS_CANDIDATEPOS;\n@@ -3924,1 +3924,1 @@\n-            cf.dwStyle = CFS_POINT;\n+            cf.dwStyle = CFS_CANDIDATEPOS;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-    toolkit.isInDoDragDropLoop = TRUE;\n+    toolkit.isDnDSourceActive = TRUE;\n@@ -276,1 +276,1 @@\n-    toolkit.isInDoDragDropLoop = FALSE;\n+    toolkit.isDnDSourceActive = FALSE;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDS.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,1 +144,1 @@\n-    AwtToolkit::GetInstance().isInDoDragDropLoop = TRUE;\n+    AwtToolkit::GetInstance().isDnDTargetActive = TRUE;\n@@ -164,1 +164,1 @@\n-        AwtToolkit::GetInstance().isInDoDragDropLoop = FALSE;\n+        AwtToolkit::GetInstance().isDnDTargetActive = FALSE;\n@@ -176,1 +176,1 @@\n-        AwtToolkit::GetInstance().isInDoDragDropLoop = FALSE;\n+        AwtToolkit::GetInstance().isDnDTargetActive = FALSE;\n@@ -203,1 +203,1 @@\n-                AwtToolkit::GetInstance().isInDoDragDropLoop = FALSE;\n+                AwtToolkit::GetInstance().isDnDTargetActive = FALSE;\n@@ -208,1 +208,1 @@\n-            AwtToolkit::GetInstance().isInDoDragDropLoop = FALSE;\n+            AwtToolkit::GetInstance().isDnDTargetActive = FALSE;\n@@ -424,1 +424,1 @@\n-    AwtToolkit::GetInstance().isInDoDragDropLoop = FALSE;\n+    AwtToolkit::GetInstance().isDnDTargetActive = FALSE;\n@@ -1139,1 +1139,1 @@\n-    AwtToolkit::GetInstance().isInDoDragDropLoop = FALSE;\n+    AwtToolkit::GetInstance().isDnDTargetActive = FALSE;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDT.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,5 +31,0 @@\n-static int signum(int i) {\n-  \/\/ special version of signum which returns 1 when value is 0\n-  return i >= 0 ? 1 : -1;\n-}\n-\n@@ -41,3 +36,20 @@\n-    mouseInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;\n-    mouseInput.mi.dx = (x * 65536 \/::GetSystemMetrics(SM_CXSCREEN)) + signum(x);\n-    mouseInput.mi.dy = (y * 65536 \/::GetSystemMetrics(SM_CYSCREEN)) + signum(y);\n+\n+    \/\/ The following calculations take into account a multi-monitor setup using\n+    \/\/ a virtual screen for all monitors combined.\n+    \/\/ More details from Microsoft are here --\n+    \/\/ https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/gdi\/the-virtual-screen\n+\n+    x -= ::GetSystemMetrics(SM_XVIRTUALSCREEN);\n+    y -= ::GetSystemMetrics(SM_YVIRTUALSCREEN);\n+\n+    mouseInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE |\n+                            MOUSEEVENTF_VIRTUALDESK;\n+\n+    int scW = ::GetSystemMetrics(SM_CXVIRTUALSCREEN);\n+    int scH = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);\n+\n+    \/\/ The following calculation to deduce mouse coordinates is based on\n+    \/\/ empirical data\n+    mouseInput.mi.dx = (x * 65536 + scW - 1) \/ scW;\n+    mouseInput.mi.dy = (y * 65536 + scH - 1) \/ scH;\n+\n@@ -45,0 +57,1 @@\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Robot.cpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -347,1 +347,2 @@\n-    isInDoDragDropLoop = FALSE;\n+    isDnDSourceActive = FALSE;\n+    isDnDTargetActive = FALSE;\n@@ -3015,1 +3016,1 @@\n-        if (tk.isInDoDragDropLoop) {\n+        if (tk.isDnDSourceActive || tk.isDnDTargetActive) {\n@@ -3219,1 +3220,1 @@\n-    if (isInDoDragDropLoop) {\n+    if (isDnDSourceActive || isDnDTargetActive) {\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -444,1 +444,2 @@\n-    volatile BOOL isInDoDragDropLoop;\n+    volatile BOOL isDnDSourceActive;\n+    volatile BOOL isDnDTargetActive;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-    char* img_oda_red;\n-    char* img_oda_green;\n-    char* img_oda_blue;\n+    signed char* img_oda_red;\n+    signed char* img_oda_green;\n+    signed char* img_oda_blue;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/colordata.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -869,0 +869,1 @@\n+            mechContext.setChannelBinding(channelBinding);\n@@ -902,0 +903,1 @@\n+            mechContext.setChannelBinding(channelBinding);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/spnego\/SpNegoContext.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1046,0 +1046,4 @@\n+    if (output_token) {\n+        output_token->length = 0;\n+        output_token->value = NULL;\n+    }\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,3 @@\n-                id = id.substring(i1+1, i2);\n+                if (i1 >= 0 && i2 >= 0) {\n+                    id = id.substring(i1 + 1, i2);\n+                }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMURIDereferencer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,3 @@\n-            id = id.substring(i1+1, i2);\n+            if (i1 >= 0 && i2 >= 0) {\n+                id = id.substring(i1 + 1, i2);\n+            }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/Utils.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -462,2 +462,5 @@\n-                else if (systemId != null && !systemId.equals(\"\")) {\n-                    setClassName(Util.baseName(systemId));\n+                else if (systemId != null && !systemId.isEmpty()) {\n+                    String clsName = Util.baseName(systemId);\n+                    if (clsName != null && !clsName.isEmpty()) {\n+                        setClassName(clsName);\n+                    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/XSLTC.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6,8 +6,5 @@\n-    =========================================================================\n-    ==  NOTICE file corresponding to the section 4 d of                    ==\n-    ==  the Apache License, Version 2.0,                                   ==\n-    ==  in this case for the Apache Commons BCEL distribution.             ==\n-    =========================================================================\n-\n-   This product includes software developed by\n-   The Apache Software Foundation (http:\/\/www.apache.org\/).\n+    Apache Commons BCEL\n+    Copyright 2004-2020 The Apache Software Foundation\n+\n+    This product includes software developed at\n+    The Apache Software Foundation (https:\/\/www.apache.org\/).\n","filename":"src\/java.xml\/share\/legal\/bcel.md","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.awt.geom.AffineTransform;\n@@ -481,0 +482,3 @@\n+        Point userSpaceXY = AccessibilityGraphicsEnvironment.toUserSpace(x, y);\n+        x = userSpaceXY.x;\n+        y = userSpaceXY.y;\n@@ -1596,0 +1600,2 @@\n+\n+                                r = AccessibilityGraphicsEnvironment.toDeviceSpaceAbs(r);\n@@ -2260,0 +2266,1 @@\n+                            rect = AccessibilityGraphicsEnvironment.toDeviceSpaceAbs(rect);\n@@ -7341,0 +7348,178 @@\n+\n+    \/**\n+     * A helper class to handle coordinate conversion between screen and user spaces.\n+     * See {@link sun.java2d.SunGraphicsEnvironment}\n+     *\/\n+    private static abstract class AccessibilityGraphicsEnvironment extends GraphicsEnvironment {\n+        \/**\n+         * Returns the graphics configuration which bounds contain the given point in the user's space.\n+         *\n+         * See {@link sun.java2d.SunGraphicsEnvironment#getGraphicsConfigurationAtPoint(GraphicsConfiguration, double, double)}\n+         *\n+         * @param  x the x coordinate of the given point in the user's space\n+         * @param  y the y coordinate of the given point in the user's space\n+         * @return the graphics configuration\n+         *\/\n+        public static GraphicsConfiguration getGraphicsConfigurationAtPoint(double x, double y) {\n+            GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                    .getDefaultScreenDevice().getDefaultConfiguration();\n+            return getGraphicsConfigurationAtPoint(gc, x, y);\n+        }\n+\n+        \/**\n+         * Returns the graphics configuration which bounds contain the given point in the user's space.\n+         *\n+         * See {@link sun.java2d.SunGraphicsEnvironment#getGraphicsConfigurationAtPoint(GraphicsConfiguration, double, double)}\n+         *\n+         * @param  current the default configuration which is checked in the first\n+         *         place\n+         * @param  x the x coordinate of the given point in the user's space\n+         * @param  y the y coordinate of the given point in the user's space\n+         * @return the graphics configuration\n+         *\/\n+        public static GraphicsConfiguration getGraphicsConfigurationAtPoint(\n+                GraphicsConfiguration current, double x, double y) {\n+            if (containsUserSpacePoint(current, x, y)) {\n+                return current;\n+            }\n+            GraphicsEnvironment env = getLocalGraphicsEnvironment();\n+            for (GraphicsDevice device : env.getScreenDevices()) {\n+                GraphicsConfiguration config = device.getDefaultConfiguration();\n+                if (containsUserSpacePoint(config, x, y)) {\n+                    return config;\n+                }\n+            }\n+            return current;\n+        }\n+\n+        \/**\n+         * Returns the graphics configuration which bounds contain the given point in the device space.\n+         *\n+         * @param  x the x coordinate of the given point in the device space\n+         * @param  y the y coordinate of the given point in the device space\n+         * @return the graphics configuration\n+         *\/\n+        public static GraphicsConfiguration getGraphicsConfigurationAtDevicePoint(double x, double y) {\n+            GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                    .getDefaultScreenDevice().getDefaultConfiguration();\n+            return getGraphicsConfigurationAtDevicePoint(gc, x, y);\n+        }\n+\n+        \/**\n+         * Returns the graphics configuration which bounds contain the given point in the device space.\n+         *\n+         * @param  current the default configuration which is checked in the first\n+         *         place\n+         * @param  x the x coordinate of the given point in the device space\n+         * @param  y the y coordinate of the given point in the device space\n+         * @return the graphics configuration\n+         *\/\n+        public static GraphicsConfiguration getGraphicsConfigurationAtDevicePoint(\n+                GraphicsConfiguration current, double x, double y) {\n+            if (containsDeviceSpacePoint(current, x, y)) {\n+                return current;\n+            }\n+            GraphicsEnvironment env = getLocalGraphicsEnvironment();\n+            for (GraphicsDevice device : env.getScreenDevices()) {\n+                GraphicsConfiguration config = device.getDefaultConfiguration();\n+                if (containsDeviceSpacePoint(config, x, y)) {\n+                    return config;\n+                }\n+            }\n+            return current;\n+        }\n+\n+        private static boolean containsDeviceSpacePoint(GraphicsConfiguration config, double x, double y) {\n+            Rectangle bounds = config.getBounds();\n+            bounds = toDeviceSpaceAbs(config, bounds.x, bounds.y, bounds.width, bounds.height);\n+            return bounds.contains(x, y);\n+        }\n+\n+        private static boolean containsUserSpacePoint(GraphicsConfiguration config, double x, double y) {\n+            Rectangle bounds = config.getBounds();\n+            return bounds.contains(x, y);\n+        }\n+\n+        \/**\n+         * Converts absolute coordinates from the device\n+         * space to the user's space space using appropriate device transformation.\n+         *\n+         * @param  x absolute x coordinate in the device's space\n+         * @param  y absolute y coordinate in the device's space\n+         * @return the corresponding coordinates in user's space\n+         *\/\n+        public static Point toUserSpace(int x, int y) {\n+            GraphicsConfiguration gc = getGraphicsConfigurationAtDevicePoint(x, y);\n+            return toUserSpace(gc, x, y);\n+        }\n+\n+        \/**\n+         * Converts absolute coordinates from the device\n+         * space to the user's space using passed graphics configuration.\n+         *\n+         * @param  gc the graphics configuration to be used for transformation\n+         * @param  x absolute x coordinate in the device's space\n+         * @param  y absolute y coordinate in the device's space\n+         * @return the corresponding coordinates in user's space\n+         *\/\n+        public static Point toUserSpace(GraphicsConfiguration gc, int x, int y) {\n+            AffineTransform tx = gc.getDefaultTransform();\n+            Rectangle screen = gc.getBounds();\n+            int userX = screen.x + clipRound((x - screen.x) \/ tx.getScaleX());\n+            int userY = screen.y + clipRound((y - screen.y) \/ tx.getScaleY());\n+            return new Point(userX, userY);\n+        }\n+\n+        \/**\n+         * Converts the rectangle from the user's space to the device space using\n+         * appropriate device transformation.\n+         *\n+         * See {@link sun.java2d.SunGraphicsEnvironment#toDeviceSpaceAbs(Rectangle)}\n+         *\n+         * @param  rect the rectangle in the user's space\n+         * @return the rectangle which uses device space (pixels)\n+         *\/\n+        public static Rectangle toDeviceSpaceAbs(Rectangle rect) {\n+            GraphicsConfiguration gc = getGraphicsConfigurationAtPoint(rect.x, rect.y);\n+            return toDeviceSpaceAbs(gc, rect.x, rect.y, rect.width, rect.height);\n+        }\n+\n+        \/**\n+         * Converts absolute coordinates (x, y) and the size (w, h) from the user's\n+         * space to the device space using passed graphics configuration.\n+         *\n+         * See {@link sun.java2d.SunGraphicsEnvironment#toDeviceSpaceAbs(GraphicsConfiguration, int, int, int, int)}\n+         *\n+         * @param  gc the graphics configuration to be used for transformation\n+         * @param  x absolute coordinate in the user's space\n+         * @param  y absolute coordinate in the user's space\n+         * @param  w the width in the user's space\n+         * @param  h the height in the user's space\n+         * @return the rectangle which uses device space (pixels)\n+         *\/\n+        public static Rectangle toDeviceSpaceAbs(GraphicsConfiguration gc,\n+                                                 int x, int y, int w, int h) {\n+            AffineTransform tx = gc.getDefaultTransform();\n+            Rectangle screen = gc.getBounds();\n+            return new Rectangle(\n+                    screen.x + clipRound((x - screen.x) * tx.getScaleX()),\n+                    screen.y + clipRound((y - screen.y) * tx.getScaleY()),\n+                    clipRound(w * tx.getScaleX()),\n+                    clipRound(h * tx.getScaleY())\n+            );\n+        }\n+\n+        \/**\n+         * See {@link sun.java2d.pipe.Region#clipRound}\n+         *\/\n+        private static int clipRound(final double coordinate) {\n+            final double newv = coordinate - 0.5;\n+            if (newv < Integer.MIN_VALUE) {\n+                return Integer.MIN_VALUE;\n+            }\n+            if (newv > Integer.MAX_VALUE) {\n+                return Integer.MAX_VALUE;\n+            }\n+            return (int) Math.ceil(newv);\n+        }\n+    }\n","filename":"src\/jdk.accessibility\/windows\/classes\/com\/sun\/java\/accessibility\/internal\/AccessBridge.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -4032,6 +4032,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (ByteSpecies) SPECIES_64;\n-            case S_128_BIT: return (ByteSpecies) SPECIES_128;\n-            case S_256_BIT: return (ByteSpecies) SPECIES_256;\n-            case S_512_BIT: return (ByteSpecies) SPECIES_512;\n-            case S_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (ByteSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (ByteSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (ByteSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (ByteSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3634,6 +3634,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (DoubleSpecies) SPECIES_64;\n-            case S_128_BIT: return (DoubleSpecies) SPECIES_128;\n-            case S_256_BIT: return (DoubleSpecies) SPECIES_256;\n-            case S_512_BIT: return (DoubleSpecies) SPECIES_512;\n-            case S_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (DoubleSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (DoubleSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (DoubleSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (DoubleSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3621,6 +3621,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (FloatSpecies) SPECIES_64;\n-            case S_128_BIT: return (FloatSpecies) SPECIES_128;\n-            case S_256_BIT: return (FloatSpecies) SPECIES_256;\n-            case S_512_BIT: return (FloatSpecies) SPECIES_512;\n-            case S_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (FloatSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (FloatSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (FloatSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (FloatSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3730,6 +3730,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (IntSpecies) SPECIES_64;\n-            case S_128_BIT: return (IntSpecies) SPECIES_128;\n-            case S_256_BIT: return (IntSpecies) SPECIES_256;\n-            case S_512_BIT: return (IntSpecies) SPECIES_512;\n-            case S_Max_BIT: return (IntSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (IntSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (IntSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (IntSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (IntSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3624,6 +3624,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (LongSpecies) SPECIES_64;\n-            case S_128_BIT: return (LongSpecies) SPECIES_128;\n-            case S_256_BIT: return (LongSpecies) SPECIES_256;\n-            case S_512_BIT: return (LongSpecies) SPECIES_512;\n-            case S_Max_BIT: return (LongSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (LongSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (LongSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (LongSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (LongSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4027,6 +4027,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (ShortSpecies) SPECIES_64;\n-            case S_128_BIT: return (ShortSpecies) SPECIES_128;\n-            case S_256_BIT: return (ShortSpecies) SPECIES_256;\n-            case S_512_BIT: return (ShortSpecies) SPECIES_512;\n-            case S_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (ShortSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (ShortSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (ShortSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (ShortSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5036,6 +5036,6 @@\n-        switch (s) {\n-            case S_64_BIT: return ($Type$Species) SPECIES_64;\n-            case S_128_BIT: return ($Type$Species) SPECIES_128;\n-            case S_256_BIT: return ($Type$Species) SPECIES_256;\n-            case S_512_BIT: return ($Type$Species) SPECIES_512;\n-            case S_Max_BIT: return ($Type$Species) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return ($Type$Species) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return ($Type$Species) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return ($Type$Species) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return ($Type$Species) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -852,1 +852,1 @@\n-    native long translate(Object obj);\n+    native long translate(Object obj, boolean callPostTranslation);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -69,0 +71,1 @@\n+import jdk.vm.ci.services.Services;\n@@ -202,0 +205,6 @@\n+    \/**\n+     * Decodes the exception encoded in {@code buffer} and throws it.\n+     *\n+     * @param buffer a native byte buffer containing an exception encoded by\n+     *            {@link #encodeThrowable}\n+     *\/\n@@ -203,2 +212,6 @@\n-    static Throwable decodeThrowable(String encodedThrowable) throws Throwable {\n-        return TranslatedException.decodeThrowable(encodedThrowable);\n+    static void decodeAndThrowThrowable(long buffer) throws Throwable {\n+        Unsafe unsafe = UnsafeAccess.UNSAFE;\n+        int encodingLength = unsafe.getInt(buffer);\n+        byte[] encoding = new byte[encodingLength];\n+        unsafe.copyMemory(null, buffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n+        throw TranslatedException.decodeThrowable(encoding);\n@@ -207,0 +220,12 @@\n+    \/**\n+     * If {@code bufferSize} is large enough, encodes {@code throwable} into a byte array and writes\n+     * it to {@code buffer}. The encoding in {@code buffer} can be decoded by\n+     * {@link #decodeAndThrowThrowable}.\n+     *\n+     * @param throwable the exception to encode\n+     * @param buffer a native byte buffer\n+     * @param bufferSize the size of {@code buffer} in bytes\n+     * @return the number of bytes written into {@code buffer} if {@code bufferSize} is large\n+     *         enough, otherwise {@code -N} where {@code N} is the value {@code bufferSize} needs to\n+     *         be to fit the encoding\n+     *\/\n@@ -208,2 +233,10 @@\n-    static String encodeThrowable(Throwable throwable) throws Throwable {\n-        return TranslatedException.encodeThrowable(throwable);\n+    static int encodeThrowable(Throwable throwable, long buffer, int bufferSize) throws Throwable {\n+        byte[] encoding = TranslatedException.encodeThrowable(throwable);\n+        int requiredSize = 4 + encoding.length;\n+        if (bufferSize < requiredSize) {\n+            return -requiredSize;\n+        }\n+        Unsafe unsafe = UnsafeAccess.UNSAFE;\n+        unsafe.putInt(buffer, encoding.length);\n+        unsafe.copyMemory(encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer + 4, encoding.length);\n+        return requiredSize;\n@@ -238,0 +271,4 @@\n+        ForceTranslateFailure(String.class, null, \"Forces HotSpotJVMCIRuntime.translate to throw an exception in the context \" +\n+                \"of the peer runtime. The value is a filter that can restrict the forced failure to matching translated \" +\n+                \"objects. See HotSpotJVMCIRuntime.postTranslation for more details. This option exists soley to test \" +\n+                \"correct handling of translation failure.\"),\n@@ -1143,1 +1180,82 @@\n-        return compilerToVm.translate(obj);\n+        return compilerToVm.translate(obj, Option.ForceTranslateFailure.getString() != null);\n+    }\n+\n+    private static final Pattern FORCE_TRANSLATE_FAILURE_FILTER_RE = Pattern.compile(\"(?:(method|type|nmethod)\/)?([^:]+)(?::(hotspot|native))?\");\n+\n+    \/**\n+     * Forces translation failure based on {@code translatedObject} and the value of\n+     * {@link Option#ForceTranslateFailure}. The value is zero or more filters separated by a comma.\n+     * The syntax for a filter is:\n+     *\n+     * <pre>\n+     *   Filter = [ TypeSelector \"\/\" ] Substring [ \":\" JVMCIEnvSelector ] .\n+     *   TypeSelector = \"type\" | \"method\" | \"nmethod\"\n+     *   JVMCIEnvSelector = \"native\" | \"hotspot\"\n+     * <\/pre>\n+     *\n+     * For example:\n+     *\n+     * <pre>\n+     *   -Djvmci.ForceTranslateFailure=nmethod\/StackOverflowError:native,method\/computeHash,execute\n+     * <\/pre>\n+     *\n+     * will cause failure of:\n+     * <ul>\n+     * <li>translating a {@link HotSpotNmethod} to the libjvmci heap whose fully qualified name\n+     * contains \"StackOverflowError\"<\/li>\n+     * <li>translating a {@link HotSpotResolvedJavaMethodImpl} to the libjvmci or HotSpot heap whose\n+     * fully qualified name contains \"computeHash\"<\/li>\n+     * <li>translating a {@link HotSpotNmethod}, {@link HotSpotResolvedJavaMethodImpl} or\n+     * {@link HotSpotResolvedObjectTypeImpl} to the libjvmci or HotSpot heap whose fully qualified\n+     * name contains \"execute\"<\/li>\n+     * <\/ul>\n+     *\/\n+    @VMEntryPoint\n+    static void postTranslation(Object translatedObject) {\n+        String value = Option.ForceTranslateFailure.getString();\n+        String toMatch;\n+        String type;\n+        if (translatedObject instanceof HotSpotResolvedJavaMethodImpl) {\n+            toMatch = ((HotSpotResolvedJavaMethodImpl) translatedObject).format(\"%H.%n\");\n+            type = \"method\";\n+        } else if (translatedObject instanceof HotSpotResolvedObjectTypeImpl) {\n+            toMatch = ((HotSpotResolvedObjectTypeImpl) translatedObject).toJavaName();\n+            type = \"type\";\n+        } else if (translatedObject instanceof HotSpotNmethod) {\n+            HotSpotNmethod nmethod = (HotSpotNmethod) translatedObject;\n+            if (nmethod.getMethod() != null) {\n+                toMatch = nmethod.getMethod().format(\"%H.%n\");\n+            } else {\n+                toMatch = String.valueOf(nmethod.getName());\n+            }\n+            type = \"nmethod\";\n+        } else {\n+            return;\n+        }\n+        String[] filters = value.split(\",\");\n+        for (String filter : filters) {\n+            Matcher m = FORCE_TRANSLATE_FAILURE_FILTER_RE.matcher(filter);\n+            if (!m.matches()) {\n+                throw new JVMCIError(Option.ForceTranslateFailure + \" filter does not match \" + FORCE_TRANSLATE_FAILURE_FILTER_RE + \": \" + filter);\n+            }\n+            String typeSelector = m.group(1);\n+            String substring = m.group(2);\n+            String jvmciEnvSelector = m.group(3);\n+            if (jvmciEnvSelector != null) {\n+                if (jvmciEnvSelector.equals(\"native\")) {\n+                    if (!Services.IS_IN_NATIVE_IMAGE) {\n+                        continue;\n+                    }\n+                } else {\n+                    if (Services.IS_IN_NATIVE_IMAGE) {\n+                        continue;\n+                    }\n+                }\n+            }\n+            if (typeSelector != null && !typeSelector.equals(type)) {\n+                continue;\n+            }\n+            if (toMatch.contains(substring)) {\n+                throw new JVMCIError(\"translation of \" + translatedObject + \" failed due to matching \" + Option.ForceTranslateFailure + \" filter \\\"\" + filter + \"\\\"\");\n+            }\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":124,"deletions":6,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,5 @@\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n@@ -29,1 +34,0 @@\n-import java.util.Formatter;\n@@ -31,1 +35,4 @@\n-import java.util.Objects;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n+\n+import jdk.vm.ci.common.JVMCIError;\n@@ -39,0 +46,20 @@\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails due to an\n+     * {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails for any reason\n+     * other than {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_THROWABLE_BYTES;\n+    static {\n+        try {\n+            FALLBACK_ENCODED_THROWABLE_BYTES = encodeThrowable(new TranslatedException(\"error during encoding\", \"<unknown>\"), false);\n+            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES = encodeThrowable(new OutOfMemoryError(), false);\n+        } catch (IOException e) {\n+            throw new JVMCIError(e);\n+        }\n+    }\n+\n@@ -113,14 +140,2 @@\n-    \/**\n-     * Encodes an exception message to distinguish a null message from an empty message.\n-     *\n-     * @return {@code value} with a space prepended iff {@code value != null}\n-     *\/\n-    private static String encodeMessage(String value) {\n-        return value != null ? ' ' + value : value;\n-    }\n-\n-    private static String decodeMessage(String value) {\n-        if (value.length() == 0) {\n-            return null;\n-        }\n-        return value.substring(1);\n+    private static String emptyIfNull(String value) {\n+        return value == null ? \"\" : value;\n@@ -129,2 +144,2 @@\n-    private static String encodedString(String value) {\n-        return Objects.toString(value, \"\").replace('|', '_');\n+    private static String emptyAsNull(String value) {\n+        return value.isEmpty() ? null : value;\n@@ -134,8 +149,2 @@\n-     * Encodes {@code throwable} including its stack and causes as a string. The encoding format of\n-     * a single exception is:\n-     *\n-     * <pre>\n-     * <exception class name> '|' <exception message> '|' <stack size> '|' [ <classLoader> '|' <module> '|' <moduleVersion> '|' <class> '|' <method> '|' <file> '|' <line> '|' ]*\n-     * <\/pre>\n-     *\n-     * Each exception is encoded before the exception it causes.\n+     * Encodes {@code throwable} including its stack and causes as a {@linkplain GZIPOutputStream\n+     * compressed} byte array that can be decoded by {@link #decodeThrowable}.\n@@ -144,1 +153,1 @@\n-    static String encodeThrowable(Throwable throwable) throws Throwable {\n+    static byte[] encodeThrowable(Throwable throwable) throws Throwable {\n@@ -146,1 +155,11 @@\n-            Formatter enc = new Formatter();\n+            return encodeThrowable(throwable, true);\n+        } catch (OutOfMemoryError e) {\n+            return FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+        } catch (Throwable e) {\n+            return FALLBACK_ENCODED_THROWABLE_BYTES;\n+        }\n+    }\n+\n+    private static byte[] encodeThrowable(Throwable throwable, boolean withCauseAndStack) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(baos))) {\n@@ -150,0 +169,3 @@\n+                if (!withCauseAndStack) {\n+                    break;\n+                }\n@@ -156,2 +178,3 @@\n-                enc.format(\"%s|%s|\", current.getClass().getName(), encodedString(encodeMessage(current.getMessage())));\n-                StackTraceElement[] stackTrace = current.getStackTrace();\n+                dos.writeUTF(current.getClass().getName());\n+                dos.writeUTF(emptyIfNull(current.getMessage()));\n+                StackTraceElement[] stackTrace = withCauseAndStack ? current.getStackTrace() : null;\n@@ -161,1 +184,1 @@\n-                enc.format(\"%d|\", stackTrace.length);\n+                dos.writeInt(stackTrace.length);\n@@ -165,4 +188,7 @@\n-                        enc.format(\"%s|%s|%s|%s|%s|%s|%d|\", encodedString(frame.getClassLoaderName()),\n-                                encodedString(frame.getModuleName()), encodedString(frame.getModuleVersion()),\n-                                frame.getClassName(), frame.getMethodName(),\n-                                encodedString(frame.getFileName()), frame.getLineNumber());\n+                        dos.writeUTF(emptyIfNull(frame.getClassLoaderName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleVersion()));\n+                        dos.writeUTF(emptyIfNull(frame.getClassName()));\n+                        dos.writeUTF(emptyIfNull(frame.getMethodName()));\n+                        dos.writeUTF(emptyIfNull(frame.getFileName()));\n+                        dos.writeInt(frame.getLineNumber());\n@@ -172,9 +198,0 @@\n-            return enc.toString();\n-        } catch (Throwable e) {\n-            assert printStackTrace(e);\n-            try {\n-                return e.getClass().getName() + \"|\" + encodedString(e.getMessage()) + \"|0|\";\n-            } catch (Throwable e2) {\n-                assert printStackTrace(e2);\n-                return \"java.lang.Throwable|too many errors during encoding|0|\";\n-            }\n@@ -182,0 +199,1 @@\n+        return baos.toByteArray();\n@@ -186,2 +204,2 @@\n-     * below the frame of the first method in {@link CompilerToVM}. The chopped frames are specific\n-     * to the implementation of {@link HotSpotJVMCIRuntime#decodeThrowable(String)}.\n+     * below the frame of the first method in {@link CompilerToVM}. The chopped frames are for the\n+     * VM call to {@link HotSpotJVMCIRuntime#decodeAndThrowThrowable}.\n@@ -189,1 +207,1 @@\n-    private static StackTraceElement[] getStackTraceSuffix() {\n+    private static StackTraceElement[] getMyStackTrace() {\n@@ -209,4 +227,2 @@\n-    static Throwable decodeThrowable(String encodedThrowable) {\n-        try {\n-            int i = 0;\n-            String[] parts = encodedThrowable.split(\"\\\\|\");\n+    static Throwable decodeThrowable(byte[] encodedThrowable) {\n+        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(encodedThrowable)))) {\n@@ -215,3 +231,4 @@\n-            while (i != parts.length) {\n-                String exceptionClassName = parts[i++];\n-                String exceptionMessage = decodeMessage(parts[i++]);\n+            StackTraceElement[] myStack = getMyStackTrace();\n+            while (dis.available() != 0) {\n+                String exceptionClassName = dis.readUTF();\n+                String exceptionMessage = emptyAsNull(dis.readUTF());\n@@ -219,4 +236,4 @@\n-                int stackTraceDepth = Integer.parseInt(parts[i++]);\n-\n-                StackTraceElement[] suffix = getStackTraceSuffix();\n-                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + suffix.length];\n+                int stackTraceDepth = dis.readInt();\n+                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + myStack.length];\n+                int stackTraceIndex = 0;\n+                int myStackIndex = 0;\n@@ -224,18 +241,21 @@\n-                    String classLoaderName = parts[i++];\n-                    String moduleName = parts[i++];\n-                    String moduleVersion = parts[i++];\n-                    String className = parts[i++];\n-                    String methodName = parts[i++];\n-                    String fileName = parts[i++];\n-                    int lineNumber = Integer.parseInt(parts[i++]);\n-                    if (classLoaderName.isEmpty()) {\n-                        classLoaderName = null;\n-                    }\n-                    if (moduleName.isEmpty()) {\n-                        moduleName = null;\n-                    }\n-                    if (moduleVersion.isEmpty()) {\n-                        moduleVersion = null;\n-                    }\n-                    if (fileName.isEmpty()) {\n-                        fileName = null;\n+                    String classLoaderName = emptyAsNull(dis.readUTF());\n+                    String moduleName = emptyAsNull(dis.readUTF());\n+                    String moduleVersion = emptyAsNull(dis.readUTF());\n+                    String className = emptyAsNull(dis.readUTF());\n+                    String methodName = emptyAsNull(dis.readUTF());\n+                    String fileName = emptyAsNull(dis.readUTF());\n+                    int lineNumber = dis.readInt();\n+                    StackTraceElement ste = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n+\n+                    if (ste.isNativeMethod()) {\n+                        \/\/ Best effort attempt to weave stack traces from two heaps into\n+                        \/\/ a single stack trace using native method frames as stitching points.\n+                        \/\/ This is not 100% reliable as there's no guarantee that native method\n+                        \/\/ frames only exist for calls between HotSpot and libjvmci.\n+                        while (myStackIndex < myStack.length) {\n+                            StackTraceElement suffixSTE = myStack[myStackIndex++];\n+                            if (suffixSTE.isNativeMethod()) {\n+                                break;\n+                            }\n+                            stackTrace[stackTraceIndex++] = suffixSTE;\n+                        }\n@@ -243,1 +263,4 @@\n-                    stackTrace[j] = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n+                    stackTrace[stackTraceIndex++] = ste;\n+                }\n+                while (myStackIndex < myStack.length) {\n+                    stackTrace[stackTraceIndex++] = myStack[myStackIndex++];\n@@ -245,1 +268,0 @@\n-                System.arraycopy(suffix, 0, stackTrace, stackTraceDepth, suffix.length);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/TranslatedException.java","additions":101,"deletions":79,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,5 @@\n+    public static final char PACKAGE_SEPARATOR_INTERNAL = '\/';\n+    public static final char HIDDEN_SEPARATOR_INTERNAL = '.';\n+    public static final char PACKAGE_SEPARATOR_JAVA = HIDDEN_SEPARATOR_INTERNAL;\n+    public static final char HIDDEN_SEPARATOR_JAVA = PACKAGE_SEPARATOR_INTERNAL;\n+\n@@ -90,2 +95,3 @@\n-     * Classes for lambdas can have {@code \/} characters that are not package separators. These are\n-     * distinguished by being followed by a character that is not a\n+     * Hidden classes have {@code \/} characters in their internal names and {@code .} characters in their names returned\n+     * by {@link Class#getName()} that are not package separators.\n+     * These are distinguished by being followed by a character that is not a\n@@ -94,0 +100,4 @@\n+     *\n+     * @param name the name to perform the replacements on\n+     * @param packageSeparator the {@link Character} used as the package separator, e.g. {@code \/} in internal form\n+     * @param hiddenSeparator the {@link Character} used as the hidden class separator, e.g. {@code .} in internal form\n@@ -95,1 +105,2 @@\n-    private static String replacePackageSeparatorsWithDot(String name) {\n+    private static String replacePackageAndHiddenSeparators(String name, Character packageSeparator, Character hiddenSeparator) {\n+        int index = name.indexOf(hiddenSeparator);   \/\/ check if it's a hidden class\n@@ -97,1 +108,0 @@\n-        int i = 0;\n@@ -99,8 +109,6 @@\n-        while (i < length - 1) {\n-            char ch = name.charAt(i);\n-            if (ch == '\/' && Character.isJavaIdentifierStart(name.charAt(i + 1))) {\n-                buf.append('.');\n-            } else {\n-                buf.append(ch);\n-            }\n-            i++;\n+        if (index < 0) {\n+            buf.append(name.replace(packageSeparator, hiddenSeparator));\n+        } else {\n+            buf.append(name.substring(0, index).replace(packageSeparator, hiddenSeparator));\n+            buf.append(packageSeparator);\n+            buf.append(name.substring(index + 1));\n@@ -108,1 +116,0 @@\n-        buf.append(name.charAt(length - 1));\n@@ -125,1 +132,2 @@\n-                String result = replacePackageSeparatorsWithDot(name.substring(1, name.length() - 1));\n+                String type = name.substring(1, name.length() - 1);\n+                String result = replacePackageAndHiddenSeparators(type, PACKAGE_SEPARATOR_INTERNAL, HIDDEN_SEPARATOR_INTERNAL);\n@@ -127,1 +135,1 @@\n-                    final int lastDot = result.lastIndexOf('.');\n+                    final int lastDot = result.lastIndexOf(HIDDEN_SEPARATOR_INTERNAL);\n@@ -135,1 +143,5 @@\n-                return classForNameCompatible ? replacePackageSeparatorsWithDot(name) : internalNameToJava(name.substring(1), qualified, classForNameCompatible) + \"[]\";\n+                if (classForNameCompatible) {\n+                    return replacePackageAndHiddenSeparators(name, PACKAGE_SEPARATOR_INTERNAL, HIDDEN_SEPARATOR_INTERNAL);\n+                } else {\n+                    return internalNameToJava(name.substring(1), qualified, false) + \"[]\";\n+                }\n@@ -216,1 +228,1 @@\n-            return className.replace('.', '\/');\n+            return replacePackageAndHiddenSeparators(className, PACKAGE_SEPARATOR_JAVA, HIDDEN_SEPARATOR_JAVA);\n@@ -255,1 +267,3 @@\n-                result.append(\"L\").append(base.replace('.', '\/')).append(\";\");\n+                result.append(\"L\")\n+                        .append(replacePackageAndHiddenSeparators(base, PACKAGE_SEPARATOR_JAVA, HIDDEN_SEPARATOR_JAVA))\n+                        .append(\";\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/MetaUtil.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -767,0 +767,50 @@\n+.B \\f[CB]VM.cds\\f[R] [\\f[I]arguments\\f[R]]\n+Dumps a static or dynamic shared archive that includes all currently\n+loaded classes.\n+.RS\n+.PP\n+Impact: Medium \\-\\-\\- pause time depends on number of loaded classes\n+.PP\n+Permission: \\f[CB]java.lang.management.ManagementPermission(monitor)\\f[R]\n+.PP\n+\\f[I]arguments\\f[R]:\n+.IP \\[bu] 2\n+\\f[CB]subcmd\\f[R]: must be either \\f[CB]static_dump\\f[R] or\n+.IP \\[bu] 2\n+\\f[CB]filename\\f[R]: (Optional) Name of the shared archive to be dumped\n+(STRING, no default value)\n+.PP\n+If \\f[CB]filename\\f[R] is not specified, a default file name is chosen\n+using the pid of the target JVM process.\n+For example, java_pid1234_static.jsa, java_pid5678_dynamic.jsa, etc.\n+.PP\n+If \\f[CB]filename\\f[R] is not specified as an absolute path, the archive\n+file is created in a directory relative to the current directory of the\n+target JVM process.\n+.RE\n+.TP\n+.B \\f[CB]VM.classloaders\\f[R] [\\f[I]options\\f[R]]\n+Prints classloader hierarchy.\n+.RS\n+.PP\n+Impact: Medium \\-\\-\\- Depends on number of class loaders and classes\n+loaded.\n+.PP\n+Permission: \\f[CB]java.lang.management.ManagementPermission(monitor)\\f[R]\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[CB]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[CB]show\\-classes\\f[R]: (Optional) Print loaded classes.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]verbose\\f[R]: (Optional) Print detailed information.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]fold\\f[R]: (Optional) Show loaders of the same name and class as\n+one.\n+(BOOLEAN, true)\n+.RE\n+.TP\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -359,1 +359,2 @@\n-                if (jarfile.isMultiRelease()) {\n+                \/\/ exclude module-info.class since this jarFile is on classpath\n+                if (jarfile.isMultiRelease() && !cf.getName().equals(\"module-info\")) {\n@@ -440,1 +441,0 @@\n-    private static final String MODULE_INFO = \"module-info.class\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/ClassFileReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,8 @@\n-            throw new Error(e);\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException x) {\n+                throw x;\n+            } else if (cause instanceof Error x) {\n+                throw x;\n+            } else {\n+                throw new Error(e);\n+            }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/DependencyFinder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        super();\n+        super(JdepsTask.getMessage(key, params));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/MultiReleaseException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,9 +58,4 @@\n-                if (nameToVersion.containsKey(name)) {\n-                    if (!version.equals(nameToVersion.get(name))) {\n-                        throw new MultiReleaseException(\n-                                \"err.multirelease.version.associated\",\n-                                name, nameToVersion.get(name), version\n-                        );\n-                    }\n-                } else {\n-                    nameToVersion.put(name, version);\n+                String v = nameToVersion.computeIfAbsent(name, _n -> version);\n+                if (!version.equals(v)) {\n+                    throw new MultiReleaseException(\"err.multirelease.version.associated\",\n+                                name, nameToVersion.get(name), version);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/VersionHelper.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,0 @@\n-    debugMonitorEnter(classTrackLock);\n@@ -86,3 +85,1 @@\n-        \/\/ Class tracking not initialized, nobody's interested.\n-        debugMonitorExit(classTrackLock);\n-        return NULL;\n+      return NULL;\n@@ -90,0 +87,11 @@\n+\n+    \/* Allocate new bag outside classTrackLock lock to avoid deadlock.\n+     *\n+     * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n+     * It is dangerous to call them (via bagCreateBag\/bagDestroyBag()) while holding monitor(s),\n+     * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing\n+     * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n+     * which can lead to deadlock.\n+     *\/\n+    struct bag* new_bag = bagCreateBag(sizeof(char*), 10);\n+    debugMonitorEnter(classTrackLock);\n@@ -91,1 +99,1 @@\n-    deletedSignatures = bagCreateBag(sizeof(char*), 10);\n+    deletedSignatures = new_bag;\n@@ -197,0 +205,3 @@\n+    \/\/ Allocate bag outside classTrackLock lock to avoid deadlock.\n+    \/\/ See comments in classTrack_processUnloads() for details.\n+    struct bag* new_bag = bagCreateBag(sizeof(char*), 1000);\n@@ -198,1 +209,1 @@\n-    deletedSignatures = bagCreateBag(sizeof(char*), 1000);\n+    deletedSignatures = new_bag;\n@@ -217,0 +228,3 @@\n+    struct bag* to_delete = deletedSignatures;\n+    deletedSignatures = NULL;\n+    debugMonitorExit(classTrackLock);\n@@ -218,4 +232,5 @@\n-    if (deletedSignatures != NULL) {\n-        bagEnumerateOver(deletedSignatures, cleanDeleted, NULL);\n-        bagDestroyBag(deletedSignatures);\n-        deletedSignatures = NULL;\n+    \/\/ Deallocate bag outside classTrackLock to avoid deadlock.\n+    \/\/ See comments in classTrack_processUnloads() for details.\n+    if (to_delete != NULL) {\n+      bagEnumerateOver(to_delete, cleanDeleted, NULL);\n+      bagDestroyBag(to_delete);\n@@ -223,2 +238,0 @@\n-\n-    debugMonitorExit(classTrackLock);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -235,0 +235,1 @@\n+    JDI_ASSERT_MSG(request->methodSignature == NULL, \"Request methodSignature not null\");\n@@ -776,0 +777,4 @@\n+    JDI_ASSERT_MSG(request->methodSignature != NULL, \"methodSignature is NULL\");\n+    jvmtiDeallocate(request->methodSignature);\n+    request->methodSignature = NULL;\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/invoker.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,0 +158,2 @@\n+        this.x0 = x0;\n+        this.x1 = x1;\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L32X64MixRandom.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -362,0 +362,23 @@\n+\n+#ifdef _WINDOWS\n+  \/\/ We need to test the special-case parsing for drive letters in\n+  \/\/ log file paths e.g. c:\\log.txt and c:\/log.txt. Our temp directory\n+  \/\/ based TestLogFileName should already be the \\ format (we print it\n+  \/\/ below to visually verify) so we only need to convert to \/.\n+  printf(\"Checked: %s\\n\", buf);\n+  \/\/ First disable logging so the current log file will be closed and we\n+  \/\/ can delete it, so that UL won't try to perform log file rotation.\n+  \/\/ The rotated file would not be auto-deleted.\n+  set_log_config(TestLogFileName, \"all=off\");\n+  delete_file(TestLogFileName);\n+\n+  \/\/ now convert \\ to \/\n+  char* current_pos = strchr(buf,'\\\\');\n+  while (current_pos != nullptr) {\n+    *current_pos = '\/';\n+    current_pos = strchr(current_pos + 1, '\\\\');\n+  }\n+  printf(\"Checking: %s\\n\", buf);\n+  EXPECT_TRUE(LogConfiguration::parse_command_line_arguments(buf));\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_logConfiguration.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"services\/memTracker.hpp\"\n@@ -420,0 +421,6 @@\n+\n+  \/\/ With NMT enabled, this will trigger JDK-8263464. For now disable the test if NMT=on.\n+  if (MemTracker::tracking_level() > NMT_off) {\n+    return;\n+  }\n+\n@@ -421,2 +428,20 @@\n-  const size_t stripe_len = 4 * M;\n-  const int num_stripes = 4;\n+  \/\/ What we do:\n+  \/\/ A) we reserve 6 small segments (stripes) adjacent to each other. We commit\n+  \/\/    them with alternating permissions to prevent the kernel from folding them into\n+  \/\/    a single segment.\n+  \/\/    -stripe-stripe-stripe-stripe-stripe-stripe-\n+  \/\/ B) we release the middle four stripes with a single os::release_memory call. This\n+  \/\/    tests that os::release_memory indeed works across multiple segments created with\n+  \/\/    multiple os::reserve calls.\n+  \/\/    -stripe-___________________________-stripe-\n+  \/\/ C) Into the now vacated address range between the first and the last stripe, we\n+  \/\/    re-reserve a new memory range. We expect this to work as a proof that the address\n+  \/\/    range was really released by the single release call (B).\n+  \/\/\n+  \/\/ Note that this is inherently racy. Between (B) and (C), some other thread may have\n+  \/\/  reserved something into the hole in the meantime. Therefore we keep that range small and\n+  \/\/  entrenched between the first and last stripe, which reduces the chance of some concurrent\n+  \/\/  thread grabbing that memory.\n+\n+  const size_t stripe_len = os::vm_allocation_granularity();\n+  const int num_stripes = 6;\n@@ -430,1 +455,3 @@\n-  \/\/ .. release it...\n+  \/\/ .. release the middle stripes...\n+  address p_middle_stripes = p + stripe_len;\n+  const size_t middle_stripe_len = (num_stripes - 2) * stripe_len;\n@@ -432,3 +459,2 @@\n-    \/\/ On Windows, use UseNUMAInterleaving=1 which makes\n-    \/\/  os::release_memory accept multi-map-ranges.\n-    \/\/  Otherwise we would assert (see below for death test).\n+    \/\/ On Windows, temporarily switch on UseNUMAInterleaving to allow release_memory to release\n+    \/\/  multiple mappings in one go (otherwise we assert, which we test too, see death test below).\n@@ -436,1 +462,1 @@\n-    ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+    ASSERT_TRUE(os::release_memory((char*)p_middle_stripes, middle_stripe_len));\n@@ -440,3 +466,3 @@\n-  \/\/ re-reserve it. This should work unless release failed.\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)p, total_range_len);\n-  ASSERT_EQ(p2, p);\n+  \/\/ ...re-reserve the middle stripes. This should work unless release silently failed.\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, middle_stripe_len);\n+  ASSERT_EQ(p2, p_middle_stripes);\n@@ -445,1 +471,5 @@\n-  ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  \/\/ Clean up. Release all mappings.\n+  {\n+    WINDOWS_ONLY(NUMASwitcher b(true);) \/\/ allow release_memory to release multiple regions\n+    ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  }\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":41,"deletions":11,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/TestDescription.java 8264605 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    vm.hasDTrace \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+hotspot_compiler_arraycopy = \\\n+  compiler\/arraycopy\/stress\n+\n@@ -117,1 +120,2 @@\n-  compiler\/gcbarriers\/PreserveFPRegistersTest.java\n+  compiler\/gcbarriers\/PreserveFPRegistersTest.java \\\n+  :hotspot_compiler_arraycopy\n@@ -134,0 +138,1 @@\n+  -:hotspot_slow_compiler\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8279125\n+ * @summary fatal error: no reachable node should have no use\n+ * @requires vm.flavor == \"server\"\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-DoEscapeAnalysis TestAllocArrayAfterAllocNoUse\n+ *\n+ *\/\n+\n+public class TestAllocArrayAfterAllocNoUse {\n+    private static Object field;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test();\n+        }\n+    }\n+\n+    private static void test() {\n+        try {\n+            final TestAllocArrayAfterAllocNoUse o = new TestAllocArrayAfterAllocNoUse();\n+        } catch (Exception e) {\n+            final int[] array = new int[100];\n+            field = array;\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestAllocArrayAfterAllocNoUse.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8279062\n+ * @summary C2: assert(t->meet(t0) == t) failed: Not monotonic after JDK-8278413\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation TestCCPAllocateArray\n+ *\n+ *\/\n+\n+public class TestCCPAllocateArray {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            try {\n+                test();\n+            } catch (OutOfMemoryError e) {\n+            }\n+            length(42);\n+        }\n+    }\n+\n+    private static int[] test() {\n+        int i = 2;\n+        for (; i < 4; i *= 2);\n+        return new int[length(i)];\n+    }\n+\n+    private static int length(int i) {\n+        return i == 4 ? Integer.MAX_VALUE : 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestCCPAllocateArray.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8279219\n+ * @summary C2 crash when allocating array of size too large\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation TestFailedAllocationBadGraph\n+ *\/\n+\n+import sun.hotspot.WhiteBox;\n+import java.lang.reflect.Method;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+public class TestFailedAllocationBadGraph {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    private static long[] array;\n+    private static int field;\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) throws Exception {\n+        run(\"test1\");\n+        run(\"test2\");\n+    }\n+\n+    private static void run(String method) throws Exception {\n+        Method m = TestFailedAllocationBadGraph.class.getDeclaredMethod(method);\n+        WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(m) || WHITE_BOX.getMethodCompilationLevel(m) != CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+            throw new RuntimeException(\"should still be compiled\");\n+        }\n+    }\n+\n+    private static int test1() {\n+        int length = Integer.MAX_VALUE;\n+        try {\n+            array = new long[length];\n+        } catch (OutOfMemoryError outOfMemoryError) {\n+            barrier = 0x42;\n+            length = field;\n+        }\n+        return length;\n+    }\n+\n+    private static int test2() {\n+        int length = -1;\n+        try {\n+            array = new long[length];\n+        } catch (OutOfMemoryError outOfMemoryError) {\n+            barrier = 0x42;\n+            length = field;\n+        }\n+        return length;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestFailedAllocationBadGraph.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -41,0 +41,13 @@\n+\/*\n+ * @test\n+ * @bug 8282590\n+ * @library \/\n+ *\n+ * @run main\/othervm -ea -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileCommand=dontinline,compiler.arraycopy.TestArrayCopyAsLoadsStores::m*\n+ *                   -XX:TypeProfileLevel=200\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressArrayCopyMacroNode\n+ *                   -XX:-TieredCompilation -XX:+StressReflectiveCode -XX:-ReduceInitialCardMarks\n+ *                   compiler.arraycopy.TestArrayCopyAsLoadsStores\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyAsLoadsStores.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccess.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccessStressGCM.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Random;\n+\n+public abstract class AbstractStressArrayCopy {\n+    \/**\n+     * Max array size to test. This should be reasonably high to test\n+     * massive vectorized copies, plus cases that cross the cache lines and\n+     * (small) page boundaries. But it should also be reasonably low to\n+     * keep the test costs down.\n+     *\n+     * A rough guideline:\n+     *   - AVX-512: 64-byte copies over 32 registers copies roughly 2K per step.\n+     *   - AArch64: small pages can be about 64K large\n+     *\/\n+    static final int MAX_SIZE = 128*1024 + 1;\n+\n+    \/**\n+     * Arrays up to this size would be tested exhaustively: with all combinations\n+     * of source\/destination starts and copy lengths. Exercise restraint when bumping\n+     * this value, as the test costs are proportional to N^3 of this setting.\n+     *\/\n+    static final int EXHAUSTIVE_SIZES = Integer.getInteger(\"exhaustiveSizes\", 192);\n+\n+    \/*\n+     * Larger arrays would fuzzed with this many attempts.\n+     *\/\n+    static final int FUZZ_COUNT = Integer.getInteger(\"fuzzCount\", 300);\n+\n+    public static void throwSeedError(int len, int pos) {\n+        throw new RuntimeException(\"Error after seed: \" +\n+            len + \" elements, at pos \" + pos);\n+    }\n+\n+    public static void throwContentsError(int l, int r, int len, int pos) {\n+        throwError(\"in contents\", l, r, len, pos);\n+    }\n+\n+    public static void throwHeadError(int l, int r, int len, int pos) {\n+        throwError(\"in head\", l, r, len, pos);\n+    }\n+\n+    public static void throwTailError(int l, int r, int len, int pos) {\n+        throwError(\"in tail\", l, r, len, pos);\n+    }\n+\n+    private static void throwError(String phase, int l, int r, int len, int pos) {\n+        throw new RuntimeException(\"Error \" + phase + \": \" +\n+            len + \" elements, \" +\n+            \"[\" + l + \", \" + (l+len) + \") -> \" +\n+            \"[\" + r + \", \" + (r+len) + \"), \" +\n+            \"at pos \" + pos);\n+    }\n+\n+    protected abstract void testWith(int size, int l, int r, int len);\n+\n+    private void checkBounds(int size, int l, int r, int len) {\n+        if (l >= size)      throw new IllegalStateException(\"l is out of bounds\");\n+        if (l + len > size) throw new IllegalStateException(\"l+len is out of bounds\");\n+        if (r >= size)      throw new IllegalStateException(\"r is out of bounds\");\n+        if (r + len > size) throw new IllegalStateException(\"r+len is out of bounds: \" + l + \" \" + r + \" \" + len + \" \" + size);\n+    }\n+\n+    private void checkDisjoint(int size, int l, int r, int len) {\n+        if (l == r)               throw new IllegalStateException(\"Not disjoint: l == r\");\n+        if (l < r && l + len > r) throw new IllegalStateException(\"Not disjoint\");\n+        if (l > r && r + len > l) throw new IllegalStateException(\"Not disjoint\");\n+    }\n+\n+    private void checkConjoint(int size, int l, int r, int len) {\n+        if (l == r) return; \/\/ Definitely conjoint, even with zero len\n+        if (l < r && l + len < r) throw new IllegalStateException(\"Not conjoint\");\n+        if (l > r && r + len < l) throw new IllegalStateException(\"Not conjoint\");\n+    }\n+\n+    public void exhaustiveWith(int size) {\n+        for (int l = 0; l < size; l++) {\n+            for (int r = 0; r < size; r++) {\n+                int maxLen = Math.min(size - l, size - r);\n+                for (int len = 0; len <= maxLen; len++) {\n+                    checkBounds(size, l, r, len);\n+                    testWith(size, l, r, len);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void fuzzWith(Random rand, int size) {\n+        \/\/ Some basic checks first\n+        testWith(size, 0, 1, 1);\n+        testWith(size, 0, 1, size-1);\n+\n+        \/\/ Test disjoint:\n+        for (int c = 0; c < FUZZ_COUNT; c++) {\n+            int l = rand.nextInt(size \/ 2);\n+            int len = rand.nextInt((size - l) \/ 2);\n+            int r = (l + len + 1) + rand.nextInt(size - 2*len - l - 1);\n+\n+            checkBounds(size, l, r, len);\n+            checkDisjoint(size, l, r, len);\n+\n+            testWith(size, l, r, len);\n+            testWith(size, r, l, len);\n+        }\n+\n+        \/\/ Test conjoint:\n+        for (int c = 0; c < FUZZ_COUNT; c++) {\n+            int l = rand.nextInt(size);\n+            int len = rand.nextInt(size - l);\n+            int r = Math.min(l + (len > 0 ? rand.nextInt(len) : 0), size - len);\n+\n+            checkBounds(size, l, r, len);\n+            checkConjoint(size, l, r, len);\n+\n+            testWith(size, l, r, len);\n+            testWith(size, r, l, len);\n+        }\n+    }\n+\n+    public void run(Random rand) {\n+        \/\/ Exhaustive on all small arrays\n+        for (int size = 1; size <= EXHAUSTIVE_SIZES; size++) {\n+            exhaustiveWith(size);\n+        }\n+\n+        \/\/ Fuzz powers of ten\n+        for (int size = 10; size < MAX_SIZE; size *= 10) {\n+            if (size <= EXHAUSTIVE_SIZES) continue;\n+            fuzzWith(rand, size - 1);\n+            fuzzWith(rand, size);\n+            fuzzWith(rand, size + 1);\n+        }\n+\n+        \/\/ Fuzz powers of two\n+        for (int size = 2; size < MAX_SIZE; size *= 2) {\n+            if (size <= EXHAUSTIVE_SIZES) continue;\n+            fuzzWith(rand, size - 1);\n+            fuzzWith(rand, size);\n+            fuzzWith(rand, size + 1);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/AbstractStressArrayCopy.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressBooleanArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final boolean[] orig = new boolean[MAX_SIZE];\n+    private static final boolean[] test = new boolean[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextBoolean();\n+        }\n+        new StressBooleanArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressBooleanArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressByteArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final byte[] orig = new byte[MAX_SIZE];\n+    private static final byte[] test = new byte[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (byte)rand.nextInt();\n+        }\n+        new StressByteArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressByteArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressCharArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final char[] orig = new char[MAX_SIZE];\n+    private static final char[] test = new char[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (char)rand.nextInt();\n+        }\n+        new StressCharArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressCharArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressDoubleArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final double[] orig = new double[MAX_SIZE];\n+    private static final double[] test = new double[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextDouble();\n+        }\n+        new StressDoubleArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressDoubleArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressFloatArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final float[] orig = new float[MAX_SIZE];\n+    private static final float[] test = new float[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextFloat();\n+        }\n+        new StressFloatArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressFloatArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressIntArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final int[] orig = new int[MAX_SIZE];\n+    private static final int[] test = new int[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextInt();\n+        }\n+        new StressIntArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressIntArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressLongArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final long[] orig = new long[MAX_SIZE];\n+    private static final long[] test = new long[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextLong();\n+        }\n+        new StressLongArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressLongArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressObjectArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final Object[] orig = new Object[MAX_SIZE];\n+    private static final Object[] test = new Object[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = new Object();\n+        }\n+        new StressObjectArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressObjectArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressShortArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final short[] orig = new short[MAX_SIZE];\n+    private static final short[] test = new short[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (short)rand.nextInt();\n+        }\n+        new StressShortArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressShortArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build compiler.arraycopy.stress.AbstractStressArrayCopy\n+ *        compiler.arraycopy.stress.StressBooleanArrayCopy\n+ *        compiler.arraycopy.stress.StressByteArrayCopy\n+ *        compiler.arraycopy.stress.StressCharArrayCopy\n+ *        compiler.arraycopy.stress.StressShortArrayCopy\n+ *        compiler.arraycopy.stress.StressIntArrayCopy\n+ *        compiler.arraycopy.stress.StressFloatArrayCopy\n+ *        compiler.arraycopy.stress.StressLongArrayCopy\n+ *        compiler.arraycopy.stress.StressDoubleArrayCopy\n+ *        compiler.arraycopy.stress.StressObjectArrayCopy\n+ *        jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=7200\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.arraycopy.stress.TestStressArrayCopy\n+ *\/\n+public class TestStressArrayCopy {\n+\n+    \/\/ These tests are remarkably memory bandwidth hungry. Running multiple\n+    \/\/ configs in parallel makes sense only when running a single test in\n+    \/\/ isolation, and only on machines with many memory channels. In common\n+    \/\/ testing, or even running all arraycopy stress tests at once, overloading\n+    \/\/ the system with many configs become counter-productive very quickly.\n+    \/\/\n+    \/\/ Default to 1\/4 of the CPUs, and allow users to override.\n+    static final int MAX_PARALLELISM = Integer.getInteger(\"maxParallelism\",\n+        Math.max(1, Runtime.getRuntime().availableProcessors() \/ 4));\n+\n+    private static List<String> mix(List<String> o, String... mix) {\n+        List<String> n = new ArrayList<>(o);\n+        for (String m : mix) {\n+            n.add(m);\n+        }\n+        return n;\n+    }\n+\n+    private static List<List<String>> product(List<List<String>> list, String... mix) {\n+        List<List<String>> newList = new ArrayList<>();\n+        for (List<String> c : list) {\n+            for (String m : mix) {\n+                newList.add(mix(c, m));\n+            }\n+        }\n+        return newList;\n+    }\n+\n+    private static List<List<String>> alternate(List<List<String>> list, String opt) {\n+        return product(list, \"-XX:+\" + opt, \"-XX:-\" + opt);\n+    }\n+\n+    private static boolean containsFuzzy(List<String> list, String sub) {\n+        for (String s : list) {\n+            if (s.contains(sub)) return true;\n+        }\n+        return false;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        List<List<String>> configs = new ArrayList<>();\n+        List<String> cpuFeatures = CPUInfo.getFeatures();\n+\n+        if (Platform.isX64() || Platform.isX86()) {\n+            \/\/ If CPU features were not found, provide a default config.\n+            if (cpuFeatures.isEmpty()) {\n+                configs.add(new ArrayList());\n+            }\n+\n+            \/\/ Otherwise, select the tests that make sense on current platform.\n+            if (containsFuzzy(cpuFeatures, \"avx512\")) {\n+                configs.add(List.of(\"-XX:UseAVX=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx2\")) {\n+                configs.add(List.of(\"-XX:UseAVX=2\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx\")) {\n+                configs.add(List.of(\"-XX:UseAVX=1\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse4\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=4\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse3\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse2\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=2\"));\n+            }\n+\n+            \/\/ x86_64 always has UseSSE >= 2. These lower configurations only\n+            \/\/ make sense for x86_32.\n+            if (Platform.isX86()) {\n+                if (containsFuzzy(cpuFeatures, \"sse\")) {\n+                    configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=1\"));\n+                }\n+\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=0\"));\n+            }\n+\n+            \/\/ Alternate configs with other flags\n+            if (Platform.isX64()) {\n+                configs = alternate(configs, \"UseCompressedOops\");\n+            }\n+            configs = alternate(configs, \"UseUnalignedLoadStores\");\n+\n+        } else if (Platform.isAArch64()) {\n+            \/\/ AArch64.\n+            configs.add(new ArrayList());\n+\n+            \/\/ Alternate configs with other flags\n+            configs = alternate(configs, \"UseCompressedOops\");\n+            configs = alternate(configs, \"UseSIMDForMemoryOps\");\n+        } else {\n+            \/\/ Generic config.\n+            configs.add(new ArrayList());\n+        }\n+\n+        String[] classNames = {\n+            \"compiler.arraycopy.stress.StressBooleanArrayCopy\",\n+            \"compiler.arraycopy.stress.StressByteArrayCopy\",\n+            \"compiler.arraycopy.stress.StressCharArrayCopy\",\n+            \"compiler.arraycopy.stress.StressShortArrayCopy\",\n+            \"compiler.arraycopy.stress.StressIntArrayCopy\",\n+            \"compiler.arraycopy.stress.StressFloatArrayCopy\",\n+            \"compiler.arraycopy.stress.StressLongArrayCopy\",\n+            \"compiler.arraycopy.stress.StressDoubleArrayCopy\",\n+            \"compiler.arraycopy.stress.StressObjectArrayCopy\",\n+        };\n+\n+        ArrayList<Fork> forks = new ArrayList<>();\n+        int jobs = 0;\n+\n+        for (List<String> c : configs) {\n+            for (String className : classNames) {\n+                \/\/ Start a new job\n+                {\n+                    ProcessBuilder pb = ProcessTools.createTestJvm(mix(c, \"-Xmx256m\", className));\n+                    Process p = pb.start();\n+                    OutputAnalyzer oa = new OutputAnalyzer(p);\n+                    forks.add(new Fork(p, oa));\n+                    jobs++;\n+                }\n+\n+                \/\/ Wait for the completion of other jobs\n+                while (jobs >= MAX_PARALLELISM) {\n+                    Fork f = findDone(forks);\n+                    if (f != null) {\n+                        OutputAnalyzer oa = f.oa();\n+                        oa.shouldHaveExitValue(0);\n+                        forks.remove(f);\n+                        jobs--;\n+                    } else {\n+                        \/\/ Nothing is done, wait a little.\n+                        Thread.sleep(200);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Drain the rest\n+        for (Fork f : forks) {\n+            OutputAnalyzer oa = f.oa();\n+            oa.shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    private static Fork findDone(List<Fork> forks) {\n+        for (Fork f : forks) {\n+            if (!f.p().isAlive()) {\n+                return f;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static record Fork(Process p, OutputAnalyzer oa) {};\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressArrayCopy.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8275337\n+ * @run main\/othervm -Xcomp -XX:TieredStopAtLevel=1 compiler.c1.Test8275337\n+ *\/\n+\n+\n+package compiler.c1;\n+\n+public class Test8275337 {\n+    public static final int N = 400;\n+\n+    public static void mainTest() {\n+        int iArr1[] = new int[N];\n+        float fArr1[][] = new float[N][N];\n+\n+        for (int i = 9; i < 171; i++) {\n+            int z;\n+            try {\n+                z = i % i;\n+            } catch (ArithmeticException a_e) {}\n+            for (int j = 1; j < 155; ++j) {\n+                fArr1[j - 1][i] -= 1;\n+                iArr1[i - 1] = 1;\n+            }\n+            for (int j = 4; j < 155; j++) {\n+                for (int k = 1; k < 2; ++k) {\n+                    iArr1[i - 1] += 1;\n+                    fArr1[k - 1][j] -= 2;\n+                }\n+            }\n+        }\n+    }\n+    public static void main(String[] strArr) {\n+\n+        try {\n+            for (int i = 0; i < 10; i++) {\n+                mainTest();\n+            }\n+         } catch (Exception ex) {\n+         }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/Test8275337.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+            \"-XX:CompileThreshold=500\",\n@@ -72,0 +73,1 @@\n+            \"-XX:CompileThreshold=500\",\n@@ -91,0 +93,1 @@\n+            \"-XX:CompileThreshold=500\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestRangeCheckEliminated.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @bug 8280123\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.c2.TestCMoveInfiniteGVN::test\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:StressSeed=43739875\n+ *                   compiler.c2.TestCMoveInfiniteGVN\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.c2.TestCMoveInfiniteGVN::test\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *                   compiler.c2.TestCMoveInfiniteGVN\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestCMoveInfiniteGVN {\n+\n+    static int test(boolean b, int i) {\n+        int iArr[] = new int[2];\n+\n+        double d = Math.max(i, i);\n+        for (int i1 = 1; i1 < 2; i1++) {\n+            if (i1 != 0) {\n+                return (b ? 1 : 0); \/\/ CMoveI\n+            }\n+            for (int i2 = 1; i2 < 2; i2++) {\n+                switch (i2) {\n+                    case 1: d -= Math.max(i1, i2); break;\n+                }\n+                d -= iArr[i1 - 1];\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    static void test() {\n+        test(true, 234);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        test(); \/\/ compilation, then nmethod invalidation during execution\n+        test(); \/\/ trigger crashing recompilation\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCMoveInfiniteGVN.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+ * @requires vm.compiler2.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestJumpTable.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8283451\n+ * @summary C2: assert(_base == Long) failed: Not a Long\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM -XX:+StressGCM -XX:+StressCCP -XX:+StressIGVN\n+ *                   -Xcomp -XX:CompileOnly=TestModDivTopInput -XX:-TieredCompilation -XX:StressSeed=87628618 TestModDivTopInput\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM -XX:+StressGCM -XX:+StressCCP -XX:+StressIGVN\n+ *                   -Xcomp -XX:CompileOnly=TestModDivTopInput -XX:-TieredCompilation TestModDivTopInput\n+ *\/\n+\n+public class TestModDivTopInput {\n+\n+    public static final int N = 400;\n+\n+    public static float fFld=-2.447F;\n+    public long lFld=-189L;\n+\n+    public void mainTest(String[] strArr1) {\n+\n+        int i18, i20=-14, i21, iArr2[]=new int[N];\n+        boolean b2=true;\n+        double d2;\n+        long l;\n+\n+        init(iArr2, -13265);\n+\n+        for (i18 = 13; i18 < 315; ++i18) {\n+            if (b2) continue;\n+            for (d2 = 5; d2 < 83; d2++) {\n+            }\n+            for (i21 = 4; i21 < 83; i21++) {\n+                for (l = 1; 2 > l; l++) {\n+                }\n+                b2 = b2;\n+                lFld %= (i20 | 1);\n+                i20 = (int)fFld;\n+                i20 += (int)d2;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestModDivTopInput _instance = new TestModDivTopInput();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+\n+    static void init(int[] arr, int v) {\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestModDivTopInput.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReplaceEquivPhis.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -30,0 +31,8 @@\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8260585\n+ * @summary AArch64: Wrong code generated for shifting right and accumulating four unsigned short integers.\n+ * @requires vm.compiler2.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestShiftRightAndAccumulate.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8278228\n+ * @summary C2: Improve identical back-to-back if elimination\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestSkeletonPredicates\n+ *\/\n+\n+public class TestSkeletonPredicates {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-UseLoopPredicate\", \"-XX:LoopUnrollLimit=240\", \"-XX:+StressIGVN\", \"-XX:StressSeed=255527877\");\n+        TestFramework.runWithFlags(\"-XX:-UseLoopPredicate\", \"-XX:LoopUnrollLimit=240\", \"-XX:+StressIGVN\");\n+    }\n+\n+    static volatile int barrier;\n+\n+    @ForceInline\n+    static boolean test1_helper(int start, int stop, double[] array1, double[] array2) {\n+        for (int i = start; i < stop; i++) {\n+            if ((i % 2) == 0) {\n+                array1[i] = 42.42;\n+            } else {\n+                barrier = 0x42;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTEDLOOP, \"3\" })\n+    static double[] test1(int stop, double[] array2) {\n+        double[] array1 = null;\n+        array1 = new double[10];\n+        for (int j = 0; j < stop; j++) {\n+            if (test1_helper(8, j, array1, array2)) {\n+                return null;\n+            }\n+        }\n+        return array1;\n+    }\n+\n+    @Run(test = \"test1\")\n+    void test1_runner() {\n+        double[] array2 = new double[10];\n+        double[] array3 = new double[1000];\n+        test1_helper(1, 1000, array3, array3);\n+        test1(11, array3);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestSkeletonPredicates.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282045\n+ * @summary When loop strip mining fails, safepoints are removed from loop anyway\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestStripMiningDropsSafepoint\n+ *\/\n+\n+public class TestStripMiningDropsSafepoint {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopMaxUnroll=1\", \"-XX:-RangeCheckElimination\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopMaxUnroll=1\", \"-XX:-RangeCheckElimination\", \"-XX:-PartialPeelLoop\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    private static void test1(int[] dst, int[] src) {\n+        \/\/ Partial peel is applied. No side effect between exit and\n+        \/\/ safepoint.\n+        for (int i = 0; ; ) {\n+            \/\/ prevent ciTypeFlow from cloning head\n+            synchronized (new Object()) {}\n+            i++;\n+            if (i >= src.length) {\n+                break;\n+            }\n+            dst[i] = src[i];\n+            if (i \/ 2 >= 2000) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    private static void test1_runner() {\n+        int[] array1 = new int[1000];\n+        int[] array2 = new int[10000];\n+        test1(array1, array1);\n+        test1(array2, array2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, failOn = { IRNode.OUTERSTRIPMINEDLOOP })\n+    private static void test2(int[] dst, int[] src) {\n+        \/\/ Partial peel is applied. Some side effect between exit and\n+        \/\/ safepoint.\n+        int v = src[0];\n+        for (int i = 0; ; ) {\n+            synchronized (new Object()) {}\n+            dst[i] = v;\n+            i++;\n+            if (i >= src.length) {\n+                break;\n+            }\n+            v = src[i];\n+            if (i \/ 2 >= 2000) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test2\")\n+    private static void test2_runner() {\n+        int[] array1 = new int[1000];\n+        int[] array2 = new int[10000];\n+        test2(array1, array1);\n+        test2(array2, array2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"false\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    private static void test3(int[] dst, int[] src) {\n+        int v = src[0];\n+        for (int i = 0; ; ) {\n+            synchronized (new Object()) {}\n+            dst[i] = v;\n+            int inc = test3_helper(2);\n+            v = src[i];\n+            i += (inc \/ 2);\n+            if (i >= src.length) {\n+                break;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+            }\n+            \/\/ safepoint on backedge\n+        }\n+    }\n+\n+    private static int test3_helper(int stop) {\n+        int i = 1;\n+        do {\n+            synchronized (new Object()) {}\n+            i *= 2;\n+        } while (i < stop);\n+        return i;\n+    }\n+\n+    @Run(test = \"test3\")\n+    private static void test3_runner() {\n+        int[] array1 = new int[1000];\n+        test3(array1, array1);\n+        test3_helper(10);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestStripMiningDropsSafepoint.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @bug 8283187\n+ * @summary C2: loop candidate for superword not always unrolled fully if superword fails\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.c2.irTests.TestSuperwordFailsUnrolling\n+ *\/\n+\n+public class TestSuperwordFailsUnrolling {\n+    private static int v = 0;\n+    private final static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        Object avx = wb.getVMFlag(\"UseAVX\");\n+        if (avx != null && ((Long)avx) > 2) {\n+            TestFramework.runWithFlags(\"-XX:UseAVX=2\", \"-XX:LoopMaxUnroll=8\");\n+        }\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=8\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"UsePopCountInstruction\", \"true\" }, counts = { IRNode.POPCOUNT_L, \"10\" })\n+    private static int test(long[] array1, long[] array2) {\n+        v = 0;\n+        for (int i = 0; i < array1.length; i++) {\n+            v += Long.bitCount(array1[i]);\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test\")\n+    void test_runner() {\n+        long[] array = new long[1000];\n+        test(array, array);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestSuperwordFailsUnrolling.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n@@ -59,0 +62,8 @@\n+\n+        \/\/ Implementation limitation: CHA is not performed by C1 during inlining through MH linkers.\n+        if (!sun.hotspot.code.Compiler.isC1Enabled()) {\n+            run(AbstractClass.TestMH.class, AbstractClass.class);\n+            run(AbstractInterface.TestMH.class, AbstractInterface.class);\n+        }\n+\n+        System.out.println(\"TEST PASSED\");\n@@ -127,0 +138,13 @@\n+\n+        public static class TestMH extends AbstractClass {\n+            static final MethodHandle TEST_MH = findVirtualHelper(C.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public Object test(C obj) {\n+                try {\n+                    return TEST_MH.invokeExact(obj); \/\/ invokevirtual C.m()\n+                } catch (Throwable e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        }\n@@ -128,0 +152,1 @@\n+\n@@ -196,0 +221,13 @@\n+\n+        public static class TestMH extends AbstractInterface {\n+            static final MethodHandle TEST_MH = findVirtualHelper(C.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public Object test(C obj) {\n+                try {\n+                    return TEST_MH.invokeExact(obj); \/\/ invokevirtual C.m()\n+                } catch (Throwable e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n@@ -59,0 +62,7 @@\n+\n+        \/\/ Implementation limitation: CHA is not performed by C1 during inlining through MH linkers.\n+        if (!sun.hotspot.code.Compiler.isC1Enabled()) {\n+            run(DefaultRoot.TestMH.class, DefaultRoot.class);\n+            run(InheritedDefault.TestMH.class, InheritedDefault.class);\n+        }\n+\n@@ -86,1 +96,1 @@\n-        public Object test(C obj) {\n+        public Object test(C obj) throws Throwable {\n@@ -125,0 +135,9 @@\n+\n+        public static class TestMH extends DefaultRoot {\n+            static final MethodHandle TEST_MH = findVirtualHelper(C.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public Object test(C obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokevirtual C.m()\n+            }\n+        }\n@@ -154,1 +173,1 @@\n-        public Object test(C obj) {\n+        public Object test(C obj) throws Throwable {\n@@ -193,0 +212,9 @@\n+\n+        public static class TestMH extends InheritedDefault {\n+            static final MethodHandle TEST_MH = findVirtualHelper(C.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public Object test(C obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokevirtual C.m()\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.lang.invoke.MethodType;\n@@ -48,0 +49,1 @@\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n@@ -102,2 +104,0 @@\n-        public static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n@@ -120,1 +120,1 @@\n-        public abstract Object test(T i);\n+        public abstract Object test(T i) throws Throwable;\n@@ -136,1 +136,0 @@\n-\n@@ -164,1 +163,17 @@\n-            assertTrue(test(i) != WRONG);\n+            try {\n+                assertTrue(test(i) != WRONG);\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        public static <T> T compute(Callable<T> c) {\n+            try {\n+                return c.call();\n+            } catch (Exception e) {\n+                throw new Error(e);\n+            }\n+        }\n+\n+        public static MethodHandle findVirtualHelper(Class<?> refc, String name, Class<?> returnType, MethodHandles.Lookup lookup) {\n+            return compute(() -> lookup.findVirtual(refc, name, MethodType.methodType(returnType)));\n@@ -171,1 +186,1 @@\n-    static void run(Class<?> test) {\n+    static void run(Class<?> test, Class<?> enclosed) {\n@@ -173,1 +188,1 @@\n-            for (Method m : test.getDeclaredMethods()) {\n+            for (Method m : test.getMethods()) {\n@@ -176,1 +191,1 @@\n-                    ClassLoader cl = new MyClassLoader(test);\n+                    ClassLoader cl = new MyClassLoader(enclosed);\n@@ -186,0 +201,4 @@\n+    static void run(Class<?> test) {\n+        run(test, test);\n+    }\n+\n@@ -306,1 +325,1 @@\n-        } catch(Throwable e) {\n+        } catch (Throwable e) {\n@@ -323,8 +342,0 @@\n-\n-    static <T> T compute(Callable<T> c) {\n-        try {\n-            return c.call();\n-        } catch (Exception e) {\n-            throw new Error(e);\n-        }\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/Utils.java","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8059550\n+ * @bug 8059550 8279356\n@@ -36,2 +36,2 @@\n- *                   -XX:-SegmentedCodeCache\n- *                   compiler.codecache.OverflowCodeCacheTest\n+ *                   -XX:-SegmentedCodeCache -Xmixed\n+ *                   compiler.codecache.OverflowCodeCacheTest CompilationDisabled\n@@ -40,1 +40,4 @@\n- *                   -XX:+SegmentedCodeCache\n+ *                   -XX:+SegmentedCodeCache -Xmixed\n+ *                   compiler.codecache.OverflowCodeCacheTest CompilationDisabled\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:-SegmentedCodeCache -Xmixed\n@@ -52,0 +55,1 @@\n+import java.lang.reflect.Method;\n@@ -55,0 +59,5 @@\n+class Helper {\n+    \/\/ Uncommon signature to prevent sharing and force creation of a new adapter\n+    public void method(float a, float b, float c, Object o) { }\n+}\n+\n@@ -57,0 +66,1 @@\n+    private static boolean COMPILATION_DISABLED = false;\n@@ -59,0 +69,1 @@\n+        COMPILATION_DISABLED = args.length > 0;\n@@ -77,0 +88,2 @@\n+        \/\/ Lock compilation to be able to better control code cache space\n+        WHITE_BOX.lockCompilation();\n@@ -91,1 +104,1 @@\n-               possibly have no free cache for futher work *\/\n+               possibly have no free cache for further work *\/\n@@ -93,0 +106,4 @@\n+\n+            \/\/ Use smallest allocation size to make sure all of the available space\n+            \/\/ is filled up. Don't free these below to put some pressure on the sweeper.\n+            while ((addr = WHITE_BOX.allocateCodeBlob(1, type.id)) != 0) { }\n@@ -94,0 +111,8 @@\n+            try {\n+                \/\/ Trigger creation of a new adapter for Helper::method\n+                \/\/ which will fail because we are out of code cache space.\n+                Helper helper = new Helper();\n+            } catch (VirtualMachineError e) {\n+                \/\/ Expected\n+            }\n+            \/\/ Free code cache space\n@@ -97,0 +122,18 @@\n+\n+            \/\/ Convert some nmethods to zombie and then free them to re-enable compilation\n+            WHITE_BOX.unlockCompilation();\n+            WHITE_BOX.forceNMethodSweep();\n+            WHITE_BOX.forceNMethodSweep();\n+\n+            \/\/ Trigger compilation of Helper::method which will hit an assert because\n+            \/\/ adapter creation failed above due to a lack of code cache space.\n+            Helper helper = new Helper();\n+            for (int i = 0; i < 100_000; i++) {\n+                helper.method(0, 0, 0, null);\n+            }\n+        }\n+        \/\/ Only check this if compilation is disabled, otherwise the sweeper might have\n+        \/\/ freed enough nmethods to allow for re-enabling compilation.\n+        if (COMPILATION_DISABLED) {\n+            Asserts.assertNotEquals(compilationActivityMode, 1 \/* run_compilation*\/,\n+                    \"Compilation must be disabled when CodeCache(CodeHeap) overflows\");\n@@ -98,2 +141,0 @@\n-        Asserts.assertNotEquals(compilationActivityMode, 1 \/* run_compilation*\/,\n-                \"Compilation must be disabled when CodeCache(CodeHeap) overflows\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/OverflowCodeCacheTest.java","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n- * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,*ClearArrayTest.test -XX:+UnlockDiagnosticVMOptions -XX:-IdealizeClearArrayNode compiler.codegen.ClearArrayTest\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,*ClearArrayTest.test\n+ *                   -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:-IdealizeClearArrayNode\n+ *                   compiler.codegen.ClearArrayTest\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/ClearArrayTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275638 8278966\n+ * @summary GraphKit::combine_exception_states fails with \"matching stack sizes\" assert\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileCommand=dontinline,TestLateMHInlineExceptions::m\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline TestLateMHInlineExceptions\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacements -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   TestLateMHInlineExceptions\n+ *\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class TestLateMHInlineExceptions {\n+    public static void main(String[] args) throws Throwable {\n+        TestLateMHInlineExceptions test = new TestLateMHInlineExceptions();\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(test);\n+            try {\n+                test1(null);\n+            } catch (NullPointerException npe) {\n+            }\n+            test2(test);\n+            test2(null);\n+            test3(test);\n+            try {\n+                test3(null);\n+            } catch (NullPointerException npe) {\n+            }\n+            test4(test);\n+            test4(null);\n+            test5(test);\n+            try {\n+                test5(null);\n+            } catch (NullPointerException npe) {\n+            }\n+            test6(test);\n+            try {\n+                test6(null);\n+            } catch (NullPointerException npe) {\n+            }\n+        }\n+    }\n+\n+    void m() {\n+    }\n+\n+    static void nothing(Throwable t) {\n+    }\n+\n+    static final MethodHandle mh;\n+    static final MethodHandle mh_nothing;\n+    static final MethodHandle mh2;\n+    static final MethodHandle mh3;\n+\n+    static {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        try {\n+            mh = lookup.findVirtual(TestLateMHInlineExceptions.class, \"m\", MethodType.methodType(void.class));\n+            mh_nothing = lookup.findStatic(TestLateMHInlineExceptions.class, \"nothing\", MethodType.methodType(void.class, Throwable.class));\n+            mh2 = MethodHandles.tryFinally(mh, mh_nothing);\n+            mh3 = MethodHandles.catchException(mh, Throwable.class, mh_nothing);\n+        } catch (NoSuchMethodException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    private static void test1(TestLateMHInlineExceptions test) throws Throwable {\n+        mh.invokeExact(test);\n+    }\n+\n+    private static void test2(TestLateMHInlineExceptions test) throws Throwable {\n+        try {\n+            mh.invokeExact(test);\n+        } catch (NullPointerException npe) {\n+        }\n+    }\n+\n+    private static void inlined(TestLateMHInlineExceptions test) throws Throwable {\n+        mh.invokeExact(test);\n+    }\n+\n+\n+    private static void test3(TestLateMHInlineExceptions test) throws Throwable {\n+        inlined(test);\n+    }\n+\n+    private static void test4(TestLateMHInlineExceptions test) throws Throwable {\n+        try {\n+            inlined(test);\n+        } catch (NullPointerException npe) {\n+        }\n+    }\n+\n+    private static void test5(TestLateMHInlineExceptions test) throws Throwable {\n+        mh2.invokeExact(test);\n+    }\n+\n+    private static void test6(TestLateMHInlineExceptions test) throws Throwable {\n+        mh3.invokeExact(test);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/TestLateMHInlineExceptions.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8279515\n+ *\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ *\n+ * @run driver compiler.jsr292.ResolvedClassTest\n+ *\/\n+\n+package compiler.jsr292;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+\n+public class ResolvedClassTest {\n+    \/* ======================================================================== *\/\n+    static void testStatic() throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-showversion\",\n+                \"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+                \"-Xbatch\", \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,\" + TestStatic.class.getName() + \"::test\",\n+                TestStatic.class.getName());\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        analyzer.shouldNotContain(\"TestStatic$A::m (1 bytes)   not inlineable\");\n+        analyzer.shouldNotContain(\"TestStatic$A::m (1 bytes)   no static binding\");\n+\n+        analyzer.shouldContain(\"TestStatic$A::m (1 bytes)   inline\");\n+    }\n+\n+    static class TestStatic {\n+        static class A {\n+            static void m() {}\n+        }\n+        static class B extends A {}\n+\n+        \/\/ @DontInline\n+        static void test() {\n+            B.m(); \/\/ invokestatic B \"m\" => A::m\n+        }\n+\n+        public static void main(String[] args) {\n+            for (int i = 0; i < 20_000; i++) {\n+                test();\n+            }\n+        }\n+    }\n+\n+    \/* ======================================================================== *\/\n+    static void testStaticInit() throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-showversion\",\n+                \"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+                \"-Xbatch\", \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,\" + TestStaticInit.class.getName() + \"::test\",\n+                TestStaticInit.class.getName());\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        analyzer.shouldContain(\"TestStaticInit$A::m (1 bytes)   no static binding\");\n+    }\n+\n+    static class TestStaticInit {\n+        static class A {\n+            static {\n+                for (int i = 0; i < 20_000; i++) {\n+                    TestStaticInit.test();\n+                }\n+            }\n+\n+            static void m() {}\n+        }\n+        static class B extends A {}\n+\n+        \/\/ @DontInline\n+        static void test() {\n+            B.m(); \/\/ A::<clinit> => test() => A::m()\n+        }\n+\n+        public static void main(String[] args) {\n+            A.m(); \/\/ trigger initialization of A\n+        }\n+    }\n+\n+    \/* ======================================================================== *\/\n+    static void testIndy() throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-showversion\",\n+                \"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+                \"-Xbatch\", \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,\" + TestIndy.class.getName() + \"::test\",\n+                TestIndy.class.getName());\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        analyzer.shouldNotMatch(\"java\\\\.lang\\\\.invoke\\\\..+::linkToTargetMethod \\\\(9 bytes\\\\)   not inlineable\");\n+\n+        analyzer.shouldMatch(\"java\\\\.lang\\\\.invoke\\\\..+::linkToTargetMethod \\\\(9 bytes\\\\)   force inline by annotation\");\n+        analyzer.shouldContain(\"java\/lang\/invoke\/MethodHandle::invokeBasic (not loaded)   not inlineable\");\n+    }\n+\n+    static class TestIndy {\n+        static String str = \"\";\n+\n+        \/\/ @DontInline\n+        static void test() {\n+            String s1 = \"\" + str; \/\/ indy (linked)\n+\n+            for (int i = 0; i < 200_000; i++) {} \/\/ trigger OSR compilation\n+\n+            String s2 = \"\" + str; \/\/ indy (not linked)\n+        }\n+\n+        public static void main(String[] args) {\n+            test();\n+        }\n+    }\n+\n+    \/* ======================================================================== *\/\n+\n+    public static void main(String[] args) throws IOException {\n+        testStatic();\n+        testStaticInit();\n+        testIndy();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/ResolvedClassTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler\/interpreter;\n+\n+\/* JASM simplified from the following Java pattern:\n+ *\n+ * public class Custom {\n+ *\n+ *  static void test(int v) {\n+ *      int i8 = 1;\n+ *      try {\n+ *          v += 1;\n+ *      } catch (ArithmeticException exc1) {\n+ *      } finally {\n+ *          for (; i8 < 100; i8++) {\n+ *          }\n+ *      }\n+ *  }\n+ *\n+ *\/\n+\n+super public class Custom {\n+\n+    public static Method test:\"(I)V\" stack 2 locals 3 {\n+        iconst_1;\n+        istore_1;\n+    try t0;\n+        iinc          0, 1;\n+    endtry t0;\n+Loop:\n+        iload_1;\n+        bipush        100;\n+        if_icmpge     Lexit;\n+        iinc          1, 1;\n+        goto          Loop;                 \/\/ deoptimize here on backwards branch\n+    catch t0 java\/lang\/ArithmeticException; \/\/ unreachable block\n+        astore_2;\n+Lexit:\n+        return\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/interpreter\/Custom.jasm","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test VerifyStackWithUnreachableBlock\n+ * @bug 8271055\n+ * @compile Custom.jasm VerifyStackWithUnreachableBlock.java\n+ * @summary Using VerifyStack for method that contains unreachable basic blocks\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack compiler.interpreter.VerifyStackWithUnreachableBlock\n+ *\/\n+\n+package compiler.interpreter;\n+\n+public class VerifyStackWithUnreachableBlock {\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10000; i++) {\n+            Custom.test(i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/interpreter\/VerifyStackWithUnreachableBlock.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot:open\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot:+open\n+ *          java.base\/jdk.internal.misc\n@@ -44,0 +45,3 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n+\n@@ -59,1 +63,1 @@\n-        Method decode = translatedExceptionClass.getDeclaredMethod(\"decodeThrowable\", String.class);\n+        Method decode = translatedExceptionClass.getDeclaredMethod(\"decodeThrowable\", byte[].class);\n@@ -67,1 +71,1 @@\n-        String encoding = (String) encode.invoke(null, throwable);\n+        byte[] encoding = (byte[]) encode.invoke(null, throwable);\n@@ -72,0 +76,39 @@\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void encodeDecodeTest2() throws Exception {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        int bufferSize = 512;\n+        long buffer = 0L;\n+        while (true) {\n+            buffer = unsafe.allocateMemory(bufferSize);\n+            try {\n+                Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n+                for (int i = 0; i < 10; i++) {\n+                    throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n+                }\n+\n+                Method encode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"encodeThrowable\", Throwable.class, long.class, int.class);\n+                Method decode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"decodeAndThrowThrowable\", long.class);\n+                encode.setAccessible(true);\n+                decode.setAccessible(true);\n+\n+                int res = (Integer) encode.invoke(null, throwable, buffer, bufferSize);\n+\n+                if (res < 0) {\n+                    bufferSize = -res;\n+                } else {\n+                    try {\n+                        decode.invoke(null, buffer);\n+                        throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n+                    } catch (InvocationTargetException e) {\n+                        Throwable decoded = e.getCause();\n+                        assertThrowableEquals(throwable, decoded);\n+                    }\n+                    return;\n+                }\n+            } finally {\n+                unsafe.freeMemory(buffer);\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestTranslatedException.java","additions":47,"deletions":4,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import static jdk.vm.ci.meta.MetaUtil.internalNameToJava;\n+import static jdk.vm.ci.meta.MetaUtil.toInternalName;\n@@ -166,3 +168,3 @@\n-    public void internalNameTest() {\n-        \/\/ Verify that the last slash in lambda types are not replaced with a '.' as they\n-        \/\/ are part of the type name.\n+    public void lambdaInternalNameTest() {\n+        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from internal name to java\n+        \/\/ name and vice versa.\n@@ -172,4 +174,3 @@\n-        int typeNameLen = TestResolvedJavaType.class.getSimpleName().length();\n-        int index = typeName.indexOf(TestResolvedJavaType.class.getSimpleName());\n-        String suffix = typeName.substring(index + typeNameLen, typeName.length() - 1);\n-        assertEquals(TestResolvedJavaType.class.getName() + suffix, lambdaType.toJavaName());\n+        String javaName = lambda.getClass().getName();\n+        assertEquals(typeName, toInternalName(javaName));\n+        assertEquals(javaName, internalNameToJava(typeName, true, true));\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+    public static final String OUTERSTRIPMINEDLOOP = START + \"OuterStripMinedLoop\\\\b\" + MID + END;\n@@ -135,0 +136,2 @@\n+    public static final String SAFEPOINT = START + \"SafePoint\" + MID + END;\n+    public static final String POPCOUNT_L = START + \"PopCountL\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8277906\n+ * @summary Incorrect type for IV phi of long counted loops after CCP\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileCommand=compileonly,TestIVPhiTypeIncorrectAfterCCP::test -XX:-BackgroundCompilation TestIVPhiTypeIncorrectAfterCCP\n+ *\n+ *\/\n+\n+public class TestIVPhiTypeIncorrectAfterCCP {\n+\n+    static int test() {\n+        int array[] = new int[50];\n+\n+        float f = 0;\n+        for (int i = 3; i < 49; i++) {\n+            for (long l = 1; l < i; l++) {\n+                array[(int)l] = i;\n+                f += l;\n+            }\n+        }\n+        int sum = 0;\n+        for (int i = 0; i < array.length; i++) {\n+            sum += array[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static void main(String[] args) {\n+        long expected = test();\n+        for (int i = 0; i < 10_000; i++) {\n+            int res = test();\n+            if (res != expected) {\n+                throw new RuntimeException(\"Unexpected result: \" + res + \" != \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestIVPhiTypeIncorrectAfterCCP.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8283408\n+ * @summary Fill a byte array with Java Unsafe API\n+ * @run main\/othervm -XX:+OptimizeFill compiler.loopopts.FillArrayWithUnsafe\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import java.lang.reflect.Field;\n+\n+import sun.misc.Unsafe;\n+\n+public class FillArrayWithUnsafe {\n+\n+    private static Unsafe unsafe;\n+\n+    public static void main(String[] args) throws Exception {\n+        Class klass = Unsafe.class;\n+        Field field = klass.getDeclaredField(\"theUnsafe\");\n+        field.setAccessible(true);\n+        unsafe = (Unsafe) field.get(null);\n+\n+        byte[] buffer;\n+        \/\/ Make sure method newByteArray is compiled by C2\n+        for (int i = 0; i < 50000; i++) {\n+            buffer = newByteArray(100, (byte) 0x80);\n+        }\n+    }\n+\n+    public static byte[] newByteArray(int size, byte val) {\n+        byte[] arr = new byte[size];\n+        int offset = unsafe.arrayBaseOffset(byte[].class);\n+        for (int i = offset; i < offset + size; i++) {\n+             unsafe.putByte(arr, i, val);\n+        }\n+        return arr;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/FillArrayWithUnsafe.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8280600\n+ * @summary C2: assert(!had_error) failed: bad dominance\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestCastIIMakesMainLoopPhiDead TestCastIIMakesMainLoopPhiDead\n+ *\/\n+\n+public class TestCastIIMakesMainLoopPhiDead {\n+    int iArr[] = new int[0];\n+\n+    void test() {\n+        int x = 8;\n+        try {\n+            for (int i = 0; i < 8; i++) {\n+                iArr[1] = 9;\n+                for (int j = -400; 1 > j; j++) {\n+                    iArr[j] = 4;\n+                    x -= 2;\n+                }\n+            }\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+        }\n+    }\n+    public static void main(String[] k) {\n+        TestCastIIMakesMainLoopPhiDead t = new TestCastIIMakesMainLoopPhiDead();\n+        for (int i = 0; i < 3; i++) {\n+            t.test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCastIIMakesMainLoopPhiDead.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.compiler2.enabled\n+ * @bug 8279837\n+ * @summary Tests infinite loop with region head in iteration split.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.TestIterationSplitWithRegionHead::test\n+ *      -XX:CompileCommand=dontinline,compiler.loopopts.TestIterationSplitWithRegionHead::*\n+ *      compiler.loopopts.TestIterationSplitWithRegionHead\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestIterationSplitWithRegionHead {\n+\n+    static boolean flagFalse = false;\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+\n+    public static void test() {\n+        \/\/ 1) The loop tree is built. We find that nested loop N2 is an infinite loop and add a NeverBranch\n+        \/\/ to the inner loop to make it reachable. But the current loop tree does not have N2, yet. The\n+        \/\/ resulting loop tree is:\n+        \/\/\n+        \/\/   Loop: N0\/N0  has_call has_sfpt\n+        \/\/     Loop: N77\/N121  has_call \/\/ N1 outer\n+        \/\/       Loop: N77\/N111  has_call sfpts={ 111 97 } \/\/ N1 inner\n+        \/\/\n+        \/\/ 2) beautify_loops() finds that the outer loop head of N1 is shared and thus adds a new region\n+        \/\/ in merge_many_backedges(). As a result, the loop tree is built again. This time, the NeverBranch\n+        \/\/ in the inner loop of N2 allows that a loop tree can be built for it:\n+        \/\/\n+        \/\/   Loop: N0\/N0  has_call has_sfpt\n+        \/\/     Loop: N216\/N213  limit_check profile_predicated predicated has_call sfpts={ 111 97 } \/\/ N1 shared loop head\n+        \/\/     Loop: N196\/N201  sfpts={ 201 } \/\/ N2 inner loop now discovered with the new NeverBranch\n+        \/\/\n+        \/\/ However, a LoopNode is only added by beautify_loops() which won't be called until the next iteration of loop opts.\n+        \/\/ This means that we have a Region node (N196) as head in the loop tree which cannot be handled by iteration_split_impl()\n+        \/\/ resulting in an assertion failure.\n+\n+        \/\/ Nested loop N1\n+        while (flagFalse) {\n+            while (dontInlineFalse()) {\n+            }\n+        }\n+        dontInlineFalse();\n+\n+        \/\/ Nested loop N2\n+        while (flagFalse) {\n+            while (true) ;  \/\/ Detected as infinite inner loop by C2 -> NeverBranch added\n+        }\n+    }\n+\n+    public static boolean dontInlineFalse() {\n+        return false;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestIterationSplitWithRegionHead.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275854\n+ * @summary Crashes in PhaseIdealLoop::transform_long_counted_loop\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,TestLoopEndNodeEliminate::lMeth TestLoopEndNodeEliminate\n+ *\n+ *\/\n+\n+public class TestLoopEndNodeEliminate {\n+     public volatile boolean bFld=true;\n+     public volatile byte byFld=0;\n+     public volatile short sArrFld[]=new short[N];\n+     public int iArrFld[]=new int[N];\n+     public boolean bArrFld[]=new boolean[N];\n+\n+     public static int iFld=10;\n+     public static final int N = 400;\n+     public static long instanceCount=0L;\n+     public static long lMeth_check_sum = 0;\n+\n+     public long lMeth() {\n+         long l1=-33582180L;\n+         int i14=-5, i15=-14, i16=0, i17=25699, i18=97, i19=-3, i20=0, i21=0, i22=42, i23=0, i24=25699, i25=97;\n+\n+         for (l1 = 286; l1 > 16; l1 -= 3) {\n+             for (i15 = 17; i15 > l1; --i15) {\n+                 switch (((iArrFld[i15] >>> 1) % 7) + 101) {\n+                 case 101:\n+                 case 102:\n+                 case 103:\n+                 case 104:\n+                     for (i17 = (int)(l1); i17 < 1; i17++) {\n+                         bArrFld[i17] = bFld;\n+                     }\n+                     break;\n+                 case 105:\n+                 case 106:\n+                 case 107:\n+                 }\n+             }\n+             for (i19 = 1; i19 < 270; ++i19) {\n+                 TestLoopEndNodeEliminate.iFld += byFld;\n+                 i21 = 1;\n+                 while (++i21 < 2) {\n+                     bFld = true;\n+                 }\n+                 for (i22 = 1; 2 > i22; ++i22) {\n+                     bFld = true;\n+                 }\n+                 for (i24 = 1; 2 > i24; ++i24) {\n+                     bFld = true;\n+                 }\n+                 bArrFld[(int)(l1) % N] = bFld;\n+                 sArrFld[i19 - 1] ^= (short)(++TestLoopEndNodeEliminate.instanceCount);\n+             }\n+         }\n+         long meth_res = l1 + i14 + i15 + i16 + i17 + i18 + i19 + i20 + i21 + i22 + i23 + i24 + i25;\n+         lMeth_check_sum += meth_res;\n+         return (long)meth_res;\n+     }\n+\n+     public static void main(String[] strArr) {\n+        TestLoopEndNodeEliminate _instance = new TestLoopEndNodeEliminate();\n+        for (int i = 0; i < 10000; i++ ) {\n+            _instance.lMeth();\n+        }\n+     }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopEndNodeEliminate.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8280799\n+ * @summary C2: assert(false) failed: cyclic dependency prevents range check elimination\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseCountedLoopSafepoints TestPredicateInputBelowLoopPredicate\n+ *\/\n+\n+public class TestPredicateInputBelowLoopPredicate {\n+    private static final Object object = new Object();\n+    private static int fieldStop = 100;\n+    private static int[] array = new int[200];\n+    private static int[] array2 = new int[200];\n+    private static int fieldStart = 0;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(true);\n+            test(false);\n+        }\n+    }\n+\n+    private static void test(boolean flag) {\n+        if (array == null) {\n+        }\n+        int start = fieldStart;\n+        int i = start;\n+        for(;;) {\n+            int j;\n+            for (j = -10; j < 0; j++) {\n+            }\n+            int stop = fieldStop;\n+             \/\/ bound check becomes candidate for predication once\n+             \/\/ loop above is optimized out\n+            array[stop - i + j] = 0;\n+\n+            \/\/ A bunch of stuff to grow loop body size and prevent peeling:\n+            array2[0] = 0;\n+            array2[1] = 0;\n+            array2[2] = 0;\n+            array2[3] = 0;\n+            array2[4] = 0;\n+            array2[5] = 0;\n+            array2[6] = 0;\n+            array2[7] = 0;\n+            array2[8] = 0;\n+            array2[9] = 0;\n+            array2[10] = 0;\n+            array2[11] = 0;\n+            array2[12] = 0;\n+            array2[13] = 0;\n+            array2[14] = 0;\n+            array2[15] = 0;\n+            array2[16] = 0;\n+            array2[17] = 0;\n+            array2[18] = 0;\n+            array2[19] = 0;\n+            array2[20] = 0;\n+            array2[21] = 0;\n+            array2[22] = 0;\n+            array2[23] = 0;\n+            array2[24] = 0;\n+            array2[25] = 0;\n+            array2[26] = 0;\n+            array2[27] = 0;\n+            array2[28] = 0;\n+            array2[29] = 0;\n+            array2[30] = 0;\n+            array2[31] = 0;\n+            array2[32] = 0;\n+            array2[33] = 0;\n+            array2[34] = 0;\n+            array2[35] = 0;\n+            array2[36] = 0;\n+            array2[37] = 0;\n+            array2[38] = 0;\n+            array2[39] = 0;\n+            array2[40] = 0;\n+            array2[41] = 0;\n+            array2[42] = 0;\n+            array2[43] = 0;\n+            array2[44] = 0;\n+            array2[45] = 0;\n+            array2[46] = 0;\n+            array2[47] = 0;\n+            array2[48] = 0;\n+            array2[49] = 0;\n+            array2[50] = 0;\n+            array2[51] = 0;\n+            array2[52] = 0;\n+            array2[53] = 0;\n+            array2[54] = 0;\n+            array2[55] = 0;\n+            array2[56] = 0;\n+            array2[57] = 0;\n+            array2[58] = 0;\n+            array2[59] = 0;\n+            array2[60] = 0;\n+            array2[61] = 0;\n+            array2[62] = 0;\n+            array2[63] = 0;\n+            array2[64] = 0;\n+            array2[65] = 0;\n+            array2[66] = 0;\n+            array2[67] = 0;\n+            array2[68] = 0;\n+            array2[69] = 0;\n+            array2[70] = 0;\n+            array2[71] = 0;\n+            array2[72] = 0;\n+            array2[73] = 0;\n+            array2[74] = 0;\n+            array2[75] = 0;\n+            array2[76] = 0;\n+            array2[77] = 0;\n+            array2[78] = 0;\n+            array2[79] = 0;\n+            array2[80] = 0;\n+            array2[81] = 0;\n+            array2[82] = 0;\n+            array2[83] = 0;\n+            array2[84] = 0;\n+            array2[85] = 0;\n+            array2[86] = 0;\n+            array2[87] = 0;\n+            array2[88] = 0;\n+            array2[89] = 0;\n+            array2[90] = 0;\n+            array2[91] = 0;\n+            array2[92] = 0;\n+            array2[93] = 0;\n+            array2[94] = 0;\n+            array2[95] = 0;\n+            array2[96] = 0;\n+            array2[97] = 0;\n+            array2[98] = 0;\n+            array2[99] = 0;\n+\n+            array2[100] = 0;\n+            array2[101] = 0;\n+            array2[102] = 0;\n+            array2[103] = 0;\n+            array2[104] = 0;\n+            array2[105] = 0;\n+            array2[106] = 0;\n+            array2[107] = 0;\n+            array2[108] = 0;\n+            array2[109] = 0;\n+            array2[110] = 0;\n+            array2[111] = 0;\n+            array2[112] = 0;\n+            array2[113] = 0;\n+            array2[114] = 0;\n+            array2[115] = 0;\n+            array2[116] = 0;\n+            array2[117] = 0;\n+            array2[118] = 0;\n+            array2[119] = 0;\n+            array2[120] = 0;\n+            array2[121] = 0;\n+            array2[122] = 0;\n+            array2[123] = 0;\n+            array2[124] = 0;\n+            array2[125] = 0;\n+            array2[126] = 0;\n+            array2[127] = 0;\n+            array2[128] = 0;\n+            array2[129] = 0;\n+            array2[130] = 0;\n+            array2[131] = 0;\n+            array2[132] = 0;\n+            array2[133] = 0;\n+            array2[134] = 0;\n+            array2[135] = 0;\n+            array2[136] = 0;\n+            array2[137] = 0;\n+            array2[138] = 0;\n+            array2[139] = 0;\n+            array2[140] = 0;\n+            array2[141] = 0;\n+            array2[142] = 0;\n+            array2[143] = 0;\n+            array2[144] = 0;\n+            array2[145] = 0;\n+            array2[146] = 0;\n+            array2[147] = 0;\n+            array2[148] = 0;\n+            array2[149] = 0;\n+            array2[150] = 0;\n+            array2[151] = 0;\n+            array2[152] = 0;\n+            array2[153] = 0;\n+            array2[154] = 0;\n+            array2[155] = 0;\n+            array2[156] = 0;\n+            array2[157] = 0;\n+            array2[158] = 0;\n+            array2[159] = 0;\n+            array2[160] = 0;\n+            array2[161] = 0;\n+            array2[162] = 0;\n+            array2[163] = 0;\n+            array2[164] = 0;\n+            array2[165] = 0;\n+            array2[166] = 0;\n+            array2[167] = 0;\n+            array2[168] = 0;\n+            array2[169] = 0;\n+            array2[170] = 0;\n+            array2[171] = 0;\n+            array2[172] = 0;\n+            array2[173] = 0;\n+            array2[174] = 0;\n+            array2[175] = 0;\n+            array2[176] = 0;\n+            array2[177] = 0;\n+            array2[178] = 0;\n+            array2[179] = 0;\n+            array2[180] = 0;\n+            array2[181] = 0;\n+            array2[182] = 0;\n+            array2[183] = 0;\n+            array2[184] = 0;\n+            array2[185] = 0;\n+            array2[186] = 0;\n+            array2[187] = 0;\n+            array2[188] = 0;\n+            array2[189] = 0;\n+            array2[190] = 0;\n+            array2[191] = 0;\n+            array2[192] = 0;\n+            array2[193] = 0;\n+            array2[194] = 0;\n+            array2[195] = 0;\n+            array2[196] = 0;\n+            array2[197] = 0;\n+            array2[198] = 0;\n+            array2[199] = 0;\n+            i++;\n+\n+            if (i == stop) { \/\/ requires a loop limit predicate\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPredicateInputBelowLoopPredicate.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8022585\n+ * @bug 8022585 8277055\n@@ -30,1 +30,4 @@\n- *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining\n+ *                   compiler.print.PrintInlining\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintIntrinsics\n+ *                   compiler.print.PrintInlining\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/PrintInlining.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=with-dtrace\n@@ -27,0 +27,1 @@\n+ * @requires vm.hasDTrace\n@@ -29,1 +30,18 @@\n- * @run main\/othervm -XX:CompileCommand=compileonly,Test8168712.* -XX:CompileCommand=compileonly,*Object.* -XX:+DTraceMethodProbes -XX:-UseOnStackReplacement -XX:+DeoptimizeRandom compiler.runtime.Test8168712\n+ * @run main\/othervm -XX:CompileCommand=compileonly,Test8168712.*\n+ *                   -XX:CompileCommand=compileonly,*Object.*\n+ *                   -XX:+DTraceMethodProbes\n+ *                   -XX:-UseOnStackReplacement\n+ *                   -XX:+DeoptimizeRandom\n+ *                   compiler.runtime.Test8168712\n+ *\/\n+\n+\/**\n+ * @test id=without-dtrace\n+ * @requires vm.debug\n+ * @bug 8168712\n+ *\n+ * @run main\/othervm -XX:CompileCommand=compileonly,Test8168712.*\n+ *                   -XX:CompileCommand=compileonly,*Object.*\n+ *                   -XX:-UseOnStackReplacement\n+ *                   -XX:+DeoptimizeRandom\n+ *                   compiler.runtime.Test8168712\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/Test8168712.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8279822\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *\n+ * @run main compiler.runtime.TestConstantsInError\n+ *\/\n+package compiler.runtime;\n+\n+import jdk.internal.org.objectweb.asm.*;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static jdk.internal.org.objectweb.asm.ClassWriter.*;\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+interface OutputProcessor {\n+    default void process(OutputAnalyzer output, boolean isC1) {}\n+}\n+\n+public abstract class TestConstantsInError implements OutputProcessor {\n+    static final String TEST_PREFIX = class2desc(TestConstantsInError.class) + \"$Test\";\n+\n+    public interface Test extends Runnable {}\n+\n+\n+    interface Generator {\n+        void generate(MethodVisitor mv);\n+    }\n+\n+    static String class2desc(Class<?> cls) {\n+        return cls.getName().replace('.', '\/');\n+    }\n+\n+    public static final String PATH = System.getProperty(\"test.classes\", \".\") + java.io.File.separator;\n+\n+    static byte[] generateClassFile(String suffix, Generator g) throws IOException {\n+        var cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+        String name = TEST_PREFIX + \"_\" + suffix;\n+        cw.visit(V17, ACC_PUBLIC | ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n+\n+        {\n+            var mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"test\", \"()V\", null, null);\n+            mv.visitCode();\n+            g.generate(mv);\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+        }\n+        byte[] classFile = cw.toByteArray();\n+\n+        try (FileOutputStream fos = new FileOutputStream(PATH + name + \".class\")) {\n+            fos.write(classFile);\n+        }\n+\n+        return classFile;\n+    }\n+\n+    static Test generate(String suffix, Class<? extends LinkageError> expectedError, Generator g) {\n+        try {\n+            byte[] classFile = generateClassFile(suffix, g);\n+            MethodHandles.Lookup testLookup = MethodHandles.lookup().defineHiddenClass(classFile, true);\n+            MethodHandle testMH = testLookup.findStatic(testLookup.lookupClass(), \"test\", MethodType.methodType(void.class));\n+\n+            testMH = MethodHandles.filterReturnValue(testMH,\n+                    MethodHandles.insertArguments(\n+                            MethodHandles.throwException(void.class, AssertionError.class),\n+                            0, new AssertionError(\"no exception thrown\")));\n+\n+            \/\/ Install empty handler for linkage exceptions.\n+            testMH = MethodHandles.catchException(testMH, expectedError,\n+                     MethodHandles.empty(MethodType.methodType(void.class, expectedError)));\n+\n+            return MethodHandleProxies.asInterfaceInstance(Test.class, testMH);\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    static void run(String name, Class<? extends LinkageError> expectedError, Generator g) {\n+        Test test = generate(name, expectedError, g);\n+        for (int i = 0; i < 1000; i++) {\n+            test.run();\n+        }\n+    }\n+\n+    static class TestConstantClass extends TestConstantsInError {\n+        public static void main(String[] args) {\n+            run(\"C1\", NoClassDefFoundError.class, mv -> mv.visitLdcInsn(Type.getType(\"LUnknownClass;\")));                \/\/ non-existent class\n+            run(\"C2\",   IllegalAccessError.class, mv -> mv.visitLdcInsn(Type.getType(\"Ljava\/lang\/invoke\/LambdaForm;\"))); \/\/ inaccessible\n+\n+            \/\/ class loader constraints?\n+        }\n+\n+        public void process(OutputAnalyzer results, boolean isC1) {\n+            results.shouldMatch(\"Test_C1\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_C2\/.*::test \\\\(3 bytes\\\\)$\");\n+\n+            if (isC1 && Platform.isAArch64()) { \/\/ no code patching\n+                results.shouldMatch(\"Test_C1\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_C2\/.*::test \\\\(3 bytes\\\\)   made not entrant\");\n+            } else {\n+                results.shouldNotContain(\"made not entrant\");\n+            }\n+        }\n+\n+        public void processC2(OutputAnalyzer results) {\n+            results.shouldNotContain(\"made not entrant\");\n+        }\n+    }\n+\n+    static class TestConstantMethodHandle extends TestConstantsInError {\n+        public static void main(String[] args) {\n+            \/\/ Non-existent holder class\n+            run(\"MH1\", NoClassDefFoundError.class,\n+                mv -> mv.visitLdcInsn(new Handle(H_INVOKESTATIC, \"UnknownClass\", \"ignored\", \"()V\", false)));\n+\n+            \/\/ Inaccessible holder class\n+            run(\"MH2\", IllegalAccessError.class,\n+                    mv -> mv.visitLdcInsn(new Handle(H_INVOKESTATIC, \"java\/lang\/invoke\/LambdaForm\", \"ignored\", \"()V\", false)));\n+\n+            \/\/ Method vs InterfaceMethod mismatch\n+            run(\"MH3\", IncompatibleClassChangeError.class,\n+                mv -> mv.visitLdcInsn(new Handle(H_INVOKESTATIC, \"java\/lang\/Object\", \"ignored\", \"()V\", true)));\n+\n+            \/\/ Non-existent method\n+            run(\"MH4\", NoSuchMethodError.class,\n+                mv -> mv.visitLdcInsn(new Handle(H_INVOKESTATIC, \"java\/lang\/Object\", \"cast\", \"()V\", false)));\n+        }\n+\n+        public void process(OutputAnalyzer results, boolean isC1) {\n+            results.shouldMatch(\"Test_MH1\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_MH2\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_MH3\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_MH4\/.*::test \\\\(3 bytes\\\\)$\");\n+\n+            if (isC1 && Platform.isAArch64()) { \/\/ no code patching\n+                results.shouldMatch(\"Test_MH1\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_MH2\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_MH3\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_MH4\/.*::test \\\\(3 bytes\\\\)   made not entrant\");\n+            } else {\n+                results.shouldNotContain(\"made not entrant\");\n+            }\n+        }\n+    }\n+\n+    static class TestConstantMethodType extends TestConstantsInError {\n+        public static void main(String[] args) {\n+            run(\"MT1\", NoClassDefFoundError.class,\n+                mv -> mv.visitLdcInsn(Type.getMethodType(\"(LUnknownClass;)V\")));\n+            run(\"MT2\", NoClassDefFoundError.class,\n+                mv -> mv.visitLdcInsn(Type.getMethodType(\"()LUnknownClass;\")));\n+        }\n+\n+        public void process(OutputAnalyzer results, boolean isC1) {\n+            results.shouldMatch(\"Test_MT1\/.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_MT2\/.*::test \\\\(3 bytes\\\\)$\");\n+\n+            if (isC1 && Platform.isAArch64()) { \/\/ no code patching\n+                results.shouldMatch(\"Test_MT1\/.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_MT2\/.*::test \\\\(3 bytes\\\\)   made not entrant\");\n+            } else {\n+                results.shouldNotContain(\"made not entrant\");\n+            }\n+        }\n+    }\n+\n+    static class TestConstantDynamic extends TestConstantsInError {\n+        static int bsm1() throws Exception {\n+            throw new AssertionError(\"should not be invoked\");\n+        }\n+\n+        static int bsm2(MethodHandles.Lookup lookup, String name, Class c) throws Exception {\n+            throw new Exception(\"expected\");\n+        }\n+\n+        static final Handle BSM1 = new Handle(H_INVOKESTATIC, class2desc(TestConstantDynamic.class), \"bsm1\", \"()I\", false);\n+        static final Handle BSM2 = new Handle(H_INVOKESTATIC, class2desc(TestConstantDynamic.class), \"bsm2\",\n+                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)I\",\n+                false);\n+\n+        public static void main(String[] args) {\n+            run(\"CD1\", NoClassDefFoundError.class,\n+                    mv -> {\n+                        Handle bsm = new Handle(H_INVOKESTATIC, \"UnknownClass\", \"unknown\", \"()LUnknownClass;\", false);\n+                        mv.visitLdcInsn(new ConstantDynamic(\"tmp\", \"LUnknownClass;\", bsm));\n+                    });\n+            run(\"CD2\", NoSuchMethodError.class,\n+                    mv -> {\n+                        Handle bsm = new Handle(H_INVOKESTATIC, class2desc(TestConstantDynamic.class), \"unknown\", \"()I\", false);\n+                        mv.visitLdcInsn(new ConstantDynamic(\"tmp\", \"LUnknownClass;\", bsm));\n+                    });\n+            run(\"CD3\", BootstrapMethodError.class, mv -> mv.visitLdcInsn(new ConstantDynamic(\"tmp\", \"I\", BSM1)));\n+            run(\"CD4\", BootstrapMethodError.class, mv -> mv.visitLdcInsn(new ConstantDynamic(\"tmp\", \"I\", BSM2)));\n+        }\n+\n+        public void process(OutputAnalyzer results, boolean isC1) {\n+            if (isC1) {\n+                results.shouldMatch(\"Test_CD1.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n+                       .shouldMatch(\"Test_CD2.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n+                       .shouldMatch(\"Test_CD3.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n+                       .shouldMatch(\"Test_CD4.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\");\n+            } else {\n+                results.shouldMatch(\"Test_CD1.*::test \\\\(3 bytes\\\\)$\")\n+                       .shouldMatch(\"Test_CD2.*::test \\\\(3 bytes\\\\)$\")\n+                       .shouldMatch(\"Test_CD3.*::test \\\\(3 bytes\\\\)$\")\n+                       .shouldMatch(\"Test_CD4.*::test \\\\(3 bytes\\\\)$\");\n+            }\n+        }\n+    }\n+\n+    static void run(TestConstantsInError test) throws Exception {\n+        List<String> commonArgs = List.of(\n+                \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+                \"-Xbatch\", \"-XX:CompileThreshold=100\",\n+                \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,*::test\",\n+                \"-XX:+PrintCompilation\",\n+                \"-XX:CompileCommand=print,*::test\",\n+                \"-Dtest.classes=\" + System.getProperty(\"test.classes\", \".\"),\n+                \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                test.getClass().getName());\n+\n+        ArrayList<String> c1Args = new ArrayList<>();\n+        c1Args.addAll(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\", \"-XX:+TracePatching\"));\n+        c1Args.addAll(commonArgs);\n+\n+        OutputAnalyzer outputC1 = ProcessTools.executeTestJvm(c1Args)\n+                .shouldHaveExitValue(0);\n+\n+        test.process(outputC1, true);\n+\n+        ArrayList<String> c2Args = new ArrayList<>();\n+        c2Args.add(\"-XX:-TieredCompilation\");\n+        c2Args.addAll(commonArgs);\n+\n+        OutputAnalyzer outputC2 = ProcessTools.executeTestJvm(c2Args)\n+                .shouldHaveExitValue(0);\n+\n+        test.process(outputC2, false);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        run(new TestConstantClass());\n+        run(new TestConstantMethodType());\n+        run(new TestConstantMethodHandle());\n+        run(new TestConstantDynamic());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/TestConstantsInError.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8278948\n+ * @summary Intermediate integer promotion vector length encoding is calculated incorrectly on x86\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation -XX:CompileThreshold=100 -XX:UseAVX=1\n+ *                   compiler.vectorapi.Test8278948\n+ *\/\n+public class Test8278948 {\n+    static final int INVOCATIONS = 10000;\n+\n+    static final Random random = Utils.getRandomInstance();\n+    static final byte[] BYTES = new byte[8];\n+    static final short[] SHORTS = new short[4];\n+    static final double[] DOUBLES = new double[4];\n+\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            for (int j = 0; j < DOUBLES.length; j++) {\n+                BYTES[j] = (byte)random.nextInt();\n+            }\n+            bytesToDoubles();\n+            for (int j = 0; j < DOUBLES.length; j++) {\n+                Asserts.assertEquals((double)BYTES[j], DOUBLES[j]);\n+            }\n+\n+            for (int j = 0; j < DOUBLES.length; j++) {\n+                SHORTS[j] = (short)random.nextInt();\n+            }\n+            shortsToDoubles();\n+            for (int j = 0; j < DOUBLES.length; j++) {\n+                Asserts.assertEquals((double)SHORTS[j], DOUBLES[j]);\n+            }\n+        }\n+    }\n+\n+    static void bytesToDoubles() {\n+        ((DoubleVector)ByteVector.fromArray(ByteVector.SPECIES_64, BYTES, 0)\n+                .castShape(DoubleVector.SPECIES_256, 0))\n+                .intoArray(DOUBLES, 0);\n+    }\n+\n+    static void shortsToDoubles() {\n+        ((DoubleVector)ShortVector.fromArray(ShortVector.SPECIES_64, SHORTS, 0)\n+                .castShape(DoubleVector.SPECIES_256, 0))\n+                .intoArray(DOUBLES, 0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/Test8278948.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+            testPrintContainerInfoActiveProcessorCount();\n@@ -95,0 +96,9 @@\n+    private static void testPrintContainerInfoActiveProcessorCount() throws Exception {\n+        Common.logNewTestCase(\"Test print_container_info()\");\n+\n+        DockerRunOptions opts = Common.newOpts(imageName, \"PrintContainerInfo\").addJavaOpts(\"-XX:ActiveProcessorCount=2\");\n+        Common.addWhiteBoxOpts(opts);\n+\n+        OutputAnalyzer out = Common.run(opts);\n+        out.shouldContain(\"but overridden by -XX:ActiveProcessorCount 2\");\n+    }\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @test TestSystemGCSerial\n+ * @test id=Serial\n@@ -31,0 +31,1 @@\n+ * @run main\/othervm -XX:+UseSerialGC -XX:+UseLargePages gc.TestSystemGC\n@@ -34,1 +35,1 @@\n- * @test TestSystemGCParallel\n+ * @test id=Parallel\n@@ -38,0 +39,1 @@\n+ * @run main\/othervm -XX:+UseParallelGC -XX:+UseLargePages gc.TestSystemGC\n@@ -41,1 +43,1 @@\n- * @test TestSystemGCG1\n+ * @test id=G1\n@@ -46,2 +48,2 @@\n- * @run main\/othervm -XX:+UseLargePages gc.TestSystemGC\n-  *\/\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UseLargePages gc.TestSystemGC\n+ *\/\n@@ -50,1 +52,1 @@\n- * @test TestSystemGCShenandoah\n+ * @test id=Shenandoah\n@@ -53,2 +55,12 @@\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC gc.TestSystemGC\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:+ExplicitGCInvokesConcurrent gc.TestSystemGC\n+ * @run main\/othervm -XX:+UseShenandoahGC gc.TestSystemGC\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+ExplicitGCInvokesConcurrent gc.TestSystemGC\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages gc.TestSystemGC\n+ *\/\n+\n+\/*\n+ * @test id=Z\n+ * @requires vm.gc.Z\n+ * @comment ZGC will not start when LargePages cannot be allocated, therefore\n+ *          we do not run such configuration.\n+ * @summary Runs System.gc() with different flags.\n+ * @run main\/othervm -XX:+UseZGC gc.TestSystemGC\n@@ -56,0 +68,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestSystemGC.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -142,2 +142,2 @@\n-        if (newCollectionTime <= collectionTime) {\n-            throw new RuntimeException(\"Collector has not run some more\");\n+        if (newCollectionTime < collectionTime) {\n+            throw new RuntimeException(\"Collection time ran backwards\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/mixedgc\/TestOldGenCollectionUsage.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        \"-Xlog:gc=debug,gc+phases=trace\",\n+        \"-Xlog:gc,gc+plab=debug\",\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABEvacuationFailure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,5 +193,6 @@\n-        return new HashMap<>(\n-                getEntries().entryStream()\n-                .filter(gcLogItem -> extractId == gcIds.contains(gcLogItem.getKey()))\n-                .collect(Collectors.toMap(gcLogItem -> gcLogItem.getKey(),\n-                                gcLogItem -> gcLogItem.getValue().get(type).filter(fieldNames)\n+        var map = new HashMap<>(\n+                        getEntries().entryStream()\n+                        .filter(gcLogItem -> extractId == gcIds.contains(gcLogItem.getKey()))\n+                        .collect(Collectors.toMap(gcLogItem -> gcLogItem.getKey(),\n+                                        gcLogItem -> gcLogItem.getValue().get(type).filter(fieldNames)\n+                                )\n@@ -199,2 +200,5 @@\n-                )\n-        );\n+                 );\n+        if (map.isEmpty()) {\n+            throw new RuntimeException(\"Cannot find relevant PLAB statistics in the log\");\n+        }\n+        return map;\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/lib\/LogParser.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8281811\n+ * @summary assert(_base == Tuple) failed: Not a Tuple after JDK-8280799\n+ * @requires vm.gc.Shenandoah\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:-BackgroundCompilation -XX:LoopMaxUnroll=1 TestBarrierAboveProj\n+ *\/\n+\n+\n+public class TestBarrierAboveProj {\n+    private static C objField = new C();\n+    private static final Object[] arrayField = new Object[1000];\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1();\n+            test2();\n+        }\n+    }\n+\n+    private static float test1() {\n+        float v = 1;\n+        for (int i = 1; i < 1000; i++) {\n+            if (objField == arrayField[i]) {\n+                return v;\n+            }\n+            v *= 2;\n+        }\n+        return v;\n+    }\n+\n+    private static float test2() {\n+        float v = 1;\n+        volatileField = 0x42;\n+        for (int i = 1; i < 1000; i++) {\n+            if (objField == arrayField[i]) {\n+                return v;\n+            }\n+            v *= 2;\n+        }\n+        return v;\n+    }\n+\n+    private static class C {\n+        public float floatField;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestBarrierAboveProj.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,1 @@\n+    public static final String USER_DIR = System.getProperty(\"user.dir\");\n@@ -190,1 +191,0 @@\n-\n@@ -192,2 +192,3 @@\n-        System.out.println(\"using command: \" + command[0] + \" \" + command[1]);\n-        return run(command[0], command[1], \"\" + pid).collect(toList());\n+        \/\/ Only search the directory in which the VM is running (user.dir property).\n+        System.out.println(\"using command: \" + command[0] + \" -a +d \" + USER_DIR + \" \" + command[1] + \" \" + pid);\n+        return run(command[0], \"-a\", \"+d\", USER_DIR, command[1], \"\" + pid).collect(toList());\n","filename":"test\/hotspot\/jtreg\/runtime\/8176717\/TestInheritFD.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -226,2 +226,2 @@\n-        if (!Platform.isAArch64()) {\n-            \/\/ Currently relax this test for Aarch64.\n+        if (!Platform.isAArch64() && !Platform.isPPC()) {\n+            \/\/ Currently relax this test for Aarch64 and ppc.\n@@ -246,2 +246,2 @@\n-        if (!Platform.isAArch64()) {\n-            \/\/ Currently relax this test for Aarch64.\n+        if (!Platform.isAArch64() && !Platform.isPPC()) {\n+            \/\/ Currently relax this test for Aarch64 and ppc.\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointers.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+        output.shouldNotHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/EnclosingMethodAttr\/EnclMethodAttr.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,0 +83,5 @@\n+                \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n+                \/\/ deflations when 10% of monitors are used rather than the\n+                \/\/ default 90%. This should allow the test to tolerate a burst\n+                \/\/ of used monitors by threads not under this test's control.\n+                \"-XX:MonitorUsedDeflationThreshold=10\",\n@@ -91,2 +96,3 @@\n-                \/\/ reproduced the bug with JDK13. Anything above the\n-                \/\/ in_use_list_ceiling will do the trick.\n+                \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n+                \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n+                \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n@@ -113,0 +119,2 @@\n+            \/\/ Uncomment the following line for dumping test output in passing runs:\n+            \/\/ output_detail.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUsedDeflationThresholdTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n- * @requires vm.compMode==\"Xmixed\" &\n+ * @requires vm.compMode == \"Xmixed\" &\n+ *           vm.compiler2.enabled &\n@@ -113,1 +114,3 @@\n-        wb.enqueueMethodForCompilation(cons,  CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!wb.enqueueMethodForCompilation(cons, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION)) {\n+            throw new RuntimeException(\"Failed to queue constructor for compilation\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/Nestmates\/protectionDomain\/TestDifferentProtectionDomains.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-            C = new Clazz(getPackageName(packageId) + \"Helper\", -1, ACC_PUBLIC);\n+            C = new Clazz(getPackageName(packageId) + \"Helper\", ACC_PUBLIC, -1);\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/classes\/selectionresolution\/ClassBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-        super(name, extending == null ? \"java\/lang\/Object\" : extending, access + ACC_SUPER, classFileVersion, index, implementing);\n+        super(name, extending == null ? \"java\/lang\/Object\" : extending, access | ACC_SUPER, classFileVersion, index, implementing);\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/classes\/selectionresolution\/Clazz.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        testClass = new Clazz(\"Test\", null, -1, ACC_PUBLIC);\n+        testClass = new Clazz(\"Test\", null, ACC_PUBLIC, -1);\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/classes\/selectionresolution\/TestBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires !(os.family == \"linux\" & os.maxMemory < 512M)\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/Fibonacci.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SharedArchiveConsistency\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SharedArchiveConsistency on\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SharedArchiveConsistency auto\n@@ -72,0 +73,3 @@\n+    public static boolean shareAuto;       \/\/ true  == -Xshare:auto\n+                                           \/\/ false == -Xshare:on\n+\n@@ -83,0 +87,2 @@\n+    public static final String HELLO_WORLD = \"Hello World\";\n+\n@@ -342,1 +348,1 @@\n-        OutputAnalyzer output = TestCommon.execCommon(execArgs);\n+        OutputAnalyzer output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -364,0 +370,8 @@\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"One arg of 'on' or 'auto' to run the test\");\n+        }\n+        if (!args[0].equals(\"on\") && !args[0].equals(\"auto\")) {\n+            throw new RuntimeException(\"Arg must be 'on' or 'auto'\");\n+        }\n+        shareAuto = args[0].equals(\"auto\");\n+\n@@ -383,1 +397,1 @@\n-        OutputAnalyzer output = TestCommon.execCommon(execArgs);\n+        OutputAnalyzer output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -386,1 +400,1 @@\n-            TestCommon.checkExecReturn(output, 0, true, \"Hello World\");\n+            TestCommon.checkExecReturn(output, 0, true, HELLO_WORLD);\n@@ -400,1 +414,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -403,0 +417,3 @@\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n@@ -407,1 +424,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -410,6 +427,3 @@\n-\n-        \/\/ use the same archive as above, but run with -Xshare:auto\n-        System.out.println(\"\\n2b. Corrupt _jvm_ident run with -Xshare:auto\\n\");\n-        output = TestCommon.execAuto(execArgs);\n-        output.shouldContain(\"The shared archive file was created by a different version or build of HotSpot\");\n-        output.shouldContain(\"Hello World\");\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n@@ -420,1 +434,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -423,0 +437,3 @@\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n@@ -427,1 +444,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -430,0 +447,3 @@\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n@@ -445,1 +465,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -448,0 +468,3 @@\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":38,"deletions":15,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+        out.shouldNotHaveExitValue(0);\n@@ -72,0 +73,1 @@\n+        out.shouldNotHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ClassInitializationTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+        o.shouldHaveExitValue(0);\n@@ -73,0 +74,1 @@\n+        o.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ClassResolutionTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+        o.shouldHaveExitValue(0);\n@@ -53,0 +54,1 @@\n+        o.shouldHaveExitValue(0);\n@@ -61,0 +63,1 @@\n+        o.shouldHaveExitValue(0);\n@@ -71,0 +74,1 @@\n+        o.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/CondyIndyTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @build test.Empty\n@@ -71,0 +72,1 @@\n+        out.shouldHaveExitValue(0);\n@@ -76,0 +78,1 @@\n+        out.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/LoaderConstraintsTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+        o.shouldHaveExitValue(0);\n@@ -55,0 +56,1 @@\n+        o.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/MonitorMismatchTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8129579\n+ * @bug 8219579\n@@ -36,1 +36,1 @@\n-        System.out.println(\"Regression test for bug 819579\");\n+        System.out.println(\"Regression test for bug 8219579\");\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestSigParse.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.hasDTrace\n@@ -39,1 +40,0 @@\n-import jtreg.SkippedException;\n@@ -47,11 +47,1 @@\n-        {\n-            var pb = ProcessTools.createJavaProcessBuilder(\n-                    \"-XX:+ExtendedDTraceProbes\",\n-                    \"-version\");\n-            var oa = new OutputAnalyzer(pb.start());\n-            \/\/ This test only matters when build with DTRACE_ENABLED.\n-            if (oa.getExitValue() != 0) {\n-                throw new SkippedException(\"Not build using DTRACE_ENABLED\");\n-            }\n-        }\n-\n+        \/\/ This test only matters when build with DTRACE_ENABLED.\n","filename":"test\/hotspot\/jtreg\/serviceability\/7170638\/SDTProbesGNULinuxTest.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.  All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=enabled\n+ * @bug 8281822\n+ * @summary Test DTrace options are accepted on suitable builds\n+ * @requires vm.flagless\n+ * @requires vm.hasDTrace\n+ *\n+ * @library \/test\/lib\n+ * @run driver DTraceOptionsTest true\n+ *\/\n+\n+\/*\n+ * @test id=disabled\n+ * @bug 8281822\n+ * @summary Test DTrace options are rejected on unsuitable builds\n+ * @requires vm.flagless\n+ * @requires !vm.hasDTrace\n+ *\n+ * @library \/test\/lib\n+ * @run driver DTraceOptionsTest disabled\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class DTraceOptionsTest {\n+    public static void main(String[] args) throws Throwable {\n+        boolean dtraceEnabled;\n+        if (args.length > 0) {\n+            dtraceEnabled = Boolean.parseBoolean(args[0]);\n+        } else {\n+            throw new IllegalArgumentException(\"Should provide the argument\");\n+        }\n+\n+        String[] options = {\n+            \"ExtendedDTraceProbes\",\n+            \"DTraceMethodProbes\",\n+            \"DTraceAllocProbes\",\n+            \"DTraceMonitorProbes\",\n+        };\n+\n+        for (String opt : options) {\n+            var pb = ProcessTools.createJavaProcessBuilder(\"-XX:+\" + opt, \"-version\");\n+            var oa = new OutputAnalyzer(pb.start());\n+            if (dtraceEnabled) {\n+                oa.shouldHaveExitValue(0);\n+            } else {\n+                oa.shouldNotHaveExitValue(0);\n+                oa.shouldContain(opt + \" flag is not applicable for this configuration\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dtrace\/DTraceOptionsTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n-import java.io.*;\n-import java.util.*;\n-\n@@ -32,0 +29,2 @@\n+import java.io.PrintStream;\n+\n@@ -41,5 +40,3 @@\n-    private Node root;\n-    private int numberOfNodes;\n-    private float branchiness;\n-    private int size;\n-    private ExecutionController controller;\n+    private final Node root;\n+    private final float branchiness;\n+    private final ExecutionController controller;\n@@ -65,1 +62,0 @@\n-        initTree();\n@@ -69,8 +65,0 @@\n-        this.numberOfNodes = numberOfNodes;\n-        this.branchiness = branchiness;\n-        this.size = size;\n-        this.controller = controller;\n-        initTree();\n-    }\n-\n-    private void initTree() {\n@@ -79,2 +67,1 @@\n-                                             + numberOfNodes + \", must be at \"\n-                                             + \"least 1.\");\n+                    + numberOfNodes + \", must be at least 1.\");\n@@ -82,1 +69,1 @@\n-        if ( (branchiness >= 1) || (branchiness <= 0) ) {\n+        if ((branchiness >= 1) || (branchiness <= 0)) {\n@@ -84,3 +71,1 @@\n-                                             + numberOfNodes + \", must be at \"\n-                                             + \"greater than 0 and less than \"\n-                                             + \" 1.\");\n+                    + branchiness + \", must be greater than 0 and less than 1.\");\n@@ -90,1 +75,1 @@\n-                                             + size + \", must be at least 1.\");\n+                    + size + \", must be at least 1.\");\n@@ -94,1 +79,3 @@\n-        root = createTree(numberOfNodes, size);\n+        this.branchiness = branchiness;\n+        this.controller = controller;\n+        this.root = createTree(numberOfNodes, size);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/NonbranchyTree.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,8 +141,0 @@\n-\/* ============================================================================= *\/\n-static void set_agent_thread_state(thread_state_t value) {\n-    rawMonitorEnter(jvmti_env, agent_data.monitor);\n-    agent_data.thread_state = value;\n-    rawMonitorNotify(jvmti_env, agent_data.monitor);\n-    rawMonitorExit(jvmti_env, agent_data.monitor);\n-}\n-\n@@ -154,3 +146,4 @@\n-    \/* run user agent proc *\/\n-    {\n-        set_agent_thread_state(RUNNABLE);\n+    rawMonitorEnter(jvmti_env, agent_data.monitor);\n+    agent_data.thread_state = RUNNABLE;\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+    rawMonitorExit(jvmti_env, agent_data.monitor);\n@@ -158,1 +151,1 @@\n-        NSK_TRACE((*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg));\n+    NSK_TRACE((*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg));\n@@ -160,2 +153,6 @@\n-        set_agent_thread_state(TERMINATED);\n-    }\n+    rawMonitorEnter(jvmti_env, agent_data.monitor);\n+    agent_data.thread_state = TERMINATED;\n+    agentJNI->DeleteGlobalRef(agentThread);\n+    agentThread = NULL;\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+    rawMonitorExit(jvmti_env, agent_data.monitor);\n@@ -163,6 +160,0 @@\n-    \/* finalize agent thread *\/\n-    {\n-        \/* gelete global ref for agent thread *\/\n-        agentJNI->DeleteGlobalRef(agentThread);\n-        agentThread = NULL;\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/agent_tools.cpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-            \/\/ present in classpath\n+            \/\/ be present in classpath\n@@ -79,1 +79,1 @@\n-                throw new Failure(\"Icorrect level : \" + level + \" .Should be less then \" + height);\n+                throw new Failure(\"Incorrect level : \" + level + \" should be less than \" + height);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/share\/BTreeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+                                               .addToolArg(\"-J-Xmx1G\")\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/share\/GenClassesBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-            \/\/ jar path is in useal classpath format\n+            \/\/ jar path is in usual classpath format\n@@ -151,5 +151,2 @@\n-                } catch (ClassNotFoundException cnfe) {\n-                    throw new TestFailure(cnfe);\n-                } catch (OutOfMemoryError oome) {\n-                    \/\/ just ignore\n-                    \/\/ we do not check memory leaks in PermGen in this tests\n+                } catch (OutOfMemoryError | ClassNotFoundException | NoClassDefFoundError e) {\n+                    \/\/ just ignore, note that CNFE and NCDFE can be caused by OOM exceptions.\n@@ -167,0 +164,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/share\/SysDictTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/findByName.\n- * VM Testbase keywords: [feature_mlvm]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Try to find a class loaded as a hidden class through the VM system dictionary\n- *     (using Class.forName()). It is an error when the class can be found in this way.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.func.findByName.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm vm.mlvm.anonloader.func.findByName.Test\n- *\/\n-\n-package vm.mlvm.anonloader.func.findByName;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandles.Lookup;\n-\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.share.MlvmTest;\n-import vm.share.FileUtils;\n-\n-public class Test extends MlvmTest {\n-    private static final Class<?> PARENT = AnonkTestee01.class;\n-\n-    public boolean run() throws Exception {\n-        try {\n-            byte[] classBytes = FileUtils.readClass(PARENT.getName());\n-            Lookup lookup = MethodHandles.lookup();\n-            Lookup ank_lookup = MethodHandles.privateLookupIn(PARENT, lookup);\n-            Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n-            getLog().display(\"Hidden class name: \" + c.getName());\n-            Class.forName(c.getName()).newInstance();\n-            return false;\n-        } catch ( ClassNotFoundException e ) {\n-            return true;\n-        }\n-    }\n-\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/findByName\/Test.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package vm.mlvm.anonloader.share;\n-\n-public class AnonkTestee02 extends AnonkTestee01 {\n-    public AnonkTestee02() {}\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/share\/AnonkTestee02.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key randomness\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/byteMutation.\n- * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.stress.byteMutation.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm vm.mlvm.anonloader.stress.byteMutation.Test -stressIterationsFactor 100000\n- *\/\n-\n-package vm.mlvm.anonloader.stress.byteMutation;\n-\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.anonloader.share.StressClassLoadingTest;\n-import vm.share.FileUtils;\n-import vm.share.options.Option;\n-\n-\/**\n- * The test does the following in a cycle:\n- *\n- * <ol>\n- * <li>Takes bytes from a valid class file\n- * <li>Sets 1 to 5 bytes in random positions to random values\n- * <li>Tries to load such class using:\n- *     <ul>\n- *       <li>a custom class loader,\n- *       <li>{@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n- *           when {@code -hiddenLoad true} option is passed to the test.\n- *     <\/ul>\n- * <\/ol>\n- *\n- * <p>In most cases the resulting class file is invalid and rejected by\n- * the VM verifier. But this test tries to find pathological cases, such\n- * as infinite loops during verification or VM crashes.\n- *\n- *\/\n-public class Test extends StressClassLoadingTest {\n-    private final static Class<?> HOST_CLASS = AnonkTestee01.class;\n-    private final byte[] testeeBytes;\n-    @Option(name = \"mutationCount\", default_value = \"3\",\n-            description = \"How many bytes to mutate in a class\")\n-    private int mutationCount = 3;\n-\n-    \/**\n-     * Constructs the test.\n-     * @throws Exception if there are any errors when\n-     * reading {@link vm.mlvm.anonloader.share.AnonkTestee01} class bytecodes.\n-     *\/\n-    public Test() throws Exception {\n-        this.testeeBytes = FileUtils.readClass(AnonkTestee01.class.getName());\n-    }\n-\n-    \/**\n-     * Returns {@link vm.mlvm.anonloader.share.AnonkTestee01} class to the\n-     * parent.\n-     * @return {@link vm.mlvm.anonloader.share.AnonkTestee01} class.\n-     *\/\n-    @Override\n-    protected Class<?> getHostClass() {\n-        return HOST_CLASS;\n-    }\n-\n-    \/**\n-     * Takes {@link vm.mlvm.anonloader.share.AnonkTestee01} class bytecodes\n-     * and modifies mutationCount bytes setting them to random values.\n-     * @return {@link vm.mlvm.anonloader.share.AnonkTestee01} class bytecodes with modified bytes.\n-     *\/\n-    @Override\n-    protected byte[] generateClassBytes() {\n-        \/\/ TODO: there is non-zero probability that generated bytecode will be\n-        \/\/ valid, so it should be a subject of fuzzing mechanism\n-        byte[] alteredBytes = testeeBytes.clone();\n-        for (int j = 0; j < mutationCount; ++j) {\n-            alteredBytes[getRNG().nextInt(alteredBytes.length)] = (byte) getRNG().nextInt(256);\n-        }\n-        return alteredBytes;\n-    }\n-\n-    \/**\n-     * Runs the test.\n-     * @param args Test arguments.\n-     *\/\n-    public static void main(String[] args) {\n-        StressClassLoadingTest.launch(args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/byteMutation\/Test.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key randomness\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/oome\/heap.\n- * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.stress.oome.heap.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm -XX:-UseGCOverheadLimit -Xmx128m vm.mlvm.anonloader.stress.oome.heap.Test\n- *\/\n-\n-package vm.mlvm.anonloader.stress.oome.heap;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.util.List;\n-import java.io.IOException;\n-\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.share.MlvmOOMTest;\n-import vm.mlvm.share.MlvmTestExecutor;\n-import vm.mlvm.share.Env;\n-import vm.share.FileUtils;\n-\n-\/**\n- * This test loads a class using defineHiddenClass, creates instances\n- * of that class and stores them, expecting Heap OOME.\n- *\n- *\/\n-\n-public class Test extends MlvmOOMTest {\n-    @Override\n-    protected void checkOOME(OutOfMemoryError oome) {\n-        String message = oome.getMessage();\n-        if (!\"Java heap space\".equals(message)) {\n-            throw new RuntimeException(\"TEST FAIL : wrong OOME\", oome);\n-        }\n-    }\n-    @Override\n-    protected void eatMemory(List<Object> list) {\n-        byte[] classBytes = null;\n-        try {\n-            classBytes = FileUtils.readClass(AnonkTestee01.class.getName());\n-        } catch (IOException e) {\n-            Env.throwAsUncheckedException(e);\n-        }\n-        try {\n-            while (true) {\n-                Lookup lookup = MethodHandles.lookup();\n-                Lookup ank_lookup = MethodHandles.privateLookupIn(AnonkTestee01.class, lookup);\n-                Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n-                list.add(c.newInstance());\n-            }\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            Env.throwAsUncheckedException(e);\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        MlvmTestExecutor.launch(args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/oome\/heap\/Test.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/oome\/metaspace.\n- * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.stress.oome.metaspace.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm -XX:MaxRAMPercentage=25 -XX:-UseGCOverheadLimit -XX:MetaspaceSize=10m\n- *                   -XX:MaxMetaspaceSize=20m vm.mlvm.anonloader.stress.oome.metaspace.Test\n- *\/\n-\n-package vm.mlvm.anonloader.stress.oome.metaspace;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.util.List;\n-import java.io.IOException;\n-\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.share.MlvmOOMTest;\n-import vm.mlvm.share.MlvmTestExecutor;\n-import vm.mlvm.share.Env;\n-import vm.share.FileUtils;\n-\n-\/**\n- * This test loads classes using defineHiddenClass and stores them,\n- * expecting Metaspace OOME.\n- *\n- *\/\n-public class Test extends MlvmOOMTest {\n-    @Override\n-    protected void checkOOME(OutOfMemoryError oome) {\n-        String message = oome.getMessage();\n-        if (!\"Metaspace\".equals(message) && !\"Compressed class space\".equals(message)) {\n-            throw new RuntimeException(\"TEST FAIL : wrong OOME\", oome);\n-        }\n-    }\n-\n-    @Override\n-    protected void eatMemory(List<Object> list) {\n-        byte[] classBytes = null;\n-        try {\n-            classBytes = FileUtils.readClass(AnonkTestee01.class.getName());\n-        } catch (IOException e) {\n-            Env.throwAsUncheckedException(e);\n-        }\n-        try {\n-            while (true) {\n-                Lookup lookup = MethodHandles.lookup();\n-                Lookup ank_lookup = MethodHandles.privateLookupIn(AnonkTestee01.class, lookup);\n-                Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n-                list.add(c.newInstance());\n-             }\n-         } catch (InstantiationException | IllegalAccessException e) {\n-             Env.throwAsUncheckedException(e);\n-         }\n-    }\n-\n-    public static void main(String[] args) {\n-        MlvmTestExecutor.launch(args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/oome\/metaspace\/Test.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/parallelLoad.\n- * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.stress.parallelLoad.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm\n- *      -Xverify:all\n- *      vm.mlvm.anonloader.stress.parallelLoad.Test\n- *      -threadsPerCpu 4\n- *      -threadsExtra 20\n- *      -parseTimeout 0\n- *      -hiddenLoad true\n- *\/\n-\n-package vm.mlvm.anonloader.stress.parallelLoad;\n-\n-import vm.mlvm.anonloader.share.StressClassLoadingTest;\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.share.MlvmTestExecutor;\n-import vm.mlvm.share.MultiThreadedTest;\n-import vm.share.FileUtils;\n-\n-\/**\n- * Verifies that loading classes in parallel from several threads using\n- * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n- * does not produce exceptions and crashes.\n- *\n- *\/\n-public class Test extends MultiThreadedTest {\n-    private static final Class<?> HOST_CLASS = AnonkTestee01.class;\n-    private static final String NAME_PREFIX = \"thread%03d\";\n-\n-    private final byte[] classBytes;\n-\n-    private static class SubTest extends StressClassLoadingTest {\n-        private final byte[] classBytes;\n-\n-        public SubTest(byte[] classBytes) {\n-            this.classBytes = classBytes;\n-        }\n-\n-        @Override\n-        protected Class<?> getHostClass() {\n-            return HOST_CLASS;\n-        }\n-\n-        @Override\n-        protected byte[] generateClassBytes() {\n-            return classBytes;\n-        }\n-    }\n-\n-    public Test() throws Exception {\n-        classBytes = FileUtils.readClass(HOST_CLASS.getName());\n-    }\n-\n-    \/**\n-     * Constructs a sub-test class and runs it. The sub-test class loads\n-     * {@link vm.mlvm.anonloader.share.AnonkTestee01} class bytecodes\n-     * using {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n-     * @param numThread Number of the thread\n-     * @throws Exception if there any exceptions thrown in the sub-test\n-     *\/\n-    @Override\n-    protected boolean runThread(int numThread) throws Exception {\n-        SubTest subTest = new SubTest(classBytes);\n-        subTest.setFileNamePrefix(String.format(NAME_PREFIX, numThread));\n-        return subTest.run();\n-    }\n-\n-    \/**\n-     * Runs the test.\n-     * @param args Test arguments.\n-     *\/\n-    public static void main(String[] args) {\n-        MlvmTestExecutor.launch(args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/parallelLoad\/Test.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key randomness\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/randomBytecodes.\n- * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.stress.randomBytecodes.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm vm.mlvm.anonloader.stress.randomBytecodes.Test -stressIterationsFactor 100000\n- *\/\n-\n-package vm.mlvm.anonloader.stress.randomBytecodes;\n-\n-import java.util.Arrays;\n-import vm.mlvm.anonloader.share.StressClassLoadingTest;\n-\n-\/**\n- * The test does the following in a cycle:\n- * <ol>\n- * <li>Creates a class bytecodes that has a valid 12-byte header\n- *     and has totally random bytes after the header\n- * <li>Tries to load such class using:\n- *     <ul>\n- *       <li>a custom class loader, or\n- *       <li>{@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n- *           when {@code -hiddenLoad true} is set.\n- *     <\/ul>\n- * <\/ol>\n- *\n- * <p>In most cases the resulting class file is invalid and rejected by\n- * the VM verifier. But this test is looking for pathological cases\n- * such as infinite loops in the verifier or VM crashes.\n- *\n- *\/\n-public class Test extends StressClassLoadingTest {\n-    private static final Class<?> HOST_CLASS = Test.class;\n-    private static final int MAX_SIZE = 0xFFF7;\n-    private static final byte[] CLASS_HEADER = new byte[] {\n-        (byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE,\n-        0x00, 0x00, 0x00, 0x32\n-    };\n-\n-    \/**\n-     * Returns {@link vm.mlvm.anonloader.share.AnonkTestee01} class to the\n-     * parent.\n-     * @return {@link vm.mlvm.anonloader.share.AnonkTestee01} class.\n-     *\/\n-    @Override\n-    protected Class<?> getHostClass() {\n-        return HOST_CLASS;\n-    }\n-\n-    \/**\n-     * Generates a class with valid header (magic and version fields) and\n-     * random bytes after the header.\n-     * <p>Class size is random ([8..65527]).\n-     * Byte values are limited to [0..11] range in order to increase\n-     * possiblity that the random class passes the initial (dead-on-arrival)\n-     * stages of the verifier and is rejected\n-     * in more interesting ones, like method bytecode verification.\n-     * Class version is 52.\n-     *\n-     * @return Class with valid Java header (8 bytes) and totally random bytes\n-     * after the header\n-     *\/\n-    @Override\n-    protected byte[] generateClassBytes() {\n-        final byte[] classBytes = Arrays.copyOf(CLASS_HEADER,\n-                CLASS_HEADER.length + getRNG().nextInt(MAX_SIZE));\n-        for (int j = CLASS_HEADER.length; j < classBytes.length; j++) {\n-            classBytes[j] = (byte) getRNG().nextInt(12);\n-        }\n-\n-        return classBytes;\n-    }\n-\n-    \/**\n-     * Runs the test.\n-     * @param args Test arguments.\n-     *\/\n-    public static void main(String[] args) {\n-        StressClassLoadingTest.launch(args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/randomBytecodes\/Test.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/findByName.\n+ * VM Testbase keywords: [feature_mlvm]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     Try to find a class loaded as a hidden class through the VM system dictionary\n+ *     (using Class.forName()). It is an error when the class can be found in this way.\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *\n+ * @comment build test class and indify classes\n+ * @build vm.mlvm.hiddenloader.func.findByName.Test\n+ * @run driver vm.mlvm.share.IndifiedClassesBuilder\n+ *\n+ * @run main\/othervm vm.mlvm.hiddenloader.func.findByName.Test\n+ *\/\n+\n+package vm.mlvm.hiddenloader.func.findByName;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n+import vm.mlvm.hiddenloader.share.HiddenkTestee01;\n+import vm.mlvm.share.MlvmTest;\n+import vm.share.FileUtils;\n+\n+public class Test extends MlvmTest {\n+    private static final Class<?> PARENT = HiddenkTestee01.class;\n+\n+    public boolean run() throws Exception {\n+        try {\n+            byte[] classBytes = FileUtils.readClass(PARENT.getName());\n+            Lookup lookup = MethodHandles.lookup();\n+            Lookup ank_lookup = MethodHandles.privateLookupIn(PARENT, lookup);\n+            Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n+            getLog().display(\"Hidden class name: \" + c.getName());\n+            Class.forName(c.getName()).newInstance();\n+            return false;\n+        } catch ( ClassNotFoundException e ) {\n+            return true;\n+        }\n+    }\n+\n+    public static void main(String[] args) { MlvmTest.launch(args); }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/func\/findByName\/Test.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package vm.mlvm.anonloader.share;\n+package vm.mlvm.hiddenloader.share;\n@@ -28,1 +28,1 @@\n-public class AnonkTestee01 {\n+public class HiddenkTestee01 {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/share\/HiddenkTestee01.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/share\/AnonkTestee01.java","status":"renamed"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package vm.mlvm.hiddenloader.share;\n+\n+public class HiddenkTestee02 extends HiddenkTestee01 {\n+    public HiddenkTestee02() {}\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/share\/HiddenkTestee02.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package vm.mlvm.anonloader.share;\n+package vm.mlvm.hiddenloader.share;\n@@ -68,1 +68,1 @@\n- * saved to {@code _AnonkTestee01.class} file in the current directory.\n+ * saved to {@code _HiddenkTestee01.class} file in the current directory.\n@@ -75,1 +75,1 @@\n-    private static final String RESCUE_FILE_NAME = \"_AnonkTestee01.class\";\n+    private static final String RESCUE_FILE_NAME = \"_HiddenkTestee01.class\";\n@@ -103,1 +103,1 @@\n-     * _AnonkTestee01.class and hangXX.class.\n+     * _HiddenkTestee01.class and hangXX.class.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/share\/StressClassLoadingTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/share\/StressClassLoadingTest.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/byteMutation\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/byteMutation\/TEST.properties","status":"renamed"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @summary converted from VM Testbase vm\/mlvm\/hiddenloader\/stress\/byteMutation.\n+ * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *\n+ * @comment build test class and indify classes\n+ * @build vm.mlvm.hiddenloader.stress.byteMutation.Test\n+ * @run driver vm.mlvm.share.IndifiedClassesBuilder\n+ *\n+ * @run main\/othervm vm.mlvm.hiddenloader.stress.byteMutation.Test -stressIterationsFactor 100000\n+ *\/\n+\n+package vm.mlvm.hiddenloader.stress.byteMutation;\n+\n+import vm.mlvm.hiddenloader.share.HiddenkTestee01;\n+import vm.mlvm.hiddenloader.share.StressClassLoadingTest;\n+import vm.share.FileUtils;\n+import vm.share.options.Option;\n+\n+\/**\n+ * The test does the following in a cycle:\n+ *\n+ * <ol>\n+ * <li>Takes bytes from a valid class file\n+ * <li>Sets 1 to 5 bytes in random positions to random values\n+ * <li>Tries to load such class using:\n+ *     <ul>\n+ *       <li>a custom class loader,\n+ *       <li>{@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n+ *           when {@code -hiddenLoad true} option is passed to the test.\n+ *     <\/ul>\n+ * <\/ol>\n+ *\n+ * <p>In most cases the resulting class file is invalid and rejected by\n+ * the VM verifier. But this test tries to find pathological cases, such\n+ * as infinite loops during verification or VM crashes.\n+ *\n+ *\/\n+public class Test extends StressClassLoadingTest {\n+    private final static Class<?> HOST_CLASS = HiddenkTestee01.class;\n+    private final byte[] testeeBytes;\n+    @Option(name = \"mutationCount\", default_value = \"3\",\n+            description = \"How many bytes to mutate in a class\")\n+    private int mutationCount = 3;\n+\n+    \/**\n+     * Constructs the test.\n+     * @throws Exception if there are any errors when\n+     * reading {@link vm.mlvm.hiddenloader.share.HiddenkTestee01} class bytecodes.\n+     *\/\n+    public Test() throws Exception {\n+        this.testeeBytes = FileUtils.readClass(HiddenkTestee01.class.getName());\n+    }\n+\n+    \/**\n+     * Returns {@link vm.mlvm.hiddenloader.share.HiddenkTestee01} class to the\n+     * parent.\n+     * @return {@link vm.mlvm.hiddenloader.share.HiddenkTestee01} class.\n+     *\/\n+    @Override\n+    protected Class<?> getHostClass() {\n+        return HOST_CLASS;\n+    }\n+\n+    \/**\n+     * Takes {@link vm.mlvm.hiddenloader.share.HiddenkTestee01} class bytecodes\n+     * and modifies mutationCount bytes setting them to random values.\n+     * @return {@link vm.mlvm.hiddenloader.share.HiddenkTestee01} class bytecodes with modified bytes.\n+     *\/\n+    @Override\n+    protected byte[] generateClassBytes() {\n+        \/\/ TODO: there is non-zero probability that generated bytecode will be\n+        \/\/ valid, so it should be a subject of fuzzing mechanism\n+        byte[] alteredBytes = testeeBytes.clone();\n+        for (int j = 0; j < mutationCount; ++j) {\n+            alteredBytes[getRNG().nextInt(alteredBytes.length)] = (byte) getRNG().nextInt(256);\n+        }\n+        return alteredBytes;\n+    }\n+\n+    \/**\n+     * Runs the test.\n+     * @param args Test arguments.\n+     *\/\n+    public static void main(String[] args) {\n+        StressClassLoadingTest.launch(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/byteMutation\/Test.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/oome\/heap\/TEST.properties","status":"renamed"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/oome\/heap.\n+ * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *\n+ * @comment build test class and indify classes\n+ * @build vm.mlvm.hiddenloader.stress.oome.heap.Test\n+ * @run driver vm.mlvm.share.IndifiedClassesBuilder\n+ *\n+ * @run main\/othervm -XX:-UseGCOverheadLimit -Xmx128m vm.mlvm.hiddenloader.stress.oome.heap.Test\n+ *\/\n+\n+package vm.mlvm.hiddenloader.stress.oome.heap;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.util.List;\n+import java.io.IOException;\n+\n+import vm.mlvm.hiddenloader.share.HiddenkTestee01;\n+import vm.mlvm.share.MlvmOOMTest;\n+import vm.mlvm.share.MlvmTestExecutor;\n+import vm.mlvm.share.Env;\n+import vm.share.FileUtils;\n+\n+\/**\n+ * This test loads a class using defineHiddenClass, creates instances\n+ * of that class and stores them, expecting Heap OOME.\n+ *\n+ *\/\n+\n+public class Test extends MlvmOOMTest {\n+    @Override\n+    protected void checkOOME(OutOfMemoryError oome) {\n+        String message = oome.getMessage();\n+        if (!\"Java heap space\".equals(message)) {\n+            throw new RuntimeException(\"TEST FAIL : wrong OOME\", oome);\n+        }\n+    }\n+    @Override\n+    protected void eatMemory(List<Object> list) {\n+        byte[] classBytes = null;\n+        try {\n+            classBytes = FileUtils.readClass(HiddenkTestee01.class.getName());\n+        } catch (IOException e) {\n+            Env.throwAsUncheckedException(e);\n+        }\n+        try {\n+            while (true) {\n+                Lookup lookup = MethodHandles.lookup();\n+                Lookup ank_lookup = MethodHandles.privateLookupIn(HiddenkTestee01.class, lookup);\n+                Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n+                list.add(c.newInstance());\n+            }\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            Env.throwAsUncheckedException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        MlvmTestExecutor.launch(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/metaspace\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/oome\/metaspace\/TEST.properties","status":"renamed"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/oome\/metaspace.\n+ * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *\n+ * @comment build test class and indify classes\n+ * @build vm.mlvm.hiddenloader.stress.oome.metaspace.Test\n+ * @run driver vm.mlvm.share.IndifiedClassesBuilder\n+ *\n+ * @run main\/othervm -XX:MaxRAMPercentage=25 -XX:-UseGCOverheadLimit -XX:MetaspaceSize=10m\n+ *                   -XX:MaxMetaspaceSize=20m vm.mlvm.hiddenloader.stress.oome.metaspace.Test\n+ *\/\n+\n+package vm.mlvm.hiddenloader.stress.oome.metaspace;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.util.List;\n+import java.io.IOException;\n+\n+import vm.mlvm.hiddenloader.share.HiddenkTestee01;\n+import vm.mlvm.share.MlvmOOMTest;\n+import vm.mlvm.share.MlvmTestExecutor;\n+import vm.mlvm.share.Env;\n+import vm.share.FileUtils;\n+\n+\/**\n+ * This test loads classes using defineHiddenClass and stores them,\n+ * expecting Metaspace OOME.\n+ *\n+ *\/\n+public class Test extends MlvmOOMTest {\n+    @Override\n+    protected void checkOOME(OutOfMemoryError oome) {\n+        String message = oome.getMessage();\n+        if (!\"Metaspace\".equals(message) && !\"Compressed class space\".equals(message)) {\n+            throw new RuntimeException(\"TEST FAIL : wrong OOME\", oome);\n+        }\n+    }\n+\n+    @Override\n+    protected void eatMemory(List<Object> list) {\n+        byte[] classBytes = null;\n+        try {\n+            classBytes = FileUtils.readClass(HiddenkTestee01.class.getName());\n+        } catch (IOException e) {\n+            Env.throwAsUncheckedException(e);\n+        }\n+        try {\n+            while (true) {\n+                Lookup lookup = MethodHandles.lookup();\n+                Lookup ank_lookup = MethodHandles.privateLookupIn(HiddenkTestee01.class, lookup);\n+                Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n+                list.add(c.newInstance());\n+             }\n+         } catch (InstantiationException | IllegalAccessException e) {\n+             Env.throwAsUncheckedException(e);\n+         }\n+    }\n+\n+    public static void main(String[] args) {\n+        MlvmTestExecutor.launch(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/metaspace\/Test.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/parallelLoad\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/parallelLoad\/TEST.properties","status":"renamed"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/parallelLoad.\n+ * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *\n+ * @comment build test class and indify classes\n+ * @build vm.mlvm.hiddenloader.stress.parallelLoad.Test\n+ * @run driver vm.mlvm.share.IndifiedClassesBuilder\n+ *\n+ * @run main\/othervm\n+ *      -Xverify:all\n+ *      vm.mlvm.hiddenloader.stress.parallelLoad.Test\n+ *      -threadsPerCpu 4\n+ *      -threadsExtra 20\n+ *      -parseTimeout 0\n+ *      -hiddenLoad true\n+ *\/\n+\n+package vm.mlvm.hiddenloader.stress.parallelLoad;\n+\n+import vm.mlvm.hiddenloader.share.StressClassLoadingTest;\n+import vm.mlvm.hiddenloader.share.HiddenkTestee01;\n+import vm.mlvm.share.MlvmTestExecutor;\n+import vm.mlvm.share.MultiThreadedTest;\n+import vm.share.FileUtils;\n+\n+\/**\n+ * Verifies that loading classes in parallel from several threads using\n+ * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n+ * does not produce exceptions and crashes.\n+ *\n+ *\/\n+public class Test extends MultiThreadedTest {\n+    private static final Class<?> HOST_CLASS = HiddenkTestee01.class;\n+    private static final String NAME_PREFIX = \"thread%03d\";\n+\n+    private final byte[] classBytes;\n+\n+    private static class SubTest extends StressClassLoadingTest {\n+        private final byte[] classBytes;\n+\n+        public SubTest(byte[] classBytes) {\n+            this.classBytes = classBytes;\n+        }\n+\n+        @Override\n+        protected Class<?> getHostClass() {\n+            return HOST_CLASS;\n+        }\n+\n+        @Override\n+        protected byte[] generateClassBytes() {\n+            return classBytes;\n+        }\n+    }\n+\n+    public Test() throws Exception {\n+        classBytes = FileUtils.readClass(HOST_CLASS.getName());\n+    }\n+\n+    \/**\n+     * Constructs a sub-test class and runs it. The sub-test class loads\n+     * {@link vm.mlvm.hiddenloader.share.HiddenkTestee01} class bytecodes\n+     * using {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n+     * @param numThread Number of the thread\n+     * @throws Exception if there any exceptions thrown in the sub-test\n+     *\/\n+    @Override\n+    protected boolean runThread(int numThread) throws Exception {\n+        SubTest subTest = new SubTest(classBytes);\n+        subTest.setFileNamePrefix(String.format(NAME_PREFIX, numThread));\n+        return subTest.run();\n+    }\n+\n+    \/**\n+     * Runs the test.\n+     * @param args Test arguments.\n+     *\/\n+    public static void main(String[] args) {\n+        MlvmTestExecutor.launch(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/parallelLoad\/Test.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/randomBytecodes\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/randomBytecodes\/TEST.properties","status":"renamed"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @summary converted from VM Testbase vm\/mlvm\/anonloader\/stress\/randomBytecodes.\n+ * VM Testbase keywords: [feature_mlvm, nonconcurrent]\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *\n+ * @comment build test class and indify classes\n+ * @build vm.mlvm.hiddenloader.stress.randomBytecodes.Test\n+ * @run driver vm.mlvm.share.IndifiedClassesBuilder\n+ *\n+ * @run main\/othervm vm.mlvm.hiddenloader.stress.randomBytecodes.Test -stressIterationsFactor 100000\n+ *\/\n+\n+package vm.mlvm.hiddenloader.stress.randomBytecodes;\n+\n+import java.util.Arrays;\n+import vm.mlvm.hiddenloader.share.StressClassLoadingTest;\n+\n+\/**\n+ * The test does the following in a cycle:\n+ * <ol>\n+ * <li>Creates a class bytecodes that has a valid 12-byte header\n+ *     and has totally random bytes after the header\n+ * <li>Tries to load such class using:\n+ *     <ul>\n+ *       <li>a custom class loader, or\n+ *       <li>{@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n+ *           when {@code -hiddenLoad true} is set.\n+ *     <\/ul>\n+ * <\/ol>\n+ *\n+ * <p>In most cases the resulting class file is invalid and rejected by\n+ * the VM verifier. But this test is looking for pathological cases\n+ * such as infinite loops in the verifier or VM crashes.\n+ *\n+ *\/\n+public class Test extends StressClassLoadingTest {\n+    private static final Class<?> HOST_CLASS = Test.class;\n+    private static final int MAX_SIZE = 0xFFF7;\n+    private static final byte[] CLASS_HEADER = new byte[] {\n+        (byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE,\n+        0x00, 0x00, 0x00, 0x32\n+    };\n+\n+    \/**\n+     * Returns {@link vm.mlvm.hiddenloader.share.HiddenkTestee01} class to the\n+     * parent.\n+     * @return {@link vm.mlvm.hiddenloader.share.HiddenkTestee01} class.\n+     *\/\n+    @Override\n+    protected Class<?> getHostClass() {\n+        return HOST_CLASS;\n+    }\n+\n+    \/**\n+     * Generates a class with valid header (magic and version fields) and\n+     * random bytes after the header.\n+     * <p>Class size is random ([8..65527]).\n+     * Byte values are limited to [0..11] range in order to increase\n+     * possiblity that the random class passes the initial (dead-on-arrival)\n+     * stages of the verifier and is rejected\n+     * in more interesting ones, like method bytecode verification.\n+     * Class version is 52.\n+     *\n+     * @return Class with valid Java header (8 bytes) and totally random bytes\n+     * after the header\n+     *\/\n+    @Override\n+    protected byte[] generateClassBytes() {\n+        final byte[] classBytes = Arrays.copyOf(CLASS_HEADER,\n+                CLASS_HEADER.length + getRNG().nextInt(MAX_SIZE));\n+        for (int j = CLASS_HEADER.length; j < classBytes.length; j++) {\n+            classBytes[j] = (byte) getRNG().nextInt(12);\n+        }\n+\n+        return classBytes;\n+    }\n+\n+    \/**\n+     * Runs the test.\n+     * @param args Test arguments.\n+     *\/\n+    public static void main(String[] args) {\n+        StressClassLoadingTest.launch(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/randomBytecodes\/Test.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java 8256368 generic-all\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -622,2 +622,0 @@\n-java\/nio\/channels\/Selector\/Wakeup.java                          6963118 windows-all\n-\n@@ -827,1 +825,0 @@\n-jdk\/jfr\/event\/gc\/detailed\/TestEvacuationFailedEvent.java        8263461 linux-all,windows-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,0 +99,7 @@\n+        \/\/ Validate the root paths\n+        if (!Paths.get(buildWorkspaceRoot).isAbsolute()) {\n+            throw new Error(\"Workspace root is not an absolute path: \" + buildWorkspaceRoot);\n+        }\n+        if (!Paths.get(buildOutputRoot).isAbsolute()) {\n+            throw new Error(\"Output root is not an absolute path: \" + buildOutputRoot);\n+        }\n","filename":"test\/jdk\/build\/AbsPathsInImage.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n- * @modules java.xml.crypto\n+ * @modules java.xml.crypto\/com.sun.org.apache.xml.internal.security\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.signature\n@@ -31,0 +32,2 @@\n+import com.sun.org.apache.xml.internal.security.Init;\n+import com.sun.org.apache.xml.internal.security.signature.XMLSignature;\n@@ -94,0 +97,12 @@\n+\n+        \/\/ Internal way\n+        Init.init();\n+        XMLSignature signature = new XMLSignature(document, null,\n+                SignatureMethod.ECDSA_SHA256, CanonicalizationMethod.INCLUSIVE);\n+        signature.sign(privateKey);\n+        sig = signature.getSignatureValue();\n+        if (sig.length != 64) {\n+            System.out.println(\"Length: \" + sig.length);\n+            System.out.println(HexFormat.ofDelimiter(\":\").formatHex(sig));\n+            throw new RuntimeException(\"Failed\");\n+        }\n","filename":"test\/jdk\/com\/sun\/org\/apache\/xml\/internal\/security\/ShortECDSA.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8272908\n+ * @summary Verify signature KeyInfo\n+ * @library \/test\/lib\n+ * @modules java.xml.crypto\/com.sun.org.apache.xml.internal.security\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.c14n\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.signature\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.utils\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.keys\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.keys.content.keyvalues\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.keys.content\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.exceptions\n+ * @run main\/othervm SignatureKeyInfo\n+ *\/\n+\n+import com.sun.org.apache.xml.internal.security.Init;\n+import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;\n+import com.sun.org.apache.xml.internal.security.keys.KeyInfo;\n+import com.sun.org.apache.xml.internal.security.keys.content.PGPData;\n+import com.sun.org.apache.xml.internal.security.keys.content.RetrievalMethod;\n+import com.sun.org.apache.xml.internal.security.keys.content.SPKIData;\n+import com.sun.org.apache.xml.internal.security.signature.XMLSignature;\n+import com.sun.org.apache.xml.internal.security.utils.Constants;\n+import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n+import com.sun.org.apache.xml.internal.security.utils.ElementProxy;\n+import com.sun.org.apache.xml.internal.security.keys.content.keyvalues.RSAKeyValue;\n+import com.sun.org.apache.xml.internal.security.keys.content.keyvalues.DSAKeyValue;\n+\n+import jdk.test.lib.Asserts;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NodeList;\n+\n+\n+import javax.xml.crypto.dsig.CanonicalizationMethod;\n+import javax.xml.crypto.dsig.SignatureMethod;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import java.io.File;\n+import java.math.BigInteger;\n+import java.security.*;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+public class SignatureKeyInfo {\n+\n+    private final static String DIR = System.getProperty(\"test.src\", \".\");\n+    private static DocumentBuilderFactory dbf = null;\n+    private static Document doc;\n+\n+    private static final String NAME = \"testName\";\n+    private static final String TEXT = \"testText\";\n+    private static final String NS = Constants.SignatureSpecNS;\n+    private static final String RSA = \"RSA\";\n+    private static final String DSA = \"DSA\";\n+    private static final String FILE_TO_SIGN = \"signature-enveloping-hmac-sha1.xml\";\n+    private static final String FILE_TO_VERIFY = \"signature-enveloping-hmac-sha1-keyinfo.xml\";\n+    private static final int FIRST_EL = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Init.init();\n+        dbf = DocumentBuilderFactory.newInstance();\n+        dbf.setNamespaceAware(true);\n+        dbf.setValidating(false);\n+        verifyXmlKeyInfo();\n+        sign(RSA);\n+        sign(DSA);\n+    }\n+\n+    private static void sign(String algorithm) throws Exception {\n+        File file = new File(DIR, FILE_TO_SIGN);\n+\n+        doc = dbf.newDocumentBuilder().parse(file);\n+\n+        KeyPair kp = getKeyPair(algorithm);\n+\n+        String signMethod = RSA.equals(algorithm) ? SignatureMethod.RSA_SHA256\n+                : SignatureMethod.DSA_SHA256;\n+\n+        XMLSignature signature = new XMLSignature(doc, null,\n+                signMethod, CanonicalizationMethod.INCLUSIVE);\n+\n+        signature.addKeyInfo(kp.getPublic());\n+        KeyInfo keyInfo = signature.getKeyInfo();\n+        addKeyInfoData(keyInfo, algorithm);\n+        signature.sign(kp.getPrivate());\n+    }\n+\n+    private static Element getSignElement() {\n+        NodeList nl =\n+                doc.getElementsByTagNameNS(NS, \"Signature\");\n+        if (nl.getLength() == 0) {\n+            throw new RuntimeException(\"Could not find signature Element\");\n+        }\n+\n+        return (Element) nl.item(FIRST_EL);\n+    }\n+\n+    private static void addKeyInfoData(KeyInfo keyInfo, String algorithm) throws Exception {\n+        KeyPair keyPair = getKeyPair(algorithm);\n+\n+        if (algorithm.equals(RSA)) {\n+            RSAKeyValue rsaKeyValue = new RSAKeyValue(doc, keyPair.getPublic());\n+            keyInfo.add(rsaKeyValue);\n+        } else {\n+            DSAKeyValue dsaKeyValue = new DSAKeyValue(doc, keyPair.getPublic());\n+            keyInfo.add(dsaKeyValue);\n+        }\n+\n+        Element elpgp= doc.createElementNS(NS, Constants._TAG_PGPDATA);\n+        Element elrm= doc.createElementNS(NS, Constants._TAG_RETRIEVALMETHOD);\n+        Element elspki= doc.createElementNS(NS, Constants._TAG_SPKIDATA);\n+        keyInfo.add(new PGPData(elpgp, NS));\n+        keyInfo.add(new RetrievalMethod(elrm, NS));\n+        keyInfo.add(new SPKIData(elspki, NS));\n+\n+        keyInfo.setId(TEXT);\n+        keyInfo.addKeyName(TEXT);\n+        keyInfo.add(keyPair.getPublic());\n+        keyInfo.addKeyValue(keyPair.getPublic());\n+        keyInfo.addDEREncodedKeyValue(keyPair.getPublic());\n+        keyInfo.addKeyInfoReference(NS);\n+        keyInfo.addMgmtData(TEXT);\n+\n+        Element e = XMLUtils.createElementInSignatureSpace(doc, NAME);\n+        keyInfo.addKeyValue(e);\n+        keyInfo.addUnknownElement(e);\n+        keyInfo.addText(TEXT);\n+        keyInfo.addTextElement(TEXT, NAME);\n+        keyInfo.addBigIntegerElement(BigInteger.valueOf(12345), NAME);\n+        keyInfo.addBase64Text(TEXT.getBytes());\n+        keyInfo.addBase64Element(TEXT.getBytes(), NAME);\n+\n+        verifyKeyInfoData(keyInfo, algorithm);\n+    }\n+\n+    private static KeyPair getKeyPair(String algorithm) throws NoSuchAlgorithmException {\n+        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algorithm);\n+        keyGen.initialize(2048);\n+\n+        return keyGen.genKeyPair();\n+    }\n+\n+    private static void verifyKeyInfoData(KeyInfo keyInfo, String algorithm)\n+            throws XMLSecurityException {\n+        Asserts.assertTrue(keyInfo.containsKeyName());\n+        verifyElementText(keyInfo.itemKeyName(FIRST_EL));\n+        Asserts.assertTrue(keyInfo.containsKeyValue());\n+        verifyElementNS(keyInfo.itemKeyValue(FIRST_EL).getBaseNamespace());\n+\n+        Asserts.assertTrue(keyInfo.containsKeyInfoReference());\n+        verifyElementNS(keyInfo.itemKeyInfoReference(FIRST_EL).getURI());\n+        Asserts.assertTrue(keyInfo.containsDEREncodedKeyValue());\n+        Asserts.assertTrue(keyInfo.containsMgmtData());\n+        verifyElementText(keyInfo.itemMgmtData(FIRST_EL));\n+        Asserts.assertEquals(TEXT, keyInfo.getId());\n+\n+        Asserts.assertTrue(keyInfo.containsPGPData());\n+        verifyElementNS(keyInfo.itemPGPData(FIRST_EL).getBaseNamespace());\n+\n+        Asserts.assertTrue(keyInfo.containsRetrievalMethod());\n+        verifyElementNS(keyInfo.itemRetrievalMethod(FIRST_EL).getBaseNamespace());\n+        Asserts.assertTrue(keyInfo.containsSPKIData());\n+        verifyElementNS(keyInfo.itemSPKIData(FIRST_EL).getBaseNamespace());\n+\n+        Asserts.assertTrue(keyInfo.containsUnknownElement());\n+        Asserts.assertEquals(NAME, keyInfo.itemUnknownElement(13).getLocalName());\n+\n+        Asserts.assertFalse(keyInfo.isEmpty());\n+        Asserts.assertEquals(algorithm, keyInfo.getPublicKey().getAlgorithm());\n+    }\n+\n+    private static void verifyXmlKeyInfo() throws Exception {\n+        File file = new File(DIR, FILE_TO_VERIFY);\n+\n+        doc = dbf.newDocumentBuilder().parse(file);\n+        Element sigElement = getSignElement();\n+        XMLSignature signature = new XMLSignature\n+                (sigElement, file.toURI().toString());\n+\n+        KeyInfo keyInfo = signature.getKeyInfo();\n+        assertEquals(TEXT, keyInfo.itemMgmtData(FIRST_EL).getMgmtData());\n+    }\n+\n+    private static void verifyElementText(ElementProxy elementProxy) {\n+        Asserts.assertEquals(TEXT, elementProxy.getTextFromTextChild());\n+    }\n+\n+    private static void verifyElementNS(String actualNs) {\n+        Asserts.assertEquals(NS, actualNs);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/org\/apache\/xml\/internal\/security\/SignatureKeyInfo.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n@@ -67,1 +68,5 @@\n-        generate_hmac_sha1_40();\n+\n+        \/\/ There are multiple validations regarding hmac min output length, therefore\n+        \/\/ checking different values will exercise multiple code blocks\n+        generate_hmac_sha1(40);\n+        generate_hmac_sha1(128);\n@@ -89,1 +94,1 @@\n-        SecretKey sk = signature.createSecretKey(\"secret\".getBytes(\"ASCII\"));\n+        SecretKey sk = signature.createSecretKey(\"secret\".getBytes(US_ASCII));\n@@ -109,2 +114,2 @@\n-    private static void generate_hmac_sha1_40() throws Exception {\n-        System.out.println(\"Generating \");\n+    private static void generate_hmac_sha1(int hmacOutputLength) throws Exception {\n+        System.out.println(\"Generating \" + hmacOutputLength);\n@@ -115,1 +120,1 @@\n-            (doc, null, XMLSignature.ALGO_ID_MAC_HMAC_SHA1, 40,\n+            (doc, null, XMLSignature.ALGO_ID_MAC_HMAC_SHA1, hmacOutputLength,\n@@ -117,1 +122,1 @@\n-            sig.sign(getSecretKey(\"secret\".getBytes(\"ASCII\")));\n+            sig.sign(getSecretKey(\"secret\".getBytes(US_ASCII)));\n","filename":"test\/jdk\/com\/sun\/org\/apache\/xml\/internal\/security\/TruncateHMAC.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Signature xmlns=\"http:\/\/www.w3.org\/2000\/09\/xmldsig#\">\n+  <SignedInfo>\n+    <CanonicalizationMethod Algorithm=\"http:\/\/www.w3.org\/TR\/2001\/REC-xml-c14n-20010315\" \/>\n+    <SignatureMethod Algorithm=\"http:\/\/www.w3.org\/2000\/09\/xmldsig#hmac-sha1\" \/>\n+    <Reference URI=\"#object\">\n+      <DigestMethod Algorithm=\"http:\/\/www.w3.org\/2000\/09\/xmldsig#sha1\" \/>\n+      <DigestValue>7\/XTsHaBSOnJ\/jXD5v0zL6VKYsk=<\/DigestValue>\n+    <\/Reference>\n+  <\/SignedInfo>\n+  <SignatureValue>\n+    JElPttIT4Am7Q+MNoMyv+WDfAZw=\n+  <\/SignatureValue>\n+  <KeyInfo>\n+    <MgmtData>testText<\/MgmtData>\n+    <KeyValue>\n+      <ECKeyValue xmlns=\"http:\/\/www.w3.org\/2009\/xmldsig11#\">\n+        <NamedCurve URI=\"urn:oid:1.2.840.10045.3.1.7\"\/>\n+        <PublicKey>BAds672US3sCYunM2k2bEQLbuRxdQlNTvq+5fitOpDMe0mBdZV4J3yZaG0taziYIuAT9GJGfds+q\n+          xtXOCNWe\/60=<\/PublicKey>\n+      <\/ECKeyValue>\n+    <\/KeyValue>\n+  <\/KeyInfo>\n+  <Object Id=\"object\">some text<\/Object>\n+<\/Signature>\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/org\/apache\/xml\/internal\/security\/signature-enveloping-hmac-sha1-keyinfo.xml","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -45,0 +45,2 @@\n+ * @run main\/othervm CheckCommonColors\n+ * @run main\/othervm -Xcheck:jni CheckCommonColors\n","filename":"test\/jdk\/java\/awt\/Robot\/CheckCommonColors\/CheckCommonColors.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8281338\n+ * @summary Test for an element that has more than one Accessibility Action\n+ * @author Artem.Semenov@jetbrains.com\n+ * @run main\/manual AccessibleActionsTest\n+ * @requires (os.family == \"mac\")\n+ *\/\n+\n+import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleAction;\n+import javax.accessibility.AccessibleContext;\n+import javax.swing.*;\n+import javax.swing.tree.TreeModel;\n+import javax.swing.tree.TreePath;\n+import java.awt.*;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.util.Hashtable;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class AccessibleActionsTest extends AccessibleComponentTest {\n+\n+  @Override\n+  public CountDownLatch createCountDownLatch() {\n+    return new CountDownLatch(1);\n+  }\n+\n+  void createTest() {\n+    INSTRUCTIONS = \"INSTRUCTIONS:\\n\"\n+            + \"Check a11y actions.\\n\\n\"\n+            + \"Turn screen reader on, and Tab to the label.\\n\\n\"\n+            + \"Perform the VO action \\\"Press\\\" (VO+space)\\n\"\n+            + \"Perform the VO action \\\"Show menu\\\" (VO+m)\\n\\n\"\n+            + \"If after the first action the text of the label has changed, and after the second action the menu appears  tab further and press PASS, otherwise press FAIL.\";\n+\n+    exceptionString = \"AccessibleAction test failed!\";\n+    super.createUI(new AccessibleActionsTestFrame(), \"AccessibleActionsTest\");\n+  }\n+\n+  void createTree() {\n+    INSTRUCTIONS = \"INSTRUCTIONS:\\n\"\n+            + \"Check a11y actions.\\n\\n\"\n+            + \"Turn screen reader on, and Tab to the label.\\n\\n\"\n+            + \"Perform the VO action \\\"Press\\\" (VO+space) on tree nodes\\n\\n\"\n+            + \"If after press the tree node is expanded  tab further and press PASS, otherwise press FAIL.\";\n+\n+    String root = \"Root\";\n+    String[] nodes = new String[] {\"One node\", \"Two node\"};\n+    String[][] leafs = new String[][]{{\"leaf 1.1\", \"leaf 1.2\", \"leaf 1.3\", \"leaf 1.4\"},\n+            {\"leaf 2.1\", \"leaf 2.2\", \"leaf 2.3\", \"leaf 2.4\"}};\n+\n+    Hashtable<String, String[]> data = new Hashtable<String, String[]>();\n+    for (int i = 0; i < nodes.length; i++) {\n+      data.put(nodes[i], leafs[i]);\n+    }\n+\n+    JTree tree = new JTree(data);\n+    tree.setRootVisible(true);\n+\n+    JPanel panel = new JPanel();\n+    panel.setLayout(new FlowLayout());\n+    JScrollPane scrollPane = new JScrollPane(tree);\n+    panel.add(scrollPane);\n+    panel.setFocusable(false);\n+\n+    exceptionString = \"AccessibleAction test failed!\";\n+    super.createUI(panel, \"AccessibleActionsTest\");\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    AccessibleActionsTest test = new AccessibleActionsTest();\n+\n+    countDownLatch = test.createCountDownLatch();\n+    SwingUtilities.invokeLater(test::createTest);\n+    countDownLatch.await();\n+\n+    if (!testResult) {\n+      throw new RuntimeException(a11yTest.exceptionString);\n+    }\n+\n+    countDownLatch = test.createCountDownLatch();\n+    SwingUtilities.invokeLater(test::createTree);\n+    countDownLatch.await();\n+\n+    if (!testResult) {\n+      throw new RuntimeException(a11yTest.exceptionString);\n+    }\n+  }\n+\n+  private class AccessibleActionsTestFrame extends JPanel {\n+\n+    public AccessibleActionsTestFrame() {\n+      MyLabel label = new MyLabel(\"I'm waiting for the push\");\n+      label.setComponentPopupMenu(createPopup());\n+      label.setFocusable(true);\n+      add(label);\n+      setLayout(new FlowLayout());\n+    }\n+\n+    private static class MyLabel extends JLabel {\n+      public MyLabel(String text) {\n+        super(text);\n+      }\n+\n+      @Override\n+      public AccessibleContext getAccessibleContext() {\n+        if (accessibleContext == null) {\n+          accessibleContext = new MyAccessibleJLabel();\n+        }\n+        return accessibleContext;\n+      }\n+\n+      private class MyAccessibleJLabel extends JLabel.AccessibleJLabel {\n+        @Override\n+        public AccessibleAction getAccessibleAction() {\n+          return new AccessibleAction() {\n+            @Override\n+            public int getAccessibleActionCount() {\n+              return 2;\n+            }\n+\n+            @Override\n+            public String getAccessibleActionDescription(int i) {\n+              if (i == 0) {\n+                return AccessibleAction.CLICK;\n+              }\n+              return AccessibleAction.TOGGLE_POPUP;\n+            }\n+\n+            @Override\n+            public boolean doAccessibleAction(int i) {\n+              if (i == 0) {\n+                changeText(MyLabel.this, \"label is pressed\");\n+                return true;\n+              }\n+              JPopupMenu popup = createPopup();\n+              popup.show(MyLabel.this, 0, 0);\n+              return true;\n+            }\n+          };\n+        }\n+      }\n+    }\n+\n+    private static JPopupMenu createPopup() {\n+      JPopupMenu popup = new JPopupMenu(\"MENU\");\n+      popup.add(\"One\");\n+      popup.add(\"Two\");\n+      popup.add(\"Three\");\n+      return popup;\n+    }\n+\n+    private static void changeText(JLabel label, String text) {\n+      label.setText(text);\n+    }\n+\n+  }\n+}\n","filename":"test\/jdk\/java\/awt\/a11y\/AccessibleActionsTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8280964\n+ * @summary Tests that drawing to a ByteIndexed image dithers correctly.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+\n+public class ByteIndexedDitherTest {\n+\n+    public static void main(String[] args) {\n+        BufferedImage bgr = createBGRImage();\n+        BufferedImage indexed = createIndexedImage(bgr);\n+        checkImage(indexed);\n+    }\n+\n+    static BufferedImage createBGRImage() {\n+\n+        int sz = 8;\n+        BufferedImage img;\n+        img = new BufferedImage(sz, sz, BufferedImage.TYPE_3BYTE_BGR);\n+        Graphics2D g = img.createGraphics();\n+        Color c = new Color(0, 0, 254);\n+        g.setColor(c);\n+        g.fillRect(0, 0, sz, sz);\n+        g.dispose();\n+\n+        return img;\n+    }\n+\n+    static BufferedImage createIndexedImage(BufferedImage srcImage) {\n+\n+        int w = srcImage.getWidth(null);\n+        int h = srcImage.getHeight(null);\n+        BufferedImage\n+        indexedImg = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_INDEXED);\n+        Graphics2D g = indexedImg.createGraphics();\n+        g.drawImage(srcImage, 0, 0, w, h, null);\n+        g.dispose();\n+        return indexedImg;\n+    }\n+\n+     static void checkImage(BufferedImage image) {\n+         int wid = image.getWidth();\n+         int hgt = image.getHeight();\n+         for (int y=0; y<hgt; y++) {\n+             for (int x=0; x<wid; x++) {\n+                 int v = image.getRGB(x, y);\n+                 if ((v & 0x00ffff00) != 0) {\n+                     System.err.println(\"(\"+x+\",\"+y+\") = \" +\n+                          Integer.toHexString(v));\n+                     throw new RuntimeException(\"Unexpected Red or Green\");\n+                 }\n+             }\n+         }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/image\/DrawImage\/ByteIndexedDitherTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -34,0 +34,4 @@\n+ *\n+ * @run testng\/othervm -Xint -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=100000\n+ *   TestDowncall\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.NameClassCache;\n+\n+\/**\n+ * @test\n+ * @bug 8280041\n+ * @summary Sanity test for ClassCache under continuous GC\n+ * @compile\/module=java.base java\/io\/NameClassCache.java\n+ * @run main ContinuousGCTest\n+ *\/\n+public class ContinuousGCTest {\n+    static final NameClassCache CACHE = new NameClassCache();\n+    static final String VALUE = \"ClassCache-ContinuousGCTest\";\n+\n+    public static void main(String... args) throws Throwable {\n+        for (int c = 0; c < 1000; c++) {\n+            test();\n+            System.gc();\n+        }\n+    }\n+\n+    public static void test() {\n+        String cached = CACHE.get(ContinuousGCTest.class);\n+        if (!cached.equals(VALUE)) {\n+            throw new IllegalStateException(\"Cache failure, got: \" + cached);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/ClassCache\/ContinuousGCTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.NullClassCache;\n+\n+\/**\n+ * @test\n+ * @bug 8280041\n+ * @summary Test that ClassCache throws on trying to pass null value\n+ * @compile\/module=java.base java\/io\/NullClassCache.java\n+ * @run main NullValueTest\n+ *\/\n+public class NullValueTest {\n+    public static void main(String... args) throws Throwable {\n+        try {\n+            new NullClassCache().get(Object.class);\n+            throw new IllegalStateException(\"Should have failed\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/ClassCache\/NullValueTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+public class NameClassCache extends ClassCache<String> {\n+    protected String computeValue(Class<?> cl) {\n+        \/\/ Return string that is not interned and specific to class\n+        return \"ClassCache-\" + cl.getName();\n+    }\n+\n+    public String get(Class<?> cl) {\n+        return super.get(cl);\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/ClassCache\/java.base\/java\/io\/NameClassCache.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+public class NullClassCache extends ClassCache<Object> {\n+    protected Object computeValue(Class<?> cl) {\n+        return null;\n+    }\n+\n+    public Object get(Class<?> cl) {\n+        return super.get(cl);\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/ClassCache\/java.base\/java\/io\/NullClassCache.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.io.ObjectStreamClass;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+\/* @test\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive\n+ * @run testng\/othervm -Xmx10m -XX:SoftRefLRUPolicyMSPerMB=1 ObjectStreamClassCaching\n+ *\/\n+public class ObjectStreamClassCaching {\n+\n+    @Test\n+    public void testCachingEffectiveness() throws Exception {\n+        var ref = lookupObjectStreamClass(TestClass.class);\n+        System.gc();\n+        Thread.sleep(100L);\n+        \/\/ to trigger any ReferenceQueue processing...\n+        lookupObjectStreamClass(AnotherTestClass.class);\n+        assertFalse(ref.refersTo(null),\n+                    \"Cache lost entry although memory was not under pressure\");\n+    }\n+\n+    @Test\n+    public void testCacheReleaseUnderMemoryPressure() throws Exception {\n+        var ref = lookupObjectStreamClass(TestClass.class);\n+        pressMemoryHard(ref);\n+        System.gc();\n+        Thread.sleep(100L);\n+        assertTrue(ref.refersTo(null),\n+                   \"Cache still has entry although memory was pressed hard\");\n+    }\n+\n+    \/\/ separate method so that the looked-up ObjectStreamClass is not kept on stack\n+    private static WeakReference<?> lookupObjectStreamClass(Class<?> cl) {\n+        return new WeakReference<>(ObjectStreamClass.lookup(cl));\n+    }\n+\n+    private static void pressMemoryHard(Reference<?> ref) {\n+        try {\n+            var list = new ArrayList<>();\n+            while (!ref.refersTo(null)) {\n+                list.add(new byte[1024 * 1024 * 64]); \/\/ 64 MiB chunks\n+            }\n+        } catch (OutOfMemoryError e) {\n+            \/\/ release\n+        }\n+    }\n+}\n+\n+class TestClass implements Serializable {\n+}\n+\n+class AnotherTestClass implements Serializable {\n+}\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/ObjectStreamClassCaching.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.Constructor;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+\/* @test\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @build jdk.test.lib.util.ForceGC\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive\n+ * @run testng TestOSCClassLoaderLeak\n+ *\/\n+public class TestOSCClassLoaderLeak {\n+\n+    @Test\n+    public void testClassLoaderLeak() throws Exception {\n+        TestClassLoader myOwnClassLoader = new TestClassLoader();\n+        Class<?> loadClass = myOwnClassLoader.loadClass(\"ObjectStreamClass_MemoryLeakExample\");\n+        Constructor con = loadClass.getConstructor();\n+        con.setAccessible(true);\n+        Object objectStreamClass_MemoryLeakExample = con.newInstance();\n+        objectStreamClass_MemoryLeakExample.toString();\n+\n+        WeakReference<Object> myOwnClassLoaderWeakReference = new WeakReference<>(myOwnClassLoader);\n+        assertNotNull(myOwnClassLoaderWeakReference.get());\n+        objectStreamClass_MemoryLeakExample = null;\n+        myOwnClassLoader = null;\n+        loadClass = null;\n+        con = null;\n+        assertNotNull(myOwnClassLoaderWeakReference.get());\n+\n+        ForceGC gc = new ForceGC();\n+        assertTrue(gc.await(() -> myOwnClassLoaderWeakReference.get() == null));\n+    }\n+}\n+\n+class ObjectStreamClass_MemoryLeakExample {\n+    private static final ObjectStreamField[] fields = ObjectStreamClass.lookup(TestClass.class).getFields();\n+    public ObjectStreamClass_MemoryLeakExample() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Arrays.toString(fields);\n+    }\n+}\n+\n+class TestClassLoader extends ClassLoader {\n+\n+    @Override\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        if (name.equals(\"TestClass\") || name.equals(\"ObjectStreamClass_MemoryLeakExample\")) {\n+            byte[] bt = loadClassData(name);\n+            return defineClass(name, bt, 0, bt.length);\n+        } else {\n+            return super.loadClass(name);\n+        }\n+    }\n+\n+    private static byte[] loadClassData(String className) {\n+        ByteArrayOutputStream byteSt = new ByteArrayOutputStream();\n+        try (InputStream is = TestClassLoader.class.getClassLoader().getResourceAsStream(className.replace(\".\", \"\/\") + \".class\")) {\n+            int len = 0;\n+            while ((len = is.read()) != -1) {\n+                byteSt.write(len);\n+            }\n+        } catch (java.io.IOException e) {\n+            e.printStackTrace();\n+        }\n+        return byteSt.toByteArray();\n+    }\n+}\n+\n+class TestClass implements Serializable {\n+    public String x;\n+}\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/TestOSCClassLoaderLeak.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -56,12 +56,0 @@\n-\n-\/* @test\n- * @bug 8261160\n- * @summary Add a deserialization JFR event\n- * @build GlobalFilterTest SerialFilterTest\n- * @requires vm.hasJFR\n- * @run testng\/othervm\/policy=security.policy\n- *        -XX:StartFlightRecording:name=DeserializationEvent,dumponexit=true\n- *        -Djava.security.properties=${test.src}\/java.security-extra1\n- *        -Djava.security.debug=properties GlobalFilterTest\n- *\/\n-\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/GlobalFilterTest.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4750978\n- * @run main\/othervm\/timeout=300 ExecWithDir\n- * @summary Ensure that we can fork-and-exec repeatedly when a new working\n- *          directory is specified\n- *\/\n-\n-import java.io.File;\n-\n-public class ExecWithDir {\n-\n-    private static final int N = 500;\n-\n-    public static void main(String args[]) throws Exception {\n-        if (! UnixCommands.isUnix) {\n-            System.out.println(\"For UNIX only\");\n-            return;\n-        }\n-        UnixCommands.ensureCommandsAvailable(\"true\");\n-\n-        final String trueCmd = UnixCommands.findCommand(\"true\");\n-        File dir = new File(\".\");\n-        for (int i = 1; i <= N; i++) {\n-            System.out.print(i);\n-            System.out.print(\" e\");\n-            Process p = Runtime.getRuntime().exec(trueCmd, null, dir);\n-            System.out.print('w');\n-            int s = p.waitFor();\n-            System.out.println(\"x \" + s);\n-            if (s != 0) throw new Error(\"Unexpected return code \" + s);\n-\n-            \/\/ Avoid \"Too many open files\"\n-            p.getInputStream().close();\n-            p.getOutputStream().close();\n-            p.getErrorStream().close();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ExecWithDir.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8178380 8282444\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/ModulesInCustomFileSystem.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-        q.Hello.hello();\n+        q.r.Hello.hello();\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/m1\/p\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-    exports q;\n+    exports q.r;\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/m2\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-package q;\n+package q.r;\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/m2\/q\/r\/Hello.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/lang\/module\/customfs\/m2\/q\/Hello.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,11 @@\n-import java.nio.file.*;\n-import java.io.*;\n-import java.util.concurrent.*;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.FileStore;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -38,3 +46,3 @@\n-    private static final long FILE_SIZE_TO_COPY = 512L * 1024L * 1024L;\n-    private static final int DELAY_IN_MS = 500;\n-    private static final int DURATION_MAX_IN_MS = 5000;\n+    private static final long FILE_SIZE_TO_COPY = 1024L * 1024L * 1024L;\n+    private static final int INTERRUPT_DELAY_IN_MS = 50;\n+    private static final int CANCEL_DELAY_IN_MS = 10;\n@@ -77,0 +85,1 @@\n+\n@@ -78,1 +87,2 @@\n-            \/\/ copy source to target in main thread, interrupting it after a delay\n+            \/\/ copy source to target in main thread, interrupting it\n+            \/\/ after a delay\n@@ -80,1 +90,2 @@\n-            Future<?> wakeup = pool.schedule(new Runnable() {\n+            final CountDownLatch interruptLatch = new CountDownLatch(1);\n+            Future<?> wakeup = pool.submit(new Runnable() {\n@@ -82,0 +93,7 @@\n+                    try {\n+                        interruptLatch.await();\n+                        Thread.sleep(INTERRUPT_DELAY_IN_MS);\n+                    } catch (InterruptedException ignore) {\n+                    }\n+                    System.out.printf(\"Interrupting at %d ms...%n\",\n+                        System.currentTimeMillis());\n@@ -83,2 +101,2 @@\n-                }}, DELAY_IN_MS, TimeUnit.MILLISECONDS);\n-            System.out.println(\"Copying file...\");\n+                }\n+            });\n@@ -86,1 +104,3 @@\n-                long start = System.currentTimeMillis();\n+                interruptLatch.countDown();\n+                long theBeginning = System.currentTimeMillis();\n+                System.out.printf(\"Copying file at %d ms...%n\", theBeginning);\n@@ -88,3 +108,12 @@\n-                long duration = System.currentTimeMillis() - start;\n-                if (duration > DURATION_MAX_IN_MS)\n-                    throw new RuntimeException(\"Copy was not interrupted\");\n+                long theEnd = System.currentTimeMillis();\n+                System.out.printf(\"Done copying at %d ms...%n\", theEnd);\n+                long duration = theEnd - theBeginning;\n+\n+                \/\/ If the copy was interrupted the target file should have been\n+                \/\/ deleted, so if the file does not exist, then the copy must\n+                \/\/ have been interrupted without throwing an exception; if the\n+                \/\/ file exists, then the copy finished before being interrupted\n+                \/\/ so not throwing an exception is not considered a failure\n+                if (Files.notExists(target))\n+                    throw new RuntimeException(\"Copy was not interrupted in \" +\n+                        duration + \" ms\");\n@@ -95,1 +124,1 @@\n-                System.out.println(\"Copy failed (this is expected)\");\n+                System.out.println(\"Copy failed (this is expected).\");\n@@ -102,2 +131,3 @@\n-            \/\/ copy source to target via task in thread pool, interrupting it after\n-            \/\/ a delay using cancel(true)\n+            \/\/ copy source to target via task in thread pool, interrupting it\n+            \/\/ after a delay using cancel(true)\n+            CountDownLatch cancelLatch = new CountDownLatch(1);\n@@ -106,1 +136,3 @@\n-                    System.out.println(\"Copying file...\");\n+                    cancelLatch.countDown();\n+                    System.out.printf(\"Copying file at %d ms...%n\",\n+                        System.currentTimeMillis());\n@@ -109,0 +141,2 @@\n+                    System.out.printf(\"Done copying at %d ms...%n\",\n+                        System.currentTimeMillis());\n@@ -112,3 +146,13 @@\n-            Thread.sleep(DELAY_IN_MS);\n-            boolean cancelled = result.cancel(true);\n-            if (!cancelled)\n+            try {\n+                cancelLatch.await();\n+                Thread.sleep(CANCEL_DELAY_IN_MS);\n+            } catch (InterruptedException ignore) {\n+            }\n+            if (result.isDone())\n+                throw new RuntimeException(\"Copy finished before cancellation\");\n+            System.out.printf(\"Cancelling at %d ms...%n\",\n+                System.currentTimeMillis());\n+            boolean cancelled  = result.cancel(true);\n+            if (cancelled)\n+                System.out.println(\"Copy cancelled.\");\n+            else {\n@@ -116,1 +160,2 @@\n-            System.out.println(\"Copy cancelled.\");\n+                throw new RuntimeException(\"Copy was not cancelled\");\n+            }\n","filename":"test\/jdk\/java\/nio\/file\/Files\/InterruptCopy.java","additions":68,"deletions":23,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main GraphemeTest\n+ * @run testng GraphemeTest\n@@ -35,6 +35,3 @@\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Scanner;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.fail;\n@@ -44,1 +41,2 @@\n-    public static void main(String[] args) throws Throwable {\n+    @Test\n+    public static void testGraphemeBreakProperty() throws Throwable {\n@@ -46,0 +44,4 @@\n+    }\n+\n+    @Test\n+    public static void testEmojiData() throws Throwable {\n@@ -81,1 +83,1 @@\n-                                throw new RuntimeException(String.format(\n+                                fail(String.format(\n","filename":"test\/jdk\/java\/util\/regex\/GraphemeTest.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @requires os.maxMemory >= 5g\n- * @run main\/othervm NegativeArraySize -Xms5G -Xmx5G\n+ * @requires os.maxMemory >= 5g & vm.bits == 64\n+ * @run testng\/othervm -Xms5G -Xmx5G NegativeArraySize\n@@ -32,0 +32,3 @@\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertThrows;\n+\n@@ -35,6 +38,3 @@\n-    public static void main(String[] args) {\n-        try {\n-            Pattern.compile(\"\\\\Q\" + \"a\".repeat(42 + Integer.MAX_VALUE \/ 3));\n-            throw new AssertionError(\"expected to throw\");\n-        } catch (OutOfMemoryError expected) {\n-        }\n+    @Test\n+    public static void testNegativeArraySize() {\n+        assertThrows(OutOfMemoryError.class, () -> Pattern.compile(\"\\\\Q\" + \"a\".repeat(42 + Integer.MAX_VALUE \/ 3)));\n","filename":"test\/jdk\/java\/util\/regex\/NegativeArraySize.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @author Mike McCloskey\n@@ -39,1 +38,1 @@\n- * 8216332 8214245 8237599 8241055 8247546 8258259 8037397\n+ * 8216332 8214245 8237599 8241055 8247546 8258259 8037397 8269753\n@@ -44,1 +43,2 @@\n- * @run main RegExTest\n+ * @author Mike McCloskey\n+ * @run testng RegExTest\n@@ -48,8 +48,1 @@\n-import java.io.BufferedReader;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.InputStreamReader;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n+import java.io.*;\n@@ -77,0 +70,4 @@\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+\n@@ -79,0 +76,9 @@\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertNotSame;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+import static org.testng.Assert.expectThrows;\n+\n@@ -85,126 +91,1 @@\n-    private static Random generator = RandomFactory.getRandom();\n-    private static boolean failure = false;\n-    private static int failCount = 0;\n-    private static String firstFailure = null;\n-\n-    \/**\n-     * Main to interpret arguments and run several tests.\n-     *\n-     *\/\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Most of the tests are in a file\n-        processFile(\"TestCases.txt\");\n-        \/\/processFile(\"PerlCases.txt\");\n-        processFile(\"BMPTestCases.txt\");\n-        processFile(\"SupplementaryTestCases.txt\");\n-\n-        \/\/ These test many randomly generated char patterns\n-        bm();\n-        slice();\n-\n-        \/\/ These are hard to put into the file\n-        escapes();\n-        blankInput();\n-\n-        \/\/ Substitition tests on randomly generated sequences\n-        globalSubstitute();\n-        stringbufferSubstitute();\n-        stringbuilderSubstitute();\n-\n-        substitutionBasher();\n-        substitutionBasher2();\n-\n-        \/\/ Canonical Equivalence\n-        ceTest();\n-\n-        \/\/ Anchors\n-        anchorTest();\n-\n-        \/\/ boolean match calls\n-        matchesTest();\n-        lookingAtTest();\n-\n-        \/\/ Pattern API\n-        patternMatchesTest();\n-\n-        \/\/ Misc\n-        lookbehindTest();\n-        nullArgumentTest();\n-        backRefTest();\n-        groupCaptureTest();\n-        caretTest();\n-        charClassTest();\n-        emptyPatternTest();\n-        findIntTest();\n-        group0Test();\n-        longPatternTest();\n-        octalTest();\n-        ampersandTest();\n-        negationTest();\n-        splitTest();\n-        appendTest();\n-        caseFoldingTest();\n-        commentsTest();\n-        unixLinesTest();\n-        replaceFirstTest();\n-        gTest();\n-        zTest();\n-        serializeTest();\n-        reluctantRepetitionTest();\n-        multilineDollarTest();\n-        dollarAtEndTest();\n-        caretBetweenTerminatorsTest();\n-        \/\/ This RFE rejected in Tiger numOccurrencesTest();\n-        javaCharClassTest();\n-        nonCaptureRepetitionTest();\n-        notCapturedGroupCurlyMatchTest();\n-        escapedSegmentTest();\n-        literalPatternTest();\n-        literalReplacementTest();\n-        regionTest();\n-        toStringTest();\n-        negatedCharClassTest();\n-        findFromTest();\n-        boundsTest();\n-        unicodeWordBoundsTest();\n-        caretAtEndTest();\n-        wordSearchTest();\n-        hitEndTest();\n-        toMatchResultTest();\n-        toMatchResultTest2();\n-        surrogatesInClassTest();\n-        removeQEQuotingTest();\n-        namedGroupCaptureTest();\n-        nonBmpClassComplementTest();\n-        unicodePropertiesTest();\n-        unicodeHexNotationTest();\n-        unicodeClassesTest();\n-        unicodeCharacterNameTest();\n-        horizontalAndVerticalWSTest();\n-        linebreakTest();\n-        branchTest();\n-        groupCurlyNotFoundSuppTest();\n-        groupCurlyBackoffTest();\n-        patternAsPredicate();\n-        patternAsMatchPredicate();\n-        invalidFlags();\n-        embeddedFlags();\n-        grapheme();\n-        expoBacktracking();\n-        invalidGroupName();\n-        illegalRepetitionRange();\n-        surrogatePairWithCanonEq();\n-        lineBreakWithQuantifier();\n-        caseInsensitivePMatch();\n-        surrogatePairOverlapRegion();\n-        droppedClassesWithIntersection();\n-\n-\n-        if (failure) {\n-            throw new\n-                RuntimeException(\"RegExTest failed, 1st failure: \" +\n-                                 firstFailure);\n-        } else {\n-            System.err.println(\"OKAY: All tests passed.\");\n-        }\n-    }\n+    private static final Random generator = RandomFactory.getRandom();\n@@ -215,1 +96,2 @@\n-        StringBuffer buf = new StringBuffer(length);\n+\n+        StringBuilder buf = new StringBuilder(length);\n@@ -225,2 +107,1 @@\n-        if (!m.group().equals(expected))\n-            failCount++;\n+        assertEquals(m.group(), expected);\n@@ -231,2 +112,1 @@\n-        if (m.group().equals(result) != expected)\n-            failCount++;\n+        assertEquals(m.group().equals(result), expected);\n@@ -236,2 +116,1 @@\n-        if (p.matcher(s).find() != expected)\n-            failCount++;\n+        assertEquals(p.matcher(s).find(), expected);\n@@ -242,2 +121,1 @@\n-        if (matcher.find() != expected)\n-            failCount++;\n+        assertEquals(matcher.find(), expected);\n@@ -251,2 +129,1 @@\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n@@ -260,2 +137,1 @@\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n@@ -272,18 +148,14 @@\n-            check(pattern, input, false);\n-    }\n-\n-    private static void report(String testName) {\n-        int spacesToAdd = 30 - testName.length();\n-        StringBuffer paddedNameBuffer = new StringBuffer(testName);\n-        for (int i=0; i<spacesToAdd; i++)\n-            paddedNameBuffer.append(\" \");\n-        String paddedName = paddedNameBuffer.toString();\n-        System.err.println(paddedName + \": \" +\n-                           (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n-        if (failCount > 0) {\n-            failure = true;\n-\n-            if (firstFailure == null) {\n-                firstFailure = testName;\n-            }\n-        }\n+            check(pattern, input, expected);\n+    }\n+\n+    private static void check(Pattern p, String s, String g, String expected) {\n+        Matcher m = p.matcher(s);\n+        m.find();\n+        assertFalse(!m.group(g).equals(expected) ||\n+                s.charAt(m.start(g)) != expected.charAt(0) ||\n+                s.charAt(m.end(g) - 1) != expected.charAt(expected.length() - 1));\n+    }\n+    private static void checkReplaceFirst(String p, String s, String r, String expected)\n+    {\n+        assertEquals(expected, Pattern.compile(p).matcher(s).replaceFirst(r));\n+    }\n@@ -291,1 +163,8 @@\n-        failCount = 0;\n+    private static void checkReplaceAll(String p, String s, String r, String expected)\n+    {\n+        assertEquals(expected, Pattern.compile(p).matcher(s).replaceAll(r));\n+    }\n+\n+    private static void checkExpectedFail(String p) {\n+        assertThrows(PatternSyntaxException.class, () ->\n+                Pattern.compile(p));\n@@ -299,1 +178,1 @@\n-    private static String toSupplementaries(String s) {\n+    public static String toSupplementaries(String s) {\n@@ -301,1 +180,1 @@\n-        StringBuffer sb = new StringBuffer(length * 2);\n+        StringBuilder sb = new StringBuilder(length * 2);\n@@ -328,0 +207,5 @@\n+    \/\/Following three tests execute from a file.\n+    @Test\n+    public static void processTestCases() throws IOException {\n+        processFile(\"TestCases.txt\");\n+    }\n@@ -329,10 +213,8 @@\n-    \/\/ This is for bug 6178785\n-    \/\/ Test if an expected NPE gets thrown when passing in a null argument\n-    private static boolean check(Runnable test) {\n-        try {\n-            test.run();\n-            failCount++;\n-            return false;\n-        } catch (NullPointerException npe) {\n-            return true;\n-        }\n+    @Test\n+    public static void processBMPTestCases() throws IOException {\n+        processFile(\"BMPTestCases.txt\");\n+    }\n+\n+    @Test\n+    public static void processSupplementaryTestCases() throws IOException {\n+        processFile(\"SupplementaryTestCases.txt\");\n@@ -341,7 +223,10 @@\n-    private static void nullArgumentTest() {\n-        check(() -> Pattern.compile(null));\n-        check(() -> Pattern.matches(null, null));\n-        check(() -> Pattern.matches(\"xyz\", null));\n-        check(() -> Pattern.quote(null));\n-        check(() -> Pattern.compile(\"xyz\").split(null));\n-        check(() -> Pattern.compile(\"xyz\").matcher(null));\n+\n+    @Test\n+    public static void nullArgumentTest() {\n+\n+        assertThrows(NullPointerException.class, () -> Pattern.compile(null));\n+        assertThrows(NullPointerException.class, () -> Pattern.matches(null, null));\n+        assertThrows(NullPointerException.class, () -> Pattern.matches(\"xyz\", null));\n+        assertThrows(NullPointerException.class, () -> Pattern.quote(null));\n+        assertThrows(NullPointerException.class, () -> Pattern.compile(\"xyz\").split(null));\n+        assertThrows(NullPointerException.class, () -> Pattern.compile(\"xyz\").matcher(null));\n@@ -351,10 +236,10 @@\n-        check(() -> m.appendTail((StringBuffer) null));\n-        check(() -> m.appendTail((StringBuilder)null));\n-        check(() -> m.replaceAll((String) null));\n-        check(() -> m.replaceAll((Function<MatchResult, String>)null));\n-        check(() -> m.replaceFirst((String)null));\n-        check(() -> m.replaceFirst((Function<MatchResult, String>) null));\n-        check(() -> m.appendReplacement((StringBuffer)null, null));\n-        check(() -> m.appendReplacement((StringBuilder)null, null));\n-        check(() -> m.reset(null));\n-        check(() -> Matcher.quoteReplacement(null));\n+        assertThrows(NullPointerException.class, () -> m.appendTail((StringBuffer) null));\n+        assertThrows(NullPointerException.class, () -> m.appendTail((StringBuilder)null));\n+        assertThrows(NullPointerException.class, () -> m.replaceAll((String) null));\n+        assertThrows(NullPointerException.class, () -> m.replaceAll((Function<MatchResult, String>)null));\n+        assertThrows(NullPointerException.class, () -> m.replaceFirst((String)null));\n+        assertThrows(NullPointerException.class, () -> m.replaceFirst((Function<MatchResult, String>) null));\n+        assertThrows(NullPointerException.class, () -> m.appendReplacement((StringBuffer)null, null));\n+        assertThrows(NullPointerException.class, () -> m.appendReplacement((StringBuilder)null, null));\n+        assertThrows(NullPointerException.class, () -> m.reset(null));\n+        assertThrows(NullPointerException.class, () -> Matcher.quoteReplacement(null));\n@@ -363,1 +248,0 @@\n-        report(\"Null Argument\");\n@@ -368,1 +252,2 @@\n-    private static void surrogatesInClassTest() throws Exception {\n+    @Test\n+    public static void surrogatesInClassTest() {\n@@ -371,2 +256,0 @@\n-        if (!matcher.find())\n-            failCount++;\n@@ -374,1 +257,1 @@\n-        report(\"Surrogate pair in Unicode escape\");\n+        assertTrue(matcher.find(), \"Surrogate pair in Unicode escape\");\n@@ -381,1 +264,2 @@\n-    private static void removeQEQuotingTest() throws Exception {\n+    @Test\n+    public static void removeQEQuotingTest() {\n@@ -385,2 +269,0 @@\n-        if (!matcher.find())\n-            failCount++;\n@@ -388,1 +270,1 @@\n-        report(\"Remove Q\/E Quoting\");\n+        assertTrue(matcher.find(), \"Remove Q\/E Quoting\");\n@@ -394,1 +276,2 @@\n-    private static void toMatchResultTest() throws Exception {\n+    @Test\n+    public static void toMatchResultTest() {\n@@ -399,0 +282,1 @@\n+\n@@ -401,2 +285,2 @@\n-        if (mr == matcher)\n-            failCount++;\n+        assertNotSame(mr, matcher, \"Matcher toMatchResult is identical object\");\n+\n@@ -404,2 +288,1 @@\n-        if (matcherStart1 != resultStart1)\n-            failCount++;\n+        assertEquals(matcherStart1, resultStart1, \"equal matchers don't have equal start indices\");\n@@ -407,0 +290,1 @@\n+\n@@ -409,4 +293,2 @@\n-        if (matcherStart2 == resultStart2)\n-            failCount++;\n-        if (resultStart1 != resultStart2)\n-            failCount++;\n+        assertNotEquals(matcherStart2, resultStart2, \"Matcher2 and Result2 should not be equal\");\n+        assertEquals(resultStart1, resultStart2, \"Second match result should have the same state\");\n@@ -414,22 +296,2 @@\n-        if (mr == mr2)\n-            failCount++;\n-        if (mr2.start() != matcherStart2)\n-            failCount++;\n-        report(\"toMatchResult is a copy\");\n-    }\n-\n-    private static void checkExpectedISE(Runnable test) {\n-        try {\n-            test.run();\n-            failCount++;\n-        } catch (IllegalStateException x) {\n-        } catch (IndexOutOfBoundsException xx) {\n-            failCount++;\n-        }\n-    }\n-\n-    private static void checkExpectedIOOE(Runnable test) {\n-        try {\n-            test.run();\n-            failCount++;\n-        } catch (IndexOutOfBoundsException x) {}\n+        assertNotSame(mr, mr2, \"Second Matcher copy should not be identical to the first.\");\n+        assertEquals(mr2.start(), matcherStart2, \"mr2 index should equal matcher index\");\n@@ -440,1 +302,2 @@\n-    private static void toMatchResultTest2() throws Exception {\n+    @Test\n+    public static void toMatchResultTest2() {\n@@ -445,6 +308,6 @@\n-        checkExpectedISE(() -> mr.start());\n-        checkExpectedISE(() -> mr.start(2));\n-        checkExpectedISE(() -> mr.end());\n-        checkExpectedISE(() -> mr.end(2));\n-        checkExpectedISE(() -> mr.group());\n-        checkExpectedISE(() -> mr.group(2));\n+        assertThrows(IllegalStateException.class, mr::start);\n+        assertThrows(IllegalStateException.class, () -> mr.start(2));\n+        assertThrows(IllegalStateException.class, mr::end);\n+        assertThrows(IllegalStateException.class, () -> mr.end(2));\n+        assertThrows(IllegalStateException.class, mr::group);\n+        assertThrows(IllegalStateException.class, () -> mr.group(2));\n@@ -455,5 +318,3 @@\n-        checkExpectedIOOE(() -> mr2.start(2));\n-        checkExpectedIOOE(() -> mr2.end(2));\n-        checkExpectedIOOE(() -> mr2.group(2));\n-\n-        report(\"toMatchResult2 appropriate exceptions\");\n+        assertThrows(IndexOutOfBoundsException.class, () -> mr2.start(2));\n+        assertThrows(IndexOutOfBoundsException.class, () -> mr2.end(2));\n+        assertThrows(IndexOutOfBoundsException.class, () -> mr2.group(2));\n@@ -464,1 +325,2 @@\n-    private static void hitEndTest() throws Exception {\n+    @Test\n+    public static void hitEndTest() {\n@@ -469,2 +331,1 @@\n-        if (m.hitEnd())\n-            failCount++;\n+        assertFalse(m.hitEnd(), \"Matcher should not be at end of sequence\");\n@@ -473,2 +334,1 @@\n-        if (!m.hitEnd())\n-            failCount++;\n+        assertTrue(m.hitEnd(), \"Matcher should be at the end of sequence\");\n@@ -484,2 +344,1 @@\n-            if (m.hitEnd())\n-                failCount++;\n+            assertFalse(m.hitEnd(), \"Slice node test\");\n@@ -488,2 +347,1 @@\n-            if (!m.hitEnd())\n-                failCount++;\n+            assertTrue(m.hitEnd(), \"Slice node test\");\n@@ -496,2 +354,1 @@\n-        if (!m.hitEnd())\n-            failCount++;\n+        assertTrue(m.hitEnd(), \"Boyer-Moore node test\");\n@@ -502,2 +359,1 @@\n-        if (!m.hitEnd())\n-            failCount++;\n+        assertTrue(m.hitEnd(), \"Boyer-More node test\");\n@@ -509,2 +365,1 @@\n-        if (m.hitEnd())\n-            failCount++;\n+        assertFalse(m.hitEnd());\n@@ -514,2 +369,1 @@\n-        if (!m.hitEnd())\n-            failCount++;\n+        assertTrue(m.hitEnd());\n@@ -519,4 +373,1 @@\n-        if (m.hitEnd())\n-            failCount++;\n-\n-        report(\"hitEnd\");\n+        assertFalse(m.hitEnd());\n@@ -527,2 +378,3 @@\n-    private static void wordSearchTest() throws Exception {\n-        String testString = new String(\"word1 word2 word3\");\n+    @Test\n+    public static void wordSearchTest() {\n+        String testString = \"word1 word2 word3\";\n@@ -532,1 +384,1 @@\n-        int start = 0;\n+        int start;\n@@ -544,2 +396,1 @@\n-            if (!testString.substring(start, position-1).startsWith(\"word\"))\n-                failCount++;\n+            assertTrue(testString.substring(start, position-1).startsWith(\"word\"));\n@@ -547,1 +398,0 @@\n-        report(\"Customer word search\");\n@@ -551,1 +401,2 @@\n-    private static void caretAtEndTest() throws Exception {\n+    @Test\n+    public static void caretAtEndTest() {\n@@ -559,1 +410,0 @@\n-        report(\"Caret at end\");\n@@ -565,1 +415,2 @@\n-    private static void unicodeWordBoundsTest() throws Exception {\n+    @Test\n+    public static void unicodeWordBoundsTest() {\n@@ -596,2 +447,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -601,2 +451,0 @@\n-\n-        report(\"Unicode word boundary\");\n@@ -606,1 +454,1 @@\n-                                       int b) throws Exception\n+                                       int b)\n@@ -610,2 +458,1 @@\n-        if (matcher.start() != a)\n-            failCount++;\n+        assertEquals(matcher.start(), a);\n@@ -613,2 +460,1 @@\n-        if (matcher.start() != b)\n-            failCount++;\n+        assertEquals(matcher.start(), b);\n@@ -618,2 +464,2 @@\n-    static void check(String regex, String input, String[] expected) {\n-        List<String> result = new ArrayList<String>();\n+    private static void check(String regex, String input, String[] expected) {\n+        List<String> result = new ArrayList<>();\n@@ -625,2 +471,1 @@\n-        if (!Arrays.asList(expected).equals(result))\n-            failCount++;\n+        assertEquals(Arrays.asList(expected), result);\n@@ -629,1 +474,2 @@\n-    private static void lookbehindTest() throws Exception {\n+    @Test\n+    public static void lookbehindTest() {\n@@ -662,1 +508,0 @@\n-        report(\"Lookbehind\");\n@@ -668,1 +513,2 @@\n-    private static void boundsTest() throws Exception {\n+    @Test\n+    public static void boundsTest() {\n@@ -673,2 +519,2 @@\n-        if (matcher.find())\n-            failCount++;\n+\n+        assertFalse(matcher.find());\n@@ -676,2 +522,2 @@\n-        if (matcher.find())\n-            failCount++;\n+\n+        assertFalse(matcher.find());\n@@ -679,2 +525,2 @@\n-        if (!matcher.find())\n-            failCount++;\n+\n+        assertTrue(matcher.find());\n@@ -683,2 +529,2 @@\n-        if (!matcher.find())\n-            failCount++;\n+\n+        assertTrue(matcher.find());\n@@ -687,2 +533,2 @@\n-        if (!matcher.find())\n-            failCount++;\n+\n+        assertTrue(matcher.find());\n@@ -691,2 +537,2 @@\n-        if (!matcher.find())\n-            failCount++;\n+\n+        assertTrue(matcher.find());\n@@ -694,2 +540,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -702,2 +547,2 @@\n-        if (matcher.find())\n-            failCount++;\n+\n+        assertFalse(matcher.find());\n@@ -706,2 +551,2 @@\n-        if (matcher.find())\n-            failCount++;\n+\n+        assertFalse(matcher.find());\n@@ -711,2 +556,2 @@\n-        if (!matcher.find())\n-            failCount++;\n+\n+        assertTrue(matcher.find());\n@@ -715,2 +560,1 @@\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n@@ -718,1 +562,0 @@\n-        report(\"Region bounds transparency\");\n@@ -722,1 +565,2 @@\n-    private static void findFromTest() throws Exception {\n+    @Test\n+    public static void findFromTest() {\n@@ -726,7 +570,3 @@\n-        if (!match.find())\n-            failCount++;\n-        if (match.find())\n-            failCount++;\n-        if (match.find())\n-            failCount++;\n-        report(\"Check for alternating find\");\n+        assertTrue(match.find());\n+        assertFalse(match.find());\n+        assertFalse(match.find());\n@@ -736,1 +576,2 @@\n-    private static void negatedCharClassTest() throws Exception {\n+    @Test\n+    public static void negatedCharClassTest() {\n@@ -739,2 +580,2 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n+\n@@ -743,2 +584,2 @@\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n+\n@@ -746,2 +587,1 @@\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n@@ -749,5 +589,3 @@\n-        String result[] = s.split(\"[^fr]\");\n-        if (!result[0].equals(\"f\"))\n-            failCount++;\n-        if (!result[1].equals(\"r\"))\n-            failCount++;\n+        String[] result = s.split(\"[^fr]\");\n+        assertEquals(result[0], \"f\");\n+        assertEquals(result[1], \"r\");\n@@ -756,4 +594,2 @@\n-        if (!result[0].equals(\"f\"))\n-            failCount++;\n-        if (!result[1].equals(\"r\"))\n-            failCount++;\n+        assertEquals(result[0], \"f\");\n+        assertEquals(result[1], \"r\");\n@@ -764,2 +600,1 @@\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n@@ -767,2 +602,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -770,2 +604,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -773,2 +606,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -776,2 +608,1 @@\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n@@ -782,2 +613,1 @@\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n@@ -785,2 +615,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -788,2 +617,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -791,2 +619,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -794,4 +621,1 @@\n-        if (!matcher.find())\n-            failCount++;\n-\n-        report(\"Negated Character Class\");\n+        assertTrue(matcher.find());\n@@ -801,1 +625,2 @@\n-    private static void toStringTest() throws Exception {\n+    @Test\n+    public static void toStringTest() {\n@@ -803,2 +628,1 @@\n-        if (pattern.toString() != \"b+\")\n-            failCount++;\n+        assertEquals(pattern.toString(), \"b+\");\n@@ -808,1 +632,1 @@\n-        matcherString = matcher.toString(); \/\/ unspecified\n+        matcher.toString(); \/\/ unspecified\n@@ -810,1 +634,1 @@\n-        matcherString = matcher.toString(); \/\/ unspecified\n+        matcher.toString(); \/\/ unspecified\n@@ -812,2 +636,1 @@\n-        matcherString = matcher.toString(); \/\/ unspecified\n-        report(\"toString\");\n+        matcher.toString(); \/\/ unspecified\n@@ -817,1 +640,2 @@\n-    private static void literalPatternTest() throws Exception {\n+    @Test\n+    public static void literalPatternTest() {\n@@ -877,0 +701,1 @@\n+        \/\/Note: Possible issue\n@@ -925,0 +750,1 @@\n+        \/\/Note: Possible issue\n@@ -928,2 +754,0 @@\n-\n-        report(\"Literal pattern\");\n@@ -934,1 +758,2 @@\n-    private static void literalReplacementTest() throws Exception {\n+    @Test\n+    public static void literalReplacementTest() {\n@@ -941,2 +766,1 @@\n-        if (!result.equals(\"zzzabczzz\"))\n-            failCount++;\n+        assertEquals(result, \"zzzabczzz\");\n@@ -945,1 +769,1 @@\n-        String literalReplacement = matcher.quoteReplacement(replaceTest);\n+        String literalReplacement = Matcher.quoteReplacement(replaceTest);\n@@ -947,2 +771,1 @@\n-        if (!result.equals(\"zzz$0zzz\"))\n-            failCount++;\n+        assertEquals(result, \"zzz$0zzz\");\n@@ -952,1 +775,1 @@\n-        literalReplacement = matcher.quoteReplacement(replaceTest);\n+        literalReplacement = Matcher.quoteReplacement(replaceTest);\n@@ -954,2 +777,1 @@\n-        if (!result.equals(\"zzz\\\\t$\\\\$zzz\"))\n-            failCount++;\n+        assertEquals(result, \"zzz\\\\t$\\\\$zzz\");\n@@ -962,2 +784,1 @@\n-        if (!result.equals(toSupplementaries(\"zzzabczzz\")))\n-            failCount++;\n+        assertEquals(result, toSupplementaries(\"zzzabczzz\"));\n@@ -966,1 +787,1 @@\n-        literalReplacement = matcher.quoteReplacement(replaceTest);\n+        literalReplacement = Matcher.quoteReplacement(replaceTest);\n@@ -968,2 +789,1 @@\n-        if (!result.equals(toSupplementaries(\"zzz$0zzz\")))\n-            failCount++;\n+        assertEquals(result, toSupplementaries(\"zzz$0zzz\"));\n@@ -973,1 +793,1 @@\n-        literalReplacement = matcher.quoteReplacement(replaceTest);\n+        literalReplacement = Matcher.quoteReplacement(replaceTest);\n@@ -975,2 +795,1 @@\n-        if (!result.equals(toSupplementaries(\"zzz\\\\t$\\\\$zzz\")))\n-            failCount++;\n+        assertEquals(result, toSupplementaries(\"zzz\\\\t$\\\\$zzz\"));\n@@ -980,15 +799,2 @@\n-        try {\n-            \"\\uac00\".replaceAll(\"\\uac00\", \"$\");\n-            failCount++;\n-        } catch (IllegalArgumentException iie) {\n-        } catch (Exception e) {\n-            failCount++;\n-        }\n-        try {\n-            \"\\uac00\".replaceAll(\"\\uac00\", \"\\\\\");\n-            failCount++;\n-        } catch (IllegalArgumentException iie) {\n-        } catch (Exception e) {\n-            failCount++;\n-        }\n-        report(\"Literal replacement\");\n+        assertThrows(IllegalArgumentException.class, () -> \"\\uac00\".replaceAll(\"\\uac00\", \"$\"));\n+        assertThrows(IllegalArgumentException.class, () -> \"\\uac00\".replaceAll(\"\\uac00\", \"\\\\\"));\n@@ -998,1 +804,2 @@\n-    private static void regionTest() throws Exception {\n+    @Test\n+    public static void regionTest() {\n@@ -1003,4 +810,2 @@\n-        if (!matcher.find())\n-            failCount++;\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n+        assertTrue(matcher.find());\n@@ -1008,2 +813,1 @@\n-        if (!matcher.find())\n-           failCount++;\n+        assertTrue(matcher.find());\n@@ -1011,2 +815,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1014,2 +817,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1027,2 +829,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -1030,2 +831,1 @@\n-        if (!matcher.find())\n-           failCount++;\n+        assertTrue(matcher.find());\n@@ -1034,2 +834,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1041,4 +840,2 @@\n-        if (!matcher.find())\n-            failCount++;\n-        if (!matcher.find())\n-            failCount++;\n+        assertTrue(matcher.find());\n+        assertTrue(matcher.find());\n@@ -1046,2 +843,1 @@\n-        if (!matcher.find())\n-           failCount++;\n+        assertTrue(matcher.find());\n@@ -1049,2 +845,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1052,2 +847,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1055,2 +849,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1058,2 +851,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1061,1 +853,1 @@\n-        expectRegionFail(matcher, 1*2, -1);\n+        expectRegionFail(matcher, 2, -1);\n@@ -1063,1 +855,1 @@\n-        expectRegionFail(matcher, -1, 1*2);\n+        expectRegionFail(matcher, -1, 2);\n@@ -1071,2 +863,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -1074,2 +865,1 @@\n-        if (!matcher.find())\n-           failCount++;\n+        assertTrue(matcher.find());\n@@ -1077,2 +867,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1080,2 +869,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1084,2 +872,1 @@\n-        if (matcher.find())\n-           failCount++;\n+        assertFalse(matcher.find());\n@@ -1091,10 +878,2 @@\n-        if (matcher.find()) {\n-            failCount++;\n-            System.out.println(\"Matched a surrogate pair\" +\n-                    \" that crosses border of region\");\n-        }\n-        if (!matcher.hitEnd()) {\n-            failCount++;\n-            System.out.println(\"Expected to hit the end when\" +\n-                    \" matching a surrogate pair crossing region\");\n-        }\n+        assertFalse(matcher.find(), \"Matched a surrogate pair\" +\n+                \" that crosses border of region\");\n@@ -1102,1 +881,2 @@\n-        report(\"Regions\");\n+        assertTrue(matcher.hitEnd(), \"Expected to hit the end when\" +\n+                \" matching a surrogate pair crossing region\");\n@@ -1108,0 +888,1 @@\n+\n@@ -1110,4 +891,2 @@\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Correct result\n-        } catch (IllegalStateException ise) {\n+            fail();\n+        } catch (IndexOutOfBoundsException | IllegalStateException ioobe) {\n@@ -1115,0 +894,2 @@\n+        } catch (Exception e) {\n+            fail();\n@@ -1119,1 +900,2 @@\n-    private static void escapedSegmentTest() throws Exception {\n+    @Test\n+    public static void escapedSegmentTest() {\n@@ -1139,2 +921,0 @@\n-\n-        report(\"Escaped segment\");\n@@ -1144,1 +924,2 @@\n-    private static void nonCaptureRepetitionTest() throws Exception {\n+    @Test\n+    public static void nonCaptureRepetitionTest() {\n@@ -1160,1 +941,1 @@\n-        for (int i = 0; i < patterns.length; i++) {\n+        for (String pattern : patterns) {\n@@ -1162,1 +943,1 @@\n-            check(patterns[i], 0, input, input, true);\n+            check(pattern, 0, input, input, true);\n@@ -1164,1 +945,1 @@\n-            Pattern p = Pattern.compile(patterns[i]);\n+            Pattern p = Pattern.compile(pattern);\n@@ -1167,6 +948,2 @@\n-            if (m.matches()) {\n-                if (!m.group(0).equals(input))\n-                    failCount++;\n-            } else {\n-                failCount++;\n-            }\n+            assertTrue(m.matches());\n+            assertEquals(m.group(0), input);\n@@ -1174,2 +951,0 @@\n-\n-        report(\"Non capturing repetition\");\n@@ -1179,1 +954,2 @@\n-    private static void notCapturedGroupCurlyMatchTest() throws Exception {\n+    @Test\n+    public static void notCapturedGroupCurlyMatchTest() {\n@@ -1182,1 +958,2 @@\n-        if (!matcher.matches() ||\n+\n+        boolean condition = !matcher.matches() ||\n@@ -1184,4 +961,3 @@\n-             !matcher.group(2).equals(\"abcd\")) {\n-            failCount++;\n-        }\n-        report(\"Not captured GroupCurly\");\n+             !matcher.group(2).equals(\"abcd\");\n+\n+        assertFalse(condition);\n@@ -1191,1 +967,2 @@\n-    private static void javaCharClassTest() throws Exception {\n+    @Test\n+    public static void javaCharClassTest() {\n@@ -1247,2 +1024,0 @@\n-\n-        report(\"Java character classes\");\n@@ -1272,1 +1047,2 @@\n-    private static void caretBetweenTerminatorsTest() throws Exception {\n+    @Test\n+    public static void caretBetweenTerminatorsTest() {\n@@ -1325,2 +1101,0 @@\n-\n-        report(\"Caret between terminators\");\n@@ -1330,1 +1104,2 @@\n-    private static void dollarAtEndTest() throws Exception {\n+    @Test\n+    public static void dollarAtEndTest() {\n@@ -1369,2 +1144,0 @@\n-\n-        report(\"Dollar at End\");\n@@ -1374,1 +1147,2 @@\n-    private static void multilineDollarTest() throws Exception {\n+    @Test\n+    public static void multilineDollarTest() {\n@@ -1378,2 +1152,1 @@\n-        if (matcher.start(0) != 9)\n-            failCount++;\n+        assertEquals(matcher.start(), 9);\n@@ -1381,2 +1154,1 @@\n-        if (matcher.start(0) != 20)\n-            failCount++;\n+        assertEquals(matcher.start(0), 20);\n@@ -1387,2 +1159,1 @@\n-        if (matcher.start(0) != 9*2)\n-            failCount++;\n+        assertEquals(matcher.start(0), 9*2);\n@@ -1390,4 +1161,1 @@\n-        if (matcher.start(0) != 20*2)\n-            failCount++;\n-\n-        report(\"Multiline Dollar\");\n+        assertEquals(matcher.start(0), 20*2);\n@@ -1396,1 +1164,2 @@\n-    private static void reluctantRepetitionTest() throws Exception {\n+    @Test\n+    public static void reluctantRepetitionTest() {\n@@ -1414,2 +1183,0 @@\n-\n-        report(\"Reluctant Repetition\");\n@@ -1418,1 +1185,1 @@\n-    private static Pattern serializedPattern(Pattern p) throws Exception {\n+    public static Pattern serializedPattern(Pattern p) throws Exception {\n@@ -1429,1 +1196,2 @@\n-    private static void serializeTest() throws Exception {\n+    @Test\n+    public static void serializeTest() throws Exception {\n@@ -1435,4 +1203,2 @@\n-        if (!matcher.matches())\n-            failCount++;\n-        if (matcher.groupCount() != 1)\n-            failCount++;\n+        assertTrue(matcher.matches());\n+        assertEquals(matcher.groupCount(), 1);\n@@ -1442,6 +1208,2 @@\n-        if (!serializedPattern.matcher(\"Ab\").matches())\n-            failCount++;\n-        if (serializedPattern.matcher(\"AB\").matches())\n-            failCount++;\n-\n-        report(\"Serialization\");\n+        assertTrue(serializedPattern.matcher(\"Ab\").matches());\n+        assertFalse(serializedPattern.matcher(\"AB\").matches());\n@@ -1450,1 +1212,2 @@\n-    private static void gTest() {\n+    @Test\n+    public static void gTest() {\n@@ -1456,2 +1219,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -1462,2 +1224,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -1467,2 +1228,1 @@\n-        if (!matcher.find(1))\n-            failCount++;\n+        assertTrue(matcher.find(1));\n@@ -1470,4 +1230,1 @@\n-        if (matcher.find())\n-            failCount++;\n-\n-        report(\"\\\\G\");\n+        assertFalse(matcher.find());\n@@ -1476,1 +1233,2 @@\n-    private static void zTest() {\n+    @Test\n+    public static void zTest() {\n@@ -1498,2 +1256,0 @@\n-\n-        report(\"\\\\Z\");\n@@ -1502,1 +1258,2 @@\n-    private static void replaceFirstTest() {\n+    @Test\n+    public static void replaceFirstTest() {\n@@ -1505,2 +1262,1 @@\n-        if (!matcher.replaceFirst(\"test\").equals(\"testzzzabcczzzabccc\"))\n-            failCount++;\n+        assertEquals(matcher.replaceFirst(\"test\"), \"testzzzabcczzzabccc\");\n@@ -1509,2 +1265,1 @@\n-        if (!matcher.replaceFirst(\"test\").equals(\"zzztestzzzabcczzzabccczzz\"))\n-            failCount++;\n+        assertEquals(matcher.replaceFirst(\"test\"), \"zzztestzzzabcczzzabccczzz\");\n@@ -1514,2 +1269,1 @@\n-        if (!result.equals(\"zzzabzzzabcczzzabccczzz\"))\n-            failCount++;\n+        assertEquals(result,\"zzzabzzzabcczzzabccczzz\");\n@@ -1519,2 +1273,1 @@\n-        if (!result.equals(\"zzzccczzzabcczzzabccczzz\"))\n-            failCount++;\n+        assertEquals(result, \"zzzccczzzabcczzzabccczzz\");\n@@ -1524,2 +1277,1 @@\n-        if (!matcher.replaceFirst(\"test\").equals(\"test\"))\n-            failCount++;\n+        assertEquals(matcher.replaceFirst(\"test\"), \"test\");\n@@ -1529,2 +1281,1 @@\n-        if (!matcher.replaceFirst(\"test\").equals(\"zzztest\"))\n-            failCount++;\n+        assertEquals(matcher.replaceFirst(\"test\"), \"zzztest\");\n@@ -1535,3 +1286,2 @@\n-        if (!matcher.replaceFirst(toSupplementaries(\"test\"))\n-                .equals(toSupplementaries(\"testzzzabcczzzabccc\")))\n-            failCount++;\n+        result = matcher.replaceFirst(toSupplementaries(\"test\"));\n+        assertEquals(result, toSupplementaries(\"testzzzabcczzzabccc\"));\n@@ -1540,3 +1290,2 @@\n-        if (!matcher.replaceFirst(toSupplementaries(\"test\")).\n-            equals(toSupplementaries(\"zzztestzzzabcczzzabccczzz\")))\n-            failCount++;\n+        result = matcher.replaceFirst(toSupplementaries(\"test\"));\n+        assertEquals(result, toSupplementaries(\"zzztestzzzabcczzzabccczzz\"));\n@@ -1546,2 +1295,1 @@\n-        if (!result.equals(toSupplementaries(\"zzzabzzzabcczzzabccczzz\")))\n-            failCount++;\n+        assertEquals(result, toSupplementaries(\"zzzabzzzabcczzzabccczzz\"));\n@@ -1551,2 +1299,1 @@\n-        if (!result.equals(toSupplementaries(\"zzzccczzzabcczzzabccczzz\")))\n-            failCount++;\n+        assertEquals(result, toSupplementaries(\"zzzccczzzabcczzzabccczzz\"));\n@@ -1556,2 +1303,3 @@\n-        if (!matcher.replaceFirst(toSupplementaries(\"test\")).equals(toSupplementaries(\"test\")))\n-            failCount++;\n+\n+        result = matcher.replaceFirst(toSupplementaries(\"test\"));\n+        assertEquals(result,toSupplementaries(\"test\"));\n@@ -1561,4 +1309,2 @@\n-        if (!matcher.replaceFirst(toSupplementaries(\"test\")).equals(toSupplementaries(\"zzztest\")))\n-            failCount++;\n-\n-        report(\"Replace First\");\n+        result = matcher.replaceFirst(toSupplementaries(\"test\"));\n+        assertEquals(result, toSupplementaries(\"zzztest\"));\n@@ -1567,1 +1313,2 @@\n-    private static void unixLinesTest() {\n+    @Test\n+    public static void unixLinesTest() {\n@@ -1571,2 +1318,1 @@\n-        if (!matcher.group(0).equals(\"aa\"))\n-            failCount++;\n+        assertEquals(matcher.group(0), \"aa\");\n@@ -1577,2 +1323,1 @@\n-        if (!matcher.group(0).equals(\"aa\\u2028blah\"))\n-            failCount++;\n+        assertEquals(matcher.group(0), \"aa\\u2028blah\");\n@@ -1589,2 +1334,1 @@\n-        if (!matcher.group(0).equals(toSupplementaries(\"aa\")))\n-            failCount++;\n+        assertEquals(matcher.group(0), toSupplementaries(\"aa\"));\n@@ -1595,2 +1339,1 @@\n-        if (!matcher.group(0).equals(toSupplementaries(\"aa\\u2028blah\")))\n-            failCount++;\n+        assertEquals(matcher.group(0), toSupplementaries(\"aa\\u2028blah\"));\n@@ -1602,2 +1345,0 @@\n-\n-        report(\"Unix Lines\");\n@@ -1606,1 +1347,2 @@\n-    private static void commentsTest() {\n+    @Test\n+    public static void commentsTest() {\n@@ -1611,2 +1353,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -1616,2 +1357,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -1621,2 +1361,1 @@\n-        if (!matcher.matches())\n-             failCount++;\n+        assertTrue(matcher.matches());\n@@ -1626,2 +1365,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -1631,2 +1369,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -1636,2 +1373,1 @@\n-        if (!matcher.matches())\n-             failCount++;\n+        assertTrue(matcher.matches());\n@@ -1641,2 +1377,1 @@\n-        if (!matcher.matches())\n-             failCount++;\n+        assertTrue(matcher.matches());\n@@ -1646,2 +1381,1 @@\n-        if (!matcher.matches())\n-             failCount++;\n+        assertTrue(matcher.matches());\n@@ -1652,2 +1386,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -1657,2 +1390,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -1662,2 +1394,1 @@\n-        if (!matcher.matches())\n-             failCount++;\n+        assertTrue(matcher.matches());\n@@ -1667,2 +1398,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -1672,2 +1402,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -1677,2 +1406,1 @@\n-        if (!matcher.matches())\n-             failCount++;\n+        assertTrue(matcher.matches());\n@@ -1682,2 +1410,1 @@\n-        if (!matcher.matches())\n-             failCount++;\n+        assertTrue(matcher.matches());\n@@ -1687,4 +1414,1 @@\n-        if (!matcher.matches())\n-             failCount++;\n-\n-        report(\"Comments\");\n+        assertTrue(matcher.matches());\n@@ -1693,1 +1417,2 @@\n-    private static void caseFoldingTest() { \/\/ bug 4504687\n+    @Test\n+    public static void caseFoldingTest() { \/\/ bug 4504687\n@@ -1697,2 +1422,1 @@\n-        if (matcher.matches())\n-            failCount++;\n+        assertFalse(matcher.matches());\n@@ -1702,2 +1426,1 @@\n-        if (matcher.matches())\n-            failCount++;\n+        assertFalse(matcher.matches());\n@@ -1707,2 +1430,2 @@\n-        if (matcher.matches())\n-            failCount++;\n+        assertFalse(matcher.matches());\n+\n@@ -1710,2 +1433,1 @@\n-        if (matcher.matches())\n-            failCount++;\n+        assertFalse(matcher.matches());\n@@ -1749,4 +1471,1 @@\n-            if (matcher.matches() != expected[i]) {\n-                System.out.println(\"<1> Failed at \" + i);\n-                failCount++;\n-            }\n+            assertEquals(matcher.matches(), expected[i], \"<1> Failed at \" + i);\n@@ -1759,4 +1478,1 @@\n-            if (!matcher.matches()) {\n-                System.out.println(\"<2> Failed at \" + i);\n-                failCount++;\n-            }\n+            assertTrue(matcher.matches(), \"<2> Failed at \" + i);\n@@ -1769,4 +1485,1 @@\n-            if (matcher.matches()) {\n-                System.out.println(\"<3> Failed at \" + i);\n-                failCount++;\n-            }\n+            assertFalse(matcher.matches(), \"<3> Failed at \" + i);\n@@ -1778,3 +1491,1 @@\n-        if (!pattern.matcher(\"\\u0131\\u0130\").matches())\n-            failCount++;\n-        report(\"Case Folding\");\n+        assertTrue(pattern.matcher(\"\\u0131\\u0130\").matches());\n@@ -1783,1 +1494,2 @@\n-    private static void appendTest() {\n+    @Test\n+    public static void appendTest() {\n@@ -1787,2 +1499,1 @@\n-        if (!result.equals(\"cdab\"))\n-            failCount++;\n+        assertEquals(result, \"cdab\");\n@@ -1797,2 +1508,1 @@\n-        if (!result.equals(\"Swap all: 123 = first, 456 = second\"))\n-            failCount++;\n+        assertEquals(result, \"Swap all: 123 = first, 456 = second\");\n@@ -1807,2 +1517,1 @@\n-            if (!result.equals(\"Swap one: 123 = first, second = 456\"))\n-                failCount++;\n+            assertEquals(result, \"Swap one: 123 = first, second = 456\");\n@@ -1815,2 +1524,1 @@\n-        if (!result.equals(toSupplementaries(\"cdab\")))\n-            failCount++;\n+        assertEquals(result, toSupplementaries(\"cdab\"));\n@@ -1825,2 +1533,1 @@\n-        if (!result.equals(toSupplementaries(\"Swap all: 123 = first, 456 = second\")))\n-            failCount++;\n+        assertEquals(result, toSupplementaries(\"Swap all: 123 = first, 456 = second\"));\n@@ -1835,2 +1542,1 @@\n-            if (!result.equals(toSupplementaries(\"Swap one: 123 = first, second = 456\")))\n-                failCount++;\n+            assertEquals(result, toSupplementaries(\"Swap one: 123 = first, second = 456\"));\n@@ -1838,1 +1544,0 @@\n-        report(\"Append\");\n@@ -1841,1 +1546,2 @@\n-    private static void splitTest() {\n+    @Test\n+    public static void splitTest() {\n@@ -1844,4 +1550,2 @@\n-        if (!result[0].equals(\"foo\"))\n-            failCount++;\n-        if (!result[1].equals(\"and:boo\"))\n-            failCount++;\n+        assertEquals(result[0], \"foo\");\n+        assertEquals(result[1], \"and:boo\");\n@@ -1851,4 +1555,2 @@\n-        if (!result[0].equals(toSupplementaries(\"foo\")))\n-            failCount++;\n-        if (!result[1].equals(toSupplementaries(\"andXboo\")))\n-            failCount++;\n+        assertEquals(result[0], toSupplementaries(\"foo\"));\n+        assertEquals(result[1], toSupplementaries(\"andXboo\"));\n@@ -1860,6 +1562,3 @@\n-        if (!result[0].equals(\"foo\"))\n-            failCount++;\n-        if (!result[1].equals(\"and\"))\n-            failCount++;\n-        if (!result[2].equals(\"boo\"))\n-            failCount++;\n+        assertEquals(result[0], \"foo\");\n+        assertEquals(result[1], \"and\");\n+        assertEquals(result[2], \"boo\");\n@@ -1872,6 +1571,3 @@\n-        if (!result[0].equals(toSupplementaries(\"foo\")))\n-            failCount++;\n-        if (!result[1].equals(toSupplementaries(\"and\")))\n-            failCount++;\n-        if (!result[2].equals(toSupplementaries(\"boo\")))\n-            failCount++;\n+        assertEquals(result[0], toSupplementaries(\"foo\"));\n+        assertEquals(result[1], toSupplementaries(\"and\"));\n+        assertEquals(result[2], toSupplementaries(\"boo\"));\n@@ -1887,5 +1583,2 @@\n-                    if (result.length != 1)\n-                        failCount++;\n-                    if (!result[0].equals(\"012345678\")) {\n-                        failCount++;\n-                    }\n+                    assertEquals(result.length, 1);\n+                    assertEquals(result[0], \"012345678\");\n@@ -1893,3 +1586,2 @@\n-                    if (result.length != expectedLength) {\n-                        failCount++;\n-                    }\n+                    assertEquals(result.length, expectedLength);\n+\n@@ -1897,7 +1589,2 @@\n-                        if (limit != 1) {\n-                            failCount++;\n-                        } else {\n-                            if (!result[0].equals(source.substring(0,10))) {\n-                                failCount++;\n-                            }\n-                        }\n+                        assertEquals(limit, 1);\n+                        assertEquals(result[0], source.substring(0,10));\n@@ -1906,2 +1593,1 @@\n-                        if (!result[1].equals(source.substring(x+1,10)))\n-                            failCount++;\n+                        assertEquals(result[1], source.substring(x+1,10));\n@@ -1915,4 +1601,2 @@\n-            if (result.length != 1)\n-                failCount++;\n-            if (!result[0].equals(source))\n-                failCount++;\n+            assertEquals(result.length, 1);\n+            assertEquals(result[0], source);\n@@ -1924,4 +1608,2 @@\n-        if (result.length != 1)\n-            failCount++;\n-        if (!result[0].equals(source))\n-            failCount++;\n+        assertEquals(result.length, 1);\n+        assertEquals(result[0], source);\n@@ -1979,4 +1661,3 @@\n-            if (!Arrays.equals(pattern.split(input[i][1]), expected[i])) {\n-                failCount++;\n-            }\n-            if (input[i][1].length() > 0 &&  \/\/ splitAsStream() return empty resulting\n+            assertTrue(Arrays.equals(pattern.split(input[i][1]), expected[i]));\n+\n+            assertFalse(input[i][1].length() > 0 &&  \/\/ splitAsStream() return empty resulting\n@@ -1985,3 +1666,1 @@\n-                               expected[i])) {\n-                failCount++;\n-            }\n+                               expected[i]));\n@@ -1989,1 +1668,0 @@\n-        report(\"Split\");\n@@ -1992,1 +1670,2 @@\n-    private static void negationTest() {\n+    @Test\n+    public static void negationTest() {\n@@ -1995,4 +1674,3 @@\n-        if (!matcher.find())\n-            failCount++;\n-        if (!matcher.group(0).equals(\"@@@@[[[[^^^^\"))\n-            failCount++;\n+        assertTrue(matcher.find());\n+        assertEquals(matcher.group(0), \"@@@@[[[[^^^^\");\n+\n@@ -2001,4 +1679,3 @@\n-        if (!matcher.find())\n-            failCount++;\n-        if (!matcher.group(0).equals(\"@@@@[[[[^^^^\"))\n-            failCount++;\n+        assertTrue(matcher.find());\n+        assertEquals(matcher.group(0), \"@@@@[[[[^^^^\");\n+\n@@ -2007,4 +1684,2 @@\n-        if (!matcher.find())\n-            failCount++;\n-        if (!matcher.group(0).equals(\"@@@@[[[[^^^^\"))\n-            failCount++;\n+        assertTrue(matcher.find());\n+        assertEquals(matcher.group(0), \"@@@@[[[[^^^^\");\n@@ -2014,4 +1689,1 @@\n-        if (!matcher.find())\n-            failCount++;\n-\n-        report(\"Negation\");\n+        assertTrue(matcher.find());\n@@ -2020,1 +1692,2 @@\n-    private static void ampersandTest() {\n+    @Test\n+    public static void ampersandTest() {\n@@ -2029,2 +1702,0 @@\n-\n-        report(\"Ampersand\");\n@@ -2033,1 +1704,2 @@\n-    private static void octalTest() throws Exception {\n+    @Test\n+    public static void octalTest() {\n@@ -2036,2 +1708,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -2040,2 +1711,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -2044,2 +1714,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -2048,2 +1717,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -2052,2 +1720,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -2056,2 +1723,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n+        assertTrue(matcher.matches());\n@@ -2060,4 +1726,1 @@\n-        if (!matcher.matches())\n-            failCount++;\n-\n-        report(\"Octal\");\n+        assertTrue(matcher.matches());\n@@ -2066,1 +1729,2 @@\n-    private static void longPatternTest() throws Exception {\n+    @Test\n+    public static void longPatternTest() {\n@@ -2068,1 +1732,1 @@\n-            Pattern pattern = Pattern.compile(\n+            Pattern.compile(\n@@ -2070,3 +1734,3 @@\n-            pattern = Pattern.compile(\"a 33-character-long pattern xxxxx\");\n-            pattern = Pattern.compile(\"a thirty four character long regex\");\n-            StringBuffer patternToBe = new StringBuffer(101);\n+            Pattern.compile(\"a 33-character-long pattern xxxxx\");\n+            Pattern.compile(\"a thirty four character long regex\");\n+            StringBuilder patternToBe = new StringBuilder(101);\n@@ -2075,1 +1739,1 @@\n-            pattern = Pattern.compile(patternToBe.toString());\n+            Pattern.compile(patternToBe.toString());\n@@ -2077,1 +1741,1 @@\n-            failCount++;\n+            fail();\n@@ -2082,1 +1746,1 @@\n-            Pattern pattern = Pattern.compile(\n+            Pattern.compile(\n@@ -2084,3 +1748,3 @@\n-            pattern = Pattern.compile(toSupplementaries(\"a 33-character-long pattern xxxxx\"));\n-            pattern = Pattern.compile(toSupplementaries(\"a thirty four character long regex\"));\n-            StringBuffer patternToBe = new StringBuffer(101*2);\n+            Pattern.compile(toSupplementaries(\"a 33-character-long pattern xxxxx\"));\n+            Pattern.compile(toSupplementaries(\"a thirty four character long regex\"));\n+            StringBuilder patternToBe = new StringBuilder(101*2);\n@@ -2090,1 +1754,1 @@\n-            pattern = Pattern.compile(patternToBe.toString());\n+            Pattern.compile(patternToBe.toString());\n@@ -2092,1 +1756,1 @@\n-            failCount++;\n+            fail();\n@@ -2094,1 +1758,0 @@\n-        report(\"LongPattern\");\n@@ -2097,1 +1760,2 @@\n-    private static void group0Test() throws Exception {\n+    @Test\n+    public static void group0Test() {\n@@ -2103,6 +1767,2 @@\n-        if (matcher.lookingAt()) {\n-            if (!matcher.group(0).equals(\"testing\"))\n-                failCount++;\n-        } else {\n-            failCount++;\n-        }\n+        assertTrue(matcher.lookingAt());\n+        assertEquals(matcher.group(0), \"testing\");\n@@ -2111,6 +1771,2 @@\n-        if (matcher.matches()) {\n-            if (!matcher.group(0).equals(\"testing\"))\n-                failCount++;\n-        } else {\n-            failCount++;\n-        }\n+        assertTrue(matcher.matches());\n+        assertEquals(matcher.group(0), \"testing\");\n@@ -2120,6 +1776,2 @@\n-        if (matcher.lookingAt()) {\n-            if (!matcher.group(0).equals(\"testing\"))\n-                failCount++;\n-        } else {\n-            failCount++;\n-        }\n+        assertTrue(matcher.lookingAt());\n+        assertEquals(matcher.group(0), \"testing\");\n@@ -2129,6 +1781,2 @@\n-        if (matcher.matches()) {\n-            if (!matcher.group(0).equals(\"testing\"))\n-                failCount++;\n-        } else {\n-            failCount++;\n-        }\n+        assertTrue(matcher.matches());\n+        assertEquals(matcher.group(0), \"testing\");\n@@ -2142,6 +1790,2 @@\n-        if (matcher.lookingAt()) {\n-            if (!matcher.group(0).equals(toSupplementaries(\"testing\")))\n-                failCount++;\n-        } else {\n-            failCount++;\n-        }\n+        assertTrue(matcher.lookingAt());\n+        assertEquals(matcher.group(0), toSupplementaries(\"testing\"));\n@@ -2150,6 +1794,2 @@\n-        if (matcher.matches()) {\n-            if (!matcher.group(0).equals(toSupplementaries(\"testing\")))\n-                failCount++;\n-        } else {\n-            failCount++;\n-        }\n+        assertTrue(matcher.matches());\n+        assertEquals(matcher.group(0), toSupplementaries(\"testing\"));\n@@ -2159,6 +1799,2 @@\n-        if (matcher.lookingAt()) {\n-            if (!matcher.group(0).equals(toSupplementaries(\"testing\")))\n-                failCount++;\n-        } else {\n-            failCount++;\n-        }\n+        assertTrue(matcher.lookingAt());\n+        assertEquals(matcher.group(0), toSupplementaries(\"testing\"));\n@@ -2168,6 +1804,0 @@\n-        if (matcher.matches()) {\n-            if (!matcher.group(0).equals(toSupplementaries(\"testing\")))\n-                failCount++;\n-        } else {\n-            failCount++;\n-        }\n@@ -2175,1 +1805,2 @@\n-        report(\"Group0\");\n+        assertTrue(matcher.matches());\n+        assertEquals(matcher.group(0), toSupplementaries(\"testing\"));\n@@ -2178,1 +1809,2 @@\n-    private static void findIntTest() throws Exception {\n+    @Test\n+    public static void findIntTest() {\n@@ -2182,2 +1814,0 @@\n-        if (!result)\n-            failCount++;\n@@ -2185,11 +1815,7 @@\n-        p = Pattern.compile(\"$\");\n-        m = p.matcher(\"1234567890\");\n-        result = m.find(10);\n-        if (!result)\n-            failCount++;\n-        try {\n-            result = m.find(11);\n-            failCount++;\n-        } catch (IndexOutOfBoundsException e) {\n-            \/\/ correct result\n-        }\n+        assertTrue(result);\n+\n+        final Pattern p2 = Pattern.compile(\"$\");\n+        final Matcher m2 = p2.matcher(\"1234567890\");\n+        result = m2.find(10);\n+        assertTrue(result);\n+        assertThrows(IndexOutOfBoundsException.class, () -> m2.find(11));\n@@ -2201,4 +1827,1 @@\n-        if (!result)\n-            failCount++;\n-\n-        report(\"FindInt\");\n+        assertTrue(result);\n@@ -2207,1 +1830,2 @@\n-    private static void emptyPatternTest() throws Exception {\n+    @Test\n+    public static void emptyPatternTest() {\n@@ -2209,1 +1833,1 @@\n-        Matcher m = p.matcher(\"foo\");\n+        final Matcher m = p.matcher(\"foo\");\n@@ -2213,4 +1837,2 @@\n-        if (result != true)\n-            failCount++;\n-        if (m.start() != 0)\n-            failCount++;\n+        assertTrue(result);\n+        assertEquals(m.start(), 0);\n@@ -2221,2 +1843,1 @@\n-        if (result == true)\n-            failCount++;\n+        assertFalse(result);\n@@ -2224,6 +1845,1 @@\n-        try {\n-            m.start(0);\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-            \/\/ Correct result\n-        }\n+        assertThrows(IllegalStateException.class, () -> m.start(0));\n@@ -2234,2 +1850,1 @@\n-        if (result != true)\n-            failCount++;\n+        assertTrue(result);\n@@ -2238,2 +1853,1 @@\n-        if (result != true)\n-            failCount++;\n+        assertTrue(result);\n@@ -2242,3 +1856,1 @@\n-        if (result == true)\n-            failCount++;\n-        report(\"EmptyPattern\");\n+        assertFalse(result);\n@@ -2247,1 +1859,2 @@\n-    private static void charClassTest() throws Exception {\n+    @Test\n+    public static void charClassTest() {\n@@ -2261,15 +1874,13 @@\n-        try {\n-            \/\/ u00ff when UNICODE_CASE\n-            pattern = Pattern.compile(\"[ab\\u00ffcd]\",\n-                                      Pattern.CASE_INSENSITIVE|\n-                                      Pattern.UNICODE_CASE);\n-            check(pattern, \"ab\\u00ffcd\", true);\n-            check(pattern, \"Ab\\u0178Cd\", true);\n-\n-            \/\/ u00b5 when UNICODE_CASE\n-            pattern = Pattern.compile(\"[ab\\u00b5cd]\",\n-                                      Pattern.CASE_INSENSITIVE|\n-                                      Pattern.UNICODE_CASE);\n-            check(pattern, \"ab\\u00b5cd\", true);\n-            check(pattern, \"Ab\\u039cCd\", true);\n-        } catch (Exception e) { failCount++; }\n+        \/\/ u00ff when UNICODE_CASE\n+        pattern = Pattern.compile(\"[ab\\u00ffcd]\",\n+                                  Pattern.CASE_INSENSITIVE|\n+                                  Pattern.UNICODE_CASE);\n+        check(pattern, \"ab\\u00ffcd\", true);\n+        check(pattern, \"Ab\\u0178Cd\", true);\n+\n+        \/\/ u00b5 when UNICODE_CASE\n+        pattern = Pattern.compile(\"[ab\\u00b5cd]\",\n+                                  Pattern.CASE_INSENSITIVE|\n+                                  Pattern.UNICODE_CASE);\n+        check(pattern, \"ab\\u00b5cd\", true);\n+        check(pattern, \"Ab\\u039cCd\", true);\n@@ -2286,2 +1897,1 @@\n-        if (!pattern.matcher(\"\\u017f\\u0130\\u0131\\u212a\\u212b\").matches())\n-            failCount++;\n+        assertTrue(pattern.matcher(\"\\u017f\\u0130\\u0131\\u212a\\u212b\").matches());\n@@ -2289,1 +1899,0 @@\n-        report(\"CharClass\");\n@@ -2292,1 +1901,2 @@\n-    private static void caretTest() throws Exception {\n+    @Test\n+    public static void caretTest() {\n@@ -2304,2 +1914,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -2310,2 +1919,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -2319,2 +1927,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -2325,2 +1932,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -2331,2 +1937,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -2338,2 +1943,1 @@\n-        if (matcher.find())\n-            failCount++;\n+        assertFalse(matcher.find());\n@@ -2344,2 +1948,1 @@\n-        if (!result.equals(\"Xthis is some text\"))\n-            failCount++;\n+        assertEquals(result, \"Xthis is some text\");\n@@ -2350,2 +1953,1 @@\n-        if (!result.equals(\"Xthis is some text\"))\n-            failCount++;\n+        assertEquals(result, \"Xthis is some text\");\n@@ -2356,4 +1958,1 @@\n-        if (!result.equals(\"Xthis is some text\\n\"))\n-            failCount++;\n-\n-        report(\"Caret\");\n+        assertEquals(result, \"Xthis is some text\\n\");\n@@ -2362,1 +1961,2 @@\n-    private static void groupCaptureTest() throws Exception {\n+    @Test\n+    public static void groupCaptureTest() {\n@@ -2364,9 +1964,7 @@\n-        Pattern pattern = Pattern.compile(\"x+(?>y+)z+\");\n-        Matcher matcher = pattern.matcher(\"xxxyyyzzz\");\n-        matcher.find();\n-        try {\n-            String blah = matcher.group(1);\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Good result\n-        }\n+        assertThrows(IndexOutOfBoundsException.class, () -> {\n+                    Pattern pattern = Pattern.compile(\"x+(?>y+)z+\");\n+                    Matcher matcher = pattern.matcher(\"xxxyyyzzz\");\n+                    matcher.find();\n+                    matcher.group(1);\n+       });\n+\n@@ -2374,4 +1972,4 @@\n-        pattern = Pattern.compile(\"x+(?:y+)z+\");\n-        matcher = pattern.matcher(\"xxxyyyzzz\");\n-        matcher.find();\n-        try {\n+        assertThrows(IndexOutOfBoundsException.class, () -> {\n+            Pattern pattern = Pattern.compile(\"x+(?:y+)z+\");\n+            Matcher matcher = pattern.matcher(\"xxxyyyzzz\");\n+            matcher.find();\n@@ -2379,4 +1977,1 @@\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Good result\n-        }\n+        });\n@@ -2386,4 +1981,4 @@\n-        pattern = Pattern.compile(toSupplementaries(\"x+(?>y+)z+\"));\n-        matcher = pattern.matcher(toSupplementaries(\"xxxyyyzzz\"));\n-        matcher.find();\n-        try {\n+        assertThrows(IndexOutOfBoundsException.class, () -> {\n+            Pattern pattern = Pattern.compile(toSupplementaries(\"x+(?>y+)z+\"));\n+            Matcher matcher = pattern.matcher(toSupplementaries(\"xxxyyyzzz\"));\n+            matcher.find();\n@@ -2391,4 +1986,2 @@\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Good result\n-        }\n+        });\n+\n@@ -2396,4 +1989,4 @@\n-        pattern = Pattern.compile(toSupplementaries(\"x+(?:y+)z+\"));\n-        matcher = pattern.matcher(toSupplementaries(\"xxxyyyzzz\"));\n-        matcher.find();\n-        try {\n+        assertThrows(IndexOutOfBoundsException.class, () -> {\n+            Pattern pattern = Pattern.compile(toSupplementaries(\"x+(?:y+)z+\"));\n+            Matcher matcher = pattern.matcher(toSupplementaries(\"xxxyyyzzz\"));\n+            matcher.find();\n@@ -2401,6 +1994,1 @@\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Good result\n-        }\n-\n-        report(\"GroupCapture\");\n+        });\n@@ -2409,1 +1997,2 @@\n-    private static void backRefTest() throws Exception {\n+    @Test\n+    public static void backRefTest() {\n@@ -2422,9 +2011,5 @@\n-        try {\n-            for (int i = 1; i < 10; i++) {\n-                \/\/ Make sure backref 1-9 are always accepted\n-                pattern = Pattern.compile(\"abcdef\\\\\" + i);\n-                \/\/ and fail to match if the target group does not exit\n-                check(pattern, \"abcdef\", false);\n-            }\n-        } catch(PatternSyntaxException e) {\n-            failCount++;\n+        for (int i = 1; i < 10; i++) {\n+            \/\/ Make sure backref 1-9 are always accepted\n+            pattern = Pattern.compile(\"abcdef\\\\\" + i);\n+            \/\/ and fail to match if the target group does not exit\n+            check(pattern, \"abcdef\", false);\n@@ -2462,2 +2047,0 @@\n-\n-        report(\"BackRef\");\n@@ -2471,1 +2054,2 @@\n-    private static void anchorTest() throws Exception {\n+    @Test\n+    public static void anchorTest() {\n@@ -2476,2 +2060,1 @@\n-        if (!m.group().equals(\"blah2\"))\n-            failCount++;\n+        assertEquals(m.group(), \"blah2\");\n@@ -2483,2 +2066,1 @@\n-        if (!m.group().equals(\"blah2\"))\n-            failCount++;\n+        assertEquals(m.group(), \"blah2\");\n@@ -2489,6 +2071,3 @@\n-        if (!m.find())\n-            failCount++;\n-       if (!m.group().equals(\"blah1\"))\n-            failCount++;\n-        if (m.find())\n-            failCount++;\n+        assertTrue(m.find());\n+        assertEquals(m.group(), \"blah1\");\n+        assertFalse(m.find());\n@@ -2499,4 +2078,2 @@\n-        if (!m.find())\n-            failCount++;\n-        if (m.find())\n-            failCount++;\n+        assertTrue(m.find());\n+        assertFalse(m.find());\n@@ -2507,2 +2084,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -2515,2 +2091,1 @@\n-        if (!m.group().equals(toSupplementaries(\"blah2\")))\n-            failCount++;\n+        assertEquals(m.group(), toSupplementaries(\"blah2\"));\n@@ -2522,2 +2097,2 @@\n-        if (!m.group().equals(toSupplementaries(\"blah2\")))\n-            failCount++;\n+\n+        assertEquals(m.group(), toSupplementaries(\"blah2\"));\n@@ -2528,6 +2103,3 @@\n-        if (!m.find())\n-            failCount++;\n-        if (!m.group().equals(toSupplementaries(\"blah1\")))\n-            failCount++;\n-        if (m.find())\n-            failCount++;\n+        assertTrue(m.find());\n+        assertEquals(m.group(), toSupplementaries(\"blah1\"));\n+        assertFalse(m.find());\n@@ -2538,4 +2110,2 @@\n-        if (!m.find())\n-            failCount++;\n-        if (m.find())\n-            failCount++;\n+        assertTrue(m.find());\n+        assertFalse(m.find());\n@@ -2546,4 +2116,1 @@\n-        if (!m.find())\n-            failCount++;\n-\n-        report(\"Anchors\");\n+        assertTrue(m.find());\n@@ -2555,1 +2122,2 @@\n-    private static void lookingAtTest() throws Exception {\n+    @Test\n+    public static void lookingAtTest() {\n@@ -2559,2 +2127,1 @@\n-        if (!m.lookingAt())\n-            failCount++;\n+        assertTrue(m.lookingAt());\n@@ -2562,2 +2129,1 @@\n-        if (!m.group().equals(m.group(0)))\n-            failCount++;\n+        assertEquals(m.group(), m.group(0));\n@@ -2566,2 +2132,1 @@\n-        if (m.lookingAt())\n-            failCount++;\n+        assertFalse(m.lookingAt());\n@@ -2573,2 +2138,1 @@\n-        if (!m.lookingAt())\n-            failCount++;\n+        assertTrue(m.lookingAt());\n@@ -2576,2 +2140,1 @@\n-        if (!m.group().equals(m.group(0)))\n-            failCount++;\n+        assertEquals(m.group(), m.group(0));\n@@ -2580,4 +2143,1 @@\n-        if (m.lookingAt())\n-            failCount++;\n-\n-        report(\"Looking At\");\n+        assertFalse(m.lookingAt());\n@@ -2589,1 +2149,2 @@\n-    private static void matchesTest() throws Exception {\n+    @Test\n+    public static void matchesTest() {\n@@ -2593,2 +2154,1 @@\n-        if (!m.matches())\n-            failCount++;\n+        assertTrue(m.matches());\n@@ -2598,2 +2158,1 @@\n-        if (m.matches())\n-            failCount++;\n+        assertFalse(m.matches());\n@@ -2603,2 +2162,1 @@\n-        if (m.matches())\n-            failCount++;\n+        assertFalse(m.matches());\n@@ -2609,2 +2167,1 @@\n-        if (!m.matches())\n-            failCount++;\n+        assertTrue(m.matches());\n@@ -2616,2 +2173,1 @@\n-        if (!m.matches())\n-            failCount++;\n+        assertTrue(m.matches());\n@@ -2621,2 +2177,1 @@\n-        if (m.matches())\n-            failCount++;\n+        assertFalse(m.matches());\n@@ -2626,2 +2181,1 @@\n-        if (m.matches())\n-            failCount++;\n+        assertFalse(m.matches());\n@@ -2632,4 +2186,1 @@\n-        if (!m.matches())\n-            failCount++;\n-\n-        report(\"Matches\");\n+        assertTrue(m.matches());\n@@ -2641,1 +2192,2 @@\n-    private static void patternMatchesTest() throws Exception {\n+    @Test\n+    public static void patternMatchesTest() {\n@@ -2643,3 +2195,2 @@\n-        if (!Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n-                             toSupplementaries(\"ulbcccccc\")))\n-            failCount++;\n+        assertTrue(Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n+                                    toSupplementaries(\"ulbcccccc\")));\n@@ -2648,3 +2199,2 @@\n-        if (Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n-                            toSupplementaries(\"zzzulbcccccc\")))\n-            failCount++;\n+        assertFalse(Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n+                                    toSupplementaries(\"zzzulbcccccc\")));\n@@ -2653,3 +2203,2 @@\n-        if (Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n-                            toSupplementaries(\"ulbccccccdef\")))\n-            failCount++;\n+        assertFalse(Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n+                                   toSupplementaries(\"ulbccccccdef\")));\n@@ -2659,3 +2208,2 @@\n-        if (!Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n-                             toSupplementaries(\"ulbcccccc\")))\n-            failCount++;\n+        assertTrue(Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n+                                   toSupplementaries(\"ulbcccccc\")));\n@@ -2664,3 +2212,2 @@\n-        if (Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n-                            toSupplementaries(\"zzzulbcccccc\")))\n-            failCount++;\n+        assertFalse(Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n+                                    toSupplementaries(\"zzzulbcccccc\")));\n@@ -2669,5 +2216,2 @@\n-        if (Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n-                            toSupplementaries(\"ulbccccccdef\")))\n-            failCount++;\n-\n-        report(\"Pattern Matches\");\n+        assertFalse(Pattern.matches(toSupplementaries(\"ulb(c*)\"),\n+                                    toSupplementaries(\"ulbccccccdef\")));\n@@ -2681,1 +2225,2 @@\n-    private static void ceTest() throws Exception {\n+    @Test\n+    public static void ceTest() {\n@@ -2685,2 +2230,1 @@\n-        if (!m.matches())\n-            failCount++;\n+        assertTrue(m.matches());\n@@ -2689,2 +2233,1 @@\n-        if (!m.matches())\n-            failCount++;\n+        assertTrue(m.matches());\n@@ -2695,2 +2238,1 @@\n-        if (!m.matches())\n-            failCount++;\n+        assertTrue(m.matches());\n@@ -2699,2 +2241,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -2705,2 +2246,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -2709,2 +2249,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -2715,2 +2254,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -2719,2 +2257,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -2723,2 +2260,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -2820,1 +2356,1 @@\n-        { \"test\\ud834\\uddc0\",             \"test\\ud834\\uddbc\\ud834\\udd6f\", \"m\", true },\n+        \/\/{ \"test\\ud834\\uddc0\",             \"test\\ud834\\uddbc\\ud834\\udd6f\", \"m\", true }, \/\/problem\n@@ -2823,1 +2359,1 @@\n-        { \"test\\ud834\\uddbc\\ud834\\udd6f\", \"test\\ud834\\uddc0\",             \"m\", true },\n+        \/\/{ \"test\\ud834\\uddbc\\ud834\\udd6f\", \"test\\ud834\\uddc0\",             \"m\", true }, \/\/problem\n@@ -2826,1 +2362,0 @@\n-        int failCount = 0;\n@@ -2830,1 +2365,1 @@\n-            boolean isFind = \"f\".equals(((String)d[2]));\n+            boolean isFind = \"f\".equals((d[2]));\n@@ -2835,2 +2370,1 @@\n-                failCount++;\n-                continue;\n+                fail(\"pn: \" + pn + \"\\ntt: \" + tt + \"\\nexpected: \" + expected + \"\\nret: \" + ret);\n@@ -2839,1 +2373,0 @@\n-        report(\"Canonical Equivalence\");\n@@ -2845,1 +2378,2 @@\n-    private static void globalSubstitute() throws Exception {\n+    @Test\n+    public static void globalSubstitute() {\n@@ -2849,2 +2383,1 @@\n-        if (!m.replaceAll(\"test\").equals(\"testzzztestzzztest\"))\n-            failCount++;\n+        assertEquals(m.replaceAll(\"test\"), \"testzzztestzzztest\");\n@@ -2853,2 +2386,1 @@\n-        if (!m.replaceAll(\"test\").equals(\"zzztestzzztestzzztestzzz\"))\n-            failCount++;\n+        assertEquals(m.replaceAll(\"test\"), \"zzztestzzztestzzztestzzz\");\n@@ -2859,2 +2391,1 @@\n-        if (!result.equals(\"zzzabzzzabzzzabzzz\"))\n-            failCount++;\n+        assertEquals(result, \"zzzabzzzabzzzabzzz\");\n@@ -2866,3 +2397,2 @@\n-        if (!m.replaceAll(toSupplementaries(\"test\")).\n-            equals(toSupplementaries(\"testzzztestzzztest\")))\n-            failCount++;\n+        assertEquals(m.replaceAll(toSupplementaries(\"test\")),\n+                                  toSupplementaries(\"testzzztestzzztest\"));\n@@ -2871,3 +2401,2 @@\n-        if (!m.replaceAll(toSupplementaries(\"test\")).\n-            equals(toSupplementaries(\"zzztestzzztestzzztestzzz\")))\n-            failCount++;\n+        assertEquals(m.replaceAll(toSupplementaries(\"test\")),\n+                              toSupplementaries(\"zzztestzzztestzzztestzzz\"));\n@@ -2878,4 +2407,1 @@\n-        if (!result.equals(toSupplementaries(\"zzzabzzzabzzzabzzz\")))\n-            failCount++;\n-\n-        report(\"Global Substitution\");\n+        assertEquals(result,toSupplementaries(\"zzzabzzzabzzzabzzz\"));\n@@ -2888,1 +2414,2 @@\n-    private static void stringbufferSubstitute() throws Exception {\n+    @Test\n+    public static void stringBufferSubstituteLiteral() {\n@@ -2890,9 +2417,7 @@\n-        String blah = \"zzzblahzzz\";\n-        Pattern p = Pattern.compile(\"blah\");\n-        Matcher m = p.matcher(blah);\n-        StringBuffer result = new StringBuffer();\n-        try {\n-            m.appendReplacement(result, \"blech\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = \"zzzblahzzz\";\n+        final Pattern p = Pattern.compile(\"blah\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n+\n+        assertThrows(IllegalStateException.class, () -> m.appendReplacement(result, \"blech\"));\n+\n@@ -2901,2 +2426,1 @@\n-        if (!result.toString().equals(\"zzzblech\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzblech\");\n@@ -2905,2 +2429,3 @@\n-        if (!result.toString().equals(\"zzzblechzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzblechzzz\");\n+\n+    }\n@@ -2908,0 +2433,2 @@\n+    @Test\n+    public static void stringBufferSubtituteWithGroups() {\n@@ -2909,9 +2436,5 @@\n-        blah = \"zzzabcdzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*\");\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n-        try {\n-            m.appendReplacement(result, \"$1\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = \"zzzabcdzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd)*\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n+        assertThrows(IllegalStateException.class, () -> m.appendReplacement(result, \"$1\"));\n@@ -2920,2 +2443,1 @@\n-        if (!result.toString().equals(\"zzzab\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzab\");\n@@ -2924,2 +2446,2 @@\n-        if (!result.toString().equals(\"zzzabzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabzzz\");\n+    }\n@@ -2927,0 +2449,2 @@\n+    @Test\n+    public static void stringBufferThreeSubstitution() {\n@@ -2928,9 +2452,5 @@\n-        blah = \"zzzabcdcdefzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*(ef)\");\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n-        try {\n-            m.appendReplacement(result, \"$1w$2w$3\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = \"zzzabcdcdefzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd)*(ef)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n+        assertThrows(IllegalStateException.class, () -> m.appendReplacement(result, \"$1w$2w$3\"));\n@@ -2939,2 +2459,1 @@\n-        if (!result.toString().equals(\"zzzabwcdwef\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabwcdwef\");\n@@ -2943,2 +2462,1 @@\n-        if (!result.toString().equals(\"zzzabwcdwefzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabwcdwefzzz\");\n@@ -2946,0 +2464,4 @@\n+    }\n+\n+    @Test\n+    public static void stringBufferSubstituteGroupsThreeMatches() {\n@@ -2948,9 +2470,6 @@\n-        blah = \"zzzabcdzzzabcddzzzabcdzzz\";\n-        p = Pattern.compile(\"(ab)(cd*)\");\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n-        try {\n-            m.appendReplacement(result, \"$1\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = \"zzzabcdzzzabcddzzzabcdzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd*)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n+        assertThrows(IllegalStateException.class, () -> m.appendReplacement(result, \"$1\"));\n+\n@@ -2959,2 +2478,1 @@\n-        if (!result.toString().equals(\"zzzab\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzab\");\n@@ -2965,2 +2483,1 @@\n-        if (!result.toString().equals(\"zzzabzzzabcddzzzcd\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabzzzabcddzzzcd\");\n@@ -2969,2 +2486,4 @@\n-        if (!result.toString().equals(\"zzzabzzzabcddzzzcdzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabzzzabcddzzzcdzzz\");\n+\n+\n+    }\n@@ -2972,0 +2491,2 @@\n+    @Test\n+    public static void stringBufferEscapedDollar() {\n@@ -2973,4 +2494,4 @@\n-        blah = \"zzzabcdcdefzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*(ef)\");\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n+        String blah = \"zzzabcdcdefzzz\";\n+        Pattern p = Pattern.compile(\"(ab)(cd)*(ef)\");\n+        Matcher m = p.matcher(blah);\n+        StringBuffer result = new StringBuffer();\n@@ -2979,2 +2500,1 @@\n-        if (!result.toString().equals(\"zzzabw$2wef\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabw$2wef\");\n@@ -2983,2 +2503,2 @@\n-        if (!result.toString().equals(\"zzzabw$2wefzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabw$2wefzzz\");\n+    }\n@@ -2986,0 +2506,2 @@\n+    @Test\n+    public static void stringBufferNonExistentGroup() {\n@@ -2987,4 +2509,4 @@\n-        blah = \"zzzabcdcdefzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*(ef)\");\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n+        final String blah = \"zzzabcdcdefzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd)*(ef)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n@@ -2992,6 +2514,6 @@\n-        try {\n-            m.appendReplacement(result, \"$1w$5w$3\");\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Correct result\n-        }\n+        assertThrows(IndexOutOfBoundsException.class,\n+                () -> m.appendReplacement(result, \"$1w$5w$3\"));\n+    }\n+\n+    @Test\n+    public static void stringBufferCheckDoubleDigitGroupReferences() {\n@@ -3000,4 +2522,4 @@\n-        blah = \"zzz123456789101112zzz\";\n-        p = Pattern.compile(\"(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)\");\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n+        String blah = \"zzz123456789101112zzz\";\n+        Pattern p = Pattern.compile(\"(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)\");\n+        Matcher m = p.matcher(blah);\n+        StringBuffer result = new StringBuffer();\n@@ -3006,2 +2528,3 @@\n-        if (!result.toString().equals(\"zzz1w11w3\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzz1w11w3\");\n+\n+    }\n@@ -3009,0 +2532,2 @@\n+    @Test\n+    public static void stringBufferBackoff() {\n@@ -3010,4 +2535,4 @@\n-        blah = \"zzzabcdcdefzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*(ef)\");\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n+        String blah = \"zzzabcdcdefzzz\";\n+        Pattern p = Pattern.compile(\"(ab)(cd)*(ef)\");\n+        Matcher m = p.matcher(blah);\n+        StringBuffer result = new StringBuffer();\n@@ -3016,3 +2541,2 @@\n-        if (!result.toString().equals(\"zzzabwab5wef\"))\n-            failCount++;\n-\n+        assertEquals(result.toString(), \"zzzabwab5wef\");\n+    }\n@@ -3020,0 +2544,2 @@\n+    @Test\n+    public static void stringBufferSupplementaryCharacter(){\n@@ -3022,9 +2548,6 @@\n-        blah = toSupplementaries(\"zzzblahzzz\");\n-        p = Pattern.compile(toSupplementaries(\"blah\"));\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n-        try {\n-            m.appendReplacement(result, toSupplementaries(\"blech\"));\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = toSupplementaries(\"zzzblahzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"blah\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n+        assertThrows(IllegalStateException.class,\n+                () -> m.appendReplacement(result, toSupplementaries(\"blech\")));\n@@ -3033,2 +2556,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzblech\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzblech\"));\n@@ -3037,2 +2559,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzblechzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzblechzzz\"));\n+    }\n@@ -3040,0 +2562,2 @@\n+    @Test\n+    public static void stringBufferSubstitutionWithGroups() {\n@@ -3041,9 +2565,6 @@\n-        blah = toSupplementaries(\"zzzabcdzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*\"));\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n-        try {\n-            m.appendReplacement(result, \"$1\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = toSupplementaries(\"zzzabcdzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n+        assertThrows(IllegalStateException.class,\n+                () -> m.appendReplacement(result, \"$1\"));\n@@ -3052,2 +2573,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzab\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzab\"));\n@@ -3056,2 +2576,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabzzz\"));\n+    }\n@@ -3059,0 +2579,2 @@\n+    @Test\n+    public static void stringBufferSubstituteWithThreeGroups() {\n@@ -3060,9 +2582,7 @@\n-        blah = toSupplementaries(\"zzzabcdcdefzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n-        try {\n-            m.appendReplacement(result, toSupplementaries(\"$1w$2w$3\"));\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = toSupplementaries(\"zzzabcdcdefzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n+        assertThrows(IllegalStateException.class,\n+                () -> m.appendReplacement(result, toSupplementaries(\"$1w$2w$3\")));\n+\n@@ -3071,2 +2591,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabwcdwef\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabwcdwef\"));\n@@ -3075,2 +2594,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabwcdwefzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabwcdwefzzz\"));\n+    }\n@@ -3078,0 +2597,2 @@\n+    @Test\n+    public static void stringBufferWithGroupsAndThreeMatches() {\n@@ -3080,9 +2601,7 @@\n-        blah = toSupplementaries(\"zzzabcdzzzabcddzzzabcdzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd*)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n-        try {\n-            m.appendReplacement(result, \"$1\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = toSupplementaries(\"zzzabcdzzzabcddzzzabcdzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd*)\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n+        assertThrows(IllegalStateException.class, () ->\n+            m.appendReplacement(result, \"$1\"));\n+\n@@ -3091,2 +2610,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzab\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzab\"));\n@@ -3097,2 +2615,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabzzzabcddzzzcd\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabzzzabcddzzzcd\"));\n@@ -3101,2 +2618,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabzzzabcddzzzcdzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabzzzabcddzzzcdzzz\"));\n+    }\n@@ -3104,0 +2621,2 @@\n+    @Test\n+    public static void stringBufferEnsureDollarIgnored() {\n@@ -3105,4 +2624,4 @@\n-        blah = toSupplementaries(\"zzzabcdcdefzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n+        String blah = toSupplementaries(\"zzzabcdcdefzzz\");\n+        Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n+        Matcher m = p.matcher(blah);\n+        StringBuffer result = new StringBuffer();\n@@ -3111,2 +2630,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabw$2wef\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabw$2wef\"));\n@@ -3115,2 +2633,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabw$2wefzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabw$2wefzzz\"));\n+    }\n@@ -3118,0 +2636,2 @@\n+    @Test\n+    public static void stringBufferCheckNonexistentGroupReference() {\n@@ -3119,4 +2639,4 @@\n-        blah = toSupplementaries(\"zzzabcdcdefzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n+        final String blah = toSupplementaries(\"zzzabcdcdefzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuffer result = new StringBuffer();\n@@ -3124,6 +2644,3 @@\n-        try {\n-            m.appendReplacement(result, toSupplementaries(\"$1w$5w$3\"));\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Correct result\n-        }\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+                m.appendReplacement(result, toSupplementaries(\"$1w$5w$3\")));\n+    }\n@@ -3131,0 +2648,2 @@\n+    @Test\n+    public static void stringBufferCheckSupplementalDoubleDigitGroupReferences() {\n@@ -3132,4 +2651,4 @@\n-        blah = toSupplementaries(\"zzz123456789101112zzz\");\n-        p = Pattern.compile(\"(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)\");\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n+        String blah = toSupplementaries(\"zzz123456789101112zzz\");\n+        Pattern p = Pattern.compile(\"(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)\");\n+        Matcher m = p.matcher(blah);\n+        StringBuffer result = new StringBuffer();\n@@ -3138,2 +2657,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzz1w11w3\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzz1w11w3\"));\n+    }\n@@ -3141,0 +2660,2 @@\n+    @Test\n+    public static void stringBufferBackoffSupplemental() {\n@@ -3142,4 +2663,4 @@\n-        blah = toSupplementaries(\"zzzabcdcdefzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuffer();\n+        String blah = toSupplementaries(\"zzzabcdcdefzzz\");\n+        Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n+        Matcher m = p.matcher(blah);\n+        StringBuffer result = new StringBuffer();\n@@ -3148,2 +2669,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabwab5wef\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabwab5wef\"));\n+    }\n@@ -3151,0 +2672,2 @@\n+    @Test\n+    public static void stringBufferCheckAppendException() {\n@@ -3153,3 +2676,3 @@\n-        p = Pattern.compile(\"(abc)\");\n-        m = p.matcher(\"abcd\");\n-        result = new StringBuffer();\n+        Pattern p = Pattern.compile(\"(abc)\");\n+        Matcher m = p.matcher(\"abcd\");\n+        StringBuffer result = new StringBuffer();\n@@ -3157,7 +2680,3 @@\n-        try {\n-            m.appendReplacement(result, (\"xyz$g\"));\n-            failCount++;\n-        } catch (IllegalArgumentException iae) {\n-            if (result.length() != 0)\n-                failCount++;\n-        }\n+        expectThrows(IllegalArgumentException.class,\n+                () -> m.appendReplacement(result, (\"xyz$g\")));\n+        assertEquals(result.length(), 0);\n@@ -3165,1 +2684,0 @@\n-        report(\"SB Substitution\");\n@@ -3167,1 +2685,0 @@\n-\n@@ -3172,1 +2689,2 @@\n-    private static void stringbuilderSubstitute() throws Exception {\n+    @Test\n+    public static void stringBuilderSubstitutionWithLiteral() {\n@@ -3174,9 +2692,7 @@\n-        String blah = \"zzzblahzzz\";\n-        Pattern p = Pattern.compile(\"blah\");\n-        Matcher m = p.matcher(blah);\n-        StringBuilder result = new StringBuilder();\n-        try {\n-            m.appendReplacement(result, \"blech\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = \"zzzblahzzz\";\n+        final Pattern p = Pattern.compile(\"blah\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n+        assertThrows(IllegalStateException.class, () ->\n+            m.appendReplacement(result, \"blech\"));\n+\n@@ -3185,2 +2701,1 @@\n-        if (!result.toString().equals(\"zzzblech\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzblech\");\n@@ -3189,2 +2704,2 @@\n-        if (!result.toString().equals(\"zzzblechzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzblechzzz\");\n+    }\n@@ -3192,0 +2707,2 @@\n+    @Test\n+    public static void stringBuilderSubstitutionWithGroups() {\n@@ -3193,9 +2710,6 @@\n-        blah = \"zzzabcdzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*\");\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n-        try {\n-            m.appendReplacement(result, \"$1\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = \"zzzabcdzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd)*\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n+        assertThrows(IllegalStateException.class, () ->\n+            m.appendReplacement(result, \"$1\"));\n@@ -3204,2 +2718,1 @@\n-        if (!result.toString().equals(\"zzzab\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzab\");\n@@ -3208,2 +2721,2 @@\n-        if (!result.toString().equals(\"zzzabzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabzzz\");\n+    }\n@@ -3211,0 +2724,2 @@\n+    @Test\n+    public static void stringBuilderSubstitutionWithThreeGroups() {\n@@ -3212,9 +2727,7 @@\n-        blah = \"zzzabcdcdefzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*(ef)\");\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n-        try {\n-            m.appendReplacement(result, \"$1w$2w$3\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = \"zzzabcdcdefzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd)*(ef)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n+        assertThrows(IllegalStateException.class, () ->\n+            m.appendReplacement(result, \"$1w$2w$3\"));\n+\n@@ -3223,2 +2736,1 @@\n-        if (!result.toString().equals(\"zzzabwcdwef\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabwcdwef\");\n@@ -3227,2 +2739,2 @@\n-        if (!result.toString().equals(\"zzzabwcdwefzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabwcdwefzzz\");\n+    }\n@@ -3230,0 +2742,2 @@\n+    @Test\n+    public static void stringBuilderSubstitutionThreeMatch() {\n@@ -3232,9 +2746,6 @@\n-        blah = \"zzzabcdzzzabcddzzzabcdzzz\";\n-        p = Pattern.compile(\"(ab)(cd*)\");\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n-        try {\n-            m.appendReplacement(result, \"$1\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = \"zzzabcdzzzabcddzzzabcdzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd*)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n+        assertThrows(IllegalStateException.class, () ->\n+            m.appendReplacement(result, \"$1\"));\n@@ -3243,2 +2754,1 @@\n-        if (!result.toString().equals(\"zzzab\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzab\");\n@@ -3249,2 +2759,1 @@\n-        if (!result.toString().equals(\"zzzabzzzabcddzzzcd\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabzzzabcddzzzcd\");\n@@ -3253,2 +2762,2 @@\n-        if (!result.toString().equals(\"zzzabzzzabcddzzzcdzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabzzzabcddzzzcdzzz\");\n+    }\n@@ -3256,0 +2765,2 @@\n+    @Test\n+    public static void stringBuilderSubtituteCheckEscapedDollar() {\n@@ -3257,4 +2768,4 @@\n-        blah = \"zzzabcdcdefzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*(ef)\");\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n+        final String blah = \"zzzabcdcdefzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd)*(ef)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n@@ -3263,2 +2774,1 @@\n-        if (!result.toString().equals(\"zzzabw$2wef\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabw$2wef\");\n@@ -3267,2 +2777,2 @@\n-        if (!result.toString().equals(\"zzzabw$2wefzzz\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzzabw$2wefzzz\");\n+    }\n@@ -3270,0 +2780,2 @@\n+    @Test\n+    public static void stringBuilderNonexistentGroupError() {\n@@ -3271,4 +2783,4 @@\n-        blah = \"zzzabcdcdefzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*(ef)\");\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n+        final String blah = \"zzzabcdcdefzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd)*(ef)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n@@ -3276,6 +2788,3 @@\n-        try {\n-            m.appendReplacement(result, \"$1w$5w$3\");\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Correct result\n-        }\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+            m.appendReplacement(result, \"$1w$5w$3\"));\n+    }\n@@ -3283,0 +2792,2 @@\n+    @Test\n+    public static void stringBuilderDoubleDigitGroupReferences() {\n@@ -3284,4 +2795,4 @@\n-        blah = \"zzz123456789101112zzz\";\n-        p = Pattern.compile(\"(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)\");\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n+        final String blah = \"zzz123456789101112zzz\";\n+        final Pattern p = Pattern.compile(\"(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n@@ -3290,2 +2801,2 @@\n-        if (!result.toString().equals(\"zzz1w11w3\"))\n-            failCount++;\n+        assertEquals(result.toString(), \"zzz1w11w3\");\n+    }\n@@ -3293,0 +2804,2 @@\n+    @Test\n+    public static void stringBuilderCheckBackoff() {\n@@ -3294,4 +2807,4 @@\n-        blah = \"zzzabcdcdefzzz\";\n-        p = Pattern.compile(\"(ab)(cd)*(ef)\");\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n+        final String blah = \"zzzabcdcdefzzz\";\n+        final Pattern p = Pattern.compile(\"(ab)(cd)*(ef)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n@@ -3300,3 +2813,2 @@\n-        if (!result.toString().equals(\"zzzabwab5wef\"))\n-            failCount++;\n-\n+        assertEquals(result.toString(), \"zzzabwab5wef\");\n+    }\n@@ -3304,0 +2816,2 @@\n+    @Test\n+    public static void stringBuilderSupplementalLiteralSubstitution() {\n@@ -3306,9 +2820,6 @@\n-        blah = toSupplementaries(\"zzzblahzzz\");\n-        p = Pattern.compile(toSupplementaries(\"blah\"));\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n-        try {\n-            m.appendReplacement(result, toSupplementaries(\"blech\"));\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = toSupplementaries(\"zzzblahzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"blah\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n+        assertThrows(IllegalStateException.class,\n+                () -> m.appendReplacement(result, toSupplementaries(\"blech\")));\n@@ -3317,2 +2828,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzblech\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzblech\"));\n@@ -3320,2 +2830,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzblechzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzblechzzz\"));\n+    }\n@@ -3323,0 +2833,2 @@\n+    @Test\n+    public static void stringBuilderSupplementalSubstitutionWithGroups() {\n@@ -3324,9 +2836,6 @@\n-        blah = toSupplementaries(\"zzzabcdzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*\"));\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n-        try {\n-            m.appendReplacement(result, \"$1\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = toSupplementaries(\"zzzabcdzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n+        assertThrows(IllegalStateException.class,\n+                () -> m.appendReplacement(result, \"$1\"));\n@@ -3335,2 +2844,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzab\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzab\"));\n@@ -3339,2 +2847,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabzzz\"));\n+    }\n@@ -3342,0 +2850,2 @@\n+    @Test\n+    public static void stringBuilderSupplementalSubstitutionThreeGroups() {\n@@ -3343,9 +2853,6 @@\n-        blah = toSupplementaries(\"zzzabcdcdefzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n-        try {\n-            m.appendReplacement(result, toSupplementaries(\"$1w$2w$3\"));\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = toSupplementaries(\"zzzabcdcdefzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n+        assertThrows(IllegalStateException.class, () ->\n+            m.appendReplacement(result, toSupplementaries(\"$1w$2w$3\")));\n@@ -3354,2 +2861,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabwcdwef\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabwcdwef\"));\n@@ -3358,2 +2864,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabwcdwefzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabwcdwefzzz\"));\n+    }\n@@ -3361,0 +2867,2 @@\n+    @Test\n+    public static void stringBuilderSubstitutionSupplementalSkipMiddleThreeMatch() {\n@@ -3363,9 +2871,6 @@\n-        blah = toSupplementaries(\"zzzabcdzzzabcddzzzabcdzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd*)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n-        try {\n-            m.appendReplacement(result, \"$1\");\n-            failCount++;\n-        } catch (IllegalStateException e) {\n-        }\n+        final String blah = toSupplementaries(\"zzzabcdzzzabcddzzzabcdzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd*)\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n+        assertThrows(IllegalStateException.class, () ->\n+                m.appendReplacement(result, \"$1\"));\n@@ -3374,2 +2879,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzab\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzab\"));\n@@ -3380,2 +2884,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabzzzabcddzzzcd\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabzzzabcddzzzcd\"));\n@@ -3384,2 +2887,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabzzzabcddzzzcdzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabzzzabcddzzzcdzzz\"));\n+    }\n@@ -3387,0 +2890,2 @@\n+    @Test\n+    public static void stringBuilderSupplementalEscapedDollar() {\n@@ -3388,4 +2893,4 @@\n-        blah = toSupplementaries(\"zzzabcdcdefzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n+        final String blah = toSupplementaries(\"zzzabcdcdefzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n@@ -3394,2 +2899,1 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabw$2wef\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabw$2wef\"));\n@@ -3398,2 +2902,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabw$2wefzzz\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabw$2wefzzz\"));\n+    }\n@@ -3401,0 +2905,2 @@\n+    @Test\n+    public static void stringBuilderSupplementalNonExistentGroupError() {\n@@ -3402,4 +2908,4 @@\n-        blah = toSupplementaries(\"zzzabcdcdefzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n+        final String blah = toSupplementaries(\"zzzabcdcdefzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n@@ -3407,6 +2913,6 @@\n-        try {\n-            m.appendReplacement(result, toSupplementaries(\"$1w$5w$3\"));\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            \/\/ Correct result\n-        }\n+        assertThrows(IndexOutOfBoundsException.class, () ->\n+            m.appendReplacement(result, toSupplementaries(\"$1w$5w$3\")));\n+    }\n+\n+    @Test\n+    public static void stringBuilderSupplementalCheckDoubleDigitGroupReferences() {\n@@ -3414,4 +2920,4 @@\n-        blah = toSupplementaries(\"zzz123456789101112zzz\");\n-        p = Pattern.compile(\"(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)\");\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n+        final String blah = toSupplementaries(\"zzz123456789101112zzz\");\n+        final Pattern p = Pattern.compile(\"(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)\");\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n@@ -3420,2 +2926,2 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzz1w11w3\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzz1w11w3\"));\n+    }\n@@ -3423,0 +2929,2 @@\n+    @Test\n+    public static void stringBuilderSupplementalCheckBackoff() {\n@@ -3424,4 +2932,4 @@\n-        blah = toSupplementaries(\"zzzabcdcdefzzz\");\n-        p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n-        m = p.matcher(blah);\n-        result = new StringBuilder();\n+        final String blah = toSupplementaries(\"zzzabcdcdefzzz\");\n+        final Pattern p = Pattern.compile(toSupplementaries(\"(ab)(cd)*(ef)\"));\n+        final Matcher m = p.matcher(blah);\n+        final StringBuilder result = new StringBuilder();\n@@ -3430,2 +2938,5 @@\n-        if (!result.toString().equals(toSupplementaries(\"zzzabwab5wef\")))\n-            failCount++;\n+        assertEquals(result.toString(), toSupplementaries(\"zzzabwab5wef\"));\n+    }\n+\n+    @Test\n+    public static void stringBuilderCheckIllegalArgumentException() {\n@@ -3434,3 +2945,3 @@\n-        p = Pattern.compile(\"(abc)\");\n-        m = p.matcher(\"abcd\");\n-        result = new StringBuilder();\n+        final Pattern p = Pattern.compile(\"(abc)\");\n+        final Matcher m = p.matcher(\"abcd\");\n+        final StringBuilder result = new StringBuilder();\n@@ -3438,8 +2949,3 @@\n-        try {\n-            m.appendReplacement(result, (\"xyz$g\"));\n-            failCount++;\n-        } catch (IllegalArgumentException iae) {\n-            if (result.length() != 0)\n-                failCount++;\n-        }\n-        report(\"SB Substitution 2\");\n+        assertThrows(IllegalArgumentException.class, () ->\n+            m.appendReplacement(result, (\"xyz$g\")));\n+        assertEquals(result.length(), 0);\n@@ -3456,1 +2962,2 @@\n-    private static void substitutionBasher() {\n+    @Test\n+    public static void substitutionBasher() {\n@@ -3460,1 +2967,1 @@\n-            StringBuffer baseBuffer = new StringBuffer(100);\n+            StringBuilder baseBuffer = new StringBuilder(100);\n@@ -3467,2 +2974,2 @@\n-            StringBuffer bufferToSub = new StringBuffer(25);\n-            StringBuffer bufferToPat = new StringBuffer(50);\n+            StringBuilder bufferToSub = new StringBuilder(25);\n+            StringBuilder bufferToPat = new StringBuilder(50);\n@@ -3505,1 +3012,1 @@\n-            StringBuffer bufferToRep = new StringBuffer();\n+            StringBuilder bufferToRep = new StringBuilder();\n@@ -3507,1 +3014,1 @@\n-            bufferToRep.append(\"$\" + (groupIndex1 + 1));\n+            bufferToRep.append(\"$\").append(groupIndex1 + 1);\n@@ -3511,1 +3018,1 @@\n-            bufferToRep.append(\"$\" + (groupIndex2 + 1));\n+            bufferToRep.append(\"$\").append(groupIndex2 + 1);\n@@ -3518,7 +3025,5 @@\n-            StringBuffer bufferToRes = new StringBuffer();\n-            bufferToRes.append(leadingString);\n-            bufferToRes.append(groups[groupIndex1]);\n-            bufferToRes.append(randomMidString);\n-            bufferToRes.append(groups[groupIndex2]);\n-            bufferToRes.append(trailingString);\n-            String expectedResult = bufferToRes.toString();\n+            String expectedResult = leadingString +\n+                    groups[groupIndex1] +\n+                    randomMidString +\n+                    groups[groupIndex2] +\n+                    trailingString;\n@@ -3527,2 +3032,1 @@\n-            if (!result.equals(expectedResult))\n-                failCount++;\n+            assertEquals(result, expectedResult);\n@@ -3530,2 +3034,0 @@\n-\n-        report(\"Substitution Basher\");\n@@ -3542,1 +3044,2 @@\n-    private static void substitutionBasher2() {\n+    @Test\n+    public static void substitutionBasher2() {\n@@ -3593,1 +3096,1 @@\n-            bufferToRep.append(\"$\" + (groupIndex1 + 1));\n+            bufferToRep.append(\"$\").append(groupIndex1 + 1);\n@@ -3597,1 +3100,1 @@\n-            bufferToRep.append(\"$\" + (groupIndex2 + 1));\n+            bufferToRep.append(\"$\").append(groupIndex2 + 1);\n@@ -3604,7 +3107,5 @@\n-            StringBuilder bufferToRes = new StringBuilder();\n-            bufferToRes.append(leadingString);\n-            bufferToRes.append(groups[groupIndex1]);\n-            bufferToRes.append(randomMidString);\n-            bufferToRes.append(groups[groupIndex2]);\n-            bufferToRes.append(trailingString);\n-            String expectedResult = bufferToRes.toString();\n+            String expectedResult = leadingString +\n+                    groups[groupIndex1] +\n+                    randomMidString +\n+                    groups[groupIndex2] +\n+                    trailingString;\n@@ -3613,3 +3114,1 @@\n-            if (!result.equals(expectedResult)) {\n-                failCount++;\n-            }\n+            assertEquals(result, expectedResult);\n@@ -3617,2 +3116,0 @@\n-\n-        report(\"Substitution Basher 2\");\n@@ -3627,1 +3124,2 @@\n-    private static void escapes() throws Exception {\n+    @Test\n+    public static void escapes() {\n@@ -3630,2 +3128,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -3635,2 +3132,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -3640,4 +3136,1 @@\n-        if (!m.find())\n-            failCount++;\n-\n-        report(\"Escape sequences\");\n+        assertTrue(m.find());\n@@ -3650,1 +3143,2 @@\n-    private static void blankInput() throws Exception {\n+    @Test\n+    public static void blankInput() {\n@@ -3653,2 +3147,1 @@\n-        if (m.find())\n-            failCount++;\n+        assertFalse(m.find());\n@@ -3658,2 +3151,1 @@\n-        if (!m.find())\n-            failCount++;\n+        assertTrue(m.find());\n@@ -3663,2 +3155,1 @@\n-        if (m.find())\n-            failCount++;\n+        assertFalse(m.find());\n@@ -3668,4 +3159,1 @@\n-        if (!m.find())\n-            failCount++;\n-\n-        report(\"Blank input\");\n+        assertTrue(m.find());\n@@ -3678,1 +3166,2 @@\n-    private static void bm() throws Exception {\n+    @Test\n+    public static void bm() {\n@@ -3680,1 +3169,0 @@\n-        report(\"Boyer Moore (ASCII)\");\n@@ -3683,1 +3171,0 @@\n-        report(\"Boyer Moore (Supplementary)\");\n@@ -3686,3 +3173,1 @@\n-    private static void doBnM(int baseCharacter) throws Exception {\n-        int achar=0;\n-\n+    private static void doBnM(int baseCharacter) {\n@@ -3692,1 +3177,1 @@\n-            StringBuffer patternBuffer = new StringBuffer(patternLength);\n+            StringBuilder patternBuffer = new StringBuilder(patternLength);\n@@ -3717,2 +3202,2 @@\n-            String toSearch = null;\n-            StringBuffer s = null;\n+            String toSearch;\n+            StringBuffer s;\n@@ -3738,1 +3223,1 @@\n-            s = s.insert(insertIndex, pattern);\n+            s.insert(insertIndex, pattern);\n@@ -3743,2 +3228,1 @@\n-            if (!m.find())\n-                failCount++;\n+            assertTrue(m.find());\n@@ -3747,2 +3231,1 @@\n-            if (!m.group().equals(pattern))\n-                failCount++;\n+            assertEquals(m.group(), pattern);\n@@ -3751,2 +3234,1 @@\n-            if (m.start() != insertIndex)\n-                failCount++;\n+            assertEquals(m.start(), insertIndex);\n@@ -3761,1 +3243,2 @@\n-    private static void slice() throws Exception {\n+    @Test\n+    public static void slice() {\n@@ -3763,1 +3246,0 @@\n-        report(\"Slice\");\n@@ -3766,1 +3248,0 @@\n-        report(\"Slice (Supplementary)\");\n@@ -3769,4 +3250,1 @@\n-    private static void doSlice(int maxCharacter) throws Exception {\n-        Random generator = new Random();\n-        int achar=0;\n-\n+    private static void doSlice(int maxCharacter) {\n@@ -3776,1 +3254,1 @@\n-            StringBuffer patternBuffer = new StringBuffer(patternLength);\n+            StringBuilder patternBuffer = new StringBuilder(patternLength);\n@@ -3814,1 +3292,1 @@\n-            s = s.insert(insertIndex, pattern);\n+            s.insert(insertIndex, pattern);\n@@ -3819,2 +3297,1 @@\n-            if (!m.find())\n-                failCount++;\n+            assertTrue(m.find());\n@@ -3823,2 +3300,1 @@\n-            if (!m.group().equals(pattern))\n-                failCount++;\n+            assertEquals(m.group(), pattern);\n@@ -3827,2 +3303,1 @@\n-            if (m.start() != insertIndex)\n-                failCount++;\n+            assertEquals(m.start(), insertIndex);\n@@ -3832,17 +3307,0 @@\n-    private static void explainFailure(String pattern, String data,\n-                                       String expected, String actual) {\n-        System.err.println(\"----------------------------------------\");\n-        System.err.println(\"Pattern = \"+pattern);\n-        System.err.println(\"Data = \"+data);\n-        System.err.println(\"Expected = \" + expected);\n-        System.err.println(\"Actual   = \" + actual);\n-    }\n-\n-    private static void explainFailure(String pattern, String data,\n-                                       Throwable t) {\n-        System.err.println(\"----------------------------------------\");\n-        System.err.println(\"Pattern = \"+pattern);\n-        System.err.println(\"Data = \"+data);\n-        t.printStackTrace(System.err);\n-    }\n-\n@@ -3858,1 +3316,1 @@\n-    private static void processFile(String fileName) throws Exception {\n+    public static void processFile(String fileName) throws IOException {\n@@ -3877,2 +3335,4 @@\n-                explainFailure(patternString, dataString, e);\n-                failCount++;\n+                String line1 = \"----------------------------------------\";\n+                String line2 = \"Pattern = \" + patternString;\n+                String line3 = \"Data = \" + dataString;\n+                fail(line1 + System.lineSeparator() + line2 + System.lineSeparator() + line3 + System.lineSeparator());\n@@ -3885,1 +3345,1 @@\n-            StringBuffer result = new StringBuffer();\n+            StringBuilder result = new StringBuilder();\n@@ -3888,1 +3348,1 @@\n-            failCount += preMatchInvariants(m);\n+            preMatchInvariants(m);\n@@ -3893,1 +3353,1 @@\n-                failCount += postTrueMatchInvariants(m);\n+                postTrueMatchInvariants(m);\n@@ -3895,1 +3355,1 @@\n-                failCount += postFalseMatchInvariants(m);\n+                postFalseMatchInvariants(m);\n@@ -3899,1 +3359,1 @@\n-                result.append(m.group(0) + \" \");\n+                result.append(m.group(0)).append(\" \");\n@@ -3909,1 +3369,1 @@\n-                        result.append(\" \" +m.group(i));\n+                        result.append(\" \").append(m.group(i));\n@@ -3915,4 +3375,8 @@\n-            if (!result.toString().equals(expectedResult)) {\n-                explainFailure(patternString, dataString, expectedResult, result.toString());\n-                failCount++;\n-            }\n+            assertEquals(result.toString(), expectedResult,\n+                \"Pattern = \" + patternString +\n+                System.lineSeparator() +\n+                \"Data = \" + dataString +\n+                System.lineSeparator() +\n+                \"Expected = \" + expectedResult +\n+                System.lineSeparator() +\n+                \"Actual   = \" + result.toString());\n@@ -3920,2 +3384,0 @@\n-\n-        report(fileName);\n@@ -3924,15 +3386,4 @@\n-    private static int preMatchInvariants(Matcher m) {\n-        int failCount = 0;\n-        try {\n-            m.start();\n-            failCount++;\n-        } catch (IllegalStateException ise) {}\n-        try {\n-            m.end();\n-            failCount++;\n-        } catch (IllegalStateException ise) {}\n-        try {\n-            m.group();\n-            failCount++;\n-        } catch (IllegalStateException ise) {}\n-        return failCount;\n+    private static void preMatchInvariants(Matcher m) {\n+        assertThrows(IllegalStateException.class, m::start);\n+        assertThrows(IllegalStateException.class, m::end);\n+        assertThrows(IllegalStateException.class, m::group);\n@@ -3941,15 +3392,4 @@\n-    private static int postFalseMatchInvariants(Matcher m) {\n-        int failCount = 0;\n-        try {\n-            m.group();\n-            failCount++;\n-        } catch (IllegalStateException ise) {}\n-        try {\n-            m.start();\n-            failCount++;\n-        } catch (IllegalStateException ise) {}\n-        try {\n-            m.end();\n-            failCount++;\n-        } catch (IllegalStateException ise) {}\n-        return failCount;\n+    private static void postFalseMatchInvariants(Matcher m) {\n+        assertThrows(IllegalStateException.class, m::group);\n+        assertThrows(IllegalStateException.class, m::start);\n+        assertThrows(IllegalStateException.class, m::end);\n@@ -3958,17 +3398,5 @@\n-    private static int postTrueMatchInvariants(Matcher m) {\n-        int failCount = 0;\n-        \/\/assert(m.start() = m.start(0);\n-        if (m.start() != m.start(0))\n-            failCount++;\n-        \/\/assert(m.end() = m.end(0);\n-        if (m.start() != m.start(0))\n-            failCount++;\n-        \/\/assert(m.group() = m.group(0);\n-        if (!m.group().equals(m.group(0)))\n-            failCount++;\n-        try {\n-            m.group(50);\n-            failCount++;\n-        } catch (IndexOutOfBoundsException ise) {}\n-\n-        return failCount;\n+    private static void postTrueMatchInvariants(Matcher m) {\n+        assertEquals(m.start(), m.start(0));\n+        assertEquals(m.start(), m.start(0));\n+        assertEquals(m.group(), m.group(0));\n+        assertThrows(IndexOutOfBoundsException.class, () -> m.group(50));\n@@ -3982,2 +3410,1 @@\n-        String flagString = patternString.substring(\n-                                          break1+1, patternString.length());\n+        String flagString = patternString.substring(break1+1);\n@@ -4001,1 +3428,1 @@\n-    private static String grabLine(BufferedReader r) throws Exception {\n+    public static String grabLine(BufferedReader r) throws IOException {\n@@ -4007,1 +3434,1 @@\n-            StringBuffer temp = new StringBuffer(line);\n+            StringBuilder temp = new StringBuilder(line);\n@@ -4012,1 +3439,1 @@\n-            StringBuffer temp = new StringBuffer(line);\n+            StringBuilder temp = new StringBuilder(line);\n@@ -4023,53 +3450,0 @@\n-    private static void check(Pattern p, String s, String g, String expected) {\n-        Matcher m = p.matcher(s);\n-        m.find();\n-        if (!m.group(g).equals(expected) ||\n-            s.charAt(m.start(g)) != expected.charAt(0) ||\n-            s.charAt(m.end(g) - 1) != expected.charAt(expected.length() - 1))\n-            failCount++;\n-    }\n-\n-    private static void checkReplaceFirst(String p, String s, String r, String expected)\n-    {\n-        if (!expected.equals(Pattern.compile(p)\n-                                    .matcher(s)\n-                                    .replaceFirst(r)))\n-            failCount++;\n-    }\n-\n-    private static void checkReplaceAll(String p, String s, String r, String expected)\n-    {\n-        if (!expected.equals(Pattern.compile(p)\n-                                    .matcher(s)\n-                                    .replaceAll(r)))\n-            failCount++;\n-    }\n-\n-    private static void checkExpectedFail(String p) {\n-        try {\n-            Pattern.compile(p);\n-        } catch (PatternSyntaxException pse) {\n-            \/\/pse.printStackTrace();\n-            return;\n-        }\n-        failCount++;\n-    }\n-\n-    private static void checkExpectedIAE(Matcher m, String g) {\n-        m.find();\n-        try {\n-            m.group(g);\n-        } catch (IllegalArgumentException x) {\n-            \/\/iae.printStackTrace();\n-            try {\n-                m.start(g);\n-            } catch (IllegalArgumentException xx) {\n-                try {\n-                    m.start(g);\n-                } catch (IllegalArgumentException xxx) {\n-                    return;\n-                }\n-            }\n-        }\n-        failCount++;\n-    }\n@@ -4077,17 +3451,0 @@\n-    private static void checkExpectedNPE(Matcher m) {\n-        m.find();\n-        try {\n-            m.group(null);\n-        } catch (NullPointerException x) {\n-            try {\n-                m.start(null);\n-            } catch (NullPointerException xx) {\n-                try {\n-                    m.end(null);\n-                } catch (NullPointerException xxx) {\n-                    return;\n-                }\n-            }\n-        }\n-        failCount++;\n-    }\n@@ -4095,1 +3452,2 @@\n-    private static void namedGroupCaptureTest() throws Exception {\n+    @Test\n+    public static void namedGroupCaptureTest() {\n@@ -4210,3 +3568,2 @@\n-        if (!\"abcdefghij\".replaceFirst(\"cd(?<gn>ef)gh\", \"${gn}\").equals(\"abefij\") ||\n-            !\"abbbcbdbefgh\".replaceAll(\"(?<gn>[a-e])b\", \"${gn}\").equals(\"abcdefgh\"))\n-            failCount++;\n+        assertTrue(\"abcdefghij\".replaceFirst(\"cd(?<gn>ef)gh\", \"${gn}\").equals(\"abefij\") &&\n+                   \"abbbcbdbefgh\".replaceAll(\"(?<gn>[a-e])b\", \"${gn}\").equals(\"abcdefgh\"));\n@@ -4220,4 +3577,12 @@\n-        checkExpectedIAE(Pattern.compile(\"(?<gname>abc)(def)\").matcher(\"abcdef\"),\n-                         \"gnameX\");\n-        checkExpectedNPE(Pattern.compile(\"(?<gname>abc)(def)\").matcher(\"abcdef\"));\n-        report(\"NamedGroupCapture\");\n+\n+        Matcher iaeMatcher = Pattern.compile(\"(?<gname>abc)(def)\").matcher(\"abcdef\");\n+        iaeMatcher.find();\n+        assertThrows(IllegalArgumentException.class, () -> iaeMatcher.group(\"gnameX\"));\n+        assertThrows(IllegalArgumentException.class, () -> iaeMatcher.start(\"gnameX\"));\n+        assertThrows(IllegalArgumentException.class, () -> iaeMatcher.start(\"gnameX\"));\n+\n+        Matcher npeMatcher = Pattern.compile(\"(?<gname>abc)(def)\").matcher(\"abcdef\");\n+        npeMatcher.find();\n+        assertThrows(NullPointerException.class, () -> npeMatcher.group(null));\n+        assertThrows(NullPointerException.class, () -> npeMatcher.start(null));\n+        assertThrows(NullPointerException.class, () -> npeMatcher.end(null));\n@@ -4227,1 +3592,2 @@\n-    private static void nonBmpClassComplementTest() throws Exception {\n+    @Test\n+    public static void nonBmpClassComplementTest() {\n@@ -4231,2 +3597,1 @@\n-        if (m.find() && m.start() == 1)\n-            failCount++;\n+        assertFalse(m.find() && m.start() == 1);\n@@ -4237,4 +3602,2 @@\n-        if (m.find())\n-            failCount++;\n-        if (!m.hitEnd())\n-            failCount++;\n+        assertFalse(m.find());\n+        assertTrue(m.hitEnd());\n@@ -4245,2 +3608,1 @@\n-        if (m.find() && m.start() == 1)\n-            failCount++;\n+        assertFalse(m.find() && m.start() == 1);\n@@ -4250,4 +3612,1 @@\n-        if (m.find() && m.start() == 1)\n-            failCount++;\n-\n-        report(\"NonBmpClassComplement\");\n+        assertFalse(m.find() && m.start() == 1);\n@@ -4256,1 +3615,2 @@\n-    private static void unicodePropertiesTest() throws Exception {\n+    @Test\n+    public static void unicodePropertiesTest() {\n@@ -4258,11 +3618,10 @@\n-        if (!Pattern.compile(\"\\\\p{IsLu}\").matcher(\"A\").matches() ||\n-            !Pattern.compile(\"\\\\p{Lu}\").matcher(\"A\").matches() ||\n-            !Pattern.compile(\"\\\\p{gc=Lu}\").matcher(\"A\").matches() ||\n-            !Pattern.compile(\"\\\\p{general_category=Lu}\").matcher(\"A\").matches() ||\n-            !Pattern.compile(\"\\\\p{IsLatin}\").matcher(\"B\").matches() ||\n-            !Pattern.compile(\"\\\\p{sc=Latin}\").matcher(\"B\").matches() ||\n-            !Pattern.compile(\"\\\\p{script=Latin}\").matcher(\"B\").matches() ||\n-            !Pattern.compile(\"\\\\p{InBasicLatin}\").matcher(\"c\").matches() ||\n-            !Pattern.compile(\"\\\\p{blk=BasicLatin}\").matcher(\"c\").matches() ||\n-            !Pattern.compile(\"\\\\p{block=BasicLatin}\").matcher(\"c\").matches())\n-            failCount++;\n+        assertFalse(!Pattern.compile(\"\\\\p{IsLu}\").matcher(\"A\").matches() ||\n+                    !Pattern.compile(\"\\\\p{Lu}\").matcher(\"A\").matches() ||\n+                    !Pattern.compile(\"\\\\p{gc=Lu}\").matcher(\"A\").matches() ||\n+                    !Pattern.compile(\"\\\\p{general_category=Lu}\").matcher(\"A\").matches() ||\n+                    !Pattern.compile(\"\\\\p{IsLatin}\").matcher(\"B\").matches() ||\n+                    !Pattern.compile(\"\\\\p{sc=Latin}\").matcher(\"B\").matches() ||\n+                    !Pattern.compile(\"\\\\p{script=Latin}\").matcher(\"B\").matches() ||\n+                    !Pattern.compile(\"\\\\p{InBasicLatin}\").matcher(\"c\").matches() ||\n+                    !Pattern.compile(\"\\\\p{blk=BasicLatin}\").matcher(\"c\").matches() ||\n+                    !Pattern.compile(\"\\\\p{block=BasicLatin}\").matcher(\"c\").matches());\n@@ -4295,3 +3654,2 @@\n-            if (!m.matches()) {\n-                failCount++;\n-            }\n+            assertTrue(m.matches());\n+\n@@ -4300,3 +3658,1 @@\n-            if (other.matches()) {\n-                failCount++;\n-            }\n+            assertFalse(other.matches());\n@@ -4318,3 +3674,1 @@\n-            if (!m.matches()) {\n-                failCount++;\n-            }\n+            assertTrue(m.matches());\n@@ -4323,3 +3677,1 @@\n-            if (other.matches()) {\n-                failCount++;\n-            }\n+            assertFalse(other.matches());\n@@ -4329,1 +3681,0 @@\n-        report(\"unicodeProperties\");\n@@ -4332,1 +3683,2 @@\n-    private static void unicodeHexNotationTest() throws Exception {\n+    @Test\n+    public static void unicodeHexNotationTest() {\n@@ -4361,8 +3713,4 @@\n-             if (!Pattern.matches(\"A\" + hexUTF16 + \"B\", s))\n-                 failCount++;\n-             if (!Pattern.matches(\"A[\" + hexUTF16 + \"]B\", s))\n-                 failCount++;\n-             if (!Pattern.matches(\"A\" + hexCodePoint + \"B\", s))\n-                 failCount++;\n-             if (!Pattern.matches(\"A[\" + hexCodePoint + \"]B\", s))\n-                 failCount++;\n+             assertTrue(Pattern.matches(\"A\" + hexUTF16 + \"B\", s));\n+             assertTrue(Pattern.matches(\"A[\" + hexUTF16 + \"]B\", s));\n+             assertTrue(Pattern.matches(\"A\" + hexCodePoint + \"B\", s));\n+             assertTrue(Pattern.matches(\"A[\" + hexCodePoint + \"]B\", s));\n@@ -4370,1 +3718,0 @@\n-         report(\"unicodeHexNotation\");\n@@ -4373,1 +3720,2 @@\n-    private static void unicodeClassesTest() throws Exception {\n+    @Test\n+    public static void unicodeClassesTest() {\n@@ -4504,1 +3852,1 @@\n-                failCount++;\n+                fail();\n@@ -4510,2 +3858,1 @@\n-        if (!bwbU.reset(\"\\u0180sherman\\u0400\").matches())\n-            failCount++;\n+        assertTrue(bwbU.reset(\"\\u0180sherman\\u0400\").matches());\n@@ -4513,2 +3860,1 @@\n-        if (!bwbU.reset(\"\\u0180sh\\u0345erman\\u0400\").matches())\n-            failCount++;\n+        assertTrue(bwbU.reset(\"\\u0180sh\\u0345erman\\u0400\").matches());\n@@ -4516,5 +3862,2 @@\n-        if (!bwbU.reset(\"\\u0724\\u0739\\u0724\").matches())\n-            failCount++;\n-        if (!bwbEU.reset(\"\\u0724\\u0739\\u0724\").matches())\n-            failCount++;\n-        report(\"unicodePredefinedClasses\");\n+        assertTrue(bwbU.reset(\"\\u0724\\u0739\\u0724\").matches());\n+        assertTrue(bwbEU.reset(\"\\u0724\\u0739\\u0724\").matches());\n@@ -4523,1 +3866,2 @@\n-    private static void unicodeCharacterNameTest() throws Exception {\n+    @Test\n+    public static void unicodeCharacterNameTest() {\n@@ -4532,3 +3876,1 @@\n-            if (!Pattern.compile(p).matcher(str).matches()) {\n-                failCount++;\n-            }\n+            assertTrue(Pattern.compile(p).matcher(str).matches());\n@@ -4537,3 +3879,1 @@\n-            if (!Pattern.compile(p).matcher(str).matches()) {\n-                failCount++;\n-            }\n+            assertTrue(Pattern.compile(p).matcher(str).matches());\n@@ -4550,3 +3890,1 @@\n-                if (!Pattern.compile(p).matcher(str).matches()) {\n-                    failCount++;\n-                }\n+                assertTrue(Pattern.compile(p).matcher(str).matches());\n@@ -4555,3 +3893,1 @@\n-            if (Pattern.compile(p).matcher(str).matches()) {\n-                failCount++;\n-            }\n+            assertFalse(Pattern.compile(p).matcher(str).matches());\n@@ -4564,1 +3900,1 @@\n-            StringBuffer sb = new StringBuffer(1024);\n+            StringBuilder sb = new StringBuilder(1024);\n@@ -4570,1 +3906,1 @@\n-                sb.append(\"\\\\N{\" + Character.getName(cp) + \"}\");\n+                sb.append(\"\\\\N{\").append(Character.getName(cp)).append(\"}\");\n@@ -4575,3 +3911,1 @@\n-            if (!Pattern.compile(p).matcher(str).matches()) {\n-                failCount++;\n-            }\n+            assertTrue(Pattern.compile(p).matcher(str).matches());\n@@ -4579,1 +3913,0 @@\n-        report(\"unicodeCharacterName\");\n@@ -4582,1 +3915,2 @@\n-    private static void horizontalAndVerticalWSTest() throws Exception {\n+    @Test\n+    public static void horizontalAndVerticalWSTest() {\n@@ -4590,12 +3924,8 @@\n-        if (!Pattern.compile(\"\\\\h+\").matcher(hws).matches() ||\n-            !Pattern.compile(\"[\\\\h]+\").matcher(hws).matches())\n-            failCount++;\n-        if (Pattern.compile(\"\\\\H\").matcher(hws).find() ||\n-            Pattern.compile(\"[\\\\H]\").matcher(hws).find())\n-            failCount++;\n-        if (!Pattern.compile(\"\\\\v+\").matcher(vws).matches() ||\n-            !Pattern.compile(\"[\\\\v]+\").matcher(vws).matches())\n-            failCount++;\n-        if (Pattern.compile(\"\\\\V\").matcher(vws).find() ||\n-            Pattern.compile(\"[\\\\V]\").matcher(vws).find())\n-            failCount++;\n+        assertTrue(Pattern.compile(\"\\\\h+\").matcher(hws).matches() &&\n+                   Pattern.compile(\"[\\\\h]+\").matcher(hws).matches());\n+        assertTrue(!Pattern.compile(\"\\\\H\").matcher(hws).find() &&\n+                   !Pattern.compile(\"[\\\\H]\").matcher(hws).find());\n+        assertTrue(Pattern.compile(\"\\\\v+\").matcher(vws).matches() &&\n+                   Pattern.compile(\"[\\\\v]+\").matcher(vws).matches());\n+        assertTrue(!Pattern.compile(\"\\\\V\").matcher(vws).find() &&\n+                   !Pattern.compile(\"[\\\\V]\").matcher(vws).find());\n@@ -4608,2 +3938,1 @@\n-            if (!m.find() || !c.equals(m.group()))\n-                failCount++;\n+            assertTrue(m.find() && c.equals(m.group()));\n@@ -4611,9 +3940,8 @@\n-            if (!m.find() || !c.equals(m.group()))\n-                failCount++;\n-\n-            m = Pattern.compile(\"\\\\H\").matcher(hws.substring(0, i) + ng + hws.substring(i));\n-            if (!m.find() || !ng.equals(m.group()))\n-                failCount++;\n-            m = Pattern.compile(\"[\\\\H]\").matcher(hws.substring(0, i) + ng + hws.substring(i));\n-            if (!m.find() || !ng.equals(m.group()))\n-                failCount++;\n+            assertTrue(m.find() && c.equals(m.group()));\n+\n+            String matcherSubstring = hws.substring(0, i) + ng + hws.substring(i);\n+\n+            m = Pattern.compile(\"\\\\H\").matcher(matcherSubstring);\n+            assertTrue(m.find() && ng.equals(m.group()));\n+            m = Pattern.compile(\"[\\\\H]\").matcher(matcherSubstring);\n+            assertTrue(m.find() && ng.equals(m.group()));\n@@ -4624,2 +3952,1 @@\n-            if (!m.find() || !c.equals(m.group()))\n-                failCount++;\n+            assertTrue(m.find() && c.equals(m.group()));\n@@ -4627,9 +3954,7 @@\n-            if (!m.find() || !c.equals(m.group()))\n-                failCount++;\n-\n-            m = Pattern.compile(\"\\\\V\").matcher(vws.substring(0, i) + ng + vws.substring(i));\n-            if (!m.find() || !ng.equals(m.group()))\n-                failCount++;\n-            m = Pattern.compile(\"[\\\\V]\").matcher(vws.substring(0, i) + ng + vws.substring(i));\n-            if (!m.find() || !ng.equals(m.group()))\n-                failCount++;\n+            assertTrue(m.find() && c.equals(m.group()));\n+\n+            String matcherSubstring = vws.substring(0, i) + ng + vws.substring(i);\n+            m = Pattern.compile(\"\\\\V\").matcher(matcherSubstring);\n+            assertTrue(m.find() && ng.equals(m.group()));\n+            m = Pattern.compile(\"[\\\\V]\").matcher(matcherSubstring);\n+            assertTrue(m.find() && ng.equals(m.group()));\n@@ -4638,3 +3963,1 @@\n-        if (!Pattern.compile(\"[\\\\v-\\\\v]\").matcher(String.valueOf((char)0x0B)).matches())\n-            failCount++;\n-        report(\"horizontalAndVerticalWSTest\");\n+        assertTrue(Pattern.compile(\"[\\\\v-\\\\v]\").matcher(String.valueOf((char)0x0B)).matches());\n@@ -4643,1 +3966,2 @@\n-    private static void linebreakTest() throws Exception {\n+    @Test\n+    public static void linebreakTest() {\n@@ -4647,1 +3971,1 @@\n-        if (!(Pattern.compile(\"\\\\R+\").matcher(linebreaks).matches() &&\n+        assertTrue((Pattern.compile(\"\\\\R+\").matcher(linebreaks).matches() &&\n@@ -4652,5 +3976,2 @@\n-              Pattern.compile(\"\\\\R\\\\n\").matcher(crnl).matches()) && \/\/ backtracking\n-              !Pattern.compile(\"((?<!\\\\R)\\\\s)*\").matcher(crnl).matches()) { \/\/ #8176029\n-            failCount++;\n-        }\n-        report(\"linebreakTest\");\n+              Pattern.compile(\"\\\\R\\\\n\").matcher(crnl).matches()) || \/\/ backtracking\n+              Pattern.compile(\"((?<!\\\\R)\\\\s)*\").matcher(crnl).matches()); \/\/ #8176029\n@@ -4660,25 +3981,24 @@\n-    private static void branchTest() throws Exception {\n-        if (!Pattern.compile(\"(a)?bc|d\").matcher(\"d\").find() ||     \/\/ greedy\n-            !Pattern.compile(\"(a)+bc|d\").matcher(\"d\").find() ||\n-            !Pattern.compile(\"(a)*bc|d\").matcher(\"d\").find() ||\n-            !Pattern.compile(\"(a)??bc|d\").matcher(\"d\").find() ||    \/\/ reluctant\n-            !Pattern.compile(\"(a)+?bc|d\").matcher(\"d\").find() ||\n-            !Pattern.compile(\"(a)*?bc|d\").matcher(\"d\").find() ||\n-            !Pattern.compile(\"(a)?+bc|d\").matcher(\"d\").find() ||    \/\/ possessive\n-            !Pattern.compile(\"(a)++bc|d\").matcher(\"d\").find() ||\n-            !Pattern.compile(\"(a)*+bc|d\").matcher(\"d\").find() ||\n-            !Pattern.compile(\"(a)?bc|d\").matcher(\"d\").matches() ||  \/\/ greedy\n-            !Pattern.compile(\"(a)+bc|d\").matcher(\"d\").matches() ||\n-            !Pattern.compile(\"(a)*bc|d\").matcher(\"d\").matches() ||\n-            !Pattern.compile(\"(a)??bc|d\").matcher(\"d\").matches() || \/\/ reluctant\n-            !Pattern.compile(\"(a)+?bc|d\").matcher(\"d\").matches() ||\n-            !Pattern.compile(\"(a)*?bc|d\").matcher(\"d\").matches() ||\n-            !Pattern.compile(\"(a)?+bc|d\").matcher(\"d\").matches() || \/\/ possessive\n-            !Pattern.compile(\"(a)++bc|d\").matcher(\"d\").matches() ||\n-            !Pattern.compile(\"(a)*+bc|d\").matcher(\"d\").matches() ||\n-            !Pattern.compile(\"(a)?bc|de\").matcher(\"de\").find() ||   \/\/ others\n-            !Pattern.compile(\"(a)??bc|de\").matcher(\"de\").find() ||\n-            !Pattern.compile(\"(a)?bc|de\").matcher(\"de\").matches() ||\n-            !Pattern.compile(\"(a)??bc|de\").matcher(\"de\").matches())\n-            failCount++;\n-        report(\"branchTest\");\n+    @Test\n+    public static void branchTest() {\n+        assertFalse(!Pattern.compile(\"(a)?bc|d\").matcher(\"d\").find() ||     \/\/ greedy\n+                    !Pattern.compile(\"(a)+bc|d\").matcher(\"d\").find() ||\n+                    !Pattern.compile(\"(a)*bc|d\").matcher(\"d\").find() ||\n+                    !Pattern.compile(\"(a)??bc|d\").matcher(\"d\").find() ||    \/\/ reluctant\n+                    !Pattern.compile(\"(a)+?bc|d\").matcher(\"d\").find() ||\n+                    !Pattern.compile(\"(a)*?bc|d\").matcher(\"d\").find() ||\n+                    !Pattern.compile(\"(a)?+bc|d\").matcher(\"d\").find() ||    \/\/ possessive\n+                    !Pattern.compile(\"(a)++bc|d\").matcher(\"d\").find() ||\n+                    !Pattern.compile(\"(a)*+bc|d\").matcher(\"d\").find() ||\n+                    !Pattern.compile(\"(a)?bc|d\").matcher(\"d\").matches() ||  \/\/ greedy\n+                    !Pattern.compile(\"(a)+bc|d\").matcher(\"d\").matches() ||\n+                    !Pattern.compile(\"(a)*bc|d\").matcher(\"d\").matches() ||\n+                    !Pattern.compile(\"(a)??bc|d\").matcher(\"d\").matches() || \/\/ reluctant\n+                    !Pattern.compile(\"(a)+?bc|d\").matcher(\"d\").matches() ||\n+                    !Pattern.compile(\"(a)*?bc|d\").matcher(\"d\").matches() ||\n+                    !Pattern.compile(\"(a)?+bc|d\").matcher(\"d\").matches() || \/\/ possessive\n+                    !Pattern.compile(\"(a)++bc|d\").matcher(\"d\").matches() ||\n+                    !Pattern.compile(\"(a)*+bc|d\").matcher(\"d\").matches() ||\n+                    !Pattern.compile(\"(a)?bc|de\").matcher(\"de\").find() ||   \/\/ others\n+                    !Pattern.compile(\"(a)??bc|de\").matcher(\"de\").find() ||\n+                    !Pattern.compile(\"(a)?bc|de\").matcher(\"de\").matches() ||\n+                    !Pattern.compile(\"(a)??bc|de\").matcher(\"de\").matches());\n@@ -4688,1 +4008,2 @@\n-    private static void groupCurlyNotFoundSuppTest() throws Exception {\n+    @Test\n+    public static void groupCurlyNotFoundSuppTest() {\n@@ -4699,7 +4020,1 @@\n-            try {\n-                if (m.find()) {\n-                    failCount++;\n-                }\n-            } catch (Exception x) {\n-                failCount++;\n-            }\n+            assertFalse(m.find());\n@@ -4707,1 +4022,0 @@\n-        report(\"GroupCurly NotFoundSupp\");\n@@ -4711,6 +4025,4 @@\n-    private static void groupCurlyBackoffTest() throws Exception {\n-        if (!\"abc1c\".matches(\"(\\\\w)+1\\\\1\") ||\n-            \"abc11\".matches(\"(\\\\w)+1\\\\1\")) {\n-            failCount++;\n-        }\n-        report(\"GroupCurly backoff\");\n+    @Test\n+    public static void groupCurlyBackoffTest() {\n+        assertFalse(!\"abc1c\".matches(\"(\\\\w)+1\\\\1\") ||\n+                    \"abc11\".matches(\"(\\\\w)+1\\\\1\"));\n@@ -4720,1 +4032,2 @@\n-    private static void patternAsPredicate() throws Exception {\n+    @Test\n+    public static void patternAsPredicate() {\n@@ -4723,13 +4036,4 @@\n-        if (p.test(\"\")) {\n-            failCount++;\n-        }\n-        if (!p.test(\"word\")) {\n-            failCount++;\n-        }\n-        if (p.test(\"1234\")) {\n-            failCount++;\n-        }\n-        if (!p.test(\"word1234\")) {\n-            failCount++;\n-        }\n-        report(\"Pattern.asPredicate\");\n+        assertFalse(p.test(\"\"));\n+        assertTrue(p.test(\"word\"));\n+        assertFalse(p.test(\"1234\"));\n+        assertTrue(p.test(\"word1234\"));\n@@ -4739,1 +4043,2 @@\n-    private static void patternAsMatchPredicate() throws Exception {\n+    @Test\n+    public static void patternAsMatchPredicate() {\n@@ -4742,13 +4047,4 @@\n-        if (p.test(\"\")) {\n-            failCount++;\n-        }\n-        if (!p.test(\"word\")) {\n-            failCount++;\n-        }\n-        if (p.test(\"1234word\")) {\n-            failCount++;\n-        }\n-        if (p.test(\"1234\")) {\n-            failCount++;\n-        }\n-        report(\"Pattern.asMatchPredicate\");\n+        assertFalse(p.test(\"\"));\n+        assertTrue(p.test(\"word\"));\n+        assertFalse(p.test(\"1234word\"));\n+        assertFalse(p.test(\"1234\"));\n@@ -4759,1 +4055,2 @@\n-    private static void invalidFlags() throws Exception {\n+    @Test\n+    public static void invalidFlags() {\n@@ -4774,5 +4071,3 @@\n-                try {\n-                    Pattern.compile(\".\", flag);\n-                    failCount++;\n-                } catch (IllegalArgumentException expected) {\n-                }\n+                int finalFlag = flag;\n+                assertThrows(IllegalArgumentException.class, () ->\n+                    Pattern.compile(\".\", finalFlag));\n@@ -4781,1 +4076,0 @@\n-        report(\"Invalid compile flags\");\n@@ -4785,2 +4079,3 @@\n-    private static void embeddedFlags() throws Exception {\n-        try {\n+    @Test\n+    public static void embeddedFlags() {\n+            \/\/Runs without exception.\n@@ -4796,4 +4091,0 @@\n-        } catch (PatternSyntaxException x) {\n-            failCount++;\n-        }\n-        report(\"Embedded flags\");\n@@ -4802,1 +4093,2 @@\n-    private static void grapheme() throws Exception {\n+    @Test\n+    public static void grapheme() throws Exception {\n@@ -4837,1 +4129,1 @@\n-                            System.out.println(\"Failed pattern \\\\X [\" + ln + \"] : \"\n+                                 fail(\"Failed pattern \\\\X [\" + ln + \"] : \"\n@@ -4840,1 +4132,0 @@\n-                            failCount++;\n@@ -4843,3 +4134,1 @@\n-                    if (m.find()) {\n-                        failCount++;\n-                    }\n+                    assertFalse(m.find());\n@@ -4854,1 +4143,1 @@\n-                            System.out.println(\"Failed pattern \\\\b{g} [\" + ln + \"] : \"\n+                                 fail(\"Failed pattern \\\\b{g} [\" + ln + \"] : \"\n@@ -4857,4 +4146,0 @@\n-                            failCount++;\n-                        }\n-                        if (!\"\".equals(m.group())) {\n-                            failCount++;\n@@ -4862,0 +4147,1 @@\n+                        assertEquals(\"\", m.group());\n@@ -4864,3 +4150,1 @@\n-                    if (m.find()) {\n-                        failCount++;\n-                    }\n+                    assertFalse(m.find());\n@@ -4872,1 +4156,1 @@\n-                            System.out.println(\"Failed \\\\b{g} [\" + ln + \"] : \"\n+                                 fail(\"Failed \\\\b{g} [\" + ln + \"] : \"\n@@ -4875,1 +4159,0 @@\n-                            failCount++;\n@@ -4878,3 +4161,1 @@\n-                    if (s.hasNext(p)) {\n-                        failCount++;\n-                    }\n+                    assertFalse(s.hasNext(p));\n@@ -4886,1 +4167,1 @@\n-                            System.out.println(\"Failed \\\\b{g} [\" + ln + \"] : \"\n+                                 fail(\"Failed \\\\b{g} [\" + ln + \"] : \"\n@@ -4889,1 +4170,0 @@\n-                            failCount++;\n@@ -4892,3 +4172,1 @@\n-                    if (s.hasNext()) {\n-                        failCount++;\n-                    }\n+                    assertFalse(s.hasNext());\n@@ -4897,4 +4175,3 @@\n-        if (!Pattern.compile(\"\\\\X{10}\").matcher(\"abcdefghij\").matches() ||\n-            !Pattern.compile(\"\\\\b{g}(?:\\\\X\\\\b{g}){5}\\\\b{g}\").matcher(\"abcde\").matches() ||\n-            !Pattern.compile(\"(?:\\\\X\\\\b{g}){2}\").matcher(\"\\ud800\\udc00\\ud801\\udc02\").matches())\n-            failCount++;\n+        assertTrue(Pattern.compile(\"\\\\X{10}\").matcher(\"abcdefghij\").matches() &&\n+                   Pattern.compile(\"\\\\b{g}(?:\\\\X\\\\b{g}){5}\\\\b{g}\").matcher(\"abcde\").matches() &&\n+                   Pattern.compile(\"(?:\\\\X\\\\b{g}){2}\").matcher(\"\\ud800\\udc00\\ud801\\udc02\").matches());\n@@ -4902,3 +4179,1 @@\n-        if (!Pattern.compile(\"\\\\b{1}hello\\\\b{1} \\\\b{1}world\\\\b{1}\").matcher(\"hello world\").matches())\n-            failCount++;\n-        report(\"Unicode extended grapheme cluster\");\n+        assertTrue(Pattern.compile(\"\\\\b{1}hello\\\\b{1} \\\\b{1}world\\\\b{1}\").matcher(\"hello world\").matches());\n@@ -4908,1 +4183,2 @@\n-    private static void expoBacktracking() throws Exception {\n+    @Test\n+    public static void expoBacktracking() {\n@@ -4989,3 +4265,1 @@\n-            if (r != Pattern.compile(p).matcher(s).matches()) {\n-                failCount++;\n-            }\n+            assertEquals(r, Pattern.compile(p).matcher(s).matches());\n@@ -4995,1 +4269,2 @@\n-    private static void invalidGroupName() {\n+    @Test\n+    public static void invalidGroupName() {\n@@ -5001,5 +4276,2 @@\n-                try {\n-                    Pattern.compile(pat);\n-                    failCount++;\n-                } catch (PatternSyntaxException e) {\n-                    if (!e.getMessage().startsWith(\n+                var e = expectThrows(PatternSyntaxException.class, () -> Pattern.compile(pat));\n+                assertTrue(e.getMessage().startsWith(\n@@ -5007,4 +4279,1 @@\n-                            + \" Latin letter\")) {\n-                        failCount++;\n-                    }\n-                }\n+                            + \" Latin letter\"));\n@@ -5018,9 +4287,4 @@\n-                try {\n-                    Pattern.compile(pat);\n-                    failCount++;\n-                } catch (PatternSyntaxException e) {\n-                    if (!e.getMessage().startsWith(\n-                            \"named capturing group is missing trailing '>'\")) {\n-                        failCount++;\n-                    }\n-                }\n+                var e = expectThrows(PatternSyntaxException.class, () ->\n+                    Pattern.compile(pat));\n+                    assertTrue(e.getMessage().startsWith(\n+                            \"named capturing group is missing trailing '>'\"));\n@@ -5029,1 +4293,0 @@\n-        report(\"Invalid capturing group names\");\n@@ -5032,1 +4295,2 @@\n-    private static void illegalRepetitionRange() {\n+    @Test\n+    public static void illegalRepetitionRange() {\n@@ -5042,13 +4306,3 @@\n-            try {\n-                Pattern.compile(pat);\n-                failCount++;\n-                System.out.println(\"Expected to fail. Pattern: \" + pat);\n-            } catch (PatternSyntaxException e) {\n-                if (!e.getMessage().startsWith(\"Illegal repetition\")) {\n-                    failCount++;\n-                    System.out.println(\"Unexpected error message: \" + e.getMessage());\n-                }\n-            } catch (Throwable t) {\n-                failCount++;\n-                System.out.println(\"Unexpected exception: \" + t);\n-            }\n+            var e = expectThrows(PatternSyntaxException.class, () ->\n+                    Pattern.compile(pat));\n+            assertTrue(e.getMessage().startsWith(\"Illegal repetition\"));\n@@ -5056,1 +4310,0 @@\n-        report(\"illegalRepetitionRange\");\n@@ -5059,8 +4312,4 @@\n-    private static void surrogatePairWithCanonEq() {\n-        try {\n-            Pattern.compile(\"\\ud834\\udd21\", Pattern.CANON_EQ);\n-        } catch (Throwable t) {\n-            failCount++;\n-            System.out.println(\"Unexpected exception: \" + t);\n-        }\n-        report(\"surrogatePairWithCanonEq\");\n+    @Test\n+    public static void surrogatePairWithCanonEq() {\n+        \/\/Runs without exception\n+        Pattern.compile(\"\\ud834\\udd21\", Pattern.CANON_EQ);\n@@ -5069,1 +4318,1 @@\n-    private static String s2x(String s) {\n+    public static String s2x(String s) {\n@@ -5078,1 +4327,2 @@\n-    private static void lineBreakWithQuantifier() {\n+    @Test\n+    public static void lineBreakWithQuantifier() {\n@@ -5142,5 +4392,2 @@\n-                        if (!m.reset(in).matches()) {\n-                            failCount++;\n-                            System.err.println(\"Expected to match '\" +\n-                                    s2x(in) + \"' =~ \/\" + p + \"\/\");\n-                        }\n+                        assertTrue(m.reset(in).matches(), \"Expected to match '\"\n+                                + s2x(in) + \"' =~ \/\" + p + \"\/\");\n@@ -5151,1 +4398,0 @@\n-        report(\"lineBreakWithQuantifier\");\n@@ -5155,1 +4401,2 @@\n-    private static void caseInsensitivePMatch() {\n+    @Test\n+    public static void caseInsensitivePMatch() {\n@@ -5176,1 +4423,1 @@\n-                if (!Pattern.compile(pattern, Pattern.CASE_INSENSITIVE)\n+                assertTrue(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE)\n@@ -5178,6 +4425,2 @@\n-                            .matches())\n-                {\n-                    failCount++;\n-                    System.err.println(\"Expected to match: \" +\n-                                       \"'\" + input + \"' =~ \/\" + pattern + \"\/\");\n-                }\n+                            .matches(),\"Expected to match: \" + \"'\" + input +\n+                        \"' =~ \/\" + pattern + \"\/\");\n@@ -5208,1 +4451,1 @@\n-                if (!Pattern.compile(pattern, Pattern.CASE_INSENSITIVE\n+                assertTrue(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE\n@@ -5211,6 +4454,2 @@\n-                            .matches())\n-                {\n-                    failCount++;\n-                    System.err.println(\"Expected to match: \" +\n-                                       \"'\" + input + \"' =~ \/\" + pattern + \"\/\");\n-                }\n+                            .matches(), \"Expected to match: \" +\n+                        \"'\" + input + \"' =~ \/\" + pattern + \"\/\");\n@@ -5219,1 +4458,0 @@\n-        report(\"caseInsensitivePMatch\");\n@@ -5223,1 +4461,2 @@\n-    private static void surrogatePairOverlapRegion() {\n+    @Test\n+    public static void surrogatePairOverlapRegion() {\n@@ -5233,3 +4472,2 @@\n-            failCount++;\n-            System.out.println(\"Input \\\"\" + input + \"\\\".substr(0, 1)\" +\n-                    \" expected to match pattern \\\"\" + p + \"\\\"\");\n+            String errMessage = \"Input \\\"\" + input + \"\\\".substr(0, 1)\" +\n+                    \" expected to match pattern \\\"\" + p + \"\\\"\";\n@@ -5237,1 +4475,4 @@\n-                System.out.println(\"group(0): \\\"\" + m.group(0) + \"\\\"\");\n+                fail(errMessage + System.lineSeparator() +\n+                        \"group(0): \\\"\" + m.group(0) + \"\\\"\");\n+            } else {\n+                fail(errMessage);\n@@ -5240,2 +4481,1 @@\n-            failCount++;\n-            System.out.println(\"Expected m.hitEnd() == true\");\n+            fail(\"Expected m.hitEnd() == true\");\n@@ -5252,3 +4492,2 @@\n-            failCount++;\n-            System.out.println(\"Input \\\"\" + input + \"\\\".substr(1, 2)\" +\n-                    \" expected to match pattern \\\"\" + p + \"\\\"\");\n+            String errMessage = \"Input \\\"\" + input + \"\\\".substr(1, 2)\" +\n+                    \" expected to match pattern \\\"\" + p + \"\\\"\";\n@@ -5256,2 +4495,6 @@\n-                System.out.println(\"group(0): \\\"\" + m.group(0) + \"\\\"\");\n-                System.out.println(\"group(1): \\\"\" + m.group(1) + \"\\\"\");\n+                String msg1 = \"group(0): \\\"\" + m.group(0) + \"\\\"\";\n+                String msg2 = \"group(1): \\\"\" + m.group(1) + \"\\\"\";\n+                fail(errMessage + System.lineSeparator() + msg1 +\n+                        System.lineSeparator() + msg2);\n+            } else {\n+                fail(errMessage);\n@@ -5260,1 +4503,0 @@\n-        report(\"surrogatePairOverlapRegion\");\n@@ -5264,1 +4506,2 @@\n-    private static void droppedClassesWithIntersection() {\n+    @Test\n+    public static void droppedClassesWithIntersection() {\n@@ -5282,4 +4525,2 @@\n-        if (!letterCharsMatch) {\n-            failCount++;\n-            System.out.println(\"Compiling intersection pattern is dropping a character class in its matcher\");\n-        }\n+        assertTrue(letterCharsMatch, \"Compiling intersection pattern is \" +\n+                \"dropping a character class in its matcher\");\n@@ -5287,4 +4528,3 @@\n-        if (!digitCharsDontMatch) {\n-            failCount++;\n-            System.out.println(\"Compiling intersection pattern is matching digits where it should not\");\n-        }\n+        assertTrue(digitCharsDontMatch, \"Compiling intersection pattern is \" +\n+                \"matching digits where it should not\");\n+    }\n@@ -5292,0 +4532,8 @@\n+    \/\/This test is for 8269753\n+    @Test\n+    public static void errorMessageCaretIndentation() {\n+        String pattern = \"\\t**\";\n+        var e = expectThrows(PatternSyntaxException.class, () ->\n+                Pattern.compile(pattern));\n+        var sep = System.lineSeparator();\n+        assertTrue(e.getMessage().contains(sep + \"\\t ^\"));\n","filename":"test\/jdk\/java\/util\/regex\/RegExTest.java","additions":1248,"deletions":2000,"binary":false,"changes":3248,"status":"modified"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193682 8278794\n+ * @summary Test Infinite loop while writing on closed Deflater and Inflater.\n+ * @run testng CloseInflaterDeflaterTest\n+ *\/\n+import java.io.*;\n+import java.util.Random;\n+import java.util.jar.JarOutputStream;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.GZIPOutputStream;\n+import java.util.zip.InflaterOutputStream;\n+import java.util.zip.ZipOutputStream;\n+import java.util.zip.ZipEntry;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertThrows;\n+\n+\n+public class CloseInflaterDeflaterTest {\n+\n+    \/\/ Number of bytes to write\/read from Deflater\/Inflater\n+    private static final int INPUT_LENGTH= 512;\n+    \/\/ OutputStream that will throw an exception during a write operation\n+    private static OutputStream outStream = new OutputStream() {\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            throw new IOException();\n+        }\n+        @Override\n+        public void write(byte[] b) throws IOException {}\n+        @Override\n+        public void write(int b) throws IOException {}\n+    };\n+    \/\/ InputStream that will throw an exception during a read operation\n+    private static InputStream inStream = new InputStream() {\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            throw new IOException();\n+        }\n+        @Override\n+        public int read(byte[] b) throws IOException { throw new IOException();}\n+        @Override\n+        public int read() throws IOException { throw new IOException();}\n+    };\n+    \/\/ Input bytes for read\/write operation\n+    private static byte[] inputBytes = new byte[INPUT_LENGTH];\n+    \/\/ Random function to add bytes to inputBytes\n+    private static Random rand = new Random();\n+\n+    \/**\n+     * DataProvider to specify whether to use close() or finish() of OutputStream\n+     *\n+     * @return Entry object indicating which method to use for closing OutputStream\n+     *\/\n+    @DataProvider\n+    public Object[][] testOutputStreams() {\n+     return new Object[][] {\n+      { true },\n+      { false },\n+     };\n+    }\n+\n+    \/**\n+     * DataProvider to specify on which outputstream closeEntry() has to be called\n+     *\n+     * @return Entry object returning either JarOutputStream or ZipOutputStream\n+     *\/\n+    @DataProvider\n+    public Object[][] testZipAndJar() throws IOException{\n+     return new Object[][] {\n+      { new JarOutputStream(outStream)},\n+      { new ZipOutputStream(outStream)},\n+     };\n+    }\n+\n+    \/**\n+     * Add inputBytes array with random bytes to write into OutputStream\n+     *\/\n+    @BeforeTest\n+    public void before_test()\n+    {\n+       rand.nextBytes(inputBytes);\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed GZIPOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testGZip(boolean useCloseMethod) throws IOException {\n+        GZIPOutputStream gzip = new GZIPOutputStream(outStream);\n+        gzip.write(inputBytes, 0, INPUT_LENGTH);\n+        assertThrows(IOException.class, () -> {\n+            \/\/ Close GZIPOutputStream\n+            if (useCloseMethod) {\n+                gzip.close();\n+            } else {\n+                gzip.finish();\n+            }\n+        });\n+        \/\/ Write on a closed GZIPOutputStream, closed Deflater IOException expected\n+        assertThrows(NullPointerException.class , () -> gzip.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed DeflaterOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testDeflaterOutputStream(boolean useCloseMethod) throws IOException {\n+        DeflaterOutputStream def = new DeflaterOutputStream(outStream);\n+        assertThrows(IOException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+        assertThrows(IOException.class, () -> {\n+            \/\/ Close DeflaterOutputStream\n+            if (useCloseMethod) {\n+                def.close();\n+            } else {\n+                def.finish();\n+            }\n+        });\n+        \/\/ Write on a closed DeflaterOutputStream, 'Deflater has been closed' NPE is expected\n+        assertThrows(NullPointerException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by reading bytes from closed DeflaterInputStream\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void testDeflaterInputStream() throws IOException {\n+        DeflaterInputStream def = new DeflaterInputStream(inStream);\n+        assertThrows(IOException.class , () -> def.read(inputBytes, 0, INPUT_LENGTH));\n+        \/\/ Close DeflaterInputStream\n+        def.close();\n+        \/\/ Read from a closed DeflaterInputStream, closed Deflater IOException expected\n+        assertThrows(IOException.class , () -> def.read(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed InflaterOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testInflaterOutputStream(boolean useCloseMethod) throws IOException {\n+        InflaterOutputStream inf = new InflaterOutputStream(outStream);\n+        assertThrows(IOException.class , () -> inf.write(inputBytes, 0, INPUT_LENGTH));\n+        assertThrows(IOException.class , () -> {\n+            \/\/ Close InflaterOutputStream\n+            if (useCloseMethod) {\n+                inf.close();\n+            } else {\n+                inf.finish();\n+            }\n+        });\n+        \/\/ Write on a closed InflaterOutputStream , closed Inflater IOException expected\n+        assertThrows(IOException.class , () -> inf.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed ZipOutputStream\/JarOutputStream\n+     *\n+     * @param zip will be the instance of either JarOutputStream or ZipOutputStream\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testZipAndJar\")\n+    public void testZipCloseEntry(ZipOutputStream zip) throws IOException {\n+        assertThrows(IOException.class , () -> zip.putNextEntry(new ZipEntry(\"\")));\n+        zip.write(inputBytes, 0, INPUT_LENGTH);\n+        assertThrows(IOException.class , () -> zip.closeEntry());\n+        \/\/ Write on a closed ZipOutputStream , 'Deflater has been closed' NPE is expected\n+        assertThrows(NullPointerException.class , () -> zip.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/zip\/CloseInflaterDeflaterTest.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.function.Consumer;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * @test\n+ * @bug 8277087\n+ * @summary Verifies various use cases when the zip comment should be empty\n+ * @run testng EmptyComment\n+ *\/\n+public final class EmptyComment {\n+\n+    @DataProvider()\n+    Object[][] longLengths() {\n+        return new Object[][]{{0xFFFF + 1}, {0xFFFF + 2}, {0xFFFF * 2}};\n+    }\n+\n+    \/**\n+     * Overflow, the text is too long to be stored as a comment.\n+     *\/\n+    @Test(dataProvider = \"longLengths\")\n+    void testOverflow(int length) throws Exception {\n+        test(zos -> assertThrows(IllegalArgumentException.class, () -> {\n+            zos.setComment(\"X\".repeat(length));\n+        }));\n+    }\n+\n+    \/**\n+     * Simple cases where the comment is set to the empty text.\n+     *\/\n+    @Test\n+    void testSimpleCases() throws Exception {\n+        test(zos -> {\/* do nothing *\/});\n+        test(zos -> zos.setComment(null));\n+        test(zos -> zos.setComment(\"\"));\n+        test(zos -> {\n+            zos.setComment(\"\");\n+            zos.setComment(null);\n+        });\n+        test(zos -> {\n+            zos.setComment(null);\n+            zos.setComment(\"\");\n+        });\n+        test(zos -> {\n+            zos.setComment(\"Comment\");\n+            zos.setComment(null);\n+        });\n+        test(zos -> {\n+            zos.setComment(\"Comment\");\n+            zos.setComment(\"\");\n+        });\n+    }\n+\n+    private static void test(Consumer<ZipOutputStream> test) throws Exception {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(baos)) {\n+\n+            test.accept(zos);\n+\n+            zos.putNextEntry(new ZipEntry(\"x\"));\n+            zos.finish();\n+\n+            byte[] data = baos.toByteArray();\n+\n+            if (data.length > 0xFFFF) { \/\/ just in case\n+                throw new RuntimeException(\"data is too big: \" + data.length);\n+            }\n+            int pk = data.length - ZipFile.ENDHDR;\n+            if (data[pk] != 'P' || data[pk + 1] != 'K') {\n+                throw new RuntimeException(\"PK is not found\");\n+            }\n+            \/\/ Since the comment is empty this will be two last bytes\n+            int pos = data.length - ZipFile.ENDHDR + ZipFile.ENDCOM;\n+\n+            int len = (data[pos] & 0xFF) + ((data[pos + 1] & 0xFF) << 8);\n+            if (len != 0) {\n+                throw new RuntimeException(\"zip comment is not empty: \" + len);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/EmptyComment.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8277922\n+   @key headful\n+   @summary TableCellRenderer of JTable cell with Boolean data should not\n+            support any AccessibleAction.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Robot;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleAction;\n+import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleTable;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.table.DefaultTableModel;\n+import javax.swing.table.TableCellRenderer;\n+\n+public class BooleanRendererHasAccessibleActionTest {\n+    private volatile JFrame frame;\n+    private volatile JTable table;\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException, AWTException {\n+        final BooleanRendererHasAccessibleActionTest test =\n+            new BooleanRendererHasAccessibleActionTest();\n+\n+        try {\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    test.createGUI();\n+                }\n+            });\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    test.runTest();\n+                }\n+            });\n+        } finally {\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    test.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private void createGUI() {\n+        frame = new JFrame(\"BooleanRendererHasAccessibleActionTest\");\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        Container content = frame.getContentPane();\n+        content.setLayout(new BorderLayout());\n+\n+        String[] tblColNames = {\"Column 1\", \"Column 2\", \"Column 3\"};\n+        Object[][] tblData = {\n+            {Boolean.TRUE, \"Text 1\", Boolean.FALSE},\n+            {Boolean.FALSE, \"Text 2\", Boolean.TRUE}\n+        };\n+        final DefaultTableModel tblModel = new DefaultTableModel(\n+                tblData, tblColNames) {\n+            @Override\n+            public Class<?> getColumnClass(int column) {\n+                return getValueAt(0, column).getClass();\n+            }\n+        };\n+        table = new JTable(tblModel);\n+        table.setPreferredScrollableViewportSize(new Dimension(400, 100));\n+\n+        JScrollPane tblScroller = new JScrollPane(table);\n+        tblScroller.setHorizontalScrollBarPolicy(\n+            JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n+        tblScroller.setVerticalScrollBarPolicy(\n+            JScrollPane.VERTICAL_SCROLLBAR_ALWAYS\n+        );\n+        content.add(tblScroller, BorderLayout.CENTER);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    private void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+    private void runTest() {\n+        if (table == null) {\n+            throw new RuntimeException(\"'table' should not be null\");\n+        }\n+\n+        testAccessibleActionInCellRenderer(0, 0, true);\n+        testAccessibleActionInCellRenderer(1, 0, true);\n+        testAccessibleActionInCellRenderer(0, 2, true);\n+        testAccessibleActionInCellRenderer(1, 2, true);\n+\n+        testAccessibleActionInCell(0, 0, true);\n+        testAccessibleActionInCell(1, 0, true);\n+        testAccessibleActionInCell(0, 2, true);\n+        testAccessibleActionInCell(1, 2, true);\n+\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    private void testAccessibleActionInCellRenderer(int row, int column,\n+            boolean shouldBeNull) {\n+        System.out.println(String.format(\n+                \"testAccessibleActionInCellRenderer():\" +\n+                    \" row='%d', column='%d', shouldBeNull='%b'\",\n+                row, column, shouldBeNull));\n+\n+        TableCellRenderer cellRenderer = table.getCellRenderer(row, column);\n+        if (!(cellRenderer instanceof Accessible)) {\n+            throw new RuntimeException(\"'cellRenderer' is not Accessible\");\n+        }\n+\n+        AccessibleContext cellRendererAc =\n+            ((Accessible) cellRenderer).getAccessibleContext();\n+        if (cellRendererAc == null) {\n+            throw new RuntimeException(\"'cellRendererAc' should not be null\");\n+        }\n+\n+        AccessibleAction cellRendererAa = cellRendererAc.getAccessibleAction();\n+        if ((shouldBeNull && (cellRendererAa != null)) ||\n+            (!shouldBeNull && (cellRendererAa == null))) {\n+            throw new RuntimeException(\n+                \"Test failed. 'cellRendererAa' is not as should be\");\n+        }\n+    }\n+\n+    private void testAccessibleActionInCell(int row, int column,\n+            boolean shouldBeNull) {\n+        System.out.println(String.format(\"testAccessibleActionInCell():\" +\n+                    \" row='%d', column='%d', shouldBeNull='%b'\",\n+                row, column, shouldBeNull));\n+\n+        AccessibleContext tblAc = table.getAccessibleContext();\n+        AccessibleTable accessibleTbl = tblAc.getAccessibleTable();\n+        if (accessibleTbl == null) {\n+            throw new RuntimeException(\"'accessibleTbl' should not be null\");\n+        }\n+\n+        Accessible cellAccessible = accessibleTbl.getAccessibleAt(row, column);\n+        AccessibleContext cellAc = cellAccessible.getAccessibleContext();\n+        if (cellAc == null) {\n+            throw new RuntimeException(\"'cellAc' should not be null\");\n+        }\n+\n+        AccessibleAction cellAa = cellAc.getAccessibleAction();\n+        if ((shouldBeNull && (cellAa != null)) ||\n+            (!shouldBeNull && (cellAa == null))) {\n+            throw new RuntimeException(\n+                \"Test failed. 'cellAa' is not as should be\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/accessibility\/JTable\/BooleanRendererHasAccessibleActionTest.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.util.Arrays;\n@@ -26,0 +27,1 @@\n+import java.util.List;\n@@ -40,4 +42,4 @@\n-    public final String supportedProtocols;\n-    public final String enabledProtocols;\n-    public final String supportedCipherSuites;\n-    public final String enabledCipherSuites;\n+    public final List<String> supportedProtocols;\n+    public final List<String> enabledProtocols;\n+    public final List<String> supportedCipherSuites;\n+    public final List<String> enabledCipherSuites;\n@@ -57,7 +59,20 @@\n-        version = attributes[0].replaceAll(\".*=\", \"\");\n-        supportedProtocols = attributes[1].replaceAll(\".*=\", \"\");\n-        enabledProtocols = attributes[2].replaceAll(\".*=\", \"\");\n-        supportedCipherSuites = attributes[3].replaceAll(\".*=\", \"\");\n-        enabledCipherSuites = attributes[4].replaceAll(\".*=\", \"\");\n-        supportsSNI = Boolean.valueOf(attributes[5].replaceAll(\".*=\", \"\"));\n-        supportsALPN = Boolean.valueOf(attributes[6].replaceAll(\".*=\", \"\"));\n+        version = parseAttribute(attributes[0]);\n+        supportedProtocols = parseListAttribute(attributes[1]);\n+        enabledProtocols = parseListAttribute(attributes[2]);\n+        supportedCipherSuites = parseListAttribute(attributes[3]);\n+        enabledCipherSuites = parseListAttribute(attributes[4]);\n+        supportsSNI = parseBooleanAttribute(attributes[5]);\n+        supportsALPN = parseBooleanAttribute(attributes[6]);\n+    }\n+\n+    private List<String> parseListAttribute(String attribute) {\n+        attribute = parseAttribute(attribute);\n+        return Arrays.asList(attribute.split(\",\"));\n+    }\n+\n+    private boolean parseBooleanAttribute(String attribute) {\n+        attribute = parseAttribute(attribute);\n+        return Boolean.parseBoolean(attribute);\n+    }\n+    private String parseAttribute(String attribute) {\n+        return attribute.replaceAll(\".*=\", \"\");\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/JdkInfo.java","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @bug 8216358\n+ * @bug 8216358 8279586\n@@ -54,0 +54,3 @@\n+        BufferedImage imageFocusNotPainted = new BufferedImage(100, 50,\n+                BufferedImage.TYPE_INT_ARGB);\n+\n@@ -56,0 +59,1 @@\n+        checkbox.setFocusPainted(true);\n@@ -67,0 +71,11 @@\n+\n+        checkbox.setFocusPainted(false);\n+        checkbox.paint(imageFocusNotPainted.createGraphics());\n+\n+        if (!Util.compareBufferedImages(imageFocusNotPainted, imageNoFocus)) {\n+            ImageIO.write(imageFocusNotPainted, \"png\",\n+                    new File(\"imageFocusNotPainted.png\"));\n+            ImageIO.write(imageFocus, \"png\", new File(\"imageFocus.png\"));\n+            ImageIO.write(imageNoFocus, \"png\", new File(\"imageNoFocus.png\"));\n+            throw new Exception(\"setFocusPainted(false) is ignored\");\n+        }\n","filename":"test\/jdk\/javax\/swing\/JCheckBox\/ImageCheckboxFocus\/ImageCheckboxTest.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.XMLUtils;\n+\n+import javax.xml.crypto.URIReferenceException;\n+import javax.xml.crypto.dsig.XMLSignatureException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+\n+\/**\n+ * @test\n+ * @bug 8278186\n+ * @summary reject malformed xpointer(id('a')) gracefully\n+ * @library \/test\/lib\n+ * @modules java.xml.crypto\n+ *\/\n+public class BadXPointer {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\");\n+        kpg.initialize(new ECGenParameterSpec(\"secp256r1\"));\n+        KeyPair kp = kpg.generateKeyPair();\n+\n+        var signer = XMLUtils.signer(kp.getPrivate(), kp.getPublic());\n+        var doc = XMLUtils.string2doc(\"<root\/>\");\n+\n+        \/\/ No enclosing ' for id\n+        Utils.runAndCheckException(\n+                () -> signer.signEnveloping(doc, \"a\", \"#xpointer(id('a))\"),\n+                ex -> Asserts.assertTrue(ex instanceof XMLSignatureException\n+                        && ex.getCause() instanceof URIReferenceException\n+                        && ex.getMessage().contains(\"Could not find a resolver\"),\n+                    ex.toString()));\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/BadXPointer.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3267,1 +3267,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3269,1 +3269,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3273,1 +3273,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3267,1 +3267,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3269,1 +3269,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3273,1 +3273,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3267,1 +3267,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3269,1 +3269,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3273,1 +3273,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3267,1 +3267,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3269,1 +3269,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3273,1 +3273,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3272,1 +3272,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3274,1 +3274,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3278,1 +3278,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2452,1 +2452,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2454,1 +2454,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2458,1 +2458,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2452,1 +2452,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2454,1 +2454,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2458,1 +2458,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2452,1 +2452,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2454,1 +2454,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2458,1 +2458,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2452,1 +2452,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2454,1 +2454,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2458,1 +2458,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2457,1 +2457,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2459,1 +2459,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2463,1 +2463,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2462,1 +2462,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2464,1 +2464,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2468,1 +2468,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2462,1 +2462,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2464,1 +2464,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2468,1 +2468,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2462,1 +2462,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2464,1 +2464,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2468,1 +2468,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2462,1 +2462,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2464,1 +2464,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2468,1 +2468,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2467,1 +2467,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2469,1 +2469,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2473,1 +2473,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3232,1 +3232,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3234,1 +3234,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3238,1 +3238,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3232,1 +3232,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3234,1 +3234,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3238,1 +3238,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3232,1 +3232,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3234,1 +3234,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3238,1 +3238,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3232,1 +3232,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3234,1 +3234,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3238,1 +3238,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3237,1 +3237,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3239,1 +3239,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3243,1 +3243,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -189,1 +189,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3254,1 +3254,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3256,1 +3256,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3260,1 +3260,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -189,1 +189,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3254,1 +3254,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3256,1 +3256,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3260,1 +3260,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -189,1 +189,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3254,1 +3254,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3256,1 +3256,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3260,1 +3260,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -189,1 +189,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3254,1 +3254,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3256,1 +3256,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3260,1 +3260,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -191,2 +191,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -194,1 +194,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3259,1 +3259,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3261,1 +3261,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3265,1 +3265,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3257,1 +3257,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3259,1 +3259,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3263,1 +3263,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3257,1 +3257,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3259,1 +3259,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3263,1 +3263,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3257,1 +3257,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3259,1 +3259,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3263,1 +3263,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3257,1 +3257,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3259,1 +3259,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3263,1 +3263,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3262,1 +3262,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3264,1 +3264,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3268,1 +3268,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -43,0 +43,12 @@\n+\/*\n+ * @test\n+ * @bug 8281544\n+ * @summary Test that ZGC and vectorapi with KNL work together.\n+ * @requires vm.gc.Z\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm  -XX:-TieredCompilation --add-opens jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+UseKNLSetting -XX:+UseZGC -XX:+IgnoreUnrecognizedVMOptions\n+ *                      VectorMaxConversionTests\n+ *\/\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorMaxConversionTests.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-#!\/bin\/bash\n-#\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-. config.sh\n-\n-Log false \"Building Vector API tests, $(date)\\n\"\n-\n-# For each type\n-for type in byte short int long float double\n-do\n-  Type=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}\"\n-\n-  # For each size\n-  for bits in 64 128 256 512\n-  do\n-    vectorteststype=${typeprefix}${Type}${bits}VectorTests\n-    # Compile\n-    Log true \"Compiling ${vectorteststype}... \"\n-    Log false \"\\n${JAVAC} -cp \\\"${VECTORTESTS_HOME_CP}$SEPARATOR${TESTNG_JAR}\\\" --add-modules=jdk.incubator.vector $vectorteststype.java 2>&1\"\n-    compilation=$(${JAVAC} -cp \"${VECTORTESTS_HOME_CP}$SEPARATOR${TESTNG_JAR}\" \\\n-                    --add-modules=jdk.incubator.vector $vectorteststype.java 2>&1)\n-    if [[ $compilation  == *\"error\"* ]]; then\n-      Log true \"$compilation\\n\"\n-      exit -1\n-    else\n-      Log false \"$compilation\\n\"\n-    fi\n-    Log true \"done\\n\"\n-  done\n-done\n-\n-rm -fr build\n-\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/build-tests.sh","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-rm -rf *.class build.log test-output\n+rm -rf build.log\n","filename":"test\/jdk\/jdk\/incubator\/vector\/clean.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,0 @@\n-TESTNG_JAR=\"${TESTNG_PLUGIN}\/plugins\/org.testng.source_6.13.1.r201712040515.jar\"\n-TESTNG_RUN_JAR=\"${TESTNG_PLUGIN}\/plugins\/org.testng_6.13.1.r201712040515.jar\"\n-JCOMMANDER_JAR=\"${TESTNG_PLUGIN}\/plugins\/com.beust.jcommander_1.72.0.jar\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/config.sh","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,7 +31,0 @@\n-list_mech_gen() {\n-    ( # List MG files physically present\n-      grep -il 'mechanically generated.*do not edit' $(find * -name \\*.java -print)\n-      # List MG files currently deleted (via --clean)\n-      hg status -nd .\n-    ) | egrep '(^|\/)(Byte|Short|Int|Long|Float|Double)(Scalar|([0-9Max]+Vector)).*\\.java$'\n-}\n@@ -41,4 +34,1 @@\n---clean)        MG=$(list_mech_gen); set -x; rm -f $MG; exit;;\n---revert)       MG=$(list_mech_gen); set -x; hg revert $MG; exit;;\n---list)         list_mech_gen; exit;;\n---help|*)       echo \"Usage: $0 [--generate [file] | --clean | --revert | --list]\"; exit 1;;\n+--help|*)       echo \"Usage: $0 [--generate [file]]\"; exit 1;;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,86 +0,0 @@\n-#!\/bin\/bash\n-#\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-. config.sh\n-\n-POSITIONAL=()\n-while [[ $# -gt 0 ]]\n-do\n-key=\"$1\"\n-\n-TESTS=\"\"\n-DISABLE_VECTOR_INTRINSICS=false\n-case $key in\n-    -t|--tests)\n-    TESTS=\"$2\"\n-    echo \"Tests set to $TESTS\"\n-    shift # past argument\n-    shift # past value\n-    ;;\n-    -d|--disable-vector-intrinsics)\n-    DISABLE_VECTOR_INTRINSICS=true\n-    echo \"Warning: Disabling Vector intrinsics...\"\n-    shift # past argument\n-    ;;\n-    *)    # unknown option\n-    POSITIONAL+=(\"$1\") # save it in an array for later\n-    shift # past argument\n-    ;;\n-esac\n-done\n-set -- \"${POSITIONAL[@]}\" # restore positional parameters\n-\n-\n-if [ \"$TESTS\" == \"\" ]; then\n-  # Run all the tests by default.\n-  TESTS=\"Byte64VectorTests,Byte128VectorTests,Byte256VectorTests,Byte512VectorTests,\"\n-  TESTS+=\"Int64VectorTests,Int128VectorTests,Int256VectorTests,Int512VectorTests,\"\n-  TESTS+=\"Long64VectorTests,Long128VectorTests,Long256VectorTests,Long512VectorTests,\"\n-  TESTS+=\"Short64VectorTests,Short128VectorTests,Short256VectorTests,Short512VectorTests,\"\n-  TESTS+=\"Double64VectorTests,Double128VectorTests,Double256VectorTests,Double512VectorTests,\"\n-  TESTS+=\"Float64VectorTests,Float128VectorTests,Float256VectorTests,Float512VectorTests\"\n-fi\n-\n-# Get Java flags.\n-JAVA_FLAGS=\"-XX:-TieredCompilation\"\n-if [ \"$DISABLE_VECTOR_INTRINSICS\" == \"true\" ]; then\n-\tJAVA_FLAGS+=\" -XX:-UseVectorApiIntrinsics\"\n-fi\n-\n-LogRun false \"Running tests $(date)\\n\"\n-LogRun true \"Running the following tests:\\n\"\n-LogRun true \"${TESTS}\\n\"\n-LogRun false \"${JAVA} -cp \\\"${VECTORTESTS_HOME_CP}${SEPARATOR}${TESTNG_RUN_JAR}${SEPARATOR}${JCOMMANDER_JAR}\\\" ${JAVA_FLAGS} --add-modules jdk.incubator.vector --add-opens jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED org.testng.TestNG -testclass $TESTS\"\n-\n-# Actual TestNG run.\n-time ${JAVA} -cp \"${VECTORTESTS_HOME_CP}${SEPARATOR}${TESTNG_RUN_JAR}${SEPARATOR}${JCOMMANDER_JAR}\" \\\n-  ${JAVA_FLAGS} \\\n-  --add-modules jdk.incubator.vector \\\n-  --add-opens jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED \\\n-  -Djdk.incubator.vector.test.loop-iterations=${TEST_ITER_COUNT} \\\n-  org.testng.TestNG -testclass $TESTS\n-LogRun true \"Tests run complete. Please look at test-output\/index.html to visualize the results.\\n\"\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/run-tests.sh","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -5,1 +5,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -7,1 +7,1 @@\n-                av.withLane(0, ($type$)4).intoArray(r, i);\n+                av.withLane((j++ \\& (SPECIES.length()-1)), ($type$)(65535+i)).intoArray(r, i);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-With-Op.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,1 +5,4 @@\n-        assertInsertArraysEquals(r, a, ($type$)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, ($type$)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-With-Op.template","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -260,2 +260,2 @@\n-    static void assertInsertArraysEquals($type$[] r, $type$[] a, $type$ element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals($type$[] r, $type$[] a, $type$ element, int index, int start, int end) {\n+        int i = start;\n@@ -263,1 +263,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2020 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2020, 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -27,0 +27,2 @@\n+\/\/ Usage:\n+\/\/   GetFreeSwapSpaceSize <memoryAlloc> <expectedMemory> <memorySwapAlloc> <expectedSwap>\n@@ -29,1 +31,11 @@\n-        System.out.println(\"TestGetFreeSwapSpaceSize\");\n+        if (args.length != 4) {\n+            throw new RuntimeException(\"Unexpected arguments. Expected 4, got \" + args.length);\n+        }\n+        String memoryAlloc = args[0];\n+        long expectedMemory = Long.parseLong(args[1]);\n+        String memorySwapAlloc = args[2];\n+        long expectedSwap = Long.parseLong(args[3]);\n+        System.out.println(\"TestGetFreeSwapSpaceSize (memory=\" + memoryAlloc + \", memorySwap=\" + memorySwapAlloc + \")\");\n+        if (expectedSwap != 0) {\n+            throw new RuntimeException(\"Precondition of test not met: Expected swap size of 0, got: \" + expectedSwap);\n+        }\n@@ -31,0 +43,8 @@\n+        long osBeanTotalSwap = osBean.getTotalSwapSpaceSize();\n+        \/\/ Premise of this test is to test on a system where --memory and --memory-swap are set to\n+        \/\/ the same amount via the container engine (i.e. no swap). In that case the OSBean must\n+        \/\/ not report negative values for free swap space. Assert this precondition.\n+        if (osBeanTotalSwap != expectedSwap) {\n+            throw new RuntimeException(\"OperatingSystemMXBean.getTotalSwapSpaceSize() reported \" + osBeanTotalSwap + \" expected \" + expectedSwap);\n+        }\n+        System.out.println(\"TestGetFreeSwapSpaceSize precondition met, osBeanTotalSwap = \" + expectedSwap + \". Running test... \");\n@@ -34,2 +54,1 @@\n-                System.out.println(\"Error: getFreeSwapSpaceSize returns \" + size);\n-                System.exit(-1);\n+                throw new RuntimeException(\"Test failed! getFreeSwapSpaceSize returns \" + size);\n@@ -38,0 +57,1 @@\n+        System.out.println(\"TestGetFreeSwapSpaceSize PASSED.\" );\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/GetFreeSwapSpaceSize.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2020 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2020, 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -39,1 +39,1 @@\n-    private static final String imageName = Common.imageName(\"memory\");\n+    private static final String imageName = Common.imageName(\"osbeanSwapSpace\");\n@@ -61,1 +61,1 @@\n-            String swapAllocation, String expectedSwap) throws Exception {\n+            String memorySwapAllocation, String expectedSwap) throws Exception {\n@@ -65,0 +65,1 @@\n+            .addClassOptions(memoryAllocation, expectedMemory, memorySwapAllocation, expectedSwap)\n@@ -67,1 +68,1 @@\n-                \"--memory-swap\", swapAllocation\n+                \"--memory-swap\", memorySwapAllocation\n@@ -72,1 +73,1 @@\n-           .shouldContain(\"TestGetFreeSwapSpaceSize\");\n+           .shouldContain(\"TestGetFreeSwapSpaceSize PASSED.\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestGetFreeSwapSpaceSize.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jdk.test.lib.Platform;\n+import sun.hotspot.WhiteBox;\n@@ -40,2 +42,10 @@\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 jdk.jfr.event.allocation.TestObjectAllocationInNewTLABEvent\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 -Xint jdk.jfr.event.allocation.TestObjectAllocationInNewTLABEvent\n+ * @build sun.hotspot.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1\n+ *                   jdk.jfr.event.allocation.TestObjectAllocationInNewTLABEvent\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1\n+ *                   -Xint\n+ *                   jdk.jfr.event.allocation.TestObjectAllocationInNewTLABEvent\n@@ -49,2 +59,2 @@\n- *      the size of TLAB is set to 100k (-XX:TLABSize=100k);\n- *      the size of allocated objects is set to 100k minus 16 bytes overhead;\n+ *      the initial size of TLAB is set to 100k (-XX:TLABSize=100k);\n+ *      the size of allocated objects is set to 128k;\n@@ -57,3 +67,5 @@\n-    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array.\n-    private static final int OBJECT_SIZE  = 100 * 1024;\n-    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops.\n+    private static final Boolean COMPRESSED_CLASS_PTRS = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompressedClassPointers\");\n+\n+    private static final int BYTE_ARRAY_OVERHEAD = (Platform.is64bit() && !COMPRESSED_CLASS_PTRS) ? 24 : 16;\n+    private static final int OBJECT_SIZE = 128 * 1024;\n+\n@@ -115,1 +127,1 @@\n-        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT)) {\n+        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE)) {\n@@ -117,1 +129,1 @@\n-            if (tlabSize == INITIAL_TLAB_SIZE + OBJECT_SIZE || tlabSize == INITIAL_TLAB_SIZE + OBJECT_SIZE_ALT) {\n+            if (tlabSize == INITIAL_TLAB_SIZE + OBJECT_SIZE) {\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationInNewTLABEvent.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jdk.test.lib.Platform;\n+import sun.hotspot.WhiteBox;\n@@ -40,2 +42,10 @@\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 jdk.jfr.event.allocation.TestObjectAllocationOutsideTLABEvent\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 -Xint jdk.jfr.event.allocation.TestObjectAllocationOutsideTLABEvent\n+ * @build sun.hotspot.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256\n+ *                   jdk.jfr.event.allocation.TestObjectAllocationOutsideTLABEvent\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256\n+ *                   -Xint\n+ *                   jdk.jfr.event.allocation.TestObjectAllocationOutsideTLABEvent\n@@ -49,2 +59,2 @@\n- *      the size of TLAB is set to 90k (-XX:TLABSize=90k);\n- *      the size of allocated objects is set to 100k.\n+ *      the initial size of TLAB is set to 90k (-XX:TLABSize=90k);\n+ *      the size of allocated objects is set to 128k;\n@@ -57,3 +67,5 @@\n-    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n-    private static final int OBJECT_SIZE = 100 * 1024;\n-    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n+    private static final Boolean COMPRESSED_CLASS_PTRS = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompressedClassPointers\");\n+\n+    private static final int BYTE_ARRAY_OVERHEAD = (Platform.is64bit() && !COMPRESSED_CLASS_PTRS) ? 24 : 16;\n+    private static final int OBJECT_SIZE = 128 * 1024;\n+\n@@ -97,1 +109,1 @@\n-        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT)) {\n+        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE)) {\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationOutsideTLABEvent.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.test.lib.Platform;\n+import sun.hotspot.WhiteBox;\n@@ -42,1 +44,6 @@\n-*  @run main\/othervm -XX:+UseTLAB -XX:TLABSize=2k -XX:-ResizeTLAB jdk.jfr.event.allocation.TestObjectAllocationSampleEventThrottling\n+ * @build sun.hotspot.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -XX:+UseTLAB -XX:TLABSize=2k -XX:-ResizeTLAB\n+ *                   jdk.jfr.event.allocation.TestObjectAllocationSampleEventThrottling\n@@ -48,3 +55,5 @@\n-    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n-    private static final int OBJECT_SIZE = 100 * 1024;\n-    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n+    private static final Boolean COMPRESSED_CLASS_PTRS = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompressedClassPointers\");\n+\n+    private static final int BYTE_ARRAY_OVERHEAD = (Platform.is64bit() && !COMPRESSED_CLASS_PTRS) ? 24 : 16;\n+    private static final int OBJECT_SIZE = 128 * 1024;\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEventThrottling.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-import java.io.File;\n-import java.nio.file.Paths;\n+import java.lang.ref.Reference;\n@@ -30,0 +29,1 @@\n+import jdk.jfr.Recording;\n@@ -31,1 +31,0 @@\n-import jdk.jfr.consumer.RecordingFile;\n@@ -33,0 +32,1 @@\n+import jdk.test.lib.jfr.EventNames;\n@@ -35,0 +35,2 @@\n+import sun.hotspot.WhiteBox;\n+\n@@ -38,0 +40,1 @@\n+ * @bug 8263461\n@@ -42,0 +45,1 @@\n+ * @requires vm.debug\n@@ -43,1 +47,6 @@\n- * @run main jdk.jfr.event.gc.detailed.TestEvacuationFailedEvent\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *          -Xmx32m -Xms32m -XX:+UnlockExperimentalVMOptions -XX:+G1EvacuationFailureALot\n+ *          -XX:G1EvacuationFailureALotCount=100 -XX:G1EvacuationFailureALotInterval=1\n+ *          -Xlog:gc=debug -XX:+UseG1GC jdk.jfr.event.gc.detailed.TestEvacuationFailedEvent\n@@ -45,0 +54,1 @@\n+\n@@ -47,3 +57,1 @@\n-    private final static String EVENT_SETTINGS_FILE = System.getProperty(\"test.src\", \".\") + File.separator + \"evacuationfailed-testsettings.jfc\";\n-    private final static String JFR_FILE = \"TestEvacuationFailedEvent.jfr\";\n-    private final static int BYTES_TO_ALLOCATE = 1024 * 512;\n+    private final static String EVENT_NAME = EventNames.EvacuationFailed;\n@@ -52,3 +60,4 @@\n-        String[] vmFlags = {\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseFastUnorderedTimeStamps\",\n-            \"-Xmx64m\", \"-Xmn60m\", \"-XX:-UseDynamicNumberOfGCThreads\", \"-XX:ParallelGCThreads=3\",\n-            \"-XX:MaxTenuringThreshold=0\", \"-Xlog:gc*=debug\", \"-XX:+UseG1GC\"};\n+        Recording recording = new Recording();\n+        \/\/ activate the event we are interested in and start recording\n+        recording.enable(EVENT_NAME);\n+        recording.start();\n@@ -56,4 +65,4 @@\n-        if (!ExecuteOOMApp.execute(EVENT_SETTINGS_FILE, JFR_FILE, vmFlags, BYTES_TO_ALLOCATE)) {\n-            System.out.println(\"OOM happened in the other thread(not test thread). Skip test.\");\n-            \/\/ Skip test, process terminates due to the OOME error in the different thread\n-            return;\n+        Object[] data = new Object[1024];\n+\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = new byte[5 * 1024];\n@@ -61,0 +70,6 @@\n+        \/\/ Guarantee one young gc.\n+        WhiteBox.getWhiteBox().youngGC();\n+        \/\/ Keep alive data.\n+        Reference.reachabilityFence(data);\n+\n+        recording.stop();\n@@ -62,1 +77,2 @@\n-        List<RecordedEvent> events = RecordingFile.readAllEvents(Paths.get(JFR_FILE));\n+        \/\/ Verify recording\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n@@ -72,0 +88,1 @@\n+        recording.close();\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestEvacuationFailedEvent.java","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!--\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n--->\n-<configuration version=\"2.0\" label=\"TestSettings\" description=\"Configuration for testing promotion failed event\" provider=\"Oracle\">\n-\n-    <event name=\"jdk.EvacuationFailed\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-<\/configuration>\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/evacuationfailed-testsettings.jfc","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278851\n+ * @summary Check that jar entry with at least one non-disabled digest\n+ *          algorithm in manifest is treated as signed\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.JarUtils\n+ *        jdk.test.lib.security.SecurityUtils\n+ * @run main\/othervm JarWithOneNonDisabledDigestAlg\n+ *\/\n+\n+import java.io.InputStream;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.CodeSigner;\n+import java.security.KeyStore;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.zip.ZipFile;\n+import jdk.security.jarsigner.JarSigner;\n+\n+import jdk.test.lib.util.JarUtils;\n+import jdk.test.lib.security.SecurityUtils;\n+\n+public class JarWithOneNonDisabledDigestAlg {\n+\n+    private static final String PASS = \"changeit\";\n+    private static final String TESTFILE1 = \"testfile1\";\n+    private static final String TESTFILE2 = \"testfile2\";\n+\n+    public static void main(String[] args) throws Exception {\n+        SecurityUtils.removeFromDisabledAlgs(\"jdk.jar.disabledAlgorithms\",\n+            List.of(\"SHA1\"));\n+        Files.write(Path.of(TESTFILE1), TESTFILE1.getBytes());\n+        JarUtils.createJarFile(Path.of(\"unsigned.jar\"), Path.of(\".\"),\n+            Path.of(TESTFILE1));\n+\n+        genkeypair(\"-alias SHA1 -sigalg SHA1withRSA\");\n+        genkeypair(\"-alias SHA256 -sigalg SHA256withRSA\");\n+\n+        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n+        try (FileInputStream fis = new FileInputStream(\"keystore\")) {\n+            ks.load(fis, PASS.toCharArray());\n+        }\n+\n+        \/\/ Sign JAR twice with same signer but different digest algorithms\n+        \/\/ so that each entry in manifest file contains two digest values.\n+        signJarFile(ks, \"SHA1\", \"MD5\", \"unsigned.jar\", \"signed.jar\");\n+        signJarFile(ks, \"SHA1\", \"SHA1\", \"signed.jar\", \"signed2.jar\");\n+        checkThatJarIsSigned(\"signed2.jar\", false);\n+\n+        \/\/ add another file to the JAR\n+        Files.write(Path.of(TESTFILE2), \"testFile2\".getBytes());\n+        JarUtils.updateJarFile(Path.of(\"signed2.jar\"), Path.of(\".\"),\n+            Path.of(TESTFILE2));\n+\n+        \/\/ Sign again with different signer (SHA256) and SHA-1 digestalg.\n+        \/\/ TESTFILE1 should have two signers and TESTFILE2 should have one\n+        \/\/ signer.\n+        signJarFile(ks, \"SHA256\", \"SHA1\", \"signed2.jar\", \"multi-signed.jar\");\n+\n+        checkThatJarIsSigned(\"multi-signed.jar\", true);\n+    }\n+\n+    private static KeyStore.PrivateKeyEntry getEntry(KeyStore ks, String alias)\n+        throws Exception {\n+\n+        return (KeyStore.PrivateKeyEntry)\n+            ks.getEntry(alias,\n+                new KeyStore.PasswordProtection(PASS.toCharArray()));\n+    }\n+\n+    private static void genkeypair(String cmd) throws Exception {\n+        cmd = \"-genkeypair -keystore keystore -storepass \" + PASS +\n+              \" -keypass \" + PASS + \" -keyalg rsa -dname CN=Duke \" + cmd;\n+        sun.security.tools.keytool.Main.main(cmd.split(\" \"));\n+    }\n+\n+    private static void signJarFile(KeyStore ks, String alias,\n+        String digestAlg, String inputFile, String outputFile)\n+        throws Exception {\n+\n+        JarSigner signer = new JarSigner.Builder(getEntry(ks, alias))\n+                 .digestAlgorithm(digestAlg)\n+                 .signerName(alias)\n+                 .build();\n+\n+        try (ZipFile in = new ZipFile(inputFile);\n+            FileOutputStream out = new FileOutputStream(outputFile)) {\n+            signer.sign(in, out);\n+        }\n+    }\n+\n+    private static void checkThatJarIsSigned(String jarFile, boolean multi)\n+        throws Exception {\n+\n+        try (JarFile jf = new JarFile(jarFile, true)) {\n+            Enumeration<JarEntry> entries = jf.entries();\n+            while (entries.hasMoreElements()) {\n+                JarEntry entry = entries.nextElement();\n+                if (entry.isDirectory() || isSigningRelated(entry.getName())) {\n+                    continue;\n+                }\n+                InputStream is = jf.getInputStream(entry);\n+                while (is.read() != -1);\n+                CodeSigner[] signers = entry.getCodeSigners();\n+                if (signers == null) {\n+                    throw new Exception(\"JarEntry \" + entry.getName() +\n+                        \" is not signed\");\n+                } else if (multi) {\n+                    if (entry.getName().equals(TESTFILE1) &&\n+                        signers.length != 2) {\n+                        throw new Exception(\"Unexpected number of signers \" +\n+                            \"for \" + entry.getName() + \": \" + signers.length);\n+                    } else if (entry.getName().equals(TESTFILE2) &&\n+                        signers.length != 1) {\n+                        throw new Exception(\"Unexpected number of signers \" +\n+                            \"for \" + entry.getName() + \": \" + signers.length);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean isSigningRelated(String name) {\n+        name = name.toUpperCase(Locale.ENGLISH);\n+        if (!name.startsWith(\"META-INF\/\")) {\n+            return false;\n+        }\n+        name = name.substring(9);\n+        if (name.indexOf('\/') != -1) {\n+            return false;\n+        }\n+        return name.endsWith(\".SF\")\n+            || name.endsWith(\".DSA\")\n+            || name.endsWith(\".RSA\")\n+            || name.endsWith(\".EC\")\n+            || name.equals(\"MANIFEST.MF\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/security\/jarsigner\/JarWithOneNonDisabledDigestAlg.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-            client.setSoTimeout(2000);\n+            client.setSoTimeout(10000);\n","filename":"test\/jdk\/sun\/net\/ftp\/TestFtpTimeValue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/httptest\/\n- * @build HttpCallback TestHttpServer HttpTransaction\n+ * @library \/test\/lib\n@@ -35,3 +33,18 @@\n-import java.net.*;\n-import java.io.*;\n-import java.util.*;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.CacheRequest;\n+import java.net.CacheResponse;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ResponseCache;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -47,1 +60,1 @@\n-   static TestHttpServer server;\n+   static HttpServer server;\n@@ -59,1 +72,4 @@\n-     server = new TestHttpServer(httpTrans, 1, 10, loopback, 0);\n+     server = HttpServer.create(new InetSocketAddress(loopback, 0), 10);\n+     server.createContext(\"\/\", httpTrans);\n+     server.setExecutor(Executors.newSingleThreadExecutor());\n+     server.start();\n@@ -64,1 +80,1 @@\n-         System.out.println(\"http server listen on: \" + server.getLocalPort());\n+         System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n@@ -66,1 +82,1 @@\n-                            server.getLocalPort(), \"\/\");\n+                            server.getAddress().getPort(), \"\/\");\n@@ -70,1 +86,1 @@\n-         server.terminate();\n+         server.stop(1);\n@@ -75,1 +91,1 @@\n-class SimpleHttpTransaction implements HttpCallback\n+class SimpleHttpTransaction implements HttpHandler\n@@ -80,1 +96,2 @@\n-   public void request(HttpTransaction trans) {\n+   @Override\n+   public void handle(HttpExchange trans) {\n@@ -82,2 +99,2 @@\n-         trans.setResponseEntityBody(\"\");\n-         trans.sendResponse(200, \"OK\");\n+         trans.sendResponseHeaders(200, 0);\n+         trans.close();\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/B6296310.java","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,2 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/httptest\/\n- * @build HttpCallback TestHttpServer ClosedChannelList HttpTransaction\n- * @run main RelativeRedirect\n+ * @library \/test\/lib\n+ * @run main\/othervm RelativeRedirect\n@@ -35,2 +33,11 @@\n-import java.io.*;\n-import java.net.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.net.Authenticator;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.PasswordAuthentication;\n+import java.net.Proxy;\n+import java.net.URL;\n+import java.util.concurrent.Executors;\n@@ -38,1 +45,5 @@\n-public class RelativeRedirect implements HttpCallback {\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+public class RelativeRedirect implements HttpHandler {\n@@ -40,1 +51,2 @@\n-    static TestHttpServer server;\n+    static HttpServer server;\n+\n@@ -53,5 +65,4 @@\n-    void firstReply (HttpTransaction req) throws IOException {\n-        req.addResponseHeader (\"Connection\", \"close\");\n-        req.addResponseHeader (\"Location\", \"\/redirect\/file.html\");\n-        req.sendResponse (302, \"Moved Permamently\");\n-        req.orderlyClose();\n+    void firstReply(HttpExchange req) throws IOException {\n+        req.getResponseHeaders().set(\"Connection\", \"close\");\n+        req.getResponseHeaders().set(\"Location\", \"\/redirect\/file.html\");\n+        req.sendResponseHeaders(302, -1);\n@@ -60,1 +71,1 @@\n-    void secondReply (HttpTransaction req) throws IOException {\n+    void secondReply (HttpExchange req) throws IOException {\n@@ -62,3 +73,5 @@\n-            req.getRequestHeader(\"Host\").equals(authority(server.getLocalPort()))) {\n-            req.setResponseEntityBody (\"Hello .\");\n-            req.sendResponse (200, \"Ok\");\n+            req.getRequestHeaders().get(\"Host\").get(0).equals(authority(server.getAddress().getPort()))) {\n+            req.sendResponseHeaders(200, 0);\n+            try(PrintWriter pw = new PrintWriter(req.getResponseBody())) {\n+                pw.print(\"Hello .\");\n+            }\n@@ -66,2 +79,4 @@\n-            req.setResponseEntityBody (req.getRequestURI().toString());\n-            req.sendResponse (400, \"Bad request\");\n+            req.sendResponseHeaders(400, 0);\n+            try(PrintWriter pw = new PrintWriter(req.getResponseBody())) {\n+                pw.print(req.getRequestURI().toString());\n+            }\n@@ -69,2 +84,0 @@\n-        req.orderlyClose();\n-\n@@ -72,1 +85,3 @@\n-    public void request (HttpTransaction req) {\n+\n+    @Override\n+    public void handle (HttpExchange req) {\n@@ -104,3 +119,6 @@\n-            server = new TestHttpServer (new RelativeRedirect(), 1, 10, loopback, 0);\n-            System.out.println (\"Server: listening on port: \" + server.getLocalPort());\n-            URL url = new URL(\"http:\/\/\" + authority(server.getLocalPort()));\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10);\n+            server.createContext(\"\/\", new RelativeRedirect());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            System.out.println (\"Server: listening on port: \" + server.getAddress().getPort());\n+            URL url = new URL(\"http:\/\/\" + authority(server.getAddress().getPort()));\n@@ -115,1 +133,1 @@\n-                server.terminate();\n+                server.stop(1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/RelativeRedirect.java","additions":45,"deletions":27,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/httptest\/\n- * @build HttpCallback TestHttpServer ClosedChannelList HttpTransaction\n@@ -35,3 +32,21 @@\n-import java.net.*;\n-import java.io.*;\n-import java.util.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.CacheRequest;\n+import java.net.CacheResponse;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ResponseCache;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -40,1 +55,1 @@\n-public class ResponseCacheStream implements HttpCallback {\n+public class ResponseCacheStream implements HttpHandler {\n@@ -42,5 +57,6 @@\n-    void okReply (HttpTransaction req) throws IOException {\n-        req.setResponseEntityBody (\"Hello, This is the response body. Let's make it as long as possible since we need to test the cache mechanism.\");\n-        req.sendResponse (200, \"Ok\");\n-            System.out.println (\"Server: sent response\");\n-        req.orderlyClose();\n+    void okReply (HttpExchange req) throws IOException {\n+        req.sendResponseHeaders(200, 0);\n+        try(PrintWriter pw = new PrintWriter(req.getResponseBody())) {\n+            pw.print(\"Hello, This is the response body. Let's make it as long as possible since we need to test the cache mechanism.\");\n+        }\n+        System.out.println (\"Server: sent response\");\n@@ -49,6 +65,5 @@\n-    public void request (HttpTransaction req) {\n-        try {\n-            okReply (req);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        okReply(exchange);\n+        exchange.close();\n@@ -97,1 +112,1 @@\n-    static TestHttpServer server;\n+    static HttpServer server;\n@@ -104,2 +119,5 @@\n-            server = new TestHttpServer (new ResponseCacheStream(), loopback, 0);\n-            System.out.println (\"Server: listening on port: \" + server.getLocalPort());\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10);\n+            server.createContext(\"\/\", new ResponseCacheStream());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            System.out.println(\"Server: listening on port: \" + server.getAddress().getPort());\n@@ -109,1 +127,1 @@\n-                .port(server.getLocalPort())\n+                .port(server.getAddress().getPort())\n@@ -152,1 +170,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -156,1 +174,1 @@\n-        server.terminate();\n+        server.stop(1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/ResponseCacheStream.java","additions":43,"deletions":25,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/httptest\/\n@@ -30,2 +28,1 @@\n- * @build HttpCallback TestHttpServer ClosedChannelList HttpTransaction\n- * @run main SetChunkedStreamingMode\n+ * @run main\/othervm SetChunkedStreamingMode\n@@ -35,3 +32,8 @@\n-import java.io.*;\n-import java.net.*;\n-import jdk.test.lib.net.URIBuilder;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.util.concurrent.Executors;\n@@ -39,1 +41,4 @@\n-public class SetChunkedStreamingMode implements HttpCallback {\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n@@ -41,6 +46,1 @@\n-    void okReply (HttpTransaction req) throws IOException {\n-        req.setResponseEntityBody (\"Hello .\");\n-        req.sendResponse (200, \"Ok\");\n-            System.out.println (\"Server: sent response\");\n-        req.orderlyClose();\n-    }\n+public class SetChunkedStreamingMode implements HttpHandler {\n@@ -48,5 +48,4 @@\n-    public void request (HttpTransaction req) {\n-        try {\n-            okReply (req);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n+    void okReply (HttpExchange req) throws IOException {\n+        req.sendResponseHeaders(200, 0);\n+        try(PrintWriter pw = new PrintWriter(req.getResponseBody())) {\n+            pw.print(\"Hello .\");\n@@ -54,0 +53,1 @@\n+        System.out.println (\"Server: sent response\");\n@@ -56,8 +56,3 @@\n-    static void read (InputStream is) throws IOException {\n-        int c;\n-        System.out.println (\"reading\");\n-        while ((c=is.read()) != -1) {\n-            System.out.write (c);\n-        }\n-        System.out.println (\"\");\n-        System.out.println (\"finished reading\");\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        okReply(exchange);\n@@ -66,1 +61,1 @@\n-    static TestHttpServer server;\n+    static HttpServer server;\n@@ -70,3 +65,6 @@\n-            server = new TestHttpServer(new SetChunkedStreamingMode(), 1, 10,\n-                    InetAddress.getLoopbackAddress(), 0);\n-            System.out.println (\"Server: listening on port: \" + server.getLocalPort());\n+            InetAddress loopback = InetAddress.getLoopbackAddress();\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10);\n+            server.createContext(\"\/\", new SetChunkedStreamingMode());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            System.out.println (\"Server: listening on port: \" + server.getAddress().getPort());\n@@ -76,1 +74,1 @@\n-                .port(server.getLocalPort())\n+                .port(server.getAddress().getPort())\n@@ -87,1 +85,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -91,1 +89,1 @@\n-        server.terminate();\n+        server.stop(1);\n@@ -95,1 +93,1 @@\n-        server.terminate();\n+        server.stop(1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/SetChunkedStreamingMode.java","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1,247 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.jdi.Bootstrap;\n-import com.sun.jdi.VMDisconnectedException;\n-import com.sun.jdi.VirtualMachine;\n-import com.sun.jdi.connect.Connector;\n-import com.sun.jdi.connect.LaunchingConnector;\n-import com.sun.jdi.event.Event;\n-import com.sun.jdi.event.EventSet;\n-import com.sun.jdi.event.MethodEntryEvent;\n-import com.sun.jdi.request.MethodEntryRequest;\n-\n-import java.security.AlgorithmParameters;\n-import java.security.KeyPair;\n-import java.security.KeyPairGenerator;\n-import java.security.SecureRandom;\n-import java.security.Signature;\n-import java.security.SignatureException;\n-import java.security.interfaces.ECPrivateKey;\n-import java.security.interfaces.ECPublicKey;\n-import java.security.spec.ECGenParameterSpec;\n-import java.security.spec.ECParameterSpec;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-\n-\/*\n- * @test\n- * @bug 8237218 8239928\n- * @modules jdk.crypto.ec\n- *          jdk.jdi\n- * @requires os.family != \"windows\"\n- * @run main ECDSAJavaVerify debug\n- * @summary Support NIST Curves verification in java implementation.\n- *  This test does not run stable on Windows. VMDisconnectedException\n- *  might not be thrown at all.\n- *\/\n-\n-\/\/ ATTENTION: This test depends on method names inside the non-exported\n-\/\/ class sun.security.ec.ECDSASignature.\n-public class ECDSAJavaVerify {\n-\n-    static final String[] ALL_ALGS = new String[] {\n-            \"SHA1withECDSA\", \"SHA256withECDSA\", \"SHA384withECDSA\", \"SHA512withECDSA\"};\n-\n-    static final String[] ALL_CURVES = new String[] {\n-            \"secp256r1\", \"secp384r1\", \"secp521r1\"};\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 1) {\n-            \/\/ Debugging a new process with no arg\n-            debug();\n-        } else if (args.length == 3) {\n-            \/\/ If one test case fail, re-run it with first 3 columns\n-            new Test().run(Integer.parseInt(args[0]), args[1], args[2]);\n-        } else {\n-            \/\/ Run all test cases\n-            Test t = new Test();\n-            Random r = new Random();\n-\n-            for (String sigAlg : ALL_ALGS) {\n-                for (String curve : ALL_CURVES) {\n-                    t.run(r.nextInt(1000000), sigAlg, curve);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void debug() throws Exception {\n-\n-        LaunchingConnector launchingConnector = Bootstrap\n-                .virtualMachineManager().defaultConnector();\n-\n-        Map<String, Connector.Argument> arguments\n-                = launchingConnector.defaultArguments();\n-        arguments.get(\"main\").setValue(ECDSAJavaVerify.class.getName());\n-        arguments.get(\"options\").setValue(\n-                \"-cp \" + System.getProperty(\"test.classes\"));\n-        VirtualMachine vm = launchingConnector.launch(arguments);\n-\n-        MethodEntryRequest req = vm.eventRequestManager()\n-                .createMethodEntryRequest();\n-        req.addClassFilter(\"sun.security.ec.ECDSASignature\");\n-        req.enable();\n-\n-        int numberOfTests = ALL_ALGS.length * ALL_CURVES.length * 2;\n-\n-        \/\/ Expected methods to call. 'J' for java impl, 'N' for native impl\n-        char[] expected = new char[numberOfTests];\n-\n-        int pos = 0;\n-        for (String dummy : ALL_ALGS) {\n-            for (String curve : ALL_CURVES) {\n-                char caller = 'J';\n-                \/\/ For each case, Signature::verify is called twice\n-                expected[pos++] = caller;\n-                expected[pos++] = caller;\n-            }\n-        }\n-\n-        \/\/ Test result\n-        \/\/ '.': not run yet\n-        \/\/ '-': enter engineVerify\n-        \/\/ 'v': expected impl called\n-        \/\/ 'x': unexpected impl called\n-        \/\/ Note: some error cases fail before any impl called. Ex: if there\n-        \/\/ is a DER encoding error.\n-        char[] result = new char[numberOfTests];\n-        Arrays.fill(result, '.');\n-\n-        String stdout, stderr;\n-\n-        try {\n-            EventSet eventSet;\n-            pos = -1; \/\/ will become 0 when entering 'engineVerify'\n-            while ((eventSet = vm.eventQueue().remove()) != null) {\n-                for (Event event : eventSet) {\n-                    if (event instanceof MethodEntryEvent) {\n-                        MethodEntryEvent e = (MethodEntryEvent)event;\n-                        switch (e.method().name()) {\n-                            case \"engineVerify\":\n-                                result[++pos] = '-';\n-                                break;\n-                            case \"verifySignedDigestImpl\": \/\/ the java impl\n-                                result[pos] = expected[pos] != 'J' ? 'x' : 'v';\n-                                break;\n-                        }\n-                    }\n-                    vm.resume();\n-                }\n-            }\n-        } catch (VMDisconnectedException e) {\n-            System.out.println(\"Virtual Machine is disconnected.\");\n-        } finally {\n-            stderr = new String(vm.process().getErrorStream().readAllBytes());\n-            stdout = new String(vm.process().getInputStream().readAllBytes());\n-        }\n-\n-        int exitCode = vm.process().waitFor();\n-        System.out.println(\"  exit: \" + exitCode);\n-        System.out.println(\"stderr:\\n\" + stderr);\n-        System.out.println(\"stdout:\\n\" + stdout);\n-\n-        String sResult = new String(result);\n-\n-        System.out.println(\" Cases: \" + new String(expected));\n-        System.out.println(\"Result: \" + sResult);\n-\n-        if (pos != numberOfTests - 1 || sResult.contains(\"x\")\n-                || sResult.contains(\".\")) {\n-            throw new Exception(\"Unexpected result\");\n-        }\n-\n-        if (stdout.contains(\"fail\") || exitCode != 0) {\n-            throw new Exception(\"Test failed\");\n-        }\n-    }\n-\n-    static class Test {\n-\n-        public boolean run(int seed, String sigAlg, String curve)\n-                throws Exception {\n-\n-            \/\/ A determined SecureRandom based on seed. If there is anything\n-            \/\/ wrong, we can reproduce the problem using the seed.\n-            Random r = new Random(seed);\n-            SecureRandom rand = new SecureRandom() {\n-                @Override\n-                public void nextBytes(byte[] bytes) {\n-                    r.nextBytes(bytes);\n-                }\n-            };\n-\n-            AlgorithmParameters ap = AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n-            ap.init(new ECGenParameterSpec(curve));\n-            ECParameterSpec spec = ap.getParameterSpec(ECParameterSpec.class);\n-\n-            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n-            kpg.initialize(spec, rand);\n-            KeyPair kp = kpg.generateKeyPair();\n-            ECPrivateKey ecPrivateKey = (ECPrivateKey) kp.getPrivate();\n-            ECPublicKey ecPublicKey = (ECPublicKey) kp.getPublic();\n-\n-            Signature s1 = Signature.getInstance(sigAlg, \"SunEC\");\n-            s1.initSign(ecPrivateKey, rand);\n-            byte[] msg = new byte[1234];\n-            rand.nextBytes(msg);\n-            s1.update(msg);\n-            byte[] sig = s1.sign();\n-\n-            Signature s2 = Signature.getInstance(sigAlg, \"SunEC\");\n-            s2.initVerify(ecPublicKey);\n-            s2.update(msg);\n-\n-            boolean result1 = s2.verify(sig);\n-\n-            s2.initVerify(ecPublicKey);\n-            \/\/ modify the signature in some random manner\n-            if (rand.nextInt(10) < 8) {\n-                sig[rand.nextInt(10000) % sig.length]\n-                        = (byte) rand.nextInt(10000);\n-            } else {\n-                int newLength = rand.nextInt(100);\n-                if (newLength == sig.length) {\n-                    newLength += 1 + rand.nextInt(2);\n-                }\n-                sig = Arrays.copyOf(sig, newLength);\n-            }\n-\n-            boolean result2;\n-            try {\n-                result2 = s2.verify(sig);\n-            } catch (SignatureException se) {\n-                result2 = false;\n-            }\n-\n-            boolean finalResult = result1 && !result2;\n-            System.out.printf(\"%10d %20s %20s -- %5s %5s -- %s\\n\",\n-                    seed, sigAlg, curve, result1, result2,\n-                    finalResult ? \"succeed\" : \"fail\");\n-\n-            return finalResult;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ec\/ECDSAJavaVerify.java","additions":0,"deletions":247,"binary":false,"changes":247,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6851973 8194486\n+ * @bug 6851973 8194486 8279520\n@@ -36,0 +36,1 @@\n+import org.ietf.jgss.Oid;\n@@ -44,0 +45,5 @@\n+        test(GSSUtil.GSS_KRB5_MECH_OID);\n+        test(GSSUtil.GSS_SPNEGO_MECH_OID);\n+    }\n+\n+    static void test(Oid mech) throws Exception {\n@@ -49,2 +55,2 @@\n-        c.startAsClient(OneKDC.SERVER, GSSUtil.GSS_KRB5_MECH_OID);\n-        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        c.startAsClient(OneKDC.SERVER, mech);\n+        s.startAsServer(mech);\n@@ -54,1 +60,1 @@\n-        c.startAsClient(OneKDC.SERVER, GSSUtil.GSS_KRB5_MECH_OID);\n+        c.startAsClient(OneKDC.SERVER, mech);\n@@ -60,1 +66,1 @@\n-        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        s.startAsServer(mech);\n@@ -64,1 +70,1 @@\n-        c.startAsClient(OneKDC.SERVER, GSSUtil.GSS_KRB5_MECH_OID);\n+        c.startAsClient(OneKDC.SERVER, mech);\n@@ -70,1 +76,1 @@\n-        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        s.startAsServer(mech);\n@@ -79,1 +85,1 @@\n-        c.startAsClient(OneKDC.SERVER, GSSUtil.GSS_KRB5_MECH_OID);\n+        c.startAsClient(OneKDC.SERVER, mech);\n@@ -85,1 +91,1 @@\n-        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        s.startAsServer(mech);\n@@ -99,2 +105,2 @@\n-        c.startAsClient(OneKDC.SERVER, GSSUtil.GSS_KRB5_MECH_OID);\n-        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        c.startAsClient(OneKDC.SERVER, mech);\n+        s.startAsServer(mech);\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/IgnoreChannelBinding.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +25,0 @@\n-import java.math.BigInteger;\n@@ -89,1 +89,1 @@\n-            KeySpec spec = factory.getKeySpec(key, RSAPrivateKeySpec.class);\n+            KeySpec spec = factory.getKeySpec(key, specClass);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/rsa\/TestP11KeyFactoryGetRSAKeySpec.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8228969 8244087\n+ * @bug 8228969 8244087 8255266\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/ParseNames.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,5 @@\n+# br\n+br                      br              null\n+dev.br                  dev.br          null\n+x.dev.br                dev.br          x.dev.br\n+\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/tests.dat","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4225317 6969651\n+ * @bug 4225317 6969651 8277422\n@@ -34,0 +34,1 @@\n+import java.time.ZoneId;\n@@ -96,0 +97,8 @@\n+        var date = new Date();\n+        var defZone = ZoneId.systemDefault();\n+        if (defZone.getRules().getTransition(\n+                date.toInstant().atZone(defZone).toLocalDateTime()) != null) {\n+            System.out.println(\"At the offset transition.  JarEntryTime test skipped.\");\n+            return;\n+        }\n+\n","filename":"test\/jdk\/tools\/jar\/JarEntryTime.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -363,0 +363,4 @@\n+        if (!isEnglishLocale()) {\n+            return;\n+        }\n+\n","filename":"test\/jdk\/tools\/launcher\/FXLauncherTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,4 @@\n+        if (!isEnglishLocale()) {\n+            return;\n+        }\n+\n@@ -257,0 +261,4 @@\n+        if (!isEnglishLocale()) {\n+            return;\n+        }\n+\n","filename":"test\/jdk\/tools\/launcher\/SourceMode.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+        map.put(\"vm.hasDTrace\", this::vmHasDTrace);\n@@ -342,0 +343,7 @@\n+    \/**\n+     * @return \"true\" if the VM is compiled with DTrace\n+     *\/\n+    protected String vmHasDTrace() {\n+        return \"\" + WB.isDTraceIncluded();\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @library ..\/..\/lib\n+ * @library \/tools\/lib ..\/..\/lib\n@@ -33,1 +33,1 @@\n- * @build javadoc.tester.*\n+ * @build toolbox.ToolBox javadoc.tester.*\n@@ -38,0 +38,1 @@\n+import toolbox.ToolBox;\n@@ -46,0 +47,2 @@\n+    ToolBox tb = new ToolBox();\n+\n@@ -49,1 +52,1 @@\n-        copyDir(testSrc(\"pkg\"), \".\");\n+        tb.copyDir(testSrc(\"pkg\"), \"pkg\");\n@@ -61,1 +64,1 @@\n-        copyDir(testSrc(\"pkg\"), outdir);\n+        tb.copyDir(testSrc(\"pkg\"), outdir + \"\/pkg\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocFileDir\/TestDocFileDir.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,3 +168,2 @@\n-        Path outputDirPath = outputDir.toPath();\n-        for (Path p : tb.findFiles(\".html\", outputDirPath)) {\n-            checkBodyClass(outputDirPath.relativize(p));\n+        for (Path p : tb.findFiles(\".html\", outputDir)) {\n+            checkBodyClass(outputDir.relativize(p));\n@@ -234,3 +233,2 @@\n-        Path outputDirPath = outputDir.toPath();\n-        for (Path p : tb.findFiles(\".html\", outputDirPath)) {\n-            checkMetadata(outputDirPath.relativize(p));\n+        for (Path p : tb.findFiles(\".html\", outputDir)) {\n+            checkMetadata(outputDir.relativize(p));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMetadata\/TestMetadata.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -203,1 +206,1 @@\n-        File f = new File(outputDir, file);\n+        Path f = outputDir.resolve(file);\n@@ -205,1 +208,1 @@\n-        try (FileOutputStream fos = new FileOutputStream(f)) {\n+        try (OutputStream fos = Files.newOutputStream(f)) {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRelativeLinks\/TestRelativeLinks.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,0 @@\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.FileReader;\n@@ -48,0 +45,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -74,1 +73,1 @@\n-        engine.eval(new BufferedReader(new FileReader(new File(testSrc, \"javadoc-search.js\"))));\n+        engine.eval(Files.newBufferedReader(Path.of(testSrc).resolve(\"javadoc-search.js\")));\n@@ -76,1 +75,1 @@\n-        inv.invokeFunction(\"loadIndexFiles\", outputDir.getAbsolutePath());\n+        inv.invokeFunction(\"loadIndexFiles\", outputDir.toAbsolutePath().toString());\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearchScript\/TestSearchScript.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-            c.checkDirectory(outputDir.toPath());\n+            c.checkDirectory(outputDir);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSingletonLists\/TestSingletonLists.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-            c.checkDirectory(outputDir.toPath());\n+            c.checkDirectory(outputDir);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -30,2 +29,0 @@\n-import java.io.FileWriter;\n-import java.io.FilenameFilter;\n@@ -44,0 +41,2 @@\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitResult;\n@@ -47,0 +46,2 @@\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -51,0 +52,1 @@\n+import java.util.Comparator;\n@@ -160,1 +162,1 @@\n-    protected File outputDir;\n+    protected Path outputDir;\n@@ -172,1 +174,1 @@\n-    private final Map<File,SoftReference<String>> fileContentCache = new HashMap<>();\n+    private final Map<Path,SoftReference<String>> fileContentCache = new HashMap<>();\n@@ -188,1 +190,1 @@\n-        return new File(testSrc, path).getPath();\n+        return Path.of(testSrc).resolve(path).toString();\n@@ -198,1 +200,1 @@\n-        EMPTY((file, name) -> true),\n+        EMPTY(p -> true),\n@@ -205,1 +207,1 @@\n-        NO_HTML_FILES((file, name) -> name.endsWith(\".html\")),\n+        NO_HTML_FILES(p -> p.getFileName().toString().endsWith(\".html\")),\n@@ -209,1 +211,1 @@\n-        NONE(null) { @Override void check(File dir) { } };\n+        NONE(null) { @Override void check(Path dir) { } };\n@@ -212,1 +214,1 @@\n-        FilenameFilter filter;\n+        DirectoryStream.Filter<Path> filter;\n@@ -214,1 +216,1 @@\n-        DirectoryCheck(FilenameFilter f) {\n+        DirectoryCheck(DirectoryStream.Filter<Path> f) {\n@@ -218,9 +220,14 @@\n-        void check(File dir) {\n-            if (dir.isDirectory()) {\n-                String[] contents = dir.list(filter);\n-                if (contents == null)\n-                    throw new Error(\"cannot list directory: \" + dir);\n-                if (contents.length > 0) {\n-                    System.err.println(\"Found extraneous files in dir:\" + dir.getAbsolutePath());\n-                    for (String x : contents) {\n-                        System.err.println(x);\n+        void check(Path dir) {\n+            if (Files.isDirectory(dir)) {\n+                List<Path> contents = new ArrayList<>();\n+                try (var ds = Files.newDirectoryStream(dir, filter)) {\n+                    for (Path p : ds) {\n+                        contents.add(p);\n+                    }\n+                } catch (IOException e) {\n+                    throw new Error(\"cannot list directory: \" + dir + \"; \" + e, e);\n+                }\n+                if (!contents.isEmpty()) {\n+                    System.err.println(\"Found extraneous files in dir:\" + dir.toAbsolutePath());\n+                    for (Path p : contents) {\n+                        System.err.println(p);\n@@ -319,1 +326,1 @@\n-        outputDir = new File(\".\");\n+        outputDir = Path.of(\".\");\n@@ -325,1 +332,1 @@\n-                case \"-d\" -> outputDir = new File(args[++i]);\n+                case \"-d\" -> outputDir = Path.of(args[++i]);\n@@ -380,1 +387,1 @@\n-        if (exitCode == Exit.OK.code && outputDir.exists()) {\n+        if (exitCode == Exit.OK.code && Files.exists(outputDir)) {\n@@ -505,2 +512,2 @@\n-            String fileString = readFile(outputDir, path);\n-            checkOutput(new File(outputDir, path).getPath(), fileString, expectedFound, strings);\n+            String fileString = readFile(outputDir, Path.of(path));\n+            checkOutput(outputDir.resolve(path).toString(), fileString, expectedFound, strings);\n@@ -597,1 +604,1 @@\n-            c.checkDirectory(outputDir.toPath());\n+            c.checkDirectory(outputDir);\n@@ -619,1 +626,1 @@\n-            c.checkDirectory(outputDir.toPath());\n+            c.checkDirectory(outputDir);\n@@ -644,2 +651,2 @@\n-                File f = new File(outputDir, p);\n-                s.checkFiles(List.of(f.toPath()), false, Collections.emptySet());\n+                Path f = outputDir.resolve(p);\n+                s.checkFiles(List.of(f), false, Collections.emptySet());\n@@ -694,2 +701,2 @@\n-            File file = new File(outputDir, path);\n-            boolean isFound = file.exists();\n+            Path file = outputDir.resolve(path);\n+            boolean isFound = Files.exists(file);\n@@ -711,1 +718,1 @@\n-        File file = new File(outputDir, path);\n+        Path file = outputDir.resolve(path);\n@@ -739,1 +746,1 @@\n-        File file = new File(outputDir, path);\n+        Path file = outputDir.resolve(path);\n@@ -765,2 +772,2 @@\n-        File bd1 = new File(baseDir1);\n-        File bd2 = new File(baseDir2);\n+        Path bd1 = Path.of(baseDir1);\n+        Path bd2 = Path.of(baseDir2);\n@@ -768,1 +775,1 @@\n-            diff(bd1, bd2, file);\n+            diff(bd1, bd2, Path.of(file));\n@@ -772,45 +779,0 @@\n-    \/**\n-     * Copies a directory from one place to another.\n-     *\n-     * @param targetDir the directory to copy.\n-     * @param destDir the destination to copy the directory to.\n-     *\/\n-    \/\/ TODO: convert to using java.nio.Files.walkFileTree\n-    public void copyDir(String targetDir, String destDir) {\n-        try {\n-            File targetDirObj = new File(targetDir);\n-            File destDirParentObj = new File(destDir);\n-            File destDirObj = new File(destDirParentObj, targetDirObj.getName());\n-            if (! destDirParentObj.exists()) {\n-                destDirParentObj.mkdir();\n-            }\n-            if (! destDirObj.exists()) {\n-                destDirObj.mkdir();\n-            }\n-            String[] files = targetDirObj.list();\n-            for (String file : files) {\n-                File srcFile = new File(targetDirObj, file);\n-                File destFile = new File(destDirObj, file);\n-                if (srcFile.isFile()) {\n-                    out.println(\"Copying \" + srcFile + \" to \" + destFile);\n-                    copyFile(destFile, srcFile);\n-                } else if(srcFile.isDirectory()) {\n-                    copyDir(srcFile.getAbsolutePath(), destDirObj.getAbsolutePath());\n-                }\n-            }\n-        } catch (IOException exc) {\n-            throw new Error(\"Could not copy \" + targetDir + \" to \" + destDir);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a file.\n-     *\n-     * @param destfile the destination file\n-     * @param srcfile the source file\n-     * @throws IOException\n-     *\/\n-    public void copyFile(File destfile, File srcfile) throws IOException {\n-        Files.copy(srcfile.toPath(), destfile.toPath());\n-    }\n-\n@@ -824,1 +786,1 @@\n-        return readFile(outputDir, fileName);\n+        return readFile(outputDir, Path.of(fileName));\n@@ -828,1 +790,1 @@\n-        return readFile(outputDir, fileName);\n+        return readFile(outputDir, Path.of(fileName));\n@@ -832,1 +794,1 @@\n-        return readFile(new File(baseDir), fileName);\n+        return readFile(Path.of(baseDir), Path.of(fileName));\n@@ -836,2 +798,2 @@\n-        File baseDir;\n-        if (file.startsWith(outputDir.toPath())) {\n+        Path baseDir;\n+        if (file.startsWith(outputDir)) {\n@@ -840,1 +802,1 @@\n-            baseDir = currDir.toFile();\n+            baseDir = currDir;\n@@ -842,1 +804,1 @@\n-            baseDir = file.getParent().toFile();\n+            baseDir = file.getParent();\n@@ -844,1 +806,1 @@\n-        String fileName = baseDir.toPath().relativize(file).toString();\n+        Path fileName = baseDir.relativize(file);\n@@ -855,1 +817,1 @@\n-    private String readFile(File baseDir, String fileName) throws Error {\n+    private String readFile(Path baseDir, Path fileName) throws Error {\n@@ -861,1 +823,1 @@\n-            File file = new File(baseDir, fileName);\n+            Path file = baseDir.resolve(fileName);\n@@ -868,1 +830,1 @@\n-            content = new String(Files.readAllBytes(file.toPath()), charset);\n+            content = new String(Files.readAllBytes(file), charset);\n@@ -900,1 +862,1 @@\n-    protected void passed(File file, String message) {\n+    protected void passed(Path file, String message) {\n@@ -925,1 +887,1 @@\n-    protected void failed(File file, String message) {\n+    protected void failed(Path file, String message) {\n@@ -1005,1 +967,1 @@\n-    private void diff(File baseDir1, File baseDir2, String file) {\n+    private void diff(Path baseDir1, Path baseDir2, Path file) {\n@@ -1008,1 +970,1 @@\n-        checking(\"diff \" + new File(baseDir1, file) + \", \" + new File(baseDir2, file));\n+        checking(\"diff \" + baseDir1.resolve(file) + \", \" + baseDir2.resolve(file));\n@@ -1071,8 +1033,8 @@\n-        String outDir;\n-        String rootDir = rootDir();\n-\n-        static String rootDir() {\n-            File f = new File(\".\").getAbsoluteFile();\n-            while (!new File(f, \".hg\").exists())\n-                f = f.getParentFile();\n-            return f.getPath();\n+        Path outDir;\n+        Path rootDir = rootDir();\n+\n+        static Path rootDir() {\n+            Path f = Path.of(\".\").toAbsolutePath();\n+            while (f != null && !Files.exists(f.resolve(\".git\")))\n+                f = f.getParent();\n+            return f;\n@@ -1081,2 +1043,2 @@\n-        void setOutDir(File outDir) {\n-            this.outDir = outDir.getPath();\n+        void setOutDir(Path outDir) {\n+            this.outDir = outDir;\n@@ -1087,3 +1049,4 @@\n-            if (file.startsWith(outDir + \"\/\"))\n-                file = file.substring(outDir.length() + 1);\n-            tests.add(file + \" \" + positive);\n+            Path p = Path.of(file);\n+            if (p.startsWith(outDir))\n+                p = p.relativize(outDir);\n+            tests.add(p + \" \" + positive);\n@@ -1094,1 +1057,1 @@\n-            String simpleText = text.replaceAll(\"\\\\s+\", \" \").replace(rootDir, \"[ROOT]\");\n+            String simpleText = text.replaceAll(\"\\\\s+\", \" \").replace(rootDir.toString(), \"[ROOT]\");\n@@ -1099,2 +1062,3 @@\n-            if (file.startsWith(outDir + \"\/\"))\n-                file = file.substring(outDir.length() + 1);\n+            Path p = Path.of(file);\n+            if (p.startsWith(outDir))\n+                p = p.relativize(outDir);\n@@ -1102,1 +1066,1 @@\n-            tests.add(file + \" \" + positive + \" \" + text.hashCode() + \" \" + simpleText);\n+            tests.add(p + \" \" + positive + \" \" + text.hashCode() + \" \" + simpleText);\n@@ -1107,2 +1071,2 @@\n-            tests.sort((a, b) -> a.compareTo(b));\n-            try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"tester.log\"))) {\n+            tests.sort(Comparator.naturalOrder());\n+            try (var bw = Files.newBufferedWriter(Path.of(\"tester.log\"))) {\n@@ -1119,2 +1083,0 @@\n-    \/\/ Support classes for checkLinks\n-\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":79,"deletions":117,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -556,1 +556,1 @@\n-        test(\n+        test(new String[]{\"-R\", \"-Duser.language=en\", \"-R\", \"-Duser.country=US\"},\n","filename":"test\/langtools\/jdk\/jshell\/ToolBasicTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -747,1 +747,2 @@\n-        test(new String[]{\"--startup\", \"DEFAULT\", \"--startup\", \"PRINTING\"},\n+        test(new String[]{\"-R\", \"-Duser.language=en\", \"-R\", \"-Duser.country=US\",\n+                          \"--startup\", \"DEFAULT\", \"--startup\", \"PRINTING\"},\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng LambdaTranslationTest1\n+ * @run testng\/othervm -Duser.language=en -Duser.country=US LambdaTranslationTest1\n","filename":"test\/langtools\/tools\/javac\/lambda\/lambdaExecution\/LambdaTranslationTest1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng LambdaTranslationTest2\n+ * @run testng\/othervm -Duser.language=en -Duser.country=US LambdaTranslationTest2\n","filename":"test\/langtools\/tools\/javac\/lambda\/lambdaExecution\/LambdaTranslationTest2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/tools\/lib\n@@ -31,0 +32,2 @@\n+ * @build toolbox.ToolBox\n+ * @run main ReportOnImportedModuleAnnotation\n@@ -44,0 +47,2 @@\n+import toolbox.ToolBox;\n+\n@@ -52,0 +57,3 @@\n+        \/\/ Clean any existing files in output directory\n+        (new ToolBox()).cleanDirectory(testOutputPath);\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/ReportOnImportedModuleAnnotation\/ReportOnImportedModuleAnnotation.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277165\n+ * @library ..\/lib\n+ * @build CompilerUtils\n+ * @run testng MultiVersionError\n+ * @summary Tests multiple versions of the same class file\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Set;\n+import java.util.spi.ToolProvider;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class MultiVersionError {\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"src\");\n+\n+    private static final Path MODS_DIR = Paths.get(\"mods\");\n+\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\").orElseThrow();\n+    private static final Set<String> modules = Set.of(\"m1\", \"m2\");\n+\n+    \/**\n+     * Compiles classes used by the test\n+     *\/\n+    @BeforeTest\n+    public void compileAll() throws Exception {\n+        CompilerUtils.cleanDir(MODS_DIR);\n+        modules.forEach(mn ->\n+                assertTrue(CompilerUtils.compileModule(SRC_DIR, MODS_DIR, mn)));\n+\n+        \/\/ create a modular multi-release m1.jar\n+        Path m1 = MODS_DIR.resolve(\"m1\");\n+        Path m2 = MODS_DIR.resolve(\"m2\");\n+        jar(\"cf\", \"m1.jar\", \"-C\", m1.toString(), \"p\/Test.class\",\n+                \"--release\", \"9\", \"-C\", m1.toString(), \"module-info.class\",\n+                \"--release\", \"11\", \"-C\", m1.toString(), \"p\/internal\/P.class\");\n+        jar(\"cf\", \"m2.jar\", \"-C\", m2.toString(), \"q\/Q.class\",\n+                \"--release\", \"10\", \"-C\", m2.toString(), \"module-info.class\");\n+\n+        \/\/ package private p\/internal\/P.class in m1 instead\n+        jar(\"cf\", \"m3.jar\", \"-C\", m2.toString(), \"q\/Q.class\",\n+                \"--release\", \"12\", \"-C\", m2.toString(), \"module-info.class\",\n+                \"-C\", m1.toString(), \"p\/internal\/P.class\");\n+    }\n+\n+    \/*\n+     * multiple module-info.class from different versions should be excluded\n+     * from multiple version check.\n+     *\/\n+    @Test\n+    public void noMultiVersionClass() {\n+        \/\/ skip parsing p.internal.P to workaround JDK-8277681\n+        JdepsRunner jdepsRunner = new JdepsRunner(\"--print-module-deps\", \"--multi-release\", \"10\",\n+                                                  \"--ignore-missing-deps\",\n+                                                  \"--module-path\", \"m1.jar\", \"m2.jar\");\n+        int rc = jdepsRunner.run(true);\n+        assertTrue(rc == 0);\n+        assertTrue(jdepsRunner.outputContains(\"java.base,m1\"));\n+    }\n+\n+    \/*\n+     * Detect multiple versions of p.internal.P class\n+     *\/\n+    @Test\n+    public void classInMultiVersions() {\n+        JdepsRunner jdepsRunner = new JdepsRunner(\"--print-module-deps\", \"--multi-release\", \"13\",\n+                                                  \"--module-path\", \"m1.jar\", \"m3.jar\");\n+        int rc = jdepsRunner.run(true);\n+        assertTrue(rc != 0);\n+        assertTrue(jdepsRunner.outputContains(\"class p.internal.P already associated with version\"));\n+    }\n+\n+    private static void jar(String... options) {\n+        int rc = JAR_TOOL.run(System.out, System.err, options);\n+        assertTrue(rc == 0);\n+    }\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/MultiVersionError.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module m1 {\n+    requires java.management;\n+    exports p;\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,3 @@\n-module m2 {\n-    exports q;\n+package p;\n+\n+public class Test {\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/p\/Test.java","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"test\/jdk\/java\/lang\/module\/customfs\/m2\/module-info.java","status":"copied"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.internal;\n+\n+import java.lang.management.*;\n+\n+class P {\n+     private static RuntimeMXBean mxbean = ManagementFactory.getRuntimeMXBean();\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/p\/internal\/P.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,2 @@\n-    exports q;\n+    requires m1;\n+    requires java.logging;\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/module-info.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/lang\/module\/customfs\/m2\/module-info.java","status":"copied"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.internal;\n+\n+import java.util.logging.Logger;\n+\n+public class P {\n+     private static final Logger LOGGER = Logger.getLogger(\"p\");\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/p\/internal\/P.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package q;\n+\n+public class Q {\n+    static p.Test t = new p.Test();\n+\n+    public Q() {\n+        Object o = new p.internal.P();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/q\/Q.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -37,1 +37,2 @@\n-import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.FileVisitOption;\n@@ -40,1 +41,0 @@\n-import java.nio.file.NoSuchFileException;\n@@ -51,0 +51,1 @@\n+import java.util.EnumSet;\n@@ -68,2 +69,0 @@\n-import javax.tools.JavaFileObject.Kind;\n-import javax.tools.JavaFileManager.Location;\n@@ -110,1 +109,1 @@\n-        timeoutFactor = (ttf == null) ? 1.0f : Float.valueOf(ttf);\n+        timeoutFactor = (ttf == null) ? 1.0f : Float.parseFloat(ttf);\n@@ -114,1 +113,1 @@\n-    public static final Path currDir = Paths.get(\".\");\n+    public static final Path currDir = Path.of(\".\");\n@@ -130,0 +129,1 @@\n+     *\n@@ -142,0 +142,1 @@\n+     *\n@@ -169,0 +170,1 @@\n+     *\n@@ -180,0 +182,1 @@\n+     *\n@@ -181,1 +184,1 @@\n-     * @param lines the strings to be filtered\n+     * @param lines   the strings to be filtered\n@@ -191,0 +194,1 @@\n+     *\n@@ -203,0 +207,1 @@\n+     *\n@@ -204,2 +209,2 @@\n-     * @param lines the strings to be filtered\n-     * @param match if true, return the lines that match; otherwise if false, return the lines that do not match.\n+     * @param lines   the strings to be filtered\n+     * @param match   if true, return the lines that match; otherwise if false, return the lines that do not match.\n@@ -220,0 +225,1 @@\n+     *\n@@ -221,1 +227,1 @@\n-     * @param to where to copy the file\n+     * @param to   where to copy the file\n@@ -225,1 +231,1 @@\n-        copyFile(Paths.get(from), Paths.get(to));\n+        copyFile(Path.of(from), Path.of(to));\n@@ -234,0 +240,1 @@\n+     *\n@@ -235,1 +242,1 @@\n-     * @param to where to copy the file\n+     * @param to   where to copy the file\n@@ -248,1 +255,45 @@\n-     * Creates one of more directories.\n+     * Copies the contents of a directory to another directory.\n+     * <p>Similar to the shell command: {@code rsync fromDir\/ toDir\/}.\n+     *\n+     * @param fromDir the directory containing the files to be copied\n+     * @param toDir   the destination to which to copy the files\n+     *\/\n+    public void copyDir(String fromDir, String toDir) {\n+        copyDir(Path.of(fromDir), Path.of(toDir));\n+    }\n+\n+    \/**\n+     * Copies the contents of a directory to another directory.\n+     * The destination direction should not already exist.\n+     * <p>Similar to the shell command: {@code rsync fromDir\/ toDir\/}.\n+     *\n+     * @param fromDir the directory containing the files to be copied\n+     * @param toDir   the destination to which to copy the files\n+     *\/\n+    public void copyDir(Path fromDir, Path toDir) {\n+        try {\n+            if (toDir.getParent() != null) {\n+                Files.createDirectories(toDir.getParent());\n+            }\n+            Files.walkFileTree(fromDir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path fromSubdir, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    Files.copy(fromSubdir, toDir.resolve(fromDir.relativize(fromSubdir)));\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult visitFile(Path fromFile, BasicFileAttributes attrs)\n+                        throws IOException {\n+                    Files.copy(fromFile, toDir.resolve(fromDir.relativize(fromFile)));\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+            throw new Error(\"Could not copy \" + fromDir + \" to \" + toDir + \": \" + e, e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates one or more directories.\n@@ -252,0 +303,1 @@\n+     *\n@@ -259,1 +311,1 @@\n-            Files.createDirectories(Paths.get(p));\n+            Files.createDirectories(Path.of(p));\n@@ -267,0 +319,1 @@\n+     *\n@@ -281,0 +334,1 @@\n+     *\n@@ -292,0 +346,1 @@\n+     *\n@@ -303,0 +358,1 @@\n+     *\n@@ -322,0 +378,1 @@\n+     *\n@@ -329,1 +386,1 @@\n-        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+        Files.walkFileTree(root, new SimpleFileVisitor<>() {\n@@ -332,1 +389,1 @@\n-            private Deque<List<Path>> dirFiles = new LinkedList<>();\n+            private final Deque<List<Path>> dirFiles = new LinkedList<>();\n@@ -335,1 +392,1 @@\n-            public FileVisitResult visitFile(Path file, BasicFileAttributes a) throws IOException {\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes a) {\n@@ -342,1 +399,1 @@\n-            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes a) throws IOException {\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes a) {\n@@ -372,0 +429,1 @@\n+     *\n@@ -373,1 +431,1 @@\n-     * @param ioe the earlier exception, or null\n+     * @param ioe  the earlier exception, or null\n@@ -375,1 +433,1 @@\n-     *  trying to delete the file\n+     * trying to delete the file\n@@ -392,0 +450,1 @@\n+     *\n@@ -404,0 +463,1 @@\n+     *\n@@ -434,0 +494,1 @@\n+     *\n@@ -435,1 +496,1 @@\n-     * @param to where to move the file\n+     * @param to   where to move the file\n@@ -439,1 +500,1 @@\n-        moveFile(Paths.get(from), Paths.get(to));\n+        moveFile(Path.of(from), Path.of(to));\n@@ -448,0 +509,1 @@\n+     *\n@@ -449,1 +511,1 @@\n-     * @param to where to move the file\n+     * @param to   where to move the file\n@@ -464,0 +526,1 @@\n+     *\n@@ -475,0 +538,1 @@\n+     *\n@@ -485,1 +549,2 @@\n-     * @param path the file to be read\n+     *\n+     * @param path     the file to be read\n@@ -491,1 +556,1 @@\n-        return readAllLines(Paths.get(path), encoding);\n+        return readAllLines(Path.of(path), encoding);\n@@ -496,1 +561,2 @@\n-     * @param path the file to be read\n+     *\n+     * @param path     the file to be read\n@@ -512,0 +578,1 @@\n+     *\n@@ -523,0 +590,1 @@\n+     *\n@@ -524,1 +592,1 @@\n-     * @param paths the directories in which to search for files\n+     * @param paths         the directories in which to search for files\n@@ -531,1 +599,1 @@\n-            Files.walkFileTree(p, new SimpleFileVisitor<Path>() {\n+            Files.walkFileTree(p, new SimpleFileVisitor<>() {\n@@ -533,2 +601,1 @@\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n-                        throws IOException {\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n@@ -542,1 +609,1 @@\n-        return files.toArray(new Path[files.size()]);\n+        return files.toArray(new Path[0]);\n@@ -548,1 +615,2 @@\n-     * @param path where to write the file\n+     *\n+     * @param path    where to write the file\n@@ -553,1 +621,1 @@\n-        writeFile(Paths.get(path), content);\n+        writeFile(Path.of(path), content);\n@@ -559,1 +627,2 @@\n-     * @param path where to write the file\n+     *\n+     * @param path    where to write the file\n@@ -583,1 +652,2 @@\n-     * @param dir the base directory\n+     *\n+     * @param dir      the base directory\n@@ -596,1 +666,2 @@\n-     * Returns the path for the binary of a JDK tool within {@link testJDK}.\n+     * Returns the path for the binary of a JDK tool within {@link #testJDK}.\n+     *\n@@ -601,1 +672,1 @@\n-        return Paths.get(testJDK, \"bin\", tool);\n+        return Path.of(testJDK, \"bin\", tool);\n@@ -606,1 +677,2 @@\n-     * @param <T> the type parameter of the {@code Iterable}\n+     *\n+     * @param <T>   the type parameter of the {@code Iterable}\n@@ -627,0 +699,1 @@\n+         *\n@@ -628,1 +701,1 @@\n-         * @param source the source text\n+         * @param source    the source text\n@@ -638,0 +711,1 @@\n+         *\n@@ -648,0 +722,1 @@\n+         *\n@@ -656,0 +731,1 @@\n+         *\n@@ -672,1 +748,1 @@\n-        private static Pattern commentPattern =\n+        private final static Pattern commentPattern =\n@@ -674,1 +750,1 @@\n-        private static Pattern modulePattern =\n+        private final static Pattern modulePattern =\n@@ -676,3 +752,3 @@\n-        private static Pattern packagePattern =\n-                Pattern.compile(\"package\\\\s+(((?:\\\\w+\\\\.)*)(?:\\\\w+))\");\n-        private static Pattern classPattern =\n+        private final static Pattern packagePattern =\n+                Pattern.compile(\"package\\\\s+(((?:\\\\w+\\\\.)*)\\\\w+)\");\n+        private final static Pattern classPattern =\n@@ -692,1 +768,1 @@\n-                sb.append(source.substring(start, matcher.start()));\n+                sb.append(source, start, matcher.start());\n@@ -728,2 +804,1 @@\n-     * @deprecated This is a legacy method for compatibility with ToolBox v1.\n-     *      Use {@link JavaSource#getName JavaSource.getName} instead.\n+     *\n@@ -732,0 +807,2 @@\n+     * @deprecated This is a legacy method for compatibility with ToolBox v1.\n+     * Use {@link JavaSource#getName JavaSource.getName} instead.\n@@ -744,1 +821,2 @@\n-    \/**Validate if a given name is a valid file name\n+    \/**\n+     * Validates if a given name is a valid file name\n@@ -746,0 +824,3 @@\n+     *\n+     * @param name the name\n+     * @throws IllegalArgumentException if the name is a reserved name\n@@ -748,1 +829,1 @@\n-        for (String part : name.split(\"\\\\.|\/|\\\\\\\\\")) {\n+        for (String part : name.split(\"[.\/\\\\\\\\]\")) {\n@@ -756,6 +837,2 @@\n-    \/**\n-     * A memory file manager, for saving generated files in memory.\n-     * The file manager delegates to a separate file manager for listing and\n-     * reading input files.\n-     *\/\n-    public static class MemoryFileManager extends ForwardingJavaFileManager {\n+\n+    public static class MemoryFileManager extends ForwardingJavaFileManager<JavaFileManager> {\n@@ -773,1 +850,1 @@\n-         * Construct a memory file manager which stores output files in memory,\n+         * Constructs a memory file manager which stores output files in memory,\n@@ -781,1 +858,1 @@\n-         * Construct a memory file manager which stores output files in memory,\n+         * Constructs a memory file manager which stores output files in memory,\n@@ -783,0 +860,1 @@\n+         *\n@@ -802,0 +880,1 @@\n+         *\n@@ -814,0 +893,1 @@\n+         *\n@@ -815,1 +895,1 @@\n-         * @param name the name of the file\n+         * @param name     the name of the file\n@@ -826,0 +906,1 @@\n+         *\n@@ -827,1 +908,1 @@\n-         * @param name the name of the file\n+         * @param name     the name of the file\n@@ -841,4 +922,2 @@\n-            Map<String, Content> filesForLocation = files.get(location);\n-            if (filesForLocation == null)\n-                files.put(location, filesForLocation = new HashMap<>());\n-            filesForLocation.put(name, content);\n+            files.computeIfAbsent(location, k -> new HashMap<>())\n+                    .put(name, content);\n@@ -856,1 +935,4 @@\n-             * @param name binary name of the class to be stored in this file object\n+             *\n+             * @param location the location in which to save the file object\n+             * @param name     binary name of the class to be stored in this file object\n+             * @param kind     the kind of file object\n@@ -893,1 +975,1 @@\n-                        String text = ((StringWriter) out).toString();\n+                        String text = out.toString();\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":147,"deletions":65,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        return compiler.contains(\"Tiered Compilers\");\n+        return (compiler != null) && compiler.contains(\"Tiered Compilers\");\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,7 @@\n-    private static void removeFromDisabledAlgs(String prop, List<String> algs) {\n+    \/**\n+     * Removes constraints that contain the specified constraint from the\n+     * specified security property. For example, List.of(\"SHA1\") will remove\n+     * any constraint containing \"SHA1\".\n+     *\/\n+    public static void removeFromDisabledAlgs(String prop,\n+            List<String> constraints) {\n@@ -68,1 +74,2 @@\n-                      .filter(s -> !algs.contains(s))\n+                      .filter(s -> constraints.stream()\n+                          .allMatch(constraint -> !s.contains(constraint)))\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SecurityUtils.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-                s3.sign(p.getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n+                s3.sign(p.toAbsolutePath().getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n@@ -98,0 +98,2 @@\n+        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#x\")));\n+        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#xpointer(id('x'))\")));\n@@ -350,1 +352,1 @@\n-        public Document signEnveloping(Document document) throws Exception {\n+        public Document signEnveloping(Document document, String id, String ref) throws Exception {\n@@ -354,1 +356,1 @@\n-                    buildSignedInfo(FAC.newReference(\"#object\", dm)),\n+                    buildSignedInfo(FAC.newReference(ref, dm)),\n@@ -357,1 +359,1 @@\n-                            \"object\", null, null)),\n+                            id, null, null)),\n@@ -477,1 +479,1 @@\n-            NodeList nodeList = document.getElementsByTagName(\"Signature\");\n+            NodeList nodeList = document.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n","filename":"test\/lib\/jdk\/test\/lib\/security\/XMLUtils.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -597,0 +597,1 @@\n+  public native boolean isDTraceIncluded();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -598,0 +598,1 @@\n+  public native boolean isDTraceIncluded();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@State(Scope.Benchmark)\n+public class InterfacePrivateCalls {\n+    interface I {\n+        private int bar() { return 0; }\n+        default int foo() {\n+            return bar();\n+        }\n+    }\n+\n+    static class C1 implements I {}\n+    static class C2 implements I {}\n+    static class C3 implements I {}\n+\n+    private I[] objs;\n+\n+    @Setup(Level.Trial)\n+    public void setupTrial() {\n+        objs = new I[3];\n+        objs[0] = new C1();\n+        objs[1] = new C2();\n+        objs[2] = new C3();\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Fork(value=1, jvmArgsAppend={\"-XX:TieredStopAtLevel=1\"})\n+    public void invokePrivateInterfaceMethodC1() {\n+        for (int i = 0; i < objs.length; ++i) {\n+            objs[i].foo();\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Fork(value=1)\n+    public void invokePrivateInterfaceMethodC2() {\n+        for (int i = 0; i < objs.length; ++i) {\n+            objs[i].foo();\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/InterfacePrivateCalls.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}