{"files":[{"patch":"@@ -56,1 +56,1 @@\n-#include \"services\/memTracker.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n@@ -1988,11 +1988,0 @@\n-  if (PrintNMTStatistics) {\n-#if INCLUDE_NMT\n-    if (MemTracker::tracking_level() == NMT_off) {\n-#endif \/\/ INCLUDE_NMT\n-      warning(\"PrintNMTStatistics is disabled, because native memory tracking is not enabled\");\n-      PrintNMTStatistics = false;\n-#if INCLUDE_NMT\n-    }\n-#endif\n-  }\n-\n@@ -3721,23 +3710,0 @@\n-    if (match_option(option, \"-XX:NativeMemoryTracking\", &tail)) {\n-#if INCLUDE_NMT\n-      \/\/ The launcher did not setup nmt environment variable properly.\n-      if (!MemTracker::check_launcher_nmt_support(tail)) {\n-        warning(\"Native Memory Tracking did not setup properly, using wrong launcher?\");\n-      }\n-\n-      \/\/ Verify if nmt option is valid.\n-      if (MemTracker::verify_nmt_option()) {\n-        \/\/ Late initialization, still in single-threaded mode.\n-        if (MemTracker::tracking_level() >= NMT_summary) {\n-          MemTracker::init();\n-        }\n-      } else {\n-        vm_exit_during_initialization(\"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n-      }\n-      continue;\n-#else\n-      jio_fprintf(defaultStream::error_stream(),\n-        \"Native Memory Tracking is not supported in this VM\\n\");\n-      return JNI_ERR;\n-#endif\n-    }\n@@ -3995,0 +3961,20 @@\n+#if INCLUDE_NMT\n+  \/\/ Verify NMT arguments\n+  const NMT_TrackingLevel lvl = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+  if (lvl == NMT_unknown) {\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n+    return JNI_ERR;\n+  }\n+  if (PrintNMTStatistics && lvl == NMT_off) {\n+    warning(\"PrintNMTStatistics is disabled, because native memory tracking is not enabled\");\n+    FLAG_SET_DEFAULT(PrintNMTStatistics, false);\n+  }\n+#else\n+  if (!FLAG_IS_DEFAULT(NativeMemoryTracking) || PrintNMTStatistics) {\n+    warning(\"Native Memory Tracking is not supported in this VM\");\n+    FLAG_SET_DEFAULT(NativeMemoryTracking, \"off\");\n+    FLAG_SET_DEFAULT(PrintNMTStatistics, false);\n+  }\n+#endif \/\/ INCLUDE_NMT\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":21,"deletions":35,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"services\/nmtPreInit.hpp\"\n@@ -684,0 +685,9 @@\n+#if INCLUDE_NMT\n+  {\n+    void* rc = NULL;\n+    if (NMTPreInit::handle_malloc(&rc, size)) {\n+      return rc;\n+    }\n+  }\n+#endif\n+\n@@ -743,0 +753,9 @@\n+#if INCLUDE_NMT\n+  {\n+    void* rc = NULL;\n+    if (NMTPreInit::handle_realloc(&rc, memblock, size)) {\n+      return rc;\n+    }\n+  }\n+#endif\n+\n@@ -793,0 +812,7 @@\n+\n+#if INCLUDE_NMT\n+  if (NMTPreInit::handle_free(memblock)) {\n+    return;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2772,0 +2772,5 @@\n+#if INCLUDE_NMT\n+  \/\/ Initialize NMT right after argument parsing to keep the pre-NMT-init window small.\n+  MemTracker::initialize();\n+#endif \/\/ INCLUDE_NMT\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -35,0 +38,2 @@\n+#include \"services\/nmtCommon.hpp\"\n+#include \"services\/nmtPreInit.hpp\"\n@@ -48,1 +53,0 @@\n-bool MemTracker::_is_nmt_env_valid = true;\n@@ -50,1 +54,8 @@\n-static const size_t buffer_size = 64;\n+void MemTracker::initialize() {\n+  bool rc = true;\n+  assert(_tracking_level == NMT_unknown, \"only call once\");\n+\n+  NMT_TrackingLevel level = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+  \/\/ Should have been validated before in arguments.cpp\n+  assert(level == NMT_off || level == NMT_summary || level == NMT_detail,\n+         \"Invalid setting for NativeMemoryTracking (%s)\", NativeMemoryTracking);\n@@ -52,1 +63,0 @@\n-NMT_TrackingLevel MemTracker::init_tracking_level() {\n@@ -57,37 +67,7 @@\n-  char nmt_env_variable[buffer_size];\n-  jio_snprintf(nmt_env_variable, sizeof(nmt_env_variable), \"NMT_LEVEL_%d\", os::current_process_id());\n-  const char* nmt_env_value;\n-#ifdef _WINDOWS\n-  \/\/ Read the NMT environment variable from the PEB instead of the CRT\n-  char value[buffer_size];\n-  nmt_env_value = GetEnvironmentVariable(nmt_env_variable, value, (DWORD)sizeof(value)) != 0 ? value : NULL;\n-#else\n-  nmt_env_value = ::getenv(nmt_env_variable);\n-#endif\n-  NMT_TrackingLevel level = NMT_off;\n-  if (nmt_env_value != NULL) {\n-    if (strcmp(nmt_env_value, \"summary\") == 0) {\n-      level = NMT_summary;\n-    } else if (strcmp(nmt_env_value, \"detail\") == 0) {\n-      level = NMT_detail;\n-    } else if (strcmp(nmt_env_value, \"off\") != 0) {\n-      \/\/ The value of the environment variable is invalid\n-      _is_nmt_env_valid = false;\n-    }\n-    \/\/ Remove the environment variable to avoid leaking to child processes\n-    os::unsetenv(nmt_env_variable);\n-  }\n-\n-  if (!MallocTracker::initialize(level) ||\n-      !VirtualMemoryTracker::initialize(level)) {\n-    level = NMT_off;\n-  }\n-  return level;\n-}\n-\n-void MemTracker::init() {\n-  NMT_TrackingLevel level = tracking_level();\n-  if (level >= NMT_summary) {\n-    if (!VirtualMemoryTracker::late_initialize(level) ||\n-        !ThreadStackTracker::late_initialize(level)) {\n-      shutdown();\n+  if (level > NMT_off) {\n+    if (!MallocTracker::initialize(level) ||\n+        !VirtualMemoryTracker::initialize(level) ||\n+        !ThreadStackTracker::initialize(level)) {\n+      assert(false, \"NMT initialization failed\");\n+      level = NMT_off;\n+      log_warning(nmt)(\"NMT initialization failed. NMT disabled.\");\n@@ -97,1 +77,0 @@\n-}\n@@ -99,16 +78,1 @@\n-bool MemTracker::check_launcher_nmt_support(const char* value) {\n-  if (strcmp(value, \"=detail\") == 0) {\n-    if (MemTracker::tracking_level() != NMT_detail) {\n-      return false;\n-    }\n-  } else if (strcmp(value, \"=summary\") == 0) {\n-    if (MemTracker::tracking_level() != NMT_summary) {\n-      return false;\n-    }\n-  } else if (strcmp(value, \"=off\") == 0) {\n-    if (MemTracker::tracking_level() != NMT_off) {\n-      return false;\n-    }\n-  } else {\n-    _is_nmt_env_valid = false;\n-  }\n+  NMTPreInit::pre_to_post();\n@@ -116,2 +80,1 @@\n-  return true;\n-}\n+  _tracking_level = _cmdline_tracking_level = level;\n@@ -119,2 +82,9 @@\n-bool MemTracker::verify_nmt_option() {\n-  return _is_nmt_env_valid;\n+  \/\/ Log state right after NMT initialization\n+  if (log_is_enabled(Info, nmt)) {\n+    LogTarget(Info, nmt) lt;\n+    LogStream ls(lt);\n+    ls.print_cr(\"NMT initialized: %s\", NMTUtil::tracking_level_to_string(_tracking_level));\n+    ls.print_cr(\"Preinit state: \");\n+    NMTPreInit::print_state(&ls);\n+    ls.cr();\n+  }\n@@ -177,0 +147,2 @@\n+    output->print(\"Preinit state:\");\n+    NMTPreInit::print_state(output);\n@@ -217,0 +189,1 @@\n+  out->print_cr(\"State: %s\", NMTUtil::tracking_level_to_string(_tracking_level));\n@@ -222,0 +195,4 @@\n+  out->cr();\n+  out->print_cr(\"Preinit state:\");\n+  NMTPreInit::print_state(out);\n+  out->cr();\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":38,"deletions":61,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,5 @@\n+  \/\/ Helper; asserts that we are in post-NMT-init phase\n+  static void assert_post_init() {\n+    assert(is_initialized(), \"NMT not yet initialized.\");\n+  }\n+\n@@ -119,0 +124,11 @@\n+\n+  \/\/ Initializes NMT to whatever -XX:NativeMemoryTracking says.\n+  \/\/  - Can only be called once.\n+  \/\/  - NativeMemoryTracking must be validated beforehand.\n+  static void initialize();\n+\n+  \/\/ Returns true if NMT had been initialized.\n+  static bool is_initialized()  {\n+    return _tracking_level != NMT_unknown;\n+  }\n+\n@@ -120,6 +136,0 @@\n-    if (_tracking_level == NMT_unknown) {\n-      \/\/ No fencing is needed here, since JVM is in single-threaded\n-      \/\/ mode.\n-      _tracking_level = init_tracking_level();\n-      _cmdline_tracking_level = _tracking_level;\n-    }\n@@ -129,6 +139,4 @@\n-  \/\/ A late initialization, for the stuff(s) can not be\n-  \/\/ done in init_tracking_level(), which can NOT malloc\n-  \/\/ any memory.\n-  static void init();\n-\n-  \/\/ Shutdown native memory tracking\n+  \/\/ Shutdown native memory tracking.\n+  \/\/ This transitions the tracking level:\n+  \/\/  summary -> minimal\n+  \/\/  detail  -> minimal\n@@ -137,17 +145,0 @@\n-  \/\/ Verify native memory tracking command line option.\n-  \/\/ This check allows JVM to detect if compatible launcher\n-  \/\/ is used.\n-  \/\/ If an incompatible launcher is used, NMT may not be\n-  \/\/ able to start, even it is enabled by command line option.\n-  \/\/ A warning message should be given if it is encountered.\n-  static bool check_launcher_nmt_support(const char* value);\n-\n-  \/\/ This method checks native memory tracking environment\n-  \/\/ variable value passed by launcher.\n-  \/\/ Launcher only obligated to pass native memory tracking\n-  \/\/ option value, but not obligated to validate the value,\n-  \/\/ and launcher has option to discard native memory tracking\n-  \/\/ option from the command line once it sets up the environment\n-  \/\/ variable, so NMT has to catch the bad value here.\n-  static bool verify_nmt_option();\n-\n@@ -210,0 +201,3 @@\n+  \/\/ Note: virtual memory operations should only ever be called after NMT initialization\n+  \/\/  (we do not do any reservations before that).\n+\n@@ -212,0 +206,1 @@\n+    assert_post_init();\n@@ -223,0 +218,1 @@\n+    assert_post_init();\n@@ -234,0 +230,1 @@\n+    assert_post_init();\n@@ -249,0 +246,1 @@\n+    assert_post_init();\n@@ -259,0 +257,1 @@\n+    assert_post_init();\n@@ -268,0 +267,1 @@\n+    assert_post_init();\n@@ -275,0 +275,1 @@\n+    assert_post_init();\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -63,0 +63,24 @@\n+const char* NMTUtil::tracking_level_to_string(NMT_TrackingLevel lvl) {\n+  switch(lvl) {\n+    case NMT_unknown: return \"unknown\"; break;\n+    case NMT_off:     return \"off\"; break;\n+    case NMT_minimal: return \"minimal\"; break;\n+    case NMT_summary: return \"summary\"; break;\n+    case NMT_detail:  return \"detail\"; break;\n+    default:          return \"invalid\"; break;\n+  }\n+}\n+\n+\/\/ Returns the parsed level; NMT_unknown if string is invalid\n+NMT_TrackingLevel NMTUtil::parse_tracking_level(const char* s) {\n+  if (s != NULL) {\n+    if (strcmp(s, \"summary\") == 0) {\n+      return NMT_summary;\n+    } else if (strcmp(s, \"detail\") == 0) {\n+      return NMT_detail;\n+    } else if (strcmp(s, \"off\") == 0) {\n+      return NMT_off;\n+    }\n+  }\n+  return NMT_unknown;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtCommon.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,0 +35,40 @@\n+\/\/\n+\/\/ The meaning of the different states:\n+\/\/\n+\/\/ \"unknown\": pre-init phase (before parsing NMT arguments)\n+\/\/\n+\/\/ \"off\":     after initialization - NMT confirmed off.\n+\/\/             - nothing is tracked\n+\/\/             - no malloc headers are used\n+\/\/\n+\/\/ \"minimal\": after shutdown - NMT had been on at some point but has been switched off\n+\/\/             - nothing is tracked\n+\/\/             - malloc headers are allocated but not initialized not used\n+\/\/\n+\/\/ \"summary\": after initialization with NativeMemoryTracking=summary - NMT in summary mode\n+\/\/             - category summaries per tag are tracked\n+\/\/             - thread stacks are tracked\n+\/\/             - malloc headers are used\n+\/\/             - malloc call site table is allocated and used\n+\/\/\n+\/\/ \"detail\":  after initialization with NativeMemoryTracking=detail - NMT in detail mode\n+\/\/             - category summaries per tag are tracked\n+\/\/             - malloc details per call site are tracked\n+\/\/             - virtual memory mapping info is tracked\n+\/\/             - thread stacks are tracked\n+\/\/             - malloc headers are used\n+\/\/             - malloc call site table is allocated and used\n+\/\/\n+\/\/ Valid state transitions:\n+\/\/\n+\/\/ unknown ----> off\n+\/\/          |\n+\/\/          |--> summary --\n+\/\/          |              |\n+\/\/          |--> detail  --+--> minimal\n+\/\/\n+\n+\n+\/\/ Please keep relation of numerical values!\n+\/\/ unknown < off < minimal < summary < detail\n+\/\/\n@@ -36,5 +76,5 @@\n-  NMT_unknown = 0xFF,\n-  NMT_off     = 0x00,\n-  NMT_minimal = 0x01,\n-  NMT_summary = 0x02,\n-  NMT_detail  = 0x03\n+  NMT_unknown = 0,\n+  NMT_off     = 1,\n+  NMT_minimal = 2,\n+  NMT_summary = 3,\n+  NMT_detail  = 4\n@@ -86,0 +126,8 @@\n+\n+  \/\/ Parses the tracking level from a string. Returns NMT_unknown if\n+  \/\/ string is not a valid level.\n+  static NMT_TrackingLevel parse_tracking_level(const char* s);\n+\n+  \/\/ Returns textual representation of a tracking level.\n+  static const char* tracking_level_to_string(NMT_TrackingLevel level);\n+\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":53,"deletions":5,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/nmtPreInit.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#if INCLUDE_NMT\n+\n+\/\/ Obviously we cannot use os::malloc for any dynamic allocation during pre-NMT-init, so we must use\n+\/\/ raw malloc; to make this very clear, wrap them.\n+static void* raw_malloc(size_t s)               { return ::malloc(s); }\n+static void* raw_realloc(void* old, size_t s)   { return ::realloc(old, s); }\n+static void  raw_free(void* p)                  { ::free(p); }\n+\n+\/\/ We must ensure that the start of the payload area of the nmt lookup table nodes is malloc-aligned\n+static const size_t malloc_alignment = 2 * sizeof(void*); \/\/ could we use max_align_t?\n+STATIC_ASSERT(is_aligned(sizeof(NMTPreInitAllocation), malloc_alignment));\n+\n+\/\/ --------- NMTPreInitAllocation --------------\n+\n+NMTPreInitAllocation* NMTPreInitAllocation::do_alloc(size_t payload_size) {\n+  const size_t outer_size = sizeof(NMTPreInitAllocation) + payload_size;\n+  void* p = raw_malloc(outer_size);\n+  NMTPreInitAllocation* a = new(p) NMTPreInitAllocation(payload_size);\n+  return a;\n+}\n+\n+NMTPreInitAllocation* NMTPreInitAllocation::do_reallocate(NMTPreInitAllocation* old, size_t new_payload_size) {\n+  assert(old->next == NULL, \"unhang from map first\");\n+  \/\/ We just reallocate the old block, header and all.\n+  const size_t new_outer_size = sizeof(NMTPreInitAllocation) + new_payload_size;\n+  void* p = raw_realloc(old, new_outer_size);\n+  \/\/ re-stamp header with new size\n+  NMTPreInitAllocation* a = new(p) NMTPreInitAllocation(new_payload_size);\n+  return a;\n+}\n+\n+void NMTPreInitAllocation::do_free(NMTPreInitAllocation* p) {\n+  assert(p->next == NULL, \"unhang from map first\");\n+  raw_free(p);\n+}\n+\n+\/\/ --------- NMTPreInitAllocationTable --------------\n+\n+NMTPreInitAllocationTable::NMTPreInitAllocationTable() {\n+  ::memset(_entries, 0, sizeof(_entries));\n+}\n+\n+\/\/ print a string describing the current state\n+void NMTPreInitAllocationTable::print_state(outputStream* st) const {\n+  \/\/ Collect some statistics and print them\n+  int num_entries = 0;\n+  int num_primary_entries = 0;\n+  int longest_chain = 0;\n+  size_t sum_bytes = 0;\n+  for (int i = 0; i < table_size; i++) {\n+    int chain_len = 0;\n+    for (NMTPreInitAllocation* a = _entries[i]; a != NULL; a = a->next) {\n+      chain_len++;\n+      sum_bytes += a->size;\n+    }\n+    if (chain_len > 0) {\n+      num_primary_entries++;\n+    }\n+    num_entries += chain_len;\n+    longest_chain = MAX2(chain_len, longest_chain);\n+  }\n+  st->print(\"entries: %d (primary: %d, empties: %d), sum bytes: \" SIZE_FORMAT\n+            \", longest chain length: %d\",\n+            num_entries, num_primary_entries, table_size - num_primary_entries,\n+            sum_bytes, longest_chain);\n+}\n+\n+#ifdef ASSERT\n+void NMTPreInitAllocationTable::print_map(outputStream* st) const {\n+  for (int i = 0; i < table_size; i++) {\n+    st->print(\"[%d]: \", i);\n+    for (NMTPreInitAllocation* a = _entries[i]; a != NULL; a = a->next) {\n+      st->print( PTR_FORMAT \"(\" SIZE_FORMAT \") \", p2i(a->payload()), a->size);\n+    }\n+    st->cr();\n+  }\n+}\n+\n+void NMTPreInitAllocationTable::verify() const {\n+  \/\/ This verifies the buildup of the lookup table, including the load and the chain lengths.\n+  \/\/ We should see chain lens of 0-1 under normal conditions. Under artificial conditions\n+  \/\/ (20000 VM args) we should see maybe 6-7. From a certain length on we can be sure something\n+  \/\/ is broken.\n+  const int longest_acceptable_chain_len = 30;\n+  int num_chains_too_long = 0;\n+  for (index_t i = 0; i < table_size; i++) {\n+    int len = 0;\n+    for (const NMTPreInitAllocation* a = _entries[i]; a != NULL; a = a->next) {\n+      index_t i2 = index_for_key(a->payload());\n+      assert(i2 == i, \"wrong hash\");\n+      assert(a->size > 0, \"wrong size\");\n+      len++;\n+      \/\/ very paranoid: search for dups\n+      bool found = false;\n+      for (const NMTPreInitAllocation* a2 = _entries[i]; a2 != NULL; a2 = a2->next) {\n+        if (a == a2) {\n+          assert(!found, \"dup!\");\n+          found = true;\n+        }\n+      }\n+    }\n+    if (len > longest_acceptable_chain_len) {\n+      num_chains_too_long++;\n+    }\n+  }\n+  if (num_chains_too_long > 0) {\n+    assert(false, \"NMT preinit lookup table degenerated (%d\/%d chains longer than %d)\",\n+                  num_chains_too_long, table_size, longest_acceptable_chain_len);\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+\/\/ --------- NMTPreinit --------------\n+\n+NMTPreInitAllocationTable* NMTPreInit::_table = NULL;\n+bool NMTPreInit::_nmt_was_initialized = false;\n+\n+\/\/ Some statistics\n+unsigned NMTPreInit::_num_mallocs_pre = 0;\n+unsigned NMTPreInit::_num_reallocs_pre = 0;\n+unsigned NMTPreInit::_num_frees_pre = 0;\n+\n+void NMTPreInit::create_table() {\n+  assert(_table == NULL, \"just once\");\n+  void* p = raw_malloc(sizeof(NMTPreInitAllocationTable));\n+  _table = new(p) NMTPreInitAllocationTable();\n+}\n+\n+\/\/ Allocate with os::malloc (hidden to prevent having to include os.hpp)\n+void* NMTPreInit::do_os_malloc(size_t size) {\n+  return os::malloc(size, mtNMT);\n+}\n+\n+\/\/ Switches from NMT pre-init state to NMT post-init state;\n+\/\/  in post-init, no modifications to the lookup table are possible.\n+void NMTPreInit::pre_to_post() {\n+  assert(_nmt_was_initialized == false, \"just once\");\n+  _nmt_was_initialized = true;\n+  DEBUG_ONLY(verify();)\n+}\n+\n+#ifdef ASSERT\n+void NMTPreInit::verify() {\n+  if (_table != NULL) {\n+    _table->verify();\n+  }\n+  assert(_num_reallocs_pre <= _num_mallocs_pre &&\n+         _num_frees_pre <= _num_mallocs_pre, \"stats are off\");\n+}\n+#endif \/\/ ASSERT\n+\n+void NMTPreInit::print_state(outputStream* st) {\n+  if (_table != NULL) {\n+    _table->print_state(st);\n+    st->cr();\n+  }\n+  st->print_cr(\"pre-init mallocs: %u, pre-init reallocs: %u, pre-init frees: %u\",\n+               _num_mallocs_pre, _num_reallocs_pre, _num_frees_pre);\n+}\n+\n+#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.cpp","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_NMT_PREINIT_HPP\n+#define SHARE_SERVICES_NMT_PREINIT_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#ifdef ASSERT\n+#include \"runtime\/atomic.hpp\"\n+#endif\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#if INCLUDE_NMT\n+\n+class outputStream;\n+\n+\/\/ NMTPreInit is the solution to a specific problem:\n+\/\/\n+\/\/ NMT tracks C-heap allocations (os::malloc and friends). Those can happen at all VM life stages,\n+\/\/ including very early during the dynamic C++ initialization of the hotspot, and in CreateJavaVM\n+\/\/ before argument parsing.\n+\/\/\n+\/\/ However, before the VM parses NMT arguments, we do not know whether NMT is enabled or not. Can we\n+\/\/ just ignore early allocations? If the only problem were statistical correctness, sure: footprint-wise\n+\/\/ they are not really relevant.\n+\/\/\n+\/\/ But there is one big problem: NMT uses malloc headers to keep meta information of malloced blocks.\n+\/\/ We have to consider those in os::free() when calling free(3).\n+\/\/\n+\/\/ So:\n+\/\/ 1) NMT off:\n+\/\/   a) pre-NMT-init allocations have no header\n+\/\/   b) post-NMT-init allocations have no header\n+\/\/ 2) NMT on:\n+\/\/   a) pre-NMT-init allocations have no header\n+\/\/   b) post-NMT-init allocations do have a header\n+\/\/\n+\/\/ The problem is that inside os::free(p), we only get an opaque void* p; we do not know if p had been\n+\/\/ allocated in (a) or (b) phase. Therefore, we do not know if p is preceded by an NMT header which we\n+\/\/ would need to subtract from the pointer before calling free(3). There is no safe way to \"guess\" here\n+\/\/ without risking C-heap corruption.\n+\/\/\n+\/\/ To solve this, we need a way to quickly determine, at os::free(p), whether p was a pre-NMT-init\n+\/\/ allocation. There are several ways to do this, see discussion under JDK-8256844.\n+\/\/\n+\/\/ One of the easiest and most elegant ways is to store early allocation pointers in a lookup table.\n+\/\/ This is what NMTPreInit does.\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ VM initialization wrt NMT:\n+\/\/\n+\/\/---------------------------------------------------------------\n+\/\/-> launcher dlopen's libjvm                           ^\n+\/\/   -> dynamic C++ initialization                      |\n+\/\/           of libjvm                                  |\n+\/\/                                                      |\n+\/\/-> launcher starts new thread (maybe)          NMT pre-init phase : store allocated pointers in lookup table\n+\/\/                                                      |\n+\/\/-> launcher invokes CreateJavaVM                      |\n+\/\/   -> VM initialization before arg parsing            |\n+\/\/   -> VM argument parsing                             v\n+\/\/   -> NMT initialization  -------------------------------------\n+\/\/                                                      ^\n+\/\/   ...                                                |\n+\/\/   -> VM life...                               NMT post-init phase : lookup table is read-only; use it in os::free() and os::realloc().\n+\/\/   ...                                                |\n+\/\/                                                      v\n+\/\/----------------------------------------------------------------\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Notes:\n+\/\/ - The VM will malloc() and realloc() several thousand times before NMT initialization.\n+\/\/   Starting with a lot of arguments increases this number since argument parsing strdups\n+\/\/   around a lot.\n+\/\/ - However, *surviving* allocations (allocations not freed immediately) are much rarer:\n+\/\/   typically only about 300-500. Again, mainly depending on the number of VM args.\n+\/\/ - There are a few cases of pre-to-post-init reallocs where pre-init allocations get\n+\/\/   reallocated after NMT initialization. Those we need to handle with special care (see\n+\/\/   NMTPreInit::handle_realloc()). Because of them we need to store allocation size with\n+\/\/   every pre-init allocation.\n+\n+\/\/ For the lookup table, design considerations are:\n+\/\/   - lookup speed is paramount since lookup is done for every os::free() call.\n+\/\/   - insert\/delete speed only matters for VM startup - after NMT initialization the lookup\n+\/\/     table is readonly\n+\/\/   - memory consumption of the lookup table matters since we always pay for it, NMT on or off.\n+\/\/   - Obviously, nothing here can use *os::malloc*. Any dynamic allocations - if they cannot\n+\/\/     be avoided - should use raw malloc(3).\n+\/\/\n+\/\/ We use a basic open hashmap, dimensioned generously - hash collisions should be very rare.\n+\/\/   The table is customized for holding malloced pointers. One main point of this map is that we do\n+\/\/   not allocate memory for the nodes themselves. Instead we piggy-back on the user allocation:\n+\/\/   the hashmap entry structure precedes, as a header, the malloced block. That way we avoid extra\n+\/\/   allocations just to hold the map nodes. This keeps runtime\/memory overhead as small as possible.\n+\n+struct NMTPreInitAllocation {\n+  NMTPreInitAllocation* next;\n+  const size_t size; \/\/ (inner) payload size without header\n+  \/\/ <-- USER ALLOCATION (PAYLOAD) STARTS HERE -->\n+\n+  NMTPreInitAllocation(size_t size) : next(NULL), size(size) {};\n+\n+  \/\/ Returns start of the user data area\n+  void* payload()             { return this + 1; }\n+  const void* payload() const { return this + 1; }\n+\n+  \/\/ These functions do raw-malloc\/realloc\/free a C-heap block of given payload size,\n+  \/\/  preceded with a NMTPreInitAllocation header.\n+  static NMTPreInitAllocation* do_alloc(size_t payload_size);\n+  static NMTPreInitAllocation* do_reallocate(NMTPreInitAllocation* old, size_t new_payload_size);\n+  static void do_free(NMTPreInitAllocation* p);\n+};\n+\n+class NMTPreInitAllocationTable {\n+\n+  \/\/ Table_size: keep table size a prime and the hash function simple; this\n+  \/\/  seems to give a good distribution for malloced pointers on all our libc variants.\n+  \/\/ 8000ish is really plenty: normal VM runs have ~500 pre-init allocations to hold,\n+  \/\/  VMs with insanely long command lines maybe ~700-1000. Which gives us an expected\n+  \/\/  load factor of ~.1. Hash collisions should be very rare.\n+  \/\/ ~8000 entries cost us ~64K for this table (64-bit), which is acceptable.\n+  static const int table_size = 7919;\n+\n+  NMTPreInitAllocation* _entries[table_size];\n+\n+  typedef int index_t;\n+  const index_t invalid_index = -1;\n+\n+  static unsigned calculate_hash(const void* p) {\n+    uintptr_t tmp = p2i(p);\n+    unsigned hash = (unsigned)tmp\n+                     LP64_ONLY( ^ (unsigned)(tmp >> 32));\n+    return hash;\n+  }\n+\n+  static index_t index_for_key(const void* p) {\n+    const unsigned hash = calculate_hash(p);\n+    return hash % table_size;\n+  }\n+\n+  const NMTPreInitAllocation* const * find_entry(const void* p) const {\n+    return const_cast<NMTPreInitAllocationTable*>(this)->find_entry(p);\n+  }\n+\n+  NMTPreInitAllocation** find_entry(const void* p) {\n+    const unsigned index = index_for_key(p);\n+    NMTPreInitAllocation** aa = (&(_entries[index]));\n+    while ((*aa) != NULL && (*aa)->payload() != p) {\n+      aa = &((*aa)->next);\n+    }\n+    assert((*aa) == NULL || p == (*aa)->payload(),\n+           \"retrieve mismatch \" PTR_FORMAT \" vs \" PTR_FORMAT \".\",\n+           p2i(p), p2i((*aa)->payload()));\n+    return aa;\n+  }\n+\n+public:\n+\n+  NMTPreInitAllocationTable();\n+\n+  \/\/ Adds an entry to the table\n+  void add(NMTPreInitAllocation* a) {\n+    void* payload = a->payload();\n+    const unsigned index = index_for_key(payload);\n+    assert(a->next == NULL, \"entry already in table?\");\n+    a->next = _entries[index]; \/\/ add to front\n+    _entries[index] = a;        \/\/   of list\n+    assert(find(payload) == a, \"add: reverse lookup error?\");\n+  }\n+\n+  \/\/ Find - but does not remove - an entry in this map.\n+  \/\/ Returns NULL if not found.\n+  const NMTPreInitAllocation* find(const void* p) const {\n+    return *(find_entry(p));\n+  }\n+\n+  \/\/ Find and removes an entry from the table. Asserts if not found.\n+  NMTPreInitAllocation* find_and_remove(void* p) {\n+    NMTPreInitAllocation** aa = find_entry(p);\n+    assert((*aa) != NULL, \"Entry not found: \" PTR_FORMAT, p2i(p));\n+    NMTPreInitAllocation* a = (*aa);\n+    (*aa) = (*aa)->next;         \/\/ remove from its list\n+    DEBUG_ONLY(a->next = NULL;)  \/\/ mark as removed\n+    return a;\n+  }\n+\n+  void print_state(outputStream* st) const;\n+  DEBUG_ONLY(void print_map(outputStream* st) const;)\n+  DEBUG_ONLY(void verify() const;)\n+};\n+\n+\/\/ NMTPreInit is the outside interface to all of NMT preinit handling.\n+class NMTPreInit : public AllStatic {\n+\n+  static NMTPreInitAllocationTable* _table;\n+  static bool _nmt_was_initialized;\n+\n+  \/\/ Some statistics\n+  static unsigned _num_mallocs_pre;           \/\/ Number of pre-init mallocs\n+  static unsigned _num_reallocs_pre;          \/\/ Number of pre-init reallocs\n+  static unsigned _num_frees_pre;             \/\/ Number of pre-init frees\n+\n+  static void create_table();\n+\n+  static void add_to_map(NMTPreInitAllocation* a) {\n+    assert(!_nmt_was_initialized, \"lookup map cannot be modified after NMT initialization\");\n+    \/\/ Only on add, we create the table on demand. Only needed on add, since everything should start\n+    \/\/ with a call to os::malloc().\n+    if (_table == NULL) {\n+      create_table();\n+    }\n+    return _table->add(a);\n+  }\n+\n+  static const NMTPreInitAllocation* find_in_map(void* p) {\n+    assert(_table != NULL, \"stray allocation?\");\n+    return _table->find(p);\n+  }\n+\n+  static NMTPreInitAllocation* find_and_remove_in_map(void* p) {\n+    assert(!_nmt_was_initialized, \"lookup map cannot be modified after NMT initialization\");\n+    assert(_table != NULL, \"stray allocation?\");\n+    return _table->find_and_remove(p);\n+  }\n+\n+  \/\/ Just a wrapper for os::malloc to avoid including os.hpp here.\n+  static void* do_os_malloc(size_t size);\n+\n+public:\n+\n+  \/\/ Switches from NMT pre-init state to NMT post-init state;\n+  \/\/  in post-init, no modifications to the lookup table are possible.\n+  static void pre_to_post();\n+\n+  \/\/ Returns true if we are still in pre-init phase, false if post-init\n+  static bool in_preinit_phase()  { return _nmt_was_initialized == false; }\n+\n+  \/\/ Called from os::malloc.\n+  \/\/ Returns true if allocation was handled here; in that case,\n+  \/\/ *rc contains the return address.\n+  static bool handle_malloc(void** rc, size_t size) {\n+    size = MAX2((size_t)1, size);         \/\/ malloc(0)\n+    if (!_nmt_was_initialized) {\n+      \/\/ pre-NMT-init:\n+      \/\/ Allocate entry and add address to lookup table\n+      NMTPreInitAllocation* a = NMTPreInitAllocation::do_alloc(size);\n+      add_to_map(a);\n+      (*rc) = a->payload();\n+      _num_mallocs_pre++;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Called from os::realloc.\n+  \/\/ Returns true if reallocation was handled here; in that case,\n+  \/\/ *rc contains the return address.\n+  static bool handle_realloc(void** rc, void* old_p, size_t new_size) {\n+    if (old_p == NULL) {                  \/\/ realloc(NULL, n)\n+      return handle_malloc(rc, new_size);\n+    }\n+    new_size = MAX2((size_t)1, new_size); \/\/ realloc(.., 0)\n+    if (!_nmt_was_initialized) {\n+      \/\/ pre-NMT-init:\n+      \/\/ - the address must already be in the lookup table\n+      \/\/ - find the old entry, remove from table, reallocate, add to table\n+      NMTPreInitAllocation* a = find_and_remove_in_map(old_p);\n+      a = NMTPreInitAllocation::do_reallocate(a, new_size);\n+      add_to_map(a);\n+      (*rc) = a->payload();\n+      _num_reallocs_pre++;\n+      return true;\n+    } else {\n+      \/\/ post-NMT-init:\n+      \/\/ If the old block was allocated during pre-NMT-init, we must relocate it: the\n+      \/\/  new block must be allocated with \"normal\" os::malloc.\n+      \/\/ We do this by:\n+      \/\/ - look up (but not remove! lu table is read-only here.) the old entry\n+      \/\/ - allocate new memory via os::malloc()\n+      \/\/ - manually copy the old content over\n+      \/\/ - return the new memory\n+      \/\/ - The lu table is readonly so we keep the old address in the table. And we leave\n+      \/\/   the old block allocated too, to prevent the libc from returning the same address\n+      \/\/   and confusing us.\n+      const NMTPreInitAllocation* a = find_in_map(old_p);\n+      if (a != NULL) { \/\/ this was originally a pre-init allocation\n+        void* p_new = do_os_malloc(new_size);\n+        ::memcpy(p_new, a->payload(), MIN2(a->size, new_size));\n+        (*rc) = p_new;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Called from os::free.\n+  \/\/ Returns true if free was handled here.\n+  static bool handle_free(void* p) {\n+    if (p == NULL) { \/\/ free(NULL)\n+      return true;\n+    }\n+    if (!_nmt_was_initialized) {\n+      \/\/ pre-NMT-init:\n+      \/\/ - the allocation must be in the hash map, since all allocations went through\n+      \/\/   NMTPreInit::handle_malloc()\n+      \/\/ - find the old entry, unhang from map, free it\n+      NMTPreInitAllocation* a = find_and_remove_in_map(p);\n+      NMTPreInitAllocation::do_free(a);\n+      _num_frees_pre++;\n+      return true;\n+    } else {\n+      \/\/ post-NMT-init:\n+      \/\/ - look up (but not remove! lu table is read-only here.) the entry\n+      \/\/ - if found, we do nothing: the lu table is readonly, so we keep the old address\n+      \/\/   in the table. We leave the block allocated to prevent the libc from returning\n+      \/\/   the same address and confusing us.\n+      \/\/ - if not found, we let regular os::free() handle this pointer\n+      if (find_in_map(p) != NULL) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  static void print_state(outputStream* st);\n+  static void print_map(outputStream* st);\n+  DEBUG_ONLY(static void verify();)\n+};\n+\n+#endif \/\/ INCLUDE_NMT\n+\n+#endif \/\/ SHARE_SERVICES_NMT_PREINIT_HPP\n+\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.hpp","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-bool ThreadStackTracker::late_initialize(NMT_TrackingLevel level) {\n+bool ThreadStackTracker::initialize(NMT_TrackingLevel level) {\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,2 +74,1 @@\n-  \/\/ Late phase initialization\n-  static bool late_initialize(NMT_TrackingLevel level);\n+  static bool initialize(NMT_TrackingLevel level);\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -323,0 +323,1 @@\n+  assert(_reserved_regions == NULL, \"only call once\");\n@@ -325,6 +326,0 @@\n-  }\n-  return true;\n-}\n-\n-bool VirtualMemoryTracker::late_initialize(NMT_TrackingLevel level) {\n-  if (level >= NMT_summary) {\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -374,3 +374,0 @@\n-  \/\/ Late phase initialization\n-  static bool late_initialize(NMT_TrackingLevel level);\n-\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-static void SetJvmEnvironment(int argc, char **argv);\n@@ -287,3 +286,0 @@\n-    \/* Set env. Must be done before LoadJavaVM. *\/\n-    SetJvmEnvironment(argc, argv);\n-\n@@ -801,78 +797,0 @@\n-\/*\n- * This method must be called before the VM is loaded, primarily\n- * used to parse and set any VM related options or env variables.\n- * This function is non-destructive leaving the argument list intact.\n- *\/\n-static void\n-SetJvmEnvironment(int argc, char **argv) {\n-\n-    static const char*  NMT_Env_Name    = \"NMT_LEVEL_\";\n-    const char* NMT_Arg_Name = IsJavaArgs() ? \"-J-XX:NativeMemoryTracking=\" : \"-XX:NativeMemoryTracking=\";\n-    int i;\n-    \/* process only the launcher arguments *\/\n-    for (i = 0; i < argc; i++) {\n-        char *arg = argv[i];\n-        \/*\n-         * Java launcher (!IsJavaArgs()):\n-         *   Since this must be a VM flag we stop processing once we see\n-         *   an argument the launcher would not have processed beyond (such\n-         *   as -version or -h), or an argument that indicates the following\n-         *   arguments are for the application (i.e. the main class name, or\n-         *   the -jar argument).\n-         * Other launchers (IsJavaArgs()):\n-         *   All arguments have to be scanned to see if it is a -J argument.\n-         *\/\n-        if (!IsJavaArgs() && i > 0) {\n-            char *prev = argv[i - 1];\n-            \/\/ skip non-dash arg preceded by class path specifiers\n-            if (*arg != '-' && IsWhiteSpaceOption(prev)) {\n-                continue;\n-            }\n-\n-            if (*arg != '-' || isTerminalOpt(arg)) {\n-                return;\n-            }\n-        }\n-        \/*\n-         * The following case checks for \"-XX:NativeMemoryTracking=value\".\n-         * If value is non null, an environmental variable set to this value\n-         * will be created to be used by the JVM.\n-         * The argument is passed to the JVM, which will check validity.\n-         * The JVM is responsible for removing the env variable.\n-         *\/\n-        if (JLI_StrCCmp(arg, NMT_Arg_Name) == 0) {\n-            int retval;\n-            \/\/ get what follows this parameter, include \"=\"\n-            size_t pnlen = JLI_StrLen(NMT_Arg_Name);\n-            if (JLI_StrLen(arg) > pnlen) {\n-                char* value = arg + pnlen;\n-                size_t pbuflen = pnlen + JLI_StrLen(value) + 10; \/\/ 10 max pid digits\n-\n-                \/*\n-                 * ensures that malloc successful\n-                 * DONT JLI_MemFree() pbuf.  JLI_PutEnv() uses system call\n-                 *   that could store the address.\n-                 *\/\n-                char * pbuf = (char*)JLI_MemAlloc(pbuflen);\n-\n-                JLI_Snprintf(pbuf, pbuflen, \"%s%d=%s\", NMT_Env_Name, JLI_GetPid(), value);\n-                retval = JLI_PutEnv(pbuf);\n-                if (JLI_IsTraceLauncher()) {\n-                    char* envName;\n-                    char* envBuf;\n-\n-                    \/\/ ensures that malloc successful\n-                    envName = (char*)JLI_MemAlloc(pbuflen);\n-                    JLI_Snprintf(envName, pbuflen, \"%s%d\", NMT_Env_Name, JLI_GetPid());\n-\n-                    printf(\"TRACER_MARKER: NativeMemoryTracking: env var is %s\\n\",envName);\n-                    printf(\"TRACER_MARKER: NativeMemoryTracking: putenv arg %s\\n\",pbuf);\n-                    envBuf = getenv(envName);\n-                    printf(\"TRACER_MARKER: NativeMemoryTracking: got value %s\\n\",envBuf);\n-                    free(envName);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":0,"deletions":82,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -96,2 +96,0 @@\n-#define JLI_PutEnv                      _putenv\n-#define JLI_GetPid                      _getpid\n@@ -105,2 +103,0 @@\n-#define JLI_PutEnv                      putenv\n-#define JLI_GetPid                      getpid\n","filename":"src\/java.base\/share\/native\/libjli\/jli_util.h","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/nmtPreInit.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ convenience log. switch on if debugging tests. Don't use tty, plain stdio only.\n+\/\/#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+#define LOG(...)\n+\n+\n+\/\/ This tests the ability of the NMT pre-init system to deal with various combinations\n+\/\/ of pre- and post-init-allocations.\n+\n+\/\/ The tests consist of two phases:\n+\/\/ 1) before NMT initialization (pre-NMT-init) we allocate and reallocate a bunch of\n+\/\/    blocks via os::malloc() and os::realloc(), and free some of them via os::free()\n+\/\/ 2) after NMT initialization, we reallocate some more, then free all of them.\n+\/\/\n+\/\/ The intent is to check that blocks allocated in pre-init phase and potentially realloced\n+\/\/ in pre-init phase are handled correctly if further realloc'ed or free'd post-init.\n+\n+\/\/ We manage to run tests in different phases with this technique:\n+\/\/ - for the pre-init phase, we start the tests in the constructor of a global object; that constructor will\n+\/\/   run as part of the dyn. C++ initialization of the gtestlauncher binary. Since the gtestlauncher links\n+\/\/   *statically* against the libjvm, gtestlauncher and libjvm initialization fold into one and are the same.\n+\/\/ - for the post-init phase, we just start it inside a TEST_VM scope, which needs to create the VM for\n+\/\/   us. So inside that scope VM initialization ran and with it the NMT initialization.\n+\/\/ To be sure, we assert those assumptions.\n+\n+#if INCLUDE_NMT\n+\n+\/\/ Some shorts to save writing out the flags every time\n+static void* os_malloc(size_t s)              { return os::malloc(s, mtTest); }\n+static void* os_realloc(void* old, size_t s)  { return os::realloc(old, s, mtTest); }\n+\n+static void log_state() {\n+  \/\/ Don't use tty! the only safe thing to use at all times is stringStream.\n+  char tmp[256];\n+  stringStream ss(tmp, sizeof(tmp));\n+  NMTPreInit::print_state(&ss);\n+  LOG(\"%s\", tmp);\n+}\n+\n+class TestAllocations {\n+  void* p1, *p2, *p3, *p4;\n+public:\n+  TestAllocations() {\n+    test_pre();\n+  }\n+  void test_pre() {\n+    \/\/ Note that this part will run every time a gtestlauncher execs (so, for every TEST_OTHER_VM).\n+    assert(NMTPreInit::in_preinit_phase(),\n+           \"This should be run in pre-init phase (as part of C++ dyn. initialization)\");\n+    LOG(\"corner cases, pre-init (%d)\", os::current_process_id());\n+    log_state();\n+\n+    p1 = os_malloc(100);                 \/\/ normal allocation\n+    os::free(os_malloc(0));              \/\/ 0-sized allocation, should be free-able\n+    p2 = os_realloc(os_malloc(10), 20);  \/\/ realloc, growing\n+    p3 = os_realloc(os_malloc(20), 10);  \/\/ realloc, shrinking\n+    p4 = os_realloc(NULL, 10);           \/\/ realloc with NULL pointer\n+    os_realloc(os_realloc(os_malloc(20), 0), 30);  \/\/ realloc to size 0 and back up again\n+    os::free(os_malloc(20));             \/\/ malloc, free\n+    os::free(os_realloc(os_malloc(20), 30));  \/\/ malloc, realloc, free\n+    os::free(NULL);                      \/\/ free(null)\n+    DEBUG_ONLY(NMTPreInit::verify();)\n+\n+    log_state();\n+  }\n+  void test_post() {\n+    assert(NMTPreInit::in_preinit_phase() == false,\n+           \"This should be run in post-init phase (from inside a TEST_VM test)\");\n+    LOG(\"corner cases, post-init (%d)\", os::current_process_id());\n+    log_state();\n+\n+    p1 = os_realloc(p1, 140);  \/\/ realloc from pre-init-phase, growing\n+    p2 = os_realloc(p2, 150);  \/\/ realloc from pre-init-phase, growing\n+    p3 = os_realloc(p3, 50);   \/\/ realloc from pre-init-phase, growing\n+    p4 = os_realloc(p4, 8);    \/\/ realloc from pre-init-phase, shrinking\n+    DEBUG_ONLY(NMTPreInit::verify();)\n+\n+    log_state();\n+  }\n+  void free_all() {\n+    assert(NMTPreInit::in_preinit_phase() == false,\n+           \"This should be run in post-init phase (from inside a TEST_VM test)\");\n+    LOG(\"corner cases, free-all (%d)\", os::current_process_id());\n+    log_state();\n+\n+    os::free(p1); os::free(p2); os::free(p3); os::free(p4);\n+    DEBUG_ONLY(NMTPreInit::verify();)\n+\n+    log_state();\n+  }\n+};\n+\n+static TestAllocations g_test_allocations;\n+\n+TEST_VM(NMTPreInit, pre_to_post_allocs) {\n+  g_test_allocations.test_post();\n+  g_test_allocations.free_all();\n+}\n+\n+#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinit.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm_io.h\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/nmtPreInit.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+\n+#if INCLUDE_NMT\n+\n+\/\/ This tests the NMTPreInitAllocationTable hash table used to store C-heap allocations before NMT initialization ran.\n+\n+static size_t small_random_nonzero_size() {\n+  \/\/ We keep the sizes random but not too random; the more regular the sizes, the\n+  \/\/ more regular the malloc return pointers and the better we see how our hash\n+  \/\/ function copes in the NMT preinit lu table.\n+  switch (os::random() % 4) {\n+  case 0: return 0x10;\n+  case 1: return 0x42;\n+  case 2: return 0x20;\n+  case 3: return 0x80;\n+  }\n+  return 1;\n+}\n+\n+\/\/#define VERBOSE\n+\n+static void print_and_check_table(NMTPreInitAllocationTable& table, int expected_num_entries) {\n+  char tmp[256];\n+  stringStream ss(tmp, sizeof(tmp));\n+  char expected[256];\n+  jio_snprintf(expected, sizeof(expected), \"entries: %d\", expected_num_entries);\n+  table.print_state(&ss);\n+  EXPECT_EQ(::strncmp(tmp, expected, strlen(expected)), 0);\n+#ifdef VERBOSE\n+  tty->print_raw(tmp);\n+  tty->cr();\n+#endif\n+  DEBUG_ONLY(table.verify();)\n+}\n+\n+TEST_VM(NMTPreInit, stress_test_map) {\n+  NMTPreInitAllocationTable table;\n+  const int num_allocs = 32 * K; \/\/ about factor 100 more than normally expected\n+  NMTPreInitAllocation** allocations = NEW_C_HEAP_ARRAY(NMTPreInitAllocation*, num_allocs, mtTest);\n+\n+  \/\/ Fill table with allocations\n+  for (int i = 0; i < num_allocs; i++) {\n+    NMTPreInitAllocation* a = NMTPreInitAllocation::do_alloc(small_random_nonzero_size());\n+    table.add(a);\n+    allocations[i] = a;\n+  }\n+\n+  print_and_check_table(table, num_allocs);\n+\n+  \/\/ look them all up\n+  for (int i = 0; i < num_allocs; i++) {\n+    const NMTPreInitAllocation* a = table.find(allocations[i]->payload());\n+    ASSERT_EQ(a, allocations[i]);\n+  }\n+\n+  \/\/ Randomly realloc\n+  for (int j = 0; j < num_allocs\/2; j++) {\n+    int pos = os::random() % num_allocs;\n+    NMTPreInitAllocation* a1 = allocations[pos];\n+    NMTPreInitAllocation* a2 = table.find_and_remove(a1->payload());\n+    ASSERT_EQ(a1, a2);\n+    NMTPreInitAllocation* a3 = NMTPreInitAllocation::do_reallocate(a2, small_random_nonzero_size());\n+    table.add(a3);\n+    allocations[pos] = a3;\n+  }\n+\n+  print_and_check_table(table, num_allocs);\n+\n+  \/\/ look them all up\n+  for (int i = 0; i < num_allocs; i++) {\n+    const NMTPreInitAllocation* a = table.find(allocations[i]->payload());\n+    ASSERT_EQ(a, allocations[i]);\n+  }\n+\n+  \/\/ free all\n+  for (int i = 0; i < num_allocs; i++) {\n+    NMTPreInitAllocation* a = table.find_and_remove(allocations[i]->payload());\n+    ASSERT_EQ(a, allocations[i]);\n+    NMTPreInitAllocation::do_free(a);\n+    allocations[i] = NULL;\n+  }\n+\n+  print_and_check_table(table, 0);\n+\n+  FREE_C_HEAP_ARRAY(NMTPreInitAllocation*, allocations);\n+}\n+\n+#ifdef ASSERT\n+\/\/ Test that we will assert if the lookup table is seriously over-booked.\n+TEST_VM_ASSERT_MSG(NMTPreInit, assert_on_lu_table_overflow, \".*NMT preinit lookup table degenerated.*\") {\n+  NMTPreInitAllocationTable table;\n+  const int num_allocs = 400 * 1000; \/\/ anything above ~250K entries should trigger the assert (note: normal number of entries is ~500)\n+  for (int i = 0; i < num_allocs; i++) {\n+    NMTPreInitAllocation* a = NMTPreInitAllocation::do_alloc(1);\n+    table.add(a);\n+  }\n+#ifdef VERBOSE\n+  table.print_state(tty);\n+  tty->cr();\n+#endif\n+  table.verify();\n+}\n+#endif \/\/ ASSERT\n+\n+#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinitmap.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -211,2 +211,0 @@\n-  VirtualMemoryTracker::initialize(NMT_detail);\n-  VirtualMemoryTracker::late_initialize(NMT_detail);\n@@ -214,3 +212,13 @@\n-  CommittedVirtualMemoryTest::test();\n-  CommittedVirtualMemoryTest::test_committed_region();\n-  CommittedVirtualMemoryTest::test_partial_region();\n+  \/\/  This tests the VM-global NMT facility. The test must *not* modify global state,\n+  \/\/  since that interferes with other tests!\n+  \/\/ The gtestLauncher are called with and without -XX:NativeMemoryTracking during jtreg-controlled\n+  \/\/  gtests.\n+\n+  if (MemTracker::tracking_level() >= NMT_detail) {\n+    CommittedVirtualMemoryTest::test();\n+    CommittedVirtualMemoryTest::test_committed_region();\n+    CommittedVirtualMemoryTest::test_partial_region();\n+  } else {\n+    tty->print_cr(\"skipped.\");\n+  }\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -24,0 +24,9 @@\n+\/\/ Tests here test the VM-global NMT facility.\n+\/\/  The tests must *not* modify global state! E.g. switch NMT on or off. Instead, they\n+\/\/  should work passively with whatever setting the gtestlauncher had been started with\n+\/\/  - if NMT is enabled, test NMT, otherwise do whatever minimal tests make sense if NMT\n+\/\/  is off.\n+\/\/\n+\/\/ The gtestLauncher then are called with various levels of -XX:NativeMemoryTracking during\n+\/\/  jtreg-controlled gtests (see test\/hotspot\/jtreg\/gtest\/NMTGtests.java)\n+\n@@ -31,0 +40,1 @@\n+#include \"memory\/virtualspace.hpp\"\n@@ -35,0 +45,4 @@\n+#include <stdio.h>\n+\n+\/\/ #define LOG(...) printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout);\n+#define LOG(...)\n@@ -50,0 +64,8 @@\n+static void diagnostic_print(ReservedMemoryRegion* rmr) {\n+  CommittedRegionIterator iter = rmr->iterate_committed_regions();\n+  LOG(\"In reserved region \" PTR_FORMAT \", size \" SIZE_FORMAT_HEX \":\", p2i(rmr->base()), rmr->size());\n+  for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+    LOG(\"   committed region: \" PTR_FORMAT \", size \" SIZE_FORMAT_HEX, p2i(region->base()), region->size());\n+  }\n+}\n+\n@@ -55,0 +77,3 @@\n+  \/\/ Helpful log\n+  diagnostic_print(rmr);\n+\n@@ -72,2 +97,0 @@\n-    VirtualMemoryTracker::initialize(NMT_detail);\n-    VirtualMemoryTracker::late_initialize(NMT_detail);\n@@ -75,1 +98,0 @@\n-    address addr = (address)0x10000000;\n@@ -77,0 +99,2 @@\n+    ReservedSpace rs(size);\n+    address addr = (address)rs.base();\n@@ -84,4 +108,1 @@\n-    \/\/ Add the reserved memory\n-    VirtualMemoryTracker::add_reserved_region(addr, size, stack, mtTest);\n-\n-    \/\/ Fetch the added RMR added above\n+    \/\/ Fetch the added RMR for the space\n@@ -150,2 +171,0 @@\n-    VirtualMemoryTracker::initialize(NMT_detail);\n-    VirtualMemoryTracker::late_initialize(NMT_detail);\n@@ -153,1 +172,0 @@\n-    address addr = (address)0x10000000;\n@@ -155,0 +173,2 @@\n+    ReservedSpace rs(size);\n+    address addr = (address)rs.base();\n@@ -165,1 +185,1 @@\n-    \/\/ Fetch the added RMR added above\n+    \/\/ Fetch the added RMR for the space\n@@ -238,2 +258,0 @@\n-    VirtualMemoryTracker::initialize(NMT_detail);\n-    VirtualMemoryTracker::late_initialize(NMT_detail);\n@@ -241,1 +259,0 @@\n-    address addr = (address)0x10000000;\n@@ -243,0 +260,2 @@\n+    ReservedSpace rs(size);\n+    address addr = (address)rs.base();\n@@ -250,4 +269,1 @@\n-    \/\/ Add the reserved memory\n-    VirtualMemoryTracker::add_reserved_region(addr, size, stack, mtTest);\n-\n-    \/\/ Fetch the added RMR added above\n+    \/\/ Fetch the added RMR for the space\n@@ -413,2 +429,0 @@\n-    VirtualMemoryTracker::initialize(NMT_detail);\n-    VirtualMemoryTracker::late_initialize(NMT_detail);\n@@ -416,1 +430,0 @@\n-    address addr = (address)0x10000000;\n@@ -418,0 +431,2 @@\n+    ReservedSpace rs(size);\n+    address addr = (address)rs.base();\n@@ -425,4 +440,1 @@\n-    \/\/ Add the reserved memory\n-    VirtualMemoryTracker::add_reserved_region(addr, size, stack, mtTest);\n-\n-    \/\/ Fetch the added RMR added above\n+    \/\/ Fetch the added RMR for the space\n@@ -542,2 +554,6 @@\n-TEST_VM(VirtualMemoryTracker, add_committed_region) {\n-  VirtualMemoryTrackerTest::test_add_committed_region();\n+TEST_VM(NMT_VirtualMemoryTracker, add_committed_region) {\n+  if (MemTracker::tracking_level() >= NMT_detail) {\n+    VirtualMemoryTrackerTest::test_add_committed_region();\n+  } else {\n+    tty->print_cr(\"skipped.\");\n+  }\n@@ -546,2 +562,6 @@\n-TEST_VM(VirtualMemoryTracker, remove_uncommitted_region) {\n-  VirtualMemoryTrackerTest::test_remove_uncommitted_region();\n+TEST_VM(NMT_VirtualMemoryTracker, remove_uncommitted_region) {\n+  if (MemTracker::tracking_level() >= NMT_detail) {\n+    VirtualMemoryTrackerTest::test_remove_uncommitted_region();\n+  } else {\n+    tty->print_cr(\"skipped.\");\n+  }\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":49,"deletions":29,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-  gtest\/LargePageGtests.java\n+  gtest\/LargePageGtests.java \\\n+  gtest\/NMTGtests.java \\\n@@ -361,1 +362,0 @@\n- -runtime\/NMT \\\n@@ -557,1 +557,2 @@\n-  runtime\/NMT\n+  runtime\/NMT \\\n+  gtest\/NMTGtests.java\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This tests NMT by running gtests with NMT enabled.\n+ *\n+ * To save time, we just run them for debug builds (where we would catch assertions) and only a selection of tests\n+ * (namely, NMT tests themselves, and - for the detail statistics - os tests, since those reserve a lot and stress NMT)\n+ *\/\n+\n+\/* @test id=nmt-summary\n+ * @summary Run NMT-related gtests with summary statistics\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.debug\n+ * @run main\/native GTestWrapper --gtest_filter=NMT* -XX:NativeMemoryTracking=summary\n+ *\/\n+\n+\/* @test id=nmt-detail\n+ * @summary Run NMT-related gtests with detailed statistics\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.debug\n+ * @run main\/native GTestWrapper --gtest_filter=NMT*:os* -XX:NativeMemoryTracking=detail\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/NMTGtests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * With JDK-8256844 \"Make NMT late-initializable\", NMT should work out of the box with jdk launchers other than\n+ * java.exe.\n+ *\n+ * Test that assumption (we test with javac and jar and leave it at that, other tools should be fine as well)\n+ *\/\n+\n+\/**\n+ * @test id=javac\n+ * @bug 8256844\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver NMTForOtherLaunchersTest javac\n+ *\/\n+\n+\/**\n+ * @test id=jar\n+ * @bug 8256844\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver NMTForOtherLaunchersTest jar\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.JDKToolFinder;\n+\n+public class NMTForOtherLaunchersTest {\n+    public static void main(String args[]) throws Exception {\n+        String tool = args[0];\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(new String[]{\n+                JDKToolFinder.getJDKTool(tool),\n+                \"-J-XX:NativeMemoryTracking=summary\",\n+                \"-J-XX:+UnlockDiagnosticVMOptions\",\n+                \"-J-XX:+PrintNMTStatistics\",\n+                \"--help\"});\n+        System.out.println(pb.command());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        \/\/ We should not see the \"wrong launcher?\" message, which would indicate\n+        \/\/ an older JDK, and we should see the NMT stat output when the VM shuts down.\n+        output.shouldNotContain(\"wrong launcher\");\n+        output.shouldContain(\"Native Memory Tracking:\");\n+        output.shouldMatch(\"Total: reserved=\\\\d+, committed=\\\\d+.*\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTForOtherLaunchersTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * This test tests the ability of NMT to work correctly when masses of allocations happen before NMT is initialized;\n+ * That pre-NMT-init phase starts when the libjvm is loaded and the C++ dynamic initialization runs, and ends when\n+ * NMT is initialized after the VM parsed its arguments in CreateJavaVM.\n+ *\n+ * During that phase, NMT is not yet initialized fully; C-heap allocations are kept in a special lookup table to\n+ * be able to tell them apart from post-NMT-init initializations later. For details, see nmtPreInit.hpp.\n+ *\n+ * The size of this table is limited, and its load factor affects lookup time; that lookup time is paid throughout\n+ * the VM life for all os::free() calls, regardless if NMT is on or not. Therefore we are interested in keeping the\n+ * number of pre-NMT-init allocations low.\n+ *\n+ * Normally, the VM allocates about 500 surviving allocations (allocations which are not freed before NMT initialization\n+ * finishes). The number is mainly influenced by the number of VM arguments, since those get strdup'ed around.\n+ * Therefore, the only direct way to test pre-NMT-init allocations is by feeding the VM a lot of arguments, and this is\n+ * what this test does.\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=normal-off\n+ * @bug 8256844\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver NMTInitializationTest normal off\n+ *\/\n+\n+\/**\n+ * @test id=normal-detail\n+ * @bug 8256844\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver NMTInitializationTest normal detail\n+ *\/\n+\n+\/**\n+ * @test id=default_long-off\n+ * @bug 8256844\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver NMTInitializationTest long off\n+ *\/\n+\n+\/**\n+ * @test id=default_long-detail\n+ * @bug 8256844\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver NMTInitializationTest long detail\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.FileWriter;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class NMTInitializationTest {\n+\n+    final static boolean debug = true;\n+\n+    static String randomString() {\n+        Random r = new Random();\n+        int len = r.nextInt(100) + 100;\n+        StringBuilder bld = new StringBuilder();\n+        for (int i = 0; i < len; i ++) {\n+            bld.append(r.nextInt(26) + 'A');\n+        }\n+        return bld.toString();\n+    }\n+\n+    static Path createCommandFile(int numlines) throws Exception {\n+        String fileName = \"commands_\" + numlines + \".txt\";\n+        FileWriter fileWriter = new FileWriter(fileName);\n+        PrintWriter printWriter = new PrintWriter(fileWriter);\n+        String line = \"-XX:ErrorFile=\" + randomString();\n+        for (long i = 0; i < numlines \/ 2; i++) {\n+            printWriter.println(line);\n+        }\n+        printWriter.close();\n+        return Paths.get(fileName);\n+    }\n+\n+    enum TestMode {\n+        \/\/ call the VM with a normal-ish command line (long but not oudlandishly so). We expect the lookup table after\n+        \/\/ initialization to be sparsely populated and sport very short chain lengths.\n+        mode_normal(30, 5),\n+        \/\/ call the VM with an outlandishly long command line. We expect the lookup table after initialization\n+        \/\/ to be densely populated but hopefully evenly distributed.\n+        mode_long(20000, 20);\n+\n+        final int num_command_line_args;\n+        final int expected_max_chain_len;\n+\n+        TestMode(int num_command_line_args, int expected_max_chain_len) {\n+            this.num_command_line_args = num_command_line_args;\n+            this.expected_max_chain_len = expected_max_chain_len;\n+        }\n+    };\n+\n+    enum NMTMode {\n+      off, summary, detail\n+    };\n+\n+    public static void main(String args[]) throws Exception {\n+        TestMode testMode = TestMode.valueOf(\"mode_\" + args[0]);\n+        NMTMode nmtMode = NMTMode.valueOf(args[1]);\n+\n+        System.out.println(\"Test mode: \" + testMode + \", NMT mode: \" + nmtMode);\n+\n+        Path commandLineFile = createCommandFile(testMode.num_command_line_args);\n+\n+        ArrayList<String> vmArgs = new ArrayList<>();\n+        vmArgs.add(\"-Xlog:nmt\");\n+        vmArgs.add(\"-XX:NativeMemoryTracking=\" + nmtMode.name());\n+        vmArgs.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        vmArgs.add(\"-XX:+PrintNMTStatistics\");\n+\n+        if (commandLineFile != null) {\n+            vmArgs.add(\"@\" + commandLineFile.getFileName());\n+        }\n+        vmArgs.add(\"-version\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(vmArgs);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        if (debug) {\n+            output.reportDiagnosticSummary();\n+        }\n+\n+        output.shouldHaveExitValue(0);\n+\n+        \/\/ Now evaluate the output of -Xlog:nmt\n+        \/\/ We expect something like:\n+        \/\/ [0.001s][info][nmt] NMT initialized: detail\n+        \/\/ [0.001s][info][nmt] Preinit state:\n+        \/\/ [0.001s][info][nmt] entries: 342 (primary: 342, empties: 7577), sum bytes: 12996, longest chain length: 1\n+        \/\/ [0.001s][info][nmt] pre-init mallocs: 375, pre-init reallocs: 6, pre-init frees: 33, pre-to-post reallocs: 4, pre-to-post frees: 0\n+\n+        output.shouldContain(\"NMT initialized: \" + nmtMode.name());\n+        output.shouldContain(\"Preinit state:\");\n+        String regex = \".*entries: (\\\\d+).*sum bytes: (\\\\d+).*longest chain length: (\\\\d+).*\";\n+        output.shouldMatch(regex);\n+        String line = output.firstMatch(regex, 0);\n+        if (line == null) {\n+            throw new RuntimeException(\"expected: \" + regex);\n+        }\n+        System.out.println(line);\n+        Pattern p = Pattern.compile(regex);\n+        Matcher mat = p.matcher(line);\n+        mat.matches();\n+        int entries = Integer.parseInt(mat.group(1));\n+        int sum_bytes = Integer.parseInt(mat.group(2));\n+        int longest_chain = Integer.parseInt(mat.group(3));\n+        System.out.println(\"found: \" + entries + \" - \" + sum_bytes + longest_chain + \".\");\n+\n+        \/\/ Now we test the state of the internal lookup table, and through our assumptions about\n+        \/\/   early pre-NMT-init allocations:\n+        \/\/ The normal allocation count of surviving pre-init allocations is around 300-500, with the sum of allocated\n+        \/\/   bytes of a few dozen KB. We check these boundaries (with a very generous overhead) to see if the numbers are\n+        \/\/   way off. If they are, we may either have a leak or just a lot more allocations than we thought before\n+        \/\/   NMT initialization. Both cases should be investigated. Even if the allocations are valid, too many of them\n+        \/\/   stretches the limits of the lookup map, and therefore may cause slower lookup. We should then either change\n+        \/\/   the coding, reducing the number of allocations. Or enlarge the lookup table.\n+\n+        \/\/ Apply some sensible assumptions\n+        if (entries > testMode.num_command_line_args + 2000) { \/\/ Note: normal baseline is 400-500\n+            throw new RuntimeException(\"Suspiciously high number of pre-init allocations.\");\n+        }\n+        if (sum_bytes > 128 * 1024 * 1024) { \/\/ Note: normal baseline is ~30-40KB\n+            throw new RuntimeException(\"Suspiciously high pre-init memory usage.\");\n+        }\n+        if (longest_chain > testMode.expected_max_chain_len) {\n+            \/\/ Under normal circumstances, load factor of the map should be about 0.1. With a good hash distribution, we\n+            \/\/ should rarely see even a chain > 1. Warn if we see exceedingly long bucket chains, since this indicates\n+            \/\/ either that the hash algorithm is inefficient or we have a bug somewhere.\n+            throw new RuntimeException(\"Suspiciously long bucket chains in lookup table.\");\n+        }\n+\n+        \/\/ Finally, check that we see our final NMT report:\n+        if (nmtMode != NMTMode.off) {\n+            output.shouldContain(\"Native Memory Tracking:\");\n+            output.shouldMatch(\"Total: reserved=\\\\d+, committed=\\\\d+.*\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTInitializationTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -27,2 +27,1 @@\n- * @summary Checks for Launcher special flags, such as MacOSX specific flags,\n- *          and JVM NativeMemoryTracking flags.\n+ * @summary Checks for Launcher special flags, such as MacOSX specific flags.\n@@ -114,161 +113,0 @@\n-    @Test\n-    void testNativeMemoryTracking() {\n-        final Map<String, String> envMap = new HashMap<>();\n-        envMap.put(\"_JAVA_LAUNCHER_DEBUG\", \"true\");\n-        TestResult tr;\n-        \/*\n-         * test argument : -XX:NativeMemoryTracking=value\n-         * A JVM flag, comsumed by the JVM, but requiring launcher\n-         * to set an environmental variable if and only if value is supplied.\n-         * Test and order:\n-         * 1) execute with valid parameter: -XX:NativeMemoryTracking=MyValue\n-         *    a) check for correct env variable name: \"NMT_LEVEL_\" + pid\n-         *    b) check that \"MyValue\" was found in local env.\n-         * 2) execute with invalid parameter: -XX:NativeMemoryTracking=\n-         *    !) Won't find \"NativeMemoryTracking:\"\n-         *       Code to create env variable not executed.\n-         * 3) execute with invalid parameter: -XX:NativeMemoryTracking\n-         *    !) Won't find \"NativeMemoryTracking:\"\n-         *       Code to create env variable not executed.\n-         * 4) give and invalid value and check to make sure JVM commented\n-         *\/\n-        String envVarPidString = \"TRACER_MARKER: NativeMemoryTracking: env var is NMT_LEVEL_\";\n-        String NMT_Option_Value = \"off\";\n-        String myClassName = \"helloworld\";\n-\n-        \/\/ === Run the tests ===\n-        \/\/ ---Test 1a\n-        tr = doExec(envMap, javaCmd, \"-XX:NativeMemoryTracking=\" + NMT_Option_Value,\n-                \"-version\");\n-\n-        \/\/ get the PID from the env var we set for the JVM\n-        String envVarPid = null;\n-        for (String line : tr.testOutput) {\n-            if (line.contains(envVarPidString)) {\n-                int sindex = envVarPidString.length();\n-                envVarPid = line.substring(sindex);\n-                break;\n-            }\n-        }\n-        \/\/ did we find envVarPid?\n-        if (envVarPid == null) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Error: failed to find env Var Pid in tracking info\");\n-        }\n-        \/\/ we think we found the pid string.  min test, not \"\".\n-        if (envVarPid.length() < 1) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Error: env Var Pid in tracking info is empty string\");\n-        }\n-\n-        \/\/ --- Test 1b\n-        if (!tr.contains(\"NativeMemoryTracking: got value \" + NMT_Option_Value)) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Error: Valid param failed to set env variable\");\n-        }\n-\n-        \/\/ --- Test 2\n-        tr = doExec(envMap, javaCmd, \"-XX:NativeMemoryTracking=\",\n-                \"-version\");\n-        if (tr.contains(\"NativeMemoryTracking:\")) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Error: invalid param caused env variable to be erroneously created\");\n-        }\n-        if (!tr.contains(\"Syntax error, expecting -XX:NativeMemoryTracking=\")) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Error: invalid param not checked by JVM\");\n-        }\n-\n-        \/\/ --- Test 3\n-        tr = doExec(envMap, javaCmd, \"-XX:NativeMemoryTracking\",\n-                \"-version\");\n-        if (tr.contains(\"NativeMemoryTracking:\")) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Error: invalid param caused env variable to be erroneously created\");\n-        }\n-        if (!tr.contains(\"Syntax error, expecting -XX:NativeMemoryTracking=\")) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Error: invalid param not checked by JVM\");\n-        }\n-        \/\/ --- Test 4\n-        tr = doExec(envMap, javaCmd, \"-XX:NativeMemoryTracking=BADVALUE\",\n-                \"-version\");\n-        if (!tr.contains(\"expecting -XX:NativeMemoryTracking\")) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Error: invalid param did not get JVM Syntax error message\");\n-        }\n-    }\n-\n-    @Test\n-    void testNMArgumentProcessing() throws FileNotFoundException {\n-        TestResult tr;\n-        \/\/ the direct invokers of the VM\n-        String options[] = {\n-            \"-version\", \"-fullversion\", \"-help\", \"-?\", \"-X\"\n-        };\n-        for (String option : options) {\n-            tr = doExec(javaCmd, option, \"-XX:NativeMemoryTracking=summary\");\n-            checkTestResult(tr);\n-        }\n-\n-        \/\/ create a test jar\n-        File jarFile = new File(\"test.jar\");\n-        createJar(jarFile, \"public static void main(String... args){}\");\n-\n-        \/\/ ones that involve main-class of some sort\n-        tr = doExec(javaCmd, \"-jar\", jarFile.getName(),\n-                \"-XX:NativeMemoryTracking=summary\");\n-        checkTestResult(tr);\n-\n-        tr = doExec(javaCmd, \"-cp\", jarFile.getName(), \"Foo\",\n-                \"-XX:NativeMemoryTracking=summary\");\n-        checkTestResult(tr);\n-\n-        final Map<String, String> envMap = new HashMap<>();\n-        \/\/ checkwith CLASSPATH set ie. no -cp or -classpath\n-        envMap.put(\"CLASSPATH\", \".\");\n-        tr = doExec(envMap, javaCmd, \"Foo\", \"-XX:NativeMemoryTracking=summary\");\n-        checkTestResult(tr);\n-\n-        \/\/ should accept with no warnings\n-        tr = doExec(javaCmd, \"-cp\", jarFile.getName(),\n-                    \"-XX:NativeMemoryTracking=summary\", \"Foo\");\n-        ensureNoWarnings(tr);\n-\n-        \/\/ should accept with no warnings\n-        tr = doExec(javaCmd, \"-classpath\", jarFile.getName(),\n-                    \"-XX:NativeMemoryTracking=summary\", \"Foo\");\n-        ensureNoWarnings(tr);\n-\n-        \/\/ make sure a missing class is handled correctly, because the class\n-        \/\/ resolution is performed by the JVM.\n-        tr = doExec(javaCmd, \"AbsentClass\", \"-XX:NativeMemoryTracking=summary\");\n-        if (!tr.contains(\"Error: Could not find or load main class AbsentClass\")) {\n-            throw new RuntimeException(\"Test Fails\");\n-        }\n-\n-        \/\/ Make sure we handle correctly the module long form (--module=)\n-        tr = doExec(javaCmd, \"-XX:NativeMemoryTracking=summary\", \"--module=jdk.compiler\/com.sun.tools.javac.Main\", \"--help\");\n-        ensureNoWarnings(tr);\n-    }\n-\n-    @Test\n-    void testNMTTools() throws FileNotFoundException {\n-        TestResult tr;\n-        \/\/ Tools (non-java launchers) should handle NTM (no \"wrong launcher\" warning).\n-        tr = doExec(jarCmd, \"-J-XX:NativeMemoryTracking=summary\", \"--help\");\n-        ensureNoWarnings(tr);\n-\n-        \/\/ And java terminal args (like \"--help\") don't stop \"-J\" args parsing.\n-        tr = doExec(jarCmd, \"--help\", \"-J-XX:NativeMemoryTracking=summary\");\n-        ensureNoWarnings(tr);\n-    }\n-\n-    void ensureNoWarnings(TestResult tr) {\n-        checkTestResult(tr);\n-        if (tr.contains(\"warning: Native Memory Tracking\")) {\n-            System.err.println(tr.toString());\n-            throw new RuntimeException(\"Test Fails\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/tools\/launcher\/TestSpecialArgs.java","additions":1,"deletions":163,"binary":false,"changes":164,"status":"modified"}]}