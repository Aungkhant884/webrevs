{"files":[{"patch":"@@ -37,0 +37,5 @@\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -43,0 +48,4 @@\n+    \/\/ Valid --date range\n+    static final ZonedDateTime DATE_MIN = ZonedDateTime.parse(\"1980-01-01T00:00:02Z\");\n+    static final ZonedDateTime DATE_MAX = ZonedDateTime.parse(\"2099-12-31T23:59:59Z\");\n+\n@@ -191,0 +200,14 @@\n+            new Option(true, OptionType.CREATE_UPDATE_INDEX, \"--date\") {\n+                void process(Main jartool, String opt, String arg) throws BadArgs {\n+                    try {\n+                        ZonedDateTime date = ZonedDateTime.parse(arg, DateTimeFormatter.ISO_ZONED_DATE_TIME)\n+                                                             .withZoneSameInstant(ZoneOffset.UTC);\n+                        if (date.isBefore(DATE_MIN) || date.isAfter(DATE_MAX)) {\n+                            throw new BadArgs(\"error.date.out.of.range\", arg);\n+                        }\n+                        jartool.date = date.toLocalDateTime();\n+                    } catch (DateTimeParseException x) {\n+                        throw new BadArgs(\"error.date.notvalid\", arg);\n+                    }\n+                }\n+            },\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -70,0 +71,2 @@\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n@@ -176,0 +179,3 @@\n+    \/* Date option for entry timestamps resolved to UTC Local time *\/\n+    LocalDateTime date;\n+\n@@ -861,1 +867,1 @@\n-                e.setTime(System.currentTimeMillis());\n+                setZipEntryTime(e);\n@@ -866,1 +872,1 @@\n-                e.setTime(System.currentTimeMillis());\n+                setZipEntryTime(e);\n@@ -966,1 +972,1 @@\n-                    e2.setTime(e.getTime());\n+                    setZipEntryTime(e2, e.getTime());\n@@ -1032,1 +1038,1 @@\n-        e.setTime(System.currentTimeMillis());\n+        setZipEntryTime(e);\n@@ -1051,1 +1057,1 @@\n-            e.setTime(System.currentTimeMillis());\n+            setZipEntryTime(e);\n@@ -1076,1 +1082,1 @@\n-        e.setTime(System.currentTimeMillis());\n+        setZipEntryTime(e);\n@@ -1197,1 +1203,1 @@\n-        e.setTime(file.lastModified());\n+        setZipEntryTime(e, file.lastModified());\n@@ -2276,0 +2282,14 @@\n+    \/\/ Set the ZipEntry dostime using date if specified otherwise the current time\n+    private void setZipEntryTime(ZipEntry e) {\n+        setZipEntryTime(e, System.currentTimeMillis());\n+    }\n+\n+    \/\/ Set the ZipEntry dostime using the date if specified\n+    \/\/ otherwise the original time\n+    private void setZipEntryTime(ZipEntry e, long origTime) {\n+        if (date != null) {\n+            e.setTimeLocal(date);\n+        } else {\n+            e.setTime(origTime);\n+        }\n+    }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,4 @@\n+error.date.notvalid=\\\n+        date {0} is not a valid ISO-8601 extended offset date-time with optional time-zone\n+error.date.out.of.range=\\\n+        date {0} is not within the valid range 1980-01-01T00:00:02Z to 2099-12-31T23:59:59Z\n@@ -293,0 +297,4 @@\n+main.help.opt.create.update.index.date=\\\n+\\      --date=TIMESTAMP       The timestamp in ISO-8601 extended offset date-time with\\n\\\n+\\                             optional time-zone format, to use for the timestamps of\\n\\\n+\\                             entries, e.g. \"2022-02-12T12:30:00-05:00\"\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.time.LocalDateTime;\n@@ -57,1 +58,1 @@\n-    static JmodOutputStream newOutputStream(Path file) throws IOException {\n+    static JmodOutputStream newOutputStream(Path file, LocalDateTime date) throws IOException {\n@@ -60,1 +61,1 @@\n-        return new JmodOutputStream(bos);\n+        return new JmodOutputStream(bos, date);\n@@ -64,1 +65,2 @@\n-    private JmodOutputStream(OutputStream out) {\n+    private final LocalDateTime date;\n+    private JmodOutputStream(OutputStream out, LocalDateTime date) {\n@@ -66,0 +68,1 @@\n+        this.date = date;\n@@ -107,1 +110,5 @@\n-        e2.setTime(e1.getTime());\n+        if (date != null) {\n+            e2.setTimeLocal(date);\n+        } else {\n+            e2.setTime(e1.getTime());\n+        }\n@@ -127,1 +134,5 @@\n-        return new ZipEntry(name);\n+        ZipEntry zipEntry = new ZipEntry(name);\n+        if (date != null) {\n+            zipEntry.setTimeLocal(date);\n+        }\n+        return zipEntry;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodOutputStream.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -163,0 +168,1 @@\n+        LocalDateTime date;\n@@ -165,0 +171,4 @@\n+    \/\/ Valid --date range\n+    static final ZonedDateTime DATE_MIN = ZonedDateTime.parse(\"1980-01-01T00:00:02Z\");\n+    static final ZonedDateTime DATE_MAX = ZonedDateTime.parse(\"2099-12-31T23:59:59Z\");\n+\n@@ -430,1 +440,1 @@\n-            try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget)) {\n+            try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.date)) {\n@@ -987,1 +997,5 @@\n-                            ze.setTime(System.currentTimeMillis());\n+                            if (options.date != null) {\n+                                ze.setTimeLocal(options.date);\n+                            } else {\n+                                ze.setTime(System.currentTimeMillis());\n+                            }\n@@ -1015,1 +1029,1 @@\n-                 JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget))\n+                 JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.date))\n@@ -1150,0 +1164,20 @@\n+    static class DateConverter implements ValueConverter<LocalDateTime> {\n+        @Override\n+        public LocalDateTime convert(String value) {\n+            try {\n+                ZonedDateTime date = ZonedDateTime.parse(value, DateTimeFormatter.ISO_ZONED_DATE_TIME)\n+                                                          .withZoneSameInstant(ZoneOffset.UTC);\n+                if (date.isBefore(DATE_MIN) || date.isAfter(DATE_MAX)) {\n+                    throw new CommandException(\"err.date.out.of.range\", value);\n+                }\n+                return date.toLocalDateTime();\n+            } catch (DateTimeParseException x) {\n+                throw new CommandException(\"err.invalid.date\", value, x.getMessage());\n+            }\n+        }\n+\n+        @Override public Class<LocalDateTime> valueType() { return LocalDateTime.class; }\n+\n+        @Override public String valuePattern() { return \"date\"; }\n+    }\n+\n@@ -1385,0 +1419,5 @@\n+        OptionSpec<LocalDateTime> date\n+                = parser.accepts(\"date\", getMessage(\"main.opt.date\"))\n+                        .withRequiredArg()\n+                        .withValuesConvertedBy(new DateConverter());\n+\n@@ -1428,0 +1467,2 @@\n+            if (opts.has(date))\n+                options.date = opts.valueOf(date);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodTask.java","additions":44,"deletions":3,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,3 @@\n+main.opt.date=Date and time for the timestamps of entries, specified in ISO-8601\\\n+\\ extended offset date-time with optional time-zone format, e.g.\\\n+\\ \"2022-02-12T12:30:00-05:00\"\n@@ -109,0 +112,2 @@\n+err.invalid.date=--date {0} is not a valid ISO-8601 extended offset date-time with optional time-zone format: {1}\n+err.date.out.of.range=--date {0} is out of the valid range 1980-01-01T00:00:02Z to 2099-12-31T23:59:59Z\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/resources\/jmod.properties","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276766\n+ * @requires vm.bits == 64\n+ * @summary Test jar --date source date of entries and that jars are\n+ *          reproducible\n+ * @modules jdk.jartool\n+ * @run testng\/othervm ReproducibleJar\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Date;\n+import java.util.TimeZone;\n+import java.util.spi.ToolProvider;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+public class ReproducibleJar {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jar tool not found\")\n+            );\n+\n+    \/\/ ZipEntry's mod date has 2 seconds precision: give extra time to\n+    \/\/ allow for e.g. rounding\/truncation and networked\/samba drives.\n+    private static final long PRECISION = 10000L;\n+\n+    private static final TimeZone TZ = TimeZone.getDefault();\n+    private static final boolean DST = TZ.inDaylightTime(new Date());\n+    private static final String UNIX_2038_ROLLOVER_TIME = \"2038-01-19T03:14:07Z\";\n+    private static final Instant UNIX_2038_ROLLOVER = Instant.parse(UNIX_2038_ROLLOVER_TIME);\n+    private static final File DIR_OUTER = new File(\"outer\");\n+    private static final File DIR_INNER = new File(DIR_OUTER, \"inner\");\n+    private static final File FILE_INNER = new File(DIR_INNER, \"foo.txt\");\n+    private static final File JAR_FILE_SOURCE_DATE1 = new File(\"JarEntryTimeSourceDate1.jar\");\n+    private static final File JAR_FILE_SOURCE_DATE2 = new File(\"JarEntryTimeSourceDate2.jar\");\n+\n+    \/\/ Valid --date values for jar\n+    @DataProvider\n+    private Object[][] validSourceDates() {\n+        return new Object[][]{\n+                {\"1980-01-01T00:00:02+00:00\"},\n+                {\"1986-06-24T01:02:03+00:00\"},\n+                {\"2022-03-15T00:00:00+00:00\"},\n+                {\"2022-03-15T00:00:00+06:00\"},\n+                {\"2021-12-25T09:30:00-08:00[America\/Los_Angeles]\"},\n+                {\"2021-12-31T23:59:59Z\"},\n+                {\"2024-06-08T14:24Z\"},\n+                {\"2026-09-24T16:26-05:00\"},\n+                {\"2038-11-26T06:06:06+00:00\"},\n+                {\"2098-02-18T00:00:00-08:00\"},\n+                {\"2099-12-31T23:59:59+00:00\"}\n+        };\n+    }\n+\n+    \/\/ Invalid --date values for jar\n+    @DataProvider\n+    private Object[][] invalidSourceDates() {\n+        return new Object[][]{\n+                {\"1976-06-24T01:02:03+00:00\"},\n+                {\"1980-01-01T00:00:01+00:00\"},\n+                {\"2100-01-01T00:00:00+00:00\"},\n+                {\"2138-02-18T00:00:00-11:00\"},\n+                {\"2006-04-06T12:38:00\"},\n+                {\"2012-08-24T16\"}\n+        };\n+    }\n+\n+    @BeforeMethod\n+    public void runBefore() throws IOException {\n+        runAfter();\n+        createOuterInnerDirs();\n+    }\n+\n+    @AfterMethod\n+    public void runAfter() {\n+        cleanup(DIR_INNER);\n+        cleanup(DIR_OUTER);\n+        JAR_FILE_SOURCE_DATE1.delete();\n+        JAR_FILE_SOURCE_DATE2.delete();\n+        TimeZone.setDefault(TZ);\n+    }\n+\n+    \/**\n+     * Test jar tool with various valid --date <timestamps>\n+     *\/\n+    @Test(dataProvider = \"validSourceDates\")\n+    public void testValidSourceDate(String sourceDate) {\n+        if (isInTransition()) return;\n+\n+        \/\/ Test --date source date\n+        Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--create\",\n+                \"--file\", JAR_FILE_SOURCE_DATE1.getName(),\n+                \"--date\", sourceDate,\n+                DIR_OUTER.getName()), 0);\n+        Assert.assertTrue(JAR_FILE_SOURCE_DATE1.exists());\n+\n+        \/\/ Extract JAR_FILE_SOURCE_DATE1 and check last modified values\n+        Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--extract\",\n+                \"--file\", JAR_FILE_SOURCE_DATE1.getName()), 0);\n+        Assert.assertTrue(DIR_OUTER.exists());\n+        Assert.assertTrue(DIR_INNER.exists());\n+        Assert.assertTrue(FILE_INNER.exists());\n+        LocalDateTime expectedLdt = ZonedDateTime.parse(sourceDate,\n+                        DateTimeFormatter.ISO_DATE_TIME)\n+                .withZoneSameInstant(ZoneOffset.UTC)\n+                .toLocalDateTime();\n+        System.out.format(\"Checking jar entries local date time for --date %s, is %s%n\",\n+                sourceDate, expectedLdt);\n+        long sourceDateEpochMillis = TimeUnit.MILLISECONDS.convert(\n+                expectedLdt.toEpochSecond(ZoneId.systemDefault().getRules()\n+                        .getOffset(expectedLdt)), TimeUnit.SECONDS);\n+        checkFileTime(DIR_OUTER.lastModified(), sourceDateEpochMillis);\n+        checkFileTime(DIR_INNER.lastModified(), sourceDateEpochMillis);\n+        checkFileTime(FILE_INNER.lastModified(), sourceDateEpochMillis);\n+    }\n+\n+    \/**\n+     * Test jar tool with various invalid --date <timestamps>\n+     *\/\n+    @Test(dataProvider = \"invalidSourceDates\")\n+    public void testInvalidSourceDate(String sourceDate) {\n+        \/\/ Negative Tests --date out of range or wrong format source date\n+        Assert.assertNotEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--create\",\n+                \"--file\", JAR_FILE_SOURCE_DATE1.getName(),\n+                \"--date\", sourceDate,\n+                DIR_OUTER.getName()), 0);\n+    }\n+\n+    \/**\n+     * Test jar produces deterministic reproducible output\n+     *\/\n+    @Test(dataProvider = \"validSourceDates\")\n+    public void testJarsReproducible(String sourceDate) throws IOException {\n+        \/\/ Test jars are reproducible across timezones\n+        TimeZone tzAsia = TimeZone.getTimeZone(\"Asia\/Shanghai\");\n+        TimeZone tzLA = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n+        TimeZone.setDefault(tzAsia);\n+        Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--create\",\n+                \"--file\", JAR_FILE_SOURCE_DATE1.getName(),\n+                \"--date\", sourceDate,\n+                DIR_OUTER.getName()), 0);\n+        Assert.assertTrue(JAR_FILE_SOURCE_DATE1.exists());\n+\n+        try {\n+            \/\/ Sleep 5 seconds to ensure jar timestamps might be different if they could be\n+            Thread.sleep(5000);\n+        } catch (InterruptedException ex) {\n+        }\n+\n+        TimeZone.setDefault(tzLA);\n+        Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--create\",\n+                \"--file\", JAR_FILE_SOURCE_DATE2.getName(),\n+                \"--date\", sourceDate,\n+                DIR_OUTER.getName()), 0);\n+        Assert.assertTrue(JAR_FILE_SOURCE_DATE2.exists());\n+\n+        \/\/ Check jars are identical\n+        Assert.assertEquals(Files.readAllBytes(JAR_FILE_SOURCE_DATE1.toPath()),\n+                Files.readAllBytes(JAR_FILE_SOURCE_DATE2.toPath()));\n+    }\n+\n+    \/**\n+     * Create the standard directory structure used by the test:\n+     * outer\/\n+     * inner\/\n+     * foo.txt\n+     *\/\n+    static void createOuterInnerDirs() throws IOException {\n+        Assert.assertTrue(DIR_OUTER.mkdir());\n+        Assert.assertTrue(DIR_INNER.mkdir());\n+        try (PrintWriter pw = new PrintWriter(FILE_INNER)) {\n+            pw.println(\"hello, world\");\n+        }\n+        Assert.assertTrue(DIR_OUTER.exists());\n+        Assert.assertTrue(DIR_INNER.exists());\n+        Assert.assertTrue(FILE_INNER.exists());\n+    }\n+\n+    \/**\n+     * Check the extracted and original millis since Epoch file times are\n+     * within the zip precision time period.\n+     *\/\n+    static void checkFileTime(long now, long original) {\n+        if (isTimeSettingChanged()) {\n+            return;\n+        }\n+\n+        if (Math.abs(now - original) > PRECISION) {\n+            \/\/ If original time is after UNIX 2038 32bit rollover\n+            \/\/ and the now time is exactly the rollover time, then assume\n+            \/\/ running on a file system that only supports to 2038 (e.g.XFS) and pass test\n+            if (FileTime.fromMillis(original).toInstant().isAfter(UNIX_2038_ROLLOVER) &&\n+                    FileTime.fromMillis(now).toInstant().equals(UNIX_2038_ROLLOVER)) {\n+                System.out.println(\"Checking file time after Unix 2038 rollover,\" +\n+                        \" and extracted file time is \" + UNIX_2038_ROLLOVER_TIME + \", \" +\n+                        \" Assuming restricted file system, pass file time check.\");\n+            } else {\n+                throw new AssertionError(\"checkFileTime failed,\" +\n+                        \" extracted to \" + FileTime.fromMillis(now) +\n+                        \", expected to be close to \" + FileTime.fromMillis(original));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Has the timezone or DST changed during the test?\n+     *\/\n+    private static boolean isTimeSettingChanged() {\n+        TimeZone currentTZ = TimeZone.getDefault();\n+        boolean currentDST = currentTZ.inDaylightTime(new Date());\n+        if (!currentTZ.equals(TZ) || currentDST != DST) {\n+            System.out.println(\"Timezone or DST has changed during \" +\n+                    \"ReproducibleJar testcase execution. Test skipped\");\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Is the Zone currently within the transition change period?\n+     *\/\n+    private static boolean isInTransition() {\n+        var inTransition = false;\n+        var date = new Date();\n+        var defZone = ZoneId.systemDefault();\n+        if (defZone.getRules().getTransition(\n+                date.toInstant().atZone(defZone).toLocalDateTime()) != null) {\n+            System.out.println(\"ReproducibleJar testcase being run during Zone offset transition.  Test skipped.\");\n+            inTransition = true;\n+        }\n+        return inTransition;\n+    }\n+\n+    \/**\n+     * Remove the directory and its contents\n+     *\/\n+    static void cleanup(File dir) {\n+        File[] x = dir.listFiles();\n+        if (x != null) {\n+            for (File f : x) {\n+                f.delete();\n+            }\n+        }\n+        dir.delete();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/ReproducibleJar.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764\n+ * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764 8276766\n@@ -186,0 +186,2 @@\n+        Path jmod = MODS_DIR.resolve(\"foo.jmod\");\n+        FileUtils.deleteFileIfExistsWithRetry(jmod);\n@@ -188,1 +190,1 @@\n-             MODS_DIR.resolve(\"foo.jmod\").toString())\n+             jmod.toString())\n@@ -192,1 +194,1 @@\n-             MODS_DIR.resolve(\"foo.jmod\").toString())\n+             jmod.toString())\n@@ -214,0 +216,58 @@\n+    @Test\n+    public void testSourceDateReproducible() throws IOException {\n+        String cp = EXPLODED_DIR.resolve(\"foo\").resolve(\"classes\").toString();\n+        Path jmod1 = MODS_DIR.resolve(\"foo1.jmod\");\n+        Path jmod2 = MODS_DIR.resolve(\"foo2.jmod\");\n+        Path jmod3 = MODS_DIR.resolve(\"foo3.jmod\");\n+        FileUtils.deleteFileIfExistsWithRetry(jmod1);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod2);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod3);\n+\n+        \/\/ Use source date of 15\/03\/2022\n+        String sourceDate = \"2022-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod1.toString())\n+            .assertSuccess();\n+\n+        try {\n+            \/\/ Sleep 5 seconds to ensure zip timestamps might be different if they could be\n+            Thread.sleep(5000);\n+        } catch(InterruptedException ex) {}\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod2.toString())\n+            .assertSuccess();\n+\n+        \/\/ Compare file byte content to see if they are identical\n+        assertSameContent(jmod1, jmod2);\n+\n+        \/\/ Use a date before 1980 and assert failure error\n+        sourceDate = \"1976-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod3.toString())\n+            .assertFailure()\n+            .resultChecker(r -> {\n+                assertContains(r.output, \"is out of the valid range\");\n+            });\n+\n+        \/\/ Use a date after 2099 and assert failure error\n+        sourceDate = \"2100-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod3.toString())\n+            .assertFailure()\n+            .resultChecker(r -> {\n+                assertContains(r.output, \"is out of the valid range\");\n+            });\n+    }\n+\n","filename":"test\/jdk\/tools\/jmod\/JmodTest.java","additions":64,"deletions":4,"binary":false,"changes":68,"status":"modified"}]}