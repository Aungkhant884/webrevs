{"files":[{"patch":"@@ -94,0 +94,1 @@\n+  BasicType bt = access.type();\n@@ -98,1 +99,1 @@\n-    if (access.type() == T_DOUBLE) {\n+    if (bt == T_DOUBLE) {\n@@ -103,2 +104,2 @@\n-    store = kit->store_to_memory(kit->control(), access.addr().node(), val.node(), access.type(),\n-                                     access.addr().type(), mo, requires_atomic_access, unaligned, mismatched, unsafe);\n+    store = kit->store_to_memory(kit->control(), access.addr().node(), val.node(), bt,\n+                                 access.addr().type(), mo, requires_atomic_access, unaligned, mismatched, unsafe);\n@@ -106,1 +107,0 @@\n-    assert(!requires_atomic_access, \"not yet supported\");\n@@ -116,1 +116,1 @@\n-    StoreNode* st = StoreNode::make(gvn, ctl, mem, access.addr().node(), adr_type, val.node(), access.type(), mo);\n+    StoreNode* st = StoreNode::make(gvn, ctl, mem, access.addr().node(), adr_type, val.node(), bt, mo, requires_atomic_access);\n@@ -159,1 +159,0 @@\n-      assert(!requires_atomic_access, \"can't ensure atomicity\");\n@@ -163,2 +162,2 @@\n-                            adr_type, val_type, access.type(), mo, dep, unaligned,\n-                            mismatched, unsafe, access.barrier_data());\n+                            adr_type, val_type, access.type(), mo, dep, requires_atomic_access,\n+                            unaligned, mismatched, unsafe, access.barrier_data());\n@@ -172,1 +171,0 @@\n-    assert(!requires_atomic_access, \"not yet supported\");\n@@ -179,2 +177,2 @@\n-    load = LoadNode::make(gvn, control, mem, adr, adr_type, val_type, access.type(), mo,\n-                          dep, unaligned, mismatched, unsafe, access.barrier_data());\n+    load = LoadNode::make(gvn, control, mem, adr, adr_type, val_type, access.type(), mo, dep,\n+                          requires_atomic_access, unaligned, mismatched, unsafe, access.barrier_data());\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1540,8 +1540,1 @@\n-  Node* ld;\n-  if (require_atomic_access && bt == T_LONG) {\n-    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);\n-  } else if (require_atomic_access && bt == T_DOUBLE) {\n-    ld = LoadDNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);\n-  } else {\n-    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);\n-  }\n+  Node* ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, require_atomic_access, unaligned, mismatched, unsafe, barrier_data);\n@@ -1567,8 +1560,1 @@\n-  Node* st;\n-  if (require_atomic_access && bt == T_LONG) {\n-    st = StoreLNode::make_atomic(ctl, mem, adr, adr_type, val, mo);\n-  } else if (require_atomic_access && bt == T_DOUBLE) {\n-    st = StoreDNode::make_atomic(ctl, mem, adr, adr_type, val, mo);\n-  } else {\n-    st = StoreNode::make(_gvn, ctl, mem, adr, adr_type, val, bt, mo);\n-  }\n+  Node* st = StoreNode::make(_gvn, ctl, mem, adr, adr_type, val, bt, mo, require_atomic_access);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -361,6 +361,1 @@\n-  Node* ld;\n-  if (require_atomic_access && bt == T_LONG) {\n-    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo);\n-  } else {\n-    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo);\n-  }\n+  Node* ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, LoadNode::DependsOnlyOnTest, require_atomic_access);\n@@ -378,6 +373,1 @@\n-  Node* st;\n-  if (require_atomic_access && bt == T_LONG) {\n-    st = StoreLNode::make_atomic(ctl, mem, adr, adr_type, val, mo);\n-  } else {\n-    st = StoreNode::make(_gvn, ctl, mem, adr, adr_type, val, bt, mo);\n-  }\n+  Node* st = StoreNode::make(_gvn, ctl, mem, adr, adr_type, val, bt, mo, require_atomic_access);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1020,1 +1020,1 @@\n-                         false \/*unaligned*\/, is_mismatched));\n+                         false \/*require_atomic_access*\/, false \/*unaligned*\/, is_mismatched));\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -864,2 +864,2 @@\n-Node *LoadNode::make(PhaseGVN& gvn, Node *ctl, Node *mem, Node *adr, const TypePtr* adr_type, const Type *rt, BasicType bt, MemOrd mo,\n-                     ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {\n+Node* LoadNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, const Type* rt, BasicType bt, MemOrd mo,\n+                     ControlDependency control_dependency, bool require_atomic_access, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {\n@@ -887,1 +887,1 @@\n-  case T_LONG:    load = new LoadLNode (ctl, mem, adr, adr_type, rt->is_long(), mo, control_dependency); break;\n+  case T_LONG:    load = new LoadLNode (ctl, mem, adr, adr_type, rt->is_long(), mo, control_dependency, require_atomic_access); break;\n@@ -889,1 +889,1 @@\n-  case T_DOUBLE:  load = new LoadDNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency); break;\n+  case T_DOUBLE:  load = new LoadDNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency, require_atomic_access); break;\n@@ -925,36 +925,0 @@\n-LoadLNode* LoadLNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, const Type* rt, MemOrd mo,\n-                                  ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {\n-  bool require_atomic = true;\n-  LoadLNode* load = new LoadLNode(ctl, mem, adr, adr_type, rt->is_long(), mo, control_dependency, require_atomic);\n-  if (unaligned) {\n-    load->set_unaligned_access();\n-  }\n-  if (mismatched) {\n-    load->set_mismatched_access();\n-  }\n-  if (unsafe) {\n-    load->set_unsafe_access();\n-  }\n-  load->set_barrier_data(barrier_data);\n-  return load;\n-}\n-\n-LoadDNode* LoadDNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, const Type* rt, MemOrd mo,\n-                                  ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {\n-  bool require_atomic = true;\n-  LoadDNode* load = new LoadDNode(ctl, mem, adr, adr_type, rt, mo, control_dependency, require_atomic);\n-  if (unaligned) {\n-    load->set_unaligned_access();\n-  }\n-  if (mismatched) {\n-    load->set_mismatched_access();\n-  }\n-  if (unsafe) {\n-    load->set_unsafe_access();\n-  }\n-  load->set_barrier_data(barrier_data);\n-  return load;\n-}\n-\n-\n-\n@@ -1291,1 +1255,1 @@\n-                        is_unaligned_access(), is_mismatched_access());\n+                        false \/*require_atomic_access*\/, is_unaligned_access(), is_mismatched_access());\n@@ -1311,1 +1275,1 @@\n-                        is_unaligned_access(), is_mismatched_access());\n+                        false \/*require_atomic_access*\/, is_unaligned_access(), is_mismatched_access());\n@@ -1334,0 +1298,3 @@\n+  const int op = Opcode();\n+  bool require_atomic_access = (op == Op_LoadL && ((LoadLNode*)this)->require_atomic_access()) ||\n+                               (op == Op_LoadD && ((LoadDNode*)this)->require_atomic_access());\n@@ -1336,1 +1303,1 @@\n-                        is_unaligned_access(), is_mismatched);\n+                        require_atomic_access, is_unaligned_access(), is_mismatched);\n@@ -1354,1 +1321,5 @@\n-  StoreNode* st = StoreNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address), raw_adr_type(), val, bt, _mo);\n+  const int op = Opcode();\n+  bool require_atomic_access = (op == Op_StoreL && ((StoreLNode*)this)->require_atomic_access()) ||\n+                               (op == Op_StoreD && ((StoreDNode*)this)->require_atomic_access());\n+  StoreNode* st = StoreNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address),\n+                                  raw_adr_type(), val, bt, _mo, require_atomic_access);\n@@ -2591,1 +2562,1 @@\n-StoreNode* StoreNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, BasicType bt, MemOrd mo) {\n+StoreNode* StoreNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, BasicType bt, MemOrd mo, bool require_atomic_access) {\n@@ -2603,1 +2574,1 @@\n-  case T_LONG:    return new StoreLNode(ctl, mem, adr, adr_type, val, mo);\n+  case T_LONG:    return new StoreLNode(ctl, mem, adr, adr_type, val, mo, require_atomic_access);\n@@ -2605,1 +2576,1 @@\n-  case T_DOUBLE:  return new StoreDNode(ctl, mem, adr, adr_type, val, mo);\n+  case T_DOUBLE:  return new StoreDNode(ctl, mem, adr, adr_type, val, mo, require_atomic_access);\n@@ -2629,11 +2600,0 @@\n-StoreLNode* StoreLNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo) {\n-  bool require_atomic = true;\n-  return new StoreLNode(ctl, mem, adr, adr_type, val, mo, require_atomic);\n-}\n-\n-StoreDNode* StoreDNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo) {\n-  bool require_atomic = true;\n-  return new StoreDNode(ctl, mem, adr, adr_type, val, mo, require_atomic);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":18,"deletions":58,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-  static Node* make(PhaseGVN& gvn, Node *c, Node *mem, Node *adr,\n-                    const TypePtr* at, const Type *rt, BasicType bt,\n+  static Node* make(PhaseGVN& gvn, Node* c, Node* mem, Node* adr,\n+                    const TypePtr* at, const Type* rt, BasicType bt,\n@@ -232,1 +232,1 @@\n-                    bool unaligned = false, bool mismatched = false, bool unsafe = false,\n+                    bool require_atomic_access = false, bool unaligned = false, bool mismatched = false, bool unsafe = false,\n@@ -418,3 +418,1 @@\n-  static LoadLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,\n-                                const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,\n-                                bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);\n+\n@@ -470,3 +468,1 @@\n-  static LoadDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,\n-                                const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,\n-                                bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);\n+\n@@ -613,2 +609,3 @@\n-  static StoreNode* make(PhaseGVN& gvn, Node *c, Node *mem, Node *adr,\n-                         const TypePtr* at, Node *val, BasicType bt, MemOrd mo);\n+  static StoreNode* make(PhaseGVN& gvn, Node* c, Node* mem, Node* adr,\n+                         const TypePtr* at, Node* val, BasicType bt,\n+                         MemOrd mo, bool require_atomic_access = false);\n@@ -695,1 +692,1 @@\n-  static StoreLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);\n+\n@@ -731,1 +728,1 @@\n-  static StoreDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8251871\n+ * @bug 8251871 8285301\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -53,0 +53,2 @@\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+AlwaysAtomicAccesses\n+ *      compiler.arraycopy.TestArrayCopyConjoint\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyConjoint.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8251871\n+ * @bug 8251871 8285301\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=600 -XX:-TieredCompilation  -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions\n@@ -53,0 +53,2 @@\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+UnlockExperimentalVMOptions -XX:+AlwaysAtomicAccesses\n+ *      compiler.arraycopy.TestArrayCopyDisjoint\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyDisjoint.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6700100 8156760 8248226\n+ * @bug 6700100 8156760 8248226 8285301\n@@ -45,0 +45,4 @@\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileCommand=dontinline,compiler.arraycopy.TestInstanceCloneAsLoadsStores::m*\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+AlwaysAtomicAccesses\n+ *                   compiler.arraycopy.TestInstanceCloneAsLoadsStores\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestInstanceCloneAsLoadsStores.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test TestAlwaysAtomicAccesses\n+ * @bug 8285301\n+ * @summary Test memory accesses from compiled code with AlwaysAtomicAccesses.\n+ * @run main\/othervm -Xcomp -XX:+UnlockExperimentalVMOptions -XX:+AlwaysAtomicAccesses\n+ *                   compiler.membars.TestAlwaysAtomicAccesses\n+ *\/\n+\n+package compiler.membars;\n+\n+public class TestAlwaysAtomicAccesses {\n+\n+    public static void main(String[] args) {\n+        \/\/ Nothing to do here. Compilations are triggered by -Xcomp.\n+        System.out.println(\"Test passed\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestAlwaysAtomicAccesses.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"}]}