{"files":[{"patch":"@@ -1015,7 +1015,9 @@\n-  void set_rounding(int mode) {\n-    \/\/ fesetround is broken on windows\n-    NOT_WINDOWS(fesetround(mode);)\n-  }\n-\n-  void check_frequency(float f) {\n-    NOT_WINDOWS(assert(f <= 1 && f >= 0, \"Incorrect frequency\");)\n+  float check_and_truncate_frequency(float f) {\n+    assert(f >= 0, \"Incorrect frequency\");\n+    \/\/ We do not perform an exact (f <= 1) check\n+    \/\/ this would be error prone with rounding of floats.\n+    \/\/ Performing a check like (f <= 1+eps) would be of benefit,\n+    \/\/ however, it is not evident how to determine such an eps,\n+    \/\/ given that an arbitrary number of add\/mul operations\n+    \/\/ are performed on these frequencies.\n+    return (f > 1) ? 1 : f;\n@@ -1031,1 +1033,0 @@\n-    set_rounding(FE_TOWARDZERO); \/\/ make sure rounding doesn't push frequency above 1\n@@ -1058,1 +1059,0 @@\n-              set_rounding(FE_UPWARD);  \/\/ make sure rounding doesn't push frequency above 1\n@@ -1065,1 +1065,0 @@\n-              set_rounding(FE_TOWARDZERO);\n@@ -1085,1 +1084,1 @@\n-              check_frequency(this_exit_f);\n+              this_exit_f = check_and_truncate_frequency(this_exit_f);\n@@ -1087,1 +1086,1 @@\n-              check_frequency(f);\n+              f = check_and_truncate_frequency(f);\n@@ -1100,1 +1099,1 @@\n-              check_frequency(f);\n+              f = check_and_truncate_frequency(f);\n@@ -1108,1 +1107,1 @@\n-            check_frequency(f);\n+            f = check_and_truncate_frequency(f);\n@@ -1121,3 +1120,1 @@\n-          set_rounding(FE_TONEAREST);\n-          check_frequency(f);\n-          return f;\n+          return check_and_truncate_frequency(f);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"}]}