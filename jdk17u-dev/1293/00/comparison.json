{"files":[{"patch":"@@ -145,1 +145,1 @@\n-  AddNode *progress = NULL;             \/\/ Progress flag\n+  AddNode *progress = nullptr;             \/\/ Progress flag\n@@ -249,1 +249,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -261,1 +261,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -289,1 +289,1 @@\n-      Node *sub  = new SubINode(NULL, NULL);\n+      Node *sub  = new SubINode(nullptr, nullptr);\n@@ -352,1 +352,1 @@\n-      in1->in(1) != NULL && in1->in(1) == in2->in(1)) {\n+      in1->in(1) != nullptr && in1->in(1) == in2->in(1)) {\n@@ -355,1 +355,1 @@\n-    if (rshift != NULL && lshift != NULL) {\n+    if (rshift != nullptr && lshift != nullptr) {\n@@ -358,2 +358,2 @@\n-      if (lshift_t != NULL && lshift_t->is_con() &&\n-          rshift_t != NULL && rshift_t->is_con() &&\n+      if (lshift_t != nullptr && lshift_t->is_con() &&\n+          rshift_t != nullptr && rshift_t->is_con() &&\n@@ -444,1 +444,1 @@\n-      Node *sub  = new SubLNode(NULL, NULL);\n+      Node *sub  = new SubLNode(nullptr, nullptr);\n@@ -482,1 +482,1 @@\n-      in1->in(1) != NULL && in1->in(1) == in2->in(1)) {\n+      in1->in(1) != nullptr && in1->in(1) == in2->in(1)) {\n@@ -485,1 +485,1 @@\n-    if (rshift != NULL && lshift != NULL) {\n+    if (rshift != nullptr && lshift != nullptr) {\n@@ -488,2 +488,2 @@\n-      if (lshift_t != NULL && lshift_t->is_con() &&\n-          rshift_t != NULL && rshift_t->is_con() &&\n+      if (lshift_t != nullptr && lshift_t->is_con() &&\n+          rshift_t != nullptr && rshift_t->is_con() &&\n@@ -561,1 +561,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -576,1 +576,1 @@\n-  return commute(phase, this) ? this : NULL;\n+  return commute(phase, this) ? this : nullptr;\n@@ -593,1 +593,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -607,1 +607,1 @@\n-  return commute(phase, this) ? this : NULL;\n+  return commute(phase, this) ? this : nullptr;\n@@ -621,1 +621,1 @@\n-  if( phase->type( in(Address) ) == Type::TOP ) return NULL;\n+  if( phase->type( in(Address) ) == Type::TOP ) return nullptr;\n@@ -632,1 +632,1 @@\n-    if( t == Type::TOP ) return NULL;\n+    if( t == Type::TOP ) return nullptr;\n@@ -637,1 +637,1 @@\n-      if( temp_t2 == Type::TOP ) return NULL;\n+      if( temp_t2 == Type::TOP ) return nullptr;\n@@ -658,1 +658,1 @@\n-    \/\/ If this is a NULL+long form (from unsafe accesses), switch to a rawptr.\n+    \/\/ If this is a null+long form (from unsafe accesses), switch to a rawptr.\n@@ -684,1 +684,1 @@\n-  return NULL;                  \/\/ No progress\n+  return nullptr;                  \/\/ No progress\n@@ -690,1 +690,1 @@\n-  if (in(Address) == NULL)  return TypePtr::BOTTOM;\n+  if (in(Address) == nullptr)  return TypePtr::BOTTOM;\n@@ -728,1 +728,1 @@\n-\/\/ Return the base, or NULL if failure.\n+\/\/ Return the base, or null if failure.\n@@ -744,1 +744,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -794,2 +794,2 @@\n-  if (lshift_t != NULL && lshift_t->is_con() &&\n-      rshift_t != NULL && rshift_t->is_con() &&\n+  if (lshift_t != nullptr && lshift_t->is_con() &&\n+      rshift_t != nullptr && rshift_t->is_con() &&\n@@ -802,1 +802,1 @@\n-    if (shift_t != NULL && shift_t->is_con() &&\n+    if (shift_t != nullptr && shift_t->is_con() &&\n@@ -807,1 +807,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -818,1 +818,1 @@\n-    if (shift != NULL) {\n+    if (shift != nullptr) {\n@@ -821,1 +821,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -828,1 +828,1 @@\n-    if (shift != NULL) {\n+    if (shift != nullptr) {\n@@ -832,1 +832,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -884,1 +884,1 @@\n-    if (shift != NULL) {\n+    if (shift != nullptr) {\n@@ -887,1 +887,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -894,1 +894,1 @@\n-    if (shift != NULL) {\n+    if (shift != nullptr) {\n@@ -898,1 +898,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1041,2 +1041,2 @@\n-  assert(is_int == (gvn.type(b)->isa_int() != NULL), \"inconsistent inputs\");\n-  Node* hook = NULL;\n+  assert(is_int == (gvn.type(b)->isa_int() != nullptr), \"inconsistent inputs\");\n+  Node* hook = nullptr;\n@@ -1049,1 +1049,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -1093,1 +1093,1 @@\n-  if (hook != NULL) {\n+  if (hook != nullptr) {\n@@ -1102,2 +1102,2 @@\n-  assert(is_int == (gvn.type(b)->isa_int() != NULL), \"inconsistent inputs\");\n-  Node* zero = NULL;\n+  assert(is_int == (gvn.type(b)->isa_int() != nullptr), \"inconsistent inputs\");\n+  Node* zero = nullptr;\n@@ -1109,1 +1109,1 @@\n-  Node* hook = NULL;\n+  Node* hook = nullptr;\n@@ -1116,1 +1116,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -1142,1 +1142,1 @@\n-  if (hook != NULL) {\n+  if (hook != nullptr) {\n@@ -1172,1 +1172,1 @@\n-  Node *progress = NULL;\n+  Node *progress = nullptr;\n@@ -1193,1 +1193,1 @@\n-    if( t == Type::TOP ) return NULL;  \/\/ No progress\n+    if( t == Type::TOP ) return nullptr;  \/\/ No progress\n@@ -1205,1 +1205,1 @@\n-    if( t == Type::TOP ) return NULL;  \/\/ No progress\n+    if( t == Type::TOP ) return nullptr;  \/\/ No progress\n@@ -1223,1 +1223,1 @@\n-      if( t == Type::TOP ) return NULL;  \/\/ No progress\n+      if( t == Type::TOP ) return nullptr;  \/\/ No progress\n@@ -1233,1 +1233,1 @@\n-    if (x == y && tx != NULL &&\n+    if (x == y && tx != nullptr &&\n@@ -1241,1 +1241,1 @@\n-    if (x == y && tx != NULL &&\n+    if (x == y && tx != nullptr &&\n@@ -1247,1 +1247,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),\n+  : CallNode(arraycopy_type(), nullptr, TypePtr::BOTTOM),\n@@ -134,1 +134,1 @@\n-      assert (ary_src != NULL, \"not an array or instance?\");\n+      assert (ary_src != nullptr, \"not an array or instance?\");\n@@ -177,1 +177,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -187,2 +187,2 @@\n-  if (inst_src == NULL) {\n-    return NULL;\n+  if (inst_src == nullptr) {\n+    return nullptr;\n@@ -267,2 +267,2 @@\n-    if (ary_src  == NULL || ary_src->klass()  == NULL ||\n-        ary_dest == NULL || ary_dest->klass() == NULL) {\n+    if (ary_src  == nullptr || ary_src->klass()  == nullptr ||\n+        ary_dest == nullptr || ary_dest->klass() == nullptr) {\n@@ -321,1 +321,1 @@\n-    assert(ary_src != NULL, \"should be a clone\");\n+    assert(ary_src != nullptr, \"should be a clone\");\n@@ -369,1 +369,1 @@\n-    assert(src_offset != NULL && dest_offset != NULL, \"should be\");\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"should be\");\n@@ -486,1 +486,1 @@\n-      if (callprojs.fallthrough_ioproj != NULL) {\n+      if (callprojs.fallthrough_ioproj != nullptr) {\n@@ -489,1 +489,1 @@\n-      if (callprojs.fallthrough_memproj != NULL) {\n+      if (callprojs.fallthrough_memproj != nullptr) {\n@@ -492,1 +492,1 @@\n-      if (callprojs.fallthrough_catchproj != NULL) {\n+      if (callprojs.fallthrough_catchproj != nullptr) {\n@@ -522,1 +522,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -534,1 +534,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -537,7 +537,7 @@\n-  assert(in(TypeFunc::Control) != NULL &&\n-         in(TypeFunc::Memory) != NULL &&\n-         in(ArrayCopyNode::Src) != NULL &&\n-         in(ArrayCopyNode::Dest) != NULL &&\n-         in(ArrayCopyNode::Length) != NULL &&\n-         in(ArrayCopyNode::SrcPos) != NULL &&\n-         in(ArrayCopyNode::DestPos) != NULL, \"broken inputs\");\n+  assert(in(TypeFunc::Control) != nullptr &&\n+         in(TypeFunc::Memory) != nullptr &&\n+         in(ArrayCopyNode::Src) != nullptr &&\n+         in(ArrayCopyNode::Dest) != nullptr &&\n+         in(ArrayCopyNode::Length) != nullptr &&\n+         in(ArrayCopyNode::SrcPos) != nullptr &&\n+         in(ArrayCopyNode::DestPos) != nullptr, \"broken inputs\");\n@@ -549,3 +549,3 @@\n-      (in(ArrayCopyNode::SrcPos) != NULL && in(ArrayCopyNode::SrcPos)->is_top()) ||\n-      (in(ArrayCopyNode::DestPos) != NULL && in(ArrayCopyNode::DestPos)->is_top())) {\n-    return NULL;\n+      (in(ArrayCopyNode::SrcPos) != nullptr && in(ArrayCopyNode::SrcPos)->is_top()) ||\n+      (in(ArrayCopyNode::DestPos) != nullptr && in(ArrayCopyNode::DestPos)->is_top())) {\n+    return nullptr;\n@@ -557,1 +557,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -561,2 +561,2 @@\n-  if (mem != NULL) {\n-    return (mem == NodeSentinel) ? NULL : mem;\n+  if (mem != nullptr) {\n+    return (mem == NodeSentinel) ? nullptr : mem;\n@@ -565,4 +565,4 @@\n-  Node* adr_src = NULL;\n-  Node* base_src = NULL;\n-  Node* adr_dest = NULL;\n-  Node* base_dest = NULL;\n+  Node* adr_src = nullptr;\n+  Node* base_src = nullptr;\n+  Node* adr_dest = nullptr;\n+  Node* base_dest = nullptr;\n@@ -570,1 +570,1 @@\n-  const Type* value_type = NULL;\n+  const Type* value_type = nullptr;\n@@ -576,3 +576,3 @@\n-    assert(adr_src == NULL, \"no node can be left behind\");\n-    assert(adr_dest == NULL, \"no node can be left behind\");\n-    return NULL;\n+    assert(adr_src == nullptr, \"no node can be left behind\");\n+    assert(adr_dest == nullptr, \"no node can be left behind\");\n+    return nullptr;\n@@ -608,1 +608,1 @@\n-  Node* ctl = NULL;\n+  Node* ctl = nullptr;\n@@ -645,1 +645,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -670,1 +670,1 @@\n-  if (n != NULL &&\n+  if (n != nullptr &&\n@@ -688,2 +688,2 @@\n-  CallNode* call = NULL;\n-  guarantee(c != NULL, \"step_over_gc_barrier failed, there must be something to step to.\");\n+  CallNode* call = nullptr;\n+  guarantee(c != nullptr, \"step_over_gc_barrier failed, there must be something to step to.\");\n@@ -692,1 +692,1 @@\n-      if (c->in(i) != NULL) {\n+      if (c->in(i) != nullptr) {\n@@ -706,1 +706,1 @@\n-    assert(c == mb->in(0) || (ac != NULL && ac->is_clonebasic() && !use_ReduceInitialCardMarks), \"only for clone\");\n+    assert(c == mb->in(0) || (ac != nullptr && ac->is_clonebasic() && !use_ReduceInitialCardMarks), \"only for clone\");\n@@ -733,1 +733,1 @@\n-  if (dest_pos_t == NULL || len_t == NULL || ary_t == NULL) {\n+  if (dest_pos_t == nullptr || len_t == nullptr || ary_t == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,2 +145,2 @@\n-                             Node* src_klass = NULL, Node* dest_klass = NULL,\n-                             Node* src_length = NULL, Node* dest_length = NULL);\n+                             Node* src_klass = nullptr, Node* dest_klass = nullptr,\n+                             Node* src_length = nullptr, Node* dest_length = nullptr);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    _blocks[0] = NULL;\n+    _blocks[0] = nullptr;\n@@ -316,1 +316,1 @@\n-      if (cfg != NULL) {\n+      if (cfg != nullptr) {\n@@ -335,1 +335,1 @@\n-  if ((cfg != NULL) && bh->is_Loop() && !head()->is_Root()) {\n+  if ((cfg != nullptr) && bh->is_Loop() && !head()->is_Root()) {\n@@ -362,1 +362,1 @@\n-  dump(NULL);\n+  dump(nullptr);\n@@ -378,1 +378,1 @@\n-, _regalloc(NULL)\n+, _regalloc(nullptr)\n@@ -382,1 +382,1 @@\n-, _node_latency(NULL)\n+, _node_latency(nullptr)\n@@ -394,1 +394,1 @@\n-  Node *x = new GotoNode(NULL);\n+  Node *x = new GotoNode(nullptr);\n@@ -397,1 +397,1 @@\n-  assert(_goto != NULL, \"\");\n+  assert(_goto != nullptr, \"\");\n@@ -430,1 +430,1 @@\n-    if (x == NULL) {                    \/\/ Does not end right...\n+    if (x == nullptr) {                    \/\/ Does not end right...\n@@ -664,1 +664,1 @@\n-  if (bx == NULL) return false;\n+  if (bx == nullptr) return false;\n@@ -851,1 +851,1 @@\n-    Block* bnext = (i < number_of_blocks() - 1) ? get_block(i + 1) : NULL;\n+    Block* bnext = (i < number_of_blocks() - 1) ? get_block(i + 1) : nullptr;\n@@ -1210,1 +1210,1 @@\n-        Node *n2 = NULL;\n+        Node *n2 = nullptr;\n@@ -1239,1 +1239,1 @@\n-        \/\/ If anything has been inserted (n2 != NULL), continue after last node inserted.\n+        \/\/ If anything has been inserted (n2 != nullptr), continue after last node inserted.\n@@ -1298,1 +1298,1 @@\n-    if (block != NULL) {\n+    if (block != nullptr) {\n@@ -1318,1 +1318,1 @@\n-  } while (home_or_ancestor != NULL);\n+  } while (home_or_ancestor != nullptr);\n@@ -1371,1 +1371,1 @@\n-              !(n->jvms() != NULL && n->jvms()->is_monitor_use(k))) {\n+              !(n->jvms() != nullptr && n->jvms()->is_monitor_use(k))) {\n@@ -1395,1 +1395,1 @@\n-        assert(parent != NULL, \"projections must have a parent\");\n+        assert(parent != nullptr, \"projections must have a parent\");\n@@ -1489,1 +1489,1 @@\n-  for (Block *b = first_block(); b != NULL; b = next(b)) {\n+  for (Block *b = first_block(); b != nullptr; b = next(b)) {\n@@ -1567,1 +1567,1 @@\n-  Trace *tr = NULL;\n+  Trace *tr = nullptr;\n@@ -1596,1 +1596,1 @@\n-      traces[n->_pre_order] = NULL;\n+      traces[n->_pre_order] = nullptr;\n@@ -1622,1 +1622,1 @@\n-    traces[b->_pre_order] = NULL;\n+    traces[b->_pre_order] = nullptr;\n@@ -1648,1 +1648,1 @@\n-  traces[hi_id] = NULL;\n+  traces[hi_id] = nullptr;\n@@ -1779,1 +1779,1 @@\n-    if (tr != NULL) {\n+    if (tr != nullptr) {\n@@ -1795,1 +1795,1 @@\n-    if (tr != NULL) {\n+    if (tr != nullptr) {\n@@ -1859,1 +1859,1 @@\n-      for (b = last_block(); b != NULL; b = prev(b)) {\n+      for (b = last_block(); b != nullptr; b = prev(b)) {\n@@ -1865,1 +1865,1 @@\n-      if (b != last_block() && b != NULL) {\n+      if (b != last_block() && b != nullptr) {\n@@ -1877,1 +1877,1 @@\n-    for (Block *b = targ_block; b != NULL; b = next(b)) {\n+    for (Block *b = targ_block; b != nullptr; b = next(b)) {\n@@ -1907,1 +1907,1 @@\n-  for (Block *b = first_block(); b != NULL; b = next(b)) {\n+  for (Block *b = first_block(); b != nullptr; b = next(b)) {\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-\/\/ Abstractly provides an infinite array of Block*'s, initialized to NULL.\n+\/\/ Abstractly provides an infinite array of Block*'s, initialized to null.\n@@ -63,1 +63,1 @@\n-      _blocks[i] = NULL;\n+      _blocks[i] = nullptr;\n@@ -66,2 +66,2 @@\n-  Block *lookup( uint i ) const \/\/ Lookup, or NULL for not mapped\n-  { return (i<Max()) ? _blocks[i] : (Block*)NULL; }\n+  Block *lookup( uint i ) const \/\/ Lookup, or null for not mapped\n+  { return (i<Max()) ? _blocks[i] : (Block*)nullptr; }\n@@ -117,1 +117,1 @@\n-  \/\/ Get the node at index 'at_index', if 'at_index' is out of bounds return NULL\n+  \/\/ Get the node at index 'at_index', if 'at_index' is out of bounds return null\n@@ -285,1 +285,1 @@\n-      _loop(NULL),\n+      _loop(nullptr),\n@@ -463,2 +463,2 @@\n-  \/\/ Detect implicit-null-check opportunities.  Basically, find NULL checks\n-  \/\/ with suitable memory ops nearby.  Use the memory op to do the NULL check.\n+  \/\/ Detect implicit-null-check opportunities.  Basically, find null checks\n+  \/\/ with suitable memory ops nearby.  Use the memory op to do the null check.\n@@ -575,1 +575,1 @@\n-    _node_to_block_mapping.map(node->_idx, NULL);\n+    _node_to_block_mapping.map(node->_idx, nullptr);\n@@ -585,1 +585,1 @@\n-    return (_node_to_block_mapping.lookup(node->_idx) != NULL);\n+    return (_node_to_block_mapping.lookup(node->_idx) != nullptr);\n@@ -688,1 +688,1 @@\n-  BlockProbPair() : _target(NULL), _prob(0.0) {}\n+  BlockProbPair() : _target(nullptr), _prob(0.0) {}\n@@ -713,3 +713,3 @@\n-    _parent(NULL),\n-    _sibling(NULL),\n-    _child(NULL),\n+    _parent(nullptr),\n+    _sibling(nullptr),\n+    _child(nullptr),\n@@ -728,1 +728,1 @@\n-  Block* backedge_block(); \/\/ Return the block on the backedge of the loop (else NULL)\n+  Block* backedge_block(); \/\/ Return the block on the backedge of the loop (else null)\n@@ -816,2 +816,2 @@\n-    set_prev(_first, NULL);\n-    set_next(_last, NULL);\n+    set_prev(_first, nullptr);\n+    set_next(_last, nullptr);\n@@ -828,2 +828,2 @@\n-    set_next(b, NULL);\n-    set_prev(b, NULL);\n+    set_next(b, nullptr);\n+    set_prev(b, nullptr);\n@@ -845,1 +845,1 @@\n-    if (next(b) != NULL) {\n+    if (next(b) != nullptr) {\n@@ -859,1 +859,1 @@\n-    assert(p != NULL, \"use append instead\");\n+    assert(p != nullptr, \"use append instead\");\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-\/\/ practice.  One array will map to a reaching def Node (or NULL for\n+\/\/ practice.  One array will map to a reaching def Node (or null for\n@@ -83,1 +83,1 @@\n-                                \/\/ or NULL if dead\/conflict\n+                                \/\/ or null if dead\/conflict\n@@ -88,1 +88,1 @@\n-                                \/\/ or NULL if dead\/conflict\n+                                \/\/ or null if dead\/conflict\n@@ -92,1 +92,1 @@\n-    _b(NULL), _next(NULL), C(c) { }\n+    _b(nullptr), _next(nullptr), C(c) { }\n@@ -169,1 +169,1 @@\n-  assert( _b == NULL, \"merging into a happy flow\" );\n+  assert( _b == nullptr, \"merging into a happy flow\" );\n@@ -174,1 +174,1 @@\n-  \/\/ is OptoReg::Bad or NULL depending.\n+  \/\/ is OptoReg::Bad or null depending.\n@@ -181,1 +181,1 @@\n-      _defs[i] = NULL;\n+      _defs[i] = nullptr;\n@@ -217,1 +217,1 @@\n-  MachCallNode *mcall = n->is_MachCall() ? n->as_MachCall() : NULL;\n+  MachCallNode *mcall = n->is_MachCall() ? n->as_MachCall() : nullptr;\n@@ -459,1 +459,1 @@\n-        MachNode *m = n->is_Mach() ? n->as_Mach() : NULL;\n+        MachNode *m = n->is_Mach() ? n->as_Mach() : nullptr;\n@@ -482,1 +482,1 @@\n-            const TypePtr *adr_type = NULL;\n+            const TypePtr *adr_type = nullptr;\n@@ -493,1 +493,1 @@\n-              \/\/ (base == NULL) OR the fp is used in a non-memory context\n+              \/\/ (base == nullptr) OR the fp is used in a non-memory context\n@@ -549,1 +549,1 @@\n-        if (block->get_node(j)->jvms() && (*safehash)[block->get_node(j)] == NULL) {\n+        if (block->get_node(j)->jvms() && (*safehash)[block->get_node(j)] == nullptr) {\n@@ -584,1 +584,1 @@\n-  Dict *safehash = NULL;        \/\/ Used for assert only\n+  Dict *safehash = nullptr;        \/\/ Used for assert only\n@@ -589,1 +589,1 @@\n-  OopFlow *free_list = NULL;    \/\/ Free, unused\n+  OopFlow *free_list = nullptr;    \/\/ Free, unused\n@@ -633,1 +633,1 @@\n-    OopFlow *flow = NULL;       \/\/ Flag for finding optimized flow\n+    OopFlow *flow = nullptr;       \/\/ Flag for finding optimized flow\n@@ -667,1 +667,1 @@\n-      assert( flow->_b == NULL, \"oopFlow is not free\" );\n+      assert( flow->_b == nullptr, \"oopFlow is not free\" );\n@@ -669,1 +669,1 @@\n-      flow->_next = NULL;\n+      flow->_next = nullptr;\n@@ -679,1 +679,1 @@\n-    flow->_b = NULL;\n+    flow->_b = nullptr;\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  _caller_jvms(NULL),\n+  _caller_jvms(nullptr),\n@@ -51,2 +51,2 @@\n-  _subtrees(c->comp_arena(), 2, 0, NULL),\n-  _msg(NULL)\n+  _subtrees(c->comp_arena(), 2, 0, nullptr),\n+  _msg(nullptr)\n@@ -58,1 +58,1 @@\n-  if (caller_jvms != NULL) {\n+  if (caller_jvms != nullptr) {\n@@ -65,1 +65,1 @@\n-  assert((caller_tree == NULL ? 0 : caller_tree->stack_depth() + 1) == stack_depth(), \"correct (redundant) depth parameter\");\n+  assert((caller_tree == nullptr ? 0 : caller_tree->stack_depth() + 1) == stack_depth(), \"correct (redundant) depth parameter\");\n@@ -69,1 +69,1 @@\n-  for( ; caller != NULL; caller = ((InlineTree *)(caller->caller_tree())) ) {\n+  for( ; caller != nullptr; caller = ((InlineTree *)(caller->caller_tree())) ) {\n@@ -200,1 +200,1 @@\n-  const char* fail_msg = NULL;\n+  const char* fail_msg = nullptr;\n@@ -216,1 +216,1 @@\n-  if (fail_msg == NULL && callee_method->has_unloaded_classes_in_signature()) {\n+  if (fail_msg == nullptr && callee_method->has_unloaded_classes_in_signature()) {\n@@ -220,1 +220,1 @@\n-  if (fail_msg != NULL) {\n+  if (fail_msg != nullptr) {\n@@ -275,1 +275,1 @@\n-  if (caller_tree() != NULL &&\n+  if (caller_tree() != nullptr &&\n@@ -278,1 +278,1 @@\n-    while (top->caller_tree() != NULL) top = top->caller_tree();\n+    while (top->caller_tree() != nullptr) top = top->caller_tree();\n@@ -439,2 +439,2 @@\n-    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : NULL;\n-    for (JVMState* j = jvms->caller(); j != NULL && j->has_method(); j = j->caller()) {\n+    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : nullptr;\n+    for (JVMState* j = jvms->caller(); j != nullptr && j->has_method(); j = j->caller()) {\n@@ -479,1 +479,1 @@\n-  if (callee_method == NULL) {\n+  if (callee_method == nullptr) {\n@@ -521,1 +521,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -528,2 +528,2 @@\n-  assert(inline_msg != NULL, \"just checking\");\n-  if (C->log() != NULL) {\n+  assert(inline_msg != nullptr, \"just checking\");\n+  if (C->log() != nullptr) {\n@@ -540,1 +540,1 @@\n-    guarantee(callee_method != NULL, \"would crash in CompilerEvent::InlineEvent::post\");\n+    guarantee(callee_method != nullptr, \"would crash in CompilerEvent::InlineEvent::post\");\n@@ -543,1 +543,1 @@\n-      while (top->caller_tree() != NULL) { top = top->caller_tree(); }\n+      while (top->caller_tree() != nullptr) { top = top->caller_tree(); }\n@@ -556,1 +556,1 @@\n-  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n+  assert(callee_method != nullptr, \"caller checks for optimized virtual!\");\n@@ -561,2 +561,2 @@\n-  if (jvms->caller() == NULL) {\n-    assert(_caller_jvms == NULL, \"redundant instance state\");\n+  if (jvms->caller() == nullptr) {\n+    assert(_caller_jvms == nullptr, \"redundant instance state\");\n@@ -580,1 +580,1 @@\n-  if (msg() != NULL) {\n+  if (msg() != nullptr) {\n@@ -590,1 +590,1 @@\n-    if (msg() == NULL) {\n+    if (msg() == nullptr) {\n@@ -598,1 +598,1 @@\n-    if (msg() == NULL) {\n+    if (msg() == nullptr) {\n@@ -610,1 +610,1 @@\n-  if (old_ilt != NULL) {\n+  if (old_ilt != nullptr) {\n@@ -614,1 +614,1 @@\n-  if (caller_jvms->method() != NULL) {\n+  if (caller_jvms->method() != nullptr) {\n@@ -649,1 +649,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -658,1 +658,1 @@\n-  InlineTree* ilt = new InlineTree(C, NULL, C->method(), NULL, -1, MaxInlineLevel);\n+  InlineTree* ilt = new InlineTree(C, nullptr, C->method(), nullptr, -1, MaxInlineLevel);\n@@ -677,1 +677,1 @@\n-    if (sub == NULL) {\n+    if (sub == nullptr) {\n@@ -681,1 +681,1 @@\n-      guarantee(sub != NULL, \"should be a sub-ilt here\");\n+      guarantee(sub != nullptr, \"should be a sub-ilt here\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-  notproduct(ccstr, PrintIdealGraphFile, NULL,                              \\\n+  notproduct(ccstr, PrintIdealGraphFile, nullptr,                           \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    if (C.failure_reason() != NULL) {\n+    if (C.failure_reason() != nullptr) {\n@@ -217,1 +217,1 @@\n-    if (StubRoutines::unsafe_arraycopy() == NULL) return false;\n+    if (StubRoutines::unsafe_arraycopy() == nullptr) return false;\n@@ -430,1 +430,1 @@\n-    if (vmClasses::reflect_CallerSensitive_klass() == NULL) return false;\n+    if (vmClasses::reflect_CallerSensitive_klass() == nullptr) return false;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    assert(InlineTree::check_can_parse(method) == NULL, \"parse must be possible\");\n+    assert(InlineTree::check_can_parse(method) == nullptr, \"parse must be possible\");\n@@ -96,1 +96,1 @@\n-    return NULL;  \/\/ bailing out of the compile; do not try to parse\n+    return nullptr;  \/\/ bailing out of the compile; do not try to parse\n@@ -104,2 +104,2 @@\n-    while (exits.pop_exception_state() != NULL) ;\n-    return NULL;\n+    while (exits.pop_exception_state() != nullptr) ;\n+    return nullptr;\n@@ -150,1 +150,1 @@\n-  if (kit.C->log() != NULL) {\n+  if (kit.C->log() != nullptr) {\n@@ -198,1 +198,1 @@\n-    : CallGenerator(method), _vtable_index(vtable_index), _separate_io_proj(separate_io_proj), _call_node(NULL)\n+    : CallGenerator(method), _vtable_index(vtable_index), _separate_io_proj(separate_io_proj), _call_node(nullptr)\n@@ -222,1 +222,1 @@\n-  if (kit.C->log() != NULL) {\n+  if (kit.C->log() != nullptr) {\n@@ -238,1 +238,1 @@\n-                      NULL, \"null receiver\");\n+                      nullptr, \"null receiver\");\n@@ -247,1 +247,1 @@\n-  ciMethodData *caller_md = (caller == NULL) ? NULL : caller->method_data();\n+  ciMethodData *caller_md = (caller == nullptr) ? nullptr : caller->method_data();\n@@ -291,1 +291,1 @@\n-  if (InlineTree::check_can_parse(m) != NULL)  return NULL;\n+  if (InlineTree::check_can_parse(m) != nullptr)  return nullptr;\n@@ -299,1 +299,1 @@\n-  if (InlineTree::check_can_parse(m) != NULL)  return NULL;\n+  if (InlineTree::check_can_parse(m) != nullptr)  return nullptr;\n@@ -391,1 +391,1 @@\n-    LateInlineCallGenerator(callee, NULL), _caller(caller), _input_not_const(input_not_const) {}\n+    LateInlineCallGenerator(callee, nullptr), _caller(caller), _input_not_const(input_not_const) {}\n@@ -432,1 +432,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -469,1 +469,1 @@\n-    _unique_id(0), _inline_cg(NULL), _callee(NULL), _is_pure_call(false), _prof_factor(prof_factor) {\n+    _unique_id(0), _inline_cg(nullptr), _callee(nullptr), _is_pure_call(false), _prof_factor(prof_factor) {\n@@ -481,1 +481,1 @@\n-    assert(_callee == NULL, \"repeated inlining attempt\");\n+    assert(_callee == nullptr, \"repeated inlining attempt\");\n@@ -491,1 +491,1 @@\n-    if (call_node() != NULL) {\n+    if (call_node() != nullptr) {\n@@ -551,1 +551,1 @@\n-                                        NULL \/*speculative_receiver_type*\/,\n+                                        nullptr \/*speculative_receiver_type*\/,\n@@ -554,1 +554,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -581,1 +581,1 @@\n-  assert(_callee != NULL, \"required\"); \/\/ set up in CallDynamicJavaNode::Ideal\n+  assert(_callee != nullptr, \"required\"); \/\/ set up in CallDynamicJavaNode::Ideal\n@@ -646,2 +646,2 @@\n-  if (call == NULL || call->outcnt() == 0 ||\n-      call->in(0) == NULL || call->in(0)->is_top()) {\n+  if (call == nullptr || call->outcnt() == 0 ||\n+      call->in(0) == nullptr || call->in(0)->is_top()) {\n@@ -679,2 +679,2 @@\n-      (callprojs.resproj != NULL && call->find_edge(callprojs.resproj) != -1) ||\n-      (callprojs.exobj   != NULL && call->find_edge(callprojs.exobj) != -1)) {\n+      (callprojs.resproj != nullptr && call->find_edge(callprojs.resproj) != -1) ||\n+      (callprojs.exobj   != nullptr && call->find_edge(callprojs.exobj) != -1)) {\n@@ -704,1 +704,1 @@\n-    result_not_used = (callprojs.resproj == NULL || callprojs.resproj->outcnt() == 0);\n+    result_not_used = (callprojs.resproj == nullptr || callprojs.resproj->outcnt() == 0);\n@@ -757,1 +757,1 @@\n-    if (old_nn != NULL) {\n+    if (old_nn != nullptr) {\n@@ -765,1 +765,1 @@\n-    if (new_jvms == NULL)  return;  \/\/ no change\n+    if (new_jvms == nullptr)  return;  \/\/ no change\n@@ -936,1 +936,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -951,1 +951,1 @@\n-  Node* slow_ctl = NULL;\n+  Node* slow_ctl = nullptr;\n@@ -960,2 +960,2 @@\n-  SafePointNode* slow_map = NULL;\n-  JVMState* slow_jvms = NULL;\n+  SafePointNode* slow_map = nullptr;\n+  JVMState* slow_jvms = nullptr;\n@@ -967,2 +967,2 @@\n-        return NULL;  \/\/ might happen because of NodeCountInliningCutoff\n-      assert(slow_jvms != NULL, \"must be\");\n+        return nullptr;  \/\/ might happen because of NodeCountInliningCutoff\n+      assert(slow_jvms != nullptr, \"must be\");\n@@ -987,1 +987,1 @@\n-  if (new_jvms == NULL) {\n+  if (new_jvms == nullptr) {\n@@ -997,1 +997,1 @@\n-  if (slow_map == NULL) {\n+  if (slow_map == nullptr) {\n@@ -1057,1 +1057,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -1092,1 +1092,1 @@\n-  if (call == NULL) return NULL;\n+  if (call == nullptr) return nullptr;\n@@ -1095,1 +1095,1 @@\n-  if (kit.C->log() != NULL) {\n+  if (kit.C->log() != nullptr) {\n@@ -1119,1 +1119,1 @@\n-        if (recv_toop != NULL) {\n+        if (recv_toop != nullptr) {\n@@ -1126,1 +1126,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -1163,1 +1163,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1177,1 +1177,1 @@\n-          if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {\n+          if (arg_type != nullptr && !arg_type->higher_equal(sig_type)) {\n@@ -1190,1 +1190,1 @@\n-            if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {\n+            if (arg_type != nullptr && !arg_type->higher_equal(sig_type)) {\n@@ -1205,1 +1205,1 @@\n-        ciKlass* speculative_receiver_type = NULL;\n+        ciKlass* speculative_receiver_type = nullptr;\n@@ -1220,1 +1220,1 @@\n-          speculative_receiver_type = (receiver_type != NULL) ? receiver_type->speculative_type() : NULL;\n+          speculative_receiver_type = (receiver_type != nullptr) ? receiver_type->speculative_type() : nullptr;\n@@ -1257,1 +1257,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1292,1 +1292,1 @@\n-  \/\/    if (receiver == NULL)\n+  \/\/    if (receiver == nullptr)\n@@ -1307,1 +1307,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1351,1 +1351,1 @@\n-      if (new_jvms == NULL) {\n+      if (new_jvms == nullptr) {\n@@ -1362,1 +1362,1 @@\n-    if (else_ctrl == NULL) {\n+    if (else_ctrl == nullptr) {\n@@ -1377,2 +1377,2 @@\n-      return NULL;  \/\/ might happen because of NodeCountInliningCutoff\n-    assert(new_jvms != NULL, \"must be\");\n+      return nullptr;  \/\/ might happen because of NodeCountInliningCutoff\n+    assert(new_jvms != nullptr, \"must be\");\n@@ -1441,1 +1441,1 @@\n-      Node* m = NULL;\n+      Node* m = nullptr;\n@@ -1511,1 +1511,1 @@\n-    kit.uncommon_trap(_reason, _action, NULL, \"monomorphic vcall checkcast\", false, keep_exact_action);\n+    kit.uncommon_trap(_reason, _action, nullptr, \"monomorphic vcall checkcast\", false, keep_exact_action);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -47,3 +47,3 @@\n-  virtual bool           do_late_inline_check(Compile* C, JVMState* jvms) { ShouldNotReachHere(); return false; }\n-  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return NULL;  }\n-  virtual bool           is_pure_call() const                             { ShouldNotReachHere(); return false; }\n+  virtual bool           do_late_inline_check(Compile* C, JVMState* jvms) { ShouldNotReachHere(); return false;  }\n+  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return nullptr;}\n+  virtual bool           is_pure_call() const                             { ShouldNotReachHere(); return false;  }\n@@ -84,1 +84,1 @@\n-  virtual CallNode* call_node() const { return NULL; }\n+  virtual CallNode* call_node() const { return nullptr; }\n@@ -123,1 +123,1 @@\n-  \/\/ If the result is NULL, it means that this CallGenerator was unable\n+  \/\/ If the result is null, it means that this CallGenerator was unable\n@@ -173,1 +173,1 @@\n-  virtual Node* generate_predicate(JVMState* jvms, int predicate) { return NULL; };\n+  virtual Node* generate_predicate(JVMState* jvms, int predicate) { return nullptr; };\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -102,1 +102,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -179,1 +179,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -224,1 +224,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -264,1 +264,1 @@\n-  assert(method != NULL, \"must be valid call site\");\n+  assert(method != nullptr, \"must be valid call site\");\n@@ -270,1 +270,1 @@\n-  _depth  = 1 + (caller == NULL ? 0 : caller->depth());\n+  _depth  = 1 + (caller == nullptr ? 0 : caller->depth());\n@@ -279,1 +279,1 @@\n-  _method(NULL) {\n+  _method(nullptr) {\n@@ -283,1 +283,1 @@\n-  _caller = NULL;\n+  _caller = nullptr;\n@@ -312,1 +312,1 @@\n-    if (p->_method == NULL)          return true;   \/\/ bci is irrelevant\n+    if (p->_method == nullptr)       return true;   \/\/ bci is irrelevant\n@@ -318,1 +318,1 @@\n-    assert(p != NULL && q != NULL, \"depth check ensures we don't run off end\");\n+    assert(p != nullptr && q != nullptr, \"depth check ensures we don't run off end\");\n@@ -339,1 +339,1 @@\n-  for (const JVMState* jvmp = this; jvmp != NULL; jvmp = jvmp->caller()) {\n+  for (const JVMState* jvmp = this; jvmp != nullptr; jvmp = jvmp->caller()) {\n@@ -351,1 +351,1 @@\n-  if (n == NULL) { st->print(\" NULL\"); return; }\n+  if (n == nullptr) { st->print(\" null\"); return; }\n@@ -374,1 +374,1 @@\n-      st->print(\" %s%d]=#NULL\",msg,i);\n+      st->print(\" %s%d]=#null\",msg,i);\n@@ -475,1 +475,1 @@\n-      ciInstanceKlass *iklass = NULL;\n+      ciInstanceKlass *iklass = nullptr;\n@@ -503,1 +503,1 @@\n-        if (iklass != NULL) {\n+        if (iklass != nullptr) {\n@@ -513,1 +513,1 @@\n-          if (iklass != NULL) {\n+          if (iklass != nullptr) {\n@@ -527,1 +527,1 @@\n-  if (caller() != NULL) caller()->format(regalloc, n, st);\n+  if (caller() != nullptr) caller()->format(regalloc, n, st);\n@@ -532,1 +532,1 @@\n-  if (_method != NULL) {\n+  if (_method != nullptr) {\n@@ -544,2 +544,2 @@\n-        if (endcn == NULL)  endcn = strchr(name, '(');\n-        if (endcn == NULL)  endcn = name + strlen(name);\n+        if (endcn == nullptr)  endcn = strchr(name, '(');\n+        if (endcn == nullptr)  endcn = name + strlen(name);\n@@ -558,1 +558,1 @@\n-  if (caller() != NULL)  caller()->dump_spec(st);\n+  if (caller() != nullptr)  caller()->dump_spec(st);\n@@ -564,1 +564,1 @@\n-                  ((caller() == NULL) || (caller()->map() != _map));\n+                  ((caller() == nullptr) || (caller()->map() != _map));\n@@ -569,1 +569,1 @@\n-      while (ex != NULL && ex->len() > ex->req()) {\n+      while (ex != nullptr && ex->len() > ex->req()) {\n@@ -576,1 +576,1 @@\n-  if (caller() != NULL) {\n+  if (caller() != nullptr) {\n@@ -581,1 +581,1 @@\n-  if (_method == NULL) {\n+  if (_method == nullptr) {\n@@ -618,1 +618,1 @@\n-  for (JVMState* p = n; p->_caller != NULL; p = p->_caller) {\n+  for (JVMState* p = n; p->_caller != nullptr; p = p->_caller) {\n@@ -630,1 +630,1 @@\n-  for (JVMState* p = this; p != NULL; p = p->_caller) {\n+  for (JVMState* p = this; p != nullptr; p = p->_caller) {\n@@ -644,1 +644,1 @@\n-  for (JVMState* jvms = this; jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = this; jvms != nullptr; jvms = jvms->caller()) {\n@@ -663,1 +663,1 @@\n-  while (jvms != NULL) {\n+  while (jvms != nullptr) {\n@@ -703,1 +703,1 @@\n-  if (tf() != NULL)  tf()->dump_on(st);\n+  if (tf() != nullptr)  tf()->dump_on(st);\n@@ -705,1 +705,1 @@\n-  if (jvms() != NULL)  jvms()->dump_spec(st);\n+  if (jvms() != nullptr)  jvms()->dump_spec(st);\n@@ -767,1 +767,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -780,1 +780,1 @@\n-  assert((t_oop != NULL), \"sanity\");\n+  assert((t_oop != nullptr), \"sanity\");\n@@ -783,1 +783,1 @@\n-    Node* dest = NULL;\n+    Node* dest = nullptr;\n@@ -796,1 +796,1 @@\n-    guarantee(dest != NULL, \"Call had only one ptr in, broken IR!\");\n+    guarantee(dest != nullptr, \"Call had only one ptr in, broken IR!\");\n@@ -812,1 +812,1 @@\n-      if ((proj == NULL) || (phase->type(proj)->is_instptr()->klass() != boxing_klass)) {\n+      if ((proj == nullptr) || (phase->type(proj)->is_instptr()->klass() != boxing_klass)) {\n@@ -816,1 +816,1 @@\n-    if (is_CallJava() && as_CallJava()->method() != NULL) {\n+    if (is_CallJava() && as_CallJava()->method() != nullptr) {\n@@ -823,2 +823,2 @@\n-      Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : NULL;\n-      if (proj != NULL) {\n+      Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : nullptr;\n+      if (proj != nullptr) {\n@@ -826,1 +826,1 @@\n-        if ((inst_t != NULL) && (!inst_t->klass_is_exact() ||\n+        if ((inst_t != nullptr) && (!inst_t->klass_is_exact() ||\n@@ -834,1 +834,1 @@\n-        if ((inst_t != NULL) && (!inst_t->klass_is_exact() ||\n+        if ((inst_t != nullptr) && (!inst_t->klass_is_exact() ||\n@@ -859,1 +859,1 @@\n-\/\/ or returns NULL if there is no one.\n+\/\/ or returns null if there is no one.\n@@ -861,1 +861,1 @@\n-  Node *cast = NULL;\n+  Node *cast = nullptr;\n@@ -864,2 +864,2 @@\n-  if (p == NULL)\n-    return NULL;\n+  if (p == nullptr)\n+    return nullptr;\n@@ -870,1 +870,1 @@\n-      if (cast != NULL) {\n+      if (cast != nullptr) {\n@@ -889,9 +889,9 @@\n-  projs->fallthrough_proj      = NULL;\n-  projs->fallthrough_catchproj = NULL;\n-  projs->fallthrough_ioproj    = NULL;\n-  projs->catchall_ioproj       = NULL;\n-  projs->catchall_catchproj    = NULL;\n-  projs->fallthrough_memproj   = NULL;\n-  projs->catchall_memproj      = NULL;\n-  projs->resproj               = NULL;\n-  projs->exobj                 = NULL;\n+  projs->fallthrough_proj      = nullptr;\n+  projs->fallthrough_catchproj = nullptr;\n+  projs->fallthrough_ioproj    = nullptr;\n+  projs->catchall_ioproj       = nullptr;\n+  projs->catchall_catchproj    = nullptr;\n+  projs->fallthrough_memproj   = nullptr;\n+  projs->catchall_memproj      = nullptr;\n+  projs->resproj               = nullptr;\n+  projs->exobj                 = nullptr;\n@@ -908,2 +908,2 @@\n-        if (cn != NULL && cn->is_Catch()) {\n-          ProjNode *cpn = NULL;\n+        if (cn != nullptr && cn->is_Catch()) {\n+          ProjNode *cpn = nullptr;\n@@ -931,1 +931,1 @@\n-          assert(projs->exobj == NULL, \"only one\");\n+          assert(projs->exobj == nullptr, \"only one\");\n@@ -953,1 +953,1 @@\n-  assert(projs->fallthrough_proj      != NULL, \"must be found\");\n+  assert(projs->fallthrough_proj      != nullptr, \"must be found\");\n@@ -955,4 +955,4 @@\n-  assert(!do_asserts || projs->fallthrough_catchproj != NULL, \"must be found\");\n-  assert(!do_asserts || projs->fallthrough_memproj   != NULL, \"must be found\");\n-  assert(!do_asserts || projs->fallthrough_ioproj    != NULL, \"must be found\");\n-  assert(!do_asserts || projs->catchall_catchproj    != NULL, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_catchproj != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_memproj   != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_ioproj    != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->catchall_catchproj    != nullptr, \"must be found\");\n@@ -960,2 +960,2 @@\n-    assert(!do_asserts || projs->catchall_memproj    != NULL, \"must be found\");\n-    assert(!do_asserts || projs->catchall_ioproj     != NULL, \"must be found\");\n+    assert(!do_asserts || projs->catchall_memproj    != nullptr, \"must be found\");\n+    assert(!do_asserts || projs->catchall_ioproj     != nullptr, \"must be found\");\n@@ -969,1 +969,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -978,1 +978,1 @@\n-  if (_name != NULL && strstr(_name, \"arraycopy\") != 0) {\n+  if (_name != nullptr && strstr(_name, \"arraycopy\") != 0) {\n@@ -1006,1 +1006,1 @@\n-    if (old_in != NULL && old_in->is_SafePointScalarObject()) {\n+    if (old_in != nullptr && old_in->is_SafePointScalarObject()) {\n@@ -1020,2 +1020,2 @@\n-  set_jvms(sfpt->jvms() != NULL ? sfpt->jvms()->clone_deep(C) : NULL);\n-  for (JVMState *jvms = this->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  set_jvms(sfpt->jvms() != nullptr ? sfpt->jvms()->clone_deep(C) : nullptr);\n+  for (JVMState *jvms = this->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -1033,1 +1033,1 @@\n-  if (method() == NULL) {\n+  if (method() == nullptr) {\n@@ -1070,1 +1070,1 @@\n-  if (can_reshape && cg != NULL) {\n+  if (can_reshape && cg != nullptr) {\n@@ -1081,1 +1081,1 @@\n-        set_generator(NULL);\n+        set_generator(nullptr);\n@@ -1087,1 +1087,1 @@\n-        set_generator(NULL);\n+        set_generator(nullptr);\n@@ -1093,1 +1093,1 @@\n-        set_generator(NULL);\n+        set_generator(nullptr);\n@@ -1103,1 +1103,1 @@\n-  if (_name != NULL && !strcmp(_name, \"uncommon_trap\")) {\n+  if (_name != nullptr && !strcmp(_name, \"uncommon_trap\")) {\n@@ -1111,1 +1111,1 @@\n-        call->in(TypeFunc::Parms) != NULL &&\n+        call->in(TypeFunc::Parms) != nullptr &&\n@@ -1125,1 +1125,1 @@\n-  if (_name != NULL) {\n+  if (_name != nullptr) {\n@@ -1159,1 +1159,1 @@\n-  if (can_reshape && cg != NULL) {\n+  if (can_reshape && cg != nullptr) {\n@@ -1192,1 +1192,1 @@\n-      set_generator(NULL);\n+      set_generator(nullptr);\n@@ -1264,1 +1264,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1381,1 +1381,1 @@\n-  assert(n == NULL || n->Opcode() == Op_SafePoint, \"correct value for next_exception\");\n+  assert(n == nullptr || n->Opcode() == Op_SafePoint, \"correct value for next_exception\");\n@@ -1383,1 +1383,1 @@\n-    if (n != NULL)  add_prec(n);\n+    if (n != nullptr)  add_prec(n);\n@@ -1393,1 +1393,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1396,1 +1396,1 @@\n-    assert(n == NULL || n->Opcode() == Op_SafePoint, \"no other uses of prec edges\");\n+    assert(n == nullptr || n->Opcode() == Op_SafePoint, \"no other uses of prec edges\");\n@@ -1405,2 +1405,2 @@\n-  assert(_jvms == NULL || ((uintptr_t)_jvms->map() & 1) || _jvms->map() == this, \"inconsistent JVMState\");\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  assert(_jvms == nullptr || ((uintptr_t)_jvms->map() & 1) || _jvms->map() == this, \"inconsistent JVMState\");\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -1418,1 +1418,1 @@\n-    if (out_c != NULL && !out_c->is_OuterStripMinedLoopEnd()) {\n+    if (out_c != nullptr && !out_c->is_OuterStripMinedLoopEnd()) {\n@@ -1614,1 +1614,1 @@\n-  if (cached != NULL) {\n+  if (cached != nullptr) {\n@@ -1639,1 +1639,1 @@\n-  : CallNode(atype, NULL, TypeRawPtr::BOTTOM)\n+  : CallNode(atype, nullptr, TypeRawPtr::BOTTOM)\n@@ -1663,1 +1663,1 @@\n-  assert(initializer != NULL &&\n+  assert(initializer != nullptr &&\n@@ -1668,1 +1668,1 @@\n-  if (analyzer == NULL) {\n+  if (analyzer == nullptr) {\n@@ -1678,1 +1678,1 @@\n-  Node* mark_node = NULL;\n+  Node* mark_node = nullptr;\n@@ -1692,1 +1692,1 @@\n-\/\/ a CastII is appropriate, return NULL.\n+\/\/ a CastII is appropriate, return null.\n@@ -1695,1 +1695,1 @@\n-  assert(length != NULL, \"length is not null\");\n+  assert(length != nullptr, \"length is not null\");\n@@ -1700,1 +1700,1 @@\n-  if (ary_type != NULL && length_type != NULL) {\n+  if (ary_type != nullptr && length_type != nullptr) {\n@@ -1713,1 +1713,1 @@\n-      \/\/ Return NULL if new nodes are not allowed\n+      \/\/ Return null if new nodes are not allowed\n@@ -1715,1 +1715,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1720,1 +1720,1 @@\n-      if (init != NULL) {\n+      if (init != nullptr) {\n@@ -1861,2 +1861,2 @@\n-  if (ctrl == NULL)\n-    return NULL;\n+  if (ctrl == nullptr)\n+    return nullptr;\n@@ -1867,1 +1867,1 @@\n-      if (n == NULL)\n+      if (n == nullptr)\n@@ -1890,2 +1890,2 @@\n-  ProjNode *ctrl_proj = (ctrl->is_Proj()) ? ctrl->as_Proj() : NULL;\n-  if (ctrl_proj != NULL && ctrl_proj->_con == TypeFunc::Control) {\n+  ProjNode *ctrl_proj = (ctrl->is_Proj()) ? ctrl->as_Proj() : nullptr;\n+  if (ctrl_proj != nullptr && ctrl_proj->_con == TypeFunc::Control) {\n@@ -1893,1 +1893,1 @@\n-    if (n != NULL && n->is_Unlock()) {\n+    if (n != nullptr && n->is_Unlock()) {\n@@ -1913,1 +1913,1 @@\n-  LockNode *lock_result = NULL;\n+  LockNode *lock_result = nullptr;\n@@ -1917,1 +1917,1 @@\n-    assert(ctrl != NULL, \"invalid control graph\");\n+    assert(ctrl != nullptr, \"invalid control graph\");\n@@ -1925,1 +1925,1 @@\n-      if (ctrl->req() == 3 && ctrl->in(1) != NULL && ctrl->in(2) != NULL) {\n+      if (ctrl->req() == 3 && ctrl->in(1) != nullptr && ctrl->in(2) != nullptr) {\n@@ -1964,1 +1964,1 @@\n-      Node* lock1_node = NULL;\n+      Node* lock1_node = nullptr;\n@@ -1975,1 +1975,1 @@\n-      if (lock1_node != NULL && lock1_node->is_Lock()) {\n+      if (lock1_node != nullptr && lock1_node->is_Lock()) {\n@@ -2000,1 +2000,1 @@\n-    if (in_node != NULL) {\n+    if (in_node != nullptr) {\n@@ -2065,1 +2065,1 @@\n-  \/\/ perform any generic optimizations first (returns 'this' or NULL)\n+  \/\/ perform any generic optimizations first (returns 'this' or null)\n@@ -2067,1 +2067,1 @@\n-  if (result != NULL)  return result;\n+  if (result != nullptr)  return result;\n@@ -2069,1 +2069,1 @@\n-  if (in(0) && in(0)->is_top())  return NULL;\n+  if (in(0) && in(0)->is_top())  return nullptr;\n@@ -2081,1 +2081,1 @@\n-    if (cgr != NULL && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n@@ -2100,1 +2100,1 @@\n-    if (iter != NULL && !is_eliminated()) {\n+    if (iter != nullptr && !is_eliminated()) {\n@@ -2180,1 +2180,1 @@\n-  return is_nested_lock_region(NULL);\n+  return is_nested_lock_region(nullptr);\n@@ -2183,1 +2183,1 @@\n-\/\/ p is used for access to compilation log; no logging if NULL\n+\/\/ p is used for access to compilation log; no logging if null\n@@ -2196,2 +2196,2 @@\n-  LockNode* unique_lock = NULL;\n-  Node* bad_lock = NULL;\n+  LockNode* unique_lock = nullptr;\n+  Node* bad_lock = nullptr;\n@@ -2206,1 +2206,1 @@\n-    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\", (unique_lock != NULL ? unique_lock : bad_lock));\n+    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\", (unique_lock != nullptr ? unique_lock : bad_lock));\n@@ -2215,1 +2215,1 @@\n-      if (unique_lock != NULL) {\n+      if (unique_lock != nullptr) {\n@@ -2219,1 +2219,1 @@\n-      if (bad_lock != NULL) {\n+      if (bad_lock != nullptr) {\n@@ -2260,1 +2260,1 @@\n-  \/\/ perform any generic optimizations first (returns 'this' or NULL)\n+  \/\/ perform any generic optimizations first (returns 'this' or null)\n@@ -2262,1 +2262,1 @@\n-  if (result != NULL)  return result;\n+  if (result != nullptr)  return result;\n@@ -2264,1 +2264,1 @@\n-  if (in(0) && in(0)->is_top())  return NULL;\n+  if (in(0) && in(0)->is_top())  return nullptr;\n@@ -2277,1 +2277,1 @@\n-    if (cgr != NULL && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n@@ -2292,1 +2292,1 @@\n-  if (C == NULL) {\n+  if (C == nullptr) {\n@@ -2296,1 +2296,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -2299,2 +2299,2 @@\n-    int box_id = box != NULL ? box->_idx : -1;\n-    int obj_id = obj != NULL ? obj->_idx : -1;\n+    int box_id = box != nullptr ? box->_idx : -1;\n+    int obj_id = obj != nullptr ? obj->_idx : -1;\n@@ -2305,1 +2305,1 @@\n-          kind_as_string(), box_id, obj_id, (bad_lock != NULL ? bad_lock->_idx : -1));\n+          kind_as_string(), box_id, obj_id, (bad_lock != nullptr ? bad_lock->_idx : -1));\n@@ -2309,1 +2309,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":133,"deletions":133,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  bool              has_method() const { return _method != NULL; }\n+  bool              has_method() const { return _method != nullptr; }\n@@ -340,1 +340,1 @@\n-  assert(s != nullptr, \"assign NULL value to _jvms\");\n+  assert(s != nullptr, \"assign null value to _jvms\");\n@@ -345,2 +345,2 @@\n-                \/\/ A plain safepoint advertises no memory effects (NULL):\n-                const TypePtr* adr_type = NULL)\n+                \/\/ A plain safepoint advertises no memory effects (null):\n+                const TypePtr* adr_type = nullptr)\n@@ -358,1 +358,1 @@\n-    if (jvms() != NULL) {\n+    if (jvms() != nullptr) {\n@@ -437,1 +437,1 @@\n-  bool is_killed() { return in(TypeFunc::Control) == NULL; }\n+  bool is_killed() { return in(TypeFunc::Control) == nullptr; }\n@@ -445,1 +445,1 @@\n-  bool                   has_exceptions() const { return next_exception() != NULL; }\n+  bool                   has_exceptions() const { return next_exception() != nullptr; }\n@@ -536,1 +536,1 @@\n-    assert(jvms != NULL, \"missed JVMS\");\n+    assert(jvms != nullptr, \"missed JVMS\");\n@@ -594,1 +594,1 @@\n-  const char*     _name;        \/\/ Printable name, if _method is NULL\n+  const char*     _name;        \/\/ Printable name, if _method is null\n@@ -601,2 +601,2 @@\n-      _generator(NULL),\n-      _name(NULL)\n+      _generator(nullptr),\n+      _name(nullptr)\n@@ -640,1 +640,1 @@\n-  \/\/ or returns NULL if there is no one.\n+  \/\/ or returns null if there is no one.\n@@ -726,1 +726,1 @@\n-    if (C->eliminate_boxing() && (method != NULL) && method->is_boxing_method()) {\n+    if (C->eliminate_boxing() && (method != nullptr) && method->is_boxing_method()) {\n@@ -732,1 +732,1 @@\n-    : CallJavaNode(tf, addr, NULL) {\n+    : CallJavaNode(tf, addr, nullptr) {\n@@ -744,1 +744,1 @@\n-    return is_macro() && (method() != NULL) && method()->is_boxing_method();\n+    return is_macro() && (method() != nullptr) && method()->is_boxing_method();\n@@ -975,1 +975,1 @@\n-    return (allo == NULL) ? NULL : allo->in(KlassNode);\n+    return (allo == nullptr) ? nullptr : allo->in(KlassNode);\n@@ -996,1 +996,1 @@\n-  \/\/ ArgEscape. In case allocation's InitializeNode is NULL, check\n+  \/\/ ArgEscape. In case allocation's InitializeNode is null, check\n@@ -1001,2 +1001,2 @@\n-    InitializeNode* init = NULL;\n-    return _is_non_escaping || (((init = initialization()) != NULL) && init->does_not_escape());\n+    InitializeNode* init = nullptr;\n+    return _is_non_escaping || (((init = initialization()) != nullptr) && init->does_not_escape());\n@@ -1045,2 +1045,2 @@\n-    return (allo == NULL || !allo->is_AllocateArray())\n-           ? NULL : allo->as_AllocateArray();\n+    return (allo == nullptr || !allo->is_AllocateArray())\n+           ? nullptr : allo->as_AllocateArray();\n@@ -1083,1 +1083,1 @@\n-    : CallNode(tf, NULL, TypeRawPtr::BOTTOM),\n+    : CallNode(tf, nullptr, TypeRawPtr::BOTTOM),\n@@ -1087,1 +1087,1 @@\n-    _counter = NULL;\n+    _counter = nullptr;\n@@ -1106,1 +1106,1 @@\n-  void log_lock_optimization(Compile* c, const char * tag, Node* bad_lock = NULL) const;\n+  void log_lock_optimization(Compile* c, const char * tag, Node* bad_lock = nullptr) const;\n@@ -1181,1 +1181,1 @@\n-    , _dbg_jvms(NULL)\n+    , _dbg_jvms(nullptr)\n@@ -1197,1 +1197,1 @@\n-  JVMState* dbg_jvms() const { return NULL; }\n+  JVMState* dbg_jvms() const { return nullptr; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  if (dom != NULL) {\n+  if (dom != nullptr) {\n@@ -81,1 +81,1 @@\n-  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : NULL;\n+  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : nullptr;\n@@ -128,1 +128,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -142,1 +142,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -147,1 +147,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -152,2 +152,2 @@\n-  if (ctl == NULL) {\n-    return NULL;\n+  if (ctl == nullptr) {\n+    return nullptr;\n@@ -159,1 +159,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -161,2 +161,2 @@\n-  if (type()->isa_rawptr() && (gvn->type_or_null(val) == NULL || gvn->type(val)->isa_oopptr())) {\n-    return NULL;\n+  if (type()->isa_rawptr() && (gvn->type_or_null(val) == nullptr || gvn->type(val)->isa_oopptr())) {\n+    return nullptr;\n@@ -169,1 +169,1 @@\n-        u->in(0) != NULL &&\n+        u->in(0) != nullptr &&\n@@ -183,1 +183,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -201,1 +201,1 @@\n-    if (in(0) != NULL && in(0)->in(0) != NULL && in(0)->in(0)->is_If()) {\n+    if (in(0) != nullptr && in(0)->in(0) != nullptr && in(0)->in(0)->is_If()) {\n@@ -265,1 +265,1 @@\n-  if (existing != NULL) {\n+  if (existing != nullptr) {\n@@ -274,1 +274,1 @@\n-  if (progress != NULL) {\n+  if (progress != nullptr) {\n@@ -281,2 +281,2 @@\n-  const TypeInteger* rx = NULL;\n-  const TypeInteger* ry = NULL;\n+  const TypeInteger* rx = nullptr;\n+  const TypeInteger* ry = nullptr;\n@@ -285,1 +285,1 @@\n-    if (igvn == NULL) {\n+    if (igvn == nullptr) {\n@@ -289,1 +289,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -312,1 +312,1 @@\n-      if (in_type != NULL && this_type != NULL &&\n+      if (in_type != nullptr && this_type != nullptr &&\n@@ -340,1 +340,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -380,1 +380,1 @@\n-  if (dom != NULL) {\n+  if (dom != nullptr) {\n@@ -410,1 +410,1 @@\n-  if( in_type != NULL && my_type != NULL ) {\n+  if( in_type != nullptr && my_type != nullptr ) {\n@@ -450,2 +450,2 @@\n-  \/\/ assert (in_oop == NULL || in_oop->klass() != NULL, \"\");\n-  \/\/ assert (my_oop == NULL || my_oop->klass() != NULL, \"\");\n+  \/\/ assert (in_oop == nullptr || in_oop->klass() != nullptr, \"\");\n+  \/\/ assert (my_oop == nullptr || my_oop->klass() != nullptr, \"\");\n@@ -548,1 +548,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -570,1 +570,1 @@\n-  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : NULL;\n+  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : nullptr;\n@@ -580,1 +580,1 @@\n-  Node* cast= NULL;\n+  Node* cast= nullptr;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,1 @@\n-  CastX2PNode( Node *n ) : Node(NULL, n) {}\n+  CastX2PNode( Node *n ) : Node(nullptr, n) {}\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-    return NULL;\n-  Node *progress = NULL;        \/\/ Progress flag\n+    return nullptr;\n+  Node *progress = nullptr;        \/\/ Progress flag\n@@ -93,1 +93,1 @@\n-          return NULL;        \/\/ Only flatten if no Phi users\n+          return nullptr;        \/\/ Only flatten if no Phi users\n@@ -128,1 +128,1 @@\n-\/\/ Helper function: Return any PhiNode that uses this region or NULL\n+\/\/ Helper function: Return any PhiNode that uses this region or null\n@@ -138,1 +138,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -143,1 +143,1 @@\n-\/\/ Helper function: Return the only PhiNode that uses this region or NULL\n+\/\/ Helper function: Return the only PhiNode that uses this region or null\n@@ -146,1 +146,1 @@\n-  PhiNode* only_phi = NULL;\n+  PhiNode* only_phi = nullptr;\n@@ -151,1 +151,1 @@\n-      if (only_phi == NULL) {\n+      if (only_phi == nullptr) {\n@@ -154,1 +154,1 @@\n-        return NULL;  \/\/ multiple phis\n+        return nullptr;  \/\/ multiple phis\n@@ -167,3 +167,3 @@\n-  min     = NULL;\n-  max     = NULL;\n-  val     = NULL;\n+  min     = nullptr;\n+  max     = nullptr;\n+  val     = nullptr;\n@@ -181,2 +181,2 @@\n-          if( min == NULL ) {\n-            min     = n->Opcode() == Op_ConI ? (ConNode*)n : NULL;\n+          if( min == nullptr ) {\n+            min     = n->Opcode() == Op_ConI ? (ConNode*)n : nullptr;\n@@ -185,1 +185,1 @@\n-            max     = n->Opcode() == Op_ConI ? (ConNode*)n : NULL;\n+            max     = n->Opcode() == Op_ConI ? (ConNode*)n : nullptr;\n@@ -222,2 +222,2 @@\n-  top_if = NULL;\n-  bot_if = NULL;\n+  top_if = nullptr;\n+  bot_if = nullptr;\n@@ -235,3 +235,3 @@\n-    if( in10 != NULL && in10->is_If() &&\n-        in20 != NULL && in20->is_If() &&\n-        in30 != NULL && in30->is_If() && in10 == in20 &&\n+    if( in10 != nullptr && in10->is_If() &&\n+        in20 != nullptr && in20->is_If() &&\n+        in30 != nullptr && in30->is_If() && in10 == in20 &&\n@@ -240,1 +240,1 @@\n-      Node *in1000 = (in100 != NULL && in100->is_Proj()) ? in100->in(0) : NULL;\n+      Node *in1000 = (in100 != nullptr && in100->is_Proj()) ? in100->in(0) : nullptr;\n@@ -242,1 +242,1 @@\n-      if( in1000 != NULL && in1000->is_If() &&\n+      if( in1000 != nullptr && in1000->is_If() &&\n@@ -251,1 +251,1 @@\n-  return (top_if != NULL);\n+  return (top_if != nullptr);\n@@ -259,1 +259,1 @@\n-  convf2i = NULL;\n+  convf2i = nullptr;\n@@ -320,1 +320,1 @@\n-  assert(req() == 2 || (req() == 3 && in(1) != NULL && in(2) == top), \"sanity check arguments\");\n+  assert(req() == 2 || (req() == 3 && in(1) != nullptr && in(2) == top), \"sanity check arguments\");\n@@ -344,1 +344,1 @@\n-    if (n != NULL && n->is_Phi()) {\n+    if (n != nullptr && n->is_Phi()) {\n@@ -354,1 +354,1 @@\n-        if (u != NULL && (u->is_Phi() || u->is_CFG())) {\n+        if (u != nullptr && (u->is_Phi() || u->is_CFG())) {\n@@ -384,1 +384,1 @@\n-      if (m != NULL && m->is_CFG()) {\n+      if (m != nullptr && m->is_CFG()) {\n@@ -459,1 +459,1 @@\n-    MergeMemNode* m = NULL;\n+    MergeMemNode* m = nullptr;\n@@ -484,1 +484,1 @@\n-  if( !can_reshape && !in(0) ) return NULL;     \/\/ Already degraded to a Copy\n+  if( !can_reshape && !in(0) ) return nullptr;     \/\/ Already degraded to a Copy\n@@ -491,1 +491,1 @@\n-    has_phis = (has_phi() != NULL);       \/\/ Cache result\n+    has_phis = (has_phi() != nullptr);       \/\/ Cache result\n@@ -509,1 +509,1 @@\n-            set_req(j, NULL);\n+            set_req(j, nullptr);\n@@ -517,1 +517,1 @@\n-  \/\/ Remove TOP or NULL input paths. If only 1 input path remains, this Region\n+  \/\/ Remove TOP or null input paths. If only 1 input path remains, this Region\n@@ -527,1 +527,1 @@\n-    if( n != NULL ) {\n+    if( n != nullptr ) {\n@@ -545,1 +545,1 @@\n-        set_req_X(i, NULL, phase); \/\/ Ignore TOP inputs\n+        set_req_X(i, nullptr, phase); \/\/ Ignore TOP inputs\n@@ -566,1 +566,1 @@\n-            n->set_req_X(i,NULL,igvn);\/\/ Correct DU info\n+            n->set_req_X(i,nullptr,igvn);\/\/ Correct DU info\n@@ -607,1 +607,1 @@\n-          if (m != NULL && m->is_CFG() && !visited.test_set(m->_idx)) {\n+          if (m != nullptr && m->is_CFG() && !visited.test_set(m->_idx)) {\n@@ -613,1 +613,1 @@\n-          n->set_req(0, NULL);\n+          n->set_req(0, nullptr);\n@@ -634,1 +634,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -639,1 +639,1 @@\n-    set_req(0, NULL);           \/\/ Null control input for region copy\n+    set_req(0, nullptr);        \/\/ Null control input for region copy\n@@ -641,2 +641,2 @@\n-      \/\/ No inputs or all inputs are NULL.\n-      return NULL;\n+      \/\/ No inputs or all inputs are null.\n+      return nullptr;\n@@ -650,1 +650,1 @@\n-        if (outer_sfpt != NULL && outer_out != NULL) {\n+        if (outer_sfpt != nullptr && outer_out != nullptr) {\n@@ -659,1 +659,1 @@\n-        if (opaq != NULL) {\n+        if (opaq != nullptr) {\n@@ -677,1 +677,1 @@\n-        assert(parent_ctrl != NULL, \"Region is a copy of some non-null control\");\n+        assert(parent_ctrl != nullptr, \"Region is a copy of some non-null control\");\n@@ -700,1 +700,1 @@\n-            assert( n->req() == 2 &&  n->in(1) != NULL, \"Only one data input expected\" );\n+            assert( n->req() == 2 &&  n->in(1) != nullptr, \"Only one data input expected\" );\n@@ -726,1 +726,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -735,1 +735,1 @@\n-    if (m != NULL)  return m;\n+    if (m != nullptr)  return m;\n@@ -742,1 +742,1 @@\n-    if (phi != NULL) {          \/\/ One Phi user\n+    if (phi != nullptr) {          \/\/ One Phi user\n@@ -755,2 +755,2 @@\n-          Node   *top_in = NULL;   \/\/ value being compared against\n-          Node   *bot_in = NULL;\n+          Node   *top_in = nullptr;   \/\/ value being compared against\n+          Node   *bot_in = nullptr;\n@@ -761,1 +761,1 @@\n-              assert( gvn != NULL, \"Only had DefUse info in IterGVN\");\n+              assert( gvn != nullptr, \"Only had DefUse info in IterGVN\");\n@@ -803,1 +803,1 @@\n-  return modified ? this : NULL;\n+  return modified ? this : nullptr;\n@@ -838,2 +838,2 @@\n-  Node* region = NULL;\n-  if (req() == 3 && in(1) != NULL && in(2) != NULL) {\n+  Node* region = nullptr;\n+  if (req() == 3 && in(1) != nullptr && in(2) != nullptr) {\n@@ -843,1 +843,1 @@\n-    if (region == NULL || region->outcnt() != 2 || region->req() != 3) {\n+    if (region == nullptr || region->outcnt() != 2 || region->req() != 3) {\n@@ -850,1 +850,1 @@\n-    if (phi == NULL) {\n+    if (phi == nullptr) {\n@@ -865,1 +865,1 @@\n-  if (region == NULL || region->in(idx1) == NULL || region->in(idx2) == NULL) {\n+  if (region == nullptr || region->in(idx1) == nullptr || region->in(idx2) == nullptr) {\n@@ -872,2 +872,2 @@\n-  if (proj1 == NULL || proj1->outcnt() != 1 ||\n-      proj2 == NULL || proj2->outcnt() != 1) {\n+  if (proj1 == nullptr || proj1->outcnt() != 1 ||\n+      proj2 == nullptr || proj2->outcnt() != 1) {\n@@ -879,2 +879,2 @@\n-  if (iff1 == NULL || iff1->outcnt() != 2 ||\n-      iff2 == NULL || iff2->outcnt() != 2) {\n+  if (iff1 == nullptr || iff1->outcnt() != 2 ||\n+      iff2 == nullptr || iff2->outcnt() != 2) {\n@@ -891,1 +891,1 @@\n-  if (bol1 == NULL || bol2 == NULL) {\n+  if (bol1 == nullptr || bol2 == nullptr) {\n@@ -961,1 +961,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -976,1 +976,1 @@\n-  if (at == NULL || at == TypePtr::BOTTOM)  return at;\n+  if (at == nullptr || at == TypePtr::BOTTOM)  return at;\n@@ -988,1 +988,1 @@\n-    if (r->in(j) != NULL)\n+    if (r->in(j) != nullptr)\n@@ -995,1 +995,1 @@\n-  const TypePtr* at = NULL;\n+  const TypePtr* at = nullptr;\n@@ -1001,1 +1001,1 @@\n-  const TypePtr* at = NULL;\n+  const TypePtr* at = nullptr;\n@@ -1024,1 +1024,1 @@\n-  assert(t_oop != NULL && t_oop->is_known_instance(), \"expecting instance oopptr\");\n+  assert(t_oop != nullptr && t_oop->is_known_instance(), \"expecting instance oopptr\");\n@@ -1061,1 +1061,1 @@\n-      if (in == NULL || igvn->type(in) == Type::TOP)\n+      if (in == nullptr || igvn->type(in) == Type::TOP)\n@@ -1063,3 +1063,3 @@\n-      Node *opt = MemNode::optimize_simple_memory_chain(in, t_oop, NULL, igvn);\n-      PhiNode *optphi = opt->is_Phi() ? opt->as_Phi() : NULL;\n-      if (optphi != NULL && optphi->adr_type() == TypePtr::BOTTOM) {\n+      Node *opt = MemNode::optimize_simple_memory_chain(in, t_oop, nullptr, igvn);\n+      PhiNode *optphi = opt->is_Phi() ? opt->as_Phi() : nullptr;\n+      if (optphi != nullptr && optphi->adr_type() == TypePtr::BOTTOM) {\n@@ -1067,1 +1067,1 @@\n-        if (opt == NULL) {\n+        if (opt == nullptr) {\n@@ -1098,1 +1098,1 @@\n-    if (n == NULL)  continue;\n+    if (n == nullptr)  continue;\n@@ -1108,1 +1108,1 @@\n-      assert((nat != NULL) == (at != NULL), \"\");\n+      assert((nat != nullptr) == (at != nullptr), \"\");\n@@ -1120,1 +1120,1 @@\n-  assert((_type == Type::MEMORY) == (_adr_type != NULL), \"adr_type for memory phis only\");\n+  assert((_type == Type::MEMORY) == (_adr_type != nullptr), \"adr_type for memory phis only\");\n@@ -1148,1 +1148,1 @@\n-  BaseCountedLoopNode* l = r->is_BaseCountedLoop() ? r->as_BaseCountedLoop() : NULL;\n+  BaseCountedLoopNode* l = r->is_BaseCountedLoop() ? r->as_BaseCountedLoop() : nullptr;\n@@ -1150,1 +1150,1 @@\n-    \/\/ protect against init_trip() or limit() returning NULL\n+    \/\/ protect against init_trip() or limit() returning nullptr\n@@ -1155,1 +1155,1 @@\n-      if (init != NULL && limit != NULL && stride != NULL) {\n+      if (init != nullptr && limit != nullptr && stride != nullptr) {\n@@ -1159,1 +1159,1 @@\n-        if (lo != NULL && hi != NULL && stride_t != NULL) { \/\/ Dying loops might have TOP here\n+        if (lo != nullptr && hi != nullptr && stride_t != nullptr) { \/\/ Dying loops might have TOP here\n@@ -1176,2 +1176,2 @@\n-    } else if (l->in(LoopNode::LoopBackControl) != NULL &&\n-               in(LoopNode::EntryControl) != NULL &&\n+    } else if (l->in(LoopNode::LoopBackControl) != nullptr &&\n+               in(LoopNode::EntryControl) != nullptr &&\n@@ -1191,2 +1191,2 @@\n-  const TypeInstPtr* ttip = (ttp != NULL) ? ttp->isa_instptr() : NULL;\n-  const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_klassptr() : NULL;\n+  const TypeInstPtr* ttip = (ttp != nullptr) ? ttp->isa_instptr() : nullptr;\n+  const TypeKlassPtr* ttkp = (ttp != nullptr) ? ttp->isa_klassptr() : nullptr;\n@@ -1194,1 +1194,1 @@\n-  if (ttip != NULL) {\n+  if (ttip != nullptr) {\n@@ -1199,1 +1199,1 @@\n-  if (ttkp != NULL) {\n+  if (ttkp != nullptr) {\n@@ -1217,1 +1217,1 @@\n-      const TypeInstPtr* tiip = (tip != NULL) ? tip->isa_instptr() : NULL;\n+      const TypeInstPtr* tiip = (tip != nullptr) ? tip->isa_instptr() : nullptr;\n@@ -1265,2 +1265,2 @@\n-      Type::get_arrays_base_elements(jt, _type, NULL, &ttip);\n-      if (!t->empty() && ttip != NULL && ttip->is_loaded() && ttip->klass()->is_interface()) {\n+      Type::get_arrays_base_elements(jt, _type, nullptr, &ttip);\n+      if (!t->empty() && ttip != nullptr && ttip->is_loaded() && ttip->klass()->is_interface()) {\n@@ -1284,2 +1284,2 @@\n-    const TypeInstPtr *jtip = (jtp != NULL) ? jtp->isa_instptr() : NULL;\n-    const TypeKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_klassptr() : NULL;\n+    const TypeInstPtr *jtip = (jtp != nullptr) ? jtp->isa_instptr() : nullptr;\n+    const TypeKlassPtr *jtkp = (jtp != nullptr) ? jtp->isa_klassptr() : nullptr;\n@@ -1385,2 +1385,2 @@\n-  if (id == NULL)\n-    return NULL;\n+  if (id == nullptr)\n+    return nullptr;\n@@ -1392,1 +1392,1 @@\n-  if (ctl != NULL && ctl->in(0) == iff) {\n+  if (ctl != nullptr && ctl->in(0) == iff) {\n@@ -1397,1 +1397,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1413,1 +1413,1 @@\n-  if (uin != NULL) {\n+  if (uin != nullptr) {\n@@ -1421,1 +1421,1 @@\n-    if (id != NULL) {\n+    if (id != nullptr) {\n@@ -1439,1 +1439,1 @@\n-            u = NULL;\n+            u = nullptr;\n@@ -1443,1 +1443,1 @@\n-        if (u != NULL) {\n+        if (u != nullptr) {\n@@ -1469,1 +1469,1 @@\n-  Node* input = NULL; \/\/ The unique direct input (maybe uncasted = ConstraintCasts removed)\n+  Node* input = nullptr; \/\/ The unique direct input (maybe uncasted = ConstraintCasts removed)\n@@ -1473,1 +1473,1 @@\n-    if (rc == NULL || phase->type(rc) == Type::TOP)\n+    if (rc == nullptr || phase->type(rc) == Type::TOP)\n@@ -1476,1 +1476,1 @@\n-    if (n == NULL)\n+    if (n == nullptr)\n@@ -1483,1 +1483,1 @@\n-      while (un != NULL && un->req() == 2 && un->is_ConstraintCast()) {\n+      while (un != nullptr && un->req() == 2 && un->is_ConstraintCast()) {\n@@ -1493,1 +1493,1 @@\n-    if (un == NULL || un == this || phase->type(un) == Type::TOP) {\n+    if (un == nullptr || un == this || phase->type(un) == Type::TOP) {\n@@ -1497,1 +1497,1 @@\n-    if (input == NULL) {\n+    if (input == nullptr) {\n@@ -1503,1 +1503,1 @@\n-  if (input == NULL) {\n+  if (input == nullptr) {\n@@ -1512,1 +1512,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1542,1 +1542,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1549,1 +1549,1 @@\n-    } else return NULL;\n+    } else return nullptr;\n@@ -1553,2 +1553,2 @@\n-    } else return NULL;\n-  } else return NULL;\n+    } else return nullptr;\n+  } else return nullptr;\n@@ -1560,1 +1560,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -1589,1 +1589,1 @@\n-  if (region->has_unique_phi() != phi)  return NULL;\n+  if (region->has_unique_phi() != phi)  return nullptr;\n@@ -1593,2 +1593,2 @@\n-  if (region->in(1)->outcnt() != 1) return NULL;\n-  if (region->in(2)->outcnt() != 1) return NULL;\n+  if (region->in(1)->outcnt() != 1) return nullptr;\n+  if (region->in(2)->outcnt() != 1) return nullptr;\n@@ -1597,2 +1597,2 @@\n-  if (b->_test._test != BoolTest::lt)  return NULL;\n-  if (cmp->Opcode() != Op_CmpI)        return NULL;\n+  if (b->_test._test != BoolTest::lt)  return nullptr;\n+  if (cmp->Opcode() != Op_CmpI)        return nullptr;\n@@ -1611,1 +1611,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1614,1 +1614,1 @@\n-  Node *y = NULL;\n+  Node *y = nullptr;\n@@ -1619,1 +1619,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -1623,1 +1623,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1654,1 +1654,1 @@\n-    default:           return NULL;                              break;\n+    default:           return nullptr;                           break;\n@@ -1662,1 +1662,1 @@\n-    default:           return NULL;                              break;\n+    default:           return nullptr;                           break;\n@@ -1667,1 +1667,1 @@\n-  const Type *tzero = NULL;\n+  const Type *tzero = nullptr;\n@@ -1673,1 +1673,1 @@\n-  default: return NULL;\n+  default: return nullptr;\n@@ -1677,1 +1677,1 @@\n-  Node *x = NULL;\n+  Node *x = nullptr;\n@@ -1686,1 +1686,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1691,1 +1691,1 @@\n-  if( phi_root->in(phi_x_idx) != x ) return NULL;\n+  if( phi_root->in(phi_x_idx) != x ) return nullptr;\n@@ -1700,1 +1700,1 @@\n-  if (!is_sub || phase->type(sub->in(1)) != tzero || sub->in(2) != x) return NULL;\n+  if (!is_sub || phase->type(sub->in(1)) != tzero || sub->in(2) != x) return nullptr;\n@@ -1722,1 +1722,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -1756,1 +1756,1 @@\n-    return NULL;                \/\/ Bail out on funny non-value stuff\n+    return nullptr;             \/\/ Bail out on funny non-value stuff\n@@ -1758,1 +1758,1 @@\n-    return NULL;                \/\/ third unequal input to be worth doing\n+    return nullptr;             \/\/ third unequal input to be worth doing\n@@ -1764,2 +1764,2 @@\n-    if( !n ) return NULL;\n-    if( phase->type(n) == Type::TOP ) return NULL;\n+    if( !n ) return nullptr;\n+    if( phase->type(n) == Type::TOP ) return nullptr;\n@@ -1770,1 +1770,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1778,2 +1778,2 @@\n-    if( !n ) return NULL;\n-    if( phase->type(n) == Type::TOP ) return NULL;\n+    if( !n ) return nullptr;\n+    if( phase->type(n) == Type::TOP ) return nullptr;\n@@ -1782,2 +1782,2 @@\n-      if (PhaseIdealLoop::find_predicate(r->in(i)) != NULL) {\n-        return NULL;            \/\/ don't split loop entry path\n+      if (PhaseIdealLoop::find_predicate(r->in(i)) != nullptr) {\n+        return nullptr;            \/\/ don't split loop entry path\n@@ -1790,1 +1790,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1843,1 +1843,1 @@\n-  if (in != NULL && !in->is_dead_loop_safe()) {\n+  if (in != nullptr && !in->is_dead_loop_safe()) {\n@@ -1852,1 +1852,1 @@\n-      if (m != NULL && !m->is_dead_loop_safe()) {\n+      if (m != nullptr && !m->is_dead_loop_safe()) {\n@@ -1855,1 +1855,1 @@\n-        Node *m1 = (m->is_AddP() && m->req() > 3) ? m->in(1) : NULL;\n+        Node *m1 = (m->is_AddP() && m->req() > 3) ? m->in(1) : nullptr;\n@@ -1858,1 +1858,1 @@\n-        if (m1 != NULL && m1 == m->in(2) &&\n+        if (m1 != nullptr && m1 == m->in(2) &&\n@@ -1901,1 +1901,1 @@\n-      if (m != NULL && !m->is_dead_loop_safe()) { \/\/ Only look for unsafe cases.\n+      if (m != nullptr && !m->is_dead_loop_safe()) { \/\/ Only look for unsafe cases.\n@@ -1920,1 +1920,1 @@\n-    if (rc != NULL &&\n+    if (rc != nullptr &&\n@@ -1924,1 +1924,1 @@\n-      } else if (rc->in(0) != NULL &&\n+      } else if (rc->in(0) != nullptr &&\n@@ -1928,1 +1928,1 @@\n-        } else if (rc->in(0)->in(1) != NULL &&\n+        } else if (rc->in(0)->in(1) != nullptr &&\n@@ -1932,1 +1932,1 @@\n-          } else if (rc->in(0)->in(1)->in(1) != NULL &&\n+          } else if (rc->in(0)->in(1)->in(1) != nullptr &&\n@@ -1953,2 +1953,2 @@\n-  assert(r != NULL && r->is_Region(), \"this phi must have a region\");\n-  assert(r->in(0) == NULL || !r->in(0)->is_Root(), \"not a specially hidden merge\");\n+  assert(r != nullptr && r->is_Region(), \"this phi must have a region\");\n+  assert(r->in(0) == nullptr || !r->in(0)->is_Root(), \"not a specially hidden merge\");\n@@ -1959,1 +1959,1 @@\n-    return NULL;                \/\/ No change\n+    return nullptr;                \/\/ No change\n@@ -1965,1 +1965,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1972,1 +1972,1 @@\n-  Node* progress = NULL;        \/\/ Record if any progress made\n+  Node* progress = nullptr;        \/\/ Record if any progress made\n@@ -1977,1 +1977,1 @@\n-    if (rc == NULL || phase->type(rc) == Type::TOP) {\n+    if (rc == nullptr || phase->type(rc) == Type::TOP) {\n@@ -1980,1 +1980,1 @@\n-        if (can_reshape && igvn != NULL) {\n+        if (can_reshape && igvn != nullptr) {\n@@ -1998,1 +1998,1 @@\n-  if (uin == NULL && can_reshape &&\n+  if (uin == nullptr && can_reshape &&\n@@ -2009,3 +2009,3 @@\n-      return NULL;              \/\/ Identity will return TOP\n-  } else if (uin != NULL) {\n-    \/\/ Only one not-NULL unique input path is left.\n+      return nullptr;              \/\/ Identity will return TOP\n+  } else if (uin != nullptr) {\n+    \/\/ Only one not-null unique input path is left.\n@@ -2014,1 +2014,1 @@\n-    if (outcnt() > 0 && r->in(0) != NULL) {\n+    if (outcnt() > 0 && r->in(0) != nullptr) {\n@@ -2023,1 +2023,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2035,1 +2035,1 @@\n-      Node* cast = NULL;\n+      Node* cast = nullptr;\n@@ -2057,1 +2057,1 @@\n-            if (cast != NULL) {\n+            if (cast != nullptr) {\n@@ -2063,1 +2063,1 @@\n-          if (cast == NULL) {\n+          if (cast == nullptr) {\n@@ -2070,1 +2070,1 @@\n-      assert(cast != NULL, \"cast should be set\");\n+      assert(cast != nullptr, \"cast should be set\");\n@@ -2093,1 +2093,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2096,1 +2096,1 @@\n-  Node* opt = NULL;\n+  Node* opt = nullptr;\n@@ -2106,1 +2106,1 @@\n-    if( unsafe_id != NULL && is_unsafe_data_reference(unsafe_id) )\n+    if( unsafe_id != nullptr && is_unsafe_data_reference(unsafe_id) )\n@@ -2110,1 +2110,1 @@\n-    if( opt == NULL )\n+    if( opt == nullptr )\n@@ -2114,1 +2114,1 @@\n-    if( opt == NULL )\n+    if( opt == nullptr )\n@@ -2118,1 +2118,1 @@\n-    if( opt == NULL && can_reshape )\n+    if( opt == nullptr && can_reshape )\n@@ -2123,1 +2123,1 @@\n-    if( opt != NULL ) {\n+    if( opt != nullptr ) {\n@@ -2133,1 +2133,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2144,2 +2144,2 @@\n-    assert(opt == NULL || opt == this, \"do not elide phi\");\n-    if (opt != NULL)  return opt;\n+    assert(opt == nullptr || opt == this, \"do not elide phi\");\n+    if (opt != nullptr)  return opt;\n@@ -2148,1 +2148,1 @@\n-  if (in(1) != NULL && in(1)->Opcode() == Op_AddP && can_reshape) {\n+  if (in(1) != nullptr && in(1)->Opcode() == Op_AddP && can_reshape) {\n@@ -2164,1 +2164,1 @@\n-    if (base != NULL && address != NULL && offset != NULL &&\n+    if (base != nullptr && address != nullptr && offset != nullptr &&\n@@ -2172,1 +2172,1 @@\n-        if (in(i) == NULL ||\n+        if (in(i) == nullptr ||\n@@ -2174,3 +2174,3 @@\n-            in(i)->in(AddPNode::Base) == NULL ||\n-            in(i)->in(AddPNode::Address) == NULL ||\n-            in(i)->in(AddPNode::Offset) == NULL ||\n+            in(i)->in(AddPNode::Base) == nullptr ||\n+            in(i)->in(AddPNode::Address) == nullptr ||\n+            in(i)->in(AddPNode::Offset) == nullptr ||\n@@ -2184,1 +2184,1 @@\n-          base = NULL;\n+          base = nullptr;\n@@ -2187,1 +2187,1 @@\n-          offset = NULL;\n+          offset = nullptr;\n@@ -2190,1 +2190,1 @@\n-          address = NULL;\n+          address = nullptr;\n@@ -2196,1 +2196,1 @@\n-      if (doit && base == NULL) {\n+      if (doit && base == nullptr) {\n@@ -2203,2 +2203,2 @@\n-            if (base2 != NULL && !base2->is_top()) {\n-              if (base == NULL)\n+            if (base2 != nullptr && !base2->is_top()) {\n+              if (base == nullptr)\n@@ -2213,2 +2213,2 @@\n-        if (base == NULL) {\n-          base = new PhiNode(in(0), base_type, NULL);\n+        if (base == nullptr) {\n+          base = new PhiNode(in(0), base_type, nullptr);\n@@ -2220,2 +2220,2 @@\n-        if (address == NULL) {\n-          address = new PhiNode(in(0), address_type, NULL);\n+        if (address == nullptr) {\n+          address = new PhiNode(in(0), address_type, nullptr);\n@@ -2227,2 +2227,2 @@\n-        if (offset == NULL) {\n-          offset = new PhiNode(in(0), TypeX_X, NULL);\n+        if (offset == nullptr) {\n+          offset = new PhiNode(in(0), TypeX_X, nullptr);\n@@ -2245,1 +2245,1 @@\n-  if (progress == NULL && can_reshape && type() == Type::MEMORY) {\n+  if (progress == nullptr && can_reshape && type() == Type::MEMORY) {\n@@ -2255,1 +2255,1 @@\n-        return NULL; \/\/ Delay optimization until graph is cleaned.\n+        return nullptr; \/\/ Delay optimization until graph is cleaned.\n@@ -2324,1 +2324,1 @@\n-        assert(igvn != NULL, \"sanity check\");\n+        assert(igvn != nullptr, \"sanity check\");\n@@ -2384,1 +2384,1 @@\n-      Node *new_in = MemNode::optimize_memory_chain(ii, at, NULL, phase);\n+      Node *new_in = MemNode::optimize_memory_chain(ii, at, nullptr, phase);\n@@ -2395,1 +2395,1 @@\n-  if ((UseCompressedOops || UseCompressedClassPointers) && can_reshape && progress == NULL) {\n+  if ((UseCompressedOops || UseCompressedClassPointers) && can_reshape && progress == nullptr) {\n@@ -2425,1 +2425,1 @@\n-        Node* new_ii = NULL;\n+        Node* new_ii = nullptr;\n@@ -2455,1 +2455,1 @@\n-  if (EnableVectorReboxing && can_reshape && progress == NULL) {\n+  if (EnableVectorReboxing && can_reshape && progress == nullptr) {\n@@ -2516,1 +2516,1 @@\n-  return (in(0) != NULL && in(0)->is_BaseCountedLoop() &&\n+  return (in(0) != nullptr && in(0)->is_BaseCountedLoop() &&\n@@ -2631,1 +2631,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -2674,1 +2674,1 @@\n-  \/\/ () virtual or interface call with NULL receiver\n+  \/\/ () virtual or interface call with null receiver\n@@ -2732,1 +2732,1 @@\n-  \/\/ a NULL receiver to a v-call, or passing bad types to a slow-check-cast.\n+  \/\/ a null receiver to a v-call, or passing bad types to a slow-check-cast.\n@@ -2791,1 +2791,1 @@\n-    if (fallthru != NULL) {\n+    if (fallthru != nullptr) {\n@@ -2796,1 +2796,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":208,"deletions":208,"binary":false,"changes":416,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    if (r == NULL)\n+    if (r == nullptr)\n@@ -87,1 +87,1 @@\n-    return NULL;  \/\/ not a copy!\n+    return nullptr;  \/\/ not a copy!\n@@ -89,2 +89,2 @@\n-  PhiNode* has_phi() const;        \/\/ returns an arbitrary phi user, or NULL\n-  PhiNode* has_unique_phi() const; \/\/ returns the unique phi user, or NULL\n+  PhiNode* has_phi() const;        \/\/ returns an arbitrary phi user, or null\n+  PhiNode* has_unique_phi() const; \/\/ returns the unique phi user, or null\n@@ -156,1 +156,1 @@\n-  PhiNode( Node *r, const Type *t, const TypePtr* at = NULL,\n+  PhiNode( Node *r, const Type *t, const TypePtr* at = nullptr,\n@@ -175,1 +175,1 @@\n-  static PhiNode* make( Node* r, Node* x, const Type *t, const TypePtr* at = NULL );\n+  static PhiNode* make( Node* r, Node* x, const Type *t, const TypePtr* at = nullptr );\n@@ -188,1 +188,1 @@\n-  \/\/ Ignore casts if it helps.  Return NULL on failure.\n+  \/\/ Ignore casts if it helps.  Return null on failure.\n@@ -192,1 +192,1 @@\n-    if (uin == NULL) {\n+    if (uin == nullptr) {\n@@ -405,1 +405,1 @@\n-  \/\/ Returns NULL is it couldn't improve the type.\n+  \/\/ Returns null is it couldn't improve the type.\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    if (_defs != NULL) {\n+    if (_defs != nullptr) {\n@@ -202,1 +202,1 @@\n-       NULL\n+       nullptr\n@@ -236,1 +236,1 @@\n-      buckets[i][j] = NULL;\n+      buckets[i][j] = nullptr;\n@@ -381,1 +381,1 @@\n-    _live = NULL;                 \/\/ Mark live as being not available\n+    _live = nullptr;              \/\/ Mark live as being not available\n@@ -399,1 +399,1 @@\n-    _live = NULL;\n+    _live = nullptr;\n@@ -438,1 +438,1 @@\n-    _live = NULL;\n+    _live = nullptr;\n@@ -476,1 +476,1 @@\n-      _live = NULL;\n+      _live = nullptr;\n@@ -546,1 +546,1 @@\n-      _live = NULL;\n+      _live = nullptr;\n@@ -624,1 +624,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -679,3 +679,3 @@\n-  _live = NULL;\n-  _ifg = NULL;\n-  C->set_indexSet_arena(NULL);  \/\/ ResourceArea is at end of scope\n+  _live = nullptr;\n+  _ifg = nullptr;\n+  C->set_indexSet_arena(nullptr);  \/\/ ResourceArea is at end of scope\n@@ -788,1 +788,1 @@\n-        if (trace_spilling() && lrg._def != NULL) {\n+        if (trace_spilling() && lrg._def != nullptr) {\n@@ -790,2 +790,2 @@\n-          if (lrg._defs == NULL) {\n-            lrg._defs = new (_ifg->_arena) GrowableArray<Node*>(_ifg->_arena, 2, 0, NULL);\n+          if (lrg._defs == nullptr) {\n+            lrg._defs = new (_ifg->_arena) GrowableArray<Node*>(_ifg->_arena, 2, 0, nullptr);\n@@ -799,1 +799,1 @@\n-        \/\/ via rematerialization.  Flag as NULL for no def found\n+        \/\/ via rematerialization.  Flag as null for no def found\n@@ -827,1 +827,1 @@\n-        assert(n_type->isa_vect() == NULL || lrg._is_vector ||\n+        assert(n_type->isa_vect() == nullptr || lrg._is_vector ||\n@@ -1044,1 +1044,1 @@\n-        assert(n->in(k)->bottom_type()->isa_vect() == NULL || is_vect ||\n+        assert(n->in(k)->bottom_type()->isa_vect() == nullptr || is_vect ||\n@@ -1073,1 +1073,1 @@\n-            (lrg._def == NULL || lrg.is_multidef() || !lrg._def->is_SpillCopy()) &&\n+            (lrg._def == nullptr || lrg.is_multidef() || !lrg._def->is_SpillCopy()) &&\n@@ -1753,1 +1753,1 @@\n-  \/\/ pointers derived from NULL!  These are always along paths that\n+  \/\/ pointers derived from null!  These are always along paths that\n@@ -1760,1 +1760,1 @@\n-  if( tj == NULL || tj->_offset == 0 ) {\n+  if( tj == nullptr || tj->_offset == 0 ) {\n@@ -1764,1 +1764,1 @@\n-  \/\/ Derived is NULL+offset?  Base is NULL!\n+  \/\/ Derived is null+offset?  Base is null!\n@@ -1767,2 +1767,2 @@\n-    assert(base != NULL, \"sanity\");\n-    if (base->in(0) == NULL) {\n+    assert(base != nullptr, \"sanity\");\n+    if (base->in(0) == nullptr) {\n@@ -1793,1 +1793,1 @@\n-    assert(base->in(0) == _cfg.get_root_node() && _cfg.get_block_for_node(base) == _cfg.get_block_for_node(C->top()), \"base NULL should be shared\");\n+    assert(base->in(0) == _cfg.get_root_node() && _cfg.get_block_for_node(base) == _cfg.get_block_for_node(C->top()), \"base null should be shared\");\n@@ -1842,1 +1842,1 @@\n-          !(phi->in(j)->is_Con() && base->in(j)->is_Con()) ) \/\/ allow different NULLs\n+          !(phi->in(j)->is_Con() && base->in(j)->is_Con()) ) \/\/ allow different nulls\n@@ -2404,1 +2404,1 @@\n-        if (jvms != NULL) {\n+        if (jvms != nullptr) {\n@@ -2428,1 +2428,1 @@\n-                    \/\/ Derived is NULL+non-zero offset, base must be NULL.\n+                    \/\/ Derived is null+non-zero offset, base must be null.\n@@ -2432,1 +2432,1 @@\n-                    \/\/ Base either ConP(NULL) or loadConP\n+                    \/\/ Base either ConP(nullptr) or loadConP\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-  bool alive() const { return _def != NULL; }\n+  bool alive() const { return _def != nullptr; }\n@@ -749,1 +749,1 @@\n-    RegDefUse() : _def(NULL), _first_use(NULL) { }\n+    RegDefUse() : _def(nullptr), _first_use(nullptr) { }\n@@ -760,2 +760,2 @@\n-      _def = NULL;\n-      _first_use = NULL;\n+      _def = nullptr;\n+      _first_use = nullptr;\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-          n->set_req(cidx,NULL);\n+          n->set_req(cidx,nullptr);\n@@ -506,1 +506,1 @@\n-  lrgs(lr2)._def = NULL;    \/\/ No def for lrg 2\n+  lrgs(lr2)._def = nullptr;    \/\/ No def for lrg 2\n@@ -523,1 +523,1 @@\n-  dst_copy->set_req( didx, NULL);\n+  dst_copy->set_req( didx, nullptr);\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  if (_mach_constant_base_node == NULL) {\n+  if (_mach_constant_base_node == nullptr) {\n@@ -156,1 +156,1 @@\n-    if (cg != NULL) {\n+    if (cg != nullptr) {\n@@ -164,1 +164,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -231,1 +231,1 @@\n-  if (xtty != NULL)  xtty->head(\"statistics type='intrinsic'\");\n+  if (xtty != nullptr)  xtty->head(\"statistics type='intrinsic'\");\n@@ -245,1 +245,1 @@\n-  if (xtty != NULL)  xtty->tail(\"statistics\");\n+  if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -250,1 +250,1 @@\n-    if (xtty != NULL)  xtty->head(\"statistics type='opto'\");\n+    if (xtty != nullptr)  xtty->head(\"statistics type='opto'\");\n@@ -257,1 +257,1 @@\n-    if (xtty != NULL)  xtty->tail(\"statistics\");\n+    if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -295,1 +295,1 @@\n-  useful.map( estimated_worklist_size, NULL );  \/\/ preallocate space\n+  useful.map( estimated_worklist_size, nullptr );  \/\/ preallocate space\n@@ -298,1 +298,1 @@\n-  if (root() != NULL)     { useful.push(root()); }\n+  if (root() != nullptr)  { useful.push(root()); }\n@@ -300,1 +300,1 @@\n-  if( cached_top_node() ) { useful.push(cached_top_node()); }\n+  if (cached_top_node())  { useful.push(cached_top_node()); }\n@@ -348,1 +348,1 @@\n-  assert(dead != NULL && dead->is_Call(), \"sanity\");\n+  assert(dead != nullptr && dead->is_Call(), \"sanity\");\n@@ -437,1 +437,1 @@\n-  if (_modified_nodes != NULL) {\n+  if (_modified_nodes != nullptr) {\n@@ -466,1 +466,1 @@\n-  assert(env->compiler_data() == NULL, \"compile already active?\");\n+  assert(env->compiler_data() == nullptr, \"compile already active?\");\n@@ -470,1 +470,1 @@\n-  compile->set_type_dict(NULL);\n+  compile->set_type_dict(nullptr);\n@@ -474,3 +474,3 @@\n-  compile->set_last_tf(NULL, NULL);\n-  compile->set_indexSet_arena(NULL);\n-  compile->set_indexSet_free_block_list(NULL);\n+  compile->set_last_tf(nullptr, nullptr);\n+  compile->set_indexSet_arena(nullptr);\n+  compile->set_indexSet_free_block_list(nullptr);\n@@ -484,1 +484,1 @@\n-  _compile->env()->set_compiler_data(NULL);\n+  _compile->env()->set_compiler_data(nullptr);\n@@ -554,3 +554,3 @@\n-                  _stub_function(NULL),\n-                  _stub_name(NULL),\n-                  _stub_entry_point(NULL),\n+                  _stub_function(nullptr),\n+                  _stub_name(nullptr),\n+                  _stub_entry_point(nullptr),\n@@ -576,10 +576,10 @@\n-                  _failure_reason(NULL),\n-                  _intrinsics        (comp_arena(), 0, 0, NULL),\n-                  _macro_nodes       (comp_arena(), 8, 0, NULL),\n-                  _predicate_opaqs   (comp_arena(), 8, 0, NULL),\n-                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, NULL),\n-                  _expensive_nodes   (comp_arena(), 8, 0, NULL),\n-                  _for_post_loop_igvn(comp_arena(), 8, 0, NULL),\n-                  _coarsened_locks   (comp_arena(), 8, 0, NULL),\n-                  _congraph(NULL),\n-                  NOT_PRODUCT(_printer(NULL) COMMA)\n+                  _failure_reason(nullptr),\n+                  _intrinsics        (comp_arena(), 0, 0, nullptr),\n+                  _macro_nodes       (comp_arena(), 8, 0, nullptr),\n+                  _predicate_opaqs   (comp_arena(), 8, 0, nullptr),\n+                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n+                  _expensive_nodes   (comp_arena(), 8, 0, nullptr),\n+                  _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+                  _coarsened_locks   (comp_arena(), 8, 0, nullptr),\n+                  _congraph(nullptr),\n+                  NOT_PRODUCT(_printer(nullptr) COMMA)\n@@ -590,1 +590,1 @@\n-                  _mach_constant_base_node(NULL),\n+                  _mach_constant_base_node(nullptr),\n@@ -592,6 +592,6 @@\n-                  _initial_gvn(NULL),\n-                  _for_igvn(NULL),\n-                  _late_inlines(comp_arena(), 2, 0, NULL),\n-                  _string_late_inlines(comp_arena(), 2, 0, NULL),\n-                  _boxing_late_inlines(comp_arena(), 2, 0, NULL),\n-                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, NULL),\n+                  _initial_gvn(nullptr),\n+                  _for_igvn(nullptr),\n+                  _late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _string_late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n@@ -600,3 +600,3 @@\n-                  _native_invokers(comp_arena(), 1, 0, NULL),\n-                  _print_inlining_stream(NULL),\n-                  _print_inlining_list(NULL),\n+                  _native_invokers(comp_arena(), 1, 0, nullptr),\n+                  _print_inlining_stream(nullptr),\n+                  _print_inlining_list(nullptr),\n@@ -604,2 +604,2 @@\n-                  _print_inlining_output(NULL),\n-                  _replay_inline_data(NULL),\n+                  _print_inlining_output(nullptr),\n+                  _replay_inline_data(nullptr),\n@@ -624,1 +624,1 @@\n-  TraceTime t2(NULL, &_t_methodCompilation, CITime, false);\n+  TraceTime t2(nullptr, &_t_methodCompilation, CITime, false);\n@@ -685,1 +685,1 @@\n-    CallGenerator* cg = NULL;\n+    CallGenerator* cg = nullptr;\n@@ -708,1 +708,1 @@\n-      if (cg == NULL) {\n+      if (cg == nullptr) {\n@@ -715,1 +715,1 @@\n-    if (cg == NULL) {\n+    if (cg == nullptr) {\n@@ -720,1 +720,1 @@\n-    if ((jvms = cg->generate(jvms)) == NULL) {\n+    if ((jvms = cg->generate(jvms)) == nullptr) {\n@@ -764,1 +764,1 @@\n-  set_default_node_notes(NULL);\n+  set_default_node_notes(nullptr);\n@@ -784,1 +784,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -800,1 +800,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -806,1 +806,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -821,1 +821,1 @@\n-  if (directive->DumpInlineOption && (ilt() != NULL)) {\n+  if (directive->DumpInlineOption && (ilt() != nullptr)) {\n@@ -855,1 +855,1 @@\n-    _method(NULL),\n+    _method(nullptr),\n@@ -859,1 +859,1 @@\n-    _stub_entry_point(NULL),\n+    _stub_entry_point(nullptr),\n@@ -878,3 +878,3 @@\n-    _failure_reason(NULL),\n-    _congraph(NULL),\n-    NOT_PRODUCT(_printer(NULL) COMMA)\n+    _failure_reason(nullptr),\n+    _congraph(nullptr),\n+    NOT_PRODUCT(_printer(nullptr) COMMA)\n@@ -885,1 +885,1 @@\n-    _mach_constant_base_node(NULL),\n+    _mach_constant_base_node(nullptr),\n@@ -887,2 +887,2 @@\n-    _initial_gvn(NULL),\n-    _for_igvn(NULL),\n+    _initial_gvn(nullptr),\n+    _for_igvn(nullptr),\n@@ -891,2 +891,2 @@\n-    _print_inlining_stream(NULL),\n-    _print_inlining_list(NULL),\n+    _print_inlining_stream(nullptr),\n+    _print_inlining_list(nullptr),\n@@ -894,2 +894,2 @@\n-    _print_inlining_output(NULL),\n-    _replay_inline_data(NULL),\n+    _print_inlining_output(nullptr),\n+    _replay_inline_data(nullptr),\n@@ -905,2 +905,2 @@\n-  TraceTime t1(NULL, &_t_totalCompilation, CITime, false);\n-  TraceTime t2(NULL, &_t_stubCompilation, CITime, false);\n+  TraceTime t1(nullptr, &_t_totalCompilation, CITime, false);\n+  TraceTime t2(nullptr, &_t_stubCompilation, CITime, false);\n@@ -941,1 +941,1 @@\n-  _regalloc = NULL;\n+  _regalloc = nullptr;\n@@ -943,4 +943,4 @@\n-  _tf      = NULL;  \/\/ filled in later\n-  _top     = NULL;  \/\/ cached later\n-  _matcher = NULL;  \/\/ filled in later\n-  _cfg     = NULL;  \/\/ filled in later\n+  _tf      = nullptr;  \/\/ filled in later\n+  _top     = nullptr;  \/\/ cached later\n+  _matcher = nullptr;  \/\/ filled in later\n+  _cfg     = nullptr;  \/\/ filled in later\n@@ -950,3 +950,3 @@\n-  _node_note_array = NULL;\n-  _default_node_notes = NULL;\n-  DEBUG_ONLY( _modified_nodes = NULL; ) \/\/ Used in Optimize()\n+  _node_note_array = nullptr;\n+  _default_node_notes = nullptr;\n+  DEBUG_ONLY( _modified_nodes = nullptr; ) \/\/ Used in Optimize()\n@@ -954,1 +954,1 @@\n-  _immutable_memory = NULL; \/\/ filled in at first inquiry\n+  _immutable_memory = nullptr; \/\/ filled in at first inquiry\n@@ -963,2 +963,2 @@\n-  \/\/ First set TOP to NULL to give safe behavior during creation of RootNode\n-  set_cached_top_node(NULL);\n+  \/\/ First set TOP to nullptr to give safe behavior during creation of RootNode\n+  set_cached_top_node(nullptr);\n@@ -968,1 +968,1 @@\n-  set_recent_alloc(NULL, NULL);\n+  set_recent_alloc(nullptr, nullptr);\n@@ -1014,1 +1014,1 @@\n-  if (UseRTMLocking && has_method() && (method()->method_data_or_null() != NULL)) {\n+  if (UseRTMLocking && has_method() && (method()->method_data_or_null() != nullptr)) {\n@@ -1034,1 +1034,1 @@\n-                        (comp_arena(), 8, 0, NULL));\n+                        (comp_arena(), 8, 0, nullptr));\n@@ -1056,1 +1056,1 @@\n-  _alias_types[AliasIdxTop]->Init(AliasIdxTop, NULL);\n+  _alias_types[AliasIdxTop]->Init(AliasIdxTop, nullptr);\n@@ -1062,2 +1062,2 @@\n-  \/\/ A NULL adr_type hits in the cache right away.  Preload the right answer.\n-  probe_alias_cache(NULL)->_index = AliasIdxTop;\n+  \/\/ A null adr_type hits in the cache right away.  Preload the right answer.\n+  probe_alias_cache(nullptr)->_index = AliasIdxTop;\n@@ -1088,1 +1088,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1094,1 +1094,1 @@\n-  if (_immutable_memory != NULL) {\n+  if (_immutable_memory != nullptr) {\n@@ -1106,1 +1106,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1112,1 +1112,1 @@\n-  if (tn != NULL)  verify_top(tn);\n+  if (tn != nullptr)  verify_top(tn);\n@@ -1117,3 +1117,3 @@\n-  if (_top != NULL)     _top->setup_is_top();\n-  if (old_top != NULL)  old_top->setup_is_top();\n-  assert(_top == NULL || top()->is_top(), \"\");\n+  if (_top != nullptr)     _top->setup_is_top();\n+  if (old_top != nullptr)  old_top->setup_is_top();\n+  assert(_top == nullptr || top()->is_top(), \"\");\n@@ -1132,2 +1132,2 @@\n-  \/\/ Return if CompileLog is NULL and PrintIdealNodeCount is false.\n-  if ((_log == NULL) && (! PrintIdealNodeCount)) {\n+  \/\/ Return if CompileLog is null and PrintIdealNodeCount is false.\n+  if ((_log == nullptr) && (! PrintIdealNodeCount)) {\n@@ -1151,1 +1151,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -1161,1 +1161,1 @@\n-          if (_log != NULL) {\n+          if (_log != nullptr) {\n@@ -1172,1 +1172,1 @@\n-        if (_log != NULL) {\n+        if (_log != nullptr) {\n@@ -1181,1 +1181,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -1187,1 +1187,1 @@\n-  if (_modified_nodes != NULL && !_inlining_incrementally && !n->is_Con()) {\n+  if (_modified_nodes != nullptr && !_inlining_incrementally && !n->is_Con()) {\n@@ -1193,1 +1193,1 @@\n-  if (_modified_nodes != NULL) {\n+  if (_modified_nodes != nullptr) {\n@@ -1201,1 +1201,1 @@\n-  if (tn != NULL) {\n+  if (tn != nullptr) {\n@@ -1204,1 +1204,1 @@\n-    assert(tn->in(0) != NULL, \"must have live top node\");\n+    assert(tn->in(0) != nullptr, \"must have live top node\");\n@@ -1213,1 +1213,1 @@\n-  guarantee(arr != NULL, \"\");\n+  guarantee(arr != nullptr, \"\");\n@@ -1228,1 +1228,1 @@\n-  if (source == NULL || dest == NULL)  return false;\n+  if (source == nullptr || dest == nullptr)  return false;\n@@ -1235,1 +1235,1 @@\n-  if (dest != NULL && dest != source && dest->debug_orig() == NULL) {\n+  if (dest != nullptr && dest != source && dest->debug_orig() == nullptr) {\n@@ -1240,1 +1240,1 @@\n-  if (node_note_array() == NULL)\n+  if (node_note_array() == nullptr)\n@@ -1246,1 +1246,1 @@\n-  if (source_notes == NULL || source_notes->is_clear())  return false;\n+  if (source_notes == nullptr || source_notes->is_clear())  return false;\n@@ -1248,1 +1248,1 @@\n-  if (dest_notes == NULL || dest_notes->is_clear()) {\n+  if (dest_notes == nullptr || dest_notes->is_clear()) {\n@@ -1281,1 +1281,1 @@\n-  bool is_known_inst = tj->isa_oopptr() != NULL &&\n+  bool is_known_inst = tj->isa_oopptr() != nullptr &&\n@@ -1337,1 +1337,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,offset);\n@@ -1341,1 +1341,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,offset);\n@@ -1353,1 +1353,1 @@\n-    if (ptr == TypePtr::NotNull || ta->klass_is_exact() || ta->speculative() != NULL) {\n+    if (ptr == TypePtr::NotNull || ta->klass_is_exact() || ta->speculative() != nullptr) {\n@@ -1378,1 +1378,1 @@\n-    if (to->speculative() != NULL) {\n+    if (to->speculative() != nullptr) {\n@@ -1386,1 +1386,1 @@\n-        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, offset);\n+        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, nullptr, offset);\n@@ -1392,1 +1392,1 @@\n-        to = NULL;\n+        to = nullptr;\n@@ -1401,1 +1401,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, offset, to->instance_id());\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, nullptr, offset, to->instance_id());\n@@ -1403,1 +1403,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, offset);\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, nullptr, offset);\n@@ -1503,2 +1503,2 @@\n-  _field = NULL;\n-  _element = NULL;\n+  _field = nullptr;\n+  _element = nullptr;\n@@ -1506,2 +1506,2 @@\n-  const TypeOopPtr *atoop = (at != NULL) ? at->isa_oopptr() : NULL;\n-  if (atoop != NULL && atoop->is_known_instance()) {\n+  const TypeOopPtr *atoop = (at != nullptr) ? at->isa_oopptr() : nullptr;\n+  if (atoop != nullptr && atoop->is_known_instance()) {\n@@ -1516,1 +1516,1 @@\n-  if (element() != NULL) {\n+  if (element() != nullptr) {\n@@ -1519,1 +1519,1 @@\n-  } if (field() != NULL) {\n+  } if (field() != nullptr) {\n@@ -1540,1 +1540,1 @@\n-  if (field() != NULL && tjp) {\n+  if (field() != nullptr && tjp) {\n@@ -1593,1 +1593,1 @@\n-  if (adr_type == NULL)             return alias_type(AliasIdxTop);\n+  if (adr_type == nullptr)          return alias_type(AliasIdxTop);\n@@ -1626,1 +1626,1 @@\n-    if (no_create)  return NULL;\n+    if (no_create)  return nullptr;\n@@ -1669,1 +1669,1 @@\n-      if (tinst->const_oop() != NULL &&\n+      if (tinst->const_oop() != nullptr &&\n@@ -1679,2 +1679,2 @@\n-      assert(field == NULL ||\n-             original_field == NULL ||\n+      assert(field == nullptr ||\n+             original_field == nullptr ||\n@@ -1685,1 +1685,1 @@\n-      if (field != NULL)  alias_type(idx)->set_field(field);\n+      if (field != nullptr)  alias_type(idx)->set_field(field);\n@@ -1696,1 +1696,1 @@\n-  if (face->_adr_type == NULL) {\n+  if (face->_adr_type == nullptr) {\n@@ -1726,1 +1726,1 @@\n-  if (adr_type == NULL)             return true;\n+  if (adr_type == nullptr)             return true;\n@@ -1729,1 +1729,1 @@\n-  return find_alias_type(adr_type, true, NULL) != NULL;\n+  return find_alias_type(adr_type, true, nullptr) != nullptr;\n@@ -1736,1 +1736,1 @@\n-  if (adr_type == NULL)                 return true;  \/\/ NULL serves as TypePtr::TOP\n+  if (adr_type == nullptr)              return true;  \/\/ null serves as TypePtr::TOP\n@@ -1754,1 +1754,1 @@\n-  if (adr_type == NULL)                 return false; \/\/ NULL serves as TypePtr::TOP\n+  if (adr_type == nullptr)              return false; \/\/ null serves as TypePtr::TOP\n@@ -1949,1 +1949,1 @@\n-        if (do_print_inlining || log() != NULL) {\n+        if (do_print_inlining || log() != nullptr) {\n@@ -2002,1 +2002,1 @@\n-  \/\/ Tracking and verification of modified nodes is disabled by setting \"_modified_nodes == NULL\"\n+  \/\/ Tracking and verification of modified nodes is disabled by setting \"_modified_nodes == nullptr\"\n@@ -2005,1 +2005,1 @@\n-  assert(_modified_nodes == NULL, \"not allowed\");\n+  assert(_modified_nodes == nullptr, \"not allowed\");\n@@ -2040,1 +2040,1 @@\n-  if (r != NULL) {\n+  if (r != nullptr) {\n@@ -2043,1 +2043,1 @@\n-      if (n != NULL && n->is_SafePoint()) {\n+      if (n != nullptr && n->is_SafePoint()) {\n@@ -2178,1 +2178,1 @@\n-    if (congraph() != NULL && macro_count() > 0) {\n+    if (congraph() != nullptr && macro_count() > 0) {\n@@ -2286,1 +2286,1 @@\n-  DEBUG_ONLY( _modified_nodes = NULL; )\n+  DEBUG_ONLY( _modified_nodes = nullptr; )\n@@ -2511,1 +2511,1 @@\n-  assert(n != NULL, \"\");\n+  assert(n != nullptr, \"\");\n@@ -2853,1 +2853,1 @@\n-            if (mem->in(i) != NULL) {\n+            if (mem->in(i) != nullptr) {\n@@ -2906,1 +2906,1 @@\n-    assert( n->in(0) != NULL || alias_idx != Compile::AliasIdxRaw ||\n+    assert( n->in(0) != nullptr || alias_idx != Compile::AliasIdxRaw ||\n@@ -3102,2 +3102,2 @@\n-      bool is_oop   = t->isa_oopptr() != NULL;\n-      bool is_klass = t->isa_klassptr() != NULL;\n+      bool is_oop   = t->isa_oopptr() != nullptr;\n+      bool is_klass = t->isa_klassptr() != nullptr;\n@@ -3107,1 +3107,1 @@\n-        Node* nn = NULL;\n+        Node* nn = nullptr;\n@@ -3116,1 +3116,1 @@\n-          if (m!= NULL && m->Opcode() == op &&\n+          if (m!= nullptr && m->Opcode() == op &&\n@@ -3122,1 +3122,1 @@\n-        if (nn != NULL) {\n+        if (nn != nullptr) {\n@@ -3139,1 +3139,1 @@\n-                assert(out_j == NULL || !out_j->is_AddP() || out_j->in(AddPNode::Base) != addp,\n+                assert(out_j == nullptr || !out_j->is_AddP() || out_j->in(AddPNode::Base) != addp,\n@@ -3163,1 +3163,1 @@\n-    if (n->in(0) != NULL) {\n+    if (n->in(0) != nullptr) {\n@@ -3198,1 +3198,1 @@\n-        \/\/ a narrow oop directly and do implicit NULL check in address:\n+        \/\/ a narrow oop directly and do implicit null check in address:\n@@ -3204,1 +3204,1 @@\n-        \/\/ use it to do implicit NULL check in address:\n+        \/\/ use it to do implicit null check in address:\n@@ -3211,1 +3211,1 @@\n-        \/\/ to keep the information to which NULL check the new DecodeN node\n+        \/\/ to keep the information to which null check the new DecodeN node\n@@ -3242,1 +3242,1 @@\n-      Node* new_in2 = NULL;\n+      Node* new_in2 = nullptr;\n@@ -3257,1 +3257,1 @@\n-          \/\/ will generated code for implicit NULL checks for compressed oops.\n+          \/\/ will generated code for implicit null checks for compressed oops.\n@@ -3263,1 +3263,1 @@\n-          \/\/    CmpP base_reg, NULL\n+          \/\/    CmpP base_reg, nullptr\n@@ -3270,1 +3270,1 @@\n-          \/\/    CmpN narrow_oop_reg, NULL\n+          \/\/    CmpN narrow_oop_reg, nullptr\n@@ -3274,1 +3274,1 @@\n-          \/\/ and the uncommon path (== NULL) will use narrow_oop_reg directly\n+          \/\/ and the uncommon path (== nullptr) will use narrow_oop_reg directly\n@@ -3298,1 +3298,1 @@\n-      if (new_in2 != NULL) {\n+      if (new_in2 != nullptr) {\n@@ -3316,1 +3316,1 @@\n-    assert(n->in(0) == NULL || (UseCompressedOops && !Matcher::narrow_oop_use_complex_address()), \"no control\");\n+    assert(n->in(0) == nullptr || (UseCompressedOops && !Matcher::narrow_oop_use_complex_address()), \"no control\");\n@@ -3351,1 +3351,1 @@\n-        if (non_io_proj  != NULL) {\n+        if (non_io_proj  != nullptr) {\n@@ -3364,1 +3364,1 @@\n-      assert(unique_in != NULL, \"\");\n+      assert(unique_in != nullptr, \"\");\n@@ -3368,1 +3368,1 @@\n-        assert(m != NULL, \"\");\n+        assert(m != nullptr, \"\");\n@@ -3370,1 +3370,1 @@\n-          unique_in = NULL;\n+          unique_in = nullptr;\n@@ -3372,1 +3372,1 @@\n-      if (unique_in != NULL) {\n+      if (unique_in != nullptr) {\n@@ -3490,1 +3490,1 @@\n-      if (t != NULL && t->is_con()) {\n+      if (t != nullptr && t->is_con()) {\n@@ -3496,1 +3496,1 @@\n-        if (t == NULL || t->_lo < 0 || t->_hi > (int)mask) {\n+        if (t == nullptr || t->_lo < 0 || t->_hi > (int)mask) {\n@@ -3550,1 +3550,1 @@\n-          if (k == NULL) {\n+          if (k == nullptr) {\n@@ -3607,2 +3607,2 @@\n-      if (m != NULL && !frc._visited.test_set(m->_idx)) {\n-        if (m->is_SafePoint() && m->as_SafePoint()->jvms() != NULL) {\n+      if (m != nullptr && !frc._visited.test_set(m->_idx)) {\n+        if (m->is_SafePoint() && m->as_SafePoint()->jvms() != nullptr) {\n@@ -3642,1 +3642,1 @@\n-    assert(jvms != NULL, \"sanity\");\n+    assert(jvms != nullptr, \"sanity\");\n@@ -3713,1 +3713,1 @@\n-    _expensive_nodes.at(i)->set_req(0, NULL);\n+    _expensive_nodes.at(i)->set_req(0, nullptr);\n@@ -3806,1 +3806,1 @@\n-        if (in != NULL) {\n+        if (in != nullptr) {\n@@ -3844,1 +3844,1 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : NULL;\n+  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : nullptr;\n@@ -3867,1 +3867,1 @@\n-      int mcount = (logmd == NULL)? -1: (int)logmd->trap_count(reason);\n+      int mcount = (logmd == nullptr)? -1: (int)logmd->trap_count(reason);\n@@ -3898,1 +3898,1 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : NULL;\n+  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : nullptr;\n@@ -4026,1 +4026,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4029,1 +4029,1 @@\n-  if (_failure_reason == NULL) {\n+  if (_failure_reason == nullptr) {\n@@ -4037,1 +4037,1 @@\n-  _root = NULL;  \/\/ flush the graph, too\n+  _root = nullptr;  \/\/ flush the graph, too\n@@ -4048,2 +4048,2 @@\n-    C = NULL;\n-    _log = NULL;\n+    C = nullptr;\n+    _log = nullptr;\n@@ -4051,1 +4051,1 @@\n-  if (_log != NULL) {\n+  if (_log != nullptr) {\n@@ -4064,1 +4064,1 @@\n-    _log = NULL;\n+    _log = nullptr;\n@@ -4078,1 +4078,1 @@\n-  if (_log != NULL) {\n+  if (_log != nullptr) {\n@@ -4152,1 +4152,1 @@\n-  if (sizetype != NULL) index_max = sizetype->_hi - 1;\n+  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n@@ -4161,1 +4161,1 @@\n-  if (ctrl != NULL) {\n+  if (ctrl != nullptr) {\n@@ -4176,1 +4176,1 @@\n-  if (_print_inlining_stream != NULL) {\n+  if (_print_inlining_stream != nullptr) {\n@@ -4178,1 +4178,1 @@\n-    _print_inlining_stream = NULL;\n+    _print_inlining_stream = nullptr;\n@@ -4233,1 +4233,1 @@\n-          (print_inlining_current()->cg() != NULL ||\n+          (print_inlining_current()->cg() != nullptr ||\n@@ -4240,1 +4240,1 @@\n-      if (print_inlining_current()->cg() != NULL) {\n+      if (print_inlining_current()->cg() != nullptr) {\n@@ -4282,1 +4282,1 @@\n-    assert(_print_inlining_list != NULL, \"process_print_inlining should be called only once.\");\n+    assert(_print_inlining_list != nullptr, \"process_print_inlining should be called only once.\");\n@@ -4287,1 +4287,1 @@\n-      DEBUG_ONLY(_print_inlining_list->at_put(i, NULL));\n+      DEBUG_ONLY(_print_inlining_list->at_put(i, nullptr));\n@@ -4291,1 +4291,1 @@\n-    _print_inlining_list = NULL;\n+    _print_inlining_list = nullptr;\n@@ -4302,1 +4302,1 @@\n-  if (_print_inlining_output != NULL) {\n+  if (_print_inlining_output != nullptr) {\n@@ -4308,1 +4308,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4312,1 +4312,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -4322,1 +4322,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4328,1 +4328,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4343,1 +4343,1 @@\n-  if (C->log() != NULL) {\n+  if (C->log() != nullptr) {\n@@ -4353,1 +4353,1 @@\n-  if (inl_tree != NULL) {\n+  if (inl_tree != nullptr) {\n@@ -4454,1 +4454,1 @@\n-      igvn.replace_input_of(n, 0, NULL);\n+      igvn.replace_input_of(n, 0, nullptr);\n@@ -4463,1 +4463,1 @@\n-    igvn.replace_input_of(n, 0, NULL);\n+    igvn.replace_input_of(n, 0, nullptr);\n@@ -4482,1 +4482,1 @@\n-    n->set_req(0, NULL);\n+    n->set_req(0, nullptr);\n@@ -4630,1 +4630,1 @@\n-      assert((t == NULL) || (t == t->remove_speculative()), \"no more speculative types\");\n+      assert((t == nullptr) || (t == t->remove_speculative()), \"no more speculative types\");\n@@ -4794,1 +4794,1 @@\n-  if (n != NULL) {\n+  if (n != nullptr) {\n@@ -4797,1 +4797,1 @@\n-    ss.print_raw(\": NULL\");\n+    ss.print_raw(\": nullptr\");\n@@ -4809,1 +4809,1 @@\n-  if (_method != NULL && should_print(level)) {\n+  if (_method != nullptr && should_print(level)) {\n@@ -4817,2 +4817,2 @@\n-IdealGraphPrinter* Compile::_debug_file_printer = NULL;\n-IdealGraphPrinter* Compile::_debug_network_printer = NULL;\n+IdealGraphPrinter* Compile::_debug_file_printer = nullptr;\n+IdealGraphPrinter* Compile::_debug_network_printer = nullptr;\n@@ -4870,1 +4870,1 @@\n-  if (_debug_file_printer == NULL) {\n+  if (_debug_file_printer == nullptr) {\n@@ -4880,1 +4880,1 @@\n-  if (_debug_network_printer == NULL) {\n+  if (_debug_network_printer == nullptr) {\n@@ -4895,1 +4895,1 @@\n-  if (type != NULL && phase->type(value)->higher_equal(type)) {\n+  if (type != nullptr && phase->type(value)->higher_equal(type)) {\n@@ -4898,1 +4898,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":214,"deletions":214,"binary":false,"changes":428,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  void insert(node_idx_t key, uint64_t val)      { assert(_dict->operator[](_2p(key)) == NULL, \"key existed\"); _dict->Insert(_2p(key), (void*)val); }\n+  void insert(node_idx_t key, uint64_t val)      { assert(_dict->operator[](_2p(key)) == nullptr, \"key existed\"); _dict->Insert(_2p(key), (void*)val); }\n@@ -179,1 +179,1 @@\n-  \/\/ Variant of TraceTime(NULL, &_t_accumulator, CITime);\n+  \/\/ Variant of TraceTime(nullptr, &_t_accumulator, CITime);\n@@ -228,1 +228,1 @@\n-      assert(_element == NULL, \"\");\n+      assert(_element == nullptr, \"\");\n@@ -258,3 +258,3 @@\n-  address               _stub_function;         \/\/ VM entry for stub being compiled, or NULL\n-  const char*           _stub_name;             \/\/ Name of stub or adapter being compiled, or NULL\n-  address               _stub_entry_point;      \/\/ Compile code entry for generated stub, or NULL\n+  address               _stub_function;         \/\/ VM entry for stub being compiled, or null\n+  const char*           _stub_name;             \/\/ Name of stub or adapter being compiled, or null\n+  address               _stub_entry_point;      \/\/ Compile code entry for generated stub, or null\n@@ -343,1 +343,1 @@\n-  RootNode*             _root;                  \/\/ Unique root of compilation, or NULL after bail-out.\n+  RootNode*             _root;                  \/\/ Unique root of compilation, or null after bail-out.\n@@ -406,1 +406,1 @@\n-      : _cg(NULL), _ss(default_stream_buffer_size) {}\n+      : _cg(nullptr), _ss(default_stream_buffer_size) {}\n@@ -454,1 +454,1 @@\n-  void print_inlining(ciMethod* method, int inline_level, int bci, const char* msg = NULL) {\n+  void print_inlining(ciMethod* method, int inline_level, int bci, const char* msg = nullptr) {\n@@ -522,3 +522,3 @@\n-  bool              is_method_compilation() const { return (_method != NULL && !_method->flags().is_native()); }\n-  const TypeFunc*   tf() const                  { assert(_tf!=NULL, \"\"); return _tf; }\n-  void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, \"\"); _tf = tf; }\n+  bool              is_method_compilation() const { return (_method != nullptr && !_method->flags().is_native()); }\n+  const TypeFunc*   tf() const                  { assert(_tf!=nullptr, \"\"); return _tf; }\n+  void         init_tf(const TypeFunc* tf)      { assert(_tf==nullptr, \"\"); _tf = tf; }\n@@ -601,1 +601,1 @@\n-    return method() != NULL && method()->has_option(option);\n+    return method() != nullptr && method()->has_option(option);\n@@ -623,1 +623,1 @@\n-    if (_method != NULL && should_print(level)) {\n+    if (_method != nullptr && should_print(level)) {\n@@ -639,1 +639,1 @@\n-      assert(_printer != NULL, \"_printer is NULL when we need it!\");\n+      assert(_printer != nullptr, \"_printer is nullptr when we need it!\");\n@@ -742,1 +742,1 @@\n-  bool        failing() const        { return _env->failing() || _failure_reason != NULL; }\n+  bool        failing() const        { return _env->failing() || _failure_reason != nullptr; }\n@@ -746,1 +746,1 @@\n-    return (r == _failure_reason) || (r != NULL && _failure_reason != NULL && strcmp(r, _failure_reason) == 0);\n+    return (r == _failure_reason) || (r != nullptr && _failure_reason != nullptr && strcmp(r, _failure_reason) == 0);\n@@ -808,1 +808,1 @@\n-  bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != NULL; }\n+  bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != nullptr; }\n@@ -852,1 +852,1 @@\n-    return (m == _last_tf_m) ? _last_tf : NULL;\n+    return (m == _last_tf_m) ? _last_tf : nullptr;\n@@ -855,1 +855,1 @@\n-    assert(m != NULL || tf == NULL, \"\");\n+    assert(m != nullptr || tf == nullptr, \"\");\n@@ -861,1 +861,1 @@\n-  AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL) { return find_alias_type(adr_type, false, field); }\n+  AliasType*        alias_type(const TypePtr* adr_type, ciField* field = nullptr) { return find_alias_type(adr_type, false, field); }\n@@ -877,1 +877,1 @@\n-                                   JVMState* jvms, bool allow_inline, float profile_factor, ciKlass* speculative_receiver_type = NULL,\n+                                   JVMState* jvms, bool allow_inline, float profile_factor, ciKlass* speculative_receiver_type = nullptr,\n@@ -907,1 +907,1 @@\n-                      ciMethodData* logmd = NULL);\n+                      ciMethodData* logmd = nullptr);\n@@ -1050,1 +1050,1 @@\n-  bool has_method() { return method() != NULL; }\n+  bool has_method() { return method() != nullptr; }\n@@ -1168,1 +1168,1 @@\n-                              Node* ctrl = NULL);\n+                              Node* ctrl = nullptr);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/opto\/connode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  ConPNode( const TypePtr *t ) : ConNode(t) {}\n+  ConPNode(const TypePtr *t) : ConNode(t) {}\n@@ -75,4 +75,5 @@\n-    if (con == NULL)\n-      return new ConPNode( TypePtr::NULL_PTR ) ;\n-    else\n-      return new ConPNode( TypeRawPtr::make(con) );\n+    if (con == nullptr) {\n+      return new ConPNode(TypePtr::NULL_PTR);\n+    } else {\n+      return new ConPNode(TypeRawPtr::make(con));\n+    }\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    address constant_addr = NULL;\n+    address constant_addr = nullptr;\n@@ -146,1 +146,1 @@\n-      if (constant_addr == NULL) {\n+      if (constant_addr == nullptr) {\n@@ -153,1 +153,1 @@\n-      address last_addr = NULL;\n+      address last_addr = nullptr;\n@@ -156,1 +156,1 @@\n-        if (last_addr == NULL) {\n+        if (last_addr == nullptr) {\n@@ -180,1 +180,1 @@\n-    if (constant_addr == NULL) {\n+    if (constant_addr == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  if( tp != NULL ) {\n+  if(tp != nullptr) {\n@@ -88,1 +88,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -115,1 +115,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -151,1 +151,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -190,1 +190,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -219,1 +219,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -278,1 +278,1 @@\n-  if (existing != NULL) {\n+  if (existing != nullptr) {\n@@ -364,1 +364,1 @@\n-  Node* this_changed = NULL;\n+  Node* this_changed = nullptr;\n@@ -366,1 +366,1 @@\n-  if (igvn != NULL) {\n+  if (igvn != nullptr) {\n@@ -370,1 +370,1 @@\n-      if (in_type != NULL && this_type != NULL &&\n+      if (in_type != nullptr && this_type != nullptr &&\n@@ -433,2 +433,2 @@\n-  const TypeInteger* rx = NULL;\n-  const TypeInteger* ry = NULL;\n+  const TypeInteger* rx = nullptr;\n+  const TypeInteger* ry = nullptr;\n@@ -436,1 +436,1 @@\n-    if (igvn == NULL) {\n+    if (igvn == nullptr) {\n@@ -521,1 +521,1 @@\n-    if (andl->outcnt() > 1) return NULL;\n+    if (andl->outcnt() > 1) return nullptr;\n@@ -526,2 +526,2 @@\n-    if (phase->type(x) == Type::TOP)  return NULL;\n-    if (phase->type(y) == Type::TOP)  return NULL;\n+    if (phase->type(x) == Type::TOP)  return nullptr;\n+    if (phase->type(y) == Type::TOP)  return nullptr;\n@@ -536,1 +536,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-\/\/ Return NULL if no transformation occurs.\n+\/\/ Return null if no transformation occurs.\n@@ -104,1 +104,1 @@\n-  Node *q = NULL;\n+  Node *q = nullptr;\n@@ -337,1 +337,1 @@\n-\/\/ Return NULL if no transformation occurs.\n+\/\/ Return null if no transformation occurs.\n@@ -348,1 +348,1 @@\n-  Node *q = NULL;\n+  Node *q = nullptr;\n@@ -463,1 +463,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -466,2 +466,2 @@\n-  if( t == TypeInt::ONE )       \/\/ Identity?\n-    return NULL;                \/\/ Skip it\n+  if( t == TypeInt::ONE )      \/\/ Identity?\n+    return nullptr;            \/\/ Skip it\n@@ -470,1 +470,1 @@\n-  if( !ti ) return NULL;\n+  if( !ti ) return nullptr;\n@@ -475,1 +475,1 @@\n-    set_req(0, NULL);           \/\/ Yank control input\n+    set_req(0, nullptr);           \/\/ Yank control input\n@@ -479,1 +479,1 @@\n-  if( !ti->is_con() ) return NULL;\n+  if( !ti->is_con() ) return nullptr;\n@@ -482,1 +482,1 @@\n-  if (i == 0) return NULL;      \/\/ Dividing by zero constant does not idealize\n+  if (i == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n@@ -485,1 +485,1 @@\n-  if( i == min_jint ) return NULL;\n+  if( i == min_jint ) return nullptr;\n@@ -569,1 +569,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -573,1 +573,1 @@\n-    return NULL;                \/\/ Skip it\n+    return nullptr;             \/\/ Skip it\n@@ -576,1 +576,1 @@\n-  if( !tl ) return NULL;\n+  if( !tl ) return nullptr;\n@@ -581,1 +581,1 @@\n-    set_req(0, NULL);           \/\/ Yank control input\n+    set_req(0, nullptr);         \/\/ Yank control input\n@@ -585,1 +585,1 @@\n-  if( !tl->is_con() ) return NULL;\n+  if( !tl->is_con() ) return nullptr;\n@@ -588,1 +588,1 @@\n-  if (l == 0) return NULL;      \/\/ Dividing by zero constant does not idealize\n+  if (l == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n@@ -591,1 +591,1 @@\n-  if( l == min_jlong ) return NULL;\n+  if( l == min_jlong ) return nullptr;\n@@ -720,1 +720,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -724,1 +724,1 @@\n-    return NULL;                \/\/ Skip it\n+    return nullptr;              \/\/ Skip it\n@@ -727,2 +727,2 @@\n-  if( !tf ) return NULL;\n-  if( tf->base() != Type::FloatCon ) return NULL;\n+  if( !tf ) return nullptr;\n+  if( tf->base() != Type::FloatCon ) return nullptr;\n@@ -731,1 +731,1 @@\n-  if( tf->is_nan() || !tf->is_finite() ) return NULL;\n+  if( tf->is_nan() || !tf->is_finite() ) return nullptr;\n@@ -738,1 +738,1 @@\n-  if( frexp((double)f, &exp) != 0.5 ) return NULL;\n+  if( frexp((double)f, &exp) != 0.5 ) return nullptr;\n@@ -741,1 +741,1 @@\n-  if( exp < -126 || exp > 126 ) return NULL;\n+  if( exp < -126 || exp > 126 ) return nullptr;\n@@ -812,1 +812,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -816,1 +816,1 @@\n-    return NULL;                \/\/ Skip it\n+    return nullptr;              \/\/ Skip it\n@@ -819,2 +819,2 @@\n-  if( !td ) return NULL;\n-  if( td->base() != Type::DoubleCon ) return NULL;\n+  if( !td ) return nullptr;\n+  if( td->base() != Type::DoubleCon ) return nullptr;\n@@ -823,1 +823,1 @@\n-  if( td->is_nan() || !td->is_finite() ) return NULL;\n+  if( td->is_nan() || !td->is_finite() ) return nullptr;\n@@ -830,1 +830,1 @@\n-  if( frexp(d, &exp) != 0.5 ) return NULL;\n+  if( frexp(d, &exp) != 0.5 ) return nullptr;\n@@ -833,1 +833,1 @@\n-  if( exp < -1021 || exp > 1022 ) return NULL;\n+  if( exp < -1021 || exp > 1022 ) return nullptr;\n@@ -850,1 +850,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -854,1 +854,1 @@\n-  if( t == Type::TOP ) return NULL;\n+  if( t == Type::TOP ) return nullptr;\n@@ -860,1 +860,1 @@\n-    set_req(0, NULL);        \/\/ Yank control input\n+    set_req(0, nullptr);        \/\/ Yank control input\n@@ -865,1 +865,1 @@\n-  if( !ti->is_con() ) return NULL;\n+  if( !ti->is_con() ) return nullptr;\n@@ -918,1 +918,1 @@\n-  if( con == 0 || con == min_jint ) return NULL;\n+  if( con == 0 || con == min_jint ) return nullptr;\n@@ -945,1 +945,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -949,1 +949,1 @@\n-    Node *mult = NULL;\n+    Node *mult = nullptr;\n@@ -1015,1 +1015,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -1019,1 +1019,1 @@\n-  if( t == Type::TOP ) return NULL;\n+  if( t == Type::TOP ) return nullptr;\n@@ -1025,1 +1025,1 @@\n-    set_req(0, NULL);        \/\/ Yank control input\n+    set_req(0, nullptr);        \/\/ Yank control input\n@@ -1030,1 +1030,1 @@\n-  if( !tl->is_con() ) return NULL;\n+  if( !tl->is_con() ) return nullptr;\n@@ -1085,1 +1085,1 @@\n-  if( con == 0 || con == min_jlong ) return NULL;\n+  if( con == 0 || con == min_jlong ) return nullptr;\n@@ -1112,1 +1112,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1116,1 +1116,1 @@\n-    Node *mult = NULL;\n+    Node *mult = nullptr;\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) { return NULL; }\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) { return nullptr; }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  assert(callee != NULL, \"failed method resolution\");\n+  assert(callee != nullptr, \"failed method resolution\");\n@@ -102,1 +102,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -124,1 +124,1 @@\n-  CallGenerator* cg_intrinsic = NULL;\n+  CallGenerator* cg_intrinsic = nullptr;\n@@ -127,1 +127,1 @@\n-    if (cg != NULL) {\n+    if (cg != nullptr) {\n@@ -132,1 +132,1 @@\n-        if (inline_cg != NULL) {\n+        if (inline_cg != nullptr) {\n@@ -142,1 +142,1 @@\n-        cg = NULL;\n+        cg = nullptr;\n@@ -180,1 +180,1 @@\n-        if (cg != NULL && is_virtual_or_interface && !callee->is_static()) {\n+        if (cg != nullptr && is_virtual_or_interface && !callee->is_static()) {\n@@ -186,1 +186,1 @@\n-        if (cg != NULL) {\n+        if (cg != nullptr) {\n@@ -209,1 +209,1 @@\n-      ciMethod* receiver_method = NULL;\n+      ciMethod* receiver_method = nullptr;\n@@ -212,1 +212,1 @@\n-      if (speculative_receiver_type != NULL) {\n+      if (speculative_receiver_type != nullptr) {\n@@ -220,2 +220,2 @@\n-          if (receiver_method == NULL) {\n-            speculative_receiver_type = NULL;\n+          if (receiver_method == nullptr) {\n+            speculative_receiver_type = nullptr;\n@@ -228,1 +228,1 @@\n-          speculative_receiver_type = NULL;\n+          speculative_receiver_type = nullptr;\n@@ -231,1 +231,1 @@\n-      if (receiver_method == NULL &&\n+      if (receiver_method == nullptr &&\n@@ -239,1 +239,1 @@\n-      if (receiver_method != NULL) {\n+      if (receiver_method != nullptr) {\n@@ -243,1 +243,1 @@\n-        if (hit_cg != NULL) {\n+        if (hit_cg != nullptr) {\n@@ -245,2 +245,2 @@\n-          CallGenerator* next_hit_cg = NULL;\n-          ciMethod* next_receiver_method = NULL;\n+          CallGenerator* next_hit_cg = nullptr;\n+          ciMethod* next_receiver_method = nullptr;\n@@ -250,1 +250,1 @@\n-            if (next_receiver_method != NULL) {\n+            if (next_receiver_method != nullptr) {\n@@ -254,1 +254,1 @@\n-              if (next_hit_cg != NULL && !next_hit_cg->is_inline() &&\n+              if (next_hit_cg != nullptr && !next_hit_cg->is_inline() &&\n@@ -257,1 +257,1 @@\n-                  next_hit_cg = NULL;\n+                  next_hit_cg = nullptr;\n@@ -264,2 +264,2 @@\n-                                               : Deoptimization::reason_class_check(speculative_receiver_type != NULL));\n-          if ((morphism == 1 || (morphism == 2 && next_hit_cg != NULL)) &&\n+                                               : Deoptimization::reason_class_check(speculative_receiver_type != nullptr));\n+          if ((morphism == 1 || (morphism == 2 && next_hit_cg != nullptr)) &&\n@@ -278,3 +278,3 @@\n-          if (miss_cg != NULL) {\n-            if (next_hit_cg != NULL) {\n-              assert(speculative_receiver_type == NULL, \"shouldn't end up here if we used speculation\");\n+          if (miss_cg != nullptr) {\n+            if (next_hit_cg != nullptr) {\n+              assert(speculative_receiver_type == nullptr, \"shouldn't end up here if we used speculation\");\n@@ -286,2 +286,2 @@\n-            if (miss_cg != NULL) {\n-              ciKlass* k = speculative_receiver_type != NULL ? speculative_receiver_type : profile.receiver(0);\n+            if (miss_cg != nullptr) {\n+              ciKlass* k = speculative_receiver_type != nullptr ? speculative_receiver_type : profile.receiver(0);\n@@ -289,1 +289,1 @@\n-              float hit_prob = speculative_receiver_type != NULL ? 1.0 : profile.receiver_prob(0);\n+              float hit_prob = speculative_receiver_type != nullptr ? 1.0 : profile.receiver_prob(0);\n@@ -291,1 +291,1 @@\n-              if (cg != NULL)  return cg;\n+              if (cg != nullptr)  return cg;\n@@ -317,1 +317,1 @@\n-      if (singleton != NULL) {\n+      if (singleton != nullptr) {\n@@ -323,1 +323,1 @@\n-        if (cha_monomorphic_target != NULL &&\n+        if (cha_monomorphic_target != nullptr &&\n@@ -337,1 +337,1 @@\n-          if (hit_cg != NULL && cg != NULL) {\n+          if (hit_cg != nullptr && cg != nullptr) {\n@@ -348,1 +348,1 @@\n-    if (allow_intrinsics && cg_intrinsic != NULL) {\n+    if (allow_intrinsics && cg_intrinsic != nullptr) {\n@@ -372,1 +372,1 @@\n-    if (cg != NULL && is_virtual_or_interface && !callee->is_static()) {\n+    if (cg != nullptr && is_virtual_or_interface && !callee->is_static()) {\n@@ -418,1 +418,1 @@\n-            if (m != NULL &&\n+            if (m != nullptr &&\n@@ -508,1 +508,1 @@\n-  ciSignature*     declared_signature = NULL;\n+  ciSignature*     declared_signature = nullptr;\n@@ -513,1 +513,1 @@\n-  assert(declared_signature != NULL, \"cannot be null\");\n+  assert(declared_signature != nullptr, \"cannot be null\");\n@@ -533,1 +533,1 @@\n-  assert(holder_klass->is_interface() || holder_klass->super() == NULL || (bc() != Bytecodes::_invokeinterface), \"must match bc\");\n+  assert(holder_klass->is_interface() || holder_klass->super() == nullptr || (bc() != Bytecodes::_invokeinterface), \"must match bc\");\n@@ -563,1 +563,1 @@\n-  ciKlass* speculative_receiver_type = NULL;\n+  ciKlass* speculative_receiver_type = nullptr;\n@@ -577,1 +577,1 @@\n-    speculative_receiver_type = receiver_type != NULL ? receiver_type->speculative_type() : NULL;\n+    speculative_receiver_type = receiver_type != nullptr ? receiver_type->speculative_type() : nullptr;\n@@ -581,1 +581,1 @@\n-  ciKlass* receiver_constraint = NULL;\n+  ciKlass* receiver_constraint = nullptr;\n@@ -593,1 +593,1 @@\n-  if (receiver_constraint != NULL) {\n+  if (receiver_constraint != nullptr) {\n@@ -596,1 +596,1 @@\n-    Node* bad_type_ctrl = NULL;\n+    Node* bad_type_ctrl = nullptr;\n@@ -598,1 +598,1 @@\n-    if (bad_type_ctrl != NULL) {\n+    if (bad_type_ctrl != nullptr) {\n@@ -626,1 +626,1 @@\n-  orig_callee = callee = NULL;\n+  orig_callee = callee = nullptr;\n@@ -648,1 +648,1 @@\n-  Node* receiver = has_receiver ? argument(0) : NULL;\n+  Node* receiver = has_receiver ? argument(0) : nullptr;\n@@ -651,1 +651,1 @@\n-  if (receiver != NULL && !call_does_dispatch && !cg->is_string_late_inline()) {\n+  if (receiver != nullptr && !call_does_dispatch && !cg->is_string_late_inline()) {\n@@ -658,1 +658,1 @@\n-  if (new_jvms == NULL) {\n+  if (new_jvms == nullptr) {\n@@ -672,1 +672,1 @@\n-    if (new_jvms == NULL) {\n+    if (new_jvms == nullptr) {\n@@ -698,1 +698,1 @@\n-    if (receiver != NULL && cg->is_virtual()) {\n+    if (receiver != nullptr && cg->is_virtual()) {\n@@ -724,1 +724,1 @@\n-            if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {\n+            if (arg_type != nullptr && !arg_type->higher_equal(sig_type)) {\n@@ -757,1 +757,1 @@\n-      if (C->log() != NULL) {\n+      if (C->log() != nullptr) {\n@@ -789,1 +789,1 @@\n-  GrowableArray<const Type*>* extypes = new (C->node_arena()) GrowableArray<const Type*>(C->node_arena(), 8, 0, NULL);\n+  GrowableArray<const Type*>* extypes = new (C->node_arena()) GrowableArray<const Type*>(C->node_arena(), 8, 0, nullptr);\n@@ -899,1 +899,1 @@\n-  assert(stopped(), \"call set_map(NULL) first\");\n+  assert(stopped(), \"call set_map(nullptr) first\");\n@@ -908,2 +908,2 @@\n-  NOT_PRODUCT(if (ex_type==NULL) tty->print_cr(\"*** Exception not InstPtr\"));\n-  if (ex_type == NULL)\n+  NOT_PRODUCT(if (ex_type==nullptr) tty->print_cr(\"*** Exception not InstPtr\"));\n+  if (ex_type == nullptr)\n@@ -922,1 +922,1 @@\n-  Node* ex_klass_node = NULL;\n+  Node* ex_klass_node = nullptr;\n@@ -925,1 +925,1 @@\n-    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n+    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n@@ -937,1 +937,1 @@\n-        if (ex_in == top() || ex_in == NULL) {\n+        if (ex_in == top() || ex_in == nullptr) {\n@@ -943,1 +943,1 @@\n-        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n+        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n@@ -1029,1 +1029,1 @@\n-                    NULL, NULL,\n+                    nullptr, nullptr,\n@@ -1092,1 +1092,1 @@\n-  if (optimized_virtual_method != NULL) {\n+  if (optimized_virtual_method != nullptr) {\n@@ -1116,2 +1116,2 @@\n-  if (receiver_type == NULL) {\n-    return NULL; \/\/ no receiver type info\n+  if (receiver_type == nullptr) {\n+    return nullptr; \/\/ no receiver type info\n@@ -1133,1 +1133,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1149,1 +1149,1 @@\n-  if (cha_monomorphic_target != NULL) {\n+  if (cha_monomorphic_target != nullptr) {\n@@ -1170,1 +1170,1 @@\n-    if (exact_method != NULL) {\n+    if (exact_method != nullptr) {\n@@ -1175,1 +1175,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-    w->_dom_next = w->_dom_child = NULL;  \/\/ Initialize for building tree later\n+    w->_dom_next = w->_dom_child = nullptr;  \/\/ Initialize for building tree later\n@@ -136,2 +136,2 @@\n-  w->_dom = NULL;\n-  w->_dom_next = w->_dom_child = NULL;  \/\/ Initialize for building tree later\n+  w->_dom = nullptr;\n+  w->_dom_next = w->_dom_child = nullptr;  \/\/ Initialize for building tree later\n@@ -148,1 +148,1 @@\n-      t->_block->_idom = NULL;  \/\/ Root\n+      t->_block->_idom = nullptr;  \/\/ Root\n@@ -178,1 +178,1 @@\n-      t->_ancestor = NULL;          \/\/ Fast LINK & EVAL setup\n+      t->_ancestor = nullptr;       \/\/ Fast LINK & EVAL setup\n@@ -181,1 +181,1 @@\n-      t->_bucket = NULL;\n+      t->_bucket = nullptr;\n@@ -183,1 +183,1 @@\n-        t->_parent = NULL;          \/\/ first block doesn't have parent\n+        t->_parent = nullptr;       \/\/ first block doesn't have parent\n@@ -344,1 +344,1 @@\n-        if (dom_child != NULL) {\n+        if (dom_child != nullptr) {\n@@ -348,1 +348,1 @@\n-      } while (t != NULL);\n+      } while (t != nullptr);\n@@ -398,1 +398,1 @@\n-    ntarjan[i]._control = NULL;\n+    ntarjan[i]._control = nullptr;\n@@ -416,1 +416,1 @@\n-    assert(w->_control != NULL,\"bad DFS walk\");\n+    assert(w->_control != nullptr,\"bad DFS walk\");\n@@ -421,1 +421,1 @@\n-      if( whead->in(j) == NULL || !whead->in(j)->is_CFG() )\n+      if( whead->in(j) == nullptr || !whead->in(j)->is_CFG() )\n@@ -471,1 +471,1 @@\n-    assert(w->_control != NULL,\"Bad DFS walk\");\n+    assert(w->_control != nullptr,\"Bad DFS walk\");\n@@ -474,1 +474,1 @@\n-    w->_dom_next = w->_dom_child = NULL;  \/\/ Initialize for building tree later\n+    w->_dom_next = w->_dom_child = nullptr;  \/\/ Initialize for building tree later\n@@ -478,3 +478,3 @@\n-  w->_dom = NULL;\n-  w->_parent = NULL;\n-  w->_dom_next = w->_dom_child = NULL;  \/\/ Initialize for building tree later\n+  w->_dom = nullptr;\n+  w->_parent = nullptr;\n+  w->_dom_next = w->_dom_child = nullptr;  \/\/ Initialize for building tree later\n@@ -485,1 +485,1 @@\n-    assert(t->_control != NULL,\"Bad DFS walk\");\n+    assert(t->_control != nullptr,\"Bad DFS walk\");\n@@ -492,1 +492,1 @@\n-      _idom[C->root()->_idx] = NULL; \/\/ Root\n+      _idom[C->root()->_idx] = nullptr; \/\/ Root\n@@ -528,1 +528,1 @@\n-      w->_ancestor = NULL;             \/\/ Fast LINK & EVAL setup\n+      w->_ancestor = nullptr;             \/\/ Fast LINK & EVAL setup\n@@ -531,1 +531,1 @@\n-      w->_bucket = NULL;\n+      w->_bucket = nullptr;\n@@ -607,1 +607,1 @@\n-        if (dom_child != NULL) {\n+        if (dom_child != nullptr) {\n@@ -611,1 +611,1 @@\n-      } while (t != NULL);\n+      } while (t != nullptr);\n@@ -631,1 +631,1 @@\n-  if(_parent != NULL)\n+  if(_parent != nullptr)\n@@ -637,1 +637,1 @@\n-  if(_dom != NULL)\n+  if(_dom != nullptr)\n","filename":"src\/hotspot\/share\/opto\/domgraph.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  _nodes(C->comp_arena(), C->unique(), C->unique(), NULL),\n+  _nodes(C->comp_arena(), C->unique(), C->unique(), nullptr),\n@@ -56,1 +56,1 @@\n-  \/\/ Add ConP(#NULL) and ConN(#NULL) nodes.\n+  \/\/ Add ConP and ConN null oop nodes\n@@ -95,1 +95,1 @@\n-  \/\/ Add ConP#NULL and ConN#NULL nodes before ConnectionGraph construction\n+  \/\/ Add ConP#nullptr and ConN#nullptr nodes before ConnectionGraph construction\n@@ -134,1 +134,1 @@\n-  ideal_nodes.map(C->live_nodes(), NULL);  \/\/ preallocate space\n+  ideal_nodes.map(C->live_nodes(), nullptr);  \/\/ preallocate space\n@@ -136,1 +136,1 @@\n-  if (C->root() != NULL) {\n+  if (C->root() != nullptr) {\n@@ -151,1 +151,1 @@\n-    if (ptn != NULL && ptn != phantom_obj) {\n+    if (ptn != nullptr && ptn != phantom_obj) {\n@@ -364,1 +364,1 @@\n-  for (JVMState* jvms = sfn->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = sfn->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -382,1 +382,1 @@\n-        if (m != NULL && not_global_escape(m)) {\n+        if (m != nullptr && not_global_escape(m)) {\n@@ -394,1 +394,1 @@\n-  if (call->method() != NULL) {\n+  if (call->method() != nullptr) {\n@@ -404,1 +404,1 @@\n-    assert(name != NULL, \"no name\");\n+    assert(name != nullptr, \"no name\");\n@@ -411,1 +411,1 @@\n-        if (at->isa_oopptr() != NULL) {\n+        if (at->isa_oopptr() != nullptr) {\n@@ -427,1 +427,1 @@\n-  if (t->make_ptr() != NULL) {\n+  if (t->make_ptr() != nullptr) {\n@@ -433,1 +433,1 @@\n-      assert((ptnode_adr(adr->_idx) == NULL ||\n+      assert((ptnode_adr(adr->_idx) == nullptr ||\n@@ -449,1 +449,1 @@\n-  if (n_ptn != NULL) {\n+  if (n_ptn != nullptr) {\n@@ -470,1 +470,1 @@\n-        if (name != NULL && strcmp(name, \"uncommon_trap\") == 0) {\n+        if (name != nullptr && strcmp(name, \"uncommon_trap\") == 0) {\n@@ -478,1 +478,1 @@\n-           n->as_Call()->proj_out_or_null(TypeFunc::Parms) != NULL) ||\n+           n->as_Call()->proj_out_or_null(TypeFunc::Parms) != nullptr) ||\n@@ -501,1 +501,1 @@\n-      if (ptn_base == NULL) {\n+      if (ptn_base == nullptr) {\n@@ -575,1 +575,1 @@\n-      if (t->make_ptr() != NULL) {\n+      if (t->make_ptr() != nullptr) {\n@@ -685,1 +685,1 @@\n-         (n_ptn != NULL) && (n_ptn->ideal_node() != NULL),\n+         (n_ptn != nullptr) && (n_ptn->ideal_node() != nullptr),\n@@ -696,1 +696,1 @@\n-      assert(ptn_base != NULL, \"field's base should be registered\");\n+      assert(ptn_base != nullptr, \"field's base should be registered\");\n@@ -707,1 +707,1 @@\n-                             n->in(1), NULL);\n+                             n->in(1), nullptr);\n@@ -713,2 +713,2 @@\n-        if (in == NULL) {\n-          continue;  \/\/ ignore NULL\n+        if (in == nullptr) {\n+          continue;  \/\/ ignore nullptr\n@@ -721,1 +721,1 @@\n-        assert(ptn != NULL, \"node should be registered\");\n+        assert(ptn != nullptr, \"node should be registered\");\n@@ -732,1 +732,1 @@\n-      if (t->make_ptr() != NULL) {\n+      if (t->make_ptr() != nullptr) {\n@@ -734,1 +734,1 @@\n-        add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);\n+        add_local_var_and_edge(n, PointsToNode::NoEscape, adr, nullptr);\n@@ -743,1 +743,1 @@\n-      if (t->make_ptr() != NULL) {\n+      if (t->make_ptr() != nullptr) {\n@@ -746,2 +746,2 @@\n-          if (in == NULL) {\n-            continue;  \/\/ ignore NULL\n+          if (in == nullptr) {\n+            continue;  \/\/ ignore nullptr\n@@ -754,1 +754,1 @@\n-          assert(ptn != NULL, \"node should be registered\");\n+          assert(ptn != nullptr, \"node should be registered\");\n@@ -765,1 +765,1 @@\n-        add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), NULL);\n+        add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), nullptr);\n@@ -776,1 +776,1 @@\n-                               n->in(TypeFunc::Parms), NULL);\n+                               n->in(TypeFunc::Parms), nullptr);\n@@ -815,1 +815,1 @@\n-                 at->isa_ptr() != NULL, \"expecting a pointer\");\n+                 at->isa_ptr() != nullptr, \"expecting a pointer\");\n@@ -820,1 +820,1 @@\n-          assert(ptn != NULL, \"node should be registered\");\n+          assert(ptn != nullptr, \"node should be registered\");\n@@ -862,1 +862,1 @@\n-  if (adr_type == NULL) {\n+  if (adr_type == nullptr) {\n@@ -900,1 +900,1 @@\n-  if (adr_type == NULL) {\n+  if (adr_type == nullptr) {\n@@ -902,1 +902,1 @@\n-    assert(adr_type != NULL, \"dead node should not be on list\");\n+    assert(adr_type != nullptr, \"dead node should not be on list\");\n@@ -909,1 +909,1 @@\n-    add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);\n+    add_local_var_and_edge(n, PointsToNode::NoEscape, adr, nullptr);\n@@ -918,1 +918,1 @@\n-    assert(adr_ptn != NULL &&\n+    assert(adr_ptn != nullptr &&\n@@ -922,1 +922,1 @@\n-    assert(ptn != NULL, \"node should be registered\");\n+    assert(ptn != nullptr, \"node should be registered\");\n@@ -929,1 +929,1 @@\n-    assert(ptn != NULL, \"node should be registered\");\n+    assert(ptn != nullptr, \"node should be registered\");\n@@ -933,1 +933,1 @@\n-    assert(adr_ptn != NULL, \"node should be registered\");\n+    assert(adr_ptn != nullptr, \"node should be registered\");\n@@ -949,1 +949,1 @@\n-    assert(kt != NULL, \"TypeKlassPtr  required.\");\n+    assert(kt != nullptr, \"TypeKlassPtr  required.\");\n@@ -1007,1 +1007,1 @@\n-    if (meth == NULL) {\n+    if (meth == nullptr) {\n@@ -1040,1 +1040,1 @@\n-          if (d->field_at(i)->isa_ptr() != NULL &&\n+          if (d->field_at(i)->isa_ptr() != nullptr &&\n@@ -1090,1 +1090,1 @@\n-        if (arg == NULL) {\n+        if (arg == nullptr) {\n@@ -1109,1 +1109,1 @@\n-        assert(arg_ptn != NULL, \"should be registered\");\n+        assert(arg_ptn != nullptr, \"should be registered\");\n@@ -1113,1 +1113,1 @@\n-                 aat->isa_ptr() != NULL, \"expecting an Ptr\");\n+                 aat->isa_ptr() != nullptr, \"expecting an Ptr\");\n@@ -1115,1 +1115,1 @@\n-                              (aat->isa_oopptr()->klass() == NULL || aat->isa_instptr() ||\n+                              (aat->isa_oopptr()->klass() == nullptr || aat->isa_instptr() ||\n@@ -1133,1 +1133,1 @@\n-                (call->as_CallLeaf()->_name != NULL &&\n+                (call->as_CallLeaf()->_name != nullptr &&\n@@ -1195,1 +1195,1 @@\n-            assert(src_ptn != NULL, \"should be registered\");\n+            assert(src_ptn != nullptr, \"should be registered\");\n@@ -1214,1 +1214,1 @@\n-      assert((name == NULL || strcmp(name, \"uncommon_trap\") != 0), \"normal calls only\");\n+      assert((name == nullptr || strcmp(name, \"uncommon_trap\") != 0), \"normal calls only\");\n@@ -1217,1 +1217,1 @@\n-      if ((meth != NULL) && meth->is_boxing_method()) {\n+      if ((meth != nullptr) && meth->is_boxing_method()) {\n@@ -1220,1 +1220,1 @@\n-      BCEscapeAnalyzer* call_analyzer = (meth !=NULL) ? meth->get_bcea() : NULL;\n+      BCEscapeAnalyzer* call_analyzer = (meth !=nullptr) ? meth->get_bcea() : nullptr;\n@@ -1222,1 +1222,1 @@\n-      if (call_analyzer != NULL) {\n+      if (call_analyzer != nullptr) {\n@@ -1230,1 +1230,1 @@\n-          if (at->isa_ptr() != NULL &&\n+          if (at->isa_ptr() != nullptr &&\n@@ -1233,1 +1233,1 @@\n-            if (call_ptn != NULL) { \/\/ Is call's result used?\n+            if (call_ptn != nullptr) { \/\/ Is call's result used?\n@@ -1235,1 +1235,1 @@\n-              assert(arg_ptn != NULL, \"node should be registered\");\n+              assert(arg_ptn != nullptr, \"node should be registered\");\n@@ -1239,1 +1239,1 @@\n-          if (at->isa_oopptr() != NULL &&\n+          if (at->isa_oopptr() != nullptr &&\n@@ -1253,1 +1253,1 @@\n-        if (call_ptn != NULL && call_ptn->is_LocalVar()) {\n+        if (call_ptn != nullptr && call_ptn->is_LocalVar()) {\n@@ -1271,1 +1271,1 @@\n-        if (at->isa_oopptr() != NULL) {\n+        if (at->isa_oopptr() != nullptr) {\n@@ -1276,1 +1276,1 @@\n-          assert(ptnode_adr(arg->_idx) != NULL, \"should be defined already\");\n+          assert(ptnode_adr(arg->_idx) != nullptr, \"should be defined already\");\n@@ -1388,1 +1388,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -1408,1 +1408,1 @@\n-  \/\/ Find fields initialized by NULL for non-escaping Allocations.\n+  \/\/ Find fields initialized by null for non-escaping Allocations.\n@@ -1416,2 +1416,2 @@\n-        \/\/ Adding references to NULL object does not change escape states\n-        \/\/ since it does not escape. Also no fields are added to NULL object.\n+        \/\/ Adding references to null object does not change escape states\n+        \/\/ since it does not escape. Also no fields are added to null object.\n@@ -1427,1 +1427,1 @@\n-      if (ini != NULL)\n+      if (ini != nullptr)\n@@ -1543,1 +1543,1 @@\n-      if (jobj == null_obj) { \/\/ NULL object does not have field edges\n+      if (jobj == null_obj) { \/\/ null object does not have field edges\n@@ -1564,1 +1564,1 @@\n-            if (jobj == null_obj) { \/\/ NULL object does not have field edges\n+            if (jobj == null_obj) { \/\/ null object does not have field edges\n@@ -1639,1 +1639,1 @@\n-        \/\/ NULL object node does not have fields.\n+        \/\/ null object node does not have fields.\n@@ -1673,1 +1673,1 @@\n-      assert(base == null_obj, \"only NULL ptr base expected here\");\n+      assert(base == null_obj, \"only null ptr base expected here\");\n@@ -1696,1 +1696,1 @@\n-  if (!pta->arraycopy_dst() && alloc->as_CallStaticJava()->method() == NULL) {\n+  if (!pta->arraycopy_dst() && alloc->as_CallStaticJava()->method() == nullptr) {\n@@ -1730,2 +1730,2 @@\n-  \/\/ a corresponding NULL if field's value if it is not recorded.\n-  \/\/ Connection Graph does not record a default initialization by NULL\n+  \/\/ a corresponding null if field's value if it is not recorded.\n+  \/\/ Connection Graph does not record a default initialization by null\n@@ -1743,1 +1743,1 @@\n-        \/\/ always add reference to NULL to all Field nodes since we don't\n+        \/\/ always add reference to null to all Field nodes since we don't\n@@ -1766,2 +1766,2 @@\n-        Node* value = NULL;\n-        if (ini != NULL) {\n+        Node* value = nullptr;\n+        if (ini != nullptr) {\n@@ -1774,1 +1774,1 @@\n-          if (store != NULL && store->is_Store() &&\n+          if (store != nullptr && store->is_Store() &&\n@@ -1781,2 +1781,2 @@\n-              assert((val != NULL), \"should be processed already\");\n-              PointsToNode* missed_obj = NULL;\n+              assert((val != nullptr), \"should be processed already\");\n+              PointsToNode* missed_obj = nullptr;\n@@ -1804,1 +1804,1 @@\n-              if (missed_obj != NULL) {\n+              if (missed_obj != nullptr) {\n@@ -1822,1 +1822,1 @@\n-            \/\/ stores which follow loads. For now, add initial value NULL so\n+            \/\/ stores which follow loads. For now, add initial value null so\n@@ -1826,2 +1826,2 @@\n-        if (value == NULL) {\n-          \/\/ A field's initializing value was not recorded. Add NULL.\n+        if (value == nullptr) {\n+          \/\/ A field's initializing value was not recorded. Add null.\n@@ -2141,1 +2141,1 @@\n-  if (jobj1 != NULL) {\n+  if (jobj1 != nullptr) {\n@@ -2155,1 +2155,1 @@\n-  if (jobj2 != NULL) {\n+  if (jobj2 != nullptr) {\n@@ -2165,2 +2165,2 @@\n-  if (jobj1 != NULL && jobj1 != phantom_obj &&\n-      jobj2 != NULL && jobj2 != phantom_obj &&\n+  if (jobj1 != nullptr && jobj1 != phantom_obj &&\n+      jobj2 != nullptr && jobj2 != phantom_obj &&\n@@ -2215,1 +2215,1 @@\n-  if (ptadr != NULL) {\n+  if (ptadr != nullptr) {\n@@ -2226,1 +2226,1 @@\n-  if (ptadr != NULL) {\n+  if (ptadr != nullptr) {\n@@ -2237,1 +2237,1 @@\n-  if (ptadr != NULL) {\n+  if (ptadr != nullptr) {\n@@ -2254,1 +2254,1 @@\n-  assert((src != null_obj) && (dst != null_obj), \"not for ConP NULL\");\n+  assert((src != null_obj) && (dst != null_obj), \"not for ConP null\");\n@@ -2256,1 +2256,1 @@\n-  if (ptadr != NULL) {\n+  if (ptadr != nullptr) {\n@@ -2277,1 +2277,1 @@\n-        (adr_type->isa_aryptr()->klass() == NULL) ||\n+        (adr_type->isa_aryptr()->klass() == nullptr) ||\n@@ -2280,1 +2280,1 @@\n-      if (find_second_addp(n, n->in(AddPNode::Base)) == NULL) {\n+      if (find_second_addp(n, n->in(AddPNode::Base)) == nullptr) {\n@@ -2287,1 +2287,1 @@\n-      if (field != NULL) {\n+      if (field != nullptr) {\n@@ -2302,1 +2302,1 @@\n-      } else if (find_second_addp(n, n->in(AddPNode::Base)) != NULL) {\n+      } else if (find_second_addp(n, n->in(AddPNode::Base)) != nullptr) {\n@@ -2322,1 +2322,1 @@\n-\/\/ Returns unique pointed java object or NULL.\n+\/\/ Returns unique pointed java object or null.\n@@ -2328,1 +2328,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2331,2 +2331,2 @@\n-  if (ptn == NULL) {\n-    return NULL;\n+  if (ptn == nullptr) {\n+    return nullptr;\n@@ -2339,1 +2339,1 @@\n-  JavaObjectNode* jobj = NULL;\n+  JavaObjectNode* jobj = nullptr;\n@@ -2343,1 +2343,1 @@\n-      if (jobj == NULL) {\n+      if (jobj == nullptr) {\n@@ -2346,1 +2346,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2387,1 +2387,1 @@\n-  if (ptn == NULL) {\n+  if (ptn == nullptr) {\n@@ -2461,1 +2461,1 @@\n-  assert(_igvn->type(addp)->isa_oopptr() == NULL, \"should be raw access\");\n+  assert(_igvn->type(addp)->isa_oopptr() == nullptr, \"should be raw access\");\n@@ -2481,1 +2481,1 @@\n-  if (adr->is_AddP() && adr_type->isa_oopptr() == NULL && is_captured_store_address(adr)) {\n+  if (adr->is_AddP() && adr_type->isa_oopptr() == nullptr && is_captured_store_address(adr)) {\n@@ -2491,1 +2491,1 @@\n-  assert(t_ptr != NULL, \"must be a pointer type\");\n+  assert(t_ptr != nullptr, \"must be a pointer type\");\n@@ -2583,1 +2583,1 @@\n-             (uncast_base->is_Mem() && (uncast_base->bottom_type()->isa_rawptr() != NULL)) ||\n+             (uncast_base->is_Mem() && (uncast_base->bottom_type()->isa_rawptr() != nullptr)) ||\n@@ -2627,1 +2627,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2637,1 +2637,1 @@\n-  assert(base_t != NULL && base_t->is_known_instance(), \"expecting instance oopptr\");\n+  assert(base_t != nullptr && base_t->is_known_instance(), \"expecting instance oopptr\");\n@@ -2639,1 +2639,1 @@\n-  if (t == NULL) {\n+  if (t == nullptr) {\n@@ -2697,1 +2697,1 @@\n-        assert(adr->is_AddP() && atype != NULL &&\n+        assert(adr->is_AddP() && atype != nullptr &&\n@@ -2725,1 +2725,1 @@\n-  if (result != NULL && C->get_alias_index(result->adr_type()) == alias_idx) {\n+  if (result != nullptr && C->get_alias_index(result->adr_type()) == alias_idx) {\n@@ -2730,1 +2730,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -2748,1 +2748,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2752,1 +2752,1 @@\n-  result = PhiNode::make(orig_phi->in(0), NULL, Type::MEMORY, atype);\n+  result = PhiNode::make(orig_phi->in(0), nullptr, Type::MEMORY, atype);\n@@ -2782,1 +2782,1 @@\n-      if (mem != NULL && mem->is_Phi()) {\n+      if (mem != nullptr && mem->is_Phi()) {\n@@ -2798,1 +2798,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2805,1 +2805,1 @@\n-    assert( result->in(0) != NULL && result->in(0) == phi->in(0), \"regions must match\");\n+    assert( result->in(0) != nullptr && result->in(0) == phi->in(0), \"regions must match\");\n@@ -2811,1 +2811,1 @@\n-      assert((phi->in(i) == NULL) == (in == NULL), \"inputs must correspond.\");\n+      assert((phi->in(i) == nullptr) == (in == nullptr), \"inputs must correspond.\");\n@@ -2835,1 +2835,1 @@\n-      !(toop->klass() != NULL &&\n+      !(toop->klass() != nullptr &&\n@@ -2851,1 +2851,1 @@\n-  assert(tp != NULL, \"ptr type\");\n+  assert(tp != nullptr, \"ptr type\");\n@@ -2880,1 +2880,1 @@\n-      if ((tp != NULL && C->get_alias_index(tp) == alias_idx) ||\n+      if ((tp != nullptr && C->get_alias_index(tp) == alias_idx) ||\n@@ -2901,1 +2901,1 @@\n-      assert(tp != NULL, \"ptr type\");\n+      assert(tp != nullptr, \"ptr type\");\n@@ -2903,1 +2903,1 @@\n-      assert(get_map(use->_idx) != NULL || idx == alias_idx,\n+      assert(get_map(use->_idx) != nullptr || idx == alias_idx,\n@@ -2908,1 +2908,1 @@\n-      assert(tp != NULL, \"ptr type\");\n+      assert(tp != nullptr, \"ptr type\");\n@@ -2924,1 +2924,1 @@\n-  if (orig_mem == NULL) {\n+  if (orig_mem == nullptr) {\n@@ -2930,1 +2930,1 @@\n-  bool is_instance = (toop != NULL) && toop->is_known_instance();\n+  bool is_instance = (toop != nullptr) && toop->is_known_instance();\n@@ -2932,1 +2932,1 @@\n-  Node *prev = NULL;\n+  Node *prev = nullptr;\n@@ -2944,1 +2944,1 @@\n-      assert (at->isa_ptr() != NULL, \"pointer type required.\");\n+      assert (at->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -2949,1 +2949,1 @@\n-      if (!is_instance && (at->isa_oopptr() == NULL ||\n+      if (!is_instance && (at->isa_oopptr() == nullptr ||\n@@ -2973,1 +2973,1 @@\n-        if (alloc == NULL || alloc->_idx != (uint)toop->instance_id()) {\n+        if (alloc == nullptr || alloc->_idx != (uint)toop->instance_id()) {\n@@ -2999,1 +2999,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -3006,1 +3006,1 @@\n-      if (un != NULL) {\n+      if (un != nullptr) {\n@@ -3021,1 +3021,1 @@\n-      Node* adr = NULL;\n+      Node* adr = nullptr;\n@@ -3031,1 +3031,1 @@\n-        assert(at->isa_ptr() != NULL, \"pointer type required.\");\n+        assert(at->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3044,1 +3044,1 @@\n-        assert(at->isa_ptr() != NULL, \"pointer type required.\");\n+        assert(at->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3192,1 +3192,1 @@\n-      if (n == NULL) {            \/\/ No uses except Initialize node\n+      if (n == nullptr) {            \/\/ No uses except Initialize node\n@@ -3217,1 +3217,1 @@\n-        Node *cast2 = NULL;\n+        Node *cast2 = nullptr;\n@@ -3225,1 +3225,1 @@\n-        if (cast2 != NULL) {\n+        if (cast2 != nullptr) {\n@@ -3236,1 +3236,1 @@\n-      if (t == NULL) {\n+      if (t == nullptr) {\n@@ -3280,1 +3280,1 @@\n-            if (addp2 != NULL) {\n+            if (addp2 != nullptr) {\n@@ -3292,1 +3292,1 @@\n-        assert (raw_result != NULL, \"must have an allocation result\");\n+        assert (raw_result != nullptr, \"must have an allocation result\");\n@@ -3297,1 +3297,1 @@\n-            if (addp2 != NULL) {\n+            if (addp2 != nullptr) {\n@@ -3309,1 +3309,1 @@\n-      if (jobj == NULL || jobj == phantom_obj) {\n+      if (jobj == nullptr || jobj == phantom_obj) {\n@@ -3313,1 +3313,1 @@\n-        assert(jobj != NULL && jobj != phantom_obj, \"escaped allocation\");\n+        assert(jobj != nullptr && jobj != phantom_obj, \"escaped allocation\");\n@@ -3330,1 +3330,1 @@\n-      if (jobj == NULL || jobj == phantom_obj) {\n+      if (jobj == nullptr || jobj == phantom_obj) {\n@@ -3333,1 +3333,1 @@\n-        assert(jobj != NULL && jobj != phantom_obj, \"escaped allocation\");\n+        assert(jobj != nullptr && jobj != phantom_obj, \"escaped allocation\");\n@@ -3341,1 +3341,1 @@\n-        assert(tinst != NULL && tinst->is_known_instance() &&\n+        assert(tinst != nullptr && tinst->is_known_instance() &&\n@@ -3351,1 +3351,1 @@\n-        if (tn_t != NULL && tinst->klass()->is_subtype_of(tn_t->klass())) {\n+        if (tn_t != nullptr && tinst->klass()->is_subtype_of(tn_t->klass())) {\n@@ -3364,1 +3364,1 @@\n-                 tn_t != NULL && !tinst->klass()->is_subtype_of(tn_t->klass()),\n+                 tn_t != nullptr && !tinst->klass()->is_subtype_of(tn_t->klass()),\n@@ -3386,1 +3386,1 @@\n-        if (addp2 != NULL) {\n+        if (addp2 != nullptr) {\n@@ -3446,1 +3446,1 @@\n-    if (jobj != NULL) {\n+    if (jobj != nullptr) {\n@@ -3448,1 +3448,1 @@\n-      if (base != NULL) {\n+      if (base != nullptr) {\n@@ -3458,1 +3458,1 @@\n-    if (jobj != NULL) {\n+    if (jobj != nullptr) {\n@@ -3460,1 +3460,1 @@\n-      if (base != NULL) {\n+      if (base != nullptr) {\n@@ -3486,1 +3486,1 @@\n-      if (n == NULL) {\n+      if (n == nullptr) {\n@@ -3493,1 +3493,1 @@\n-      assert(n != NULL && n->Opcode() == Op_SCMemProj, \"memory projection required\");\n+      assert(n != nullptr && n->Opcode() == Op_SCMemProj, \"memory projection required\");\n@@ -3501,1 +3501,1 @@\n-      assert (addr_t->isa_ptr() != NULL, \"pointer type required.\");\n+      assert (addr_t->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3518,1 +3518,1 @@\n-        assert(n != NULL && n->Opcode() == Op_SCMemProj, \"memory projection required\");\n+        assert(n != nullptr && n->Opcode() == Op_SCMemProj, \"memory projection required\");\n@@ -3579,2 +3579,2 @@\n-      Node* cur = NULL;\n-      if (mem == NULL || mem->is_top()) {\n+      Node* cur = nullptr;\n+      if (mem == nullptr || mem->is_top()) {\n@@ -3588,1 +3588,1 @@\n-          assert (at->isa_ptr() != NULL, \"pointer type required.\");\n+          assert (at->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3591,1 +3591,1 @@\n-            if (cur == NULL) {\n+            if (cur == nullptr) {\n@@ -3602,1 +3602,1 @@\n-      nmm->set_memory_at(i, (cur != NULL) ? cur : mem);\n+      nmm->set_memory_at(i, (cur != nullptr) ? cur : mem);\n@@ -3672,1 +3672,1 @@\n-    assert(nmem != NULL, \"sanity\");\n+    assert(nmem != nullptr, \"sanity\");\n@@ -3764,1 +3764,1 @@\n-  if (_node == NULL) {\n+  if (_node == nullptr) {\n@@ -3776,1 +3776,1 @@\n-    if (ptn == NULL || !ptn->is_JavaObject()) {\n+    if (ptn == nullptr || !ptn->is_JavaObject()) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":169,"deletions":169,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-  PointsToNode* get() const { ShouldNotCallThis(); return NULL; }\n+  PointsToNode* get() const { ShouldNotCallThis(); return nullptr; }\n@@ -432,1 +432,1 @@\n-    \/\/ Don't change non-escaping state of NULL pointer.\n+    \/\/ Don't change non-escaping state of nullptr pointer.\n@@ -443,1 +443,1 @@\n-    \/\/ Don't change non-escaping state of NULL pointer.\n+    \/\/ Don't change non-escaping state of nullptr pointer.\n@@ -468,1 +468,1 @@\n-  \/\/ Returns unique corresponding java object or NULL.\n+  \/\/ Returns unique corresponding java object or null.\n@@ -506,1 +506,1 @@\n-        return is_new; \/\/ Don't add fields to NULL pointer.\n+        return is_new; \/\/ Don't add fields to null pointer.\n@@ -561,1 +561,1 @@\n-    return (phi == NULL) ? NULL : phi->as_Phi();\n+    return (phi == nullptr) ? nullptr : phi->as_Phi();\n@@ -601,1 +601,1 @@\n-    if (delayed_worklist != NULL) { \/\/ First iteration of CG construction\n+    if (delayed_worklist != nullptr) { \/\/ First iteration of CG construction\n@@ -603,1 +603,1 @@\n-      if (ptn == NULL) {\n+      if (ptn == nullptr) {\n@@ -608,1 +608,1 @@\n-      assert(ptn != NULL, \"node should be registered\");\n+      assert(ptn != nullptr, \"node should be registered\");\n@@ -615,1 +615,1 @@\n-    assert(ptn != NULL, \"only existing PointsTo node\");\n+    assert(ptn != nullptr, \"only existing PointsTo node\");\n@@ -628,2 +628,2 @@\n-  _edges(CG->_compile->comp_arena(), 2, 0, NULL),\n-  _uses (CG->_compile->comp_arena(), 2, 0, NULL),\n+  _edges(CG->_compile->comp_arena(), 2, 0, nullptr),\n+  _uses (CG->_compile->comp_arena(), 2, 0, nullptr),\n@@ -637,1 +637,1 @@\n-  assert(n != NULL && es != UnknownEscape, \"sanity\");\n+  assert(n != nullptr && es != UnknownEscape, \"sanity\");\n@@ -642,1 +642,1 @@\n-  _bases(CG->_compile->comp_arena(), 2, 0, NULL),\n+  _bases(CG->_compile->comp_arena(), 2, 0, nullptr),\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        if (buse != NULL) {\n+        if (buse != nullptr) {\n@@ -80,1 +80,1 @@\n-  assert(in0 != NULL, \"Only control-dependent\");\n+  assert(in0 != nullptr, \"Only control-dependent\");\n@@ -82,1 +82,1 @@\n-  if (p != NULL && p != n) {    \/\/ Control from a block projection?\n+  if (p != nullptr && p != n) {    \/\/ Control from a block projection?\n@@ -112,1 +112,1 @@\n-  assert(n != NULL && d != NULL, \"blocks must exist\");\n+  assert(n != nullptr && d != nullptr, \"blocks must exist\");\n@@ -215,1 +215,1 @@\n-      Node* n = NULL;\n+      Node* n = nullptr;\n@@ -218,1 +218,1 @@\n-        if (m == NULL) continue;\n+        if (m == nullptr) continue;\n@@ -223,1 +223,1 @@\n-          if (n == NULL) {\n+          if (n == nullptr) {\n@@ -234,1 +234,1 @@\n-      if (n != NULL) {\n+      if (n != nullptr) {\n@@ -242,1 +242,1 @@\n-      \/\/ process all inputs that are non NULL\n+      \/\/ process all inputs that are non null\n@@ -244,1 +244,1 @@\n-        if (node->in(i) != NULL) {\n+        if (node->in(i) != nullptr) {\n@@ -257,1 +257,1 @@\n-  if (b1 == NULL)  return;\n+  if (b1 == nullptr)  return;\n@@ -260,1 +260,1 @@\n-  while (tmp != b1 && tmp != NULL) {\n+  while (tmp != b1 && tmp != nullptr) {\n@@ -268,1 +268,1 @@\n-      if (inn == NULL)  continue;  \/\/ Ignore NULL, missing inputs\n+      if (inn == nullptr)  continue;  \/\/ Ignore null, missing inputs\n@@ -283,1 +283,1 @@\n-  Block* deepb           = NULL;        \/\/ Deepest block so far\n+  Block* deepb           = nullptr;     \/\/ Deepest block so far\n@@ -287,1 +287,1 @@\n-    if (inn == NULL)  continue;         \/\/ Ignore NULL, missing inputs\n+    if (inn == nullptr)  continue;      \/\/ Ignore null, missing inputs\n@@ -289,1 +289,1 @@\n-    assert(inb != NULL, \"must already have scheduled this input\");\n+    assert(inb != nullptr, \"must already have scheduled this input\");\n@@ -299,1 +299,1 @@\n-  assert(deepb != NULL, \"must be at least one input to n\");\n+  assert(deepb != nullptr, \"must be at least one input to n\");\n@@ -328,1 +328,1 @@\n-        if (control_input != NULL) {\n+        if (control_input != nullptr) {\n@@ -348,1 +348,1 @@\n-        if (in == NULL) {\n+        if (in == nullptr) {\n@@ -404,1 +404,1 @@\n-\/\/ As a convenient boundary condition, return 'this' if LCA is NULL.\n+\/\/ As a convenient boundary condition, return 'this' if LCA is null.\n@@ -407,1 +407,1 @@\n-  if (LCA == NULL || LCA == this)  return this;\n+  if (LCA == nullptr || LCA == this)  return this;\n@@ -431,1 +431,1 @@\n-  if (buse == NULL)    return LCA;   \/\/ Unused killing Projs have no use block\n+  if (buse == nullptr) return LCA;   \/\/ Unused killing Projs have no use block\n@@ -510,3 +510,3 @@\n-  if (base != NULL)  mem_inputs[mem_inputs_length++] = base;\n-  if (index != NULL) mem_inputs[mem_inputs_length++] = index;\n-  if (store != NULL) mem_inputs[mem_inputs_length++] = store;\n+  if (base != nullptr)  mem_inputs[mem_inputs_length++] = base;\n+  if (index != nullptr) mem_inputs[mem_inputs_length++] = index;\n+  if (store != nullptr) mem_inputs[mem_inputs_length++] = store;\n@@ -522,1 +522,1 @@\n-    if (load->in(0) != NULL) mem_inputs[mem_inputs_length++] = load->in(0);\n+    if (load->in(0) != nullptr) mem_inputs[mem_inputs_length++] = load->in(0);\n@@ -524,1 +524,1 @@\n-    Block* deepb           = NULL;        \/\/ Deepest block so far\n+    Block* deepb           = nullptr;        \/\/ Deepest block so far\n@@ -557,1 +557,1 @@\n-    assert(if_true != NULL, \"null check without null projection\");\n+    assert(if_true != nullptr, \"null check without null projection\");\n@@ -559,1 +559,1 @@\n-    assert(null_block_region != NULL, \"null check without null region\");\n+    assert(null_block_region != nullptr, \"null check without null region\");\n@@ -583,1 +583,1 @@\n-  assert(LCA != NULL, \"\");\n+  assert(LCA != nullptr, \"\");\n@@ -653,1 +653,1 @@\n-  worklist_mem.push(NULL);\n+  worklist_mem.push(nullptr);\n@@ -668,1 +668,1 @@\n-        initial_mem = NULL;  \/\/ only process initial memory once\n+        initial_mem = nullptr;  \/\/ only process initial memory once\n@@ -711,1 +711,1 @@\n-          if (mcj->_method == NULL) {\n+          if (mcj->_method == nullptr) {\n@@ -740,1 +740,1 @@\n-    assert(store_block != NULL, \"unused killing projections skipped above\");\n+    assert(store_block != nullptr, \"unused killing projections skipped above\");\n@@ -890,1 +890,1 @@\n-  \/\/ If the _stack is empty, then just return NULL: finished.\n+  \/\/ If the _stack is empty, then just return null: finished.\n@@ -892,1 +892,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -914,1 +914,1 @@\n-    Node *unvisited = NULL;  \/\/ Unvisited anti-dependent Node, if any\n+    Node *unvisited = nullptr;  \/\/ Unvisited anti-dependent Node, if any\n@@ -1153,1 +1153,1 @@\n-  MachNode* mach = self->is_Mach() ? self->as_Mach() : NULL;\n+  MachNode* mach = self->is_Mach() ? self->as_Mach() : nullptr;\n@@ -1178,1 +1178,1 @@\n-    if (LCA == NULL) {\n+    if (LCA == nullptr) {\n@@ -1181,1 +1181,1 @@\n-      C->record_method_not_compilable(\"late schedule failed: LCA == NULL\");\n+      C->record_method_not_compilable(\"late schedule failed: LCA is null\");\n@@ -1295,1 +1295,1 @@\n-    MachNode* mach = self->is_Mach() ? self->as_Mach() : NULL;\n+    MachNode* mach = self->is_Mach() ? self->as_Mach() : nullptr;\n@@ -1307,1 +1307,1 @@\n-        if (def != NULL && def->bottom_type()->base() == Type::RawPtr) {\n+        if (def != nullptr && def->bottom_type()->base() == Type::RawPtr) {\n@@ -1365,1 +1365,1 @@\n-    Block *LCA = NULL;\n+    Block *LCA = nullptr;\n@@ -1372,1 +1372,1 @@\n-      guarantee(LCA != NULL, \"There must be a LCA\");\n+      guarantee(LCA != nullptr, \"There must be a LCA\");\n@@ -1378,1 +1378,1 @@\n-    if (mach != NULL && mach->is_MachTemp()) {\n+    if (mach != nullptr && mach->is_MachTemp()) {\n@@ -1413,1 +1413,1 @@\n-      assert(LCA != NULL, \"a valid LCA must exist\");\n+      assert(LCA != nullptr, \"a valid LCA must exist\");\n@@ -1426,1 +1426,1 @@\n-    if (mach != NULL && must_clone[mach->ideal_Opcode()])\n+    if (mach != nullptr && must_clone[mach->ideal_Opcode()])\n@@ -1429,1 +1429,1 @@\n-    Block* late = NULL;\n+    Block* late = nullptr;\n@@ -1509,2 +1509,2 @@\n-  \/\/ Detect implicit-null-check opportunities.  Basically, find NULL checks\n-  \/\/ with suitable memory ops nearby.  Use the memory op to do the NULL check.\n+  \/\/ Detect implicit-null-check opportunities.  Basically, find null checks\n+  \/\/ with suitable memory ops nearby.  Use the memory op to do the null check.\n@@ -1530,1 +1530,1 @@\n-  intptr_t *recalc_pressure_nodes = NULL;\n+  intptr_t *recalc_pressure_nodes = nullptr;\n@@ -1583,1 +1583,1 @@\n-      _regalloc = NULL;\n+      _regalloc = nullptr;\n@@ -1587,1 +1587,1 @@\n-  _regalloc = NULL;\n+  _regalloc = nullptr;\n@@ -1728,1 +1728,1 @@\n-    assert(block->_loop == NULL, \"clear _loop expected\");\n+    assert(block->_loop == nullptr, \"clear _loop expected\");\n@@ -1761,1 +1761,1 @@\n-        assert(loop_head->_loop == NULL, \"just checking\");\n+        assert(loop_head->_loop == nullptr, \"just checking\");\n@@ -1784,1 +1784,1 @@\n-    if (lp == NULL) {\n+    if (lp == nullptr) {\n@@ -1793,1 +1793,1 @@\n-      if (lp->parent() == NULL) {\n+      if (lp->parent() == nullptr) {\n@@ -1812,1 +1812,1 @@\n-  if (pred_loop == NULL) {\n+  if (pred_loop == nullptr) {\n@@ -1821,1 +1821,1 @@\n-    while (pred_loop->_parent != NULL && pred_loop->_parent != this) {\n+    while (pred_loop->_parent != nullptr && pred_loop->_parent != this) {\n@@ -1825,1 +1825,1 @@\n-    if (pred_loop->_parent == NULL) {\n+    if (pred_loop->_parent == nullptr) {\n@@ -1833,1 +1833,1 @@\n-      assert(pred_loop->_parent == this && _parent == NULL, \"just checking\");\n+      assert(pred_loop->_parent == this && _parent == nullptr, \"just checking\");\n@@ -1841,1 +1841,1 @@\n-  assert(_parent == NULL, \"no parent yet\");\n+  assert(_parent == nullptr, \"no parent yet\");\n@@ -1845,1 +1845,1 @@\n-  if (ch == NULL) {\n+  if (ch == nullptr) {\n@@ -1848,1 +1848,1 @@\n-    while (ch->_sibling != NULL) { ch = ch->_sibling; }\n+    while (ch->_sibling != nullptr) { ch = ch->_sibling; }\n@@ -1859,1 +1859,1 @@\n-  while (ch != NULL) {\n+  while (ch != nullptr) {\n@@ -1878,1 +1878,1 @@\n-  while (ch != NULL) {\n+  while (ch != nullptr) {\n@@ -2208,1 +2208,1 @@\n-  while (ch != NULL) {\n+  while (ch != nullptr) {\n@@ -2216,1 +2216,1 @@\n-  if (_child != NULL) {\n+  if (_child != nullptr) {\n@@ -2226,2 +2226,2 @@\n-  if (_child != NULL)   _child->dump_tree();\n-  if (_sibling != NULL) _sibling->dump_tree();\n+  if (_child != nullptr)   _child->dump_tree();\n+  if (_sibling != nullptr) _sibling->dump_tree();\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":70,"deletions":70,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  \/\/ as soon as last_Java_sp != NULL the has_last_Java_frame is true and\n+  \/\/ as soon as last_Java_sp != nullptr the has_last_Java_frame is true and\n@@ -237,1 +237,1 @@\n-    Node* vm_result = make_load(NULL, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n+    Node* vm_result = make_load(nullptr, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n@@ -246,1 +246,1 @@\n-  Node* pending = make_load(NULL, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n+  Node* pending = make_load(nullptr, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n@@ -257,1 +257,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -270,1 +270,1 @@\n-  Node *ret = NULL;\n+  Node *ret = nullptr;\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  if (_exceptions != NULL)  jvms->map()->set_next_exception(NULL);\n+  if (_exceptions != nullptr)  jvms->map()->set_next_exception(nullptr);\n@@ -75,2 +75,2 @@\n-  _exceptions = NULL;\n-  set_map(NULL);\n+  _exceptions = nullptr;\n+  set_map(nullptr);\n@@ -123,1 +123,1 @@\n-  if (parse == NULL) {\n+  if (parse == nullptr) {\n@@ -143,1 +143,1 @@\n-  if (reg == NULL)  return false;\n+  if (reg == nullptr)  return false;\n@@ -146,1 +146,1 @@\n-    if (reg == NULL)  return false;\n+    if (reg == nullptr)  return false;\n@@ -148,1 +148,1 @@\n-  return reg->is_Region() && reg->in(0) != NULL && reg->in(0)->is_Root();\n+  return reg->is_Region() && reg->in(0) != nullptr && reg->in(0)->is_Root();\n@@ -152,1 +152,1 @@\n-  if (map() == NULL)  return;  \/\/ null map is OK\n+  if (map() == nullptr)  return;  \/\/ null map is OK\n@@ -159,1 +159,1 @@\n-  assert(ex_map->next_exception() == NULL, \"not already part of a chain\");\n+  assert(ex_map->next_exception() == nullptr, \"not already part of a chain\");\n@@ -165,1 +165,1 @@\n-\/\/ Set _map to NULL, signalling a stop to further bytecode execution.\n+\/\/ Set _map to null, signalling a stop to further bytecode execution.\n@@ -169,1 +169,1 @@\n-  if (dead_map != NULL) {\n+  if (dead_map != nullptr) {\n@@ -177,1 +177,1 @@\n-\/\/ Tell if _map is NULL, or control is top.\n+\/\/ Tell if _map is null, or control is top.\n@@ -179,1 +179,1 @@\n-  if (map() == NULL)           return true;\n+  if (map() == nullptr)        return true;\n@@ -188,1 +188,1 @@\n-  for (JVMState* jvmsp = jvms(); jvmsp != NULL; jvmsp = jvmsp->caller()) {\n+  for (JVMState* jvmsp = jvms(); jvmsp != nullptr; jvmsp = jvmsp->caller()) {\n@@ -244,1 +244,1 @@\n-  if (ex_map == NULL || ex_map->control() == top()) {\n+  if (ex_map == nullptr || ex_map->control() == top()) {\n@@ -263,1 +263,1 @@\n-  for (SafePointNode* e2 = _exceptions; e2 != NULL; e2 = e2->next_exception()) {\n+  for (SafePointNode* e2 = _exceptions; e2 != nullptr; e2 = e2->next_exception()) {\n@@ -281,3 +281,3 @@\n-  if (ex_map != NULL) {\n-    jvms->map()->set_next_exception(NULL);\n-    for (SafePointNode* next_map; ex_map != NULL; ex_map = next_map) {\n+  if (ex_map != nullptr) {\n+    jvms->map()->set_next_exception(nullptr);\n+    for (SafePointNode* next_map; ex_map != nullptr; ex_map = next_map) {\n@@ -285,1 +285,1 @@\n-      ex_map->set_next_exception(NULL);\n+      ex_map->set_next_exception(nullptr);\n@@ -293,1 +293,1 @@\n-  if (map() == NULL) {\n+  if (map() == nullptr) {\n@@ -299,1 +299,1 @@\n-      _map->set_next_exception(NULL);\n+      _map->set_next_exception(nullptr);\n@@ -304,1 +304,1 @@\n-      JVMState* jvms = new (C) JVMState(_method, NULL);\n+      JVMState* jvms = new (C) JVMState(_method, nullptr);\n@@ -319,1 +319,1 @@\n-  _exceptions = NULL;   \/\/ done with this set of exceptions\n+  _exceptions = nullptr;   \/\/ done with this set of exceptions\n@@ -341,1 +341,1 @@\n-\/\/ having a control input of its exception map, rather than NULL.  Such\n+\/\/ having a control input of its exception map, rather than null.  Such\n@@ -493,1 +493,1 @@\n-  if (method != NULL && bci != InvocationEntryBci)\n+  if (method != nullptr && bci != InvocationEntryBci)\n@@ -523,1 +523,1 @@\n-                    (ciKlass*)NULL, (char*)NULL, must_throw);\n+                    (ciKlass*)nullptr, (char*)nullptr, must_throw);\n@@ -571,1 +571,1 @@\n-    ciInstance* ex_obj = NULL;\n+    ciInstance* ex_obj = nullptr;\n@@ -593,1 +593,1 @@\n-    if (ex_obj != NULL) {\n+    if (ex_obj != nullptr) {\n@@ -602,1 +602,1 @@\n-      if (C->log() != NULL)\n+      if (C->log() != nullptr)\n@@ -638,1 +638,1 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : NULL;\n+  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : nullptr;\n@@ -644,1 +644,1 @@\n-    if (C->log() != NULL)\n+    if (C->log() != nullptr)\n@@ -656,1 +656,1 @@\n-  uncommon_trap(reason, action, (ciKlass*)NULL, (char*)NULL, must_throw);\n+  uncommon_trap(reason, action, (ciKlass*)nullptr, (char*)nullptr, must_throw);\n@@ -666,1 +666,1 @@\n-  kit->set_map(clone_map ? kit->clone_map() : NULL);\n+  kit->set_map(clone_map ? kit->clone_map() : nullptr);\n@@ -670,1 +670,1 @@\n-  int block = (parser == NULL || parser->block() == NULL) ? -1 : parser->block()->rpo();\n+  int block = (parser == nullptr || parser->block() == nullptr) ? -1 : parser->block()->rpo();\n@@ -679,1 +679,1 @@\n-  int block = (parser == NULL || parser->block() == NULL) ? -1 : parser->block()->rpo();\n+  int block = (parser == nullptr || parser->block() == nullptr) ? -1 : parser->block()->rpo();\n@@ -724,1 +724,1 @@\n-  if (map() == NULL)  return NULL;\n+  if (map() == nullptr)  return nullptr;\n@@ -746,1 +746,1 @@\n-  _map->set_next_exception(NULL);\n+  _map->set_next_exception(nullptr);\n@@ -769,1 +769,1 @@\n-  if (method() == NULL || method()->code_size() == 0) {\n+  if (method() == nullptr || method()->code_size() == 0) {\n@@ -797,1 +797,1 @@\n-  if (method() == NULL || method()->code_size() == 0) {\n+  if (method() == nullptr || method()->code_size() == 0) {\n@@ -804,1 +804,1 @@\n-  for (JVMState* jvms = this->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = this->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -837,1 +837,1 @@\n-  if (cur_method != NULL && cur_bci != InvocationEntryBci) {\n+  if (cur_method != nullptr && cur_bci != InvocationEntryBci) {\n@@ -931,1 +931,1 @@\n-  for (JVMState* in_jvms = youngest_jvms; in_jvms != NULL; ) {\n+  for (JVMState* in_jvms = youngest_jvms; in_jvms != nullptr; ) {\n@@ -1080,1 +1080,1 @@\n-      ciSignature* declared_signature = NULL;\n+      ciSignature* declared_signature = nullptr;\n@@ -1082,1 +1082,1 @@\n-      assert(declared_signature != NULL, \"cannot be null\");\n+      assert(declared_signature != nullptr, \"cannot be null\");\n@@ -1180,1 +1180,1 @@\n-  if (akls != NULL)  return akls;\n+  if (akls != nullptr)  return akls;\n@@ -1182,1 +1182,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n@@ -1190,1 +1190,1 @@\n-  if (alloc == NULL) {\n+  if (alloc == nullptr) {\n@@ -1220,2 +1220,2 @@\n-\/\/ Helper function to do a NULL pointer check.  Returned value is\n-\/\/ the incoming address with NULL casted away.  You are allowed to use the\n+\/\/ Helper function to do a null pointer check.  Returned value is\n+\/\/ the incoming address with null casted away.  You are allowed to use the\n@@ -1232,1 +1232,1 @@\n-  assert(!assert_null || null_control == NULL, \"not both at once\");\n+  assert(!assert_null || null_control == nullptr, \"not both at once\");\n@@ -1236,2 +1236,2 @@\n-  \/\/ Construct NULL check\n-  Node *chk = NULL;\n+  \/\/ Construct null check\n+  Node *chk = nullptr;\n@@ -1247,1 +1247,1 @@\n-      if (tp != NULL && tp->klass() != NULL && !tp->klass()->is_loaded()\n+      if (tp != nullptr && tp->klass() != nullptr && !tp->klass()->is_loaded()\n@@ -1249,1 +1249,1 @@\n-          && !assert_null && null_control == NULL) {\n+          && !assert_null && null_control == nullptr) {\n@@ -1278,2 +1278,2 @@\n-        \/\/ See if mixing in the NULL pointer changes type.\n-        \/\/ If so, then the NULL pointer was not allowed in the original\n+        \/\/ See if mixing in the null pointer changes type.\n+        \/\/ If so, then the null pointer was not allowed in the original\n@@ -1294,1 +1294,1 @@\n-  assert(chk != NULL, \"sanity check\");\n+  assert(chk != nullptr, \"sanity check\");\n@@ -1327,1 +1327,1 @@\n-      if (cfg == NULL)  break;  \/\/ Quit at region nodes\n+      if (cfg == nullptr)  break;  \/\/ Quit at region nodes\n@@ -1352,1 +1352,1 @@\n-  if (null_control != NULL || too_many_traps(reason)) {\n+  if (null_control != nullptr || too_many_traps(reason)) {\n@@ -1357,1 +1357,1 @@\n-             method() != NULL &&\n+             method() != nullptr &&\n@@ -1363,1 +1363,1 @@\n-  if (null_control != NULL) {\n+  if (null_control != nullptr) {\n@@ -1382,1 +1382,1 @@\n-                    NULL, \"assert_null\");\n+                    nullptr, \"assert_null\");\n@@ -1404,1 +1404,1 @@\n-    if (null_control == NULL || (*null_control) == top())\n+    if (null_control == nullptr || (*null_control) == top())\n@@ -1501,1 +1501,1 @@\n-  debug_only( map()->set_memory((Node*)NULL) );\n+  debug_only( map()->set_memory((Node*)nullptr) );\n@@ -1537,1 +1537,1 @@\n-  const TypePtr* adr_type = NULL; \/\/ debug-mode-only argument\n+  const TypePtr* adr_type = nullptr; \/\/ debug-mode-only argument\n@@ -1557,1 +1557,1 @@\n-  const TypePtr* adr_type = NULL;\n+  const TypePtr* adr_type = nullptr;\n@@ -1587,1 +1587,1 @@\n-  \/\/ Transformation of a value which could be NULL pointer (CastPP #NULL)\n+  \/\/ Transformation of a value which could be null pointer (CastPP #null)\n@@ -1598,1 +1598,1 @@\n-  assert(val != NULL, \"not dead path\");\n+  assert(val != nullptr, \"not dead path\");\n@@ -1638,1 +1638,1 @@\n-  C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, NULL, addr);\n+  C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, nullptr, addr);\n@@ -1803,1 +1803,1 @@\n-  if (call->method() == NULL ||\n+  if (call->method() == nullptr ||\n@@ -1836,1 +1836,1 @@\n-  Node* m = narrow_mem == NULL ? memory : narrow_mem;\n+  Node* m = narrow_mem == nullptr ? memory : narrow_mem;\n@@ -1847,1 +1847,1 @@\n-\/\/ If keep_mem is not NULL, use it for the output state,\n+\/\/ If keep_mem is not null, use it for the output state,\n@@ -1849,1 +1849,1 @@\n-\/\/ If hook_mem is NULL, this call produces no memory effects at all.\n+\/\/ If hook_mem is null, this call produces no memory effects at all.\n@@ -1863,1 +1863,1 @@\n-    if (hook_mem != NULL) {\n+    if (hook_mem != nullptr) {\n@@ -1877,1 +1877,1 @@\n-    assert(hook_mem == NULL, \"\");\n+    assert(hook_mem == nullptr, \"\");\n@@ -1898,1 +1898,1 @@\n-  JVMState* ejvms = NULL;\n+  JVMState* ejvms = nullptr;\n@@ -1920,1 +1920,1 @@\n-  if (callprojs.fallthrough_catchproj != NULL) {\n+  if (callprojs.fallthrough_catchproj != nullptr) {\n@@ -1923,1 +1923,1 @@\n-  if (callprojs.fallthrough_memproj != NULL) {\n+  if (callprojs.fallthrough_memproj != nullptr) {\n@@ -1931,1 +1931,1 @@\n-  if (callprojs.fallthrough_ioproj != NULL) {\n+  if (callprojs.fallthrough_ioproj != nullptr) {\n@@ -1936,1 +1936,1 @@\n-  if (callprojs.resproj != NULL && result != NULL) {\n+  if (callprojs.resproj != nullptr && result != nullptr) {\n@@ -1940,1 +1940,1 @@\n-  if (ejvms == NULL) {\n+  if (ejvms == nullptr) {\n@@ -1942,1 +1942,1 @@\n-    if (callprojs.catchall_catchproj != NULL) {\n+    if (callprojs.catchall_catchproj != nullptr) {\n@@ -1945,1 +1945,1 @@\n-    if (callprojs.catchall_memproj != NULL) {\n+    if (callprojs.catchall_memproj != nullptr) {\n@@ -1948,1 +1948,1 @@\n-    if (callprojs.catchall_ioproj != NULL) {\n+    if (callprojs.catchall_ioproj != nullptr) {\n@@ -1952,1 +1952,1 @@\n-    if (callprojs.exobj != NULL) {\n+    if (callprojs.exobj != nullptr) {\n@@ -1964,1 +1964,1 @@\n-    if (callprojs.catchall_catchproj != NULL) {\n+    if (callprojs.catchall_catchproj != nullptr) {\n@@ -1968,1 +1968,1 @@\n-    if (callprojs.catchall_memproj != NULL) {\n+    if (callprojs.catchall_memproj != nullptr) {\n@@ -1973,1 +1973,1 @@\n-    if (callprojs.catchall_ioproj != NULL) {\n+    if (callprojs.catchall_ioproj != nullptr) {\n@@ -1978,1 +1978,1 @@\n-    if (callprojs.exobj != NULL) {\n+    if (callprojs.exobj != nullptr) {\n@@ -1993,1 +1993,1 @@\n-  if (callprojs.fallthrough_catchproj != NULL && !final_ctl->is_top() && do_replaced_nodes) {\n+  if (callprojs.fallthrough_catchproj != nullptr && !final_ctl->is_top() && do_replaced_nodes) {\n@@ -2061,1 +2061,1 @@\n-      if (C->log() != NULL) {\n+      if (C->log() != nullptr) {\n@@ -2093,2 +2093,2 @@\n-  if (log != NULL) {\n-    int kid = (klass == NULL)? -1: log->identify(klass);\n+  if (log != nullptr) {\n+    int kid = (klass == nullptr)? -1: log->identify(klass);\n@@ -2100,1 +2100,1 @@\n-    if (comment != NULL)  log->print(\" comment='%s'\", comment);\n+    if (comment != nullptr)  log->print(\" comment='%s'\", comment);\n@@ -2106,1 +2106,1 @@\n-  if (i0 != NULL && i0->is_If()) {        \/\/ Found a guarding if test?\n+  if (i0 != nullptr && i0->is_If()) {        \/\/ Found a guarding if test?\n@@ -2123,1 +2123,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -2157,1 +2157,1 @@\n-  if (ctrl != NULL && ctrl->is_Region() && ctrl->req() == 2 &&\n+  if (ctrl != nullptr && ctrl->is_Region() && ctrl->req() == 2 &&\n@@ -2164,1 +2164,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2203,1 +2203,1 @@\n-      if (speculative != NULL) {\n+      if (speculative != nullptr) {\n@@ -2247,1 +2247,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -2256,1 +2256,1 @@\n-          if (receiver != NULL) {\n+          if (receiver != nullptr) {\n@@ -2285,1 +2285,1 @@\n-      ciKlass* better_type = NULL;\n+      ciKlass* better_type = nullptr;\n@@ -2305,1 +2305,1 @@\n-      ciKlass* better_type = NULL;\n+      ciKlass* better_type = nullptr;\n@@ -2323,1 +2323,1 @@\n-  ciKlass* better_type = NULL;\n+  ciKlass* better_type = nullptr;\n@@ -2396,1 +2396,1 @@\n-\/\/              [in]     NULL\n+\/\/              [in]     null\n@@ -2434,1 +2434,1 @@\n-  \/\/ Initial NULL check taken path\n+  \/\/ Initial null check taken path\n@@ -2441,1 +2441,1 @@\n-    \/\/ recompile; the offending check-cast will be compiled to handle NULLs.\n+    \/\/ recompile; the offending check-cast will be compiled to handle nulls.\n@@ -2443,1 +2443,1 @@\n-    \/\/ method will be compiled to handle NULLs.\n+    \/\/ method will be compiled to handle nulls.\n@@ -2450,1 +2450,1 @@\n-    (*null_control) = top();    \/\/ NULL path is dead\n+    (*null_control) = top();    \/\/ null path is dead\n@@ -2481,1 +2481,1 @@\n-                                  \/\/ The first NULL ends the list.\n+                                  \/\/ The first null ends the list.\n@@ -2486,1 +2486,1 @@\n-  assert(call_addr != NULL, \"must not call NULL targets\");\n+  assert(call_addr != nullptr, \"must not call null targets\");\n@@ -2491,1 +2491,1 @@\n-  if (call_name == NULL) {\n+  if (call_name == nullptr) {\n@@ -2514,1 +2514,1 @@\n-  Node* prev_mem = NULL;\n+  Node* prev_mem = nullptr;\n@@ -2523,9 +2523,9 @@\n-  \/\/ Hook each parm in order.  Stop looking at the first NULL.\n-  if (parm0 != NULL) { call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL) { call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL) { call->init_req(TypeFunc::Parms+2, parm2);\n-  if (parm3 != NULL) { call->init_req(TypeFunc::Parms+3, parm3);\n-  if (parm4 != NULL) { call->init_req(TypeFunc::Parms+4, parm4);\n-  if (parm5 != NULL) { call->init_req(TypeFunc::Parms+5, parm5);\n-  if (parm6 != NULL) { call->init_req(TypeFunc::Parms+6, parm6);\n-  if (parm7 != NULL) { call->init_req(TypeFunc::Parms+7, parm7);\n+  \/\/ Hook each parm in order.  Stop looking at the first nullptr.\n+  if (parm0 != nullptr) { call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr) { call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr) { call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm3 != nullptr) { call->init_req(TypeFunc::Parms+3, parm3);\n+  if (parm4 != nullptr) { call->init_req(TypeFunc::Parms+4, parm4);\n+  if (parm5 != nullptr) { call->init_req(TypeFunc::Parms+5, parm5);\n+  if (parm6 != nullptr) { call->init_req(TypeFunc::Parms+6, parm6);\n+  if (parm7 != nullptr) { call->init_req(TypeFunc::Parms+7, parm7);\n@@ -2533,1 +2533,1 @@\n-  assert(call->in(call->req()-1) != NULL, \"must initialize all parms\");\n+  assert(call->in(call->req()-1) != nullptr, \"must initialize all parms\");\n@@ -2638,1 +2638,1 @@\n-    if (invoker == NULL) {\n+    if (invoker == nullptr) {\n@@ -2640,1 +2640,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2645,1 +2645,1 @@\n-  assert(call_addr != NULL, \"sanity\");\n+  assert(call_addr != nullptr, \"sanity\");\n@@ -2669,1 +2669,1 @@\n-  if (method() == NULL || method()->return_type()->basic_type() == T_VOID) {\n+  if (method() == nullptr || method()->return_type()->basic_type() == T_VOID) {\n@@ -2707,1 +2707,1 @@\n-          phi = PhiNode::make(region, NULL, Type::MEMORY, mms.adr_type(C));\n+          phi = PhiNode::make(region, nullptr, Type::MEMORY, mms.adr_type(C));\n@@ -2762,1 +2762,1 @@\n-  Node* cmp = NULL;\n+  Node* cmp = nullptr;\n@@ -2839,1 +2839,1 @@\n-  Node *chk_off = gvn.transform(new LoadINode(NULL, m, p1, gvn.type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n+  Node *chk_off = gvn.transform(new LoadINode(nullptr, m, p1, gvn.type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n@@ -2847,2 +2847,2 @@\n-  \/\/ Worst-case type is a little odd: NULL is allowed as a result (usually\n-  \/\/ klass loads can never produce a NULL).\n+  \/\/ Worst-case type is a little odd: null is allowed as a result (usually\n+  \/\/ klass loads can never produce a null).\n@@ -2863,1 +2863,1 @@\n-  if (might_be_cache && mem != NULL) {\n+  if (might_be_cache && mem != nullptr) {\n@@ -2866,1 +2866,1 @@\n-  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n+  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, nullptr, kmem, p2, gvn.type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n@@ -3026,1 +3026,1 @@\n-\/\/ recompile; the offending check will be recompiled to handle NULLs.\n+\/\/ recompile; the offending check will be recompiled to handle nulls.\n@@ -3039,1 +3039,1 @@\n-    if (data == NULL)\n+    if (data == nullptr)\n@@ -3055,1 +3055,1 @@\n-  Node* init_state = LoadNode::make(_gvn, NULL, immutable_memory(), adr,\n+  Node* init_state = LoadNode::make(_gvn, nullptr, immutable_memory(), adr,\n@@ -3074,1 +3074,1 @@\n-  Node* init_thread = LoadNode::make(_gvn, NULL, immutable_memory(), adr,\n+  Node* init_thread = LoadNode::make(_gvn, nullptr, immutable_memory(), adr,\n@@ -3102,1 +3102,1 @@\n-                  NULL);\n+                  nullptr);\n@@ -3113,1 +3113,1 @@\n-  if (!UseTypeProfile || !TypeProfileCasts) return NULL;\n+  if (!UseTypeProfile || !TypeProfileCasts) return nullptr;\n@@ -3115,1 +3115,1 @@\n-  Deoptimization::DeoptReason reason = Deoptimization::reason_class_check(spec_klass != NULL);\n+  Deoptimization::DeoptReason reason = Deoptimization::reason_class_check(spec_klass != nullptr);\n@@ -3119,1 +3119,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3125,3 +3125,3 @@\n-  ciKlass* exact_kls = spec_klass == NULL ? profile_has_unique_klass() : spec_klass;\n-  if (exact_kls != NULL) {\/\/ no cast failures here\n-    if (require_klass == NULL ||\n+  ciKlass* exact_kls = spec_klass == nullptr ? profile_has_unique_klass() : spec_klass;\n+  if (exact_kls != nullptr) {\/\/ no cast failures here\n+    if (require_klass == nullptr ||\n@@ -3150,1 +3150,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3168,2 +3168,2 @@\n-  \/\/ type == NULL if profiling tells us this object is always null\n-  if (type != NULL) {\n+  \/\/ type is null if profiling tells us this object is always null\n+  if (type != nullptr) {\n@@ -3175,1 +3175,1 @@\n-      Node* not_null_obj = NULL;\n+      Node* not_null_obj = nullptr;\n@@ -3223,1 +3223,1 @@\n-  ciProfileData* data = NULL;\n+  ciProfileData* data = nullptr;\n@@ -3236,1 +3236,1 @@\n-  if (stopped()) {              \/\/ Doing instance-of on a NULL?\n+  if (stopped()) {              \/\/ Doing instance-of on a null?\n@@ -3255,1 +3255,1 @@\n-    if (subk != NULL && subk->is_loaded()) {\n+    if (subk != nullptr && subk->is_loaded()) {\n@@ -3266,2 +3266,2 @@\n-    if (spec_obj_type != NULL || (ProfileDynamicTypes && data != NULL)) {\n-      Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);\n+    if (spec_obj_type != nullptr || (ProfileDynamicTypes && data != nullptr)) {\n+      Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, nullptr, spec_obj_type, safe_for_replace);\n@@ -3272,1 +3272,1 @@\n-      if (cast_obj != NULL) {\n+      if (cast_obj != nullptr) {\n@@ -3325,1 +3325,1 @@\n-    if (objtp != NULL && objtp->klass() != NULL) {\n+    if (objtp != nullptr && objtp->klass() != nullptr) {\n@@ -3346,1 +3346,1 @@\n-  ciProfileData* data = NULL;\n+  ciProfileData* data = nullptr;\n@@ -3348,1 +3348,1 @@\n-  if (failure_control == NULL) {        \/\/ use MDO in regular case only\n+  if (failure_control == nullptr) {        \/\/ use MDO in regular case only\n@@ -3364,1 +3364,1 @@\n-  bool never_see_null = ((failure_control == NULL)  \/\/ regular case only\n+  bool never_see_null = ((failure_control == nullptr)  \/\/ regular case only\n@@ -3372,1 +3372,1 @@\n-  if (stopped()) {              \/\/ Doing instance-of on a NULL?\n+  if (stopped()) {              \/\/ Doing instance-of on a null?\n@@ -3386,1 +3386,1 @@\n-  Node* cast_obj = NULL;\n+  Node* cast_obj = nullptr;\n@@ -3396,1 +3396,1 @@\n-    if (spec_obj_type != NULL || data != NULL) {\n+    if (spec_obj_type != nullptr || data != nullptr) {\n@@ -3398,2 +3398,2 @@\n-      if (cast_obj != NULL) {\n-        if (failure_control != NULL) \/\/ failure is now impossible\n+      if (cast_obj != nullptr) {\n+        if (failure_control != nullptr) \/\/ failure is now impossible\n@@ -3407,1 +3407,1 @@\n-  if (cast_obj == NULL) {\n+  if (cast_obj == nullptr) {\n@@ -3414,1 +3414,1 @@\n-    if (failure_control == NULL) {\n+    if (failure_control == nullptr) {\n@@ -3428,1 +3428,1 @@\n-  \/\/ A merge of NULL or Casted-NotNull obj\n+  \/\/ A merge of null or Casted-NotNull obj\n@@ -3512,1 +3512,1 @@\n-    return NULL;                \/\/ Not locking things?\n+    return nullptr;                \/\/ Not locking things?\n@@ -3514,1 +3514,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3617,1 +3617,1 @@\n-\/\/ and return (Node*)NULL.  Otherwise, load the non-constant\n+\/\/ and return (Node*)nullptr.  Otherwise, load the non-constant\n@@ -3623,1 +3623,1 @@\n-  if (!StressReflectiveCode && inst_klass != NULL) {\n+  if (!StressReflectiveCode && inst_klass != nullptr) {\n@@ -3630,1 +3630,1 @@\n-        return (Node*) NULL;\n+        return (Node*) nullptr;\n@@ -3636,1 +3636,1 @@\n-  return make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);\n+  return make_load(nullptr, lhp, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3756,1 +3756,1 @@\n-  int   layout_is_con = (layout_val == NULL);\n+  int   layout_is_con = (layout_val == nullptr);\n@@ -3758,1 +3758,1 @@\n-  if (extra_slow_test == NULL)  extra_slow_test = intcon(0);\n+  if (extra_slow_test == nullptr)  extra_slow_test = intcon(0);\n@@ -3760,1 +3760,1 @@\n-  \/\/ Node for 1) or NEVER (return a NULL) or perhaps (in the reflective\n+  \/\/ Node for 1) or NEVER (return a null) or perhaps (in the reflective\n@@ -3762,1 +3762,1 @@\n-  Node* initial_slow_test = NULL;\n+  Node* initial_slow_test = nullptr;\n@@ -3781,1 +3781,1 @@\n-  Node* size = NULL;\n+  Node* size = nullptr;\n@@ -3793,1 +3793,1 @@\n-  if (return_size_val != NULL) {\n+  if (return_size_val != nullptr) {\n@@ -3830,1 +3830,1 @@\n-  int   layout_is_con = (layout_val == NULL);\n+  int   layout_is_con = (layout_val == nullptr);\n@@ -3845,1 +3845,1 @@\n-    layout_val = NULL;\n+    layout_val = nullptr;\n@@ -3872,1 +3872,1 @@\n-  Node* header_size = NULL;\n+  Node* header_size = nullptr;\n@@ -3894,1 +3894,1 @@\n-  Node* elem_shift = NULL;\n+  Node* elem_shift = nullptr;\n@@ -3911,1 +3911,1 @@\n-    if (tilen != NULL && tilen->_lo < 0) {\n+    if (tilen != nullptr && tilen->_lo < 0) {\n@@ -3948,1 +3948,1 @@\n-  if (elem_shift != NULL)\n+  if (elem_shift != nullptr)\n@@ -3957,1 +3957,1 @@\n-  if (return_size_val != NULL) {\n+  if (return_size_val != nullptr) {\n@@ -3996,1 +3996,1 @@\n-  if (ary_type->isa_aryptr() && length_type != NULL) {\n+  if (ary_type->isa_aryptr() && length_type != nullptr) {\n@@ -4013,2 +4013,2 @@\n-  if (ptr == NULL) {     \/\/ reduce dumb test in callers\n-    return NULL;\n+  if (ptr == nullptr) {     \/\/ reduce dumb test in callers\n+    return nullptr;\n@@ -4022,1 +4022,1 @@\n-    if (ptr == NULL) return NULL;\n+    if (ptr == nullptr) return nullptr;\n@@ -4024,1 +4024,1 @@\n-  \/\/ Return NULL for allocations with several casts:\n+  \/\/ Return null for allocations with several casts:\n@@ -4030,1 +4030,1 @@\n-    if (allo != NULL && allo->is_Allocate()) {\n+    if (allo != nullptr && allo->is_Allocate()) {\n@@ -4035,1 +4035,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4042,1 +4042,1 @@\n-  if (base == NULL)  return NULL;\n+  if (base == nullptr)  return nullptr;\n@@ -4055,1 +4055,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4061,1 +4061,1 @@\n-  if (rawoop == NULL)  return NULL;\n+  if (rawoop == nullptr)  return nullptr;\n@@ -4069,1 +4069,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4144,1 +4144,1 @@\n-                                                     false, NULL, 0);\n+                                                     false, nullptr, 0);\n@@ -4161,1 +4161,1 @@\n-                                                     false, NULL, 0);\n+                                                     false, nullptr, 0);\n@@ -4173,1 +4173,1 @@\n-                                                     false, NULL, 0);\n+                                                     false, nullptr, 0);\n@@ -4183,1 +4183,1 @@\n-                                                     false, NULL, 0);\n+                                                     false, nullptr, 0);\n@@ -4284,1 +4284,1 @@\n-    return NULL; \/\/ Field not marked as constant.\n+    return nullptr; \/\/ Field not marked as constant.\n@@ -4286,1 +4286,1 @@\n-  ciInstance* holder = NULL;\n+  ciInstance* holder = nullptr;\n@@ -4289,1 +4289,1 @@\n-    if (const_oop != NULL && const_oop->is_instance()) {\n+    if (const_oop != nullptr && const_oop->is_instance()) {\n@@ -4295,1 +4295,1 @@\n-  if (con_type != NULL) {\n+  if (con_type != nullptr) {\n@@ -4298,1 +4298,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":207,"deletions":207,"binary":false,"changes":414,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    assert(_map != NULL, \"must call stopped() to test for reset compiler map\");\n+    assert(_map != nullptr, \"must call stopped() to test for reset compiler map\");\n@@ -89,2 +89,2 @@\n-  virtual Parse*          is_Parse()          const { return NULL; }\n-  virtual LibraryCallKit* is_LibraryCallKit() const { return NULL; }\n+  virtual Parse*          is_Parse()          const { return nullptr; }\n+  virtual LibraryCallKit* is_LibraryCallKit() const { return nullptr; }\n@@ -134,1 +134,1 @@\n-  bool               has_exceptions() const { return _exceptions != NULL; }\n+  bool               has_exceptions() const { return _exceptions != nullptr; }\n@@ -145,1 +145,1 @@\n-                                        _method = jvms->has_method() ? jvms->method() : NULL; }\n+                                        _method = jvms->has_method() ? jvms->method() : nullptr; }\n@@ -179,1 +179,1 @@\n-  \/\/ Set _map to NULL, signalling a stop to further bytecode execution.\n+  \/\/ Set _map to null, signalling a stop to further bytecode execution.\n@@ -181,1 +181,1 @@\n-  SafePointNode* stop() { SafePointNode* m = map(); set_map(NULL); return m; }\n+  SafePointNode* stop() { SafePointNode* m = map(); set_map(nullptr); return m; }\n@@ -183,1 +183,1 @@\n-  \/\/ Stop, but first smash the map's inputs to NULL, to mark it dead.\n+  \/\/ Stop, but first smash the map's inputs to null, to mark it dead.\n@@ -186,1 +186,1 @@\n-  \/\/ Tell if _map is NULL, or control is top.\n+  \/\/ Tell if _map is null, or control is top.\n@@ -218,1 +218,1 @@\n-    if (ex_map != NULL) {\n+    if (ex_map != nullptr) {\n@@ -220,1 +220,1 @@\n-      ex_map->set_next_exception(NULL);\n+      ex_map->set_next_exception(nullptr);\n@@ -243,1 +243,1 @@\n-    if (_exceptions == NULL)  return NULL;\n+    if (_exceptions == nullptr)  return nullptr;\n@@ -246,1 +246,1 @@\n-    while ((ex_map = pop_exception_state()) != NULL) {\n+    while ((ex_map = pop_exception_state()) != nullptr) {\n@@ -274,1 +274,1 @@\n-  void builtin_throw(Deoptimization::DeoptReason reason, Node* arg = NULL);\n+  void builtin_throw(Deoptimization::DeoptReason reason, Node* arg = nullptr);\n@@ -354,1 +354,1 @@\n-  \/\/ Helper function to do a NULL pointer check or ZERO check based on type.\n+  \/\/ Helper function to do a null pointer check or ZERO check based on type.\n@@ -360,1 +360,1 @@\n-                          Node* *null_control = NULL,\n+                          Node* *null_control = nullptr,\n@@ -363,1 +363,1 @@\n-    return null_check_common(value, type, false, NULL, !_gvn.type(value)->speculative_maybe_null());\n+    return null_check_common(value, type, false, nullptr, !_gvn.type(value)->speculative_maybe_null());\n@@ -382,1 +382,1 @@\n-    return null_check_common(value, type, true, NULL, _gvn.type(value)->speculative_always_null());\n+    return null_check_common(value, type, true, nullptr, _gvn.type(value)->speculative_always_null());\n@@ -415,1 +415,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -480,1 +480,1 @@\n-    else                   return NULL;\n+    else                   return nullptr;\n@@ -550,1 +550,1 @@\n-    assert(adr_type != NULL, \"use other make_load factory\");\n+    assert(adr_type != nullptr, \"use other make_load factory\");\n@@ -577,1 +577,1 @@\n-    assert(adr_type != NULL, \"use other store_to_memory factory\");\n+    assert(adr_type != nullptr, \"use other store_to_memory factory\");\n@@ -658,1 +658,1 @@\n-                              const TypeInt* sizetype = NULL,\n+                              const TypeInt* sizetype = nullptr,\n@@ -660,1 +660,1 @@\n-                              Node* ctrl = NULL);\n+                              Node* ctrl = nullptr);\n@@ -715,1 +715,1 @@\n-    set_predefined_output_for_runtime_call(call, NULL, NULL);\n+    set_predefined_output_for_runtime_call(call, nullptr, nullptr);\n@@ -720,1 +720,1 @@\n-  Node* set_predefined_input_for_runtime_call(SafePointNode* call, Node* narrow_mem = NULL);\n+  Node* set_predefined_input_for_runtime_call(SafePointNode* call, Node* narrow_mem = nullptr);\n@@ -736,1 +736,1 @@\n-                     ciKlass* klass = NULL, const char* reason_string = NULL,\n+                     ciKlass* klass = nullptr, const char* reason_string = nullptr,\n@@ -742,1 +742,1 @@\n-                     ciKlass* klass = NULL, const char* reason_string = NULL,\n+                     ciKlass* klass = nullptr, const char* reason_string = nullptr,\n@@ -751,1 +751,1 @@\n-                           ciKlass* klass = NULL, const char* reason_string = NULL,\n+                           ciKlass* klass = nullptr, const char* reason_string = nullptr,\n@@ -801,5 +801,5 @@\n-                          const TypePtr* adr_type, \/\/ NULL if no memory effects\n-                          Node* parm0 = NULL, Node* parm1 = NULL,\n-                          Node* parm2 = NULL, Node* parm3 = NULL,\n-                          Node* parm4 = NULL, Node* parm5 = NULL,\n-                          Node* parm6 = NULL, Node* parm7 = NULL);\n+                          const TypePtr* adr_type, \/\/ null if no memory effects\n+                          Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                          Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                          Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                          Node* parm6 = nullptr, Node* parm7 = nullptr);\n@@ -829,2 +829,2 @@\n-  Node* insert_mem_bar(int opcode, Node* precedent = NULL);\n-  Node* insert_mem_bar_volatile(int opcode, int alias_idx, Node* precedent = NULL);\n+  Node* insert_mem_bar(int opcode, Node* precedent = nullptr);\n+  Node* insert_mem_bar_volatile(int opcode, int alias_idx, Node* precedent = nullptr);\n@@ -845,1 +845,1 @@\n-                       Node* *failure_control = NULL );\n+                       Node* *failure_control = nullptr );\n@@ -865,2 +865,2 @@\n-                     Node* slow_test = NULL,\n-                     Node* *return_size_val = NULL,\n+                     Node* slow_test = nullptr,\n+                     Node* *return_size_val = nullptr,\n@@ -869,1 +869,1 @@\n-                  Node* *return_size_val = NULL,\n+                  Node* *return_size_val = nullptr,\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  if (!thread->is_Compiler_thread()) return NULL;\n+  if (!thread->is_Compiler_thread()) return nullptr;\n@@ -83,1 +83,1 @@\n-  if (compiler_thread->ideal_graph_printer() == NULL) {\n+  if (compiler_thread->ideal_graph_printer() == nullptr) {\n@@ -99,1 +99,1 @@\n-      c->set_ideal_graph_printer(NULL);\n+      c->set_ideal_graph_printer(nullptr);\n@@ -103,1 +103,1 @@\n-  if (debug_file_printer != NULL) {\n+  if (debug_file_printer != nullptr) {\n@@ -107,1 +107,1 @@\n-  if (debug_network_printer != NULL) {\n+  if (debug_network_printer != nullptr) {\n@@ -117,1 +117,1 @@\n-\/\/ Either print methods to the specified file 'file_name' or if NULL over the network to the IGV. If 'append'\n+\/\/ Either print methods to the specified file 'file_name' or if null over the network to the IGV. If 'append'\n@@ -121,1 +121,1 @@\n-  assert(!append || (append && file_name != NULL), \"can only use append flag when printing to file\");\n+  assert(!append || (append && file_name != nullptr), \"can only use append flag when printing to file\");\n@@ -139,1 +139,1 @@\n-  _output = NULL;\n+  _output = nullptr;\n@@ -142,2 +142,2 @@\n-  _current_method = NULL;\n-  _network_stream = NULL;\n+  _current_method = nullptr;\n+  _network_stream = nullptr;\n@@ -145,1 +145,1 @@\n-  if (file_name != NULL) {\n+  if (file_name != nullptr) {\n@@ -166,1 +166,1 @@\n-    _xml = NULL;\n+    _xml = nullptr;\n@@ -172,1 +172,1 @@\n-      _output = NULL;\n+      _output = nullptr;\n@@ -174,1 +174,1 @@\n-    _network_stream = NULL;\n+    _network_stream = nullptr;\n@@ -179,1 +179,1 @@\n-    _output = NULL;\n+    _output = nullptr;\n@@ -258,1 +258,1 @@\n-  if (tree != NULL && tree->subtrees().length() > 0) {\n+  if (tree != nullptr && tree->subtrees().length() > 0) {\n@@ -272,1 +272,1 @@\n-  if (tree != NULL) {\n+  if (tree != nullptr) {\n@@ -282,1 +282,1 @@\n-    if (inlineTree != NULL) {\n+    if (inlineTree != nullptr) {\n@@ -327,1 +327,1 @@\n-  _current_method = NULL;\n+  _current_method = nullptr;\n@@ -374,1 +374,1 @@\n-    if (C->cfg() != NULL) {\n+    if (C->cfg() != nullptr) {\n@@ -376,1 +376,1 @@\n-      if (block == NULL) {\n+      if (block == nullptr) {\n@@ -381,1 +381,1 @@\n-          if (block->_idom != NULL) {\n+          if (block->_idom != nullptr) {\n@@ -448,1 +448,1 @@\n-    if (C->matcher() != NULL) {\n+    if (C->matcher() != nullptr) {\n@@ -460,1 +460,1 @@\n-      if (old != NULL) {\n+      if (old != nullptr) {\n@@ -477,1 +477,1 @@\n-    if (t != NULL && (t->isa_instptr() || t->isa_klassptr())) {\n+    if (t != nullptr && (t->isa_instptr() || t->isa_klassptr())) {\n@@ -480,1 +480,1 @@\n-      ciKlass*           klass = toop ? toop->klass() : (tkls ? tkls->klass() : NULL );\n+      ciKlass*           klass = toop ? toop->klass() : (tkls ? tkls->klass() : nullptr );\n@@ -566,1 +566,1 @@\n-    JVMState* caller = NULL;\n+    JVMState* caller = nullptr;\n@@ -571,1 +571,1 @@\n-      if (notes != NULL) {\n+      if (notes != nullptr) {\n@@ -576,1 +576,1 @@\n-    if (caller != NULL) {\n+    if (caller != nullptr) {\n@@ -578,1 +578,1 @@\n-      ciMethod* last = NULL;\n+      ciMethod* last = nullptr;\n@@ -589,1 +589,1 @@\n-      if (last != NULL && last->has_linenumber_table() && last_bci >= 0) {\n+      if (last != nullptr && last->has_linenumber_table() && last_bci >= 0) {\n@@ -595,1 +595,1 @@\n-    if (node->debug_orig() != NULL) {\n+    if (node->debug_orig() != nullptr) {\n@@ -625,1 +625,1 @@\n-  GrowableArray<Node *> nodeStack(Thread::current()->resource_area(), 0, 0, NULL);\n+  GrowableArray<Node *> nodeStack(Thread::current()->resource_area(), 0, 0, nullptr);\n@@ -628,1 +628,1 @@\n-  if (C->cfg() != NULL) {\n+  if (C->cfg() != nullptr) {\n@@ -672,1 +672,1 @@\n-  if (!_current_method || !_should_send_method || node == NULL) return;\n+  if (!_current_method || !_should_send_method || node == nullptr) return;\n@@ -684,1 +684,1 @@\n-  if (C->cfg() != NULL) {\n+  if (C->cfg() != nullptr) {\n@@ -700,1 +700,1 @@\n-  if (C->cfg() != NULL) {\n+  if (C->cfg() != nullptr) {\n@@ -765,1 +765,1 @@\n-      _network_stream = NULL;\n+      _network_stream = nullptr;\n@@ -778,1 +778,1 @@\n-  assert(C != NULL, \"must already be set\");\n+  assert(C != nullptr, \"must already be set\");\n@@ -782,1 +782,1 @@\n-    _current_method = NULL;\n+    _current_method = nullptr;\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-  IdealGraphPrinter(Compile* compile, const char* file_name = NULL, bool append = false);\n+  IdealGraphPrinter(Compile* compile, const char* file_name = nullptr, bool append = false);\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  _cvstate = NULL;\n+  _cvstate = nullptr;\n@@ -50,1 +50,1 @@\n-  assert(_initial_memory == NULL || _initial_memory->Opcode() == Op_MergeMem, \"memory must be pre-split\");\n+  assert(_initial_memory == nullptr || _initial_memory->Opcode() == Op_MergeMem, \"memory must be pre-split\");\n@@ -76,2 +76,2 @@\n-  if (left->bottom_type()->isa_ptr() == NULL) {\n-    if (left->bottom_type()->isa_int() != NULL) {\n+  if (left->bottom_type()->isa_ptr() == nullptr) {\n+    if (left->bottom_type()->isa_int() != nullptr) {\n@@ -80,1 +80,1 @@\n-      assert(left->bottom_type()->isa_long() != NULL, \"what else?\");\n+      assert(left->bottom_type()->isa_long() != nullptr, \"what else?\");\n@@ -205,1 +205,1 @@\n-  assert(_cvstate != NULL, \"must declare variables before labels\");\n+  assert(_cvstate != nullptr, \"must declare variables before labels\");\n@@ -231,1 +231,1 @@\n-  while (slot < reg->req() && reg->in(slot) != NULL) slot++;\n+  while (slot < reg->req() && reg->in(slot) != nullptr) slot++;\n@@ -248,1 +248,1 @@\n-    if (m == NULL) {\n+    if (m == nullptr) {\n@@ -250,1 +250,1 @@\n-    } else if (l == NULL || m == l) {\n+    } else if (l == nullptr || m == l) {\n@@ -329,1 +329,1 @@\n-  for (uint i = 0; i < m->req(); i++) m->set_req(i, NULL);\n+  for (uint i = 0; i < m->req(); i++) m->set_req(i, nullptr);\n@@ -359,1 +359,1 @@\n-  const TypePtr* adr_type = NULL; \/\/ debug-mode-only argument\n+  const TypePtr* adr_type = nullptr; \/\/ debug-mode-only argument\n@@ -371,1 +371,1 @@\n-  const TypePtr* adr_type = NULL;\n+  const TypePtr* adr_type = nullptr;\n@@ -390,1 +390,1 @@\n-  const TypePtr* adr_type = NULL;\n+  const TypePtr* adr_type = nullptr;\n@@ -414,2 +414,2 @@\n-  assert(join_region != NULL, \"join region must exist\");\n-  if (join->in(TypeFunc::I_O) == NULL ) {\n+  assert(join_region != nullptr, \"join region must exist\");\n+  if (join->in(TypeFunc::I_O) == nullptr ) {\n@@ -418,1 +418,1 @@\n-  if (join->in(TypeFunc::Memory) == NULL ) {\n+  if (join->in(TypeFunc::Memory) == nullptr ) {\n@@ -506,4 +506,4 @@\n-  if (parm0 != NULL)  call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL)  call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL)  call->init_req(TypeFunc::Parms+2, parm2);\n-  if (parm3 != NULL)  call->init_req(TypeFunc::Parms+3, parm3);\n+  if (parm0 != nullptr)  call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr)  call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr)  call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm3 != nullptr)  call->init_req(TypeFunc::Parms+3, parm3);\n@@ -527,1 +527,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -558,4 +558,4 @@\n-  if (parm0 != NULL)  call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL)  call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL)  call->init_req(TypeFunc::Parms+2, parm2);\n-  if (parm3 != NULL)  call->init_req(TypeFunc::Parms+3, parm3);\n+  if (parm0 != nullptr)  call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr)  call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr)  call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm3 != nullptr)  call->init_req(TypeFunc::Parms+3, parm3);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-  void dead(IdealVariable& v)           { set(v, (Node*)NULL); }\n+  void dead(IdealVariable& v)           { set(v, (Node*)nullptr); }\n@@ -251,3 +251,3 @@\n-                       Node* parm1 = NULL,\n-                       Node* parm2 = NULL,\n-                       Node* parm3 = NULL);\n+                       Node* parm1 = nullptr,\n+                       Node* parm2 = nullptr,\n+                       Node* parm3 = nullptr);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -822,1 +822,1 @@\n-  if (str != NULL) {\n+  if (str != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  if( !i1->is_Bool() ) return NULL;\n+  if( !i1->is_Bool() ) return nullptr;\n@@ -85,1 +85,1 @@\n-  if( !cmp->is_Cmp() ) return NULL;\n+  if( !cmp->is_Cmp() ) return nullptr;\n@@ -87,1 +87,1 @@\n-  if( i1 == NULL || !i1->is_Phi() ) return NULL;\n+  if( i1 == nullptr || !i1->is_Phi() ) return nullptr;\n@@ -90,1 +90,1 @@\n-  if( !con2->is_Con() ) return NULL;\n+  if( !con2->is_Con() ) return nullptr;\n@@ -92,1 +92,1 @@\n-  Node *con1=NULL;\n+  Node *con1=nullptr;\n@@ -96,1 +96,1 @@\n-    if( !con1 ) return NULL;    \/\/ Do not optimize partially collapsed merges\n+    if( !con1 ) return nullptr;    \/\/ Do not optimize partially collapsed merges\n@@ -103,1 +103,1 @@\n-  if( i4 >= phi->req() ) return NULL; \/\/ Found no constants\n+  if( i4 >= phi->req() ) return nullptr; \/\/ Found no constants\n@@ -114,1 +114,1 @@\n-  if( !t->singleton() ) return NULL;\n+  if( !t->singleton() ) return nullptr;\n@@ -119,1 +119,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -125,1 +125,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -142,1 +142,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -148,1 +148,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -160,2 +160,2 @@\n-        if (v->in(0) == NULL) {\n-          return NULL;\n+        if (v->in(0) == nullptr) {\n+          return nullptr;\n@@ -170,3 +170,3 @@\n-      \/\/if( vop == Op_Phi ) {     \/\/ Phi from another merge point might be OK\n-      \/\/  Node *r = v->in(0);     \/\/ Get controlling point\n-      \/\/  if( !r ) return NULL;   \/\/ Degraded to a copy\n+      \/\/if( vop == Op_Phi ) {        \/\/ Phi from another merge point might be OK\n+      \/\/  Node *r = v->in(0);        \/\/ Get controlling point\n+      \/\/  if( !r ) return nullptr;   \/\/ Degraded to a copy\n@@ -193,1 +193,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -201,1 +201,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -208,1 +208,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -217,1 +217,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -246,1 +246,1 @@\n-    if (proj != NULL) {\n+    if (proj != nullptr) {\n@@ -249,1 +249,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -256,1 +256,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -264,1 +264,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -339,2 +339,2 @@\n-  cmp->set_req(1,NULL);  \/\/ Whack the inputs to cmp because it will be dead\n-  cmp->set_req(2,NULL);\n+  cmp->set_req(1,nullptr);  \/\/ Whack the inputs to cmp because it will be dead\n+  cmp->set_req(2,nullptr);\n@@ -343,2 +343,2 @@\n-  Node *phi_s = NULL;     \/\/ do not construct unless needed\n-  Node *phi_f = NULL;     \/\/ do not construct unless needed\n+  Node *phi_s = nullptr;     \/\/ do not construct unless needed\n+  Node *phi_f = nullptr;     \/\/ do not construct unless needed\n@@ -349,1 +349,1 @@\n-    Node *proj = NULL;\n+    Node *proj = nullptr;\n@@ -362,1 +362,1 @@\n-    guarantee(proj != NULL, \"sanity\");\n+    guarantee(proj != nullptr, \"sanity\");\n@@ -366,1 +366,1 @@\n-      if( phi_s == NULL ) {\n+      if( phi_s == nullptr ) {\n@@ -378,1 +378,1 @@\n-      if( phi_f == NULL ) {\n+      if( phi_f == nullptr ) {\n@@ -434,1 +434,1 @@\n-      r->set_req(0, NULL);\n+      r->set_req(0, nullptr);\n@@ -455,1 +455,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -458,1 +458,1 @@\n-  if (b == NULL || !b->is_Bool())  return NULL;\n+  if (b == nullptr || !b->is_Bool())  return nullptr;\n@@ -461,2 +461,2 @@\n-  if (cmp == NULL)  return NULL;\n-  if (cmp->Opcode() != Op_CmpU)  return NULL;\n+  if (cmp == nullptr)  return nullptr;\n+  if (cmp->Opcode() != Op_CmpU)  return nullptr;\n@@ -472,1 +472,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -474,2 +474,2 @@\n-  if (l->is_top())  return NULL;   \/\/ Top input means dead test\n-  if (r->Opcode() != Op_LoadRange && !is_RangeCheck())  return NULL;\n+  if (l->is_top())  return nullptr;   \/\/ Top input means dead test\n+  if (r->Opcode() != Op_LoadRange && !is_RangeCheck())  return nullptr;\n@@ -488,1 +488,1 @@\n-\/\/ offset.  Return 2 if we had to negate the test.  Index is NULL if the check\n+\/\/ offset.  Return 2 if we had to negate the test.  Index is null if the check\n@@ -492,2 +492,2 @@\n-  Node* l = NULL;\n-  Node* r = NULL;\n+  Node* l = nullptr;\n+  Node* r = nullptr;\n@@ -496,1 +496,1 @@\n-  if (iftrap == NULL) {\n+  if (iftrap == nullptr) {\n@@ -504,1 +504,1 @@\n-  if (iftrap->is_uncommon_trap_proj(Deoptimization::Reason_range_check) == NULL) {\n+  if (iftrap->is_uncommon_trap_proj(Deoptimization::Reason_range_check) == nullptr) {\n@@ -521,1 +521,1 @@\n-    ind = NULL;\n+    ind = nullptr;\n@@ -566,1 +566,1 @@\n-\/\/ Walk up the dominator tree one step.  Return NULL at root or true\n+\/\/ Walk up the dominator tree one step.  Return null at root or true\n@@ -579,1 +579,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -582,1 +582,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -601,1 +601,1 @@\n-    if (din3 != NULL && din3 == din4 && din3->is_If()) \/\/ Regions not degraded to a copy\n+    if (din3 != nullptr && din3 == din4 && din3->is_If()) \/\/ Regions not degraded to a copy\n@@ -606,1 +606,1 @@\n-  return NULL;                  \/\/ Dead loop?  Or hit root?\n+  return nullptr;                  \/\/ Dead loop?  Or hit root?\n@@ -623,1 +623,1 @@\n-          if (cmp2_t != NULL) {\n+          if (cmp2_t != nullptr) {\n@@ -631,1 +631,1 @@\n-              if (val_t != NULL && !val_t->singleton() && cmp2_t->is_con()) {\n+              if (val_t != nullptr && !val_t->singleton() && cmp2_t->is_con()) {\n@@ -639,1 +639,1 @@\n-              return NULL;\n+              return nullptr;\n@@ -672,1 +672,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -715,1 +715,1 @@\n-  return in(1) != NULL &&\n+  return in(1) != nullptr &&\n@@ -717,1 +717,1 @@\n-    in(1)->in(1) != NULL &&\n+    in(1)->in(1) != nullptr &&\n@@ -719,1 +719,1 @@\n-    in(1)->in(1)->in(2) != NULL &&\n+    in(1)->in(1)->in(2) != nullptr &&\n@@ -728,1 +728,1 @@\n-  return ctrl != NULL &&\n+  return ctrl != nullptr &&\n@@ -730,1 +730,1 @@\n-    ctrl->in(0) != NULL &&\n+    ctrl->in(0) != nullptr &&\n@@ -735,1 +735,1 @@\n-    ctrl->in(0)->in(1)->in(1)->in(1) != NULL &&\n+    ctrl->in(0)->in(1)->in(1)->in(1) != nullptr &&\n@@ -744,3 +744,3 @@\n-  RegionNode* region = (otherproj_ctrl_use != NULL && otherproj_ctrl_use->is_Region()) ? otherproj_ctrl_use->as_Region() : NULL;\n-  success = NULL;\n-  fail = NULL;\n+  RegionNode* region = (otherproj_ctrl_use != nullptr && otherproj_ctrl_use->is_Region()) ? otherproj_ctrl_use->as_Region() : nullptr;\n+  success = nullptr;\n+  fail = nullptr;\n@@ -748,1 +748,1 @@\n-  if (otherproj->outcnt() == 1 && region != NULL && !region->has_phi()) {\n+  if (otherproj->outcnt() == 1 && region != nullptr && !region->has_phi()) {\n@@ -751,1 +751,1 @@\n-      if (success == NULL && proj->outcnt() == 1 && proj->unique_out() == region) {\n+      if (success == nullptr && proj->outcnt() == 1 && proj->unique_out() == region) {\n@@ -753,1 +753,1 @@\n-      } else if (fail == NULL) {\n+      } else if (fail == nullptr) {\n@@ -756,1 +756,1 @@\n-        success = fail = NULL;\n+        success = fail = nullptr;\n@@ -760,1 +760,1 @@\n-  return success != NULL && fail != NULL;\n+  return success != nullptr && fail != nullptr;\n@@ -775,1 +775,1 @@\n-  if ((dom_caller == NULL) != (caller == NULL)) {\n+  if ((dom_caller == nullptr) != (caller == nullptr)) {\n@@ -779,1 +779,1 @@\n-  } else if (dom_caller != NULL && !dom_caller->same_calls_as(caller)) {\n+  } else if (dom_caller != nullptr && !dom_caller->same_calls_as(caller)) {\n@@ -799,1 +799,1 @@\n-    if (call != NULL) {\n+    if (call != nullptr) {\n@@ -803,1 +803,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -811,1 +811,1 @@\n-  if (otherproj->outcnt() == 1 && dom_unc != NULL) {\n+  if (otherproj->outcnt() == 1 && dom_unc != nullptr) {\n@@ -817,1 +817,1 @@\n-    CallStaticJavaNode* unc = NULL;\n+    CallStaticJavaNode* unc = nullptr;\n@@ -819,1 +819,1 @@\n-    if (unc_proj != NULL && unc_proj->outcnt() == 1) {\n+    if (unc_proj != nullptr && unc_proj->outcnt() == 1) {\n@@ -826,1 +826,1 @@\n-        assert(r->has_phi() == NULL, \"simple region shouldn't have a phi\");\n+        assert(r->has_phi() == nullptr, \"simple region shouldn't have a phi\");\n@@ -894,2 +894,2 @@\n-  Node* adjusted_lim = NULL;\n-  if (lo_type != NULL && hi_type != NULL && hi_type->_lo > lo_type->_hi &&\n+  Node* adjusted_lim = nullptr;\n+  if (lo_type != nullptr && hi_type != nullptr && hi_type->_lo > lo_type->_hi &&\n@@ -940,1 +940,1 @@\n-  } else if (lo_type != NULL && hi_type != NULL && lo_type->_lo > hi_type->_hi &&\n+  } else if (lo_type != nullptr && hi_type != nullptr && lo_type->_lo > hi_type->_hi &&\n@@ -1000,1 +1000,1 @@\n-    if (failtype != NULL) {\n+    if (failtype != nullptr) {\n@@ -1002,1 +1002,1 @@\n-      if (type2 != NULL) {\n+      if (type2 != nullptr) {\n@@ -1013,2 +1013,2 @@\n-    lo = NULL;\n-    hi = NULL;\n+    lo = nullptr;\n+    hi = nullptr;\n@@ -1022,1 +1022,1 @@\n-    if (adjusted_lim == NULL) {\n+    if (adjusted_lim == nullptr) {\n@@ -1097,2 +1097,2 @@\n-  Node* l = NULL;\n-  Node* r = NULL;\n+  Node* l = nullptr;\n+  Node* r = nullptr;\n@@ -1100,1 +1100,1 @@\n-  if (success->in(0)->as_If()->range_check_trap_proj(flip_test, l, r) != NULL) {\n+  if (success->in(0)->as_If()->range_check_trap_proj(flip_test, l, r) != nullptr) {\n@@ -1155,1 +1155,1 @@\n-        for (int i = 0; i < 10 && ctrl != NULL && ctrl != fail; i++) {\n+        for (int i = 0; i < 10 && ctrl != nullptr && ctrl != fail; i++) {\n@@ -1185,1 +1185,1 @@\n-      } else if (use->in(0) == NULL && (igvn->type(use)->isa_long() ||\n+      } else if (use->in(0) == nullptr && (igvn->type(use)->isa_long() ||\n@@ -1200,3 +1200,3 @@\n-  if (in(1) != NULL &&\n-      in(1)->in(1) != NULL &&\n-      in(1)->in(1)->in(2) != NULL) {\n+  if (in(1) != nullptr &&\n+      in(1)->in(1) != nullptr &&\n+      in(1)->in(1)->in(2) != nullptr) {\n@@ -1205,3 +1205,3 @@\n-        ((other->in(0) != NULL && other->in(0) == proj) ||\n-         (other->in(0) == NULL &&\n-          other->in(2) != NULL &&\n+        ((other->in(0) != nullptr && other->in(0) == proj) ||\n+         (other->in(0) == nullptr &&\n+          other->in(2) != nullptr &&\n@@ -1209,1 +1209,1 @@\n-          other->in(2)->in(1) != NULL &&\n+          other->in(2)->in(1) != nullptr &&\n@@ -1220,2 +1220,2 @@\n-  if (other->in(MemNode::Address) != NULL &&\n-      proj->in(0)->in(1) != NULL &&\n+  if (other->in(MemNode::Address) != nullptr &&\n+      proj->in(0)->in(1) != nullptr &&\n@@ -1223,1 +1223,1 @@\n-      proj->in(0)->in(1)->in(1) != NULL &&\n+      proj->in(0)->in(1)->in(1) != nullptr &&\n@@ -1225,1 +1225,1 @@\n-      proj->in(0)->in(1)->in(1)->in(2) != NULL &&\n+      proj->in(0)->in(1)->in(1)->in(2) != nullptr &&\n@@ -1236,1 +1236,1 @@\n-  if (proj == NULL) {\n+  if (proj == nullptr) {\n@@ -1240,1 +1240,1 @@\n-  if (unc != NULL && proj->outcnt() <= 2) {\n+  if (unc != nullptr && proj->outcnt() <= 2) {\n@@ -1246,1 +1246,1 @@\n-      assert(dom_unc != NULL, \"is_uncommon_trap_if_pattern returned NULL\");\n+      assert(dom_unc != nullptr, \"is_uncommon_trap_if_pattern returned null\");\n@@ -1301,1 +1301,1 @@\n-  if (Opcode() != Op_If) return NULL;\n+  if (Opcode() != Op_If) return nullptr;\n@@ -1308,2 +1308,2 @@\n-      ProjNode* success = NULL;\n-      ProjNode* fail = NULL;\n+      ProjNode* success = nullptr;\n+      ProjNode* fail = nullptr;\n@@ -1321,5 +1321,5 @@\n-      return NULL;\n-    } else if (ctrl->in(0) != NULL &&\n-               ctrl->in(0)->in(0) != NULL) {\n-      ProjNode* success = NULL;\n-      ProjNode* fail = NULL;\n+      return nullptr;\n+    } else if (ctrl->in(0) != nullptr &&\n+               ctrl->in(0)->in(0) != nullptr) {\n+      ProjNode* success = nullptr;\n+      ProjNode* fail = nullptr;\n@@ -1342,1 +1342,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1351,1 +1351,1 @@\n-  if( !i1->is_Bool() ) return NULL;\n+  if( !i1->is_Bool() ) return nullptr;\n@@ -1355,1 +1355,1 @@\n-  if( cmp->Opcode() != Op_CmpI ) return NULL;\n+  if( cmp->Opcode() != Op_CmpI ) return nullptr;\n@@ -1361,1 +1361,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1365,1 +1365,1 @@\n-  if( !i1->is_Phi() ) return NULL;\n+  if( !i1->is_Phi() ) return nullptr;\n@@ -1368,1 +1368,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1372,1 +1372,1 @@\n-  if( true_path == 0 ) return NULL;\n+  if( true_path == 0 ) return nullptr;\n@@ -1377,1 +1377,1 @@\n-  if (phi->in(0)->in(1)->in(0) == iff) return NULL;\n+  if (phi->in(0)->in(1)->in(0) == iff) return nullptr;\n@@ -1386,1 +1386,1 @@\n-  else if( bol->_test._test != BoolTest::eq ) return NULL;\n+  else if( bol->_test._test != BoolTest::eq ) return nullptr;\n@@ -1393,1 +1393,1 @@\n-    if( phi2_t != TypeInt::ONE ) return NULL;\n+    if( phi2_t != TypeInt::ONE ) return nullptr;\n@@ -1397,2 +1397,2 @@\n-    if( phi1_t != TypeInt::ONE  ) return NULL;\n-    if( phi2_t != TypeInt::ZERO ) return NULL;\n+    if( phi1_t != TypeInt::ONE  ) return nullptr;\n+    if( phi2_t != TypeInt::ZERO ) return nullptr;\n@@ -1422,1 +1422,1 @@\n-  if (!can_reshape)  return NULL;\n+  if (!can_reshape)  return nullptr;\n@@ -1425,1 +1425,1 @@\n-  if (in(0)->is_top())  return NULL;\n+  if (in(0)->is_top())  return nullptr;\n@@ -1427,1 +1427,1 @@\n-  if (in(1)->is_top())  return NULL;\n+  if (in(1)->is_top())  return nullptr;\n@@ -1429,1 +1429,1 @@\n-  if (in(1)->is_Con())  return NULL;\n+  if (in(1)->is_Con())  return nullptr;\n@@ -1431,1 +1431,1 @@\n-  if (outcnt() < 2)  return NULL;\n+  if (outcnt() < 2)  return nullptr;\n@@ -1435,1 +1435,1 @@\n-  if (idt_if != NULL)  return idt_if;\n+  if (idt_if != nullptr)  return idt_if;\n@@ -1440,1 +1440,1 @@\n-  if (s != NULL)  return s;\n+  if (s != nullptr)  return s;\n@@ -1460,1 +1460,1 @@\n-  if (in(0) == NULL) return NULL;     \/\/ Dead loop?\n+  if (in(0) == nullptr) return nullptr;     \/\/ Dead loop?\n@@ -1464,1 +1464,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1473,1 +1473,1 @@\n-        cmp->in(2) != NULL && \/\/ make sure cmp is not already dead\n+        cmp->in(2) != nullptr && \/\/ make sure cmp is not already dead\n@@ -1481,1 +1481,1 @@\n-  if (prev_dom != NULL) {\n+  if (prev_dom != nullptr) {\n@@ -1507,2 +1507,2 @@\n-  if (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||\n-      unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL) {\n+  if (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n+      unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr) {\n@@ -1563,1 +1563,1 @@\n-    if (dist < 0) return NULL;\n+    if (dist < 0) return nullptr;\n@@ -1568,1 +1568,1 @@\n-    if (!dom) return NULL;\n+    if (!dom) return nullptr;\n@@ -1573,1 +1573,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1577,1 +1577,1 @@\n-  if (dist > 2) { \/\/ Add to count of NULL checks elided\n+  if (dist > 2) { \/\/ Add to count of null checks elided\n@@ -1621,1 +1621,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1625,1 +1625,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1629,1 +1629,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1633,1 +1633,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1637,1 +1637,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1640,1 +1640,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1648,1 +1648,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1652,1 +1652,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1729,1 +1729,1 @@\n-      if (head != NULL && head->is_BaseCountedLoop() && head->in(LoopNode::LoopBackControl) == this) {\n+      if (head != nullptr && head->is_BaseCountedLoop() && head->in(LoopNode::LoopBackControl) == this) {\n@@ -1784,1 +1784,1 @@\n-  assert(iff->in(0) != NULL, \"If must be live\");\n+  assert(iff->in(0) != nullptr, \"If must be live\");\n@@ -1786,1 +1786,1 @@\n-  if (iff->outcnt() != 2)  return NULL; \/\/ Malformed projections.\n+  if (iff->outcnt() != 2)  return nullptr; \/\/ Malformed projections.\n@@ -1793,2 +1793,2 @@\n-  if (iff->is_BaseCountedLoopEnd())  return NULL;\n-  if (!iff->in(1)->is_Bool())  return NULL; \/\/ Happens for partially optimized IF tests\n+  if (iff->is_BaseCountedLoopEnd())  return nullptr;\n+  if (!iff->in(1)->is_Bool())  return nullptr; \/\/ Happens for partially optimized IF tests\n@@ -1799,1 +1799,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1804,1 +1804,1 @@\n-  if( !new_b->is_Bool() ) return NULL;\n+  if( !new_b->is_Bool() ) return nullptr;\n@@ -1878,1 +1878,1 @@\n-        if (dom == this) return NULL; \/\/ dead loop\n+        if (dom == this) return nullptr; \/\/ dead loop\n@@ -1915,1 +1915,1 @@\n-      if (!phase->C->allow_range_check_smearing())  return NULL;\n+      if (!phase->C->allow_range_check_smearing())  return nullptr;\n@@ -1919,1 +1919,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1926,1 +1926,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1947,1 +1947,1 @@\n-              return NULL;\n+              return nullptr;\n@@ -1994,2 +1994,2 @@\n-    if (prev_dom == NULL) {\n-      return NULL;\n+    if (prev_dom == nullptr) {\n+      return nullptr;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":164,"deletions":164,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  if (free_list == NULL) {\n+  if (free_list == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,1 @@\n-    compile->set_indexSet_free_block_list(NULL);\n+    compile->set_indexSet_free_block_list(nullptr);\n@@ -404,1 +404,1 @@\n-  \/\/ _set is NULL, we do no replacement.\n+  \/\/ _set is null, we do no replacement.\n@@ -421,1 +421,1 @@\n-    _words(NULL),\n+    _words(nullptr),\n@@ -438,1 +438,1 @@\n-    _words(NULL),\n+    _words(nullptr),\n@@ -440,1 +440,1 @@\n-    _set(NULL)\n+    _set(nullptr)\n","filename":"src\/hotspot\/share\/opto\/indexSet.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  if (in(0) && in(0)->is_top())  return NULL;\n+  if (in(0) && in(0)->is_top())  return nullptr;\n@@ -54,1 +54,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -70,1 +70,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -78,1 +78,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -92,1 +92,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-\/\/ i.e. will grab into the base of the heap if it represents NULL.\n+\/\/ i.e. will grab into the base of the heap if it represents null.\n@@ -45,1 +45,1 @@\n-  if (CompressedOops::base() != NULL) { \/\/ Implies UseCompressedOops.\n+  if (CompressedOops::base() != nullptr) { \/\/ Implies UseCompressedOops.\n@@ -49,1 +49,1 @@\n-        \/\/ decode NULL to point to the heap base (Decode_NN).\n+        \/\/ decode null to point to the heap base (Decode_NN).\n@@ -80,2 +80,2 @@\n-\/\/ Detect implicit-null-check opportunities.  Basically, find NULL checks\n-\/\/ with suitable memory ops nearby.  Use the memory op to do the NULL check.\n+\/\/ Detect implicit-null-check opportunities.  Basically, find null checks\n+\/\/ with suitable memory ops nearby.  Use the memory op to do the null check.\n@@ -152,1 +152,1 @@\n-  assert(!is_decoden || (val->in(0) == NULL) && val->is_Mach() &&\n+  assert(!is_decoden || (val->in(0) == nullptr) && val->is_Mach() &&\n@@ -157,1 +157,1 @@\n-  MachNode *best = NULL;        \/\/ Best found so far\n+  MachNode *best = nullptr;        \/\/ Best found so far\n@@ -225,1 +225,1 @@\n-        if (oper == NULL || oper == (MachOper*)-1) {\n+        if (oper == nullptr || oper == (MachOper*)-1) {\n@@ -248,1 +248,1 @@\n-    if (ctrl != NULL && !(ctrl == not_null_block->head() ||\n+    if (ctrl != nullptr && !(ctrl == not_null_block->head() ||\n@@ -256,1 +256,1 @@\n-      const TypePtr *adr_type = NULL;  \/\/ Do not need this return value here\n+      const TypePtr *adr_type = nullptr;  \/\/ Do not need this return value here\n@@ -258,1 +258,1 @@\n-      if (base == NULL || base == NodeSentinel) {\n+      if (base == nullptr || base == NodeSentinel) {\n@@ -353,1 +353,1 @@\n-      continue;                 \/\/ Already being used as a NULL check\n+      continue;                 \/\/ Already being used as a null check\n@@ -357,1 +357,1 @@\n-    if (best == NULL || get_block_for_node(mach)->_dom_depth < get_block_for_node(best)->_dom_depth) {\n+    if (best == nullptr || get_block_for_node(mach)->_dom_depth < get_block_for_node(best)->_dom_depth) {\n@@ -363,1 +363,1 @@\n-  if (best == NULL) {\n+  if (best == nullptr) {\n@@ -414,1 +414,1 @@\n-  \/\/ Don't change it in other cases: NULL or dominating control.\n+  \/\/ Don't change it in other cases: null or dominating control.\n@@ -416,1 +416,1 @@\n-  if (ctrl != NULL && get_block_for_node(ctrl) == not_null_block) {\n+  if (ctrl != nullptr && get_block_for_node(ctrl) == not_null_block) {\n@@ -434,4 +434,4 @@\n-  \/\/   (IfTrue  (If (Bool NE (CmpP ptr NULL))))\n-  \/\/   (IfFalse (If (Bool EQ (CmpP ptr NULL))))\n-  \/\/ NULL checks are always branch-if-eq.  If we see a IfTrue projection\n-  \/\/ then we are replacing a 'ne' test with a 'eq' NULL check test.\n+  \/\/   (IfTrue  (If (Bool NE (CmpP ptr null))))\n+  \/\/   (IfFalse (If (Bool EQ (CmpP ptr null))))\n+  \/\/ null checks are always branch-if-eq.  If we see a IfTrue projection\n+  \/\/ then we are replacing a 'ne' test with a 'eq' null check test.\n@@ -445,1 +445,1 @@\n-    Node *tmp = new Node(C->top()); \/\/ Use not NULL input\n+    Node *tmp = new Node(C->top()); \/\/ Use not null input\n@@ -449,1 +449,1 @@\n-    tmp->destruct(NULL);\n+    tmp->destruct(nullptr);\n@@ -465,1 +465,1 @@\n-    old_tst->set_req(i3, NULL);\n+    old_tst->set_req(i3, nullptr);\n@@ -524,1 +524,1 @@\n-  bool block_size_threshold_ok = (recalc_pressure_nodes != NULL) && (block->number_of_nodes() > 10);\n+  bool block_size_threshold_ok = (recalc_pressure_nodes != nullptr) && (block->number_of_nodes() > 10);\n@@ -694,1 +694,1 @@\n-    if (src_n == NULL) continue;\n+    if (src_n == nullptr) continue;\n@@ -753,1 +753,1 @@\n-        _regalloc->lower_pressure(block, 0, lrg_src, NULL, _regalloc->_sched_int_pressure, _regalloc->_sched_float_pressure);\n+        _regalloc->lower_pressure(block, 0, lrg_src, nullptr, _regalloc->_sched_int_pressure, _regalloc->_sched_float_pressure);\n@@ -755,1 +755,1 @@\n-        _regalloc->lower_pressure(block, 0, lrg_src, NULL, _regalloc->_scratch_int_pressure, _regalloc->_scratch_float_pressure);\n+        _regalloc->lower_pressure(block, 0, lrg_src, nullptr, _regalloc->_scratch_int_pressure, _regalloc->_scratch_float_pressure);\n@@ -803,1 +803,1 @@\n-  Node* call = NULL;\n+  Node* call = nullptr;\n@@ -813,1 +813,1 @@\n-  if (call == NULL)  return;    \/\/ No next call (e.g., block end is near)\n+  if (call == nullptr)  return;    \/\/ No next call (e.g., block end is near)\n@@ -884,1 +884,1 @@\n-  const char *save_policy = NULL;\n+  const char *save_policy = nullptr;\n@@ -967,1 +967,1 @@\n-  bool block_size_threshold_ok = (recalc_pressure_nodes != NULL) && (block->number_of_nodes() > 10);\n+  bool block_size_threshold_ok = (recalc_pressure_nodes != nullptr) && (block->number_of_nodes() > 10);\n@@ -1013,1 +1013,1 @@\n-            if (oop_store != NULL) {\n+            if (oop_store != nullptr) {\n@@ -1033,1 +1033,1 @@\n-        if (x != NULL && get_block_for_node(x) == block && n->find_prec_edge(x) != -1) {\n+        if (x != nullptr && get_block_for_node(x) == block && n->find_prec_edge(x) != -1) {\n@@ -1271,1 +1271,1 @@\n-  Node *fixup = NULL;\n+  Node *fixup = nullptr;\n@@ -1296,1 +1296,1 @@\n-          fixup = NULL;\n+          fixup = nullptr;\n@@ -1303,1 +1303,1 @@\n-    if (fixup == NULL) {\n+    if (fixup == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -83,1 +83,1 @@\n-    is_available = compiler != NULL && compiler->is_intrinsic_supported(mh, is_virtual) &&\n+    is_available = compiler != nullptr && compiler->is_intrinsic_supported(mh, is_virtual) &&\n@@ -97,1 +97,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -170,1 +170,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -204,1 +204,1 @@\n-    return slow_ctl; \/\/ Could be NULL if the check folds.\n+    return slow_ctl; \/\/ Could be null if the check folds.\n@@ -229,1 +229,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -750,2 +750,2 @@\n-\/\/ or NULL if it is obvious that the slow path can never be taken.\n-\/\/ Also, if region and the slow control are not NULL, the slow edge\n+\/\/ or null if it is obvious that the slow path can never be taken.\n+\/\/ Also, if region and the slow control are not null, the slow edge\n@@ -756,1 +756,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -763,1 +763,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -771,1 +771,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -774,1 +774,1 @@\n-  if (region != NULL)\n+  if (region != nullptr)\n@@ -793,1 +793,1 @@\n-    return NULL;                \/\/ already stopped\n+    return nullptr;                \/\/ already stopped\n@@ -795,1 +795,1 @@\n-    return NULL;                \/\/ index is already adequately typed\n+    return nullptr;                \/\/ index is already adequately typed\n@@ -799,1 +799,1 @@\n-  if (is_neg != NULL && pos_index != NULL) {\n+  if (is_neg != nullptr && pos_index != nullptr) {\n@@ -827,1 +827,1 @@\n-    return NULL;                \/\/ already stopped\n+    return nullptr;                \/\/ already stopped\n@@ -830,1 +830,1 @@\n-    return NULL;                \/\/ common case of whole-array copy\n+    return nullptr;                \/\/ common case of whole-array copy\n@@ -873,1 +873,1 @@\n-  Node* thread_obj_handle = LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(), TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  Node* thread_obj_handle = LoadNode::make(_gvn, nullptr, immutable_memory(), p, p->bottom_type()->is_ptr(), TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n@@ -885,1 +885,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -903,1 +903,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -959,2 +959,2 @@\n-    Node* if_ne = generate_slow_guard(bol, NULL);\n-    if (if_ne != NULL) {\n+    Node* if_ne = generate_slow_guard(bol, nullptr);\n+    if (if_ne != nullptr) {\n@@ -1112,1 +1112,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1158,1 +1158,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1164,2 +1164,2 @@\n-    Node* if_lt = generate_slow_guard(bol, NULL);\n-    if (if_lt != NULL) {\n+    Node* if_lt = generate_slow_guard(bol, nullptr);\n+    if (if_lt != nullptr) {\n@@ -1191,2 +1191,2 @@\n-  Node* if_gt = generate_slow_guard(bol, NULL);\n-  if (if_gt != NULL) {\n+  Node* if_gt = generate_slow_guard(bol, nullptr);\n+  if (if_gt != nullptr) {\n@@ -1200,2 +1200,2 @@\n-    Node* if_zero = generate_slow_guard(bol, NULL);\n-    if (if_zero != NULL) {\n+    Node* if_zero = generate_slow_guard(bol, nullptr);\n+    if (if_zero != nullptr) {\n@@ -1209,1 +1209,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1248,2 +1248,2 @@\n-  Node* if_lt = generate_slow_guard(bol, NULL);\n-  if (if_lt != NULL) {\n+  Node* if_lt = generate_slow_guard(bol, nullptr);\n+  if (if_lt != nullptr) {\n@@ -1321,1 +1321,1 @@\n-  Node* count = NULL;\n+  Node* count = nullptr;\n@@ -1328,1 +1328,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -1371,1 +1371,1 @@\n-  Node* newcopy = NULL;\n+  Node* newcopy = nullptr;\n@@ -1405,1 +1405,1 @@\n-    guarantee(alloc != NULL, \"created above\");\n+    guarantee(alloc != nullptr, \"created above\");\n@@ -1505,1 +1505,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -1538,1 +1538,1 @@\n-  Node* ch = is_store ? argument(2) : NULL;\n+  Node* ch = is_store ? argument(2) : nullptr;\n@@ -1582,1 +1582,1 @@\n-      n = _gvn.transform(new RoundDoubleNode(NULL, n));\n+      n = _gvn.transform(new RoundDoubleNode(nullptr, n));\n@@ -1598,1 +1598,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -1619,1 +1619,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -1639,1 +1639,1 @@\n-  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;\n+  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : nullptr;\n@@ -1641,1 +1641,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -1644,1 +1644,1 @@\n-                                 a, top(), b, b ? top() : NULL);\n+                                 a, top(), b, b ? top() : nullptr);\n@@ -1659,1 +1659,1 @@\n-  if (d != NULL) {\n+  if (d != nullptr) {\n@@ -1679,1 +1679,1 @@\n-      Node* if_pow = generate_slow_guard(test, NULL);\n+      Node* if_pow = generate_slow_guard(test, nullptr);\n@@ -1684,1 +1684,1 @@\n-      if (if_pow != NULL) {\n+      if (if_pow != nullptr) {\n@@ -1686,1 +1686,1 @@\n-        address target = StubRoutines::dpow() != NULL ? StubRoutines::dpow() :\n+        address target = StubRoutines::dpow() != nullptr ? StubRoutines::dpow() :\n@@ -1688,1 +1688,1 @@\n-        const TypePtr* no_memory_effects = NULL;\n+        const TypePtr* no_memory_effects = nullptr;\n@@ -1709,1 +1709,1 @@\n-  return StubRoutines::dpow() != NULL ?\n+  return StubRoutines::dpow() != nullptr ?\n@@ -1720,1 +1720,1 @@\n-    return StubRoutines::dsin() != NULL ?\n+    return StubRoutines::dsin() != nullptr ?\n@@ -1724,1 +1724,1 @@\n-    return StubRoutines::dcos() != NULL ?\n+    return StubRoutines::dcos() != nullptr ?\n@@ -1728,1 +1728,1 @@\n-    return StubRoutines::dtan() != NULL ?\n+    return StubRoutines::dtan() != nullptr ?\n@@ -1732,1 +1732,1 @@\n-    return StubRoutines::dlog() != NULL ?\n+    return StubRoutines::dlog() != nullptr ?\n@@ -1736,1 +1736,1 @@\n-    return StubRoutines::dlog10() != NULL ?\n+    return StubRoutines::dlog10() != nullptr ?\n@@ -1751,1 +1751,1 @@\n-    return StubRoutines::dexp() != NULL ?\n+    return StubRoutines::dexp() != nullptr ?\n@@ -1789,1 +1789,1 @@\n-  Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, NULL, TypeRawPtr::BOTTOM, argument(0));\n+  Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, nullptr, TypeRawPtr::BOTTOM, argument(0));\n@@ -1885,1 +1885,1 @@\n-  if (txvalue == NULL || tyvalue == NULL)  return top();\n+  if (txvalue == nullptr || tyvalue == nullptr)  return top();\n@@ -1913,2 +1913,2 @@\n-  Node* cmpxy = NULL;\n-  Node* cmpyx = NULL;\n+  Node* cmpxy = nullptr;\n+  Node* cmpyx = nullptr;\n@@ -1918,1 +1918,1 @@\n-        cmp->in(0) == NULL &&           \/\/ must be context-independent\n+        cmp->in(0) == nullptr &&           \/\/ must be context-independent\n@@ -1929,1 +1929,1 @@\n-    if (cmps[cmpn] != NULL)  break;     \/\/ find a result\n+    if (cmps[cmpn] != nullptr)  break;     \/\/ find a result\n@@ -1935,1 +1935,1 @@\n-    for (; dom != NULL; dom = IfNode::up_one_dom(dom, true)) {\n+    for (; dom != nullptr; dom = IfNode::up_one_dom(dom, true)) {\n@@ -1944,1 +1944,1 @@\n-      if (cmp == NULL)  continue;\n+      if (cmp == nullptr)  continue;\n@@ -1973,1 +1973,1 @@\n-  Node*          best_bol   = NULL;\n+  Node*          best_bol   = nullptr;\n@@ -1977,1 +1977,1 @@\n-    if (cmp == NULL)  continue;\n+    if (cmp == nullptr)  continue;\n@@ -1984,1 +1984,1 @@\n-      if (bol->outcnt() > (best_bol == NULL ? 0 : best_bol->outcnt())) {\n+      if (bol->outcnt() > (best_bol == nullptr ? 0 : best_bol->outcnt())) {\n@@ -1991,2 +1991,2 @@\n-  Node* answer_if_true  = NULL;\n-  Node* answer_if_false = NULL;\n+  Node* answer_if_true  = nullptr;\n+  Node* answer_if_false = nullptr;\n@@ -1995,1 +1995,1 @@\n-    if (cmpxy == NULL)\n+    if (cmpxy == nullptr)\n@@ -2026,1 +2026,1 @@\n-  Node* cmov = CMoveNode::make(NULL, best_bol,\n+  Node* cmov = CMoveNode::make(nullptr, best_bol,\n@@ -2051,2 +2051,2 @@\n-  if (base != NULL)  base_type = _gvn.type(base)->isa_ptr();\n-  if (base_type == NULL) {\n+  if (base != nullptr)  base_type = _gvn.type(base)->isa_ptr();\n+  if (base_type == nullptr) {\n@@ -2056,1 +2056,1 @@\n-    \/\/ Since this is a NULL+long form, we have to switch to a rawptr.\n+    \/\/ Since this is a null+long form, we have to switch to a rawptr.\n@@ -2069,1 +2069,1 @@\n-    if (offset_type != NULL &&\n+    if (offset_type != nullptr &&\n@@ -2079,1 +2079,1 @@\n-    \/\/ Otherwise, it might either be oop+off or NULL+addr.\n+    \/\/ Otherwise, it might either be oop+off or null+addr.\n@@ -2144,1 +2144,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -2166,1 +2166,1 @@\n-  ciKlass* sharpened_klass = NULL;\n+  ciKlass* sharpened_klass = nullptr;\n@@ -2169,1 +2169,1 @@\n-  if (alias_type->field() != NULL) {\n+  if (alias_type->field() != nullptr) {\n@@ -2179,1 +2179,1 @@\n-      if (elem_type != NULL) {\n+      if (elem_type != nullptr) {\n@@ -2187,1 +2187,1 @@\n-  if (sharpened_klass != NULL && sharpened_klass->is_loaded()) {\n+  if (sharpened_klass != nullptr && sharpened_klass->is_loaded()) {\n@@ -2199,1 +2199,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2298,1 +2298,1 @@\n-  \/\/ Can base be NULL? Otherwise, always on-heap access.\n+  \/\/ Can base be null? Otherwise, always on-heap access.\n@@ -2305,1 +2305,1 @@\n-  Node* val = is_store ? argument(4) : NULL;\n+  Node* val = is_store ? argument(4) : nullptr;\n@@ -2364,1 +2364,1 @@\n-    if (tjp != NULL) {\n+    if (tjp != nullptr) {\n@@ -2379,1 +2379,1 @@\n-    Node* p = NULL;\n+    Node* p = nullptr;\n@@ -2382,1 +2382,1 @@\n-    if (heap_base_oop != top() && field != NULL && field->is_constant() && !mismatched) {\n+    if (heap_base_oop != top() && field != nullptr && field->is_constant() && !mismatched) {\n@@ -2387,1 +2387,1 @@\n-    if (p == NULL) { \/\/ Could not constant fold the load\n+    if (p == nullptr) { \/\/ Could not constant fold the load\n@@ -2392,2 +2392,2 @@\n-           heap_base_oop == top() ||                  \/\/ - heap_base_oop is NULL or\n-           (can_access_non_heap && field == NULL))    \/\/ - heap_base_oop is potentially NULL\n+           heap_base_oop == top() ||                  \/\/ - heap_base_oop is null or\n+           (can_access_non_heap && field == nullptr)) \/\/ - heap_base_oop is potentially null\n@@ -2412,1 +2412,1 @@\n-      p = gvn().transform(new CastP2XNode(NULL, p));\n+      p = gvn().transform(new CastP2XNode(nullptr, p));\n@@ -2547,5 +2547,5 @@\n-  Node* receiver = NULL;\n-  Node* base     = NULL;\n-  Node* offset   = NULL;\n-  Node* oldval   = NULL;\n-  Node* newval   = NULL;\n+  Node* receiver = nullptr;\n+  Node* base     = nullptr;\n+  Node* offset   = nullptr;\n+  Node* oldval   = nullptr;\n+  Node* newval   = nullptr;\n@@ -2569,1 +2569,1 @@\n-      oldval   = NULL;\n+      oldval   = nullptr;\n@@ -2612,1 +2612,1 @@\n-        if (tjp != NULL) {\n+        if (tjp != nullptr) {\n@@ -2637,1 +2637,1 @@\n-    \/\/ Transformation of a value which could be NULL pointer (CastPP #NULL)\n+    \/\/ Transformation of a value which could be null pointer (CastPP #null)\n@@ -2643,1 +2643,1 @@\n-    if (oldval != NULL && _gvn.type(oldval) == TypePtr::NULL_PTR) {\n+    if (oldval != nullptr && _gvn.type(oldval) == TypePtr::NULL_PTR) {\n@@ -2649,1 +2649,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -2712,1 +2712,1 @@\n-  if (klsptr == NULL) {\n+  if (klsptr == nullptr) {\n@@ -2778,1 +2778,1 @@\n-  Node* kls = load_klass_from_mirror(cls, false, NULL, 0);\n+  Node* kls = load_klass_from_mirror(cls, false, nullptr, 0);\n@@ -2782,1 +2782,1 @@\n-  Node* test = NULL;\n+  Node* test = nullptr;\n@@ -2790,1 +2790,1 @@\n-    Node* inst = make_load(NULL, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n+    Node* inst = make_load(nullptr, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n@@ -2806,1 +2806,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -2842,1 +2842,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n@@ -2872,1 +2872,1 @@\n-    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n@@ -2939,1 +2939,1 @@\n-  Node* junk = NULL;\n+  Node* junk = nullptr;\n@@ -2948,1 +2948,1 @@\n-  Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  Node* load = make_load(nullptr, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n@@ -2959,1 +2959,1 @@\n-\/\/ If the region is NULL, force never_see_null = true.\n+\/\/ If the region is nullptr, force never_see_null = true.\n@@ -2965,1 +2965,1 @@\n-  if (region == NULL)  never_see_null = true;\n+  if (region == nullptr)  never_see_null = true;\n@@ -2968,1 +2968,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n@@ -2971,1 +2971,1 @@\n-  if (region != NULL) {\n+  if (region != nullptr) {\n@@ -2987,1 +2987,1 @@\n-  Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* mods = make_load(nullptr, modp, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3053,1 +3053,1 @@\n-  if (mirror_con == NULL)  return false;  \/\/ cannot happen?\n+  if (mirror_con == nullptr)  return false;  \/\/ cannot happen?\n@@ -3106,1 +3106,1 @@\n-    query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3111,1 +3111,1 @@\n-    if (generate_interface_guard(kls, region) != NULL)\n+    if (generate_interface_guard(kls, region) != nullptr)\n@@ -3120,1 +3120,1 @@\n-    if (generate_array_guard(kls, region) != NULL)\n+    if (generate_array_guard(kls, region) != nullptr)\n@@ -3133,1 +3133,1 @@\n-    if (generate_hidden_class_guard(kls, region) != NULL)\n+    if (generate_hidden_class_guard(kls, region) != nullptr)\n@@ -3148,1 +3148,1 @@\n-    if (generate_interface_guard(kls, region) != NULL)\n+    if (generate_interface_guard(kls, region) != nullptr)\n@@ -3151,1 +3151,1 @@\n-    if (generate_array_guard(kls, region) != NULL)\n+    if (generate_array_guard(kls, region) != nullptr)\n@@ -3156,1 +3156,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n@@ -3171,1 +3171,1 @@\n-    query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3193,1 +3193,1 @@\n-  if (mirror_con == NULL) {\n+  if (mirror_con == nullptr) {\n@@ -3196,1 +3196,1 @@\n-  if (obj == NULL || obj->is_top()) {\n+  if (obj == nullptr || obj->is_top()) {\n@@ -3204,2 +3204,2 @@\n-  if (tm != NULL && tm->is_klass() &&\n-      tp != NULL && tp->klass() != NULL) {\n+  if (tm != nullptr && tm->is_klass() &&\n+      tp != nullptr && tp->klass() != nullptr) {\n@@ -3239,1 +3239,1 @@\n-  \/\/ Not-subtype or the mirror's klass ptr is NULL (in case it is a primitive).\n+  \/\/ Not-subtype or the mirror's klass ptr is null (in case it is a primitive).\n@@ -3310,1 +3310,1 @@\n-    Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);\n+    Node* kls = LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, adr_type, kls_type);\n@@ -3360,1 +3360,1 @@\n-    if (ctl == NULL || ctl == top()) {\n+    if (ctl == nullptr || ctl == top()) {\n@@ -3363,1 +3363,1 @@\n-    } else if (phi->in(i) == NULL) {\n+    } else if (phi->in(i) == nullptr) {\n@@ -3378,1 +3378,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3393,1 +3393,1 @@\n-  if (layout_val == NULL) {\n+  if (layout_val == nullptr) {\n@@ -3398,1 +3398,1 @@\n-      return NULL;                       \/\/ never a branch\n+      return nullptr;                       \/\/ never a branch\n@@ -3401,1 +3401,1 @@\n-      if (region != NULL)\n+      if (region != nullptr)\n@@ -3459,1 +3459,1 @@\n-    CallJavaNode* slow_call = NULL;\n+    CallJavaNode* slow_call = nullptr;\n@@ -3511,1 +3511,1 @@\n-  Node* non_array = generate_non_array_guard(load_object_klass(array), NULL);\n+  Node* non_array = generate_non_array_guard(load_object_klass(array), nullptr);\n@@ -3513,1 +3513,1 @@\n-  if (non_array != NULL) {\n+  if (non_array != nullptr) {\n@@ -3544,1 +3544,1 @@\n-  Node* newcopy = NULL;\n+  Node* newcopy = nullptr;\n@@ -3559,1 +3559,1 @@\n-    Node* klass_node = load_klass_from_mirror(array_type_mirror, false, NULL, 0);\n+    Node* klass_node = load_klass_from_mirror(array_type_mirror, false, nullptr, 0);\n@@ -3568,1 +3568,1 @@\n-    if (not_objArray != NULL) {\n+    if (not_objArray != nullptr) {\n@@ -3625,1 +3625,1 @@\n-          if (t_original->speculative_type() != NULL) {\n+          if (t_original->speculative_type() != nullptr) {\n@@ -3689,1 +3689,1 @@\n-  Node* target_call = make_load(NULL, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  Node* target_call = make_load(nullptr, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n@@ -3773,1 +3773,1 @@\n-  Node* obj = NULL;\n+  Node* obj = nullptr;\n@@ -3817,1 +3817,1 @@\n-  \/\/ The control of the load must be NULL. Otherwise, the load can move before\n+  \/\/ The control of the load must be null. Otherwise, the load can move before\n@@ -3819,1 +3819,1 @@\n-  Node* no_ctrl = NULL;\n+  Node* no_ctrl = nullptr;\n@@ -3926,1 +3926,1 @@\n-  for (int n = 1; caller_jvms != NULL; caller_jvms = caller_jvms->caller(), n++) {\n+  for (int n = 1; caller_jvms != nullptr; caller_jvms = caller_jvms->caller(), n++) {\n@@ -3983,1 +3983,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -4135,1 +4135,1 @@\n-  assert(obj_size != NULL, \"\");\n+  assert(obj_size != nullptr, \"\");\n@@ -4139,1 +4139,1 @@\n-  AllocateNode* alloc = NULL;\n+  AllocateNode* alloc = nullptr;\n@@ -4145,1 +4145,1 @@\n-    guarantee(alloc != NULL && alloc->maybe_set_complete(&_gvn), \"\");\n+    guarantee(alloc != nullptr && alloc->maybe_set_complete(&_gvn), \"\");\n@@ -4156,1 +4156,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -4205,1 +4205,1 @@\n-        obj_type->speculative_type() != NULL &&\n+        obj_type->speculative_type() != nullptr &&\n@@ -4238,2 +4238,2 @@\n-    Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);\n-    if (array_ctl != NULL) {\n+    Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)nullptr);\n+    if (array_ctl != nullptr) {\n@@ -4244,1 +4244,1 @@\n-      Node* obj_size  = NULL;\n+      Node* obj_size  = nullptr;\n@@ -4251,2 +4251,2 @@\n-        Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);\n-        if (is_obja != NULL) {\n+        Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)nullptr);\n+        if (is_obja != nullptr) {\n@@ -4318,1 +4318,1 @@\n-      Node* obj_size  = NULL;\n+      Node* obj_size  = nullptr;\n@@ -4322,1 +4322,1 @@\n-      Node* alloc_obj = new_instance(obj_klass, NULL, &obj_size, \/*deoptimize_on_exception=*\/true);\n+      Node* alloc_obj = new_instance(obj_klass, nullptr, &obj_size, \/*deoptimize_on_exception=*\/true);\n@@ -4366,1 +4366,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -4410,1 +4410,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4446,1 +4446,1 @@\n-  if (saved_jvms_before_guards != NULL && !stopped()) {\n+  if (saved_jvms_before_guards != nullptr && !stopped()) {\n@@ -4449,1 +4449,1 @@\n-    assert(alloc != NULL, \"only with a tightly coupled allocation\");\n+    assert(alloc != nullptr, \"only with a tightly coupled allocation\");\n@@ -4478,1 +4478,1 @@\n-    Node* prev_cast = NULL;\n+    Node* prev_cast = nullptr;\n@@ -4484,1 +4484,1 @@\n-        if (prev_cast == NULL) {\n+        if (prev_cast == nullptr) {\n@@ -4512,1 +4512,1 @@\n-    if (ary_type->isa_aryptr() && length_type != NULL) {\n+    if (ary_type->isa_aryptr() && length_type != nullptr) {\n@@ -4607,4 +4607,4 @@\n-  \/\/ if alloc == NULL we don't have to worry about a tightly coupled allocation so we can emit all needed guards\n-  \/\/ if saved_jvms_before_guards != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n-  \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we can't emit any guards\n-  bool can_emit_guards = (alloc == NULL || saved_jvms_before_guards != NULL);\n+  \/\/ if alloc == null we don't have to worry about a tightly coupled allocation so we can emit all needed guards\n+  \/\/ if saved_jvms_before_guards is not null (then alloc is not null) then we can handle guards and a tightly coupled allocation\n+  \/\/ if saved_jvms_before_guards is null and alloc is not null, we can't emit any guards\n+  bool can_emit_guards = (alloc == nullptr || saved_jvms_before_guards != nullptr);\n@@ -4626,1 +4626,1 @@\n-  src  = saved_jvms_before_guards != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n+  src  = saved_jvms_before_guards != nullptr ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n@@ -4631,1 +4631,1 @@\n-    \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we don't emit any\n+    \/\/ if saved_jvms_before_guards is null and alloc is not null, we don't emit any\n@@ -4649,1 +4649,1 @@\n-  bool has_src = (top_src != NULL && top_src->klass() != NULL);\n+  bool has_src = (top_src != nullptr && top_src->klass() != nullptr);\n@@ -4651,1 +4651,1 @@\n-  bool has_dest = (top_dest != NULL && top_dest->klass() != NULL);\n+  bool has_dest = (top_dest != nullptr && top_dest->klass() != nullptr);\n@@ -4667,1 +4667,1 @@\n-    ciKlass* src_k = NULL;\n+    ciKlass* src_k = nullptr;\n@@ -4670,1 +4670,1 @@\n-      if (src_k != NULL && src_k->is_array_klass()) {\n+      if (src_k != nullptr && src_k->is_array_klass()) {\n@@ -4675,1 +4675,1 @@\n-    ciKlass* dest_k = NULL;\n+    ciKlass* dest_k = nullptr;\n@@ -4678,1 +4678,1 @@\n-      if (dest_k != NULL && dest_k->is_array_klass()) {\n+      if (dest_k != nullptr && dest_k->is_array_klass()) {\n@@ -4689,1 +4689,1 @@\n-        has_src = (top_src != NULL && top_src->klass() != NULL);\n+        has_src = (top_src != nullptr && top_src->klass() != nullptr);\n@@ -4696,1 +4696,1 @@\n-        has_dest = (top_dest != NULL && top_dest->klass() != NULL);\n+        has_dest = (top_dest != nullptr && top_dest->klass() != nullptr);\n@@ -4721,1 +4721,1 @@\n-        if (src_k != NULL && src_k->is_array_klass()) {\n+        if (src_k != nullptr && src_k->is_array_klass()) {\n@@ -4727,1 +4727,1 @@\n-        if (dest_k != NULL && dest_k->is_array_klass()) {\n+        if (dest_k != nullptr && dest_k->is_array_klass()) {\n@@ -4745,1 +4745,1 @@\n-  if (saved_jvms_before_guards != NULL) {\n+  if (saved_jvms_before_guards != nullptr) {\n@@ -4824,1 +4824,1 @@\n-  ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,\n+  ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != nullptr, negative_length_guard_generated,\n@@ -4851,2 +4851,2 @@\n-  if (stopped())             return NULL;  \/\/ no fast path\n-  if (C->AliasLevel() == 0)  return NULL;  \/\/ no MergeMems around\n+  if (stopped())             return nullptr;  \/\/ no fast path\n+  if (C->AliasLevel() == 0)  return nullptr;  \/\/ no MergeMems around\n@@ -4855,1 +4855,1 @@\n-  if (alloc == NULL)  return NULL;\n+  if (alloc == nullptr)  return nullptr;\n@@ -4862,1 +4862,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4866,1 +4866,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4873,1 +4873,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -4935,2 +4935,2 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL ||\n-      top_dest == NULL || top_dest->klass() == NULL) {\n+  if (top_src  == nullptr || top_src->klass()  == nullptr ||\n+      top_dest == nullptr || top_dest->klass() == nullptr) {\n@@ -4969,1 +4969,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -4990,2 +4990,2 @@\n-  if (top_x  == NULL || top_x->klass()  == NULL ||\n-      top_y == NULL || top_y->klass() == NULL) {\n+  if (top_x  == nullptr || top_x->klass()  == nullptr ||\n+      top_y == nullptr || top_y->klass() == nullptr) {\n@@ -5079,1 +5079,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5098,2 +5098,2 @@\n-  if (top_x  == NULL || top_x->klass()  == NULL ||\n-      top_z  == NULL || top_z->klass()  == NULL) {\n+  if (top_x  == nullptr || top_x->klass()  == nullptr ||\n+      top_z  == nullptr || top_z->klass()  == nullptr) {\n@@ -5128,1 +5128,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5147,2 +5147,2 @@\n-  if (top_out  == NULL || top_out->klass()  == NULL ||\n-      top_in == NULL || top_in->klass() == NULL) {\n+  if (top_out  == nullptr || top_out->klass()  == nullptr ||\n+      top_in == nullptr || top_in->klass() == nullptr) {\n@@ -5176,1 +5176,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5200,4 +5200,4 @@\n-  if (top_a  == NULL || top_a->klass()  == NULL ||\n-      top_b == NULL || top_b->klass()  == NULL ||\n-      top_n == NULL || top_n->klass()  == NULL ||\n-      top_m == NULL || top_m->klass()  == NULL) {\n+  if (top_a  == nullptr || top_a->klass()  == nullptr ||\n+      top_b == nullptr || top_b->klass()  == nullptr ||\n+      top_n == nullptr || top_n->klass()  == nullptr ||\n+      top_m == nullptr || top_m->klass()  == nullptr) {\n@@ -5236,1 +5236,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5257,3 +5257,3 @@\n-  if (top_a  == NULL || top_a->klass()  == NULL ||\n-      top_n == NULL || top_n->klass()  == NULL ||\n-      top_m == NULL || top_m->klass()  == NULL) {\n+  if (top_a  == nullptr || top_a->klass()  == nullptr ||\n+      top_n == nullptr || top_n->klass()  == nullptr ||\n+      top_m == nullptr || top_m->klass()  == nullptr) {\n@@ -5289,2 +5289,2 @@\n-  address stubAddr = NULL;\n-  const char* stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char* stubName = nullptr;\n@@ -5293,1 +5293,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5311,2 +5311,2 @@\n-  if (top_newArr == NULL || top_newArr->klass() == NULL || top_oldArr == NULL\n-      || top_oldArr->klass() == NULL) {\n+  if (top_newArr == nullptr || top_newArr->klass() == nullptr || top_oldArr == nullptr\n+      || top_oldArr->klass() == nullptr) {\n@@ -5356,2 +5356,2 @@\n-  if (obja_t == NULL || obja_t->klass() == NULL ||\n-      objb_t == NULL || objb_t->klass() == NULL ||\n+  if (obja_t == nullptr || obja_t->klass() == nullptr ||\n+      objb_t == nullptr || objb_t->klass() == nullptr ||\n@@ -5425,1 +5425,1 @@\n-      call_stub_path = generate_guard(bol_gt, NULL, PROB_MIN);\n+      call_stub_path = generate_guard(bol_gt, nullptr, PROB_MIN);\n@@ -5450,1 +5450,1 @@\n-  if (call_stub_path != NULL) {\n+  if (call_stub_path != nullptr) {\n@@ -5524,1 +5524,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == nullptr || top_src->klass()  == nullptr) {\n@@ -5588,2 +5588,2 @@\n-  Node* table = load_field_from_object(NULL, \"byteTable\", \"[I\", \/*decorators*\/ IN_HEAP, \/*is_static*\/ true, crc32c_class);\n-  assert (table != NULL, \"wrong version of java.util.zip.CRC32C\");\n+  Node* table = load_field_from_object(nullptr, \"byteTable\", \"[I\", \/*decorators*\/ IN_HEAP, \/*is_static*\/ true, crc32c_class);\n+  assert (table != nullptr, \"wrong version of java.util.zip.CRC32C\");\n@@ -5613,1 +5613,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == nullptr || top_src->klass()  == nullptr) {\n@@ -5706,1 +5706,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == nullptr || top_src->klass()  == nullptr) {\n@@ -5781,2 +5781,2 @@\n-                                        decorators, \/*is_static*\/ false, NULL);\n-  if (result == NULL) return false;\n+                                        decorators, \/*is_static*\/ false, nullptr);\n+  if (result == nullptr) return false;\n@@ -5804,2 +5804,2 @@\n-                                          decorators, \/*is_static*\/ false, NULL);\n-  if (referent == NULL) return false;\n+                                          decorators, \/*is_static*\/ false, nullptr);\n+  if (referent == nullptr) return false;\n@@ -5835,2 +5835,2 @@\n-                                             ciInstanceKlass* fromKls = NULL) {\n-  if (fromKls == NULL) {\n+                                             ciInstanceKlass* fromKls = nullptr) {\n+  if (fromKls == nullptr) {\n@@ -5838,1 +5838,1 @@\n-    assert(tinst != NULL, \"obj is null\");\n+    assert(tinst != nullptr, \"obj is null\");\n@@ -5848,2 +5848,2 @@\n-  assert (field != NULL, \"undefined field\");\n-  if (field == NULL) return (Node *) NULL;\n+  assert (field != nullptr, \"undefined field\");\n+  if (field == nullptr) return (Node *) nullptr;\n@@ -5884,2 +5884,2 @@\n-                                                 ciInstanceKlass * fromKls = NULL) {\n-  if (fromKls == NULL) {\n+                                                 ciInstanceKlass * fromKls = nullptr) {\n+  if (fromKls == nullptr) {\n@@ -5887,1 +5887,1 @@\n-    assert(tinst != NULL, \"obj is null\");\n+    assert(tinst != nullptr, \"obj is null\");\n@@ -5899,1 +5899,1 @@\n-  assert(field != NULL, \"undefined field\");\n+  assert(field != nullptr, \"undefined field\");\n@@ -5918,1 +5918,1 @@\n-  address stubAddr = NULL;\n+  address stubAddr = nullptr;\n@@ -5934,1 +5934,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -5950,1 +5950,1 @@\n-  assert (top_src  != NULL && top_src->klass()  != NULL &&  top_dest != NULL && top_dest->klass() != NULL, \"args are strange\");\n+  assert (top_src  != nullptr && top_src->klass()  != nullptr &&  top_dest != nullptr && top_dest->klass() != nullptr, \"args are strange\");\n@@ -5956,2 +5956,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -5965,1 +5965,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -5977,2 +5977,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -5994,1 +5994,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -6011,2 +6011,2 @@\n-  assert (top_src  != NULL && top_src->klass()  != NULL\n-          &&  top_dest != NULL && top_dest->klass() != NULL, \"args are strange\");\n+  assert (top_src  != nullptr && top_src->klass()  != nullptr\n+          &&  top_dest != nullptr && top_dest->klass() != nullptr, \"args are strange\");\n@@ -6017,2 +6017,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -6029,1 +6029,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -6033,1 +6033,1 @@\n-  assert(tinst != NULL, \"CBC obj is null\");\n+  assert(tinst != nullptr, \"CBC obj is null\");\n@@ -6046,1 +6046,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -6050,1 +6050,1 @@\n-  if (objRvec == NULL) return false;\n+  if (objRvec == nullptr) return false;\n@@ -6067,2 +6067,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -6085,1 +6085,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -6099,2 +6099,2 @@\n-  assert(top_src != NULL && top_src->klass() != NULL\n-         &&  top_dest != NULL && top_dest->klass() != NULL, \"args are strange\");\n+  assert(top_src != nullptr && top_src->klass() != nullptr\n+         &&  top_dest != nullptr && top_dest->klass() != nullptr, \"args are strange\");\n@@ -6105,2 +6105,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -6117,1 +6117,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -6121,1 +6121,1 @@\n-  assert(tinst != NULL, \"ECB obj is null\");\n+  assert(tinst != nullptr, \"ECB obj is null\");\n@@ -6134,1 +6134,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -6153,2 +6153,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -6159,1 +6159,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -6173,2 +6173,2 @@\n-  assert(top_src != NULL && top_src->klass() != NULL &&\n-         top_dest != NULL && top_dest->klass() != NULL, \"args are strange\");\n+  assert(top_src != nullptr && top_src->klass() != nullptr &&\n+         top_dest != nullptr && top_dest->klass() != nullptr, \"args are strange\");\n@@ -6179,2 +6179,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -6190,1 +6190,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -6193,1 +6193,1 @@\n-  assert(tinst != NULL, \"CTR obj is null\");\n+  assert(tinst != nullptr, \"CTR obj is null\");\n@@ -6204,1 +6204,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -6207,1 +6207,1 @@\n-  if (obj_counter == NULL) return false;\n+  if (obj_counter == nullptr) return false;\n@@ -6211,1 +6211,1 @@\n-  if (saved_encCounter == NULL) return false;\n+  if (saved_encCounter == nullptr) return false;\n@@ -6235,3 +6235,3 @@\n-  assert (objSessionK != NULL, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n-  if (objSessionK == NULL) {\n-    return (Node *) NULL;\n+  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n+  if (objSessionK == nullptr) {\n+    return (Node *) nullptr;\n@@ -6243,2 +6243,2 @@\n-  assert (objAESCryptKey != NULL, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n-  if (objAESCryptKey == NULL) return (Node *) NULL;\n+  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n+  if (objAESCryptKey == nullptr) return (Node *) nullptr;\n@@ -6261,1 +6261,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -6274,1 +6274,1 @@\n-  assert(tinst != NULL, \"CBCobj is null\");\n+  assert(tinst != nullptr, \"CBCobj is null\");\n@@ -6296,1 +6296,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -6300,1 +6300,1 @@\n-    return instof_false;  \/\/ even if it is NULL\n+    return instof_false;  \/\/ even if it is null\n@@ -6310,1 +6310,1 @@\n-  Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);\n+  Node* src_dest_conjoint = generate_guard(bool_src_dest, nullptr, PROB_MIN);\n@@ -6327,1 +6327,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -6337,1 +6337,1 @@\n-  assert(tinst != NULL, \"ECBobj is null\");\n+  assert(tinst != nullptr, \"ECBobj is null\");\n@@ -6354,1 +6354,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -6358,1 +6358,1 @@\n-    return instof_false;  \/\/ even if it is NULL\n+    return instof_false;  \/\/ even if it is null\n@@ -6369,1 +6369,1 @@\n-  Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);\n+  Node* src_dest_conjoint = generate_guard(bool_src_dest, nullptr, PROB_MIN);\n@@ -6387,1 +6387,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -6397,1 +6397,1 @@\n-  assert(tinst != NULL, \"CTRobj is null\");\n+  assert(tinst != nullptr, \"CTRobj is null\");\n@@ -6413,1 +6413,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -6415,1 +6415,1 @@\n-  return instof_false; \/\/ even if it is NULL\n+  return instof_false; \/\/ even if it is null\n@@ -6438,1 +6438,1 @@\n-  assert(state_start, \"state is NULL\");\n+  assert(state_start, \"state is null\");\n@@ -6440,1 +6440,1 @@\n-  assert(subkeyH_start, \"subkeyH is NULL\");\n+  assert(subkeyH_start, \"subkeyH is null\");\n@@ -6442,1 +6442,1 @@\n-  assert(data_start, \"data is NULL\");\n+  assert(data_start, \"data is null\");\n@@ -6472,1 +6472,1 @@\n-  assert(src_start, \"source array is NULL\");\n+  assert(src_start, \"source array is null\");\n@@ -6474,1 +6474,1 @@\n-  assert(dest_start, \"destination array is NULL\");\n+  assert(dest_start, \"destination array is null\");\n@@ -6505,1 +6505,1 @@\n-  assert(src_start, \"source array is NULL\");\n+  assert(src_start, \"source array is null\");\n@@ -6507,1 +6507,1 @@\n-  assert(dest_start, \"destination array is NULL\");\n+  assert(dest_start, \"destination array is null\");\n@@ -6544,1 +6544,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == nullptr || top_src->klass()  == nullptr) {\n@@ -6556,2 +6556,2 @@\n-  Node* state = NULL;\n-  Node* digest_length = NULL;\n+  Node* state = nullptr;\n+  Node* digest_length = nullptr;\n@@ -6592,1 +6592,1 @@\n-    if (digest_length == NULL) return false;\n+    if (digest_length == nullptr) return false;\n@@ -6598,1 +6598,1 @@\n-  if (state == NULL) return false;\n+  if (state == nullptr) return false;\n@@ -6600,2 +6600,2 @@\n-  assert(stubAddr != NULL, \"Stub is generated\");\n-  if (stubAddr == NULL) return false;\n+  assert(stubAddr != nullptr, \"Stub is generated\");\n+  if (stubAddr == nullptr) return false;\n@@ -6605,1 +6605,1 @@\n-  if (digest_length == NULL) {\n+  if (digest_length == nullptr) {\n@@ -6629,1 +6629,1 @@\n-  Node* digestBase_obj = argument(0); \/\/ The receiver was checked for NULL already.\n+  Node* digestBase_obj = argument(0); \/\/ The receiver was checked for null already.\n@@ -6636,1 +6636,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == nullptr || top_src->klass()  == nullptr) {\n@@ -6649,3 +6649,3 @@\n-  const char* klass_digestBase_name = NULL;\n-  const char* stub_name = NULL;\n-  address     stub_addr = NULL;\n+  const char* klass_digestBase_name = nullptr;\n+  const char* stub_name = nullptr;\n+  address     stub_addr = nullptr;\n@@ -6695,3 +6695,3 @@\n-  if (klass_digestBase_name != NULL) {\n-    assert(stub_addr != NULL, \"Stub is generated\");\n-    if (stub_addr == NULL) return false;\n+  if (klass_digestBase_name != nullptr) {\n+    assert(stub_addr != nullptr, \"Stub is generated\");\n+    if (stub_addr == nullptr) return false;\n@@ -6701,1 +6701,1 @@\n-    assert(tinst != NULL, \"digestBase_obj is not instance???\");\n+    assert(tinst != nullptr, \"digestBase_obj is not instance???\");\n@@ -6722,1 +6722,1 @@\n-  if (state == NULL) return false;\n+  if (state == nullptr) return false;\n@@ -6724,1 +6724,1 @@\n-  Node* digest_length = NULL;\n+  Node* digest_length = nullptr;\n@@ -6727,1 +6727,1 @@\n-    if (digest_length == NULL) return false;\n+    if (digest_length == nullptr) return false;\n@@ -6732,1 +6732,1 @@\n-  if (digest_length == NULL) {\n+  if (digest_length == nullptr) {\n@@ -6754,2 +6754,2 @@\n-  assert (digest_state != NULL, \"wrong version of sun.security.provider.MD5\/SHA\/SHA2\/SHA5\/SHA3\");\n-  if (digest_state == NULL) return (Node *) NULL;\n+  assert (digest_state != nullptr, \"wrong version of sun.security.provider.MD5\/SHA\/SHA2\/SHA5\/SHA3\");\n+  if (digest_state == nullptr) return (Node *) nullptr;\n@@ -6765,1 +6765,1 @@\n-  assert (digest_length != NULL, \"sanity\");\n+  assert (digest_length != nullptr, \"sanity\");\n@@ -6779,1 +6779,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for nullptr already.\n@@ -6784,1 +6784,1 @@\n-  assert(tinst != NULL, \"digestBaseObj is null\");\n+  assert(tinst != nullptr, \"digestBaseObj is null\");\n@@ -6787,1 +6787,1 @@\n-  const char* klass_name = NULL;\n+  const char* klass_name = nullptr;\n@@ -6823,2 +6823,2 @@\n-  ciKlass* klass = NULL;\n-  if (klass_name != NULL) {\n+  ciKlass* klass = nullptr;\n+  if (klass_name != nullptr) {\n@@ -6827,1 +6827,1 @@\n-  if ((klass == NULL) || !klass->is_loaded()) {\n+  if ((klass == nullptr) || !klass->is_loaded()) {\n@@ -6838,1 +6838,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -6840,1 +6840,1 @@\n-  return instof_false;  \/\/ even if it is NULL\n+  return instof_false;  \/\/ even if it is null\n@@ -6845,4 +6845,4 @@\n-  Node *a = NULL;\n-  Node *b = NULL;\n-  Node *c = NULL;\n-  Node* result = NULL;\n+  Node *a = nullptr;\n+  Node *b = nullptr;\n+  Node *c = nullptr;\n+  Node* result = nullptr;\n@@ -6875,1 +6875,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -6908,1 +6908,1 @@\n-  if ( md != NULL && md->is_mature() && md->invocation_count() > 0 ) {\n+  if ( md != nullptr && md->is_mature() && md->invocation_count() > 0 ) {\n@@ -6934,3 +6934,3 @@\n-  Node *a = NULL;\n-  Node *b = NULL;\n-  Node *n = NULL;\n+  Node *a = nullptr;\n+  Node *b = nullptr;\n+  Node *n = nullptr;\n@@ -6967,2 +6967,2 @@\n-  const TypeAryPtr* ary = NULL;\n-  ciArray* aobj = NULL;\n+  const TypeAryPtr* ary = nullptr;\n+  ciArray* aobj = nullptr;\n@@ -6970,2 +6970,2 @@\n-      && (ary = counts->bottom_type()->isa_aryptr()) != NULL\n-      && (aobj = ary->const_oop()->as_array()) != NULL\n+      && (ary = counts->bottom_type()->isa_aryptr()) != nullptr\n+      && (aobj = ary->const_oop()->as_array()) != nullptr\n@@ -6977,1 +6977,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -7058,1 +7058,1 @@\n-  int   layout_is_con = (layout_val == NULL);\n+  int   layout_is_con = (layout_val == nullptr);\n@@ -7106,2 +7106,2 @@\n-    Node* array_ctl = generate_array_guard(klass_node, NULL);\n-    if (array_ctl != NULL) {\n+    Node* array_ctl = generate_array_guard(klass_node, nullptr);\n+    if (array_ctl != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":354,"deletions":354,"binary":false,"changes":708,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-      _result(NULL)\n+      _result(nullptr)\n@@ -88,1 +88,1 @@\n-      ciSignature* declared_signature = NULL;\n+      ciSignature* declared_signature = nullptr;\n@@ -108,1 +108,1 @@\n-    if (!stopped() && result() != NULL) {\n+    if (!stopped() && result() != nullptr) {\n@@ -119,1 +119,1 @@\n-  void  set_result(Node* n) { assert(_result == NULL, \"only set once\"); _result = n; }\n+  void  set_result(Node* n) { assert(_result == nullptr, \"only set once\"); _result = n; }\n@@ -131,1 +131,1 @@\n-                                Node* *pos_index = NULL);\n+                                Node* *pos_index = nullptr);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  _free_IndexSet = NULL;\n+  _free_IndexSet = nullptr;\n@@ -179,1 +179,1 @@\n-  while (free != NULL) {\n+  while (free != nullptr) {\n@@ -226,1 +226,1 @@\n-  _deltas[p->_pre_order-1] = NULL;\n+  _deltas[p->_pre_order-1] = nullptr;\n","filename":"src\/hotspot\/share\/opto\/live.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-  void reset() { _live = NULL; }\n+  void reset() { _live = nullptr; }\n","filename":"src\/hotspot\/share\/opto\/live.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  LockNode* lock = NULL;\n+  LockNode* lock = nullptr;\n@@ -99,2 +99,2 @@\n-          if ((unique_lock != NULL) && alock->is_Lock()) {\n-            if (lock == NULL) {\n+          if ((unique_lock != nullptr) && alock->is_Lock()) {\n+            if (lock == nullptr) {\n@@ -105,1 +105,1 @@\n-              if (bad_lock != NULL) {\n+              if (bad_lock != nullptr) {\n@@ -111,1 +111,1 @@\n-          if (bad_lock != NULL) {\n+          if (bad_lock != nullptr) {\n@@ -135,1 +135,1 @@\n-  if (unique_lock != NULL && has_one_lock) {\n+  if (unique_lock != nullptr && has_one_lock) {\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,3 +85,3 @@\n-    _counters = NULL;\n-    _rtm_counters = NULL;\n-    _stack_rtm_counters = NULL;\n+    _counters = nullptr;\n+    _rtm_counters = nullptr;\n+    _stack_rtm_counters = nullptr;\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  if (_idom != NULL) {\n+  if (_idom != nullptr) {\n@@ -134,1 +134,1 @@\n-    if (_idom != NULL) {\n+    if (_idom != nullptr) {\n@@ -148,1 +148,1 @@\n-  if (new_entry != NULL) {\n+  if (new_entry != nullptr) {\n@@ -154,1 +154,1 @@\n-  IfNode* new_iff = NULL;\n+  IfNode* new_iff = nullptr;\n@@ -183,1 +183,1 @@\n-  if (_idom != NULL) {\n+  if (_idom != nullptr) {\n@@ -219,1 +219,1 @@\n-  if (new_entry == NULL) {\n+  if (new_entry == nullptr) {\n@@ -222,1 +222,1 @@\n-    if (_idom != NULL) {\n+    if (_idom != nullptr) {\n@@ -266,1 +266,1 @@\n-  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n+  assert(clone_phi_input != nullptr && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n@@ -307,1 +307,1 @@\n-      if (in_clone != NULL) {\n+      if (in_clone != nullptr) {\n@@ -393,1 +393,1 @@\n-  while (predicate != NULL && predicate->is_Proj() && predicate->in(0)->is_If()) {\n+  while (predicate != nullptr && predicate->is_Proj() && predicate->in(0)->is_If()) {\n@@ -418,2 +418,2 @@\n-  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, output_proj);\n-  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(),\n+  Node* bol = clone_skeleton_predicate_bool(iff, nullptr, nullptr, output_proj);\n+  ProjNode* proj = create_new_if_for_predicate(output_proj, nullptr, reason, iff->Opcode(),\n@@ -435,1 +435,1 @@\n-  ProjNode* limit_check_proj = NULL;\n+  ProjNode* limit_check_proj = nullptr;\n@@ -437,1 +437,1 @@\n-  if (limit_check_proj != NULL) {\n+  if (limit_check_proj != nullptr) {\n@@ -440,2 +440,2 @@\n-  ProjNode* profile_predicate_proj = NULL;\n-  ProjNode* predicate_proj = NULL;\n+  ProjNode* profile_predicate_proj = nullptr;\n+  ProjNode* predicate_proj = nullptr;\n@@ -444,1 +444,1 @@\n-    if (profile_predicate_proj != NULL) {\n+    if (profile_predicate_proj != nullptr) {\n@@ -451,1 +451,1 @@\n-  if (predicate_proj != NULL) { \/\/ right pattern that can be used by loop predication\n+  if (predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -460,1 +460,1 @@\n-  if (profile_predicate_proj != NULL) { \/\/ right pattern that can be used by loop predication\n+  if (profile_predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -469,1 +469,1 @@\n-  if (limit_check_proj != NULL && clone_limit_check) {\n+  if (limit_check_proj != nullptr && clone_limit_check) {\n@@ -483,1 +483,1 @@\n-  assert(new_entry != NULL, \"IfTrue or IfFalse after clone predicate\");\n+  assert(new_entry != nullptr, \"IfTrue or IfFalse after clone predicate\");\n@@ -500,1 +500,1 @@\n-  while (entry != NULL && entry->is_Proj() && entry->in(0)->is_If()) {\n+  while (entry != nullptr && entry->is_Proj() && entry->in(0)->is_If()) {\n@@ -510,1 +510,1 @@\n-  Node* predicate = NULL;\n+  Node* predicate = nullptr;\n@@ -512,1 +512,1 @@\n-  if (predicate != NULL) {\n+  if (predicate != nullptr) {\n@@ -517,1 +517,1 @@\n-    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+    if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -523,1 +523,1 @@\n-    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+    if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -533,2 +533,2 @@\n-  if (start_c == NULL || !start_c->is_Proj())\n-    return NULL;\n+  if (start_c == nullptr || !start_c->is_Proj())\n+    return nullptr;\n@@ -538,1 +538,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -544,1 +544,1 @@\n-  Node* predicate = NULL;\n+  Node* predicate = nullptr;\n@@ -546,1 +546,1 @@\n-  if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+  if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -551,1 +551,1 @@\n-    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+    if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -557,1 +557,1 @@\n-    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+    if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -561,1 +561,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -574,1 +574,1 @@\n-  Node* _data_dependency_on; \/\/ The projection into the loop on which data nodes are dependent or NULL otherwise\n+  Node* _data_dependency_on; \/\/ The projection into the loop on which data nodes are dependent or null otherwise\n@@ -586,1 +586,1 @@\n-        _stack.push(n, n->in(0) == NULL ? 1 : 0);\n+        _stack.push(n, n->in(0) == nullptr ? 1 : 0);\n@@ -605,1 +605,1 @@\n-          if (in == NULL) continue;\n+          if (in == nullptr) continue;\n@@ -617,1 +617,1 @@\n-          if (n->is_CFG() || n->depends_only_on_test() || n->in(0) == NULL || !_phase->is_member(_lpt, n->in(0))) {\n+          if (n->is_CFG() || n->depends_only_on_test() || n->in(0) == nullptr || !_phase->is_member(_lpt, n->in(0))) {\n@@ -624,1 +624,1 @@\n-        if (m != NULL && !_visited.test_set(m->_idx)) {\n+        if (m != nullptr && !_visited.test_set(m->_idx)) {\n@@ -640,1 +640,1 @@\n-      _stack.push(n, n->in(0) == NULL ? 1 : 0);\n+      _stack.push(n, n->in(0) == nullptr ? 1 : 0);\n@@ -658,1 +658,1 @@\n-          if (in == NULL) continue;\n+          if (in == nullptr) continue;\n@@ -664,1 +664,1 @@\n-        if (m != NULL && !_clone_visited.test_set(m->_idx)) {\n+        if (m != nullptr && !_clone_visited.test_set(m->_idx)) {\n@@ -677,1 +677,1 @@\n-    _data_dependency_on(NULL)\n+    _data_dependency_on(nullptr)\n@@ -710,1 +710,1 @@\n-  \/\/ are dependent that prevent loop predication. Otherwise, return NULL.\n+  \/\/ are dependent that prevent loop predication. Otherwise, return null.\n@@ -765,1 +765,1 @@\n-    if (tint == NULL || tint->empty() || tint->_lo < 0) {\n+    if (tint == nullptr || tint->empty() || tint->_lo < 0) {\n@@ -781,1 +781,1 @@\n-  Node *offset = NULL;\n+  Node *offset = nullptr;\n@@ -785,1 +785,1 @@\n-  if (offset != NULL) {\n+  if (offset != nullptr) {\n@@ -790,1 +790,1 @@\n-    if (data_dependency_on != NULL && old_unique_idx < C->unique()) {\n+    if (data_dependency_on != nullptr && old_unique_idx < C->unique()) {\n@@ -836,1 +836,1 @@\n-  jint con_limit  = (limit != NULL && limit->is_Con())  ? limit->get_int()  : 0;\n+  jint con_limit  = (limit != nullptr && limit->is_Con())  ? limit->get_int()  : 0;\n@@ -840,1 +840,1 @@\n-  stringStream* predString = NULL;\n+  stringStream* predString = nullptr;\n@@ -847,1 +847,1 @@\n-  Node* max_idx_expr = NULL;\n+  Node* max_idx_expr = nullptr;\n@@ -850,1 +850,1 @@\n-    guarantee(limit != NULL, \"sanity\");\n+    guarantee(limit != nullptr, \"sanity\");\n@@ -951,1 +951,1 @@\n-  CmpNode* cmp = NULL;\n+  CmpNode* cmp = nullptr;\n@@ -979,1 +979,1 @@\n-  if (predicate_proj == NULL) {\n+  if (predicate_proj == nullptr) {\n@@ -987,1 +987,1 @@\n-  while (l != NULL && follow_branches) {\n+  while (l != nullptr && follow_branches) {\n@@ -989,1 +989,1 @@\n-    if (child->_child != NULL &&\n+    if (child->_child != nullptr &&\n@@ -991,1 +991,1 @@\n-      assert(child->_child->_next == NULL, \"only one inner loop for strip mined loop\");\n+      assert(child->_child->_next == nullptr, \"only one inner loop for strip mined loop\");\n@@ -995,1 +995,1 @@\n-    if (child->_child != NULL || child->_irreducible) {\n+    if (child->_child != nullptr || child->_irreducible) {\n@@ -1008,1 +1008,1 @@\n-        if (cl->phi() != NULL) {\n+        if (cl->phi() != nullptr) {\n@@ -1196,1 +1196,1 @@\n-        } else if (c->unique_ctrl_out() == NULL && !c->is_If() && !c->is_Jump()) {\n+        } else if (c->unique_ctrl_out() == nullptr && !c->is_If() && !c->is_Jump()) {\n@@ -1256,1 +1256,1 @@\n-  ProjNode* new_predicate_proj = NULL;\n+  ProjNode* new_predicate_proj = nullptr;\n@@ -1265,1 +1265,1 @@\n-    new_predicate_proj = create_new_if_for_predicate(predicate_proj, NULL,\n+    new_predicate_proj = create_new_if_for_predicate(predicate_proj, nullptr,\n@@ -1290,1 +1290,1 @@\n-  } else if (cl != NULL && loop->is_range_check_if(iff, this, invar DEBUG_ONLY(COMMA predicate_proj))) {\n+  } else if (cl != nullptr && loop->is_range_check_if(iff, this, invar DEBUG_ONLY(COMMA predicate_proj))) {\n@@ -1330,1 +1330,1 @@\n-    ProjNode* lower_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff->Opcode());\n+    ProjNode* lower_bound_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n@@ -1339,1 +1339,1 @@\n-    ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff->Opcode());\n+    ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n@@ -1363,1 +1363,1 @@\n-  assert(new_predicate_proj != NULL, \"sanity\");\n+  assert(new_predicate_proj != nullptr, \"sanity\");\n@@ -1395,1 +1395,1 @@\n-  ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff->Opcode());\n+  ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n@@ -1417,1 +1417,1 @@\n-  new_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff->Opcode());\n+  new_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n@@ -1445,1 +1445,1 @@\n-  CountedLoopNode *cl = NULL;\n+  CountedLoopNode *cl = nullptr;\n@@ -1453,1 +1453,1 @@\n-      cl = NULL;\n+      cl = nullptr;\n@@ -1457,3 +1457,3 @@\n-  ProjNode *loop_limit_proj = NULL;\n-  ProjNode *predicate_proj = NULL;\n-  ProjNode *profile_predicate_proj = NULL;\n+  ProjNode *loop_limit_proj = nullptr;\n+  ProjNode *predicate_proj = nullptr;\n+  ProjNode *profile_predicate_proj = nullptr;\n@@ -1462,1 +1462,1 @@\n-  if (loop_limit_proj != NULL) {\n+  if (loop_limit_proj != nullptr) {\n@@ -1467,1 +1467,1 @@\n-  if (profile_predicate_proj != NULL) {\n+  if (profile_predicate_proj != nullptr) {\n@@ -1482,1 +1482,1 @@\n-  if (predicate_proj == NULL && !follow_branches) {\n+  if (predicate_proj == nullptr && !follow_branches) {\n@@ -1531,1 +1531,1 @@\n-      if (call == NULL) {\n+      if (call == nullptr) {\n@@ -1552,1 +1552,1 @@\n-      if (predicate_proj != NULL) {\n+      if (predicate_proj != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":78,"deletions":78,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-\/\/ Given an IfNode, return the loop-exiting projection or NULL if both\n+\/\/ Given an IfNode, return the loop-exiting projection or null if both\n@@ -50,1 +50,1 @@\n-  if (iff->outcnt() != 2) return NULL;  \/\/ Ignore partially dead tests\n+  if (iff->outcnt() != 2) return nullptr;  \/\/ Ignore partially dead tests\n@@ -58,1 +58,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -76,1 +76,1 @@\n-    assert(outer_loop != NULL, \"missing piece of strip mined loop\");\n+    assert(outer_loop != nullptr, \"missing piece of strip mined loop\");\n@@ -79,1 +79,1 @@\n-    assert(outer_loop_tail != NULL, \"missing piece of strip mined loop\");\n+    assert(outer_loop_tail != nullptr, \"missing piece of strip mined loop\");\n@@ -82,1 +82,1 @@\n-    assert(outer_loop_end != NULL, \"missing piece of strip mined loop\");\n+    assert(outer_loop_end != nullptr, \"missing piece of strip mined loop\");\n@@ -85,1 +85,1 @@\n-    assert(outer_safepoint != NULL, \"missing piece of strip mined loop\");\n+    assert(outer_safepoint != nullptr, \"missing piece of strip mined loop\");\n@@ -88,1 +88,1 @@\n-    assert(cle_out != NULL, \"missing piece of strip mined loop\");\n+    assert(cle_out != nullptr, \"missing piece of strip mined loop\");\n@@ -118,1 +118,1 @@\n-  if (init_n != NULL && limit_n != NULL) {\n+  if (init_n != nullptr && limit_n != nullptr) {\n@@ -211,1 +211,1 @@\n-    if (_child == NULL) {\n+    if (_child == nullptr) {\n@@ -267,1 +267,1 @@\n-\/\/ not NULL, \"n\" must be re-associative with it.\n+\/\/ not null, \"n\" must be re-associative with it.\n@@ -270,1 +270,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -322,1 +322,1 @@\n-  bool is_int = n1->bottom_type()->isa_int() != NULL;\n+  bool is_int = n1->bottom_type()->isa_int() != nullptr;\n@@ -378,2 +378,2 @@\n-  if (!is_associative(n1) || n1->outcnt() == 0) return NULL;\n-  if (is_invariant(n1)) return NULL;\n+  if (!is_associative(n1) || n1->outcnt() == 0) return nullptr;\n+  if (is_invariant(n1)) return nullptr;\n@@ -381,1 +381,1 @@\n-  if (n1->is_Add() && n1->in(2)->is_Con()) return NULL;\n+  if (n1->is_Add() && n1->in(2)->is_Con()) return nullptr;\n@@ -384,1 +384,1 @@\n-  if (!inv1_idx) return NULL;\n+  if (!inv1_idx) return nullptr;\n@@ -386,1 +386,1 @@\n-  if (!is_associative(n2, n1)) return NULL;\n+  if (!is_associative(n2, n1)) return nullptr;\n@@ -388,1 +388,1 @@\n-  if (!inv2_idx) return NULL;\n+  if (!inv2_idx) return nullptr;\n@@ -390,1 +390,1 @@\n-  if (!phase->may_require_nodes(10, 10)) return NULL;\n+  if (!phase->may_require_nodes(10, 10)) return nullptr;\n@@ -392,1 +392,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -420,1 +420,1 @@\n-  assert(result != NULL, \"\");\n+  assert(result != nullptr, \"\");\n@@ -435,1 +435,1 @@\n-      if (nn == NULL) break;\n+      if (nn == nullptr) break;\n@@ -518,2 +518,2 @@\n-      assert(test != NULL, \"test cannot be NULL\");\n-      Node* test_cond = NULL;\n+      assert(test != nullptr, \"test cannot be null\");\n+      Node* test_cond = nullptr;\n@@ -523,1 +523,1 @@\n-      if (test_cond != NULL && \/\/ Test?\n+      if (test_cond != nullptr && \/\/ Test?\n@@ -910,1 +910,1 @@\n-  if (limit_n == NULL) return false; \/\/ We will dereference it below.\n+  if (limit_n == nullptr) return false; \/\/ We will dereference it below.\n@@ -915,1 +915,1 @@\n-  if (init_n == NULL || !init_n->is_Con() || !limit_n->is_Con()) {\n+  if (init_n == nullptr || !init_n->is_Con() || !limit_n->is_Con()) {\n@@ -917,1 +917,1 @@\n-    if (phi != NULL) {\n+    if (phi != nullptr) {\n@@ -1116,1 +1116,1 @@\n-      if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {\n+      if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, nullptr, nullptr)) {\n@@ -1164,1 +1164,1 @@\n-    return (x != NULL) ? x : n;\n+    return (x != nullptr) ? x : n;\n@@ -1167,1 +1167,1 @@\n-  Node *x = NULL;               \/\/ If required, a clone of 'n'\n+  Node *x = nullptr;               \/\/ If required, a clone of 'n'\n@@ -1170,1 +1170,1 @@\n-    assert(clones.find(n->_idx) == NULL, \"dead loop\");\n+    assert(clones.find(n->_idx) == nullptr, \"dead loop\");\n@@ -1183,1 +1183,1 @@\n-        assert(clones.find(n->_idx) == NULL, \"dead loop\");\n+        assert(clones.find(n->_idx) == nullptr, \"dead loop\");\n@@ -1210,1 +1210,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1217,1 +1217,1 @@\n-  assert(zer_bol != NULL && zer_bol->is_Bool(), \"must be Bool\");\n+  assert(zer_bol != nullptr && zer_bol->is_Bool(), \"must be Bool\");\n@@ -1219,1 +1219,1 @@\n-  assert(zer_cmp != NULL && zer_cmp->Opcode() == Op_CmpI, \"must be CmpI\");\n+  assert(zer_cmp != nullptr && zer_cmp->Opcode() == Op_CmpI, \"must be CmpI\");\n@@ -1222,1 +1222,1 @@\n-  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_Opaque1, \"must be Opaque1\");\n+  assert(zer_opaq != nullptr && zer_opaq->Opcode() == Op_Opaque1, \"must be Opaque1\");\n@@ -1239,1 +1239,1 @@\n-  if (predicate != NULL) {\n+  if (predicate != nullptr) {\n@@ -1257,1 +1257,1 @@\n-    while (predicate != NULL && predicate->is_Proj() && predicate->in(0)->is_If()) {\n+    while (predicate != nullptr && predicate->is_Proj() && predicate->in(0)->is_If()) {\n@@ -1267,1 +1267,1 @@\n-        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, opaque_init, NULL, predicate, uncommon_proj,\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, opaque_init, nullptr, predicate, uncommon_proj,\n@@ -1283,1 +1283,1 @@\n-          if (!loop_node->is_CFG() && (pre_loop_node != NULL && pre_loop_node->_idx > idx_after_post_before_pre)) {\n+          if (!loop_node->is_CFG() && (pre_loop_node != nullptr && pre_loop_node->_idx > idx_after_post_before_pre)) {\n@@ -1291,1 +1291,1 @@\n-            assert(pre_loop_node == NULL, \"a node belonging to the post loop should not have an old_new mapping at this stage\");\n+            assert(pre_loop_node == nullptr, \"a node belonging to the post loop should not have an old_new mapping at this stage\");\n@@ -1362,1 +1362,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -1386,1 +1386,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -1402,1 +1402,1 @@\n-\/\/ Unswitched loop: new_init and new_stride are both NULL. Clone OpaqueLoopInit and OpaqueLoopStride instead.\n+\/\/ Unswitched loop: new_init and new_stride are both null. Clone OpaqueLoopInit and OpaqueLoopStride instead.\n@@ -1407,3 +1407,3 @@\n-  Node* result = NULL;\n-  bool is_unswitched_loop = new_init == NULL && new_stride == NULL;\n-  assert(new_init != NULL || is_unswitched_loop, \"new_init must be set when new_stride is non-null\");\n+  Node* result = nullptr;\n+  bool is_unswitched_loop = new_init == nullptr && new_stride == nullptr;\n+  assert(new_init != nullptr || is_unswitched_loop, \"new_init must be set when new_stride is non-null\");\n@@ -1430,1 +1430,1 @@\n-        if (is_unswitched_loop && m->_idx < current && new_init == NULL) {\n+        if (is_unswitched_loop && m->_idx < current && new_init == nullptr) {\n@@ -1437,1 +1437,1 @@\n-        if (is_unswitched_loop && m->_idx < current && new_stride == NULL) {\n+        if (is_unswitched_loop && m->_idx < current && new_stride == nullptr) {\n@@ -1441,1 +1441,1 @@\n-        if (new_stride != NULL) {\n+        if (new_stride != nullptr) {\n@@ -1471,1 +1471,1 @@\n-  } while (result == NULL);\n+  } while (result == nullptr);\n@@ -1473,1 +1473,1 @@\n-  assert(!is_unswitched_loop || new_init != NULL, \"new_init must always be found and cloned\");\n+  assert(!is_unswitched_loop || new_init != nullptr, \"new_init must always be found and cloned\");\n@@ -1509,1 +1509,1 @@\n-    Node* predicate = NULL;\n+    Node* predicate = nullptr;\n@@ -1511,1 +1511,1 @@\n-    if (predicate != NULL) {\n+    if (predicate != nullptr) {\n@@ -1514,1 +1514,1 @@\n-    Node* profile_predicate = NULL;\n+    Node* profile_predicate = nullptr;\n@@ -1517,1 +1517,1 @@\n-      if (profile_predicate != NULL) {\n+      if (profile_predicate != nullptr) {\n@@ -1578,1 +1578,1 @@\n-  CountedLoopNode *post_head = NULL;\n+  CountedLoopNode *post_head = nullptr;\n@@ -1684,1 +1684,1 @@\n-  assert(castii != NULL, \"no castII inserted\");\n+  assert(castii != nullptr, \"no castII inserted\");\n@@ -1809,1 +1809,1 @@\n-  CountedLoopNode *post_head = NULL;\n+  CountedLoopNode *post_head = nullptr;\n@@ -1856,1 +1856,1 @@\n-  CountedLoopNode *post_head = NULL;\n+  CountedLoopNode *post_head = nullptr;\n@@ -1962,1 +1962,1 @@\n-  assert(incr != NULL, \"no castII inserted\");\n+  assert(incr != nullptr, \"no castII inserted\");\n@@ -1994,1 +1994,1 @@\n-  while (entry != NULL && entry->is_Proj() && entry->in(0)->is_If()) {\n+  while (entry != nullptr && entry->is_Proj() && entry->in(0)->is_If()) {\n@@ -2032,1 +2032,1 @@\n-  while (ctrl != NULL && ctrl->is_Proj() && ctrl->in(0)->is_If()) {\n+  while (ctrl != nullptr && ctrl->is_Proj() && ctrl->in(0)->is_If()) {\n@@ -2089,1 +2089,1 @@\n-  Node *opaq = NULL;\n+  Node *opaq = nullptr;\n@@ -2097,1 +2097,1 @@\n-    if (opaq == NULL) {\n+    if (opaq == nullptr) {\n@@ -2106,1 +2106,1 @@\n-  Node* new_limit = NULL;\n+  Node* new_limit = nullptr;\n@@ -2148,1 +2148,1 @@\n-    assert(opaq != NULL && opaq->in(1) == limit, \"sanity\");\n+    assert(opaq != nullptr && opaq->in(1) == limit, \"sanity\");\n@@ -2193,3 +2193,3 @@\n-        Node* old_limit = NULL;\n-        Node* adj_limit = NULL;\n-        Node* bol = limit->is_CMove() ? limit->in(CMoveNode::Condition) : NULL;\n+        Node* old_limit = nullptr;\n+        Node* adj_limit = nullptr;\n+        Node* bol = limit->is_CMove() ? limit->in(CMoveNode::Condition) : nullptr;\n@@ -2213,1 +2213,1 @@\n-        assert(old_limit != NULL && adj_limit != NULL, \"\");\n+        assert(old_limit != nullptr && adj_limit != nullptr, \"\");\n@@ -2238,1 +2238,1 @@\n-    assert(new_limit != NULL, \"\");\n+    assert(new_limit != nullptr, \"\");\n@@ -2392,1 +2392,1 @@\n-      if (def_node != NULL) {\n+      if (def_node != nullptr) {\n@@ -2394,1 +2394,1 @@\n-        if (n_ctrl != NULL && loop->is_member(get_loop(n_ctrl))) {\n+        if (n_ctrl != nullptr && loop->is_member(get_loop(n_ctrl))) {\n@@ -2445,1 +2445,1 @@\n-  Node* limit = new DivLNode(NULL, sub, scale);\n+  Node* limit = new DivLNode(nullptr, sub, scale);\n@@ -2501,2 +2501,2 @@\n-  assert(_igvn.type(offset)->isa_long() != NULL && _igvn.type(low_limit)->isa_long() != NULL &&\n-         _igvn.type(upper_limit)->isa_long() != NULL, \"arguments should be long values\");\n+  assert(_igvn.type(offset)->isa_long() != nullptr && _igvn.type(low_limit)->isa_long() != nullptr &&\n+         _igvn.type(upper_limit)->isa_long() != nullptr, \"arguments should be long values\");\n@@ -2576,1 +2576,1 @@\n-    if (p_scale != NULL) {\n+    if (p_scale != nullptr) {\n@@ -2584,1 +2584,1 @@\n-      if (p_scale != NULL) {\n+      if (p_scale != nullptr) {\n@@ -2590,1 +2590,1 @@\n-      if (p_scale != NULL) {\n+      if (p_scale != nullptr) {\n@@ -2597,1 +2597,1 @@\n-      if (p_scale != NULL) {\n+      if (p_scale != nullptr) {\n@@ -2610,1 +2610,1 @@\n-    if (p_offset != NULL) {\n+    if (p_offset != nullptr) {\n@@ -2621,1 +2621,1 @@\n-      if (p_offset != NULL) {\n+      if (p_offset != nullptr) {\n@@ -2627,1 +2627,1 @@\n-      if (p_offset != NULL) {\n+      if (p_offset != nullptr) {\n@@ -2633,1 +2633,1 @@\n-      Node* offset2 = NULL;\n+      Node* offset2 = nullptr;\n@@ -2636,2 +2636,2 @@\n-                                   p_offset != NULL ? &offset2 : NULL, depth+1)) {\n-        if (p_offset != NULL) {\n+                                   p_offset != nullptr ? &offset2 : nullptr, depth+1)) {\n+        if (p_offset != nullptr) {\n@@ -2648,1 +2648,1 @@\n-      if (p_offset != NULL) {\n+      if (p_offset != nullptr) {\n@@ -2659,1 +2659,1 @@\n-      if (p_offset != NULL) {\n+      if (p_offset != nullptr) {\n@@ -2675,1 +2675,1 @@\n-  BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con > 0) != (scale_con > 0), overflow, false);\n+  BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, nullptr, stride_con, limit, (stride_con > 0) != (scale_con > 0), overflow, false);\n@@ -2678,1 +2678,1 @@\n-  IfNode* new_iff = NULL;\n+  IfNode* new_iff = nullptr;\n@@ -2728,1 +2728,1 @@\n-  if (cl->is_canonical_loop_entry() == NULL) {\n+  if (cl->is_canonical_loop_entry() == nullptr) {\n@@ -2763,1 +2763,1 @@\n-  if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP) {\n+  if (orig_limit == nullptr || _igvn.type(orig_limit) == Type::TOP) {\n@@ -2834,1 +2834,1 @@\n-      Node *offset = NULL;\n+      Node *offset = nullptr;\n@@ -2955,1 +2955,1 @@\n-          _igvn.replace_input_of(cd, 0, ctrl); \/\/ ctrl, not NULL\n+          _igvn.replace_input_of(cd, 0, ctrl); \/\/ ctrl, not null\n@@ -3060,1 +3060,1 @@\n-  if (legacy_cl->is_canonical_loop_entry() == NULL) {\n+  if (legacy_cl->is_canonical_loop_entry() == nullptr) {\n@@ -3068,1 +3068,1 @@\n-  if (post_loop_region == NULL) return multi_version_succeeded;\n+  if (post_loop_region == nullptr) return multi_version_succeeded;\n@@ -3071,1 +3071,1 @@\n-  if (covering_region == NULL) return multi_version_succeeded;\n+  if (covering_region == nullptr) return multi_version_succeeded;\n@@ -3074,1 +3074,1 @@\n-  if (p_f == NULL) return multi_version_succeeded;\n+  if (p_f == nullptr) return multi_version_succeeded;\n@@ -3078,1 +3078,1 @@\n-  if (rce_loop_end == NULL) return multi_version_succeeded;\n+  if (rce_loop_end == nullptr) return multi_version_succeeded;\n@@ -3080,1 +3080,1 @@\n-  if (rce_cl == NULL || !rce_cl->is_post_loop()) return multi_version_succeeded;\n+  if (rce_cl == nullptr || !rce_cl->is_post_loop()) return multi_version_succeeded;\n@@ -3104,1 +3104,1 @@\n-  Node *last_min = NULL;\n+  Node *last_min = nullptr;\n@@ -3278,1 +3278,1 @@\n-  if (_next == NULL) {\n+  if (_next == nullptr) {\n@@ -3330,1 +3330,1 @@\n-  Node* iv = NULL;\n+  Node* iv = nullptr;\n@@ -3334,1 +3334,1 @@\n-      assert(iv == NULL, \"Too many phis\");\n+      assert(iv == nullptr, \"Too many phis\");\n@@ -3647,2 +3647,2 @@\n-  const char* msg = NULL;\n-  Node* msg_node = NULL;\n+  const char* msg = nullptr;\n+  Node* msg_node = nullptr;\n@@ -3650,3 +3650,3 @@\n-  store_value = NULL;\n-  con = NULL;\n-  shift = NULL;\n+  store_value = nullptr;\n+  con = nullptr;\n+  shift = nullptr;\n@@ -3657,1 +3657,1 @@\n-  for (uint i = 0; msg == NULL && i < lpt->_body.size(); i++) {\n+  for (uint i = 0; msg == nullptr && i < lpt->_body.size(); i++) {\n@@ -3661,1 +3661,1 @@\n-      if (store != NULL) {\n+      if (store != nullptr) {\n@@ -3684,1 +3684,1 @@\n-  if (store == NULL) {\n+  if (store == nullptr) {\n@@ -3689,1 +3689,1 @@\n-  if (msg == NULL && head->stride_con() != 1) {\n+  if (msg == nullptr && head->stride_con() != 1) {\n@@ -3698,1 +3698,1 @@\n-  if (msg == NULL && !store->in(MemNode::Address)->is_AddP()) {\n+  if (msg == nullptr && !store->in(MemNode::Address)->is_AddP()) {\n@@ -3703,1 +3703,1 @@\n-  if (msg == NULL &&\n+  if (msg == nullptr &&\n@@ -3713,2 +3713,2 @@\n-  if (msg == NULL &&\n-      StubRoutines::select_fill_function(t, false, fill_name) == NULL) {\n+  if (msg == nullptr &&\n+      StubRoutines::select_fill_function(t, false, fill_name) == nullptr) {\n@@ -3719,1 +3719,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -3723,1 +3723,1 @@\n-      if (msg_node != NULL) msg_node->dump();\n+      if (msg_node != nullptr) msg_node->dump();\n@@ -3732,2 +3732,2 @@\n-  Node* cast = NULL;\n-  Node* conv = NULL;\n+  Node* cast = nullptr;\n+  Node* conv = nullptr;\n@@ -3738,1 +3738,1 @@\n-    if (n->is_Con() && con == NULL) {\n+    if (n->is_Con() && con == nullptr) {\n@@ -3740,1 +3740,1 @@\n-    } else if (n->Opcode() == Op_LShiftX && shift == NULL) {\n+    } else if (n->Opcode() == Op_LShiftX && shift == nullptr) {\n@@ -3764,1 +3764,1 @@\n-    } else if (n->Opcode() == Op_ConvI2L && conv == NULL) {\n+    } else if (n->Opcode() == Op_ConvI2L && conv == nullptr) {\n@@ -3797,1 +3797,1 @@\n-  if (msg == NULL && shift == NULL && t != T_BYTE && t != T_BOOLEAN) {\n+  if (msg == nullptr && shift == nullptr && t != T_BYTE && t != T_BOOLEAN) {\n@@ -3802,1 +3802,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -3806,1 +3806,1 @@\n-      if (msg_node != NULL) msg_node->dump();\n+      if (msg_node != nullptr) msg_node->dump();\n@@ -3835,1 +3835,1 @@\n-  for (uint i = 0; msg == NULL && i < lpt->_body.size(); i++) {\n+  for (uint i = 0; msg == nullptr && i < lpt->_body.size(); i++) {\n@@ -3849,1 +3849,1 @@\n-  for (uint i = 0; msg == NULL && i < lpt->_body.size(); i++) {\n+  for (uint i = 0; msg == nullptr && i < lpt->_body.size(); i++) {\n@@ -3866,1 +3866,1 @@\n-    if (msg != NULL) {\n+    if (msg != nullptr) {\n@@ -3868,1 +3868,1 @@\n-      if (msg_node != NULL) msg_node->dump();\n+      if (msg_node != nullptr) msg_node->dump();\n@@ -3879,1 +3879,1 @@\n-  return msg == NULL;\n+  return msg == nullptr;\n@@ -3900,4 +3900,4 @@\n-  Node* store = NULL;\n-  Node* store_value = NULL;\n-  Node* shift = NULL;\n-  Node* offset = NULL;\n+  Node* store = nullptr;\n+  Node* store_value = nullptr;\n+  Node* shift = nullptr;\n+  Node* offset = nullptr;\n@@ -3909,1 +3909,1 @@\n-  if (exit == NULL) {\n+  if (exit == nullptr) {\n@@ -3930,1 +3930,1 @@\n-  if (shift != NULL) {\n+  if (shift != nullptr) {\n@@ -3939,2 +3939,2 @@\n-  \/\/ AddP node adding an absolute offset, so we do a NULL check here.\n-  assert(offset != NULL || C->has_unsafe_access(),\n+  \/\/ AddP node adding an absolute offset, so we do a null check here.\n+  assert(offset != nullptr || C->has_unsafe_access(),\n@@ -3942,1 +3942,1 @@\n-  if (offset != NULL) {\n+  if (offset != nullptr) {\n@@ -3965,1 +3965,1 @@\n-  if (offset != NULL && head->init_trip()->is_Con()) {\n+  if (offset != nullptr && head->init_trip()->is_Con()) {\n@@ -3973,1 +3973,1 @@\n-  assert(fill != NULL, \"what?\");\n+  assert(fill != nullptr, \"what?\");\n@@ -4017,1 +4017,1 @@\n-  if (alloc != NULL && alloc->is_AllocateArray()) {\n+  if (alloc != nullptr && alloc->is_AllocateArray()) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":147,"deletions":147,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-  if (phase->find_unswitching_candidate(this) == NULL) {\n+  if (phase->find_unswitching_candidate(this) == nullptr) {\n@@ -91,1 +91,1 @@\n-  IfNode* unswitch_iff = NULL;\n+  IfNode* unswitch_iff = nullptr;\n@@ -123,3 +123,3 @@\n-  if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != NULL\n-      || (UseProfiledLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != NULL)\n-      || (UseLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != NULL)) {\n+  if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != nullptr\n+      || (UseProfiledLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != nullptr)\n+      || (UseLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != nullptr)) {\n@@ -136,1 +136,1 @@\n-  assert(unswitch_iff != NULL, \"should be at least one\");\n+  assert(unswitch_iff != nullptr, \"should be at least one\");\n@@ -158,1 +158,1 @@\n-  if (predicate == NULL) {\n+  if (predicate == nullptr) {\n@@ -169,1 +169,1 @@\n-      if (predicate != NULL) {\n+      if (predicate != nullptr) {\n@@ -175,1 +175,1 @@\n-      if (predicate != NULL) {\n+      if (predicate != nullptr) {\n@@ -346,3 +346,3 @@\n-  _lp(NULL),\n-  _iff(NULL),\n-  _lp_reserved(NULL),\n+  _lp(nullptr),\n+  _iff(nullptr),\n+  _lp_reserved(nullptr),\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    if (le != NULL &&\n+    if (le != nullptr &&\n@@ -81,2 +81,2 @@\n-      if (exit != NULL && exit->Opcode() == Op_IfFalse &&\n-          phi != NULL && phi->is_Phi() &&\n+      if (exit != nullptr && exit->Opcode() == Op_IfFalse &&\n+          phi != nullptr && phi->is_Phi() &&\n@@ -176,1 +176,1 @@\n-    if (ctl->is_CountedLoop() && ctl->in(1) != NULL && ctl->in(1)->in(0) != NULL && ctl->in(1)->in(0)->is_If()) {\n+    if (ctl->is_CountedLoop() && ctl->in(1) != nullptr && ctl->in(1)->in(0) != nullptr && ctl->in(1)->in(0)->is_If()) {\n@@ -186,1 +186,1 @@\n-      if (parent_ctl == NULL) {\n+      if (parent_ctl == nullptr) {\n@@ -188,1 +188,1 @@\n-      } else if (parent_ctl->is_CountedLoopEnd() && parent_ctl->as_CountedLoopEnd()->loopnode() != NULL) {\n+      } else if (parent_ctl->is_CountedLoopEnd() && parent_ctl->as_CountedLoopEnd()->loopnode() != nullptr) {\n@@ -252,1 +252,1 @@\n-  if (update_body && loop->_child == NULL) {\n+  if (update_body && loop->_child == nullptr) {\n@@ -292,1 +292,1 @@\n-  loop->_next = NULL;\n+  loop->_next = nullptr;\n@@ -344,1 +344,1 @@\n-  Node* new_predicate_proj = create_new_if_for_predicate(limit_check_proj, NULL,\n+  Node* new_predicate_proj = create_new_if_for_predicate(limit_check_proj, nullptr,\n@@ -369,1 +369,1 @@\n-  \/\/ Counted loop head must be a good RegionNode with only 3 not NULL\n+  \/\/ Counted loop head must be a good RegionNode with only 3 not null\n@@ -371,2 +371,2 @@\n-  if (x->in(LoopNode::Self) == NULL || x->req() != 3 || loop->_irreducible) {\n-    return NULL;\n+  if (x->in(LoopNode::Self) == nullptr || x->req() != 3 || loop->_irreducible) {\n+    return nullptr;\n@@ -376,2 +376,2 @@\n-  if (init_control == NULL || back_control == NULL) {   \/\/ Partially dead\n-    return NULL;\n+  if (init_control == nullptr || back_control == nullptr) {   \/\/ Partially dead\n+    return nullptr;\n@@ -381,1 +381,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -397,1 +397,1 @@\n-    return NULL; \/\/ Obscure back-control\n+    return nullptr; \/\/ Obscure back-control\n@@ -403,1 +403,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -422,1 +422,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -440,1 +440,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -443,1 +443,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -451,1 +451,1 @@\n-      return NULL; \/\/ Not simple trip counter expression\n+      return nullptr; \/\/ Not simple trip counter expression\n@@ -456,1 +456,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -469,1 +469,1 @@\n-      return NULL;             \/\/ Nope, unknown stride, bail out\n+      return nullptr;          \/\/ Nope, unknown stride, bail out\n@@ -480,1 +480,1 @@\n-    return NULL; \/\/ Too much math on the trip counter\n+    return nullptr; \/\/ Too much math on the trip counter\n@@ -482,2 +482,2 @@\n-  if (phi_incr != NULL && phi_incr != xphi) {\n-    return NULL;\n+  if (phi_incr != nullptr && phi_incr != xphi) {\n+    return nullptr;\n@@ -489,1 +489,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -569,1 +569,1 @@\n-    const TypePtr* no_memory_effects = NULL;\n+    const TypePtr* no_memory_effects = nullptr;\n@@ -574,2 +574,2 @@\n-    Node* mem = NULL;\n-    Node* i_o = NULL;\n+    Node* mem = nullptr;\n+    Node* i_o = nullptr;\n@@ -618,1 +618,1 @@\n-  SafePointNode* safepoint = NULL;\n+  SafePointNode* safepoint = nullptr;\n@@ -667,1 +667,1 @@\n-  SafePointNode* safepoint = NULL;\n+  SafePointNode* safepoint = nullptr;\n@@ -680,2 +680,2 @@\n-    if (safepoint == NULL) {\n-      return NULL;\n+    if (safepoint == nullptr) {\n+      return nullptr;\n@@ -689,1 +689,1 @@\n-    MergeMemNode* mm = NULL;\n+    MergeMemNode* mm = nullptr;\n@@ -702,1 +702,1 @@\n-      safepoint = NULL;\n+      safepoint = nullptr;\n@@ -704,1 +704,1 @@\n-      assert(mm == NULL|| _igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n+      assert(mm == nullptr|| _igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n@@ -707,1 +707,1 @@\n-    if (mm != NULL) {\n+    if (mm != nullptr) {\n@@ -766,1 +766,1 @@\n-  if (loop->_child != NULL || !x->is_LongCountedLoop() || x->as_Loop()->is_transformed_long_outer_loop()) {\n+  if (loop->_child != nullptr || !x->is_LongCountedLoop() || x->as_Loop()->is_transformed_long_outer_loop()) {\n@@ -863,1 +863,1 @@\n-  Node* inner_iters_max = NULL;\n+  Node* inner_iters_max = nullptr;\n@@ -891,1 +891,1 @@\n-  Node* inner_cmp = NULL;\n+  Node* inner_cmp = nullptr;\n@@ -949,1 +949,1 @@\n-  \/\/ long adjusted_limit = limit + stride;  \/\/because phi_incr != NULL\n+  \/\/ long adjusted_limit = limit + stride;  \/\/because phi_incr != nullptr\n@@ -985,1 +985,1 @@\n-  if (safepoint != NULL || !loop->_has_call) {\n+  if (safepoint != nullptr || !loop->_has_call) {\n@@ -992,1 +992,1 @@\n-  if (safepoint != NULL) {\n+  if (safepoint != nullptr) {\n@@ -1037,1 +1037,1 @@\n-  assert(back_control != NULL, \"no back control\");\n+  assert(back_control != nullptr, \"no back control\");\n@@ -1041,2 +1041,2 @@\n-  Node* incr = NULL;\n-  Node* limit = NULL;\n+  Node* incr = nullptr;\n+  Node* limit = nullptr;\n@@ -1045,1 +1045,1 @@\n-  assert(cmp != NULL && cmp->Opcode() == Op_CmpL, \"no exit test\");\n+  assert(cmp != nullptr && cmp->Opcode() == Op_CmpL, \"no exit test\");\n@@ -1047,1 +1047,1 @@\n-  Node* phi_incr = NULL;\n+  Node* phi_incr = nullptr;\n@@ -1049,1 +1049,1 @@\n-  assert(incr != NULL && incr->Opcode() == Op_AddL, \"no incr\");\n+  assert(incr != nullptr && incr->Opcode() == Op_AddL, \"no incr\");\n@@ -1051,1 +1051,1 @@\n-  Node* xphi = NULL;\n+  Node* xphi = nullptr;\n@@ -1054,1 +1054,1 @@\n-  assert(stride != NULL, \"no stride\");\n+  assert(stride != nullptr, \"no stride\");\n@@ -1058,1 +1058,1 @@\n-  assert(phi != NULL && phi->in(LoopNode::LoopBackControl) == incr, \"No phi\");\n+  assert(phi != nullptr && phi->in(LoopNode::LoopBackControl) == incr, \"No phi\");\n@@ -1065,1 +1065,1 @@\n-  assert(phi_incr == NULL, \"bad loop shape\");\n+  assert(phi_incr == nullptr, \"bad loop shape\");\n@@ -1091,1 +1091,1 @@\n-        Node* clone = new CmpLNode(NULL, NULL);\n+        Node* clone = new CmpLNode(nullptr, nullptr);\n@@ -1096,1 +1096,1 @@\n-        Node* clone = new AddLNode(NULL, NULL);\n+        Node* clone = new AddLNode(nullptr, nullptr);\n@@ -1111,1 +1111,1 @@\n-      if (in == NULL) {\n+      if (in == nullptr) {\n@@ -1124,1 +1124,1 @@\n-      if (clone != NULL) {\n+      if (clone != nullptr) {\n@@ -1136,1 +1136,1 @@\n-      if (in == NULL) {\n+      if (in == nullptr) {\n@@ -1140,1 +1140,1 @@\n-      if (in_clone == NULL) {\n+      if (in_clone == nullptr) {\n@@ -1146,1 +1146,1 @@\n-      if (in_clone->in(0) == NULL) {\n+      if (in_clone->in(0) == nullptr) {\n@@ -1149,1 +1149,1 @@\n-        in_clone->set_req(0, NULL);\n+        in_clone->set_req(0, nullptr);\n@@ -1162,1 +1162,1 @@\n-    Node* m = n->Opcode() == Op_CmpI ? clone : NULL;\n+    Node* m = n->Opcode() == Op_CmpI ? clone : nullptr;\n@@ -1168,1 +1168,1 @@\n-      if (m == NULL) {\n+      if (m == nullptr) {\n@@ -1187,1 +1187,1 @@\n-  if (back_control == NULL) {\n+  if (back_control == nullptr) {\n@@ -1193,2 +1193,2 @@\n-  Node* incr = NULL;\n-  Node* limit = NULL;\n+  Node* incr = nullptr;\n+  Node* limit = nullptr;\n@@ -1196,1 +1196,1 @@\n-  if (cmp == NULL || !(cmp->is_Cmp() && cmp->operates_on(iv_bt, true))) {\n+  if (cmp == nullptr || !(cmp->is_Cmp() && cmp->operates_on(iv_bt, true))) {\n@@ -1205,1 +1205,1 @@\n-  Node* phi_incr = NULL;\n+  Node* phi_incr = nullptr;\n@@ -1207,1 +1207,1 @@\n-  if (incr == NULL) {\n+  if (incr == nullptr) {\n@@ -1211,3 +1211,3 @@\n-  Node* trunc1 = NULL;\n-  Node* trunc2 = NULL;\n-  const TypeInteger* iv_trunc_t = NULL;\n+  Node* trunc1 = nullptr;\n+  Node* trunc2 = nullptr;\n+  const TypeInteger* iv_trunc_t = nullptr;\n@@ -1220,1 +1220,1 @@\n-  Node* xphi = NULL;\n+  Node* xphi = nullptr;\n@@ -1223,1 +1223,1 @@\n-  if (stride == NULL) {\n+  if (stride == nullptr) {\n@@ -1237,3 +1237,3 @@\n-  if (phi == NULL ||\n-      (trunc1 == NULL && phi->in(LoopNode::LoopBackControl) != incr) ||\n-      (trunc1 != NULL && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n+  if (phi == nullptr ||\n+      (trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != incr) ||\n+      (trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n@@ -1249,1 +1249,1 @@\n-  if (trunc1 != NULL) {\n+  if (trunc1 != nullptr) {\n@@ -1278,1 +1278,1 @@\n-    assert(trunc1 != NULL, \"must have found some truncation\");\n+    assert(trunc1 != nullptr, \"must have found some truncation\");\n@@ -1308,1 +1308,1 @@\n-    assert(trunc1 == NULL && trunc2 == NULL, \"no truncation for int\");\n+    assert(trunc1 == nullptr && trunc2 == nullptr, \"no truncation for int\");\n@@ -1327,1 +1327,1 @@\n-  if (phi_incr != NULL && bt != BoolTest::ne) {\n+  if (phi_incr != nullptr && bt != BoolTest::ne) {\n@@ -1370,1 +1370,1 @@\n-  if (phi_incr != NULL) {\n+  if (phi_incr != nullptr) {\n@@ -1471,2 +1471,2 @@\n-  Node* sfpt = NULL;\n-  if (loop->_child == NULL) {\n+  Node* sfpt = nullptr;\n+  if (loop->_child == nullptr) {\n@@ -1477,1 +1477,1 @@\n-      sfpt = NULL;\n+      sfpt = nullptr;\n@@ -1485,1 +1485,1 @@\n-        sfpt == NULL) {\n+        sfpt == nullptr) {\n@@ -1494,1 +1494,1 @@\n-      if (loop->_safepts != NULL) {\n+      if (loop->_safepts != nullptr) {\n@@ -1506,1 +1506,1 @@\n-      trunc1 == NULL &&\n+      trunc1 == nullptr &&\n@@ -1512,1 +1512,1 @@\n-  if (phi_incr != NULL) {\n+  if (phi_incr != nullptr) {\n@@ -1614,2 +1614,2 @@\n-                         loop->_child == NULL &&\n-                         sfpt != NULL &&\n+                         loop->_child == nullptr &&\n+                         sfpt != nullptr &&\n@@ -1617,1 +1617,1 @@\n-  IdealLoopTree* outer_ilt = NULL;\n+  IdealLoopTree* outer_ilt = nullptr;\n@@ -1641,1 +1641,1 @@\n-    if (sfpt != NULL && (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt))) {\n+    if (sfpt != nullptr && (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt))) {\n@@ -1663,1 +1663,1 @@\n-      if (loop->_safepts != NULL) {\n+      if (loop->_safepts != nullptr) {\n@@ -1718,1 +1718,1 @@\n-  Node *limit = NULL;\n+  Node *limit = nullptr;\n@@ -1741,1 +1741,1 @@\n-  assert(limit != NULL, \"sanity\");\n+  assert(limit != nullptr, \"sanity\");\n@@ -1757,2 +1757,2 @@\n-  const OuterStripMinedLoopNode* outer = NULL;\n-  const CountedLoopNode* inner = NULL;\n+  const OuterStripMinedLoopNode* outer = nullptr;\n+  const CountedLoopNode* inner = nullptr;\n@@ -1772,2 +1772,2 @@\n-  if (inner != NULL || outer != NULL) {\n-    assert(inner != NULL && outer != NULL, \"missing loop in strip mined nest\");\n+  if (inner != nullptr || outer != nullptr) {\n+    assert(inner != nullptr && outer != nullptr, \"missing loop in strip mined nest\");\n@@ -1882,1 +1882,1 @@\n-    return NULL;  \/\/ Identity\n+    return nullptr;  \/\/ Identity\n@@ -1907,1 +1907,1 @@\n-    return NULL;  \/\/ Dead\n+    return nullptr;  \/\/ Dead\n@@ -1911,1 +1911,1 @@\n-    return NULL;  \/\/ Identity\n+    return nullptr;  \/\/ Identity\n@@ -1914,1 +1914,1 @@\n-    return NULL;  \/\/ Value\n+    return nullptr;  \/\/ Value\n@@ -1919,1 +1919,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1981,1 +1981,1 @@\n-  return NULL;    \/\/ No progress\n+  return nullptr;    \/\/ No progress\n@@ -1997,1 +1997,1 @@\n-\/\/ Return NULL for failure. Success returns the increment node.\n+\/\/ Return null for failure. Success returns the increment node.\n@@ -2002,1 +2002,1 @@\n-  if (expr == NULL || expr->req() != 3)  return NULL;\n+  if (expr == nullptr || expr->req() != 3)  return nullptr;\n@@ -2004,2 +2004,2 @@\n-  Node *t1 = NULL;\n-  Node *t2 = NULL;\n+  Node *t1 = nullptr;\n+  Node *t2 = nullptr;\n@@ -2021,1 +2021,1 @@\n-               n1->in(1) != NULL &&\n+               n1->in(1) != nullptr &&\n@@ -2050,1 +2050,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2054,1 +2054,1 @@\n-  if (is_strip_mined() && in(EntryControl) != NULL && in(EntryControl)->is_OuterStripMinedLoop()) {\n+  if (is_strip_mined() && in(EntryControl) != nullptr && in(EntryControl)->is_OuterStripMinedLoop()) {\n@@ -2064,2 +2064,2 @@\n-  if (c == NULL || c->is_top() || !c->is_OuterStripMinedLoop()) {\n-    return NULL;\n+  if (c == nullptr || c->is_top() || !c->is_OuterStripMinedLoop()) {\n+    return nullptr;\n@@ -2072,2 +2072,2 @@\n-  if (c == NULL || c->is_top()) {\n-    return NULL;\n+  if (c == nullptr || c->is_top()) {\n+    return nullptr;\n@@ -2080,2 +2080,2 @@\n-  if (l == NULL) {\n-    return NULL;\n+  if (l == nullptr) {\n+    return nullptr;\n@@ -2088,2 +2088,2 @@\n-  if (proj == NULL) {\n-    return NULL;\n+  if (proj == nullptr) {\n+    return nullptr;\n@@ -2092,2 +2092,2 @@\n-  if (c == NULL || c->is_top() || c->outcnt() != 2) {\n-    return NULL;\n+  if (c == nullptr || c->is_top() || c->outcnt() != 2) {\n+    return nullptr;\n@@ -2100,2 +2100,2 @@\n-  if (l == NULL) {\n-    return NULL;\n+  if (l == nullptr) {\n+    return nullptr;\n@@ -2108,2 +2108,2 @@\n-  if (le == NULL) {\n-    return NULL;\n+  if (le == nullptr) {\n+    return nullptr;\n@@ -2112,2 +2112,2 @@\n-  if (c == NULL) {\n-    return NULL;\n+  if (c == nullptr) {\n+    return nullptr;\n@@ -2120,2 +2120,2 @@\n-  if (l == NULL) {\n-    return NULL;\n+  if (l == nullptr) {\n+    return nullptr;\n@@ -2128,2 +2128,2 @@\n-  if (le == NULL) {\n-    return NULL;\n+  if (le == nullptr) {\n+    return nullptr;\n@@ -2132,2 +2132,2 @@\n-  if (c == NULL || c->is_top()) {\n-    return NULL;\n+  if (c == nullptr || c->is_top()) {\n+    return nullptr;\n@@ -2141,2 +2141,2 @@\n-  if (l == NULL) {\n-    return NULL;\n+  if (l == nullptr) {\n+    return nullptr;\n@@ -2148,2 +2148,2 @@\n-    while (ctrl != NULL && ctrl->is_Proj() && ctrl->in(0) != NULL && ctrl->in(0)->is_If() &&\n-            (ctrl->in(0)->as_If()->proj_out_or_null(1-ctrl->as_Proj()->_con) == NULL ||\n+    while (ctrl != nullptr && ctrl->is_Proj() && ctrl->in(0) != nullptr && ctrl->in(0)->is_If() &&\n+            (ctrl->in(0)->as_If()->proj_out_or_null(1-ctrl->as_Proj()->_con) == nullptr ||\n@@ -2172,1 +2172,1 @@\n-  return cle != NULL ? cle->stride_con() : 0;\n+  return cle != nullptr ? cle->stride_con() : 0;\n@@ -2177,1 +2177,1 @@\n-  return cle != NULL ? cle->stride_con() : 0;\n+  return cle != nullptr ? cle->stride_con() : 0;\n@@ -2196,1 +2196,1 @@\n-  if (inner_iv_phi == NULL) {\n+  if (inner_iv_phi == nullptr) {\n@@ -2268,1 +2268,1 @@\n-        if (n->in(i) != NULL && old_new[n->in(i)->_idx] != NULL) {\n+        if (n->in(i) != nullptr && old_new[n->in(i)->_idx] != nullptr) {\n@@ -2272,1 +2272,1 @@\n-      if (n->in(0) != NULL && n->in(0) == cle_tail) {\n+      if (n->in(0) != nullptr && n->in(0) == cle_tail) {\n@@ -2279,1 +2279,1 @@\n-  Node* iv_phi = NULL;\n+  Node* iv_phi = nullptr;\n@@ -2289,1 +2289,1 @@\n-      if (be != NULL) {\n+      if (be != nullptr) {\n@@ -2316,1 +2316,1 @@\n-          Node* next = NULL;\n+          Node* next = nullptr;\n@@ -2320,1 +2320,1 @@\n-              assert(next == NULL, \"only one in the outer loop\");\n+              assert(next == nullptr, \"only one in the outer loop\");\n@@ -2324,1 +2324,1 @@\n-          if (next == NULL) {\n+          if (next == nullptr) {\n@@ -2329,1 +2329,1 @@\n-        Node* phi = NULL;\n+        Node* phi = nullptr;\n@@ -2334,1 +2334,1 @@\n-            if (be->is_Store() && old_new[be->_idx] != NULL) {\n+            if (be->is_Store() && old_new[be->_idx] != nullptr) {\n@@ -2344,1 +2344,1 @@\n-              assert(phi == NULL, \"only one phi\");\n+              assert(phi == nullptr, \"only one phi\");\n@@ -2381,1 +2381,1 @@\n-        if (phi == NULL) {\n+        if (phi == nullptr) {\n@@ -2394,1 +2394,1 @@\n-          assert(!(be->is_Store() && old_new[be->_idx] != NULL), \"store on the backedge + sunk stores: unsupported\");\n+          assert(!(be->is_Store() && old_new[be->_idx] != nullptr), \"store on the backedge + sunk stores: unsupported\");\n@@ -2415,1 +2415,1 @@\n-  if (iv_phi != NULL) {\n+  if (iv_phi != nullptr) {\n@@ -2422,1 +2422,1 @@\n-    Node* max = NULL;\n+    Node* max = nullptr;\n@@ -2436,1 +2436,1 @@\n-    Node* new_limit = NULL;\n+    Node* new_limit = nullptr;\n@@ -2479,1 +2479,1 @@\n-    if (backedge != NULL) {\n+    if (backedge != nullptr) {\n@@ -2481,2 +2481,2 @@\n-      if (head != NULL && head->is_OuterStripMinedLoop()) {\n-        if (head->find_out_with(Op_Phi) != NULL) {\n+      if (head != nullptr && head->is_OuterStripMinedLoop()) {\n+        if (head->find_out_with(Op_Phi) != nullptr) {\n@@ -2494,1 +2494,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2515,1 +2515,1 @@\n-  const TypeInt* filtered_t = NULL;\n+  const TypeInt* filtered_t = nullptr;\n@@ -2517,1 +2517,1 @@\n-    assert(n_ctrl != NULL || n_ctrl == C->top(), \"valid control\");\n+    assert(n_ctrl != nullptr || n_ctrl == C->top(), \"valid control\");\n@@ -2523,1 +2523,1 @@\n-    assert(n_ctrl == NULL || n_ctrl == region, \"ctrl parameter must be region\");\n+    assert(n_ctrl == nullptr || n_ctrl == region, \"ctrl parameter must be region\");\n@@ -2529,2 +2529,2 @@\n-        if (val_t != NULL) {\n-          if (filtered_t == NULL) {\n+        if (val_t != nullptr) {\n+          if (filtered_t == nullptr) {\n@@ -2540,1 +2540,1 @@\n-  if (filtered_t != NULL) {\n+  if (filtered_t != nullptr) {\n@@ -2554,1 +2554,1 @@\n-  const TypeInt* rtn_t = NULL;\n+  const TypeInt* rtn_t = nullptr;\n@@ -2565,2 +2565,2 @@\n-        if (if_t != NULL) {\n-          if (rtn_t == NULL) {\n+        if (if_t != nullptr) {\n+          if (rtn_t == nullptr) {\n@@ -2574,1 +2574,1 @@\n-      if (pred == NULL || pred == C->top()) {\n+      if (pred == nullptr || pred == C->top()) {\n@@ -2591,1 +2591,1 @@\n-  if( in(TestValue) != NULL && in(TestValue)->is_Bool() ) {\n+  if( in(TestValue) != nullptr && in(TestValue)->is_Bool() ) {\n@@ -2775,1 +2775,1 @@\n-      if ((data == NULL) || !data->is_CounterData()) {\n+      if ((data == nullptr) || !data->is_CounterData()) {\n@@ -2830,1 +2830,1 @@\n-  Node *hot_tail = NULL;\n+  Node *hot_tail = nullptr;\n@@ -2850,1 +2850,1 @@\n-      Node *hot_phi = NULL;\n+      Node *hot_phi = nullptr;\n@@ -2897,1 +2897,1 @@\n-        ilt->_head = NULL;      \/\/ Flag as a loop UNIONED into parent\n+        ilt->_head = nullptr;   \/\/ Flag as a loop UNIONED into parent\n@@ -3011,1 +3011,1 @@\n-        if (_required_safept == NULL) _required_safept = new Node_List();\n+        if (_required_safept == nullptr) _required_safept = new Node_List();\n@@ -3089,4 +3089,4 @@\n-  if (!_head->is_CountedLoop() && !_has_sfpt && _parent != NULL && !_irreducible) {\n-    bool  has_call         = false; \/\/ call on dom-path\n-    bool  has_local_ncsfpt = false; \/\/ ncsfpt on dom-path at this loop depth\n-    Node* nonlocal_ncsfpt  = NULL;  \/\/ ncsfpt on dom-path at a deeper depth\n+  if (!_head->is_CountedLoop() && !_has_sfpt && _parent != nullptr && !_irreducible) {\n+    bool  has_call         = false;    \/\/ call on dom-path\n+    bool  has_local_ncsfpt = false;    \/\/ ncsfpt on dom-path at this loop depth\n+    Node* nonlocal_ncsfpt  = nullptr;  \/\/ ncsfpt on dom-path at a deeper depth\n@@ -3104,1 +3104,1 @@\n-        if (nonlocal_ncsfpt == NULL) {\n+        if (nonlocal_ncsfpt == nullptr) {\n@@ -3132,3 +3132,3 @@\n-    if (_child != NULL && !has_call && !has_local_ncsfpt) {\n-      if (nonlocal_ncsfpt != NULL) {\n-        if (_required_safept == NULL) _required_safept = new Node_List();\n+    if (_child != nullptr && !has_call && !has_local_ncsfpt) {\n+      if (nonlocal_ncsfpt != nullptr) {\n+        if (_required_safept == nullptr) _required_safept = new Node_List();\n@@ -3150,1 +3150,1 @@\n-  while (lp != NULL) {\n+  while (lp != nullptr) {\n@@ -3152,1 +3152,1 @@\n-    if (sfpts != NULL) {\n+    if (sfpts != nullptr) {\n@@ -3171,1 +3171,1 @@\n-  if (incr == NULL)\n+  if (incr == nullptr)\n@@ -3254,1 +3254,1 @@\n-  Node* keep = NULL;\n+  Node* keep = nullptr;\n@@ -3268,1 +3268,1 @@\n-  bool prune = !keep_one || keep != NULL;\n+  bool prune = !keep_one || keep != nullptr;\n@@ -3272,2 +3272,2 @@\n-  if (prune && sfpts != NULL) {\n-    assert(keep == NULL || keep->Opcode() == Op_SafePoint, \"not safepoint\");\n+  if (prune && sfpts != nullptr) {\n+    assert(keep == nullptr || keep->Opcode() == Op_SafePoint, \"not safepoint\");\n@@ -3313,1 +3313,1 @@\n-    if (_parent != NULL && !_irreducible) {\n+    if (_parent != nullptr && !_irreducible) {\n@@ -3322,1 +3322,1 @@\n-  assert(loop->_child != this || (loop->_child->_child == NULL && loop->_child->_next == NULL), \"would miss some loops\");\n+  assert(loop->_child != this || (loop->_child->_child == nullptr && loop->_child->_next == nullptr), \"would miss some loops\");\n@@ -3388,1 +3388,1 @@\n-      if (out == NULL) continue;\n+      if (out == nullptr) continue;\n@@ -3395,1 +3395,1 @@\n-        assert(ctrl != NULL, \"must be\");\n+        assert(ctrl != nullptr, \"must be\");\n@@ -3421,1 +3421,1 @@\n-  if (predicate != NULL ) {\n+  if (predicate != nullptr ) {\n@@ -3427,1 +3427,1 @@\n-    if (predicate != NULL) {\n+    if (predicate != nullptr) {\n@@ -3434,1 +3434,1 @@\n-    if (predicate != NULL) {\n+    if (predicate != nullptr) {\n@@ -3443,1 +3443,1 @@\n-    if (init_n  != NULL &&  init_n->is_Con())\n+    if (init_n  != nullptr &&  init_n->is_Con())\n@@ -3448,1 +3448,1 @@\n-    if (limit_n  != NULL &&  limit_n->is_Con())\n+    if (limit_n  != nullptr &&  limit_n->is_Con())\n@@ -3468,1 +3468,1 @@\n-  if (_safepts != NULL && _safepts->size() > 0) {\n+  if (_safepts != nullptr && _safepts->size() > 0) {\n@@ -3471,1 +3471,1 @@\n-  if (_required_safept != NULL && _required_safept->size() > 0) {\n+  if (_required_safept != nullptr && _required_safept->size() > 0) {\n@@ -3495,1 +3495,1 @@\n-    if (loop->_child != NULL) {\n+    if (loop->_child != nullptr) {\n@@ -3500,1 +3500,1 @@\n-      assert(loop->_next == NULL, \"what?\");\n+      assert(loop->_next == nullptr, \"what?\");\n@@ -3502,1 +3502,1 @@\n-  } else if (loop != NULL) {\n+  } else if (loop != nullptr) {\n@@ -3524,1 +3524,1 @@\n-  if (C->log() != NULL) {\n+  if (C->log() != nullptr) {\n@@ -3545,1 +3545,1 @@\n-    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+    if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -3552,1 +3552,1 @@\n-      if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+      if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -3561,1 +3561,1 @@\n-      if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+      if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n@@ -3702,1 +3702,1 @@\n-  for (IdealLoopTree* l = _ltree_root->_child; l != NULL; l = l->_next) {\n+  for (IdealLoopTree* l = _ltree_root->_child; l != nullptr; l = l->_next) {\n@@ -3744,1 +3744,1 @@\n-  _nodes.map(C->unique(), NULL);\n+  _nodes.map(C->unique(), nullptr);\n@@ -3755,3 +3755,3 @@\n-  _idom      = NULL;\n-  _dom_depth = NULL;\n-  _dom_stk   = NULL;\n+  _idom      = nullptr;\n+  _dom_depth = nullptr;\n+  _dom_stk   = nullptr;\n@@ -3776,1 +3776,1 @@\n-  assert(_ltree_root->_child == NULL || C->has_loops() || only_has_infinite_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n+  assert(_ltree_root->_child == nullptr || C->has_loops() || only_has_infinite_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n@@ -3809,1 +3809,1 @@\n-      _ltree_root->_child = NULL;\n+      _ltree_root->_child = nullptr;\n@@ -3824,1 +3824,1 @@\n-  \/\/ Build Dominators for elision of NULL checks & loop finding.\n+  \/\/ Build Dominators for elision of null checks & loop finding.\n@@ -3830,1 +3830,1 @@\n-  _dom_stk   = NULL; \/\/ Allocated on demand in recompute_dom_depth\n+  _dom_stk   = nullptr; \/\/ Allocated on demand in recompute_dom_depth\n@@ -4136,1 +4136,1 @@\n-  _ltree_root->verify_tree(loop_verify._ltree_root, NULL);\n+  _ltree_root->verify_tree(loop_verify._ltree_root, nullptr);\n@@ -4295,2 +4295,2 @@\n-  if (_child != NULL)  _child->verify_tree(loop->_child, this);\n-  if (_next  != NULL)  _next ->verify_tree(loop->_next,  parent);\n+  if (_child != nullptr)  _child->verify_tree(loop->_child, this);\n+  if (_next  != nullptr)  _next ->verify_tree(loop->_next,  parent);\n@@ -4300,1 +4300,1 @@\n-  if (!Compile::current()->major_progress() && _child == NULL) {\n+  if (!Compile::current()->major_progress() && _child == nullptr) {\n@@ -4368,2 +4368,2 @@\n-    \/\/ Only indices with a _dom_depth has a Node* or NULL (otherwise uninitalized).\n-    if (_dom_depth[i] > 0 && _idom[i] != NULL) {\n+    \/\/ Only indices with a _dom_depth has a Node* or nullptr (otherwise uninitalized).\n+    if (_dom_depth[i] > 0 && _idom[i] != nullptr) {\n@@ -4373,1 +4373,1 @@\n-      if (_idom[i]->in(0) == NULL) {\n+      if (_idom[i]->in(0) == nullptr) {\n@@ -4378,1 +4378,1 @@\n-  if (_dom_stk == NULL) {\n+  if (_dom_stk == nullptr) {\n@@ -4443,1 +4443,1 @@\n-\/\/ bits.  The _nodes[] array is mapped by Node index and holds a NULL for\n+\/\/ bits.  The _nodes[] array is mapped by Node index and holds a null for\n@@ -4543,1 +4543,1 @@\n-  IdealLoopTree *innermost = NULL;\n+  IdealLoopTree *innermost = nullptr;\n@@ -4600,1 +4600,1 @@\n-          Node* cfg = NULL;       \/\/ Find the One True Control User of m\n+          Node* cfg = nullptr;       \/\/ Find the One True Control User of m\n@@ -4606,1 +4606,1 @@\n-          assert(cfg != NULL, \"must find the control user of m\");\n+          assert(cfg != nullptr, \"must find the control user of m\");\n@@ -4640,1 +4640,1 @@\n-        if (l == NULL) {\n+        if (l == nullptr) {\n@@ -4701,1 +4701,1 @@\n-        if (innermost->_safepts == NULL) innermost->_safepts = new Node_List();\n+        if (innermost->_safepts == nullptr) innermost->_safepts = new Node_List();\n@@ -4736,1 +4736,1 @@\n-          \/\/ dead loops to NULL and the _parent field points to the owning\n+          \/\/ dead loops to null and the _parent field points to the owning\n@@ -4753,1 +4753,1 @@\n-            if (ilt->_safepts != NULL) {\n+            if (ilt->_safepts != nullptr) {\n@@ -4775,1 +4775,1 @@\n-        if (in == NULL) continue;\n+        if (in == nullptr) continue;\n@@ -4822,1 +4822,1 @@\n-  if( !n1 ) return n2;          \/\/ Handle NULL original LCA\n+  if( !n1 ) return n2;          \/\/ Handle null original LCA\n@@ -4867,1 +4867,1 @@\n-  Node *LCA = NULL;\n+  Node *LCA = nullptr;\n@@ -4899,1 +4899,1 @@\n-  Node *LCA = NULL;\n+  Node *LCA = nullptr;\n@@ -4902,1 +4902,1 @@\n-    if (_nodes[c->_idx] == NULL)\n+    if (_nodes[c->_idx] == nullptr)\n@@ -4936,1 +4936,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4940,2 +4940,2 @@\n-  if (ctrl == NULL || (!ctrl->is_IfTrue() && !ctrl->is_IfFalse())) {\n-    return NULL;\n+  if (ctrl == nullptr || (!ctrl->is_IfTrue() && !ctrl->is_IfFalse())) {\n+    return nullptr;\n@@ -4944,2 +4944,2 @@\n-  if (iffm == NULL || !iffm->is_If()) {\n-    return NULL;\n+  if (iffm == nullptr || !iffm->is_If()) {\n+    return nullptr;\n@@ -4948,2 +4948,2 @@\n-  if (bolzm == NULL || !bolzm->is_Bool()) {\n-    return NULL;\n+  if (bolzm == nullptr || !bolzm->is_Bool()) {\n+    return nullptr;\n@@ -4952,2 +4952,2 @@\n-  if (cmpzm == NULL || !cmpzm->is_Cmp()) {\n-    return NULL;\n+  if (cmpzm == nullptr || !cmpzm->is_Cmp()) {\n+    return nullptr;\n@@ -4957,2 +4957,2 @@\n-  if (input >= cmpzm->req() || cmpzm->in(input) == NULL) {\n-    return NULL;\n+  if (input >= cmpzm->req() || cmpzm->in(input) == nullptr) {\n+    return nullptr;\n@@ -4972,1 +4972,1 @@\n-  return res ? cmpzm->in(input) : NULL;\n+  return res ? cmpzm->in(input) : nullptr;\n@@ -4978,1 +4978,1 @@\n-  assert(early != NULL, \"early control should not be NULL\");\n+  assert(early != nullptr, \"early control should not be null\");\n@@ -5025,2 +5025,2 @@\n-        assert(sctrl != NULL || !s->is_reachable_from_root(), \"must have control\");\n-        if (sctrl != NULL && !sctrl->is_top() && is_dominator(early, sctrl)) {\n+        assert(sctrl != nullptr || !s->is_reachable_from_root(), \"must have control\");\n+        if (sctrl != nullptr && !sctrl->is_top() && is_dominator(early, sctrl)) {\n@@ -5183,1 +5183,1 @@\n-        if( _nodes[use->_idx] != NULL || use->is_top() ) { \/\/ Not dead?\n+        if( _nodes[use->_idx] != nullptr || use->is_top() ) { \/\/ Not dead?\n@@ -5242,1 +5242,1 @@\n-        if (nn != NULL && has_ctrl(nn) && get_loop(get_ctrl(nn)) == loop) {\n+        if (nn != nullptr && has_ctrl(nn) && get_loop(get_ctrl(nn)) == loop) {\n@@ -5333,2 +5333,2 @@\n-  \/\/ LCA is NULL due to uses being dead\n-  if( LCA == NULL ) {\n+  \/\/ LCA is null due to uses being dead\n+  if( LCA == nullptr ) {\n@@ -5337,1 +5337,1 @@\n-      assert( _nodes[n->out(i1)->_idx] == NULL, \"all uses must also be dead\");\n+      assert( _nodes[n->out(i1)->_idx] == nullptr, \"all uses must also be dead\");\n@@ -5344,1 +5344,1 @@\n-  assert(LCA != NULL && !LCA->is_top(), \"no dead nodes\");\n+  assert(LCA != nullptr && !LCA->is_top(), \"no dead nodes\");\n@@ -5374,1 +5374,1 @@\n-      if (call == NULL) {\n+      if (call == nullptr) {\n@@ -5442,1 +5442,1 @@\n-  if (n->in(0) != NULL  && !n->in(0)->is_top() &&\n+  if (n->in(0) != nullptr  && !n->in(0)->is_top() &&\n@@ -5448,1 +5448,1 @@\n-    if (in1 != NULL && in1 != n && !in1->is_top()) {\n+    if (in1 != nullptr && in1 != n && !in1->is_top()) {\n@@ -5452,1 +5452,1 @@\n-      if (in1->in(0) != NULL     && !in1->in(0)->is_top() &&\n+      if (in1->in(0) != nullptr     && !in1->in(0)->is_top() &&\n@@ -5458,1 +5458,1 @@\n-        if (in2 != NULL && in2 != n && in2 != in1 && !in2->is_top()) {\n+        if (in2 != nullptr && in2 != n && in2 != in1 && !in2->is_top()) {\n@@ -5462,1 +5462,1 @@\n-          if (in2->in(0) != NULL     && !in2->in(0)->is_top() &&\n+          if (in2->in(0) != nullptr     && !in2->in(0)->is_top() &&\n@@ -5487,1 +5487,1 @@\n-      if (u1->in(0) != NULL     && !u1->in(0)->is_top() &&\n+      if (u1->in(0) != nullptr     && !u1->in(0)->is_top() &&\n@@ -5499,1 +5499,1 @@\n-          if (u2->in(0) != NULL     && !u2->in(0)->is_top() &&\n+          if (u2->in(0) != nullptr     && !u2->in(0)->is_top() &&\n@@ -5651,1 +5651,1 @@\n-                          _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : NULL);\n+                          _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : nullptr);\n@@ -5725,1 +5725,1 @@\n-  if (_curnt->_child != NULL) {\n+  if (_curnt->_child != nullptr) {\n@@ -5727,1 +5727,1 @@\n-  } else if (_curnt->_next != NULL) {\n+  } else if (_curnt->_next != nullptr) {\n@@ -5730,1 +5730,1 @@\n-    while (_curnt != _root && _curnt->_next == NULL) {\n+    while (_curnt != _root && _curnt->_next == nullptr) {\n@@ -5734,1 +5734,1 @@\n-      _curnt = NULL;\n+      _curnt = nullptr;\n@@ -5737,1 +5737,1 @@\n-      assert(_curnt->_next != NULL, \"must be more to do\");\n+      assert(_curnt->_next != nullptr, \"must be more to do\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":276,"deletions":276,"binary":false,"changes":552,"status":"modified"},{"patch":"@@ -152,3 +152,3 @@\n-    return req() == 3 && in(0) != NULL &&\n-      in(1) != NULL && phase->type(in(1)) != Type::TOP &&\n-      in(2) != NULL && phase->type(in(2)) != Type::TOP;\n+    return req() == 3 && in(0) != nullptr &&\n+      in(1) != nullptr && phase->type(in(1)) != Type::TOP &&\n+      in(2) != nullptr && phase->type(in(2)) != Type::TOP;\n@@ -163,4 +163,4 @@\n-  virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return NULL; }\n-  virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return NULL; }\n-  virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return NULL; }\n-  virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return NULL; }\n+  virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return nullptr; }\n+  virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return nullptr; }\n+  virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return nullptr; }\n+  virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return nullptr; }\n@@ -396,6 +396,6 @@\n-  Node *cmp_node() const            { return (in(TestValue)->req() >=2) ? in(TestValue)->in(1) : NULL; }\n-  Node* incr() const                { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n-  Node* limit() const               { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n-  Node* stride() const              { Node* tmp = incr(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n-  Node* init_trip() const           { Node* tmp = phi(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n-  bool stride_is_con() const        { Node *tmp = stride(); return (tmp != NULL && tmp->is_Con()); }\n+  Node *cmp_node() const            { return (in(TestValue)->req() >=2) ? in(TestValue)->in(1) : nullptr; }\n+  Node* incr() const                { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(1) : nullptr; }\n+  Node* limit() const               { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(2) : nullptr; }\n+  Node* stride() const              { Node* tmp = incr(); return (tmp && tmp->req() == 3) ? tmp->in(2) : nullptr; }\n+  Node* init_trip() const           { Node* tmp = phi(); return (tmp && tmp->req() == 3) ? tmp->in(1) : nullptr; }\n+  bool stride_is_con() const        { Node *tmp = stride(); return (tmp != nullptr && tmp->is_Con()); }\n@@ -411,1 +411,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -419,2 +419,2 @@\n-    if (iv_phi == NULL) {\n-      return NULL;\n+    if (iv_phi == nullptr) {\n+      return nullptr;\n@@ -424,1 +424,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -427,1 +427,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -494,1 +494,1 @@\n-  if (bctrl == NULL) return NULL;\n+  if (bctrl == nullptr) return nullptr;\n@@ -498,1 +498,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -502,1 +502,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -509,1 +509,1 @@\n-  assert(cle != NULL, \"loopexit is NULL\");\n+  assert(cle != nullptr, \"loopexit is nullptr\");\n@@ -515,1 +515,1 @@\n-  return cle != NULL ? cle->init_trip() : NULL;\n+  return cle != nullptr ? cle->init_trip() : nullptr;\n@@ -519,1 +519,1 @@\n-  return cle != NULL ? cle->stride() : NULL;\n+  return cle != nullptr ? cle->stride() : nullptr;\n@@ -524,1 +524,1 @@\n-  return cle != NULL && cle->stride_is_con();\n+  return cle != nullptr && cle->stride_is_con();\n@@ -528,1 +528,1 @@\n-  return cle != NULL ? cle->limit() : NULL;\n+  return cle != nullptr ? cle->limit() : nullptr;\n@@ -532,1 +532,1 @@\n-  return cle != NULL ? cle->incr() : NULL;\n+  return cle != nullptr ? cle->incr() : nullptr;\n@@ -536,1 +536,1 @@\n-  return cle != NULL ? cle->phi() : NULL;\n+  return cle != nullptr ? cle->phi() : nullptr;\n@@ -635,2 +635,2 @@\n-      _safepts(NULL),\n-      _required_safept(NULL),\n+      _safepts(nullptr),\n+      _required_safept(nullptr),\n@@ -639,2 +639,2 @@\n-    precond(_head != NULL);\n-    precond(_tail != NULL);\n+    precond(_head != nullptr);\n+    precond(_tail != nullptr);\n@@ -764,1 +764,1 @@\n-  bool is_associative(Node* n, Node* base=NULL);\n+  bool is_associative(Node* n, Node* base=nullptr);\n@@ -772,1 +772,1 @@\n-  bool is_root() { return _parent == NULL; }\n+  bool is_root() { return _parent == nullptr; }\n@@ -776,1 +776,1 @@\n-  bool is_innermost() { return is_loop() && _child == NULL; }\n+  bool is_innermost() { return is_loop() && _child == nullptr; }\n@@ -886,2 +886,2 @@\n-    \/\/ Fast-path NULL lca\n-    if( lca != NULL && lca != n ) {\n+    \/\/ Fast-path null lca\n+    if( lca != nullptr && lca != n ) {\n@@ -898,1 +898,1 @@\n-    if (ctrl != NULL) {\n+    if (ctrl != nullptr) {\n@@ -939,2 +939,2 @@\n-    guarantee(n != NULL, \"No Node.\");\n-    return _nodes[n->_idx] != NULL;\n+    guarantee(n != nullptr, \"No Node.\");\n+    return _nodes[n->_idx] != nullptr;\n@@ -959,2 +959,2 @@\n-      if (old_loop->_child == NULL) old_loop->_body.yank(n);\n-      if (new_loop->_child == NULL) new_loop->_body.push(n);\n+      if (old_loop->_child == nullptr) old_loop->_body.yank(n);\n+      if (new_loop->_child == nullptr) new_loop->_body.push(n);\n@@ -1097,2 +1097,2 @@\n-    assert(n != NULL,\"Bad immediate dominator info.\");\n-    while (n->in(0) == NULL) { \/\/ Skip dead CFG nodes\n+    assert(n != nullptr,\"Bad immediate dominator info.\");\n+    while (n->in(0) == nullptr) { \/\/ Skip dead CFG nodes\n@@ -1100,1 +1100,1 @@\n-      assert(n != NULL,\"Bad immediate dominator info.\");\n+      assert(n != nullptr,\"Bad immediate dominator info.\");\n@@ -1116,1 +1116,1 @@\n-    guarantee(d != NULL, \"Null dominator info.\");\n+    guarantee(d != nullptr, \"Null dominator info.\");\n@@ -1166,1 +1166,1 @@\n-  virtual Node* transform(Node* n) { return NULL; }\n+  virtual Node* transform(Node* n) { return nullptr; }\n@@ -1213,1 +1213,1 @@\n-  \/\/   When side_by_size_idom is NULL, the dominator tree is constructed for\n+  \/\/   When side_by_size_idom is null, the dominator tree is constructed for\n@@ -1228,1 +1228,1 @@\n-                  CloneLoopMode mode, Node* side_by_side_idom = NULL);\n+                  CloneLoopMode mode, Node* side_by_side_idom = nullptr);\n@@ -1494,1 +1494,1 @@\n-  const TypeInt* filtered_type( Node *n ) { return filtered_type(n, NULL); }\n+  const TypeInt* filtered_type( Node *n ) { return filtered_type(n, nullptr); }\n@@ -1661,1 +1661,1 @@\n-    precond(_phase != NULL);\n+    precond(_phase != nullptr);\n@@ -1760,1 +1760,1 @@\n-  if (_tail->in(0) == NULL) {\n+  if (_tail->in(0) == nullptr) {\n@@ -1768,1 +1768,1 @@\n-  if (_head->in(0) == NULL) {\n+  if (_head->in(0) == nullptr) {\n@@ -1790,1 +1790,1 @@\n-  bool done() { return _curnt == NULL; }       \/\/ Finished iterating?\n+  bool done() { return _curnt == nullptr; }       \/\/ Finished iterating?\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":54,"deletions":54,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -61,1 +61,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -65,1 +65,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -75,1 +75,1 @@\n-  if (t_oop != NULL && t_oop->is_known_instance_field()) {\n+  if (t_oop != nullptr && t_oop->is_known_instance_field()) {\n@@ -79,1 +79,1 @@\n-    phi = new PhiNode(region, type, NULL, iid, index, offset);\n+    phi = new PhiNode(region, type, nullptr, iid, index, offset);\n@@ -86,1 +86,1 @@\n-    Node* the_clone = NULL;\n+    Node* the_clone = nullptr;\n@@ -151,1 +151,1 @@\n-    if (x != the_clone && the_clone != NULL)\n+    if (x != the_clone && the_clone != nullptr)\n@@ -158,1 +158,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -179,2 +179,2 @@\n-      old_ctrl = NULL;\n-      old_loop = NULL;               \/\/ Not in any prior loop\n+      old_ctrl = nullptr;\n+      old_loop = nullptr;               \/\/ Not in any prior loop\n@@ -197,1 +197,1 @@\n-        (old_loop == NULL || !new_loop->is_member(old_loop))) {\n+        (old_loop == nullptr || !new_loop->is_member(old_loop))) {\n@@ -239,1 +239,1 @@\n-  assert(n->in(0) == NULL, \"divisions with zero check should already have bailed out earlier in split-if\");\n+  assert(n->in(0) == nullptr, \"divisions with zero check should already have bailed out earlier in split-if\");\n@@ -296,1 +296,1 @@\n-  if (dp == NULL)\n+  if (dp == nullptr)\n@@ -302,3 +302,3 @@\n-      (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) != NULL)) {\n+      (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n+       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr ||\n+       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) != nullptr)) {\n@@ -349,1 +349,1 @@\n-    return NULL;                \/\/ No Phi inputs; nowhere to clone thru\n+    return nullptr;                \/\/ No Phi inputs; nowhere to clone thru\n@@ -375,1 +375,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -388,1 +388,1 @@\n-  if (!has_ctrl(n))  return NULL;\n+  if (!has_ctrl(n))  return nullptr;\n@@ -396,1 +396,1 @@\n-  if( n->req() < 3 || n->req() > 4 ) return NULL;\n+  if( n->req() < 3 || n->req() > 4 ) return nullptr;\n@@ -409,1 +409,1 @@\n-    return NULL;                \/\/ Leave well enough alone\n+    return nullptr;                \/\/ Leave well enough alone\n@@ -415,1 +415,1 @@\n-    return NULL;                \/\/ No loop-invariant inputs\n+    return nullptr;                \/\/ No loop-invariant inputs\n@@ -427,1 +427,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -430,1 +430,1 @@\n-      return NULL;              \/\/ Dont bother with byte\/short masking\n+      return nullptr;              \/\/ Dont bother with byte\/short masking\n@@ -436,1 +436,1 @@\n-    if( n_loop != add_loop ) return NULL;  \/\/ happens w\/ evil ZKM loops\n+    if( n_loop != add_loop ) return nullptr;  \/\/ happens w\/ evil ZKM loops\n@@ -448,1 +448,1 @@\n-    if( add->Opcode() != Op_AddI ) return NULL;\n+    if( add->Opcode() != Op_AddI ) return nullptr;\n@@ -466,1 +466,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -468,1 +468,1 @@\n-      return NULL;              \/\/ No invariant part of the add?\n+      return nullptr;              \/\/ No invariant part of the add?\n@@ -543,1 +543,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -549,1 +549,1 @@\n-  Node * nn = NULL;\n+  Node * nn = nullptr;\n@@ -612,1 +612,1 @@\n-  if (region->req() != 3) return NULL;\n+  if (region->req() != 3) return nullptr;\n@@ -617,1 +617,1 @@\n-  if (!lp || !rp) return NULL;\n+  if (!lp || !rp) return nullptr;\n@@ -619,1 +619,1 @@\n-  if (lp_c == NULL || lp_c != rp->in(0) || !lp_c->is_If()) return NULL;\n+  if (lp_c == nullptr || lp_c != rp->in(0) || !lp_c->is_If()) return nullptr;\n@@ -624,2 +624,2 @@\n-  if (lp->outcnt() > 1) return NULL;\n-  if (rp->outcnt() > 1) return NULL;\n+  if (lp->outcnt() > 1) return nullptr;\n+  if (rp->outcnt() > 1) return nullptr;\n@@ -670,1 +670,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -675,1 +675,1 @@\n-      return NULL;              \/\/ In particular, can't do memory or I\/O\n+      return nullptr;              \/\/ In particular, can't do memory or I\/O\n@@ -708,1 +708,1 @@\n-    return NULL; \/\/ Ignore loop predicate checks (the Opaque4 ensures they will go away)\n+    return nullptr; \/\/ Ignore loop predicate checks (the Opaque4 ensures they will go away)\n@@ -713,1 +713,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -717,1 +717,1 @@\n-  if (phis > 1 && (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return NULL;\n+  if (phis > 1 && (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return nullptr;\n@@ -722,1 +722,1 @@\n-    if (cost >= ConditionalMoveLimit) return NULL; \/\/ Too much goo\n+    if (cost >= ConditionalMoveLimit) return nullptr; \/\/ Too much goo\n@@ -737,1 +737,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -745,1 +745,1 @@\n-    PhiNode* phi = NULL;\n+    PhiNode* phi = nullptr;\n@@ -753,1 +753,1 @@\n-    if (phi == NULL || _igvn.type(phi) == Type::TOP) {\n+    if (phi == nullptr || _igvn.type(phi) == Type::TOP) {\n@@ -763,1 +763,1 @@\n-        if (m != NULL && !is_dominator(get_ctrl(m), cmov_ctrl)) {\n+        if (m != nullptr && !is_dominator(get_ctrl(m), cmov_ctrl)) {\n@@ -818,1 +818,1 @@\n-      n->in(0) != NULL) {\n+      n->in(0) != nullptr) {\n@@ -848,1 +848,1 @@\n-      assert(n_loop->_tail != NULL, \"need a tail\");\n+      assert(n_loop->_tail != nullptr, \"need a tail\");\n@@ -894,1 +894,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -899,1 +899,1 @@\n-  if (n->is_Store() && n->in(0) != NULL) {\n+  if (n->is_Store() && n->in(0) != nullptr) {\n@@ -911,1 +911,1 @@\n-        Node* phi = NULL;\n+        Node* phi = nullptr;\n@@ -922,1 +922,1 @@\n-              if (phi != NULL) {\n+              if (phi != nullptr) {\n@@ -931,1 +931,1 @@\n-        if (phi != NULL) {\n+        if (phi != nullptr) {\n@@ -1051,1 +1051,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -1070,1 +1070,1 @@\n-    if (dom_cast != NULL && is_dominator(get_ctrl(dom_cast), get_ctrl(n))) {\n+    if (dom_cast != nullptr && is_dominator(get_ctrl(dom_cast), get_ctrl(n))) {\n@@ -1285,1 +1285,1 @@\n-\/\/ Return: NULL if it's not the case, or the exit of outer strip-mined loop\n+\/\/ Return: null if it's not the case, or the exit of outer strip-mined loop\n@@ -1287,1 +1287,1 @@\n-  Node* out_le = NULL;\n+  Node* out_le = nullptr;\n@@ -1292,1 +1292,1 @@\n-      if (loop != NULL && loop->is_strip_mined()) {\n+      if (loop != nullptr && loop->is_strip_mined()) {\n@@ -1338,1 +1338,1 @@\n-      if (iff->in(0) != NULL && iff->in(0) != n_ctrl ) {\n+      if (iff->in(0) != nullptr && iff->in(0) != n_ctrl ) {\n@@ -1367,1 +1367,1 @@\n-    guarantee(bolphi != NULL, \"null boolean phi node\");\n+    guarantee(bolphi != nullptr, \"null boolean phi node\");\n@@ -1440,1 +1440,1 @@\n-          if (out_le != NULL) {\n+          if (out_le != nullptr) {\n@@ -1465,1 +1465,1 @@\n-      n->in(1) != NULL &&\n+      n->in(1) != nullptr &&\n@@ -1477,1 +1477,1 @@\n-  if (cl == NULL) {\n+  if (cl == nullptr) {\n@@ -1483,1 +1483,1 @@\n-  if (cl->is_canonical_loop_entry() == NULL) {\n+  if (cl->is_canonical_loop_entry() == nullptr) {\n@@ -1506,1 +1506,1 @@\n-    if (n->in(0) != NULL) {\n+    if (n->in(0) != nullptr) {\n@@ -1522,1 +1522,1 @@\n-        Node* outer_loop_clone = NULL;\n+        Node* outer_loop_clone = nullptr;\n@@ -1527,1 +1527,1 @@\n-          Node* x_ctrl = NULL;\n+          Node* x_ctrl = nullptr;\n@@ -1570,1 +1570,1 @@\n-              if (outer_loop_clone != NULL) {\n+              if (outer_loop_clone != nullptr) {\n@@ -1577,1 +1577,1 @@\n-          } else if (n->in(0) != NULL){\n+          } else if (n->in(0) != nullptr){\n@@ -1591,1 +1591,1 @@\n-          if (x->in(0) == NULL && !x->is_DecodeNarrowPtr() &&\n+          if (x->in(0) == nullptr && !x->is_DecodeNarrowPtr() &&\n@@ -1595,1 +1595,1 @@\n-            Node* cast = NULL;\n+            Node* cast = nullptr;\n@@ -1598,1 +1598,1 @@\n-              if (in != NULL && n_loop->is_member(get_loop(get_ctrl(in)))) {\n+              if (in != nullptr && n_loop->is_member(get_loop(get_ctrl(in)))) {\n@@ -1602,1 +1602,1 @@\n-              if (cast != NULL) {\n+              if (cast != nullptr) {\n@@ -1612,1 +1612,1 @@\n-                      assert(u->find_out_with(Op_AddP) == NULL, \"more than 2 chained AddP nodes?\");\n+                      assert(u->find_out_with(Op_AddP) == nullptr, \"more than 2 chained AddP nodes?\");\n@@ -1619,1 +1619,1 @@\n-            assert(cast != NULL, \"must have added a cast to pin the node\");\n+            assert(cast != nullptr, \"must have added a cast to pin the node\");\n@@ -1632,1 +1632,1 @@\n-  Node* early_ctrl = NULL;\n+  Node* early_ctrl = nullptr;\n@@ -1638,1 +1638,1 @@\n-    Node* c = NULL;\n+    Node* c = nullptr;\n@@ -1646,1 +1646,1 @@\n-        if (in != NULL) {\n+        if (in != nullptr) {\n@@ -1651,1 +1651,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -1653,1 +1653,1 @@\n-      if (early_ctrl == NULL || is_dominator(early_ctrl, c)) {\n+      if (early_ctrl == nullptr || is_dominator(early_ctrl, c)) {\n@@ -1775,2 +1775,2 @@\n-  Node* sample_opaque = NULL;\n-  Node *sample_bool = NULL;\n+  Node* sample_opaque = nullptr;\n+  Node *sample_bool = nullptr;\n@@ -1790,2 +1790,2 @@\n-    Node *n1 = sample_opaque == NULL ? phi->in(i)->in(1)->in(1) : phi->in(i)->in(1)->in(1)->in(1);\n-    Node *n2 = sample_opaque == NULL ? phi->in(i)->in(1)->in(2) : phi->in(i)->in(1)->in(1)->in(2);\n+    Node *n1 = sample_opaque == nullptr ? phi->in(i)->in(1)->in(1) : phi->in(i)->in(1)->in(1)->in(1);\n+    Node *n2 = sample_opaque == nullptr ? phi->in(i)->in(1)->in(2) : phi->in(i)->in(1)->in(1)->in(2);\n@@ -1831,1 +1831,1 @@\n-  if (sample_opaque != NULL) {\n+  if (sample_opaque != nullptr) {\n@@ -1942,1 +1942,1 @@\n-    if (loop->_head->as_Loop()->is_strip_mined() && outer_loop->is_member(use_loop) && !loop->is_member(use_loop) && old_new[use->_idx] == NULL) {\n+    if (loop->_head->as_Loop()->is_strip_mined() && outer_loop->is_member(use_loop) && !loop->is_member(use_loop) && old_new[use->_idx] == nullptr) {\n@@ -2047,1 +2047,1 @@\n-        if( hit == NULL ) {\n+        if( hit == nullptr ) {\n@@ -2080,2 +2080,2 @@\n-    assert(check_old_new || old_new[u->_idx] == NULL, \"shouldn't have been cloned\");\n-    if (!u->is_CFG() && (!check_old_new || old_new[u->_idx] == NULL)) {\n+    assert(check_old_new || old_new[u->_idx] == nullptr, \"shouldn't have been cloned\");\n+    if (!u->is_CFG() && (!check_old_new || old_new[u->_idx] == nullptr)) {\n@@ -2092,1 +2092,1 @@\n-          if (u_c != NULL) {\n+          if (u_c != nullptr) {\n@@ -2118,1 +2118,1 @@\n-    Node* new_sfpt = NULL;\n+    Node* new_sfpt = nullptr;\n@@ -2173,1 +2173,1 @@\n-             (n->in(i) == NULL ||\n+             (n->in(i) == nullptr ||\n@@ -2176,1 +2176,1 @@\n-              (old_new[n->in(i)->_idx] != NULL && old_new[n->in(i)->_idx]->_idx >= new_counter))) {\n+              (old_new[n->in(i)->_idx] != nullptr && old_new[n->in(i)->_idx]->_idx >= new_counter))) {\n@@ -2183,1 +2183,1 @@\n-        assert(old_new[n->_idx] == NULL || n == sfpt || old_new[n->_idx]->_idx < new_counter, \"no clone yet\");\n+        assert(old_new[n->_idx] == nullptr || n == sfpt || old_new[n->_idx]->_idx < new_counter, \"no clone yet\");\n@@ -2185,1 +2185,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -2187,1 +2187,1 @@\n-            if (m->in(i) != NULL && old_new[m->in(i)->_idx] != NULL) {\n+            if (m->in(i) != nullptr && old_new[m->in(i)->_idx] != nullptr) {\n@@ -2233,1 +2233,1 @@\n-      if (n->in(0) != NULL) {\n+      if (n->in(0) != nullptr) {\n@@ -2265,1 +2265,1 @@\n-\/\/   When side_by_size_idom is NULL, the dominator tree is constructed for\n+\/\/   When side_by_size_idom is null, the dominator tree is constructed for\n@@ -2279,1 +2279,1 @@\n-    if (mname != NULL) {\n+    if (mname != nullptr) {\n@@ -2369,1 +2369,1 @@\n-        Node* newuse = NULL;\n+        Node* newuse = nullptr;\n@@ -2385,1 +2385,1 @@\n-        if (newuse == NULL) {\n+        if (newuse == nullptr) {\n@@ -2451,3 +2451,3 @@\n-  Node_List *split_if_set = NULL;\n-  Node_List *split_bool_set = NULL;\n-  Node_List *split_cex_set = NULL;\n+  Node_List *split_if_set = nullptr;\n+  Node_List *split_bool_set = nullptr;\n+  Node_List *split_cex_set = nullptr;\n@@ -2498,1 +2498,1 @@\n-      split_up(b, b->in(0), NULL);\n+      split_up(b, b->in(0), nullptr);\n@@ -2511,4 +2511,4 @@\n-  Node* trunc1 = NULL;\n-  Node* trunc2 = NULL;\n-  const TypeInteger* ttype = NULL;\n-  if (!iff->is_If() || iff->in(1) == NULL || !iff->in(1)->is_Bool()) {\n+  Node* trunc1 = nullptr;\n+  Node* trunc2 = nullptr;\n+  const TypeInteger* ttype = nullptr;\n+  if (!iff->is_If() || iff->in(1) == nullptr || !iff->in(1)->is_Bool()) {\n@@ -2526,1 +2526,1 @@\n-  Node* add2 = NULL;\n+  Node* add2 = nullptr;\n@@ -2555,1 +2555,1 @@\n-  if (add2 != NULL) {\n+  if (add2 != nullptr) {\n@@ -2568,2 +2568,2 @@\n-  Node* unique = NULL;\n-  if (!n) return NULL;\n+  Node* unique = nullptr;\n+  if (!n) return nullptr;\n@@ -2573,2 +2573,2 @@\n-      if (unique != NULL) {\n-        return NULL;\n+      if (unique != nullptr) {\n+        return nullptr;\n@@ -2606,1 +2606,1 @@\n-  guarantee(live_proj != NULL, \"null projection\");\n+  guarantee(live_proj != nullptr, \"null projection\");\n@@ -2648,1 +2648,1 @@\n-  proj->set_req(0, NULL);  \/\/ temporary disconnect\n+  proj->set_req(0, nullptr);  \/\/ temporary disconnect\n@@ -2668,1 +2668,1 @@\n-  guarantee(new_exit != NULL, \"null exit node\");\n+  guarantee(new_exit != nullptr, \"null exit node\");\n@@ -2709,1 +2709,1 @@\n-  proj->set_req(0, NULL);  \/\/ temporary disconnect\n+  proj->set_req(0, nullptr);  \/\/ temporary disconnect\n@@ -2717,1 +2717,1 @@\n-  IfNode* dum_if = new IfNode(reg, short_circuit_if(NULL, proj), iff->_prob, iff->_fcnt);\n+  IfNode* dum_if = new IfNode(reg, short_circuit_if(nullptr, proj), iff->_prob, iff->_fcnt);\n@@ -2770,1 +2770,1 @@\n-  if (bol->_test._test != BoolTest::lt) return NULL;\n+  if (bol->_test._test != BoolTest::lt) return nullptr;\n@@ -2772,1 +2772,1 @@\n-  if (cmpu->Opcode() != Op_CmpU) return NULL;\n+  if (cmpu->Opcode() != Op_CmpU) return nullptr;\n@@ -2774,1 +2774,1 @@\n-  if (stride == 0) return NULL;\n+  if (stride == 0) return nullptr;\n@@ -2777,1 +2777,1 @@\n-  guarantee(lp_proj != NULL, \"null loop node\");\n+  guarantee(lp_proj != nullptr, \"null loop node\");\n@@ -2784,1 +2784,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2788,1 +2788,1 @@\n-  Node* limit = NULL;\n+  Node* limit = nullptr;\n@@ -2797,1 +2797,1 @@\n-  guarantee(reg != NULL, \"null region node\");\n+  guarantee(reg != nullptr, \"null region node\");\n@@ -3020,1 +3020,1 @@\n-  if( hit == NULL ) {\n+  if( hit == nullptr ) {\n@@ -3356,2 +3356,2 @@\n-  IfNode *peel_if = NULL;\n-  IfNode *peel_if_cmpu = NULL;\n+  IfNode *peel_if = nullptr;\n+  IfNode *peel_if_cmpu = nullptr;\n@@ -3381,3 +3381,3 @@\n-  IfNode* new_peel_if = NULL;\n-  if (peel_if == NULL) {\n-    if (!PartialPeelAtUnsignedTests || peel_if_cmpu == NULL) {\n+  IfNode* new_peel_if = nullptr;\n+  if (peel_if == nullptr) {\n+    if (!PartialPeelAtUnsignedTests || peel_if_cmpu == nullptr) {\n@@ -3387,1 +3387,1 @@\n-    if (new_peel_if == NULL) {\n+    if (new_peel_if == nullptr) {\n@@ -3394,1 +3394,1 @@\n-  if (first_not_peeled == NULL || first_not_peeled == head) {\n+  if (first_not_peeled == nullptr || first_not_peeled == head) {\n@@ -3501,1 +3501,1 @@\n-          if (n->in(0) == NULL && !n->is_Load() && !n->is_CMove()) {\n+          if (n->in(0) == nullptr && !n->is_Load() && !n->is_CMove()) {\n@@ -3539,1 +3539,1 @@\n-                    new_phi_cnt, old_phi_cnt, new_peel_if != NULL?'T':'F');\n+                    new_phi_cnt, old_phi_cnt, new_peel_if != nullptr?'T':'F');\n@@ -3542,1 +3542,1 @@\n-    if (new_peel_if != NULL) {\n+    if (new_peel_if != nullptr) {\n@@ -3615,1 +3615,1 @@\n-              if (old_new[use->_idx] != NULL) { \/\/ null for dead code\n+              if (old_new[use->_idx] != nullptr) { \/\/ null for dead code\n@@ -3649,1 +3649,1 @@\n-    if (!n->is_CFG()           && n->in(0) != NULL        &&\n+    if (!n->is_CFG()           && n->in(0) != nullptr        &&\n@@ -3747,1 +3747,1 @@\n-        u_ctrl = NULL;\n+        u_ctrl = nullptr;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":140,"deletions":140,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-TypeOopPtr *MachOper::oop() const { return NULL; }\n+TypeOopPtr *MachOper::oop() const { return nullptr; }\n@@ -81,1 +81,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -187,1 +187,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -215,1 +215,1 @@\n-  if( rm == NULL || (int)opcnt != cisc_operand() ) {\n+  if( rm == nullptr || (int)opcnt != cisc_operand() ) {\n@@ -229,3 +229,3 @@\n-    base = NULL;\n-    index = NULL;\n-    if (oper != NULL) {\n+    base = nullptr;\n+    index = nullptr;\n+    if (oper != nullptr) {\n@@ -260,2 +260,2 @@\n-  if (oper == NULL) {\n-    \/\/ Base has been set to NULL\n+  if (oper == nullptr) {\n+    \/\/ Base has been set to null\n@@ -268,1 +268,1 @@\n-    \/\/ Base may be NULL, even if offset turns out to be != 0\n+    \/\/ Base may be null, even if offset turns out to be != 0\n@@ -274,1 +274,1 @@\n-    if (index != NULL) {\n+    if (index != nullptr) {\n@@ -281,1 +281,1 @@\n-        assert(base == NULL, \"Memory references through narrow oops have no base\");\n+        assert(base == nullptr, \"Memory references through narrow oops have no base\");\n@@ -284,1 +284,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -289,1 +289,1 @@\n-        if (ti == NULL) {\n+        if (ti == nullptr) {\n@@ -303,2 +303,2 @@\n-      const TypePtr *t_disp = oper->disp_as_type();  \/\/ only !NULL for indOffset32X\n-      if (t_disp != NULL) {\n+      const TypePtr *t_disp = oper->disp_as_type();  \/\/ only not null for indOffset32X\n+      if (t_disp != nullptr) {\n@@ -314,1 +314,1 @@\n-      } else if( base == NULL && offset != 0 && offset != Type::OffsetBot ) {\n+      } else if( base == nullptr && offset != 0 && offset != Type::OffsetBot ) {\n@@ -317,1 +317,1 @@\n-        if( tp != NULL) {\n+        if( tp != nullptr) {\n@@ -342,2 +342,2 @@\n-  if (base == NULL) {\n-    \/\/ NULL base, zero offset means no memory at all (a null pointer!)\n+  if (base == nullptr) {\n+    \/\/ null base, zero offset means no memory at all (a null pointer!)\n@@ -345,1 +345,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -347,1 +347,1 @@\n-    \/\/ NULL base, any offset means any pointer whatever\n+    \/\/ null base, any offset means any pointer whatever\n@@ -380,1 +380,1 @@\n-  if (tp == NULL) {\n+  if (tp == nullptr) {\n@@ -433,1 +433,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -508,1 +508,1 @@\n-    if (_opnds[i] != NULL) {\n+    if (_opnds[i] != nullptr) {\n@@ -532,1 +532,1 @@\n-  if (_bottom_type != NULL) {\n+  if (_bottom_type != nullptr) {\n@@ -535,1 +535,1 @@\n-    st->print(\" NULL\");\n+    st->print(\" null\");\n@@ -605,1 +605,1 @@\n-    if (ctrl == NULL)  return NULL; \/\/ node is dead\n+    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n@@ -609,1 +609,1 @@\n-      assert(adr_type != NULL, \"source must have adr_type\");\n+      assert(adr_type != nullptr, \"source must have adr_type\");\n@@ -614,1 +614,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -678,1 +678,1 @@\n-  if (tf() != NULL)  tf()->dump_on(st);\n+  if (tf() != nullptr)  tf()->dump_on(st);\n@@ -680,1 +680,1 @@\n-  if (jvms() != NULL)  jvms()->dump_spec(st);\n+  if (jvms() != nullptr)  jvms()->dump_spec(st);\n@@ -772,1 +772,1 @@\n-  if (_name != NULL && !strcmp(_name, \"uncommon_trap\")) {\n+  if (_name != nullptr && !strcmp(_name, \"uncommon_trap\")) {\n@@ -792,1 +792,1 @@\n-  if (_name != NULL) {\n+  if (_name != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  virtual const TypePtr *disp_as_type() const { return NULL; }\n+  virtual const TypePtr *disp_as_type() const { return nullptr; }\n@@ -196,1 +196,1 @@\n-    if (o == NULL)                   return true;\n+    if (o == nullptr)                   return true;\n@@ -209,1 +209,1 @@\n-  MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(NULL) {\n+  MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(nullptr) {\n@@ -261,1 +261,1 @@\n-  virtual const RegMask *cisc_RegMask() const { return NULL; }\n+  virtual const RegMask *cisc_RegMask() const { return nullptr; }\n@@ -331,1 +331,1 @@\n-  \/\/ If there are no such, return NULL.  If there are multiple addresses\n+  \/\/ If there are no such, return null.  If there are multiple addresses\n@@ -343,2 +343,2 @@\n-  \/\/ are set to NodeSentinel. If (MachOper *) NULL is returned, base and\n-  \/\/ index are set to NULL.\n+  \/\/ are set to NodeSentinel. If null is returned, base and\n+  \/\/ index are set to null.\n@@ -348,1 +348,1 @@\n-  \/\/ By default, returns NULL, which means there is no such operand.\n+  \/\/ By default, returns null, which means there is no such operand.\n@@ -350,1 +350,1 @@\n-  virtual const MachOper* memory_operand() const { return NULL; }\n+  virtual const MachOper* memory_operand() const { return nullptr; }\n@@ -395,1 +395,1 @@\n-  virtual const class Type *bottom_type() const { return _opnds == NULL ? Type::CONTROL : MachNode::bottom_type(); }\n+  virtual const class Type *bottom_type() const { return _opnds == nullptr ? Type::CONTROL : MachNode::bottom_type(); }\n@@ -595,1 +595,1 @@\n-    add_req(NULL);\n+    add_req(nullptr);\n@@ -663,1 +663,1 @@\n-    add_req(NULL);\n+    add_req(nullptr);\n@@ -689,1 +689,1 @@\n-  virtual MachNode *short_branch_version() { return NULL; }\n+  virtual MachNode *short_branch_version() { return nullptr; }\n@@ -835,1 +835,1 @@\n-  MachSafePointNode() : MachReturnNode(), _oop_map(NULL), _jvms(NULL), _jvmadj(0), _has_ea_local_in_scope(false) {\n+  MachSafePointNode() : MachReturnNode(), _oop_map(nullptr), _jvms(nullptr), _jvmadj(0), _has_ea_local_in_scope(false) {\n@@ -948,1 +948,1 @@\n-      assert(_method != NULL, \"method should be set\");\n+      assert(_method != nullptr, \"method should be set\");\n@@ -952,1 +952,1 @@\n-    return 0; \/\/ Use symbolic info from bytecode (resolved_method == NULL).\n+    return 0; \/\/ Use symbolic info from bytecode (resolved_method is null).\n@@ -1002,1 +1002,1 @@\n-  const char *_name;            \/\/ Printable name, if _method is NULL\n+  const char *_name;            \/\/ Printable name, if _method is null\n@@ -1080,1 +1080,1 @@\n-    add_req(NULL);\n+    add_req(nullptr);\n@@ -1112,1 +1112,1 @@\n-  virtual Label *label() const { assert(_label != NULL, \"need Label\"); return _label; }\n+  virtual Label *label() const { assert(_label != nullptr, \"need Label\"); return _label; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    } else if (j >= req && uin == NULL) {\n+    } else if (j >= req && uin == nullptr) {\n@@ -85,1 +85,1 @@\n-  assert(old != NULL, \"sanity\");\n+  assert(old != nullptr, \"sanity\");\n@@ -145,3 +145,3 @@\n-  if (parm0 != NULL)  call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL)  call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL)  call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm0 != nullptr)  call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr)  call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr)  call->init_req(TypeFunc::Parms+2, parm2);\n@@ -187,1 +187,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -189,1 +189,1 @@\n-          if (ac != NULL) {\n+          if (ac != nullptr) {\n@@ -227,1 +227,1 @@\n-        if (init != NULL) {\n+        if (init != nullptr) {\n@@ -236,1 +236,1 @@\n-      Node* adr = NULL;\n+      Node* adr = nullptr;\n@@ -249,1 +249,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -259,1 +259,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -278,1 +278,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -296,2 +296,2 @@\n-      Node* adr = NULL;\n-      const TypePtr* adr_type = NULL;\n+      Node* adr = nullptr;\n+      const TypePtr* adr_type = nullptr;\n@@ -321,1 +321,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -329,1 +329,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -336,1 +336,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -343,1 +343,1 @@\n-\/\/ Returns the computed Phi, or NULL if it cannot compute it.\n+\/\/ Returns the computed Phi, or null if it cannot compute it.\n@@ -361,1 +361,1 @@\n-  if (new_phi != NULL)\n+  if (new_phi != nullptr)\n@@ -365,1 +365,1 @@\n-    return NULL; \/\/ Give up: phi tree too deep\n+    return nullptr; \/\/ Give up: phi tree too deep\n@@ -371,1 +371,1 @@\n-  GrowableArray <Node *> values(length, length, NULL);\n+  GrowableArray <Node *> values(length, length, nullptr);\n@@ -374,1 +374,1 @@\n-  PhiNode *phi = new PhiNode(mem->in(0), phi_type, NULL, mem->_idx, instance_id, alias_idx, offset);\n+  PhiNode *phi = new PhiNode(mem->in(0), phi_type, nullptr, mem->_idx, instance_id, alias_idx, offset);\n@@ -380,1 +380,1 @@\n-    if (in == NULL || in->is_top()) {\n+    if (in == nullptr || in->is_top()) {\n@@ -392,2 +392,2 @@\n-      if (val == NULL) {\n-        return NULL;  \/\/ can't find a value on this path\n+      if (val == nullptr) {\n+        return nullptr;  \/\/ can't find a value on this path\n@@ -409,2 +409,2 @@\n-        if (val == NULL) {\n-          return NULL;\n+        if (val == nullptr) {\n+          return nullptr;\n@@ -418,1 +418,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -421,2 +421,2 @@\n-        if (res == NULL) {\n-          return NULL;\n+        if (res == nullptr) {\n+          return nullptr;\n@@ -428,1 +428,1 @@\n-        return NULL;  \/\/ unknown node on this path\n+        return nullptr;  \/\/ unknown node on this path\n@@ -460,1 +460,1 @@\n-      return NULL;  \/\/ found a loop, give up\n+      return nullptr;  \/\/ found a loop, give up\n@@ -467,1 +467,1 @@\n-      if (mem == NULL) {\n+      if (mem == nullptr) {\n@@ -476,1 +476,1 @@\n-      assert(atype != NULL, \"address type must be oopptr\");\n+      assert(atype != nullptr, \"address type must be oopptr\");\n@@ -483,1 +483,1 @@\n-      Node *unique_input = NULL;\n+      Node *unique_input = nullptr;\n@@ -487,1 +487,1 @@\n-        if (n == NULL || n == top || n == mem) {\n+        if (n == nullptr || n == top || n == mem) {\n@@ -489,1 +489,1 @@\n-        } else if (unique_input == NULL) {\n+        } else if (unique_input == nullptr) {\n@@ -496,1 +496,1 @@\n-      if (unique_input != NULL && unique_input != top) {\n+      if (unique_input != nullptr && unique_input != top) {\n@@ -508,1 +508,1 @@\n-  if (mem != NULL) {\n+  if (mem != nullptr) {\n@@ -521,1 +521,1 @@\n-      if (phi != NULL) {\n+      if (phi != nullptr) {\n@@ -543,1 +543,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -550,2 +550,2 @@\n-  NOT_PRODUCT( const char* fail_eliminate = NULL; )\n-  DEBUG_ONLY( Node* disq_node = NULL; )\n+  NOT_PRODUCT( const char* fail_eliminate = nullptr; )\n+  DEBUG_ONLY( Node* disq_node = nullptr; )\n@@ -555,2 +555,2 @@\n-  const TypeOopPtr* res_type = NULL;\n-  if (res == NULL) {\n+  const TypeOopPtr* res_type = nullptr;\n+  if (res == nullptr) {\n@@ -563,1 +563,1 @@\n-    if (res_type == NULL) {\n+    if (res_type == nullptr) {\n@@ -575,1 +575,1 @@\n-  if (can_eliminate && res != NULL) {\n+  if (can_eliminate && res != nullptr) {\n@@ -619,1 +619,1 @@\n-        if (sfptMem == NULL || sfptMem->is_top()) {\n+        if (sfptMem == nullptr || sfptMem->is_top()) {\n@@ -621,1 +621,1 @@\n-          NOT_PRODUCT(fail_eliminate = \"NULL or TOP memory\";)\n+          NOT_PRODUCT(fail_eliminate = \"null or TOP memory\";)\n@@ -651,1 +651,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -657,1 +657,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -662,1 +662,1 @@\n-      if (disq_node != NULL) {\n+      if (disq_node != nullptr) {\n@@ -677,2 +677,2 @@\n-  ciKlass* klass = NULL;\n-  ciInstanceKlass* iklass = NULL;\n+  ciKlass* klass = nullptr;\n+  ciInstanceKlass* iklass = nullptr;\n@@ -683,1 +683,1 @@\n-  ciType* elem_type = NULL;\n+  ciType* elem_type = nullptr;\n@@ -686,3 +686,3 @@\n-  assert(res == NULL || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n-  const TypeOopPtr* res_type = NULL;\n-  if (res != NULL) { \/\/ Could be NULL when there are no users\n+  assert(res == nullptr || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n+  const TypeOopPtr* res_type = nullptr;\n+  if (res != nullptr) { \/\/ Could be nullptr when there are no users\n@@ -692,1 +692,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -716,1 +716,1 @@\n-    assert(sfpt->jvms() != NULL, \"missed JVMS\");\n+    assert(sfpt->jvms() != nullptr, \"missed JVMS\");\n@@ -732,2 +732,2 @@\n-      ciField* field = NULL;\n-      if (iklass != NULL) {\n+      ciField* field = nullptr;\n+      if (iklass != nullptr) {\n@@ -747,1 +747,1 @@\n-        } else if (field != NULL && field->is_static_constant()) {\n+        } else if (field != nullptr && field->is_static_constant()) {\n@@ -753,1 +753,1 @@\n-          assert(field_type != NULL, \"field singleton type must be consistent\");\n+          assert(field_type != nullptr, \"field singleton type must be consistent\");\n@@ -768,1 +768,1 @@\n-      if (field_val == NULL) {\n+      if (field_val == nullptr) {\n@@ -806,1 +806,1 @@\n-          if (field != NULL) {\n+          if (field != nullptr) {\n@@ -817,1 +817,1 @@\n-          if (res == NULL)\n+          if (res == nullptr)\n@@ -852,1 +852,1 @@\n-  if (ctl_proj != NULL) {\n+  if (ctl_proj != nullptr) {\n@@ -855,1 +855,1 @@\n-  if (mem_proj != NULL) {\n+  if (mem_proj != nullptr) {\n@@ -863,1 +863,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -942,1 +942,1 @@\n-  if (_callprojs.resproj != NULL && _callprojs.resproj->outcnt() != 0) {\n+  if (_callprojs.resproj != nullptr && _callprojs.resproj->outcnt() != 0) {\n@@ -962,1 +962,1 @@\n-        if (ctrl_proj != NULL) {\n+        if (ctrl_proj != nullptr) {\n@@ -965,1 +965,1 @@\n-          \/\/ If the InitializeNode has no memory out, it will die, and tmp will become NULL\n+          \/\/ If the InitializeNode has no memory out, it will die, and tmp will become null\n@@ -967,1 +967,1 @@\n-          assert(tmp == NULL || tmp == _callprojs.fallthrough_catchproj, \"allocation control projection\");\n+          assert(tmp == nullptr || tmp == _callprojs.fallthrough_catchproj, \"allocation control projection\");\n@@ -971,1 +971,1 @@\n-        if (mem_proj != NULL) {\n+        if (mem_proj != nullptr) {\n@@ -988,1 +988,1 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n+  if (_callprojs.fallthrough_catchproj != nullptr) {\n@@ -991,1 +991,1 @@\n-  if (_callprojs.fallthrough_memproj != NULL) {\n+  if (_callprojs.fallthrough_memproj != nullptr) {\n@@ -994,1 +994,1 @@\n-  if (_callprojs.catchall_memproj != NULL) {\n+  if (_callprojs.catchall_memproj != nullptr) {\n@@ -997,1 +997,1 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n+  if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -1000,1 +1000,1 @@\n-  if (_callprojs.catchall_ioproj != NULL) {\n+  if (_callprojs.catchall_ioproj != nullptr) {\n@@ -1003,1 +1003,1 @@\n-  if (_callprojs.catchall_catchproj != NULL) {\n+  if (_callprojs.catchall_catchproj != nullptr) {\n@@ -1025,1 +1025,1 @@\n-  if (!alloc->_is_scalar_replaceable && (!boxing_alloc || (res != NULL))) {\n+  if (!alloc->_is_scalar_replaceable && (!boxing_alloc || (res != nullptr))) {\n@@ -1037,1 +1037,1 @@\n-    assert(res == NULL, \"sanity\");\n+    assert(res == nullptr, \"sanity\");\n@@ -1051,1 +1051,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1055,1 +1055,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -1078,1 +1078,1 @@\n-  if (!C->eliminate_boxing() || boxing->proj_out_or_null(TypeFunc::Parms) != NULL) {\n+  if (!C->eliminate_boxing() || boxing->proj_out_or_null(TypeFunc::Parms) != nullptr) {\n@@ -1082,1 +1082,1 @@\n-  assert(boxing->result_cast() == NULL, \"unexpected boxing node result\");\n+  assert(boxing->result_cast() == nullptr, \"unexpected boxing node result\");\n@@ -1089,1 +1089,1 @@\n-  assert(t != NULL, \"sanity\");\n+  assert(t != nullptr, \"sanity\");\n@@ -1092,1 +1092,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1096,1 +1096,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -1145,1 +1145,1 @@\n-  mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);\n+  mem = StoreNode::make(_igvn, ctl, mem, adr, nullptr, value, bt, MemNode::unordered);\n@@ -1218,1 +1218,1 @@\n-  assert(ctrl != NULL, \"must have control\");\n+  assert(ctrl != nullptr, \"must have control\");\n@@ -1223,4 +1223,4 @@\n-  Node *result_region = NULL;\n-  Node *result_phi_rawmem = NULL;\n-  Node *result_phi_rawoop = NULL;\n-  Node *result_phi_i_o = NULL;\n+  Node *result_region = nullptr;\n+  Node *result_phi_rawmem = nullptr;\n+  Node *result_phi_rawoop = nullptr;\n+  Node *result_phi_i_o = nullptr;\n@@ -1238,1 +1238,1 @@\n-    initial_slow_test = NULL;\n+    initial_slow_test = nullptr;\n@@ -1247,1 +1247,1 @@\n-    initial_slow_test = NULL;\n+    initial_slow_test = nullptr;\n@@ -1250,1 +1250,1 @@\n-  bool allocation_has_use = (alloc->result_cast() != NULL);\n+  bool allocation_has_use = (alloc->result_cast() != nullptr);\n@@ -1253,1 +1253,1 @@\n-    if (init != NULL) {\n+    if (init != nullptr) {\n@@ -1256,1 +1256,1 @@\n-    if (expand_fast_path && (initial_slow_test == NULL)) {\n+    if (expand_fast_path && (initial_slow_test == nullptr)) {\n@@ -1264,1 +1264,1 @@\n-        if (res != NULL) {\n+        if (res != nullptr) {\n@@ -1277,1 +1277,1 @@\n-  Node *slow_region = NULL;\n+  Node *slow_region = nullptr;\n@@ -1281,1 +1281,1 @@\n-  if (initial_slow_test != NULL ) {\n+  if (initial_slow_test != nullptr ) {\n@@ -1334,1 +1334,1 @@\n-      Node* needgc_ctrl = NULL;\n+      Node* needgc_ctrl = nullptr;\n@@ -1337,1 +1337,1 @@\n-      intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;\n+      intx prefetch_lines = length != nullptr ? AllocatePrefetchLines : AllocateInstancePrefetchLines;\n@@ -1343,1 +1343,1 @@\n-      if (initial_slow_test != NULL) {\n+      if (initial_slow_test != nullptr) {\n@@ -1362,1 +1362,1 @@\n-      assert (initial_slow_test != NULL, \"sanity\");\n+      assert (initial_slow_test != nullptr, \"sanity\");\n@@ -1388,1 +1388,1 @@\n-  if (length != NULL) {\n+  if (length != nullptr) {\n@@ -1398,1 +1398,1 @@\n-  if (valid_length_test != NULL) {\n+  if (valid_length_test != nullptr) {\n@@ -1427,1 +1427,1 @@\n-  if (expand_fast_path && _callprojs.fallthrough_memproj != NULL) {\n+  if (expand_fast_path && _callprojs.fallthrough_memproj != nullptr) {\n@@ -1432,2 +1432,2 @@\n-  if (_callprojs.catchall_memproj != NULL ) {\n-    if (_callprojs.fallthrough_memproj == NULL) {\n+  if (_callprojs.catchall_memproj != nullptr ) {\n+    if (_callprojs.fallthrough_memproj == nullptr) {\n@@ -1446,1 +1446,1 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n+  if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -1451,2 +1451,2 @@\n-  if (_callprojs.catchall_ioproj != NULL ) {\n-    if (_callprojs.fallthrough_ioproj == NULL) {\n+  if (_callprojs.catchall_ioproj != nullptr ) {\n+    if (_callprojs.fallthrough_ioproj == nullptr) {\n@@ -1476,1 +1476,1 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n+  if (_callprojs.fallthrough_catchproj != nullptr) {\n@@ -1484,1 +1484,1 @@\n-  if (_callprojs.resproj == NULL) {\n+  if (_callprojs.resproj == nullptr) {\n@@ -1513,1 +1513,1 @@\n-  if (_callprojs.resproj != NULL) {\n+  if (_callprojs.resproj != nullptr) {\n@@ -1523,1 +1523,1 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n+  if (_callprojs.fallthrough_catchproj != nullptr) {\n@@ -1527,1 +1527,1 @@\n-  if (_callprojs.catchall_catchproj != NULL) {\n+  if (_callprojs.catchall_catchproj != nullptr) {\n@@ -1531,1 +1531,1 @@\n-  if (_callprojs.fallthrough_proj != NULL) {\n+  if (_callprojs.fallthrough_proj != nullptr) {\n@@ -1536,1 +1536,1 @@\n-  if (_callprojs.fallthrough_memproj != NULL) {\n+  if (_callprojs.fallthrough_memproj != nullptr) {\n@@ -1540,1 +1540,1 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n+  if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -1544,1 +1544,1 @@\n-  if (_callprojs.catchall_memproj != NULL) {\n+  if (_callprojs.catchall_memproj != nullptr) {\n@@ -1548,1 +1548,1 @@\n-  if (_callprojs.catchall_ioproj != NULL) {\n+  if (_callprojs.catchall_ioproj != nullptr) {\n@@ -1582,2 +1582,2 @@\n-    (init == NULL || !init->is_complete_with_arraycopy())) {\n-    if (init == NULL || init->req() < InitializeNode::RawStores) {\n+    (init == nullptr || !init->is_complete_with_arraycopy())) {\n+    if (init == nullptr || init->req() < InitializeNode::RawStores) {\n@@ -1626,1 +1626,1 @@\n-      if (init_ctrl != NULL) {\n+      if (init_ctrl != nullptr) {\n@@ -1629,1 +1629,1 @@\n-      if (init_mem != NULL) {\n+      if (init_mem != nullptr) {\n@@ -1684,1 +1684,1 @@\n-  if (length != NULL) {         \/\/ Arrays need length field\n+  if (length != nullptr) {         \/\/ Arrays need length field\n@@ -1694,1 +1694,1 @@\n-  if (init == NULL) {\n+  if (init == nullptr) {\n@@ -1880,1 +1880,1 @@\n-  expand_allocate_common(alloc, NULL,\n+  expand_allocate_common(alloc, nullptr,\n@@ -1882,1 +1882,1 @@\n-                         OptoRuntime::new_instance_Java(), NULL);\n+                         OptoRuntime::new_instance_Java(), nullptr);\n@@ -1892,1 +1892,1 @@\n-  if (init != NULL && init->is_complete_with_arraycopy() &&\n+  if (init != nullptr && init->is_complete_with_arraycopy() &&\n@@ -1926,1 +1926,1 @@\n-      oldbox->as_BoxLock()->is_simple_lock_region(NULL, obj, NULL)) {\n+      oldbox->as_BoxLock()->is_simple_lock_region(nullptr, obj, nullptr)) {\n@@ -2018,1 +2018,1 @@\n-      if (alock->jvms() != NULL) {\n+      if (alock->jvms() != nullptr) {\n@@ -2046,1 +2046,1 @@\n-          if (C->log() != NULL)\n+          if (C->log() != nullptr)\n@@ -2104,1 +2104,1 @@\n-  guarantee(ctrl != NULL, \"missing control projection, cannot replace_node() with NULL\");\n+  guarantee(ctrl != nullptr, \"missing control projection, cannot replace_node() with null\");\n@@ -2110,2 +2110,2 @@\n-         _callprojs.fallthrough_proj != NULL &&\n-         _callprojs.fallthrough_memproj != NULL,\n+         _callprojs.fallthrough_proj != nullptr &&\n+         _callprojs.fallthrough_memproj != nullptr,\n@@ -2123,1 +2123,1 @@\n-    assert(membar != NULL && membar->Opcode() == Op_MemBarAcquireLock, \"\");\n+    assert(membar != nullptr && membar->Opcode() == Op_MemBarAcquireLock, \"\");\n@@ -2241,1 +2241,1 @@\n-    if (klass_node == NULL) {\n+    if (klass_node == nullptr) {\n@@ -2243,1 +2243,1 @@\n-      klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)->is_ptr()));\n+      klass_node = transform_later(LoadKlassNode::make(_igvn, nullptr, mem, k_adr, _igvn.type(k_adr)->is_ptr()));\n@@ -2366,2 +2366,2 @@\n-                                  OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,\n-                                  obj, box, NULL);\n+                                  OptoRuntime::complete_monitor_locking_Java(), nullptr, slow_path,\n+                                  obj, box, nullptr);\n@@ -2375,2 +2375,2 @@\n-  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n-         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs.fallthrough_ioproj == nullptr && _callprojs.catchall_ioproj == nullptr &&\n+         _callprojs.catchall_memproj == nullptr && _callprojs.catchall_catchproj == nullptr, \"Unexpected projection from Lock\");\n@@ -2441,2 +2441,2 @@\n-  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n-         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs.fallthrough_ioproj == nullptr && _callprojs.catchall_ioproj == nullptr &&\n+         _callprojs.catchall_memproj == nullptr && _callprojs.catchall_catchproj == nullptr, \"Unexpected projection from Lock\");\n@@ -2465,1 +2465,1 @@\n-  assert(check->in(SubTypeCheckNode::Control) == NULL, \"should be pinned\");\n+  assert(check->in(SubTypeCheckNode::Control) == nullptr, \"should be pinned\");\n@@ -2484,1 +2484,1 @@\n-    Node* subklass = NULL;\n+    Node* subklass = nullptr;\n@@ -2489,1 +2489,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n@@ -2492,1 +2492,1 @@\n-    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, NULL, _igvn);\n+    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn);\n@@ -2621,1 +2621,1 @@\n-               ifn->proj_out(1)->is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, \"\");\n+               ifn->proj_out(1)->is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != nullptr, \"\");\n@@ -2678,1 +2678,1 @@\n-    if (_igvn.type(n) == Type::TOP || (n->in(0) != NULL && n->in(0)->is_top())) {\n+    if (_igvn.type(n) == Type::TOP || (n->in(0) != nullptr && n->in(0)->is_top())) {\n@@ -2731,1 +2731,1 @@\n-    if (_igvn.type(n) == Type::TOP || (n->in(0) != NULL && n->in(0)->is_top())) {\n+    if (_igvn.type(n) == Type::TOP || (n->in(0) != nullptr && n->in(0)->is_top())) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":157,"deletions":157,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,4 +71,4 @@\n-                       Node* parm0 = NULL, Node* parm1 = NULL,\n-                       Node* parm2 = NULL, Node* parm3 = NULL,\n-                       Node* parm4 = NULL, Node* parm5 = NULL,\n-                       Node* parm6 = NULL, Node* parm7 = NULL);\n+                       Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                       Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                       Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                       Node* parm6 = nullptr, Node* parm7 = nullptr);\n@@ -115,1 +115,1 @@\n-  void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = NULL);\n+  void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = nullptr);\n@@ -143,1 +143,1 @@\n-                           RegionNode* slow_region = NULL);\n+                           RegionNode* slow_region = nullptr);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,9 +86,9 @@\n-  \/\/ Hook each parm in order.  Stop looking at the first NULL.\n-  if (parm0 != NULL) { call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL) { call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL) { call->init_req(TypeFunc::Parms+2, parm2);\n-  if (parm3 != NULL) { call->init_req(TypeFunc::Parms+3, parm3);\n-  if (parm4 != NULL) { call->init_req(TypeFunc::Parms+4, parm4);\n-  if (parm5 != NULL) { call->init_req(TypeFunc::Parms+5, parm5);\n-  if (parm6 != NULL) { call->init_req(TypeFunc::Parms+6, parm6);\n-  if (parm7 != NULL) { call->init_req(TypeFunc::Parms+7, parm7);\n+  \/\/ Hook each parm in order.  Stop looking at the first null.\n+  if (parm0 != nullptr) { call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr) { call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr) { call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm3 != nullptr) { call->init_req(TypeFunc::Parms+3, parm3);\n+  if (parm4 != nullptr) { call->init_req(TypeFunc::Parms+4, parm4);\n+  if (parm5 != nullptr) { call->init_req(TypeFunc::Parms+5, parm5);\n+  if (parm6 != nullptr) { call->init_req(TypeFunc::Parms+6, parm6);\n+  if (parm7 != nullptr) { call->init_req(TypeFunc::Parms+7, parm7);\n@@ -96,1 +96,1 @@\n-  assert(call->in(call->req()-1) != NULL, \"must initialize all parms\");\n+  assert(call->in(call->req()-1) != nullptr, \"must initialize all parms\");\n@@ -109,2 +109,2 @@\n-\/\/ or NULL if it is obvious that the slow path can never be taken.\n-\/\/ Also, if region and the slow control are not NULL, the slow edge\n+\/\/ or null if it is obvious that the slow path can never be taken.\n+\/\/ Also, if region and the slow control are not null, the slow edge\n@@ -115,1 +115,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -121,1 +121,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -130,1 +130,1 @@\n-  if (region != NULL) {\n+  if (region != nullptr) {\n@@ -202,2 +202,2 @@\n-  Node* inline_block = NULL;\n-  Node* stub_block = NULL;\n+  Node* inline_block = nullptr;\n+  Node* stub_block = nullptr;\n@@ -206,1 +206,1 @@\n-  const TypeInt* lty = NULL;\n+  const TypeInt* lty = nullptr;\n@@ -237,1 +237,1 @@\n-  inline_block  = generate_guard(ctrl, bol_le, NULL, PROB_FAIR);\n+  inline_block  = generate_guard(ctrl, bol_le, nullptr, PROB_FAIR);\n@@ -272,1 +272,1 @@\n-  if ((*ctrl)->is_top())  return NULL;\n+  if ((*ctrl)->is_top())  return nullptr;\n@@ -275,1 +275,1 @@\n-    return NULL;                \/\/ index is already adequately typed\n+    return nullptr;                \/\/ index is already adequately typed\n@@ -281,1 +281,1 @@\n-  Node* is_notp = generate_guard(ctrl, bol_le, NULL, PROB_MIN);\n+  Node* is_notp = generate_guard(ctrl, bol_le, nullptr, PROB_MIN);\n@@ -321,2 +321,2 @@\n-  if (src_offset_inttype != NULL && src_offset_inttype->is_con() &&\n-      dest_offset_inttype != NULL && dest_offset_inttype->is_con()) {\n+  if (src_offset_inttype != nullptr && src_offset_inttype->is_con() &&\n+      dest_offset_inttype != nullptr && dest_offset_inttype->is_con()) {\n@@ -330,1 +330,1 @@\n-  } else if (src_offset == dest_offset && src_offset != NULL) {\n+  } else if (src_offset == dest_offset && src_offset != nullptr) {\n@@ -383,1 +383,1 @@\n-  if (slow_region == NULL) {\n+  if (slow_region == nullptr) {\n@@ -401,1 +401,1 @@\n-      && alloc != NULL\n+      && alloc != nullptr\n@@ -426,1 +426,1 @@\n-    alloc                  = NULL;\n+    alloc                  = nullptr;\n@@ -458,3 +458,3 @@\n-  Node* checked_mem     = NULL;\n-  Node* checked_i_o     = NULL;\n-  Node* checked_value   = NULL;\n+  Node* checked_mem     = nullptr;\n+  Node* checked_i_o     = nullptr;\n+  Node* checked_value   = nullptr;\n@@ -468,1 +468,1 @@\n-    if (cv == NULL)  cv = intcon(-1);  \/\/ failure (no stub available)\n+    if (cv == nullptr)  cv = intcon(-1);  \/\/ failure (no stub available)\n@@ -477,1 +477,1 @@\n-  if (not_pos != NULL) {\n+  if (not_pos != nullptr) {\n@@ -498,1 +498,1 @@\n-                             intcon(0), NULL,\n+                             intcon(0), nullptr,\n@@ -536,1 +536,1 @@\n-                           NULL);\n+                           nullptr);\n@@ -544,1 +544,1 @@\n-    Node* tail_ctl = NULL;\n+    Node* tail_ctl = nullptr;\n@@ -548,2 +548,2 @@\n-      tail_ctl = generate_slow_guard(ctrl, bol_lt, NULL);\n-      assert(tail_ctl != NULL || !(*ctrl)->is_top(), \"must be an outcome\");\n+      tail_ctl = generate_slow_guard(ctrl, bol_lt, nullptr);\n+      assert(tail_ctl != nullptr || !(*ctrl)->is_top(), \"must be an outcome\");\n@@ -553,1 +553,1 @@\n-    if (!(*ctrl)->is_top() && alloc != NULL && basic_elem_type != T_OBJECT) {\n+    if (!(*ctrl)->is_top() && alloc != nullptr && basic_elem_type != T_OBJECT) {\n@@ -578,2 +578,2 @@\n-    if (tail_ctl != NULL) {\n-      Node* notail_ctl = (*ctrl)->is_top() ? NULL : *ctrl;\n+    if (tail_ctl != nullptr) {\n+      Node* notail_ctl = (*ctrl)->is_top() ? nullptr : *ctrl;\n@@ -581,1 +581,1 @@\n-      if (notail_ctl == NULL) {\n+      if (notail_ctl == nullptr) {\n@@ -584,1 +584,1 @@\n-                             dest_tail, NULL,\n+                             dest_tail, nullptr,\n@@ -594,1 +594,1 @@\n-                             dest_tail, NULL,\n+                             dest_tail, nullptr,\n@@ -623,1 +623,1 @@\n-      assert(src_klass != NULL && dest_klass != NULL, \"should have klasses\");\n+      assert(src_klass != nullptr && dest_klass != nullptr, \"should have klasses\");\n@@ -646,1 +646,1 @@\n-        Node* n1 = LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n+        Node* n1 = LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n@@ -653,1 +653,1 @@\n-        if (cv == NULL)  cv = intcon(-1);  \/\/ failure (no stub available)\n+        if (cv == nullptr)  cv = intcon(-1);  \/\/ failure (no stub available)\n@@ -663,1 +663,1 @@\n-    if (!bs->array_copy_requires_gc_barriers(alloc != NULL, copy_type, false, false, BarrierSetC2::Expansion)) {\n+    if (!bs->array_copy_requires_gc_barriers(alloc != nullptr, copy_type, false, false, BarrierSetC2::Expansion)) {\n@@ -689,1 +689,1 @@\n-  assert(slow_region != NULL, \"allocated on entry\");\n+  assert(slow_region != nullptr, \"allocated on entry\");\n@@ -732,1 +732,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -772,1 +772,1 @@\n-                           intcon(0), NULL,\n+                           intcon(0), nullptr,\n@@ -792,1 +792,1 @@\n-    if (result_region->in(i) == NULL) {\n+    if (result_region->in(i) == nullptr) {\n@@ -804,1 +804,1 @@\n-  DEBUG_ONLY(mem = NULL);\n+  DEBUG_ONLY(mem = nullptr);\n@@ -818,1 +818,1 @@\n-  if (alloc != NULL && !alloc->initialization()->does_not_escape()) {\n+  if (alloc != nullptr && !alloc->initialization()->does_not_escape()) {\n@@ -834,1 +834,1 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n+  if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -842,1 +842,1 @@\n-    ArrayCopyNode* ac = NULL;\n+    ArrayCopyNode* ac = nullptr;\n@@ -844,1 +844,1 @@\n-    assert(ac == NULL, \"no arraycopy anymore\");\n+    assert(ac == nullptr, \"no arraycopy anymore\");\n@@ -868,1 +868,1 @@\n-\/\/   slice_len          number of elements to store (or NULL)\n+\/\/   slice_len          number of elements to store (or null)\n@@ -871,3 +871,3 @@\n-\/\/ Exactly one of slice_len or dest_size must be non-NULL.\n-\/\/ If dest_size is non-NULL, zeroing extends to the end of the object.\n-\/\/ If slice_len is non-NULL, the slice_idx value must be a constant.\n+\/\/ Exactly one of slice_len or dest_size must be non-null.\n+\/\/ If dest_size is non-null, zeroing extends to the end of the object.\n+\/\/ If slice_len is non-null, the slice_idx value must be a constant.\n@@ -882,3 +882,3 @@\n-  assert((slice_len != NULL? 1: 0) + (dest_size != NULL? 1: 0) == 1, \"\");\n-  if (slice_len == NULL)  slice_len = top();\n-  if (dest_size == NULL)  dest_size = top();\n+  assert((slice_len != nullptr? 1: 0) + (dest_size != nullptr? 1: 0) == 1, \"\");\n+  if (slice_len == nullptr)  slice_len = top();\n+  if (dest_size == nullptr)  dest_size = top();\n@@ -1044,1 +1044,1 @@\n-  bool disjoint_bases = true;   \/\/ since alloc != NULL\n+  bool disjoint_bases = true;   \/\/ since alloc isn't null\n@@ -1047,1 +1047,1 @@\n-                               sptr, NULL, dptr, NULL, countx, dest_uninitialized);\n+                               sptr, nullptr, dptr, nullptr, countx, dest_uninitialized);\n@@ -1101,2 +1101,2 @@\n-  \/\/ could be NULL. Skip clone and update NULL fallthrough_ioproj.\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n+  \/\/ could be null. Skip clone and update null fallthrough_ioproj.\n+  if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -1106,1 +1106,1 @@\n-    *io = NULL;\n+    *io = nullptr;\n@@ -1119,1 +1119,1 @@\n-  if ((*ctrl)->is_top())  return NULL;\n+  if ((*ctrl)->is_top())  return nullptr;\n@@ -1122,2 +1122,2 @@\n-  if (copyfunc_addr == NULL) { \/\/ Stub was not generated, go slow path.\n-    return NULL;\n+  if (copyfunc_addr == nullptr) { \/\/ Stub was not generated, go slow path.\n+    return nullptr;\n@@ -1132,1 +1132,1 @@\n-  Node* n3 = new LoadINode(NULL, *mem \/*memory(p3)*\/, p3, _igvn.type(p3)->is_ptr(), TypeInt::INT, MemNode::unordered);\n+  Node* n3 = new LoadINode(nullptr, *mem \/*memory(p3)*\/, p3, _igvn.type(p3)->is_ptr(), TypeInt::INT, MemNode::unordered);\n@@ -1157,1 +1157,1 @@\n-  if ((*ctrl)->is_top()) return NULL;\n+  if ((*ctrl)->is_top()) return nullptr;\n@@ -1161,2 +1161,2 @@\n-  if (copyfunc_addr == NULL) { \/\/ Stub was not generated, go slow path.\n-    return NULL;\n+  if (copyfunc_addr == nullptr) { \/\/ Stub was not generated, go slow path.\n+    return nullptr;\n@@ -1189,1 +1189,1 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n@@ -1200,2 +1200,2 @@\n-  Node* result_memory = NULL;\n-  RegionNode* exit_block = NULL;\n+  Node* result_memory = nullptr;\n+  RegionNode* exit_block = nullptr;\n@@ -1245,1 +1245,1 @@\n-  MergeMemNode* merge_mem = NULL;\n+  MergeMemNode* merge_mem = nullptr;\n@@ -1256,1 +1256,1 @@\n-    AllocateArrayNode* alloc = NULL;\n+    AllocateArrayNode* alloc = nullptr;\n@@ -1259,1 +1259,1 @@\n-      assert(alloc != NULL, \"expect alloc\");\n+      assert(alloc != nullptr, \"expect alloc\");\n@@ -1274,1 +1274,1 @@\n-  AllocateArrayNode* alloc = NULL;\n+  AllocateArrayNode* alloc = nullptr;\n@@ -1277,1 +1277,1 @@\n-    assert(alloc != NULL, \"expect alloc\");\n+    assert(alloc != nullptr, \"expect alloc\");\n@@ -1295,1 +1295,1 @@\n-  if (top_dest != NULL && top_dest->klass() != NULL) {\n+  if (top_dest != nullptr && top_dest->klass() != nullptr) {\n@@ -1298,1 +1298,1 @@\n-  if (top_src != NULL && top_src->klass() != NULL) {\n+  if (top_src != nullptr && top_src->klass() != nullptr) {\n@@ -1322,1 +1322,1 @@\n-    Node* mem = generate_arraycopy(ac, NULL, &ctrl, merge_mem, &io,\n+    Node* mem = generate_arraycopy(ac, nullptr, &ctrl, merge_mem, &io,\n@@ -1344,1 +1344,1 @@\n-    if (_callprojs.fallthrough_ioproj != NULL) {\n+    if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -1393,1 +1393,1 @@\n-    assert(alen != NULL, \"need src len\");\n+    assert(alen != nullptr, \"need src len\");\n@@ -1401,1 +1401,1 @@\n-    assert(alen != NULL, \"need dest len\");\n+    assert(alen != nullptr, \"need dest len\");\n@@ -1411,1 +1411,1 @@\n-  const TypePtr* adr_type = NULL;\n+  const TypePtr* adr_type = nullptr;\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":92,"deletions":92,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -86,46 +86,46 @@\n-  idealreg2spillmask  [Op_RegI] = NULL;\n-  idealreg2spillmask  [Op_RegN] = NULL;\n-  idealreg2spillmask  [Op_RegL] = NULL;\n-  idealreg2spillmask  [Op_RegF] = NULL;\n-  idealreg2spillmask  [Op_RegD] = NULL;\n-  idealreg2spillmask  [Op_RegP] = NULL;\n-  idealreg2spillmask  [Op_VecA] = NULL;\n-  idealreg2spillmask  [Op_VecS] = NULL;\n-  idealreg2spillmask  [Op_VecD] = NULL;\n-  idealreg2spillmask  [Op_VecX] = NULL;\n-  idealreg2spillmask  [Op_VecY] = NULL;\n-  idealreg2spillmask  [Op_VecZ] = NULL;\n-  idealreg2spillmask  [Op_RegFlags] = NULL;\n-  idealreg2spillmask  [Op_RegVectMask] = NULL;\n-\n-  idealreg2debugmask  [Op_RegI] = NULL;\n-  idealreg2debugmask  [Op_RegN] = NULL;\n-  idealreg2debugmask  [Op_RegL] = NULL;\n-  idealreg2debugmask  [Op_RegF] = NULL;\n-  idealreg2debugmask  [Op_RegD] = NULL;\n-  idealreg2debugmask  [Op_RegP] = NULL;\n-  idealreg2debugmask  [Op_VecA] = NULL;\n-  idealreg2debugmask  [Op_VecS] = NULL;\n-  idealreg2debugmask  [Op_VecD] = NULL;\n-  idealreg2debugmask  [Op_VecX] = NULL;\n-  idealreg2debugmask  [Op_VecY] = NULL;\n-  idealreg2debugmask  [Op_VecZ] = NULL;\n-  idealreg2debugmask  [Op_RegFlags] = NULL;\n-  idealreg2debugmask  [Op_RegVectMask] = NULL;\n-\n-  idealreg2mhdebugmask[Op_RegI] = NULL;\n-  idealreg2mhdebugmask[Op_RegN] = NULL;\n-  idealreg2mhdebugmask[Op_RegL] = NULL;\n-  idealreg2mhdebugmask[Op_RegF] = NULL;\n-  idealreg2mhdebugmask[Op_RegD] = NULL;\n-  idealreg2mhdebugmask[Op_RegP] = NULL;\n-  idealreg2mhdebugmask[Op_VecA] = NULL;\n-  idealreg2mhdebugmask[Op_VecS] = NULL;\n-  idealreg2mhdebugmask[Op_VecD] = NULL;\n-  idealreg2mhdebugmask[Op_VecX] = NULL;\n-  idealreg2mhdebugmask[Op_VecY] = NULL;\n-  idealreg2mhdebugmask[Op_VecZ] = NULL;\n-  idealreg2mhdebugmask[Op_RegFlags] = NULL;\n-  idealreg2mhdebugmask[Op_RegVectMask] = NULL;\n-\n-  debug_only(_mem_node = NULL;)   \/\/ Ideal memory node consumed by mach node\n+  idealreg2spillmask  [Op_RegI] = nullptr;\n+  idealreg2spillmask  [Op_RegN] = nullptr;\n+  idealreg2spillmask  [Op_RegL] = nullptr;\n+  idealreg2spillmask  [Op_RegF] = nullptr;\n+  idealreg2spillmask  [Op_RegD] = nullptr;\n+  idealreg2spillmask  [Op_RegP] = nullptr;\n+  idealreg2spillmask  [Op_VecA] = nullptr;\n+  idealreg2spillmask  [Op_VecS] = nullptr;\n+  idealreg2spillmask  [Op_VecD] = nullptr;\n+  idealreg2spillmask  [Op_VecX] = nullptr;\n+  idealreg2spillmask  [Op_VecY] = nullptr;\n+  idealreg2spillmask  [Op_VecZ] = nullptr;\n+  idealreg2spillmask  [Op_RegFlags] = nullptr;\n+  idealreg2spillmask  [Op_RegVectMask] = nullptr;\n+\n+  idealreg2debugmask  [Op_RegI] = nullptr;\n+  idealreg2debugmask  [Op_RegN] = nullptr;\n+  idealreg2debugmask  [Op_RegL] = nullptr;\n+  idealreg2debugmask  [Op_RegF] = nullptr;\n+  idealreg2debugmask  [Op_RegD] = nullptr;\n+  idealreg2debugmask  [Op_RegP] = nullptr;\n+  idealreg2debugmask  [Op_VecA] = nullptr;\n+  idealreg2debugmask  [Op_VecS] = nullptr;\n+  idealreg2debugmask  [Op_VecD] = nullptr;\n+  idealreg2debugmask  [Op_VecX] = nullptr;\n+  idealreg2debugmask  [Op_VecY] = nullptr;\n+  idealreg2debugmask  [Op_VecZ] = nullptr;\n+  idealreg2debugmask  [Op_RegFlags] = nullptr;\n+  idealreg2debugmask  [Op_RegVectMask] = nullptr;\n+\n+  idealreg2mhdebugmask[Op_RegI] = nullptr;\n+  idealreg2mhdebugmask[Op_RegN] = nullptr;\n+  idealreg2mhdebugmask[Op_RegL] = nullptr;\n+  idealreg2mhdebugmask[Op_RegF] = nullptr;\n+  idealreg2mhdebugmask[Op_RegD] = nullptr;\n+  idealreg2mhdebugmask[Op_RegP] = nullptr;\n+  idealreg2mhdebugmask[Op_VecA] = nullptr;\n+  idealreg2mhdebugmask[Op_VecS] = nullptr;\n+  idealreg2mhdebugmask[Op_VecD] = nullptr;\n+  idealreg2mhdebugmask[Op_VecX] = nullptr;\n+  idealreg2mhdebugmask[Op_VecY] = nullptr;\n+  idealreg2mhdebugmask[Op_VecZ] = nullptr;\n+  idealreg2mhdebugmask[Op_RegFlags] = nullptr;\n+  idealreg2mhdebugmask[Op_RegVectMask] = nullptr;\n+\n+  debug_only(_mem_node = nullptr;)   \/\/ Ideal memory node consumed by mach node\n@@ -175,1 +175,1 @@\n-      if (in != NULL) {\n+      if (in != nullptr) {\n@@ -327,1 +327,1 @@\n-  \/\/ Create new ideal node ConP #NULL even if it does exist in old space\n+  \/\/ Create new ideal node ConP #null even if it does exist in old space\n@@ -338,1 +338,1 @@\n-  if (_old_node_note_array != NULL) {\n+  if (_old_node_note_array != nullptr) {\n@@ -341,1 +341,1 @@\n-                            0, NULL));\n+                            0, nullptr));\n@@ -358,1 +358,1 @@\n-    if (xroot == NULL) {\n+    if (xroot == nullptr) {\n@@ -375,2 +375,2 @@\n-      \/\/ Generate new mach node for ConP #NULL\n-      assert(new_ideal_null != NULL, \"sanity\");\n+      \/\/ Generate new mach node for ConP #null\n+      assert(new_ideal_null != nullptr, \"sanity\");\n@@ -381,1 +381,1 @@\n-      assert(_mach_null != NULL, \"\");\n+      assert(_mach_null != nullptr, \"\");\n@@ -383,1 +383,1 @@\n-      C->set_root(xroot->is_Root() ? xroot->as_Root() : NULL);\n+      C->set_root(xroot->is_Root() ? xroot->as_Root() : nullptr);\n@@ -390,1 +390,1 @@\n-  if (C->top() == NULL || C->root() == NULL) {\n+  if (C->top() == nullptr || C->root() == nullptr) {\n@@ -992,1 +992,1 @@\n-      if (n1at != NULL) {\n+      if (n1at != nullptr) {\n@@ -1042,1 +1042,1 @@\n-      nat = NULL;\n+      nat = nullptr;\n@@ -1065,1 +1065,1 @@\n-  mstack.push(n, Visit, NULL, -1);  \/\/ set NULL as parent to indicate root\n+  mstack.push(n, Visit, nullptr, -1);  \/\/ set null as parent to indicate root\n@@ -1068,1 +1068,1 @@\n-    if (C->failing()) return NULL;\n+    if (C->failing()) return nullptr;\n@@ -1085,2 +1085,2 @@\n-            if (C->failing())  return NULL;\n-            if (m == NULL) { Matcher::soft_match_failure(); return NULL; }\n+            if (C->failing())  return nullptr;\n+            if (m == nullptr) { Matcher::soft_match_failure(); return nullptr; }\n@@ -1091,1 +1091,1 @@\n-            if (n->is_Proj() && n->in(0) != NULL && n->in(0)->is_Multi()) {       \/\/ Projections?\n+            if (n->is_Proj() && n->in(0) != nullptr && n->in(0)->is_Multi()) {       \/\/ Projections?\n@@ -1095,1 +1095,1 @@\n-              if (m->in(0) != NULL) \/\/ m might be top\n+              if (m->in(0) != nullptr) \/\/ m might be top\n@@ -1107,1 +1107,1 @@\n-          if (_old_node_note_array != NULL) {\n+          if (_old_node_note_array != nullptr) {\n@@ -1125,1 +1125,1 @@\n-        if (m == NULL) break;\n+        if (m == nullptr) break;\n@@ -1133,1 +1133,1 @@\n-        if (m == NULL || C->node_arena()->contains(m)) continue;\n+        if (m == nullptr || C->node_arena()->contains(m)) continue;\n@@ -1168,1 +1168,1 @@\n-        if(m != NULL)\n+        if(m != nullptr)\n@@ -1176,1 +1176,1 @@\n-      if (p != NULL) { \/\/ root doesn't have parent\n+      if (p != nullptr) { \/\/ root doesn't have parent\n@@ -1222,2 +1222,2 @@\n-  MachSafePointNode *msfpt = NULL;\n-  MachCallNode      *mcall = NULL;\n+  MachSafePointNode *msfpt = nullptr;\n+  MachCallNode      *mcall = nullptr;\n@@ -1228,1 +1228,1 @@\n-  ciMethod*        method = NULL;\n+  ciMethod*        method = nullptr;\n@@ -1237,2 +1237,2 @@\n-    if (C->failing())  return NULL;\n-    if( m == NULL ) { Matcher::soft_match_failure(); return NULL; }\n+    if (C->failing())  return nullptr;\n+    if( m == nullptr ) { Matcher::soft_match_failure(); return nullptr; }\n@@ -1285,2 +1285,2 @@\n-    call = NULL;\n-    domain = NULL;\n+    call = nullptr;\n+    domain = nullptr;\n@@ -1288,1 +1288,1 @@\n-    if (C->failing())  return NULL;\n+    if (C->failing())  return nullptr;\n@@ -1313,1 +1313,1 @@\n-  if( call != NULL && call->is_CallRuntime() )\n+  if( call != nullptr && call->is_CallRuntime() )\n@@ -1315,1 +1315,1 @@\n-  if( call != NULL && call->is_CallNative() )\n+  if( call != nullptr && call->is_CallNative() )\n@@ -1426,1 +1426,1 @@\n-  assert((mcall == NULL) || (mcall->jvms() == NULL) ||\n+  assert((mcall == nullptr) || (mcall->jvms() == nullptr) ||\n@@ -1465,1 +1465,1 @@\n-  _mem_node = n->is_Store() ? (Node*)n : NULL;\n+  _mem_node = n->is_Store() ? (Node*)n : nullptr;\n@@ -1470,2 +1470,2 @@\n-  s->_kids[0] = NULL;\n-  s->_kids[1] = NULL;\n+  s->_kids[0] = nullptr;\n+  s->_kids[1] = nullptr;\n@@ -1476,1 +1476,1 @@\n-  if (C->failing())  return NULL;\n+  if (C->failing())  return nullptr;\n@@ -1496,1 +1496,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1543,1 +1543,1 @@\n-    Node* mem_control = (m->is_Load()) ? m->in(MemNode::Memory)->in(0) : NULL;\n+    Node* mem_control = (m->is_Load()) ? m->in(MemNode::Memory)->in(0) : nullptr;\n@@ -1597,1 +1597,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1607,1 +1607,1 @@\n-  Node *input_mem = NULL;\n+  Node *input_mem = nullptr;\n@@ -1613,1 +1613,1 @@\n-      if( input_mem == NULL ) {\n+      if( input_mem == nullptr ) {\n@@ -1635,2 +1635,2 @@\n-    s->_kids[0] = NULL;\n-    s->_kids[1] = NULL;\n+    s->_kids[0] = nullptr;\n+    s->_kids[1] = nullptr;\n@@ -1661,1 +1661,1 @@\n-      if( control == NULL && m->in(0) != NULL && m->req() > 1 )\n+      if( control == nullptr && m->in(0) != nullptr && m->req() > 1 )\n@@ -1665,1 +1665,1 @@\n-      if (C->failing()) return NULL;\n+      if (C->failing()) return nullptr;\n@@ -1693,1 +1693,1 @@\n-  if (!leaf->is_Con() && !leaf->is_DecodeNarrowPtr()) return NULL;\n+  if (!leaf->is_Con() && !leaf->is_DecodeNarrowPtr()) return nullptr;\n@@ -1696,1 +1696,1 @@\n-  if (_shared_nodes.Size() <= leaf->_idx) return NULL;\n+  if (_shared_nodes.Size() <= leaf->_idx) return nullptr;\n@@ -1698,1 +1698,1 @@\n-  if (last != NULL && rule == last->rule()) {\n+  if (last != nullptr && rule == last->rule()) {\n@@ -1704,1 +1704,1 @@\n-    if (xroot == NULL) {\n+    if (xroot == nullptr) {\n@@ -1706,1 +1706,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1713,1 +1713,1 @@\n-      if (control == NULL || control == C->root()) {\n+      if (control == nullptr || control == C->root()) {\n@@ -1717,1 +1717,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1722,1 +1722,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1748,1 +1748,1 @@\n-  if (shared_node != NULL) {\n+  if (shared_node != nullptr) {\n@@ -1754,1 +1754,1 @@\n-  guarantee(mach != NULL, \"Missing MachNode\");\n+  guarantee(mach != nullptr, \"Missing MachNode\");\n@@ -1756,1 +1756,1 @@\n-  assert( mach->_opnds[0] != NULL, \"Missing result operand\" );\n+  assert( mach->_opnds[0] != nullptr, \"Missing result operand\" );\n@@ -1779,1 +1779,1 @@\n-    if (oper != NULL && oper != (MachOper*)-1) {\n+    if (oper != nullptr && oper != (MachOper*)-1) {\n@@ -1781,1 +1781,1 @@\n-      Node* m = NULL;\n+      Node* m = nullptr;\n@@ -1786,1 +1786,1 @@\n-        assert(m != NULL && m->is_Mem(), \"expecting memory node\");\n+        assert(m != nullptr && m->is_Mem(), \"expecting memory node\");\n@@ -1825,1 +1825,1 @@\n-      mach->set_req(i,NULL);\n+      mach->set_req(i,nullptr);\n@@ -1858,1 +1858,1 @@\n-    if (n->in(i) != NULL) {\n+    if (n->in(i) != nullptr) {\n@@ -1905,2 +1905,2 @@\n-  if( s->_leaf->in(0) != NULL && s->_leaf->req() > 1) {\n-    if( mach->in(0) == NULL )\n+  if( s->_leaf->in(0) != nullptr && s->_leaf->req() > 1) {\n+    if( mach->in(0) == nullptr )\n@@ -1913,1 +1913,1 @@\n-    if( newstate == NULL ) break;      \/\/ Might only have 1 child\n+    if( newstate == nullptr ) break;      \/\/ Might only have 1 child\n@@ -1968,1 +1968,1 @@\n-  assert( kid == NULL || s->_leaf->in(0) == NULL, \"internal operands have no control\" );\n+  assert( kid == nullptr || s->_leaf->in(0) == nullptr, \"internal operands have no control\" );\n@@ -1971,1 +1971,1 @@\n-  if( kid == NULL && !_swallowed[rule] ) {\n+  if( kid == nullptr && !_swallowed[rule] ) {\n@@ -1992,1 +1992,1 @@\n-  for (uint i = 0; kid != NULL && i < 2; kid = s->_kids[1], i++) {   \/\/ binary tree\n+  for (uint i = 0; kid != nullptr && i < 2; kid = s->_kids[1], i++) {   \/\/ binary tree\n@@ -2032,1 +2032,1 @@\n-  if (n != NULL && m != NULL) {\n+  if (n != nullptr && m != nullptr) {\n@@ -2112,2 +2112,2 @@\n-        if (m == NULL) {\n-          continue;  \/\/ Ignore NULLs\n+        if (m == nullptr) {\n+          continue;  \/\/ Ignore nulls\n@@ -2492,1 +2492,1 @@\n-          \/\/ use it to do implicit NULL check in address.\n+          \/\/ use it to do implicit null check in address.\n@@ -2502,1 +2502,1 @@\n-              val->set_req(0, NULL); \/\/ Unpin now.\n+              val->set_req(0, nullptr); \/\/ Unpin now.\n@@ -2504,1 +2504,1 @@\n-              \/\/ a regular case: CmpP(DecodeN, NULL).\n+              \/\/ a regular case: CmpP(DecodeN, null).\n@@ -2518,1 +2518,1 @@\n-\/\/ Its possible that the value being NULL checked is not the root of a match\n+\/\/ Its possible that the value being null checked is not the root of a match\n@@ -2530,1 +2530,1 @@\n-        assert(val->is_DecodeNarrowPtr() && val->in(0) == NULL, \"sanity\");\n+        assert(val->is_DecodeNarrowPtr() && val->in(0) == nullptr, \"sanity\");\n@@ -2535,1 +2535,1 @@\n-        new_val->set_req(0, NULL);\n+        new_val->set_req(0, nullptr);\n@@ -2561,1 +2561,1 @@\n-          CompressedOops::base() != NULL);\n+          CompressedOops::base() != nullptr);\n@@ -2567,1 +2567,1 @@\n-  if (t == NULL) {\n+  if (t == nullptr) {\n@@ -2569,1 +2569,1 @@\n-    return NULL; \/\/ not supported\n+    return nullptr; \/\/ not supported\n@@ -2578,6 +2578,6 @@\n-    case Op_RegN: spill = new LoadNNode(NULL, mem, fp, atp, t->is_narrowoop(), mo); break;\n-    case Op_RegI: spill = new LoadINode(NULL, mem, fp, atp, t->is_int(),       mo); break;\n-    case Op_RegP: spill = new LoadPNode(NULL, mem, fp, atp, t->is_ptr(),       mo); break;\n-    case Op_RegF: spill = new LoadFNode(NULL, mem, fp, atp, t,                 mo); break;\n-    case Op_RegD: spill = new LoadDNode(NULL, mem, fp, atp, t,                 mo); break;\n-    case Op_RegL: spill = new LoadLNode(NULL, mem, fp, atp, t->is_long(),      mo); break;\n+    case Op_RegN: spill = new LoadNNode(nullptr, mem, fp, atp, t->is_narrowoop(), mo); break;\n+    case Op_RegI: spill = new LoadINode(nullptr, mem, fp, atp, t->is_int(),       mo); break;\n+    case Op_RegP: spill = new LoadPNode(nullptr, mem, fp, atp, t->is_ptr(),       mo); break;\n+    case Op_RegF: spill = new LoadFNode(nullptr, mem, fp, atp, t,                 mo); break;\n+    case Op_RegD: spill = new LoadDNode(nullptr, mem, fp, atp, t,                 mo); break;\n+    case Op_RegL: spill = new LoadLNode(nullptr, mem, fp, atp, t->is_long(),      mo); break;\n@@ -2590,1 +2590,1 @@\n-    case Op_VecZ: spill = new LoadVectorNode(NULL, mem, fp, atp, t->is_vect()); break;\n+    case Op_VecZ: spill = new LoadVectorNode(nullptr, mem, fp, atp, t->is_vect()); break;\n@@ -2596,1 +2596,1 @@\n-  assert(mspill != NULL, \"matching failed: %d\", ideal_reg);\n+  assert(mspill != nullptr, \"matching failed: %d\", ideal_reg);\n@@ -2632,1 +2632,1 @@\n-  Node* def = NULL;\n+  Node* def = nullptr;\n@@ -2677,1 +2677,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -2700,1 +2700,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -2723,1 +2723,1 @@\n-  Node* ctrl = NULL;\n+  Node* ctrl = nullptr;\n@@ -2733,1 +2733,1 @@\n-  assert((ctrl != NULL), \"missing control projection\");\n+  assert((ctrl != nullptr), \"missing control projection\");\n@@ -2808,1 +2808,1 @@\n-  Node *ifFalse = NULL;\n+  Node *ifFalse = nullptr;\n@@ -2820,3 +2820,3 @@\n-  while (reg != NULL && cnt > 0) {\n-    CallNode *call = NULL;\n-    RegionNode *nxt_reg = NULL;\n+  while (reg != nullptr && cnt > 0) {\n+    CallNode *call = nullptr;\n+    RegionNode *nxt_reg = nullptr;\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":144,"deletions":144,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    _nodes.map(idx_limit-1, NULL);\n+    _nodes.map(idx_limit-1, nullptr);\n@@ -154,1 +154,1 @@\n-    return _nodes.at(n->_idx) != NULL;\n+    return _nodes.at(n->_idx) != nullptr;\n@@ -172,1 +172,1 @@\n-  \/\/ Mach node for ConP #NULL\n+  \/\/ Mach node for ConP #null\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,2 +195,2 @@\n-    if (type1 == NULL || type2 == NULL) {\n-      return NULL;\n+    if (type1 == nullptr || type2 == nullptr) {\n+      return nullptr;\n@@ -207,1 +207,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -209,1 +209,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -221,1 +221,1 @@\n-    if (i1 == NULL || i2 == NULL) {\n+    if (i1 == nullptr || i2 == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/mathexactnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-  if (adr == NULL)  return NULL; \/\/ node is dead\n-  const TypePtr* cross_check = NULL;\n+  if (adr == nullptr)  return nullptr; \/\/ node is dead\n+  const TypePtr* cross_check = nullptr;\n@@ -75,1 +75,1 @@\n-  if (adr != NULL) {\n+  if (adr != nullptr) {\n@@ -85,1 +85,1 @@\n-  if (in(Address) == NULL)  return; \/\/ node is dead\n+  if (in(Address) == nullptr)  return; \/\/ node is dead\n@@ -88,2 +88,2 @@\n-  const TypePtr* _adr_type = NULL;\n-  if (in(Address) != NULL)\n+  const TypePtr* _adr_type = nullptr;\n+  if (in(Address) != nullptr)\n@@ -111,2 +111,2 @@\n-  if (adr_type == NULL) {\n-    st->print(\"NULL\");\n+  if (adr_type == nullptr) {\n+    st->print(\"null\");\n@@ -116,1 +116,1 @@\n-    Compile::AliasType* atp = NULL;\n+    Compile::AliasType* atp = nullptr;\n@@ -118,1 +118,1 @@\n-    if (atp == NULL)\n+    if (atp == nullptr)\n@@ -142,1 +142,1 @@\n-  assert((t_oop != NULL), \"sanity\");\n+  assert((t_oop != nullptr), \"sanity\");\n@@ -145,2 +145,2 @@\n-                             (load != NULL) && load->is_Load() &&\n-                             (phase->is_IterGVN() != NULL);\n+                             (load != nullptr) && load->is_Load() &&\n+                             (phase->is_IterGVN() != nullptr);\n@@ -151,1 +151,1 @@\n-  Node *prev = NULL;\n+  Node *prev = nullptr;\n@@ -172,1 +172,1 @@\n-        if ((alloc == NULL) || (alloc->_idx == instance_id)) {\n+        if ((alloc == nullptr) || (alloc->_idx == instance_id)) {\n@@ -185,1 +185,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -201,1 +201,1 @@\n-      result = step_through_mergemem(phase, result->as_MergeMem(), t_oop, NULL, tty);\n+      result = step_through_mergemem(phase, result->as_MergeMem(), t_oop, nullptr, tty);\n@@ -209,1 +209,1 @@\n-  if (t_oop == NULL)\n+  if (t_oop == nullptr)\n@@ -214,1 +214,1 @@\n-  if (is_instance && igvn != NULL && result->is_Phi()) {\n+  if (is_instance && igvn != nullptr && result->is_Phi()) {\n@@ -239,1 +239,1 @@\n-    bool consistent =  adr_check == NULL || adr_check->empty() ||\n+    bool consistent =  adr_check == nullptr || adr_check->empty() ||\n@@ -242,1 +242,1 @@\n-    if( !consistent && adr_check != NULL && !adr_check->empty() &&\n+    if( !consistent && adr_check != nullptr && !adr_check->empty() &&\n@@ -253,2 +253,2 @@\n-      if( adr_check == NULL ) {\n-        st->print(\"NULL\");\n+      if( adr_check == nullptr ) {\n+        st->print(\"null\");\n@@ -270,1 +270,1 @@\n-        toop->klass() != NULL &&\n+        toop->klass() != nullptr &&\n@@ -299,3 +299,3 @@\n-  if (ctl && can_reshape && igvn != NULL) {\n-    Node* bol = NULL;\n-    Node* cmp = NULL;\n+  if (ctl && can_reshape && igvn != nullptr) {\n+    Node* bol = nullptr;\n+    Node* cmp = nullptr;\n@@ -309,2 +309,2 @@\n-        (bol != NULL && igvn->_worklist.member(bol)) ||\n-        (cmp != NULL && igvn->_worklist.member(cmp)) ) {\n+        (bol != nullptr && igvn->_worklist.member(bol)) ||\n+        (cmp != nullptr && igvn->_worklist.member(cmp)) ) {\n@@ -314,1 +314,1 @@\n-      return NodeSentinel; \/\/ caller will return NULL\n+      return NodeSentinel; \/\/ caller will return null\n@@ -319,1 +319,1 @@\n-  if (phase->type( mem ) == Type::TOP) return NodeSentinel; \/\/ caller will return NULL\n+  if (phase->type( mem ) == Type::TOP) return NodeSentinel; \/\/ caller will return null\n@@ -322,1 +322,1 @@\n-  if (can_reshape && igvn != NULL && igvn->_worklist.member(mem)) {\n+  if (can_reshape && igvn != nullptr && igvn->_worklist.member(mem)) {\n@@ -326,1 +326,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -331,1 +331,1 @@\n-  if (t_adr == Type::TOP)              return NodeSentinel; \/\/ caller will return NULL\n+  if (t_adr == Type::TOP)              return NodeSentinel; \/\/ caller will return null\n@@ -336,1 +336,1 @@\n-    assert(ctl != NULL, \"unsafe accesses should be control dependent\");\n+    assert(ctl != nullptr, \"unsafe accesses should be control dependent\");\n@@ -351,1 +351,1 @@\n-  if (can_reshape && igvn != NULL &&\n+  if (can_reshape && igvn != nullptr &&\n@@ -357,1 +357,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -367,1 +367,1 @@\n-  Node* base = NULL;\n+  Node* base = nullptr;\n@@ -371,1 +371,1 @@\n-  if (base != NULL && phase->type(base)->higher_equal(TypePtr::NULL_PTR) &&\n+  if (base != nullptr && phase->type(base)->higher_equal(TypePtr::NULL_PTR) &&\n@@ -375,1 +375,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -398,1 +398,1 @@\n-    if (can_reshape && old_mem->outcnt() == 0 && igvn != NULL) {\n+    if (can_reshape && old_mem->outcnt() == 0 && igvn != nullptr) {\n@@ -406,1 +406,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -417,1 +417,1 @@\n-  if (dom == NULL || dom->is_top() || sub == NULL || sub->is_top())\n+  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n@@ -422,1 +422,1 @@\n-  if (dom == NULL || dom->is_top())\n+  if (dom == nullptr || dom->is_top())\n@@ -439,1 +439,1 @@\n-  \/\/ 'sub' should have sub->in(0) != NULL.\n+  \/\/ 'sub' should have sub->in(0) != nullptr.\n@@ -446,1 +446,1 @@\n-  if (sub == NULL || sub->is_top())\n+  if (sub == nullptr || sub->is_top())\n@@ -474,1 +474,1 @@\n-        if (n == NULL || n->is_top())\n+        if (n == nullptr || n->is_top())\n@@ -488,1 +488,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -497,1 +497,1 @@\n-          if (m == NULL || m->is_top())\n+          if (m == nullptr || m->is_top())\n@@ -519,1 +519,1 @@\n-  if (a1 == NULL && a2 == NULL) {           \/\/ neither an allocation\n+  if (a1 == nullptr && a2 == nullptr) {           \/\/ neither an allocation\n@@ -521,1 +521,1 @@\n-  } else if (a1 != NULL && a2 != NULL) {    \/\/ both allocations\n+  } else if (a1 != nullptr && a2 != nullptr) {    \/\/ both allocations\n@@ -523,1 +523,1 @@\n-  } else if (a1 != NULL) {                  \/\/ one allocation a1\n+  } else if (a1 != nullptr) {                  \/\/ one allocation a1\n@@ -526,1 +526,1 @@\n-  } else { \/\/(a2 != NULL)                   \/\/ one allocation a2\n+  } else { \/\/(a2 != null)                   \/\/ one allocation a2\n@@ -540,1 +540,1 @@\n-\/\/ Otherwise return NULL.\n+\/\/ Otherwise return null.\n@@ -543,1 +543,1 @@\n-  if (ac != NULL) {\n+  if (ac != nullptr) {\n@@ -551,1 +551,1 @@\n-    if (ary_t != NULL && ld_addp->is_AddP()) {\n+    if (ary_t != nullptr && ld_addp->is_AddP()) {\n@@ -567,2 +567,2 @@\n-    \/\/ dependent on the runtime range check. This is achieved by returning NULL.\n-  } else if (mem->is_Proj() && mem->in(0) != NULL && mem->in(0)->is_ArrayCopy()) {\n+    \/\/ dependent on the runtime range check. This is achieved by returning null.\n+  } else if (mem->is_Proj() && mem->in(0) != nullptr && mem->in(0)->is_ArrayCopy()) {\n@@ -594,1 +594,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -598,1 +598,1 @@\n-  if (mem->is_Proj() && mem->in(0) != NULL && (mem->in(0)->Opcode() == Op_MemBarStoreStore ||\n+  if (mem->is_Proj() && mem->in(0) != nullptr && (mem->in(0)->Opcode() == Op_MemBarStoreStore ||\n@@ -600,1 +600,1 @@\n-    if (ld_alloc != NULL) {\n+    if (ld_alloc != nullptr) {\n@@ -603,3 +603,3 @@\n-      ArrayCopyNode* ac = NULL;\n-      if (mb->in(0) != NULL && mb->in(0)->is_Proj() &&\n-          mb->in(0)->in(0) != NULL && mb->in(0)->in(0)->is_ArrayCopy()) {\n+      ArrayCopyNode* ac = nullptr;\n+      if (mb->in(0) != nullptr && mb->in(0)->is_Proj() &&\n+          mb->in(0)->in(0) != nullptr && mb->in(0)->in(0)->is_ArrayCopy()) {\n@@ -617,1 +617,1 @@\n-      if (ac != NULL && ac->is_clonebasic()) {\n+      if (ac != nullptr && ac->is_clonebasic()) {\n@@ -619,1 +619,1 @@\n-        if (alloc != NULL && alloc == ld_alloc) {\n+        if (alloc != nullptr && alloc == ld_alloc) {\n@@ -625,1 +625,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -649,1 +649,1 @@\n-    return NULL;            \/\/ cannot unalias unless there are precise offsets\n+    return nullptr;            \/\/ cannot unalias unless there are precise offsets\n@@ -667,1 +667,1 @@\n-      if (st_base == NULL)\n+      if (st_base == nullptr)\n@@ -710,1 +710,1 @@\n-      if (st_alloc == NULL)\n+      if (st_alloc == nullptr)\n@@ -716,1 +716,1 @@\n-      else if (alloc != NULL)\n+      else if (alloc != nullptr)\n@@ -741,1 +741,1 @@\n-    } else if (find_previous_arraycopy(phase, alloc, mem, false) != NULL) {\n+    } else if (find_previous_arraycopy(phase, alloc, mem, false) != nullptr) {\n@@ -748,1 +748,1 @@\n-    } else if (addr_t != NULL && addr_t->is_known_instance_field()) {\n+    } else if (addr_t != nullptr && addr_t->is_known_instance_field()) {\n@@ -758,1 +758,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -785,1 +785,1 @@\n-  return NULL;              \/\/ bail out\n+  return nullptr;              \/\/ bail out\n@@ -792,1 +792,1 @@\n-  if (t == Type::TOP)  return NULL; \/\/ does not touch memory any more?\n+  if (t == Type::TOP)  return nullptr; \/\/ does not touch memory any more?\n@@ -794,1 +794,1 @@\n-  if (!VerifyAliases || VMError::is_error_reported() || Node::in_dump())  cross_check = NULL;\n+  if (!VerifyAliases || VMError::is_error_reported() || Node::in_dump())  cross_check = nullptr;\n@@ -797,2 +797,2 @@\n-  if (tp == NULL) {\n-    assert(cross_check == NULL || cross_check == TypePtr::BOTTOM, \"expected memory type must be wide\");\n+  if (tp == nullptr) {\n+    assert(cross_check == nullptr || cross_check == TypePtr::BOTTOM, \"expected memory type must be wide\");\n@@ -804,1 +804,1 @@\n-    if (cross_check != NULL &&\n+    if (cross_check != nullptr &&\n@@ -886,1 +886,1 @@\n-  assert( ctl != NULL || C->get_alias_index(adr_type) != Compile::AliasIdxRaw ||\n+  assert( ctl != nullptr || C->get_alias_index(adr_type) != Compile::AliasIdxRaw ||\n@@ -890,1 +890,1 @@\n-  LoadNode* load = NULL;\n+  LoadNode* load = nullptr;\n@@ -916,1 +916,1 @@\n-  assert(load != NULL, \"LoadNode should have been created\");\n+  assert(load != nullptr, \"LoadNode should have been created\");\n@@ -942,2 +942,2 @@\n-  if ((atp != NULL) && (atp->index() >= Compile::AliasIdxRaw)) {\n-    bool non_volatile = (atp->field() != NULL) && !atp->field()->is_volatile();\n+  if ((atp != nullptr) && (atp->index() >= Compile::AliasIdxRaw)) {\n+    bool non_volatile = (atp->field() != nullptr) && !atp->field()->is_volatile();\n@@ -945,1 +945,1 @@\n-                         (tp != NULL) && (tp->isa_aryptr() != NULL) &&\n+                         (tp != nullptr) && (tp->isa_aryptr() != nullptr) &&\n@@ -962,1 +962,1 @@\n-  if (ac != NULL) {\n+  if (ac != nullptr) {\n@@ -970,1 +970,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -976,1 +976,1 @@\n-      assert(ld_alloc != NULL, \"need an alloc\");\n+      assert(ld_alloc != nullptr, \"need an alloc\");\n@@ -1017,1 +1017,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1034,1 +1034,1 @@\n-  Compile::AliasType* atp = (tp != NULL) ? phase->C->alias_type(tp) : NULL;\n+  Compile::AliasType* atp = (tp != nullptr) ? phase->C->alias_type(tp) : nullptr;\n@@ -1038,1 +1038,1 @@\n-    Node* result = NULL;\n+    Node* result = nullptr;\n@@ -1074,1 +1074,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -1089,5 +1089,5 @@\n-        if (ld_base == NULL)                                   return NULL;\n-        if (st_base == NULL)                                   return NULL;\n-        if (!ld_base->eqv_uncast(st_base, \/*keep_deps=*\/true)) return NULL;\n-        if (ld_off != st_off)                                  return NULL;\n-        if (ld_off == Type::OffsetBot)                         return NULL;\n+        if (ld_base == nullptr)                                return nullptr;\n+        if (st_base == nullptr)                                return nullptr;\n+        if (!ld_base->eqv_uncast(st_base, \/*keep_deps=*\/true)) return nullptr;\n+        if (ld_off != st_off)                                  return nullptr;\n+        if (ld_off == Type::OffsetBot)                         return nullptr;\n@@ -1109,1 +1109,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1116,1 +1116,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1133,1 +1133,1 @@\n-        if (ReduceBulkZeroing || find_array_copy_clone(phase, ld_alloc, in(MemNode::Memory)) == NULL) {\n+        if (ReduceBulkZeroing || find_array_copy_clone(phase, ld_alloc, in(MemNode::Memory)) == nullptr) {\n@@ -1149,1 +1149,1 @@\n-      if ((alloc != NULL) && (alloc == ld_alloc)) {\n+      if ((alloc != nullptr) && (alloc == ld_alloc)) {\n@@ -1152,1 +1152,1 @@\n-        if (st != NULL) {\n+        if (st != nullptr) {\n@@ -1160,1 +1160,1 @@\n-        (tp != NULL) && tp->is_ptr_to_boxed_value()) {\n+        (tp != nullptr) && tp->is_ptr_to_boxed_value()) {\n@@ -1165,1 +1165,1 @@\n-      if (base != NULL && base->is_Proj() &&\n+      if (base != nullptr && base->is_Proj() &&\n@@ -1176,1 +1176,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1185,1 +1185,1 @@\n-    if( t_oop != NULL &&\n+    if( t_oop != nullptr &&\n@@ -1239,1 +1239,1 @@\n-      if (base == NULL) {\n+      if (base == nullptr) {\n@@ -1260,1 +1260,1 @@\n-  const Type* rt = NULL;\n+  const Type* rt = nullptr;\n@@ -1268,1 +1268,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1278,1 +1278,1 @@\n-  const Type* rt = NULL;\n+  const Type* rt = nullptr;\n@@ -1288,1 +1288,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1312,1 +1312,1 @@\n-  if (raw_type == NULL) {\n+  if (raw_type == nullptr) {\n@@ -1346,1 +1346,1 @@\n-  if (raw_type == NULL) {\n+  if (raw_type == nullptr) {\n@@ -1364,1 +1364,1 @@\n-  if ((base == NULL) || base->is_Phi()) {\n+  if ((base == nullptr) || base->is_Phi()) {\n@@ -1368,1 +1368,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1380,1 +1380,1 @@\n-      return NULL; \/\/ Complex address\n+      return nullptr; \/\/ Complex address\n@@ -1384,1 +1384,1 @@\n-    if ((cache_base != NULL) && cache_base->is_DecodeN()) {\n+    if ((cache_base != nullptr) && cache_base->is_DecodeN()) {\n@@ -1388,1 +1388,1 @@\n-    if ((cache_base != NULL) && cache_base->is_Con()) {\n+    if ((cache_base != nullptr) && cache_base->is_Con()) {\n@@ -1390,1 +1390,1 @@\n-      if ((base_type != NULL) && base_type->is_autobox_cache()) {\n+      if ((base_type != nullptr) && base_type->is_autobox_cache()) {\n@@ -1415,1 +1415,1 @@\n-              return NULL; \/\/ should not happen since cache is array indexed by value\n+              return nullptr; \/\/ should not happen since cache is array indexed by value\n@@ -1419,1 +1419,1 @@\n-              return NULL; \/\/ should not happen since cache is array indexed by value\n+              return nullptr; \/\/ should not happen since cache is array indexed by value\n@@ -1471,1 +1471,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1476,1 +1476,1 @@\n-  if (region == NULL) {\n+  if (region == nullptr) {\n@@ -1482,1 +1482,1 @@\n-    if (rc == NULL || phase->type(rc) == Type::TOP)\n+    if (rc == nullptr || phase->type(rc) == Type::TOP)\n@@ -1485,1 +1485,1 @@\n-    if (in == NULL || phase->type(in) == Type::TOP)\n+    if (in == nullptr || phase->type(in) == Type::TOP)\n@@ -1496,1 +1496,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1502,1 +1502,1 @@\n-  assert((t_oop != NULL) &&\n+  assert((t_oop != nullptr) &&\n@@ -1509,1 +1509,1 @@\n-  bool base_is_phi = (base != NULL) && base->is_Phi();\n+  bool base_is_phi = (base != nullptr) && base->is_Phi();\n@@ -1511,1 +1511,1 @@\n-                           (base != NULL) && (base == address->in(AddPNode::Base)) &&\n+                           (base != nullptr) && (base == address->in(AddPNode::Base)) &&\n@@ -1516,1 +1516,1 @@\n-    return NULL; \/\/ memory is not Phi\n+    return nullptr; \/\/ memory is not Phi\n@@ -1521,1 +1521,1 @@\n-      return NULL; \/\/ Wait stable graph\n+      return nullptr; \/\/ Wait stable graph\n@@ -1546,1 +1546,1 @@\n-      return NULL; \/\/ Wait stable graph\n+      return nullptr; \/\/ Wait stable graph\n@@ -1553,1 +1553,1 @@\n-          return NULL; \/\/ Wait stable graph\n+          return nullptr; \/\/ Wait stable graph\n@@ -1565,1 +1565,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1575,1 +1575,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1581,1 +1581,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1589,1 +1589,1 @@\n-      return NULL; \/\/ complex graph\n+      return nullptr; \/\/ complex graph\n@@ -1605,1 +1605,1 @@\n-  Node* phi = new PhiNode(region, this_type, NULL, mem->_idx, this_iid, this_index, this_offset);\n+  Node* phi = new PhiNode(region, this_type, nullptr, mem->_idx, this_iid, this_index, this_offset);\n@@ -1608,1 +1608,1 @@\n-    Node* the_clone = NULL;\n+    Node* the_clone = nullptr;\n@@ -1611,1 +1611,1 @@\n-        in != NULL && in->is_OuterStripMinedLoop()) {\n+        in != nullptr && in->is_OuterStripMinedLoop()) {\n@@ -1615,1 +1615,1 @@\n-    if (in == NULL || in == C->top()) {\n+    if (in == nullptr || in == C->top()) {\n@@ -1624,1 +1624,1 @@\n-        x->set_req(0, NULL);\n+        x->set_req(0, nullptr);\n@@ -1676,1 +1676,1 @@\n-    if (x != the_clone && the_clone != NULL) {\n+    if (x != the_clone && the_clone != nullptr) {\n@@ -1691,2 +1691,2 @@\n-    if (alloc != NULL && mem->is_Proj() &&\n-        mem->in(0) != NULL &&\n+    if (alloc != nullptr && mem->is_Proj() &&\n+        mem->in(0) != nullptr &&\n@@ -1694,1 +1694,1 @@\n-        alloc->initialization()->proj_out_or_null(0) != NULL) {\n+        alloc->initialization()->proj_out_or_null(0) != nullptr) {\n@@ -1698,1 +1698,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1709,1 +1709,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1712,1 +1712,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -1723,1 +1723,1 @@\n-  if( ctrl != NULL && ctrl->Opcode() == Op_SafePoint &&\n+  if( ctrl != nullptr && ctrl->Opcode() == Op_SafePoint &&\n@@ -1734,1 +1734,1 @@\n-  if (base != NULL\n+  if (base != nullptr\n@@ -1737,1 +1737,1 @@\n-    if (in(MemNode::Control) != NULL\n+    if (in(MemNode::Control) != nullptr\n@@ -1742,1 +1742,1 @@\n-      set_req(MemNode::Control, NULL);\n+      set_req(MemNode::Control, nullptr);\n@@ -1750,1 +1750,1 @@\n-  if (can_reshape && (addr_t != NULL)) {\n+  if (can_reshape && (addr_t != nullptr)) {\n@@ -1755,1 +1755,1 @@\n-      if (phase->type( opt_mem ) == Type::TOP) return NULL;\n+      if (phase->type( opt_mem ) == Type::TOP) return nullptr;\n@@ -1759,1 +1759,1 @@\n-    if ((t_oop != NULL) &&\n+    if ((t_oop != nullptr) &&\n@@ -1763,1 +1763,1 @@\n-      assert(igvn != NULL, \"must be PhaseIterGVN when can_reshape is true\");\n+      assert(igvn != nullptr, \"must be PhaseIterGVN when can_reshape is true\");\n@@ -1767,1 +1767,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1771,1 +1771,1 @@\n-      if (result != NULL) return result;\n+      if (result != nullptr) return result;\n@@ -1775,1 +1775,1 @@\n-        if (result != NULL) return result;\n+        if (result != nullptr) return result;\n@@ -1783,1 +1783,1 @@\n-  if (in(0) != NULL && !adr_type()->isa_rawptr() && can_reshape) {\n+  if (in(0) != nullptr && !adr_type()->isa_rawptr() && can_reshape) {\n@@ -1788,1 +1788,1 @@\n-          use->in(0) != NULL &&\n+          use->in(0) != nullptr &&\n@@ -1792,1 +1792,1 @@\n-        for (int i = 0; i < 10 && ctl != NULL; i++) {\n+        for (int i = 0; i < 10 && ctl != nullptr; i++) {\n@@ -1816,1 +1816,1 @@\n-  if (prev_mem != NULL) {\n+  if (prev_mem != nullptr) {\n@@ -1818,1 +1818,1 @@\n-    if (value != NULL) {\n+    if (value != nullptr) {\n@@ -1823,1 +1823,1 @@\n-  if (prev_mem != NULL && prev_mem != in(MemNode::Memory)) {\n+  if (prev_mem != nullptr && prev_mem != in(MemNode::Memory)) {\n@@ -1835,1 +1835,1 @@\n-  if (alloc != NULL && alloc->Opcode() == Op_Allocate && UseBiasedLocking) {\n+  if (alloc != nullptr && alloc->Opcode() == Op_Allocate && UseBiasedLocking) {\n@@ -1841,1 +1841,1 @@\n-  return progress ? this : NULL;\n+  return progress ? this : nullptr;\n@@ -1868,1 +1868,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1879,1 +1879,1 @@\n-  if (tp == NULL || tp->empty())  return Type::TOP;\n+  if (tp == nullptr || tp->empty())  return Type::TOP;\n@@ -1902,1 +1902,1 @@\n-      if (aobj != NULL && off_beyond_header && adr->is_AddP() && off != Type::OffsetBot) {\n+      if (aobj != nullptr && off_beyond_header && adr->is_AddP() && off != Type::OffsetBot) {\n@@ -1907,1 +1907,1 @@\n-        if (con_type != NULL) {\n+        if (con_type != nullptr) {\n@@ -1928,2 +1928,2 @@\n-    if ((t->isa_int() == NULL) && (t->isa_long() == NULL)\n-        && (_type->isa_vect() == NULL)\n+    if ((t->isa_int() == nullptr) && (t->isa_long() == nullptr)\n+        && (_type->isa_vect() == nullptr)\n@@ -1944,1 +1944,1 @@\n-          if ((base != NULL) && base->is_DecodeN()) {\n+          if ((base != nullptr) && base->is_DecodeN()) {\n@@ -1948,1 +1948,1 @@\n-          if ((base != NULL) && base->is_Con()) {\n+          if ((base != nullptr) && base->is_Con()) {\n@@ -1950,1 +1950,1 @@\n-            if ((base_type != NULL) && base_type->is_autobox_cache()) {\n+            if ((base_type != nullptr) && base_type->is_autobox_cache()) {\n@@ -1972,1 +1972,1 @@\n-    if (!is_mismatched_access() && off != Type::OffsetBot && const_oop != NULL && const_oop->is_instance()) {\n+    if (!is_mismatched_access() && off != Type::OffsetBot && const_oop != nullptr && const_oop->is_instance()) {\n@@ -1974,1 +1974,1 @@\n-      if (con_type != NULL) {\n+      if (con_type != nullptr) {\n@@ -1996,1 +1996,1 @@\n-    if (tkls != NULL && !StressReflectiveCode) {\n+    if (tkls != nullptr && !StressReflectiveCode) {\n@@ -2007,1 +2007,1 @@\n-  if (tkls != NULL && !StressReflectiveCode) {\n+  if (tkls != nullptr && !StressReflectiveCode) {\n@@ -2030,1 +2030,1 @@\n-      if (aift != NULL)  return aift;\n+      if (aift != nullptr)  return aift;\n@@ -2079,2 +2079,2 @@\n-  bool is_instance = (tinst != NULL) && tinst->is_known_instance_field();\n-  bool is_boxed_value = (tinst != NULL) && tinst->is_ptr_to_boxed_value();\n+  bool is_instance = (tinst != nullptr) && tinst->is_known_instance_field();\n+  bool is_boxed_value = (tinst != nullptr) && tinst->is_ptr_to_boxed_value();\n@@ -2083,1 +2083,1 @@\n-    if (value != NULL && value->is_Con()) {\n+    if (value != nullptr && value->is_Con()) {\n@@ -2089,1 +2089,1 @@\n-  bool is_vect = (_type->isa_vect() != NULL);\n+  bool is_vect = (_type->isa_vect() != nullptr);\n@@ -2103,1 +2103,1 @@\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n+  if (alloc != nullptr && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n@@ -2126,1 +2126,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2139,1 +2139,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2160,1 +2160,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2173,1 +2173,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2194,1 +2194,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2207,1 +2207,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2228,1 +2228,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2241,1 +2241,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2258,1 +2258,1 @@\n-  assert(adr_type != NULL, \"expecting TypeKlassPtr\");\n+  assert(adr_type != nullptr, \"expecting TypeKlassPtr\");\n@@ -2294,1 +2294,1 @@\n-  if (tinst != NULL) {\n+  if (tinst != nullptr) {\n@@ -2304,1 +2304,1 @@\n-      if (t != NULL) {\n+      if (t != nullptr) {\n@@ -2315,1 +2315,1 @@\n-          \/\/ a primitive Class (e.g., int.class) has NULL for a klass field\n+          \/\/ a primitive Class (e.g., int.class) has null for a klass field\n@@ -2348,1 +2348,1 @@\n-  if( tary != NULL ) {\n+  if( tary != nullptr ) {\n@@ -2350,1 +2350,1 @@\n-    if (tary_klass != NULL   \/\/ can be NULL when at BOTTOM or TOP\n+    if (tary_klass != nullptr   \/\/ can be nullptr when at BOTTOM or TOP\n@@ -2383,1 +2383,1 @@\n-  if (tkls != NULL && !StressReflectiveCode) {\n+  if (tkls != nullptr && !StressReflectiveCode) {\n@@ -2427,1 +2427,1 @@\n-  if (base == NULL)     return this;\n+  if (base == nullptr)     return this;\n@@ -2429,1 +2429,1 @@\n-  if (toop == NULL)     return this;\n+  if (toop == nullptr)     return this;\n@@ -2441,1 +2441,1 @@\n-    if (allocated_klass != NULL) {\n+    if (allocated_klass != nullptr) {\n@@ -2462,1 +2462,1 @@\n-        if (tkls != NULL && !tkls->empty()\n+        if (tkls != nullptr && !tkls->empty()\n@@ -2522,1 +2522,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -2529,1 +2529,1 @@\n-  if (base == NULL)     return NULL;\n+  if (base == nullptr)     return nullptr;\n@@ -2531,1 +2531,1 @@\n-  if (tary == NULL)     return NULL;\n+  if (tary == nullptr)     return nullptr;\n@@ -2537,1 +2537,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -2547,1 +2547,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2561,1 +2561,1 @@\n-  if (base == NULL)     return this;\n+  if (base == nullptr)     return this;\n@@ -2563,1 +2563,1 @@\n-  if (tary == NULL)     return this;\n+  if (tary == nullptr)     return this;\n@@ -2569,1 +2569,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -2591,1 +2591,1 @@\n-         ctl != NULL, \"raw memory operations should have control edge\");\n+         ctl != nullptr, \"raw memory operations should have control edge\");\n@@ -2621,1 +2621,1 @@\n-    return (StoreNode*)NULL;\n+    return (StoreNode*)nullptr;\n@@ -2645,1 +2645,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -2703,1 +2703,1 @@\n-      if (moved != NULL) {\n+      if (moved != nullptr) {\n@@ -2724,1 +2724,1 @@\n-  return NULL;                  \/\/ No further progress\n+  return nullptr;                  \/\/ No further progress\n@@ -2781,1 +2781,1 @@\n-      if (prev_mem != NULL) {\n+      if (prev_mem != nullptr) {\n@@ -2783,1 +2783,1 @@\n-        if (prev_val != NULL && prev_val == val) {\n+        if (prev_val != nullptr && prev_val == val) {\n@@ -2793,1 +2793,1 @@\n-  if (result != this && igvn != NULL) {\n+  if (result != this && igvn != nullptr) {\n@@ -2795,1 +2795,1 @@\n-    if (trailing != NULL) {\n+    if (trailing != nullptr) {\n@@ -2798,1 +2798,1 @@\n-      assert(t_oop == NULL || t_oop->is_known_instance_field(), \"only for non escaping objects\");\n+      assert(t_oop == nullptr || t_oop->is_known_instance_field(), \"only for non escaping objects\");\n@@ -2834,1 +2834,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2858,1 +2858,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2869,1 +2869,1 @@\n-  if (adr_oop == NULL)\n+  if (adr_oop == nullptr)\n@@ -2884,1 +2884,1 @@\n-    MemBarNode* trailing_mb = NULL;\n+    MemBarNode* trailing_mb = nullptr;\n@@ -2890,1 +2890,1 @@\n-          assert(trailing_mb == NULL, \"only one\");\n+          assert(trailing_mb == nullptr, \"only one\");\n@@ -2905,1 +2905,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2916,1 +2916,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2919,1 +2919,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2931,1 +2931,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2934,1 +2934,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2958,1 +2958,1 @@\n-  if (progress != NULL) return progress;\n+  if (progress != nullptr) return progress;\n@@ -2967,1 +2967,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2986,1 +2986,1 @@\n-  if (in(0) == NULL || phase->type(in(0)) == Type::TOP) {\n+  if (in(0) == nullptr || phase->type(in(0)) == Type::TOP) {\n@@ -3042,1 +3042,1 @@\n-  MemBarNode* trailing = NULL;\n+  MemBarNode* trailing = nullptr;\n@@ -3048,1 +3048,1 @@\n-        assert(trailing == NULL, \"only one\");\n+        assert(trailing == nullptr, \"only one\");\n@@ -3069,1 +3069,1 @@\n-LoadStoreConditionalNode::LoadStoreConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex ) : LoadStoreNode(c, mem, adr, val, NULL, TypeInt::BOOL, 5) {\n+LoadStoreConditionalNode::LoadStoreConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex ) : LoadStoreNode(c, mem, adr, val, nullptr, TypeInt::BOOL, 5) {\n@@ -3086,1 +3086,1 @@\n-  if (adr == NULL)  return NULL; \/\/ node is dead\n+  if (adr == nullptr)  return nullptr; \/\/ node is dead\n@@ -3106,1 +3106,1 @@\n-  if (_is_large) return NULL;\n+  if (_is_large) return nullptr;\n@@ -3110,2 +3110,2 @@\n-  if (!t)  return NULL;\n-  if (!t->is_con())  return NULL;\n+  if (!t)  return nullptr;\n+  if (!t->is_con())  return nullptr;\n@@ -3118,1 +3118,1 @@\n-  if (size <= 0 || size % unit != 0)  return NULL;\n+  if (size <= 0 || size % unit != 0)  return nullptr;\n@@ -3125,1 +3125,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3127,1 +3127,1 @@\n-  if (!IdealizeClearArrayNode) return NULL;\n+  if (!IdealizeClearArrayNode) return nullptr;\n@@ -3129,1 +3129,1 @@\n-  if( phase->type(mem)==Type::TOP ) return NULL;\n+  if( phase->type(mem)==Type::TOP ) return nullptr;\n@@ -3132,1 +3132,1 @@\n-  if( at==Type::TOP ) return NULL;\n+  if( at==Type::TOP ) return nullptr;\n@@ -3135,1 +3135,1 @@\n-  if (atp == NULL)  atp = TypePtr::BOTTOM;\n+  if (atp == nullptr)  atp = TypePtr::BOTTOM;\n@@ -3165,1 +3165,1 @@\n-  assert(alloc != NULL, \"should have allocation\");\n+  assert(alloc != nullptr, \"should have allocation\");\n@@ -3172,1 +3172,1 @@\n-  if (init != NULL)\n+  if (init != nullptr)\n@@ -3261,1 +3261,1 @@\n-  : MultiNode(TypeFunc::Parms + (precedent == NULL? 0: 1)),\n+  : MultiNode(TypeFunc::Parms + (precedent == nullptr? 0: 1)),\n@@ -3272,1 +3272,1 @@\n-  if (precedent != NULL)\n+  if (precedent != nullptr)\n@@ -3297,1 +3297,1 @@\n-  default: ShouldNotReachHere(); return NULL;\n+  default: ShouldNotReachHere(); return nullptr;\n@@ -3308,1 +3308,1 @@\n-    if (leading != NULL) {\n+    if (leading != nullptr) {\n@@ -3313,1 +3313,1 @@\n-  if (proj_out_or_null(TypeFunc::Memory) != NULL) {\n+  if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n@@ -3316,1 +3316,1 @@\n-  if (proj_out_or_null(TypeFunc::Control) != NULL) {\n+  if (proj_out_or_null(TypeFunc::Control) != nullptr) {\n@@ -3328,1 +3328,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3340,1 +3340,1 @@\n-      if ((my_mem != NULL) && (opc == Op_MemBarAcquire) && (my_mem->outcnt() == 1)) {\n+      if ((my_mem != nullptr) && (opc == Op_MemBarAcquire) && (my_mem->outcnt() == 1)) {\n@@ -3352,1 +3352,1 @@\n-          my_mem = NULL;\n+          my_mem = nullptr;\n@@ -3356,1 +3356,1 @@\n-      if (my_mem != NULL && my_mem->is_Mem()) {\n+      if (my_mem != nullptr && my_mem->is_Mem()) {\n@@ -3359,1 +3359,1 @@\n-        if( t_oop != NULL && t_oop->is_known_instance_field() &&\n+        if( t_oop != nullptr && t_oop->is_known_instance_field() &&\n@@ -3368,1 +3368,1 @@\n-      if ((alloc != NULL) && alloc->is_Allocate() &&\n+      if ((alloc != nullptr) && alloc->is_Allocate() &&\n@@ -3383,1 +3383,1 @@\n-  return progress ? this : NULL;\n+  return progress ? this : nullptr;\n@@ -3403,1 +3403,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3433,1 +3433,1 @@\n-      trailing = NULL;\n+      trailing = nullptr;\n@@ -3448,1 +3448,1 @@\n-      if (trailing != NULL && !seen.test_set(trailing->_idx)) {\n+      if (trailing != nullptr && !seen.test_set(trailing->_idx)) {\n@@ -3474,4 +3474,4 @@\n-  while (leading != NULL && (!leading->is_MemBar() || !leading->as_MemBar()->leading())) {\n-    while (leading == NULL || leading->is_top() || seen.test_set(leading->_idx)) {\n-      leading = NULL;\n-      while (regions.size() > 0 && leading == NULL) {\n+  while (leading != nullptr && (!leading->is_MemBar() || !leading->as_MemBar()->leading())) {\n+    while (leading == nullptr || leading->is_top() || seen.test_set(leading->_idx)) {\n+      leading = nullptr;\n+      while (regions.size() > 0 && leading == nullptr) {\n@@ -3487,1 +3487,1 @@\n-      if (leading == NULL) {\n+      if (leading == nullptr) {\n@@ -3489,1 +3489,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -3508,1 +3508,1 @@\n-        if (in != NULL && !in->is_top()) {\n+        if (in != nullptr && !in->is_top()) {\n@@ -3518,1 +3518,1 @@\n-        if (in != NULL && !in->is_top()) {\n+        if (in != nullptr && !in->is_top()) {\n@@ -3524,1 +3524,1 @@\n-  assert(found == 1 || (found == 0 && leading == NULL), \"consistency check failed\");\n+  assert(found == 1 || (found == 0 && leading == nullptr), \"consistency check failed\");\n@@ -3526,2 +3526,2 @@\n-  if (leading == NULL) {\n-    return NULL;\n+  if (leading == nullptr) {\n+    return nullptr;\n@@ -3542,1 +3542,1 @@\n-    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n+    if (n != nullptr && OptoReg::is_valid(ra->get_reg_first(n))) {\n@@ -3657,1 +3657,1 @@\n-  \/\/ Note:  allocation() can be NULL, for secondary initialization barriers\n+  \/\/ Note:  allocation() can be null, for secondary initialization barriers\n@@ -3703,1 +3703,1 @@\n-  if (init == NULL || init->is_complete())  return false;\n+  if (init == nullptr || init->is_complete())  return false;\n@@ -3733,1 +3733,1 @@\n-  if (base == NULL)     return -1;  \/\/ something is dead,\n+  if (base == nullptr)  return -1;  \/\/ something is dead,\n@@ -3756,1 +3756,1 @@\n-    if (n == NULL)      continue;   \/\/ (can this really happen?)\n+    if (n == nullptr)   continue;   \/\/ (can this really happen?)\n@@ -3769,1 +3769,1 @@\n-    if (ctl != NULL && !ctl->is_top()) {\n+    if (ctl != nullptr && !ctl->is_top()) {\n@@ -3785,1 +3785,1 @@\n-      if (m == NULL || m == n || m->is_top())  continue;\n+      if (m == nullptr || m == n || m->is_top())  continue;\n@@ -3804,1 +3804,1 @@\n-  if (!(ctl != NULL && ctl->is_Proj() && ctl->in(0) == this))\n+  if (!(ctl != nullptr && ctl->is_Proj() && ctl->in(0) == this))\n@@ -3812,1 +3812,1 @@\n-  if (alloc == NULL)\n+  if (alloc == nullptr)\n@@ -3840,1 +3840,1 @@\n-    Node* unique_merge = NULL;\n+    Node* unique_merge = nullptr;\n@@ -3850,1 +3850,1 @@\n-        } else if (n->in(0) != NULL && n->in(0) != ctl) {\n+        } else if (n->in(0) != nullptr && n->in(0) != ctl) {\n@@ -3872,1 +3872,1 @@\n-            if (other_t_adr != NULL) {\n+            if (other_t_adr != nullptr) {\n@@ -3883,1 +3883,1 @@\n-                if (base != NULL) {\n+                if (base != nullptr) {\n@@ -3928,1 +3928,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -3980,1 +3980,1 @@\n-    return NULL;                \/\/ something is dead\n+    return nullptr;              \/\/ something is dead\n@@ -4024,1 +4024,1 @@\n-  if (start < 0)  return NULL;\n+  if (start < 0)  return nullptr;\n@@ -4030,2 +4030,2 @@\n-  if (i == 0)  return NULL;     \/\/ bail out\n-  Node* prev_mem = NULL;        \/\/ raw memory for the captured store\n+  if (i == 0)  return nullptr;  \/\/ bail out\n+  Node* prev_mem = nullptr;     \/\/ raw memory for the captured store\n@@ -4063,1 +4063,1 @@\n-  assert(check_st == new_st || check_st == NULL, \"must be findable\");\n+  assert(check_st == new_st || check_st == nullptr, \"must be findable\");\n@@ -4191,1 +4191,1 @@\n-        if (con != 0 && st != NULL && st->Opcode() == Op_StoreI) {\n+        if (con != 0 && st != nullptr && st->Opcode() == Op_StoreI) {\n@@ -4200,1 +4200,1 @@\n-          nodes[j] = NULL;      \/\/ undo nodes[j] = st\n+          nodes[j] = nullptr;   \/\/ undo nodes[j] = st\n@@ -4237,1 +4237,1 @@\n-    assert(old != NULL, \"need the prior store\");\n+    assert(old != nullptr, \"need the prior store\");\n@@ -4314,1 +4314,1 @@\n-  if (C->log() != NULL)\n+  if (C->log() != nullptr)\n@@ -4385,1 +4385,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -4488,1 +4488,1 @@\n-    const Type* val = NULL;\n+    const Type* val = nullptr;\n@@ -4514,2 +4514,2 @@\n-      assert(alloc != NULL, \"must be present\");\n-      if (alloc != NULL && alloc->Opcode() == Op_Allocate) {\n+      assert(alloc != nullptr, \"must be present\");\n+      if (alloc != nullptr && alloc->Opcode() == Op_Allocate) {\n@@ -4537,1 +4537,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -4613,1 +4613,1 @@\n-\/\/ MergeMem nodes never (?) have control inputs, so in(0) is NULL.\n+\/\/ MergeMem nodes never (?) have control inputs, so in(0) is null.\n@@ -4666,1 +4666,1 @@\n-  \/\/ set_input(0, NULL);  \/\/ no control input\n+  \/\/ set_input(0, nullptr);  \/\/ no control input\n@@ -4675,1 +4675,1 @@\n-  if( new_base != NULL && new_base->is_MergeMem() ) {\n+  if( new_base != nullptr && new_base->is_MergeMem() ) {\n@@ -4725,1 +4725,1 @@\n-  Node *progress = NULL;\n+  Node *progress = nullptr;\n@@ -4731,1 +4731,1 @@\n-    return NULL; \/\/ Dead memory path.\n+    return nullptr; \/\/ Dead memory path.\n@@ -4734,1 +4734,1 @@\n-  if (old_base != NULL && old_base->is_MergeMem())\n+  if (old_base != nullptr && old_base->is_MergeMem())\n@@ -4737,1 +4737,1 @@\n-    old_mbase = NULL;\n+    old_mbase = nullptr;\n@@ -4748,1 +4748,1 @@\n-  if (new_base != NULL && new_base->is_Phi())\n+  if (new_base != nullptr && new_base->is_Phi())\n@@ -4751,1 +4751,1 @@\n-    phi_base = NULL;\n+    phi_base = nullptr;\n@@ -4753,1 +4753,1 @@\n-  Node*    phi_reg = NULL;\n+  Node*    phi_reg = nullptr;\n@@ -4755,1 +4755,1 @@\n-  if (phi_base != NULL) {\n+  if (phi_base != nullptr) {\n@@ -4760,1 +4760,1 @@\n-      if (phi_base->in(i) == NULL) {\n+      if (phi_base->in(i) == nullptr) {\n@@ -4762,1 +4762,1 @@\n-        phi_reg = NULL;\n+        phi_reg = nullptr;\n@@ -4788,1 +4788,1 @@\n-    if (old_mem != NULL && old_mem->is_MergeMem())\n+    if (old_mem != nullptr && old_mem->is_MergeMem())\n@@ -4791,1 +4791,1 @@\n-      old_mmem = NULL;\n+      old_mmem = nullptr;\n@@ -4806,1 +4806,1 @@\n-    else if (old_mmem != NULL) {\n+    else if (old_mmem != nullptr) {\n@@ -4841,1 +4841,1 @@\n-    if( m != NULL &&\n+    if( m != nullptr &&\n@@ -4903,1 +4903,1 @@\n-    Node* mem = (in(i) != NULL) ? memory_at(i) : base_mem;\n+    Node* mem = (in(i) != nullptr) ? memory_at(i) : base_mem;\n@@ -4927,1 +4927,1 @@\n-  assert(n != NULL, \"\");\n+  assert(n != nullptr, \"\");\n@@ -4937,1 +4937,1 @@\n-    assert(n_adr_type != NULL, \"new memory must have a well-defined adr_type\");\n+    assert(n_adr_type != nullptr, \"new memory must have a well-defined adr_type\");\n@@ -4974,2 +4974,2 @@\n-           || n == NULL || n->bottom_type() == Type::TOP\n-           || n->adr_type() == NULL \/\/ address is TOP\n+           || n == nullptr || n->bottom_type() == Type::TOP\n+           || n->adr_type() == nullptr \/\/ address is TOP\n@@ -5017,1 +5017,1 @@\n-  if (other != NULL) {\n+  if (other != nullptr) {\n@@ -5028,1 +5028,1 @@\n-  if (base_mem != NULL && !base_mem->is_top()) {\n+  if (base_mem != nullptr && !base_mem->is_top()) {\n@@ -5058,1 +5058,1 @@\n-    assert(in(i) != NULL, \"sane slice\");\n+    assert(in(i) != nullptr, \"sane slice\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":333,"deletions":333,"binary":false,"changes":666,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/ Load or Store, possibly throwing a NULL pointer exception\n+\/\/ Load or Store, possibly throwing a null pointer exception\n@@ -95,1 +95,1 @@\n-  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return NULL; }\n+  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return nullptr; }\n@@ -114,1 +114,1 @@\n-  Node *Ideal_common(PhaseGVN *phase, bool can_reshape);  \/\/ Return -1 for short-circuit NULL.\n+  Node *Ideal_common(PhaseGVN *phase, bool can_reshape);  \/\/ Return -1 for short-circuit null.\n@@ -117,1 +117,1 @@\n-  static const TypePtr* calculate_adr_type(const Type* t, const TypePtr* cross_check = NULL);\n+  static const TypePtr* calculate_adr_type(const Type* t, const TypePtr* cross_check = nullptr);\n@@ -265,1 +265,1 @@\n-    assert(t != NULL, \"sanity\");\n+    assert(t != nullptr, \"sanity\");\n@@ -271,1 +271,1 @@\n-  const Type* type() const { assert(_type != NULL, \"sanity\"); return _type; };\n+  const Type* type() const { assert(_type != nullptr, \"sanity\"); return _type; };\n@@ -825,1 +825,1 @@\n-    if (ctrl == NULL)  return NULL; \/\/ node is dead\n+    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n@@ -1218,1 +1218,1 @@\n-                          Node* precedent = NULL);\n+                          Node* precedent = nullptr);\n@@ -1425,1 +1425,1 @@\n-  \/\/ Return the captured copy, else NULL if there is some sort of problem.\n+  \/\/ Return the captured copy, else null if there is some sort of problem.\n@@ -1430,1 +1430,1 @@\n-  \/\/ if there is no such store.  Return NULL if there is a problem.\n+  \/\/ if there is no such store.  Return null if there is a problem.\n@@ -1494,1 +1494,1 @@\n-  void iteration_setup(const MergeMemNode* other = NULL);\n+  void iteration_setup(const MergeMemNode* other = nullptr);\n@@ -1514,1 +1514,1 @@\n-  void init(MergeMemNode* mm, const MergeMemNode* mm2 = NULL) {\n+  void init(MergeMemNode* mm, const MergeMemNode* mm2 = nullptr) {\n@@ -1528,1 +1528,1 @@\n-    assert(mm2==NULL || mm2->verify_sparse(), \"please, no dups of base\");\n+    assert(mm2==nullptr || mm2->verify_sparse(), \"please, no dups of base\");\n@@ -1535,2 +1535,2 @@\n-    _mem = NULL;\n-    _mem2 = NULL;\n+    _mem = nullptr;\n+    _mem2 = nullptr;\n@@ -1594,1 +1594,1 @@\n-    assert(_mm2 != NULL, \"\");\n+    assert(_mm2 != nullptr, \"\");\n@@ -1665,1 +1665,1 @@\n-    assert((_mm2 != NULL) == have_mm2, \"use other next\");\n+    assert((_mm2 != nullptr) == have_mm2, \"use other next\");\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-  if (in(0) != NULL && remove_dead_region(phase, can_reshape)) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n@@ -82,2 +82,2 @@\n-  if (in(0) != NULL && in(0)->is_top()) {\n-    return NULL;\n+  if (in(0) != nullptr && in(0)->is_top()) {\n+    return nullptr;\n@@ -91,1 +91,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -98,1 +98,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -111,1 +111,1 @@\n-       return NULL;\n+       return nullptr;\n@@ -120,1 +120,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -183,1 +183,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -217,1 +217,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -220,1 +220,1 @@\n-  if( !in(1)->is_Bool() ) return NULL;\n+  if( !in(1)->is_Bool() ) return nullptr;\n@@ -225,1 +225,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -228,1 +228,1 @@\n-  if( !bol->in(1)->is_Cmp() ) return NULL;\n+  if( !bol->in(1)->is_Cmp() ) return nullptr;\n@@ -234,1 +234,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -236,1 +236,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -261,1 +261,1 @@\n-  if( !in(1)->is_Bool() ) return NULL;\n+  if( !in(1)->is_Bool() ) return nullptr;\n@@ -269,1 +269,1 @@\n-    default:           return NULL;                           break;\n+    default:           return nullptr;                        break;\n@@ -274,2 +274,2 @@\n-  if( cmpf->Opcode() != Op_CmpF ) return NULL;\n-  Node *X = NULL;\n+  if( cmpf->Opcode() != Op_CmpF ) return nullptr;\n+  Node *X = nullptr;\n@@ -284,1 +284,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -288,1 +288,1 @@\n-  if( X != in(phi_x_idx) ) return NULL;\n+  if( X != in(phi_x_idx) ) return nullptr;\n@@ -295,1 +295,1 @@\n-     phase->type(sub->in(1)) != TypeF::ZERO ) return NULL;\n+     phase->type(sub->in(1)) != TypeF::ZERO ) return nullptr;\n@@ -317,1 +317,1 @@\n-  if( !in(1)->is_Bool() ) return NULL;\n+  if( !in(1)->is_Bool() ) return nullptr;\n@@ -325,1 +325,1 @@\n-    default:           return NULL;                           break;\n+    default:           return nullptr;                        break;\n@@ -330,2 +330,2 @@\n-  if( cmpd->Opcode() != Op_CmpD ) return NULL;\n-  Node *X = NULL;\n+  if( cmpd->Opcode() != Op_CmpD ) return nullptr;\n+  Node *X = nullptr;\n@@ -340,1 +340,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -344,1 +344,1 @@\n-  if( X != in(phi_x_idx) ) return NULL;\n+  if( X != in(phi_x_idx) ) return nullptr;\n@@ -351,1 +351,1 @@\n-     phase->type(sub->in(1)) != TypeD::ZERO ) return NULL;\n+     phase->type(sub->in(1)) != TypeD::ZERO ) return nullptr;\n@@ -367,1 +367,1 @@\n-    if (ld != NULL && (ld->outcnt() == 1)) { \/\/ replace only\n+    if (ld != nullptr && (ld->outcnt() == 1)) { \/\/ replace only\n@@ -378,1 +378,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    \/\/ init_req(Control,NULL);\n+    \/\/ init_req(Control,nullptr);\n@@ -103,1 +103,1 @@\n-  MoveNode(Node* value) : Node(NULL, value) {\n+  MoveNode(Node* value) : Node(nullptr, value) {\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  Node* progress = NULL;        \/\/ Progress flag\n+  Node* progress = nullptr;        \/\/ Progress flag\n@@ -114,1 +114,1 @@\n-    if( t2 == Type::TOP ) return NULL;\n+    if( t2 == Type::TOP ) return nullptr;\n@@ -217,2 +217,2 @@\n-  if (con == 0) return NULL;   \/\/ By zero is handled by Value call\n-  if (con == 1) return NULL;   \/\/ By one  is handled by Identity call\n+  if (con == 0) return nullptr;   \/\/ By zero is handled by Value call\n+  if (con == 1) return nullptr;   \/\/ By one  is handled by Identity call\n@@ -229,1 +229,1 @@\n-  Node *res = NULL;\n+  Node *res = nullptr;\n@@ -312,2 +312,2 @@\n-  if (con == CONST64(0)) return NULL;  \/\/ By zero is handled by Value call\n-  if (con == CONST64(1)) return NULL;  \/\/ By one  is handled by Identity call\n+  if (con == CONST64(0)) return nullptr;  \/\/ By zero is handled by Value call\n+  if (con == CONST64(1)) return nullptr;  \/\/ By one  is handled by Identity call\n@@ -323,1 +323,1 @@\n-  Node *res = NULL;\n+  Node *res = nullptr;\n@@ -477,1 +477,1 @@\n-    if (t1 != NULL && t1->_lo >= 0) {\n+    if (t1 != nullptr && t1->_lo >= 0) {\n@@ -600,1 +600,1 @@\n-    if (t1 != NULL && t1->_lo >= 0) {\n+    if (t1 != nullptr && t1->_lo >= 0) {\n@@ -668,1 +668,1 @@\n-  if (tcount != NULL && tcount->is_con()) {\n+  if (tcount != nullptr && tcount->is_con()) {\n@@ -712,1 +712,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -758,1 +758,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -825,1 +825,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -868,1 +868,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -936,1 +936,1 @@\n-      if (t11 == NULL) {\n+      if (t11 == nullptr) {\n@@ -952,1 +952,1 @@\n-  if (!t1) return NULL;        \/\/ Left input is an integer\n+  if (!t1) return nullptr;        \/\/ Left input is an integer\n@@ -956,1 +956,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -974,1 +974,1 @@\n-  if( shl->Opcode() != Op_LShiftI ) return NULL;\n+  if( shl->Opcode() != Op_LShiftI ) return nullptr;\n@@ -1010,1 +1010,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1150,1 +1150,1 @@\n-        if (t_x != NULL && 0 <= t_x->_lo && t_x->_hi <= (max_jint>>LogBytesPerWord)) {\n+        if (t_x != nullptr && 0 <= t_x->_lo && t_x->_hi <= (max_jint>>LogBytesPerWord)) {\n@@ -1164,1 +1164,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1236,1 +1236,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1328,1 +1328,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1381,1 +1381,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1575,1 +1575,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -68,1 +68,1 @@\n-    if (proj != NULL && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n+    if (proj != nullptr && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n@@ -72,1 +72,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -79,1 +79,1 @@\n-  assert(p != NULL, \"named projection %u not found\", which_proj);\n+  assert(p != nullptr, \"named projection %u not found\", which_proj);\n@@ -116,1 +116,1 @@\n-  if (in(0) == NULL) return Type::TOP;\n+  if (in(0) == nullptr) return Type::TOP;\n@@ -124,1 +124,1 @@\n-    if (ctrl == NULL)  return NULL; \/\/ node is dead\n+    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n@@ -128,1 +128,1 @@\n-      assert(adr_type != NULL, \"source must have adr_type\");\n+      assert(adr_type != nullptr, \"source must have adr_type\");\n@@ -133,1 +133,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -145,1 +145,1 @@\n-    } else if (o == NULL) {\n+    } else if (o == nullptr) {\n@@ -158,1 +158,1 @@\n-  if (n == NULL)       return;  \/\/ should be assert, but NodeHash makes bogons\n+  if (n == nullptr)    return;  \/\/ should be assert, but NodeHash makes bogons\n@@ -169,1 +169,1 @@\n-  if (in(0) == NULL) return Type::TOP;\n+  if (in(0) == nullptr) return Type::TOP;\n@@ -186,1 +186,1 @@\n-\/\/ NULL otherwise\n+\/\/ nullptr otherwise\n@@ -192,2 +192,2 @@\n-    if (out == NULL)\n-      return NULL;\n+    if (out == nullptr)\n+      return nullptr;\n@@ -203,1 +203,1 @@\n-      return NULL; \/\/ don't do further after call\n+      return nullptr; \/\/ don't do further after call\n@@ -206,1 +206,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -208,1 +208,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -216,1 +216,1 @@\n-\/\/ NULL otherwise\n+\/\/ null otherwise\n@@ -220,1 +220,1 @@\n-  if (!in0->is_If()) return NULL;\n+  if (!in0->is_If()) return nullptr;\n@@ -222,1 +222,1 @@\n-  if (in0->outcnt() < 2)  return NULL;\n+  if (in0->outcnt() < 2)  return nullptr;\n@@ -229,1 +229,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -235,1 +235,1 @@\n-  if (call != NULL) {\n+  if (call != nullptr) {\n@@ -240,1 +240,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  \/\/ NULL otherwise\n+  \/\/ null otherwise\n@@ -101,1 +101,1 @@\n-  \/\/ NULL otherwise\n+  \/\/ null otherwise\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    init_req(0, NULL);\n+    init_req(0, nullptr);\n@@ -80,1 +80,1 @@\n-    init_req(0, NULL);\n+    init_req(0, nullptr);\n","filename":"src\/hotspot\/share\/opto\/narrowptrnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  _debug_orig = NULL;\n+  _debug_orig = nullptr;\n@@ -97,1 +97,1 @@\n-  _last_del = NULL;\n+  _last_del = nullptr;\n@@ -112,1 +112,1 @@\n-  _last     = NULL;\n+  _last     = nullptr;\n@@ -293,1 +293,1 @@\n-\/\/ The value NULL is reserved for the top node only.\n+\/\/ The value null is reserved for the top node only.\n@@ -315,1 +315,1 @@\n-  if (nn != NULL)  init_node_notes(C, idx, nn);\n+  if (nn != nullptr)  init_node_notes(C, idx, nn);\n@@ -341,1 +341,1 @@\n-    _in = NULL;\n+    _in = nullptr;\n@@ -345,1 +345,1 @@\n-      to[i] = NULL;\n+      to[i] = nullptr;\n@@ -361,1 +361,1 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n@@ -376,2 +376,2 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n@@ -393,3 +393,3 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n@@ -412,4 +412,4 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n-  _in[3] = n3; if (n3 != NULL) n3->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n+  _in[3] = n3; if (n3 != nullptr) n3->add_out((Node *)this);\n@@ -433,5 +433,5 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n-  _in[3] = n3; if (n3 != NULL) n3->add_out((Node *)this);\n-  _in[4] = n4; if (n4 != NULL) n4->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n+  _in[3] = n3; if (n3 != nullptr) n3->add_out((Node *)this);\n+  _in[4] = n4; if (n4 != nullptr) n4->add_out((Node *)this);\n@@ -457,6 +457,6 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n-  _in[3] = n3; if (n3 != NULL) n3->add_out((Node *)this);\n-  _in[4] = n4; if (n4 != NULL) n4->add_out((Node *)this);\n-  _in[5] = n5; if (n5 != NULL) n5->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n+  _in[3] = n3; if (n3 != nullptr) n3->add_out((Node *)this);\n+  _in[4] = n4; if (n4 != nullptr) n4->add_out((Node *)this);\n+  _in[5] = n5; if (n5 != nullptr) n5->add_out((Node *)this);\n@@ -483,7 +483,7 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n-  _in[3] = n3; if (n3 != NULL) n3->add_out((Node *)this);\n-  _in[4] = n4; if (n4 != NULL) n4->add_out((Node *)this);\n-  _in[5] = n5; if (n5 != NULL) n5->add_out((Node *)this);\n-  _in[6] = n6; if (n6 != NULL) n6->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n+  _in[3] = n3; if (n3 != nullptr) n3->add_out((Node *)this);\n+  _in[4] = n4; if (n4 != nullptr) n4->add_out((Node *)this);\n+  _in[5] = n5; if (n5 != nullptr) n5->add_out((Node *)this);\n+  _in[6] = n6; if (n6 != nullptr) n6->add_out((Node *)this);\n@@ -518,1 +518,1 @@\n-    if (x != NULL) x->add_out(n);\n+    if (x != nullptr) x->add_out(n);\n@@ -567,1 +567,1 @@\n-    if (cg != NULL) {\n+    if (cg != nullptr) {\n@@ -592,1 +592,1 @@\n-    _out = NULL;                           \/\/ marker value for top\n+    _out = nullptr;                           \/\/ marker value for top\n@@ -595,1 +595,1 @@\n-    if (_out == NULL)  _out = NO_OUT_ARRAY;\n+    if (_out == nullptr)  _out = NO_OUT_ARRAY;\n@@ -603,2 +603,2 @@\n-  Compile* compile = (phase != NULL) ? phase->C : Compile::current();\n-  if (phase != NULL && phase->is_IterGVN()) {\n+  Compile* compile = (phase != nullptr) ? phase->C : Compile::current();\n+  if (phase != nullptr && phase->is_IterGVN()) {\n@@ -616,1 +616,1 @@\n-  if (nn != NULL)  nn->clear();\n+  if (nn != nullptr)  nn->clear();\n@@ -621,1 +621,1 @@\n-    set_req(i, NULL);\n+    set_req(i, nullptr);\n@@ -629,1 +629,1 @@\n-  char *out_array = (char*)(_out == NO_OUT_ARRAY? NULL: _out);\n+  char *out_array = (char*)(_out == NO_OUT_ARRAY? nullptr: _out);\n@@ -688,4 +688,4 @@\n-    to[0] = NULL;\n-    to[1] = NULL;\n-    to[2] = NULL;\n-    to[3] = NULL;\n+    to[0] = nullptr;\n+    to[1] = nullptr;\n+    to[2] = nullptr;\n+    to[3] = nullptr;\n@@ -699,1 +699,1 @@\n-  Copy::zero_to_bytes(&_in[_max], (new_max-_max)*sizeof(Node*)); \/\/ NULL all new space\n+  Copy::zero_to_bytes(&_in[_max], (new_max-_max)*sizeof(Node*)); \/\/ null all new space\n@@ -721,1 +721,1 @@\n-  assert(_out != NULL && _out != NO_OUT_ARRAY, \"out must have sensible value\");\n+  assert(_out != nullptr && _out != NO_OUT_ARRAY, \"out must have sensible value\");\n@@ -723,1 +723,1 @@\n-  \/\/Copy::zero_to_bytes(&_out[_outmax], (new_max-_outmax)*sizeof(Node*)); \/\/ NULL all new space\n+  \/\/Copy::zero_to_bytes(&_out[_outmax], (new_max-_outmax)*sizeof(Node*)); \/\/ null all new space\n@@ -737,1 +737,1 @@\n-    if( _in[i] != NULL )\n+    if( _in[i] != nullptr )\n@@ -765,1 +765,1 @@\n-  return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL && in(0)->is_top());\n+  return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != nullptr && in(0)->is_top());\n@@ -774,1 +774,1 @@\n-  if( (_cnt >= _max) || (in(_max-1) != NULL) )\n+  if( (_cnt >= _max) || (in(_max-1) != nullptr) )\n@@ -778,1 +778,1 @@\n-  if( in(_cnt) != NULL ) {       \/\/ Next precedence edge is busy?\n+  if( in(_cnt) != nullptr ) {       \/\/ Next precedence edge is busy?\n@@ -781,1 +781,1 @@\n-      if( in(i) == NULL )       \/\/ Find the NULL at end of prec edge list\n+      if( in(i) == nullptr )       \/\/ Find the nullptr at end of prec edge list\n@@ -786,1 +786,1 @@\n-  if (n != NULL) n->add_out((Node *)this);\n+  if (n != nullptr) n->add_out((Node *)this);\n@@ -805,1 +805,1 @@\n-  if( _in[_cnt] != NULL ) {     \/\/ Next precedence edge is busy?\n+  if( _in[_cnt] != nullptr ) {  \/\/ Next precedence edge is busy?\n@@ -808,1 +808,1 @@\n-      if( _in[i] == NULL )      \/\/ Find the NULL at end of prec edge list\n+      if( _in[i] == nullptr )   \/\/ Find the null at end of prec edge list\n@@ -820,1 +820,1 @@\n-  if (n != NULL && !n->is_top()) {\n+  if (n != nullptr && !n->is_top()) {\n@@ -835,1 +835,1 @@\n-  if (n != NULL) n->del_out((Node *)this);\n+  if (n != nullptr) n->del_out((Node *)this);\n@@ -850,1 +850,1 @@\n-  if (n != NULL) n->del_out((Node *)this);\n+  if (n != nullptr) n->del_out((Node *)this);\n@@ -863,1 +863,1 @@\n-  add_req(NULL);                \/\/ Make space\n+  add_req(nullptr);                \/\/ Make space\n@@ -870,1 +870,1 @@\n-  if (n != NULL) n->add_out((Node *)this); \/\/ Add reciprocal def-use edge\n+  if (n != nullptr) n->add_out((Node *)this); \/\/ Add reciprocal def-use edge\n@@ -888,1 +888,1 @@\n-        if (gvn != NULL) {\n+        if (gvn != nullptr) {\n@@ -894,1 +894,1 @@\n-        assert(gvn == NULL || gvn->is_IterGVN() == NULL, \"no support for igvn here\");\n+        assert(gvn == nullptr || gvn->is_IterGVN() == nullptr, \"no support for igvn here\");\n@@ -920,1 +920,1 @@\n-\/\/ NULL out all inputs to eliminate incoming Def-Use edges.\n+\/\/ null out all inputs to eliminate incoming Def-Use edges.\n@@ -939,1 +939,1 @@\n-    rm_prec(--i);  \/\/ no-op if _in[i] is nullptr\n+    rm_prec(--i);  \/\/ no-op if _in[i] is null\n@@ -976,1 +976,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -981,1 +981,1 @@\n-  return (find_out_with(opcode) != NULL);\n+  return (find_out_with(opcode) != nullptr);\n@@ -1012,1 +1012,1 @@\n-    if (p == NULL || p->req() != 2) {\n+    if (p == nullptr || p->req() != 2) {\n@@ -1028,1 +1028,1 @@\n-\/\/ duplicates removed and NULLs packed down at the end.\n+\/\/ duplicates removed and nullptrs packed down at the end.\n@@ -1032,1 +1032,1 @@\n-  \/\/ Check for NULL at end\n+  \/\/ Check for nullptr at end\n@@ -1038,1 +1038,1 @@\n-  while( in(i) != NULL ) {\n+  while( in(i) != nullptr ) {\n@@ -1042,2 +1042,2 @@\n-  _in[i] = n;                                \/\/ Stuff prec edge over NULL\n-  if ( n != NULL) n->add_out((Node *)this);  \/\/ Add mirror edge\n+  _in[i] = n;                                \/\/ Stuff prec edge over nullptr\n+  if ( n != nullptr) n->add_out((Node *)this);  \/\/ Add mirror edge\n@@ -1046,1 +1046,1 @@\n-  while ((++i)<_max) { assert(_in[i] == NULL, \"spec violation: Gap in prec edges (node %d)\", _idx); }\n+  while ((++i)<_max) { assert(_in[i] == nullptr, \"spec violation: Gap in prec edges (node %d)\", _idx); }\n@@ -1052,1 +1052,1 @@\n-\/\/ duplicates removed and NULLs packed down at the end.\n+\/\/ duplicates removed and nullptrs packed down at the end.\n@@ -1056,1 +1056,1 @@\n-  if (_in[j] == NULL) return;   \/\/ Avoid spec violation: Gap in prec edges.\n+  if (_in[j] == nullptr) return;   \/\/ Avoid spec violation: Gap in prec edges.\n@@ -1068,1 +1068,1 @@\n-JVMState* Node::jvms() const { return NULL; }\n+JVMState* Node::jvms() const { return nullptr; }\n@@ -1073,1 +1073,1 @@\n-  for (JVMState* jvms = this->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = this->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -1153,1 +1153,1 @@\n-\/\/ return the 'this' pointer instead of NULL.\n+\/\/ return the 'this' pointer instead of null.\n@@ -1157,1 +1157,1 @@\n-\/\/ another Node have the Ideal call make no change and return NULL.\n+\/\/ another Node have the Ideal call make no change and return null.\n@@ -1159,1 +1159,1 @@\n-\/\/ returns NULL instead of doing any graph reshaping.\n+\/\/ returns null instead of doing any graph reshaping.\n@@ -1194,1 +1194,1 @@\n-  return NULL;                  \/\/ Default to being Ideal already\n+  return nullptr;                  \/\/ Default to being Ideal already\n@@ -1227,1 +1227,1 @@\n-  if (ctrl == NULL && this->is_Region())\n+  if (ctrl == nullptr && this->is_Region())\n@@ -1230,1 +1230,1 @@\n-  if (ctrl != NULL && ctrl->is_CatchProj()) {\n+  if (ctrl != nullptr && ctrl->is_CatchProj()) {\n@@ -1233,1 +1233,1 @@\n-    if (ctrl != NULL && !ctrl->is_top())\n+    if (ctrl != nullptr && !ctrl->is_top())\n@@ -1237,1 +1237,1 @@\n-  if (ctrl != NULL && ctrl->is_Proj())\n+  if (ctrl != nullptr && ctrl->is_Proj())\n@@ -1251,1 +1251,1 @@\n-  assert(sub != NULL && sub->is_CFG(), \"expecting control\");\n+  assert(sub != nullptr && sub->is_CFG(), \"expecting control\");\n@@ -1268,1 +1268,1 @@\n-  while (sub != NULL) {\n+  while (sub != nullptr) {\n@@ -1335,1 +1335,1 @@\n-        if (in != NULL && !in->is_top() && in != sub) {\n+        if (in != nullptr && !in->is_top() && in != sub) {\n@@ -1411,1 +1411,1 @@\n-            } else if (in != NULL && !in->is_top()) {\n+            } else if (in != nullptr && !in->is_top()) {\n@@ -1435,1 +1435,1 @@\n-        if (n != NULL && !n->is_top()) { \/\/ Input is valid?\n+        if (n != nullptr && !n->is_top()) { \/\/ Input is valid?\n@@ -1484,1 +1484,1 @@\n-    sum = (sum<<1)-(uintptr_t)in(i);        \/\/ Ignore embedded NULLs\n+    sum = (sum<<1)-(uintptr_t)in(i);        \/\/ Ignore embedded nulls\n@@ -1521,1 +1521,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1531,1 +1531,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1556,1 +1556,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1566,1 +1566,1 @@\n-  if (tp == NULL) {\n+  if (tp == nullptr) {\n@@ -1568,1 +1568,1 @@\n-    assert((tp != NULL), \"unexpected node type\");\n+    assert((tp != nullptr), \"unexpected node type\");\n@@ -1618,2 +1618,2 @@\n-\/\/ the search also includes forward (out) edges. Returns NULL if not found.\n-\/\/ If only_ctrl is set, the search will only be done on control nodes. Returns NULL if\n+\/\/ the search also includes forward (out) edges. Returns null if not found.\n+\/\/ If only_ctrl is set, the search will only be done on control nodes. Returns null if\n@@ -1628,1 +1628,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -1635,1 +1635,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -1658,1 +1658,1 @@\n-    while (orig != NULL && add_to_worklist(orig, &worklist, old_arena, &old_space, &new_space)) {\n+    while (orig != nullptr && add_to_worklist(orig, &worklist, old_arena, &old_space, &new_space)) {\n@@ -1668,1 +1668,1 @@\n-    return false; \/\/ Gracefully handle NULL, -1, 0xabababab, etc.\n+    return false; \/\/ Gracefully handle nullptr, -1, 0xabababab, etc.\n@@ -1686,1 +1686,1 @@\n-    if (n->in(i) != NULL)  return false;\n+    if (n->in(i) != nullptr)  return false;\n@@ -1695,3 +1695,3 @@\n-  if (not_a_node(orig)) orig = NULL;\n-  if (orig != NULL && !C->node_arena()->contains(orig)) orig = NULL;\n-  if (orig == NULL) return;\n+  if (not_a_node(orig)) orig = nullptr;\n+  if (orig != nullptr && !C->node_arena()->contains(orig)) orig = nullptr;\n+  if (orig == nullptr) return;\n@@ -1702,2 +1702,2 @@\n-  if (not_a_node(fast)) fast = NULL;\n-  while (orig != NULL) {\n+  if (not_a_node(fast)) fast = nullptr;\n+  while (orig != nullptr) {\n@@ -1711,4 +1711,4 @@\n-    if (not_a_node(orig)) orig = NULL;\n-    if (orig != NULL && !C->node_arena()->contains(orig)) orig = NULL;\n-    if (orig != NULL) st->print(\",\");\n-    if (fast != NULL) {\n+    if (not_a_node(orig)) orig = nullptr;\n+    if (orig != nullptr && !C->node_arena()->contains(orig)) orig = nullptr;\n+    if (orig != nullptr) st->print(\",\");\n+    if (fast != nullptr) {\n@@ -1717,2 +1717,2 @@\n-      if (not_a_node(fast)) fast = NULL;\n-      if (fast != NULL && fast != orig) {\n+      if (not_a_node(fast)) fast = nullptr;\n+      if (fast != nullptr && fast != orig) {\n@@ -1720,1 +1720,1 @@\n-        if (not_a_node(fast)) fast = NULL;\n+        if (not_a_node(fast)) fast = nullptr;\n@@ -1733,1 +1733,1 @@\n-  if (not_a_node(orig))  orig = NULL;\n+  if (not_a_node(orig))  orig = nullptr;\n@@ -1735,1 +1735,1 @@\n-  while (orig != NULL) {\n+  while (orig != nullptr) {\n@@ -1742,1 +1742,1 @@\n-    if (not_a_node(orig))  orig = NULL;\n+    if (not_a_node(orig))  orig = nullptr;\n@@ -1791,1 +1791,1 @@\n-  if (t != NULL && (t->isa_instptr() || t->isa_klassptr())) {\n+  if (t != nullptr && (t->isa_instptr() || t->isa_klassptr())) {\n@@ -1794,1 +1794,1 @@\n-    ciKlass*           klass = toop ? toop->klass() : (tkls ? tkls->klass() : NULL );\n+    ciKlass*           klass = toop ? toop->klass() : (tkls ? tkls->klass() : nullptr );\n@@ -1820,2 +1820,2 @@\n-    if (nn != NULL && !nn->is_clear()) {\n-      if (nn->jvms() != NULL) {\n+    if (nn != nullptr && !nn->is_clear()) {\n+      if (nn->jvms() != nullptr) {\n@@ -1836,1 +1836,1 @@\n-    if (d == NULL) {\n+    if (d == nullptr) {\n@@ -1853,1 +1853,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -1868,1 +1868,1 @@\n-    if (u == NULL) {\n+    if (u == nullptr) {\n@@ -2188,1 +2188,1 @@\n-    if (n != NULL && !n->is_top()) {\n+    if (n != nullptr && !n->is_top()) {\n@@ -2201,1 +2201,1 @@\n-    } else if (n == NULL) {\n+    } else if (n == nullptr) {\n@@ -2213,1 +2213,1 @@\n-    if( n != NULL )\n+    if( n != nullptr )\n@@ -2231,1 +2231,1 @@\n-      if (C->cached_top_node() == NULL) {\n+      if (C->cached_top_node() == nullptr) {\n@@ -2327,1 +2327,1 @@\n-  _nodes[_max - 1] = NULL;\n+  _nodes[_max - 1] = nullptr;\n@@ -2334,1 +2334,1 @@\n-    if (nn != NULL) {\n+    if (nn != nullptr) {\n@@ -2349,1 +2349,1 @@\n-      if (n != NULL && n->is_Phi()) {\n+      if (n != nullptr && n->is_Phi()) {\n@@ -2363,1 +2363,1 @@\n-\/\/ be found; Otherwise return NULL;\n+\/\/ be found; Otherwise return null;\n@@ -2386,1 +2386,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2393,1 +2393,1 @@\n-  Node* found = NULL;\n+  Node* found = nullptr;\n@@ -2397,2 +2397,2 @@\n-      if (found != NULL) {\n-        return NULL;\n+      if (found != nullptr) {\n+        return nullptr;\n@@ -2407,1 +2407,1 @@\n-  if (in(0) == NULL) {\n+  if (in(0) == nullptr) {\n@@ -2418,1 +2418,1 @@\n-  if (is_Proj() && in(0) == NULL)  {\n+  if (is_Proj() && in(0) == nullptr)  {\n@@ -2471,1 +2471,1 @@\n-      tty->print(\" NULL\");\n+      tty->print(\" null\");\n@@ -2497,1 +2497,1 @@\n-    assert( n != NULL, \"Did not expect null entries in worklist\");\n+    assert( n != nullptr, \"Did not expect null entries in worklist\");\n@@ -2525,1 +2525,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":146,"deletions":146,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-  \/\/ E.g.  new (C,3) FooNode( C, NULL, left, right );\n+  \/\/ E.g.  new (C,3) FooNode( C, nullptr, left, right );\n@@ -273,1 +273,1 @@\n-  Node* clone_with_data_edge(Node* in1, Node* in2 = NULL) const {\n+  Node* clone_with_data_edge(Node* in1, Node* in2 = nullptr) const {\n@@ -275,2 +275,2 @@\n-    if (in1 != NULL)  nn->set_req(1, in1);\n-    if (in2 != NULL)  nn->set_req(2, in2);\n+    if (in1 != nullptr)  nn->set_req(1, in1);\n+    if (in2 != nullptr)  nn->set_req(2, in2);\n@@ -295,1 +295,1 @@\n-  \/\/ for semantic correctness; order is important and NULLs are allowed.\n+  \/\/ for semantic correctness; order is important and nulls are allowed.\n@@ -298,1 +298,1 @@\n-  \/\/ duplicated; they have no embedded NULLs.  Edges from 0 to _cnt-1\n+  \/\/ duplicated; they have no embedded nulls.  Edges from 0 to _cnt-1\n@@ -393,2 +393,2 @@\n-  \/\/ Reference to the i'th input Node.  NULL if out of bounds.\n-  Node* lookup(uint i) const { return ((i < _max) ? _in[i] : NULL); }\n+  \/\/ Reference to the i'th input Node.  null if out of bounds.\n+  Node* lookup(uint i) const { return ((i < _max) ? _in[i] : nullptr); }\n@@ -415,1 +415,1 @@\n-#define is_not_dead(n) ((n) == NULL || !VerifyIterativeGVN || !((n)->is_dead()))\n+#define is_not_dead(n) ((n) == nullptr || !VerifyIterativeGVN || !((n)->is_dead()))\n@@ -437,1 +437,1 @@\n-    if (*p != NULL)  (*p)->del_out((Node *)this);\n+    if (*p != nullptr)  (*p)->del_out((Node *)this);\n@@ -439,1 +439,1 @@\n-    if (n != NULL)      n->add_out((Node *)this);\n+    if (n != nullptr)      n->add_out((Node *)this);\n@@ -449,1 +449,1 @@\n-    assert( _in[i] == NULL, \"sanity\");\n+    assert( _in[i] == nullptr, \"sanity\");\n@@ -451,1 +451,1 @@\n-    if (n != NULL)      n->add_out((Node *)this);\n+    if (n != nullptr)      n->add_out((Node *)this);\n@@ -459,2 +459,2 @@\n-      if (_in[i] == NULL) {\n-        DEBUG_ONLY( while ((++i) < len()) assert(_in[i] == NULL, \"Gap in prec edges!\"); )\n+      if (_in[i] == nullptr) {\n+        DEBUG_ONLY( while ((++i) < len()) assert(_in[i] == nullptr, \"Gap in prec edges!\"); )\n@@ -466,1 +466,1 @@\n-  int replace_edge(Node* old, Node* neww, PhaseGVN* gvn = NULL);\n+  int replace_edge(Node* old, Node* neww, PhaseGVN* gvn = nullptr);\n@@ -468,1 +468,1 @@\n-  \/\/ NULL out all inputs to eliminate incoming Def-Use edges.\n+  \/\/ null out all inputs to eliminate incoming Def-Use edges.\n@@ -473,2 +473,2 @@\n-    assert((this == (Node*) Compile::current()->top()) == (_out == NULL), \"\");\n-    return (_out == NULL);\n+    assert((this == (Node*) Compile::current()->top()) == (_out == nullptr), \"\");\n+    return (_out == nullptr);\n@@ -522,1 +522,1 @@\n-    Node *last = NULL;\n+    Node *last = nullptr;\n@@ -525,1 +525,1 @@\n-      if (next == NULL) break;\n+      if (next == nullptr) break;\n@@ -528,2 +528,2 @@\n-    _in[gap] = last; \/\/ Move last slot to empty one.\n-    _in[i] = NULL;   \/\/ NULL out last slot.\n+    _in[gap] = last;  \/\/ Move last slot to empty one.\n+    _in[i] = nullptr; \/\/ null out last slot.\n@@ -556,1 +556,1 @@\n-    if (n == NULL || find_prec_edge(n) != -1) {\n+    if (n == nullptr || find_prec_edge(n) != -1) {\n@@ -560,1 +560,1 @@\n-    if (_in[i] != NULL) _in[i]->del_out((Node *)this);\n+    if (_in[i] != nullptr) _in[i]->del_out((Node *)this);\n@@ -584,1 +584,1 @@\n-  \/\/ NOTE: Required edges can contain embedded NULL pointers.\n+  \/\/ NOTE: Required edges can contain embedded null pointers.\n@@ -827,1 +827,1 @@\n-    assert(is_##type(), \"invalid node class: %s\", Name()); \\\n+    assert(is_##type(), \"invalid node class: %s\", Name());   \\\n@@ -831,1 +831,1 @@\n-    return (is_##type()) ? as_##type() : NULL;               \\\n+    return (is_##type()) ? as_##type() : nullptr;            \\\n@@ -984,1 +984,1 @@\n-  bool is_expensive() const { return (_flags & Flag_is_expensive) != 0 && in(0) != NULL; }\n+  bool is_expensive() const { return (_flags & Flag_is_expensive) != 0 && in(0) != nullptr; }\n@@ -1009,1 +1009,1 @@\n-  \/\/ or NULL if none.  The address type is conservatively wide.\n+  \/\/ or null if none.  The address type is conservatively wide.\n@@ -1012,1 +1012,1 @@\n-  virtual const class TypePtr *adr_type() const { return NULL; }\n+  virtual const class TypePtr *adr_type() const { return nullptr; }\n@@ -1070,1 +1070,1 @@\n-  \/\/ be found; Otherwise return NULL;\n+  \/\/ be found; Otherwise return null;\n@@ -1100,1 +1100,1 @@\n-  \/\/ Return JVM State Object if this Node carries debug info, or NULL otherwise\n+  \/\/ Return JVM State Object if this Node carries debug info, or null otherwise\n@@ -1116,1 +1116,1 @@\n-    return (t != NULL && t->is_con()) ? t->get_con() : value_if_unknown;\n+    return (t != nullptr && t->is_con()) ? t->get_con() : value_if_unknown;\n@@ -1121,1 +1121,1 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != nullptr, \"must be con\");\n@@ -1131,1 +1131,1 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != nullptr, \"must be con\");\n@@ -1136,1 +1136,1 @@\n-    return (t != NULL && t->is_con()) ? t->get_con() : value_if_unknown;\n+    return (t != nullptr && t->is_con()) ? t->get_con() : value_if_unknown;\n@@ -1142,1 +1142,1 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != nullptr, \"must be con\");\n@@ -1230,1 +1230,1 @@\n-        tty->print(\" NULL\");\n+        tty->print(\" nullptr\");\n@@ -1266,1 +1266,1 @@\n-  if (n == NULL)                   return true;\n+  if (n == nullptr)                return true;\n@@ -1526,1 +1526,1 @@\n-\/\/ Abstractly provides an infinite array of Node*'s, initialized to NULL.\n+\/\/ Abstractly provides an infinite array of Node*'s, initialized to null.\n@@ -1543,2 +1543,2 @@\n-  Node *operator[] ( uint i ) const \/\/ Lookup, or NULL for not mapped\n-  { return (i<_max) ? _nodes[i] : (Node*)NULL; }\n+  Node *operator[] ( uint i ) const \/\/ Lookup, or null for not mapped\n+  { return (i<_max) ? _nodes[i] : (Node*)nullptr; }\n@@ -1551,1 +1551,1 @@\n-  \/\/ Clear all entries in _nodes to NULL but keep storage\n+  \/\/ Clear all entries in _nodes to null but keep storage\n@@ -1729,1 +1729,1 @@\n-  Node_Notes(JVMState* jvms = NULL) {\n+  Node_Notes(JVMState* jvms = nullptr) {\n@@ -1738,1 +1738,1 @@\n-    return (_jvms == NULL);\n+    return (_jvms == nullptr);\n@@ -1743,1 +1743,1 @@\n-    _jvms = NULL;\n+    _jvms = nullptr;\n@@ -1762,2 +1762,2 @@\n-    if (source != NULL) {\n-      if (source->jvms() != NULL) {\n+    if (source != nullptr) {\n+      if (source->jvms() != nullptr) {\n@@ -1778,1 +1778,1 @@\n-  int grow_by = (block_idx - (arr == NULL? 0: arr->length()));\n+  int grow_by = (block_idx - (arr == nullptr? 0: arr->length()));\n@@ -1780,1 +1780,1 @@\n-    if (!can_grow) return NULL;\n+    if (!can_grow) return nullptr;\n@@ -1783,1 +1783,1 @@\n-  if (arr == NULL) return NULL;\n+  if (arr == nullptr) return nullptr;\n@@ -1790,1 +1790,1 @@\n-  if (value == NULL || value->is_clear())\n+  if (value == nullptr || value->is_clear())\n@@ -1793,1 +1793,1 @@\n-  assert(loc != NULL, \"\");\n+  assert(loc != nullptr, \"\");\n@@ -1808,1 +1808,1 @@\n-    assert(t != NULL, \"sanity\");\n+    assert(t != nullptr, \"sanity\");\n@@ -1814,1 +1814,1 @@\n-  const Type* type() const { assert(_type != NULL, \"sanity\"); return _type; };\n+  const Type* type() const { assert(_type != nullptr, \"sanity\"); return _type; };\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  Opaque1Node(Compile* C, Node *n) : Node(NULL, n) {\n+  Opaque1Node(Compile* C, Node *n) : Node(nullptr, n) {\n@@ -46,1 +46,1 @@\n-  Opaque1Node(Compile* C, Node *n, Node* orig_limit) : Node(NULL, n, orig_limit) {\n+  Opaque1Node(Compile* C, Node *n, Node* orig_limit) : Node(nullptr, n, orig_limit) {\n@@ -52,1 +52,1 @@\n-  Node* original_loop_limit() { return req()==3 ? in(2) : NULL; }\n+  Node* original_loop_limit() { return req()==3 ? in(2) : nullptr; }\n@@ -117,1 +117,1 @@\n-  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {\n+  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(nullptr, tst, final_tst) {\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n+    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == nullptr) {\n@@ -301,3 +301,3 @@\n-    _oop_map_set(NULL),\n-    _scratch_buffer_blob(NULL),\n-    _scratch_locs_memory(NULL),\n+    _oop_map_set(nullptr),\n+    _scratch_buffer_blob(nullptr),\n+    _scratch_locs_memory(nullptr),\n@@ -309,1 +309,1 @@\n-    _node_bundling_base(NULL),\n+    _node_bundling_base(nullptr),\n@@ -313,1 +313,1 @@\n-    _block(NULL),\n+    _block(nullptr),\n@@ -316,1 +316,1 @@\n-  if (C->stub_name() == NULL) {\n+  if (C->stub_name() == nullptr) {\n@@ -322,2 +322,2 @@\n-  C->set_output(NULL);\n-  if (_scratch_buffer_blob != NULL) {\n+  C->set_output(nullptr);\n+  if (_scratch_buffer_blob != nullptr) {\n@@ -422,1 +422,1 @@\n-  if (cb == NULL || C->failing()) {\n+  if (cb == nullptr || C->failing()) {\n@@ -443,1 +443,1 @@\n-  return (C->stub_function() == NULL &&\n+  return (C->stub_function() == nullptr &&\n@@ -453,1 +453,1 @@\n-  return (C->stub_function() == NULL && C->has_java_calls());\n+  return (C->stub_function() == nullptr && C->has_java_calls());\n@@ -659,2 +659,2 @@\n-      MachNode* mach = (idx == -1) ? NULL: block->get_node(idx)->as_Mach();\n-      if (mach != NULL && mach->may_be_short_branch()) {\n+      MachNode* mach = (idx == -1) ? nullptr: block->get_node(idx)->as_Mach();\n+      if (mach != nullptr && mach->may_be_short_branch()) {\n@@ -724,1 +724,1 @@\n-      if (mach != NULL && (mach->may_be_short_branch() ||\n+      if (mach != nullptr && (mach->may_be_short_branch() ||\n@@ -790,1 +790,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -795,1 +795,1 @@\n-  assert(sv_for_node_id(objs, sv->id()) == NULL, \"Precondition\");\n+  assert(sv_for_node_id(objs, sv->id()) == nullptr, \"Precondition\");\n@@ -824,1 +824,1 @@\n-    if (sv == NULL) {\n+    if (sv == nullptr) {\n@@ -912,1 +912,1 @@\n-      array->append(new ConstantOopWriteValue(NULL));\n+      array->append(new ConstantOopWriteValue(nullptr));\n@@ -920,1 +920,1 @@\n-        array->append(new ConstantOopWriteValue(NULL));\n+        array->append(new ConstantOopWriteValue(nullptr));\n@@ -1013,1 +1013,1 @@\n-    mcall = NULL;\n+    mcall = nullptr;\n@@ -1038,1 +1038,1 @@\n-  \/\/ Do not skip safepoints with a NULL method, they need monitor info\n+  \/\/ Do not skip safepoints with a null method, they need monitor info\n@@ -1051,1 +1051,1 @@\n-    ciMethod* method = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* method = jvms->has_method() ? jvms->method() : nullptr;\n@@ -1054,2 +1054,2 @@\n-    int num_locs = (method == NULL) ? 0 : jvms->loc_size();\n-    int num_exps = (method == NULL) ? 0 : jvms->stk_size();\n+    int num_locs = (method == nullptr) ? 0 : jvms->loc_size();\n+    int num_exps = (method == nullptr) ? 0 : jvms->stk_size();\n@@ -1057,1 +1057,1 @@\n-    assert(method == NULL || jvms->bci() < 0 || num_locs == method->max_locals(),\n+    assert(method == nullptr || jvms->bci() < 0 || num_locs == method->max_locals(),\n@@ -1092,1 +1092,1 @@\n-      ScopeValue *scval = NULL;\n+      ScopeValue *scval = nullptr;\n@@ -1097,1 +1097,1 @@\n-        if (scval == NULL) {\n+        if (scval == nullptr) {\n@@ -1183,1 +1183,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1191,2 +1191,2 @@\n-      if (nn == NULL || nn->jvms() == NULL)  return;\n-      if (_pending_jvms != NULL &&\n+      if (nn == nullptr || nn->jvms() == nullptr)  return;\n+      if (_pending_jvms != nullptr &&\n@@ -1197,1 +1197,1 @@\n-        if (_pending_jvms != NULL &&\n+        if (_pending_jvms != nullptr &&\n@@ -1201,1 +1201,1 @@\n-        _pending_jvms = NULL;\n+        _pending_jvms = nullptr;\n@@ -1203,1 +1203,1 @@\n-          \/\/ This is the only way _pending_jvms can become non-NULL:\n+          \/\/ This is the only way _pending_jvms can become non-null:\n@@ -1212,1 +1212,1 @@\n-      if (_pending_jvms != NULL &&\n+      if (_pending_jvms != nullptr &&\n@@ -1217,1 +1217,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1221,1 +1221,1 @@\n-      if (_pending_jvms != NULL) {\n+      if (_pending_jvms != nullptr) {\n@@ -1224,1 +1224,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1233,1 +1233,1 @@\n-  _pending_jvms = NULL;\n+  _pending_jvms = nullptr;\n@@ -1244,1 +1244,1 @@\n-    ciMethod* method = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* method = jvms->has_method() ? jvms->method() : nullptr;\n@@ -1343,1 +1343,1 @@\n-  if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+  if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1345,1 +1345,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1400,1 +1400,1 @@\n-  int* node_offsets      = NULL;\n+  int* node_offsets      = nullptr;\n@@ -1406,1 +1406,1 @@\n-  if (node_offsets != NULL) {\n+  if (node_offsets != nullptr) {\n@@ -1429,1 +1429,1 @@\n-  Node* delay_slot = NULL;\n+  Node* delay_slot = nullptr;\n@@ -1470,1 +1470,1 @@\n-        assert(delay_slot == NULL, \"no use of delay slot node\");\n+        assert(delay_slot == nullptr, \"no use of delay slot node\");\n@@ -1520,1 +1520,1 @@\n-          if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+          if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1549,1 +1549,1 @@\n-            if (sfn->jvms()->method() == NULL) {\n+            if (sfn->jvms()->method() == nullptr) {\n@@ -1576,1 +1576,1 @@\n-            assert(delay_slot == NULL, \"not expecting delay slot node\");\n+            assert(delay_slot == nullptr, \"not expecting delay slot node\");\n@@ -1641,1 +1641,1 @@\n-            if (oop_store == NULL) continue;\n+            if (oop_store == nullptr) continue;\n@@ -1672,1 +1672,1 @@\n-      if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+      if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1679,1 +1679,1 @@\n-      if ((node_offsets != NULL) && (n->_idx < node_offset_limit)) {\n+      if ((node_offsets != nullptr) && (n->_idx < node_offset_limit)) {\n@@ -1735,1 +1735,1 @@\n-        guarantee(delay_slot != NULL, \"expecting delay slot node\");\n+        guarantee(delay_slot != nullptr, \"expecting delay slot node\");\n@@ -1742,1 +1742,1 @@\n-        if ((node_offsets != NULL) && (delay_slot->_idx < node_offset_limit)) {\n+        if ((node_offsets != nullptr) && (delay_slot->_idx < node_offset_limit)) {\n@@ -1751,1 +1751,1 @@\n-          if (!mach->is_MachCall() && mach->as_MachSafePoint()->jvms()->method() == NULL) {\n+          if (!mach->is_MachCall() && mach->as_MachSafePoint()->jvms()->method() == nullptr) {\n@@ -1753,1 +1753,1 @@\n-            delay_slot = NULL;\n+            delay_slot = nullptr;\n@@ -1768,1 +1768,1 @@\n-        delay_slot = NULL;\n+        delay_slot = nullptr;\n@@ -1856,1 +1856,1 @@\n-  if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+  if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1876,1 +1876,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -1880,1 +1880,1 @@\n-      if (C->method() != NULL) {\n+      if (C->method() != nullptr) {\n@@ -1883,1 +1883,1 @@\n-      } else if (C->stub_name() != NULL) {\n+      } else if (C->stub_name() != nullptr) {\n@@ -1890,1 +1890,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -1908,1 +1908,1 @@\n-    Node *n = NULL;\n+    Node *n = nullptr;\n@@ -1969,1 +1969,1 @@\n-      _handler_table.add_subtable(call_return, &handler_bcis, NULL, &handler_pcos);\n+      _handler_table.add_subtable(call_return, &handler_bcis, nullptr, &handler_pcos);\n@@ -2007,1 +2007,1 @@\n-          _next_node(NULL),\n+          _next_node(nullptr),\n@@ -2258,1 +2258,1 @@\n-      tty->print(\"#   ChooseNodeToBundle: NULL\\n\");\n+      tty->print(\"#   ChooseNodeToBundle: null\\n\");\n@@ -2260,1 +2260,1 @@\n-    return (NULL);\n+    return (nullptr);\n@@ -2609,1 +2609,1 @@\n-  _unconditional_delay_slot = NULL;\n+  _unconditional_delay_slot = nullptr;\n@@ -2671,1 +2671,1 @@\n-  Block *succ_bb = NULL;\n+  Block *succ_bb = nullptr;\n@@ -2773,1 +2773,1 @@\n-      guarantee(n != NULL, \"no nodes available\");\n+      guarantee(n != nullptr, \"no nodes available\");\n@@ -2848,1 +2848,1 @@\n-    _reg_node.map(def,NULL); \/\/ Kill live USEs\n+    _reg_node.map(def,nullptr); \/\/ Kill live USEs\n@@ -2925,1 +2925,1 @@\n-  if ((pinch == NULL) || _cfg->get_block_for_node(pinch) != b || \/\/ No pinch-point yet?\n+  if ((pinch == nullptr) || _cfg->get_block_for_node(pinch) != b || \/\/ No pinch-point yet?\n@@ -2935,1 +2935,1 @@\n-  Node *later_def = NULL;\n+  Node *later_def = nullptr;\n@@ -2957,1 +2957,1 @@\n-      pinch->init_req(0, C->top());     \/\/ set not NULL for the next call\n+      pinch->init_req(0, C->top());     \/\/ set not null for the next call\n@@ -2959,1 +2959,1 @@\n-      later_def = NULL;           \/\/ and no later def\n+      later_def = nullptr;           \/\/ and no later def\n@@ -2978,1 +2978,1 @@\n-        pinch->set_req(0,NULL);  \/\/\n+        pinch->set_req(0,nullptr);  \/\/\n@@ -2996,1 +2996,1 @@\n-  if ((pinch != NULL) && _cfg->get_block_for_node(pinch) == b &&\n+  if ((pinch != nullptr) && _cfg->get_block_for_node(pinch) == b &&\n@@ -3048,1 +3048,1 @@\n-  \/\/ compilation.  _reg_node is lazily initialized; it either contains a NULL,\n+  \/\/ compilation.  _reg_node is lazily initialized; it either contains a null,\n@@ -3050,1 +3050,1 @@\n-  \/\/ block.  Leftover node from some prior block is treated like a NULL (no\n+  \/\/ block.  Leftover node from some prior block is treated like a null (no\n@@ -3055,1 +3055,1 @@\n-  Node* end_node         = (_bb_end-1 >= _bb_start) ? b->get_node(last_safept) : NULL;\n+  Node* end_node         = (_bb_end-1 >= _bb_start) ? b->get_node(last_safept) : nullptr;\n@@ -3173,1 +3173,1 @@\n-    if ((pinch != NULL) && pinch->Opcode() == Op_Node &&\n+    if ((pinch != nullptr) && pinch->Opcode() == Op_Node &&\n@@ -3175,1 +3175,1 @@\n-        (pinch->req() == pinch->len() || pinch->in(pinch->req()) == NULL) ) {\n+        (pinch->req() == pinch->len() || pinch->in(pinch->req()) == nullptr) ) {\n@@ -3178,1 +3178,1 @@\n-      _reg_node.map(k, NULL);\n+      _reg_node.map(k, nullptr);\n@@ -3213,1 +3213,1 @@\n-  pinch->set_req(0, NULL);\n+  pinch->set_req(0, nullptr);\n@@ -3266,1 +3266,1 @@\n-  if ((blob != NULL) && (const_size <= _scratch_const_size)) {\n+  if ((blob != nullptr) && (const_size <= _scratch_const_size)) {\n@@ -3269,1 +3269,1 @@\n-    if (blob != NULL) {\n+    if (blob != nullptr) {\n@@ -3280,1 +3280,1 @@\n-    if (scratch_buffer_blob() == NULL) {\n+    if (scratch_buffer_blob() == nullptr) {\n@@ -3310,1 +3310,1 @@\n-  assert(blob != NULL, \"Initialize BufferBlob at start\");\n+  assert(blob != nullptr, \"Initialize BufferBlob at start\");\n@@ -3319,1 +3319,1 @@\n-  assert(locs_buf != NULL, \"sanity\");\n+  assert(locs_buf != nullptr, \"sanity\");\n@@ -3332,1 +3332,1 @@\n-  Label*   saveL = NULL;\n+  Label*   saveL = nullptr;\n@@ -3358,1 +3358,1 @@\n-  } else if (C->stub_function() != NULL) {\n+  } else if (C->stub_function() != nullptr) {\n@@ -3409,1 +3409,1 @@\n-    if (C->log() != NULL) { \/\/ Print code cache state into compiler log\n+    if (C->log() != nullptr) { \/\/ Print code cache state into compiler log\n@@ -3416,1 +3416,1 @@\n-  if (code_buffer() == NULL) {\n+  if (code_buffer() == nullptr) {\n@@ -3434,1 +3434,1 @@\n-      assert(rs != NULL && rs->is_runtime_stub(), \"sanity check\");\n+      assert(rs != nullptr && rs->is_runtime_stub(), \"sanity check\");\n@@ -3477,1 +3477,1 @@\n-  if (pcs != NULL) {\n+  if (pcs != nullptr) {\n@@ -3496,1 +3496,1 @@\n-  Node *n = NULL;\n+  Node *n = nullptr;\n@@ -3507,1 +3507,1 @@\n-    if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+    if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3522,1 +3522,1 @@\n-    Node *delay = NULL;\n+    Node *delay = nullptr;\n@@ -3554,1 +3554,1 @@\n-        if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+        if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3571,1 +3571,1 @@\n-        guarantee(delay != NULL, \"no unconditional delay instruction\");\n+        guarantee(delay != nullptr, \"no unconditional delay instruction\");\n@@ -3576,1 +3576,1 @@\n-        if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+        if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3587,1 +3587,1 @@\n-        delay = NULL;\n+        delay = nullptr;\n@@ -3598,1 +3598,1 @@\n-    assert(cut_short || delay == NULL, \"no unconditional delay branch\");\n+    assert(cut_short || delay == nullptr, \"no unconditional delay branch\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":103,"deletions":103,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  \/\/ If \"objs\" contains an ObjectValue whose id is \"id\", returns it, else NULL.\n+  \/\/ If \"objs\" contains an ObjectValue whose id is \"id\", returns it, else null.\n@@ -256,1 +256,1 @@\n-  void dump_asm(int* pcs = NULL, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }\n+  void dump_asm(int* pcs = nullptr, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }\n@@ -259,1 +259,1 @@\n-  void dump_asm(int* pcs = NULL, uint pc_limit = 0) { return; }\n+  void dump_asm(int* pcs = nullptr, uint pc_limit = 0) { return; }\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-    bool is_merged() const                 { return _start_map != NULL; }\n+    bool is_merged() const                 { return _start_map != nullptr; }\n@@ -190,1 +190,1 @@\n-      if (pred != NULL && is_SEL_backedge(pred)) {\n+      if (pred != nullptr && is_SEL_backedge(pred)) {\n@@ -257,1 +257,1 @@\n-    \/\/ Initialize me by recording the parser's map.  My own map must be NULL.\n+    \/\/ Initialize me by recording the parser's map.  My own map must be null.\n@@ -377,1 +377,1 @@\n-    assert((_alloc_with_final == NULL) || (_alloc_with_final == n), \"different init objects?\");\n+    assert((_alloc_with_final == nullptr) || (_alloc_with_final == n), \"different init objects?\");\n@@ -404,1 +404,1 @@\n-  \/\/ Can return NULL if the flow pass did not complete a block.\n+  \/\/ Can return null if the flow pass did not complete a block.\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    tty->print_cr(\"%d original NULL checks - %d elided (%2d%%); optimizer leaves %d,\",\n+    tty->print_cr(\"%d original null checks - %d elided (%2d%%); optimizer leaves %d,\",\n@@ -115,1 +115,1 @@\n-  Node *l = NULL;\n+  Node *l = nullptr;\n@@ -155,1 +155,1 @@\n-      (tp != NULL && !tp->klass()->is_loaded())) {\n+      (tp != nullptr && !tp->klass()->is_loaded())) {\n@@ -171,1 +171,1 @@\n-  if (tp != NULL && tp->klass() != C->env()->Object_klass()) {\n+  if (tp != nullptr && tp->klass() != C->env()->Object_klass()) {\n@@ -173,1 +173,1 @@\n-    Node* bad_type_ctrl = NULL;\n+    Node* bad_type_ctrl = nullptr;\n@@ -275,1 +275,1 @@\n-    if (type->isa_oopptr() != NULL) {\n+    if (type->isa_oopptr() != nullptr) {\n@@ -284,1 +284,1 @@\n-        if (C->log() != NULL) {\n+        if (C->log() != nullptr) {\n@@ -306,1 +306,1 @@\n-      \/\/ Ptr types are mixed together with T_ADDRESS but NULL is\n+      \/\/ Ptr types are mixed together with T_ADDRESS but null is\n@@ -341,1 +341,1 @@\n-    if (type->isa_oopptr() != NULL) {\n+    if (type->isa_oopptr() != nullptr) {\n@@ -403,1 +403,1 @@\n-  _alloc_with_final = NULL;\n+  _alloc_with_final = nullptr;\n@@ -405,2 +405,2 @@\n-  _tf = NULL;\n-  _block = NULL;\n+  _tf = nullptr;\n+  _block = nullptr;\n@@ -452,1 +452,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -477,1 +477,1 @@\n-      if (log != NULL)\n+      if (log != nullptr)\n@@ -486,1 +486,1 @@\n-  if (log != NULL && method()->has_exception_handlers()) {\n+  if (log != nullptr && method()->has_exception_handlers()) {\n@@ -490,1 +490,1 @@\n-  assert(InlineTree::check_can_parse(method()) == NULL, \"Can not parse this method, cutout earlier\");\n+  assert(InlineTree::check_can_parse(method()) == nullptr, \"Can not parse this method, cutout earlier\");\n@@ -557,1 +557,1 @@\n-  if (failing() || entry_map == NULL) {\n+  if (failing() || entry_map == nullptr) {\n@@ -815,1 +815,1 @@\n-\/\/ unknown caller.  The method & bci will be NULL & InvocationEntryBci.\n+\/\/ unknown caller.  The method & bci will be null & InvocationEntryBci.\n@@ -824,1 +824,1 @@\n-  if (old_nn != NULL && has_method()) {\n+  if (old_nn != nullptr && has_method()) {\n@@ -850,1 +850,1 @@\n-  if (caller_nn == NULL)  return NULL;\n+  if (caller_nn == nullptr)  return nullptr;\n@@ -912,1 +912,1 @@\n-    while (pop_exception_state() != NULL) ;\n+    while (pop_exception_state() != nullptr) ;\n@@ -919,1 +919,1 @@\n-  while ((ex_map = pop_exception_state()) != NULL) {\n+  while ((ex_map = pop_exception_state()) != nullptr) {\n@@ -1072,1 +1072,1 @@\n-    while ((ex_map = kit.pop_exception_state()) != NULL) {\n+    while ((ex_map = kit.pop_exception_state()) != nullptr) {\n@@ -1107,1 +1107,1 @@\n-    while ((ex_map = caller.pop_exception_state()) != NULL) {\n+    while ((ex_map = caller.pop_exception_state()) != nullptr) {\n@@ -1123,1 +1123,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1137,1 +1137,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1141,1 +1141,1 @@\n-  assert(method() != NULL, \"parser must have a method\");\n+  assert(method() != nullptr, \"parser must have a method\");\n@@ -1144,1 +1144,1 @@\n-  JVMState* jvms = new (C) JVMState(method(), _caller->has_method() ? _caller : NULL);\n+  JVMState* jvms = new (C) JVMState(method(), _caller->has_method() ? _caller : nullptr);\n@@ -1151,1 +1151,1 @@\n-  assert(inmap != NULL, \"must have inmap\");\n+  assert(inmap != nullptr, \"must have inmap\");\n@@ -1207,1 +1207,1 @@\n-    if (receiver_type != NULL && !receiver_type->higher_equal(holder_type)) {\n+    if (receiver_type != nullptr && !receiver_type->higher_equal(holder_type)) {\n@@ -1237,1 +1237,1 @@\n-    Node *lock_obj = NULL;\n+    Node *lock_obj = nullptr;\n@@ -1285,1 +1285,1 @@\n-  _start_map = NULL;\n+  _start_map = nullptr;\n@@ -1289,1 +1289,1 @@\n-  _successors = NULL;\n+  _successors = nullptr;\n@@ -1308,1 +1308,1 @@\n-  _successors = (ns+ne == 0) ? NULL : NEW_RESOURCE_ARRAY(Block*, ns+ne);\n+  _successors = (ns+ne == 0) ? nullptr : NEW_RESOURCE_ARRAY(Block*, ns+ne);\n@@ -1351,1 +1351,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1531,1 +1531,1 @@\n-    if (log != NULL) {\n+    if (log != nullptr) {\n@@ -1566,1 +1566,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -1581,1 +1581,1 @@\n-  if (nn == NULL)  return;\n+  if (nn == nullptr)  return;\n@@ -1590,1 +1590,1 @@\n-  if (jvms != NULL && jvms->bci() != bci) {\n+  if (jvms != nullptr && jvms->bci() != bci) {\n@@ -1602,1 +1602,1 @@\n-  if (target == NULL) { handle_missing_successor(target_bci); return; }\n+  if (target == nullptr) { handle_missing_successor(target_bci); return; }\n@@ -1612,1 +1612,1 @@\n-  if (target == NULL) { handle_missing_successor(target_bci); return; }\n+  if (target == nullptr) { handle_missing_successor(target_bci); return; }\n@@ -1629,1 +1629,1 @@\n-  if (target == NULL) { handle_missing_successor(target_bci); return; }\n+  if (target == nullptr) { handle_missing_successor(target_bci); return; }\n@@ -1690,2 +1690,2 @@\n-      \/\/ zap all inputs to NULL for debugging (done in Node(uint) constructor)\n-      \/\/ for (int j = 1; j < edges+1; j++) { r->init_req(j, NULL); }\n+      \/\/ zap all inputs to null for debugging (done in Node(uint) constructor)\n+      \/\/ for (int j = 1; j < edges+1; j++) { r->init_req(j, nullptr); }\n@@ -1750,1 +1750,1 @@\n-        phi = NULL;\n+        phi = nullptr;\n@@ -1758,1 +1758,1 @@\n-          assert(phi == NULL, \"the merge contains phis, not vice versa\");\n+          assert(phi == nullptr, \"the merge contains phis, not vice versa\");\n@@ -1762,1 +1762,1 @@\n-          if (phi == NULL) {\n+          if (phi == nullptr) {\n@@ -1784,1 +1784,1 @@\n-      if (phi != NULL) {\n+      if (phi != nullptr) {\n@@ -1830,1 +1830,1 @@\n-  assert(n != NULL, \"\");\n+  assert(n != nullptr, \"\");\n@@ -1837,2 +1837,2 @@\n-  PhiNode* base = NULL;\n-  MergeMemNode* remerge = NULL;\n+  PhiNode* base = nullptr;\n+  MergeMemNode* remerge = nullptr;\n@@ -1846,3 +1846,3 @@\n-      if (remerge == NULL) {\n-        guarantee(base != NULL, \"\");\n-        assert(base->in(0) != NULL, \"should not be xformed away\");\n+      if (remerge == nullptr) {\n+        guarantee(base != nullptr, \"\");\n+        assert(base->in(0) != nullptr, \"should not be xformed away\");\n@@ -1864,1 +1864,1 @@\n-        phi = NULL;\n+        phi = nullptr;\n@@ -1867,1 +1867,1 @@\n-    if (phi != NULL) {\n+    if (phi != nullptr) {\n@@ -1881,1 +1881,1 @@\n-  if (base != NULL && pnum == 1) {\n+  if (base != nullptr && pnum == 1) {\n@@ -1940,1 +1940,1 @@\n-  r->add_req(NULL);\n+  r->add_req(nullptr);\n@@ -1950,1 +1950,1 @@\n-          phi->add_req(NULL);\n+          phi->add_req(nullptr);\n@@ -1956,1 +1956,1 @@\n-        n->add_req(NULL);\n+        n->add_req(nullptr);\n@@ -1972,1 +1972,1 @@\n-  assert(o != NULL, \"\");\n+  assert(o != nullptr, \"\");\n@@ -1974,1 +1974,1 @@\n-  if (o == top())  return NULL; \/\/ TOP always merges into TOP\n+  if (o == top())  return nullptr; \/\/ TOP always merges into TOP\n@@ -1983,1 +1983,1 @@\n-  const Type* t = NULL;\n+  const Type* t = nullptr;\n@@ -2002,1 +2002,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2009,1 +2009,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2027,1 +2027,1 @@\n-  assert(o != NULL && o != top(), \"\");\n+  assert(o != nullptr && o != top(), \"\");\n@@ -2061,1 +2061,1 @@\n-  assert(receiver != NULL && receiver->bottom_type()->isa_instptr() != NULL,\n+  assert(receiver != nullptr && receiver->bottom_type()->isa_instptr() != nullptr,\n@@ -2065,1 +2065,1 @@\n-  if (tinst != NULL && tinst->klass()->is_loaded() && !tinst->klass_is_exact()) {\n+  if (tinst != nullptr && tinst->klass()->is_loaded() && !tinst->klass_is_exact()) {\n@@ -2079,1 +2079,1 @@\n-  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n+  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n@@ -2082,1 +2082,1 @@\n-  Node* access_flags = make_load(NULL, access_flags_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* access_flags = make_load(nullptr, access_flags_addr, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -2105,1 +2105,1 @@\n-                                   NULL, TypePtr::BOTTOM,\n+                                   nullptr, TypePtr::BOTTOM,\n@@ -2177,1 +2177,1 @@\n-  if (mc == NULL) {\n+  if (mc == nullptr) {\n@@ -2234,1 +2234,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2255,2 +2255,2 @@\n-      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->klass()->is_interface() &&\n-          val_tip != NULL && val_tip->is_loaded() && !val_tip->klass()->is_interface()) {\n+      if (phi_tip != nullptr && phi_tip->is_loaded() && phi_tip->klass()->is_interface() &&\n+          val_tip != nullptr && val_tip->is_loaded() && !val_tip->klass()->is_interface()) {\n@@ -2282,1 +2282,1 @@\n-  SafePointNode *sfpnt = new SafePointNode(parms, NULL);\n+  SafePointNode *sfpnt = new SafePointNode(parms, nullptr);\n@@ -2324,1 +2324,1 @@\n-    assert(C->root() != NULL, \"Expect parse is still valid\");\n+    assert(C->root() != nullptr, \"Expect parse is still valid\");\n@@ -2332,2 +2332,2 @@\n-  InlineTree* ilt = NULL;\n-  if (C->ilt() != NULL) {\n+  InlineTree* ilt = nullptr;\n+  if (C->ilt() != nullptr) {\n@@ -2398,1 +2398,1 @@\n-  if( method() != NULL ) {\n+  if( method() != nullptr ) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":80,"deletions":80,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    if (C->log() != NULL)   C->log()->elem(\"observe that='!need_range_check'\");\n+    if (C->log() != nullptr)   C->log()->elem(\"observe that='!need_range_check'\");\n@@ -147,1 +147,1 @@\n-  if ((arytype_klass != NULL) && (!arytype_klass->is_loaded())) {\n+  if ((arytype_klass != nullptr) && (!arytype_klass->is_loaded())) {\n@@ -192,1 +192,1 @@\n-                      NULL, \"range_check\");\n+                      nullptr, \"range_check\");\n@@ -236,1 +236,1 @@\n-                    NULL,\n+                    nullptr,\n@@ -258,1 +258,1 @@\n-                    NULL,\n+                    nullptr,\n@@ -277,1 +277,1 @@\n-                  NULL,\n+                  nullptr,\n@@ -426,1 +426,1 @@\n-  ciMultiBranchData* profile = NULL;\n+  ciMultiBranchData* profile = nullptr;\n@@ -429,1 +429,1 @@\n-    if (data != NULL && data->is_MultiBranchData()) {\n+    if (data != nullptr && data->is_MultiBranchData()) {\n@@ -442,1 +442,1 @@\n-    if (profile != NULL) {\n+    if (profile != nullptr) {\n@@ -452,1 +452,1 @@\n-    if (profile != NULL) {\n+    if (profile != nullptr) {\n@@ -463,1 +463,1 @@\n-    if (profile != NULL) {\n+    if (profile != nullptr) {\n@@ -500,1 +500,1 @@\n-  ciMultiBranchData* profile = NULL;\n+  ciMultiBranchData* profile = nullptr;\n@@ -503,1 +503,1 @@\n-    if (data != NULL && data->is_MultiBranchData()) {\n+    if (data != nullptr && data->is_MultiBranchData()) {\n@@ -516,1 +516,1 @@\n-      table[3*j+2] = (profile == NULL) ? 1 : MIN2<uint>(max_jint, profile->count_at(j));\n+      table[3*j+2] = (profile == nullptr) ? 1 : MIN2<uint>(max_jint, profile->count_at(j));\n@@ -534,1 +534,1 @@\n-  if (profile != NULL) {\n+  if (profile != nullptr) {\n@@ -618,1 +618,1 @@\n-    : _lo(lo), _hi(hi), _mid(NULL),\n+    : _lo(lo), _hi(hi), _mid(nullptr),\n@@ -623,1 +623,1 @@\n-    : _lo(NULL), _hi(NULL), _mid(NULL),\n+    : _lo(nullptr), _hi(nullptr), _mid(nullptr),\n@@ -637,1 +637,1 @@\n-      if (r._mid == NULL) {\n+      if (r._mid == nullptr) {\n@@ -646,1 +646,1 @@\n-        SwitchRange* mid = NULL;\n+        SwitchRange* mid = nullptr;\n@@ -695,1 +695,1 @@\n-  SwitchRange* ranges = NULL;\n+  SwitchRange* ranges = nullptr;\n@@ -891,1 +891,1 @@\n-  ciMultiBranchData* profile = NULL;\n+  ciMultiBranchData* profile = nullptr;\n@@ -894,1 +894,1 @@\n-    if (data != NULL && data->is_MultiBranchData()) {\n+    if (data != nullptr && data->is_MultiBranchData()) {\n@@ -899,1 +899,1 @@\n-  Node* jtn = _gvn.transform(new JumpNode(control(), key_val, num_cases, probs, profile == NULL ? COUNT_UNKNOWN : total));\n+  Node* jtn = _gvn.transform(new JumpNode(control(), key_val, num_cases, probs, profile == nullptr ? COUNT_UNKNOWN : total));\n@@ -953,1 +953,1 @@\n-    if (ti != NULL) {\n+    if (ti != nullptr) {\n@@ -990,1 +990,1 @@\n-    SwitchRange* mid = NULL;\n+    SwitchRange* mid = nullptr;\n@@ -1114,1 +1114,1 @@\n-                              \"frem\", NULL, \/\/no memory effects\n+                              \"frem\", nullptr, \/\/no memory effects\n@@ -1126,1 +1126,1 @@\n-                              \"drem\", NULL, \/\/no memory effects\n+                              \"drem\", nullptr, \/\/no memory effects\n@@ -1143,1 +1143,1 @@\n-                              \"l2f\", NULL, \/\/no memory effects\n+                              \"l2f\", nullptr, \/\/no memory effects\n@@ -1225,1 +1225,1 @@\n-    if (data == NULL) {\n+    if (data == nullptr) {\n@@ -1245,1 +1245,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -1275,2 +1275,2 @@\n-  if (C->log() != NULL) {\n-    const char* prob_str = NULL;\n+  if (C->log() != nullptr) {\n+    const char* prob_str = nullptr;\n@@ -1280,1 +1280,1 @@\n-    if (prob_str == NULL) {\n+    if (prob_str == nullptr) {\n@@ -1319,1 +1319,1 @@\n-        if (data == NULL ||\n+        if (data == nullptr ||\n@@ -1369,2 +1369,2 @@\n-  assert(argument(0) != NULL, \"must exist\");\n-  assert(bc_depth == 1 || argument(1) != NULL, \"two must exist\");\n+  assert(argument(0) != nullptr, \"must exist\");\n+  assert(bc_depth == 1 || argument(1) != nullptr, \"two must exist\");\n@@ -1392,1 +1392,1 @@\n-                  NULL, \"cold\");\n+                  nullptr, \"cold\");\n@@ -1463,1 +1463,1 @@\n-                  NULL, \"cold\");\n+                  nullptr, \"cold\");\n@@ -1493,1 +1493,1 @@\n-    \/\/ This wins when (Bool ne (Conv2B p) 0) => (Bool ne (CmpP p NULL)).\n+    \/\/ This wins when (Bool ne (Conv2B p) 0) => (Bool ne (CmpP p null)).\n@@ -1598,1 +1598,1 @@\n-                  NULL,\n+                  nullptr,\n@@ -1636,1 +1636,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1641,1 +1641,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1645,1 +1645,1 @@\n-  assert(ldk != NULL && ldk->is_Load(), \"should have found a LoadKlass or LoadNKlass node\");\n+  assert(ldk != nullptr && ldk->is_Load(), \"should have found a LoadKlass or LoadNKlass node\");\n@@ -1650,2 +1650,2 @@\n-  if (obj == NULL || off != oopDesc::klass_offset_in_bytes()) \/\/ loading oopDesc::_klass?\n-    return NULL;\n+  if (obj == nullptr || off != oopDesc::klass_offset_in_bytes()) \/\/ loading oopDesc::_klass?\n+    return nullptr;\n@@ -1653,2 +1653,2 @@\n-  if (tp == NULL || !(tp->isa_instptr() || tp->isa_aryptr())) \/\/ is obj a Java object ptr?\n-    return NULL;\n+  if (tp == nullptr || !(tp->isa_instptr() || tp->isa_aryptr())) \/\/ is obj a Java object ptr?\n+    return nullptr;\n@@ -1667,1 +1667,1 @@\n-    if (obj != NULL && (con_type->isa_instptr() || con_type->isa_aryptr())) {\n+    if (obj != nullptr && (con_type->isa_instptr() || con_type->isa_aryptr())) {\n@@ -1673,1 +1673,1 @@\n-       if (tboth != NULL && tboth->klass_is_exact() && tboth != obj_type &&\n+       if (tboth != nullptr && tboth->klass_is_exact() && tboth != obj_type &&\n@@ -1706,2 +1706,2 @@\n-  ConstraintCastNode* ccast = NULL;\n-  Node* cast = NULL;\n+  ConstraintCastNode* ccast = nullptr;\n+  Node* cast = nullptr;\n@@ -1744,1 +1744,1 @@\n-  if (ccast != NULL) {\n+  if (ccast != nullptr) {\n@@ -1755,1 +1755,1 @@\n-  if (cast != NULL) {                   \/\/ Here's the payoff.\n+  if (cast != nullptr) {                   \/\/ Here's the payoff.\n@@ -1775,2 +1775,2 @@\n-    Node* load_klass = NULL;\n-    Node* decode = NULL;\n+    Node* load_klass = nullptr;\n+    Node* decode = nullptr;\n@@ -1787,1 +1787,1 @@\n-      if (obj_type->speculative_type_not_null() != NULL) {\n+      if (obj_type->speculative_type_not_null() != nullptr) {\n@@ -1797,1 +1797,1 @@\n-        if (decode != NULL) {\n+        if (decode != nullptr) {\n@@ -1885,1 +1885,1 @@\n-      if (con_type != NULL) {\n+      if (con_type != nullptr) {\n@@ -1893,1 +1893,1 @@\n-                      NULL, \"constant in error state\", true \/* must_throw *\/);\n+                      nullptr, \"constant in error state\", true \/* must_throw *\/);\n@@ -1900,1 +1900,1 @@\n-                      NULL, \"unresolved constant\", false \/* must_throw *\/);\n+                      nullptr, \"unresolved constant\", false \/* must_throw *\/);\n@@ -2543,1 +2543,1 @@\n-    a = Compile::narrow_value(T_BYTE, a, NULL, &_gvn, true);\n+    a = Compile::narrow_value(T_BYTE, a, nullptr, &_gvn, true);\n@@ -2548,1 +2548,1 @@\n-    a = Compile::narrow_value(T_SHORT, a, NULL, &_gvn, true);\n+    a = Compile::narrow_value(T_SHORT, a, nullptr, &_gvn, true);\n@@ -2553,1 +2553,1 @@\n-    a = Compile::narrow_value(T_CHAR, a, NULL, &_gvn, true);\n+    a = Compile::narrow_value(T_CHAR, a, nullptr, &_gvn, true);\n@@ -2577,1 +2577,1 @@\n-    return_current(NULL);\n+    return_current(nullptr);\n@@ -2593,1 +2593,1 @@\n-    \/\/ null exception oop throws NULL pointer exception\n+    \/\/ null exception oop throws null pointer exception\n@@ -2627,1 +2627,1 @@\n-    assert(data != NULL && data->is_JumpData(), \"need JumpData for taken branch\");\n+    assert(data != nullptr && data->is_JumpData(), \"need JumpData for taken branch\");\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-                  NULL, \"put to call site target field\");\n+                  nullptr, \"put to call site target field\");\n@@ -121,1 +121,1 @@\n-    if (con != NULL) {\n+    if (con != nullptr) {\n@@ -159,1 +159,1 @@\n-      assert(type != NULL, \"field singleton type must be consistent\");\n+      assert(type != nullptr, \"field singleton type must be consistent\");\n@@ -189,1 +189,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -245,1 +245,1 @@\n-      if (AllocateNode::Ideal_allocation(obj, &_gvn) != NULL) {\n+      if (AllocateNode::Ideal_allocation(obj, &_gvn) != nullptr) {\n@@ -301,1 +301,1 @@\n-  assert(length != NULL, \"\");\n+  assert(length != nullptr, \"\");\n@@ -334,1 +334,1 @@\n-  length[ndimensions] = NULL;  \/\/ terminating null for make_runtime_call\n+  length[ndimensions] = nullptr;  \/\/ terminating null for make_runtime_call\n@@ -359,1 +359,1 @@\n-    Node* obj = NULL;\n+    Node* obj = nullptr;\n@@ -374,1 +374,1 @@\n-  address fun = NULL;\n+  address fun = nullptr;\n@@ -382,1 +382,1 @@\n-  Node* c = NULL;\n+  Node* c = nullptr;\n@@ -384,1 +384,1 @@\n-  if (fun != NULL) {\n+  if (fun != nullptr) {\n@@ -387,1 +387,1 @@\n-                          fun, NULL, TypeRawPtr::BOTTOM,\n+                          fun, nullptr, TypeRawPtr::BOTTOM,\n@@ -390,2 +390,2 @@\n-                          (ndimensions > 2) ? length[3] : NULL,\n-                          (ndimensions > 3) ? length[4] : NULL);\n+                          (ndimensions > 2) ? length[3] : nullptr,\n+                          (ndimensions > 3) ? length[4] : nullptr);\n@@ -394,1 +394,1 @@\n-    Node* dims = NULL;\n+    Node* dims = nullptr;\n@@ -409,1 +409,1 @@\n-                          OptoRuntime::multianewarrayN_Java(), NULL, TypeRawPtr::BOTTOM,\n+                          OptoRuntime::multianewarrayN_Java(), nullptr, TypeRawPtr::BOTTOM,\n@@ -424,1 +424,1 @@\n-  if (ltype != NULL)\n+  if (ltype != nullptr)\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-  \/\/ _from_ is not loaded, and value is not null.  If the value _is_ NULL,\n+  \/\/ _from_ is not loaded, and value is not null.  If the value _is_ nullptr,\n@@ -76,1 +76,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -115,1 +115,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -159,1 +159,1 @@\n-  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS));\n+  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS));\n@@ -213,1 +213,1 @@\n-      if (log != NULL) {\n+      if (log != nullptr) {\n@@ -229,1 +229,1 @@\n-  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : NULL,\n+  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : nullptr,\n@@ -286,2 +286,2 @@\n-  MergeMemNode *mem = map() == NULL ? NULL : (map()->memory()->is_MergeMem() ?\n-                                      map()->memory()->as_MergeMem() : NULL);\n+  MergeMemNode *mem = map() == nullptr ? nullptr : (map()->memory()->is_MergeMem() ?\n+                                      map()->memory()->as_MergeMem() : nullptr);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-Phase::Phase( PhaseNumber pnum ) : _pnum(pnum), C( pnum == Compiler ? NULL : Compile::current()) {\n+Phase::Phase( PhaseNumber pnum ) : _pnum(pnum), C( pnum == Compiler ? nullptr : Compile::current()) {\n","filename":"src\/hotspot\/share\/opto\/phase.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  _sentinel = new ProjNode(NULL, TypeFunc::Control);\n+  _sentinel = new ProjNode(nullptr, TypeFunc::Control);\n@@ -76,1 +76,1 @@\n-  _sentinel = new ProjNode(NULL, TypeFunc::Control);\n+  _sentinel = new ProjNode(nullptr, TypeFunc::Control);\n@@ -102,1 +102,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -110,1 +110,1 @@\n-    return NULL;                \/\/ Miss!\n+    return nullptr;             \/\/ Miss!\n@@ -132,1 +132,1 @@\n-      return NULL;              \/\/ Miss!\n+      return nullptr;           \/\/ Miss!\n@@ -136,1 +136,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -147,1 +147,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -159,1 +159,1 @@\n-    return NULL;                \/\/ Miss!\n+    return nullptr;             \/\/ Miss!\n@@ -188,1 +188,1 @@\n-      return NULL;              \/\/ Miss!\n+      return nullptr;           \/\/ Miss!\n@@ -196,1 +196,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -238,1 +238,1 @@\n-  for( ; \/* (k != NULL) && (k != _sentinel) *\/; ) {\n+  for( ; \/* (k != nullptr) && (k != _sentinel) *\/; ) {\n@@ -297,1 +297,1 @@\n-\/\/ Clear all entries in _table to NULL but keep storage\n+\/\/ Clear all entries in _table to null but keep storage\n@@ -322,1 +322,1 @@\n-    if(n != NULL && n != sentinel_node && !useful.test(n->_idx)) {\n+    if(n != nullptr && n != sentinel_node && !useful.test(n->_idx)) {\n@@ -338,1 +338,1 @@\n-    if (n != NULL &&\n+    if (n != nullptr &&\n@@ -382,1 +382,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -570,1 +570,1 @@\n-  if (type != NULL && type->isa_oopptr() && type->is_oopptr()->is_known_instance()) {\n+  if (type != nullptr && type->isa_oopptr() && type->is_oopptr()->is_known_instance()) {\n@@ -598,1 +598,1 @@\n-  _types.map(C->unique(), NULL);\n+  _types.map(C->unique(), nullptr);\n@@ -614,1 +614,1 @@\n-  _types.map(C->unique(), NULL);\n+  _types.map(C->unique(), nullptr);\n@@ -641,1 +641,1 @@\n-  if (n == NULL)  return NULL;\n+  if (n == nullptr)  return nullptr;\n@@ -646,1 +646,1 @@\n-  if (t == NULL)  return NULL;\n+  if (t == nullptr)  return nullptr;\n@@ -653,1 +653,1 @@\n-  if (n == NULL)  return NULL;\n+  if (n == nullptr)  return nullptr;\n@@ -656,1 +656,1 @@\n-  if (t == NULL)  return NULL;\n+  if (t == nullptr)  return nullptr;\n@@ -698,1 +698,1 @@\n-  if (type_or_null(n) != NULL) {\n+  if (type_or_null(n) != nullptr) {\n@@ -761,1 +761,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -764,1 +764,1 @@\n-    if (nna != NULL) {\n+    if (nna != nullptr) {\n@@ -781,1 +781,1 @@\n-    if (icon != NULL && icon->in(TypeFunc::Control) != NULL)\n+    if (icon != nullptr && icon->in(TypeFunc::Control) != nullptr)\n@@ -797,1 +797,1 @@\n-    if (lcon != NULL && lcon->in(TypeFunc::Control) != NULL)\n+    if (lcon != nullptr && lcon->in(TypeFunc::Control) != nullptr)\n@@ -822,1 +822,1 @@\n-  if (zcon != NULL && zcon->in(TypeFunc::Control) != NULL)\n+  if (zcon != nullptr && zcon->in(TypeFunc::Control) != nullptr)\n@@ -834,1 +834,1 @@\n-  if (i == NULL) {\n+  if (i == nullptr) {\n@@ -857,1 +857,1 @@\n-  while (i != NULL) {\n+  while (i != nullptr) {\n@@ -878,1 +878,1 @@\n-  assert(t != NULL, \"value sanity\");\n+  assert(t != nullptr, \"value sanity\");\n@@ -882,1 +882,1 @@\n-    if (type_or_null(k) == NULL) {\n+    if (type_or_null(k) == nullptr) {\n@@ -928,1 +928,1 @@\n-    if (n == NULL || i >= 100) {\n+    if (n == nullptr || i >= 100) {\n@@ -941,1 +941,1 @@\n-  if (n != NULL && !n->is_dead_loop_safe() && !n->is_CFG()) {\n+  if (n != nullptr && !n->is_dead_loop_safe() && !n->is_CFG()) {\n@@ -949,1 +949,1 @@\n-      } else if (in != NULL && !in->is_dead_loop_safe()) {\n+      } else if (in != nullptr && !in->is_dead_loop_safe()) {\n@@ -1004,1 +1004,1 @@\n-    if(n != NULL && n != _table.sentinel() && n->outcnt() == 0) {\n+    if(n != nullptr && n != _table.sentinel() && n->outcnt() == 0) {\n@@ -1051,1 +1051,1 @@\n-      if (n == NULL) {\n+      if (n == nullptr) {\n@@ -1075,1 +1075,1 @@\n-      if (oldtype != newtype && oldtype != NULL) {\n+      if (oldtype != newtype && oldtype != nullptr) {\n@@ -1084,1 +1084,1 @@\n-      if (oldtype == NULL) {\n+      if (oldtype == nullptr) {\n@@ -1091,1 +1091,1 @@\n-      if (newtype == NULL) {\n+      if (newtype == nullptr) {\n@@ -1109,1 +1109,1 @@\n-      verify_step((Node*) NULL);\n+      verify_step((Node*) nullptr);\n@@ -1118,1 +1118,1 @@\n-    _verify_window[i] = NULL;\n+    _verify_window[i] = nullptr;\n@@ -1123,1 +1123,1 @@\n-  while (modified_list != NULL && modified_list->size()) {\n+  while (modified_list != nullptr && modified_list->size()) {\n@@ -1137,1 +1137,1 @@\n-  while (modified_list != NULL && modified_list->size()) {\n+  while (modified_list != nullptr && modified_list->size()) {\n@@ -1158,1 +1158,1 @@\n-  if (modified_list != NULL) {\n+  if (modified_list != nullptr) {\n@@ -1236,1 +1236,1 @@\n-  if (orig != NULL)  C->copy_node_notes_to(n, orig);\n+  if (orig != nullptr)  C->copy_node_notes_to(n, orig);\n@@ -1251,1 +1251,1 @@\n-  if (type_or_null(n) == NULL) {\n+  if (type_or_null(n) == nullptr) {\n@@ -1278,1 +1278,1 @@\n-  while (i != NULL) {\n+  while (i != nullptr) {\n@@ -1310,1 +1310,1 @@\n-  assert(t != NULL, \"value sanity\");\n+  assert(t != nullptr, \"value sanity\");\n@@ -1395,2 +1395,2 @@\n-          if (in != NULL && in != C->top()) {  \/\/ Points to something?\n-            int nrep = dead->replace_edge(in, NULL, this);  \/\/ Kill edges\n+          if (in != nullptr && in != C->top()) {  \/\/ Points to something?\n+            int nrep = dead->replace_edge(in, nullptr, this);  \/\/ Kill edges\n@@ -1421,1 +1421,1 @@\n-                in->is_Proj() && in->in(0) != NULL && in->in(0)->is_Initialize()) {\n+                in->is_Proj() && in->in(0) != nullptr && in->in(0)->is_Initialize()) {\n@@ -1432,1 +1432,1 @@\n-          } \/\/ if (in != NULL && in != C->top())\n+          } \/\/ if (in != nullptr && in != C->top())\n@@ -1488,1 +1488,1 @@\n-  if (old->is_Phi() && old->as_Phi()->type()->has_memory() && old->in(0) != NULL) {\n+  if (old->is_Phi() && old->as_Phi()->type()->has_memory() && old->in(0) != nullptr) {\n@@ -1492,1 +1492,1 @@\n-      if (phi != NULL && phi->inst_mem_id() == (int)old->_idx) {\n+      if (phi != nullptr && phi->inst_mem_id() == (int)old->_idx) {\n@@ -1503,1 +1503,1 @@\n-  if (nn != NULL && nn->outcnt() == 0) {\n+  if (nn != nullptr && nn->outcnt() == 0) {\n@@ -1535,1 +1535,1 @@\n-          if (phi != NULL) {\n+          if (phi != nullptr) {\n@@ -1542,1 +1542,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1557,1 +1557,1 @@\n-    \/\/ the Catch following the call.  It's looking for a non-NULL\n+    \/\/ the Catch following the call.  It's looking for a non-null\n@@ -1562,1 +1562,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -1590,1 +1590,1 @@\n-        if (phi != NULL) {\n+        if (phi != nullptr) {\n@@ -1602,1 +1602,1 @@\n-            if (castii->in(0) != NULL && castii->in(0)->in(0) != NULL && castii->in(0)->in(0)->is_If()) {\n+            if (castii->in(0) != nullptr && castii->in(0)->in(0) != nullptr && castii->in(0)->in(0)->is_If()) {\n@@ -1604,1 +1604,1 @@\n-              if (ifnode->in(1) != NULL && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == use) {\n+              if (ifnode->in(1) != nullptr && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == use) {\n@@ -1653,1 +1653,1 @@\n-      if (init != NULL) {\n+      if (init != nullptr) {\n@@ -1655,1 +1655,1 @@\n-        if (imem != NULL)  add_users_to_worklist0(imem);\n+        if (imem != nullptr)  add_users_to_worklist0(imem);\n@@ -1663,1 +1663,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -1670,1 +1670,1 @@\n-      if (imem != NULL)  add_users_to_worklist0(imem);\n+      if (imem != nullptr)  add_users_to_worklist0(imem);\n@@ -1706,1 +1706,1 @@\n-    if (t != NULL) {\n+    if (t != nullptr) {\n@@ -1840,1 +1840,1 @@\n-              if (catch_node != NULL) {\n+              if (catch_node != nullptr) {\n@@ -1871,1 +1871,1 @@\n-          if (phi != NULL) {\n+          if (phi != nullptr) {\n@@ -1941,1 +1941,1 @@\n-  if( new_node != NULL )\n+  if( new_node != nullptr )\n@@ -1962,1 +1962,1 @@\n-    assert(new_node == NULL, \"\");\n+    assert(new_node == nullptr, \"\");\n@@ -1974,1 +1974,1 @@\n-      if( input != NULL ) {                    \/\/ Ignore NULLs\n+      if( input != nullptr ) {                 \/\/ Ignore nulls\n@@ -1976,1 +1976,1 @@\n-        if( new_input == NULL ) {\n+        if( new_input == nullptr ) {\n@@ -2017,1 +2017,1 @@\n-      if( C->cached_top_node() == NULL || C->cached_top_node()->in(0) == NULL ) {\n+      if( C->cached_top_node() == nullptr || C->cached_top_node()->in(0) == nullptr ) {\n@@ -2029,1 +2029,1 @@\n-        n->set_req(0, NULL);        \/\/ Cut selfreference\n+        n->set_req(0, nullptr);     \/\/ Cut selfreference\n@@ -2062,1 +2062,1 @@\n-  \/\/ TEMPORARY fix to ensure that 2nd GVN pass eliminates NULL checks\n+  \/\/ TEMPORARY fix to ensure that 2nd GVN pass eliminates null checks\n@@ -2122,1 +2122,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2144,1 +2144,1 @@\n-        if( m2 != NULL ) {\n+        if( m2 != nullptr ) {\n@@ -2237,1 +2237,1 @@\n-  if (igvn == NULL) {\n+  if (igvn == nullptr) {\n@@ -2270,1 +2270,1 @@\n-    _types[0] = NULL;\n+    _types[0] = nullptr;\n@@ -2283,1 +2283,1 @@\n-    if( _types[i] != NULL ) {\n+    if( _types[i] != nullptr ) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":82,"deletions":82,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-\/\/ Expandable closed hash-table of nodes, initialized to NULL.\n+\/\/ Expandable closed hash-table of nodes, initialized to null.\n@@ -85,1 +85,1 @@\n-  void   clear();               \/\/ Set all entries to NULL, keep storage.\n+  void   clear();               \/\/ Set all entries to null, keep storage.\n@@ -119,1 +119,1 @@\n-\/\/ Abstractly provides an infinite array of Type*'s, initialized to NULL.\n+\/\/ Abstractly provides an infinite array of Type*'s, initialized to null.\n@@ -128,2 +128,2 @@\n-  const Type *operator[] ( uint i ) const \/\/ Lookup, or NULL for not mapped\n-  { return (i<_max) ? _types[i] : (Type*)NULL; }\n+  const Type *operator[] ( uint i ) const \/\/ Lookup, or null for not mapped\n+  { return (i<_max) ? _types[i] : (Type*)nullptr; }\n@@ -222,1 +222,1 @@\n-  \/\/ you must use type_or_null, and test the result for NULL.\n+  \/\/ you must use type_or_null, and test the result for nullptr.\n@@ -225,1 +225,1 @@\n-    assert(n != NULL, \"must not be null\");\n+    assert(n != nullptr, \"must not be null\");\n@@ -227,1 +227,1 @@\n-    assert(t != NULL, \"must set before get\");\n+    assert(t != nullptr, \"must set before get\");\n@@ -231,1 +231,1 @@\n-  \/\/ or else return NULL if there is none.\n+  \/\/ or else return nullptr if there is none.\n@@ -238,1 +238,1 @@\n-    assert(t != NULL, \"type must not be null\");\n+    assert(t != nullptr, \"type must not be null\");\n@@ -246,1 +246,1 @@\n-    assert(_types[n->_idx] == NULL, \"must set the initial type just once\");\n+    assert(_types[n->_idx] == nullptr, \"must set the initial type just once\");\n@@ -253,1 +253,1 @@\n-      _types.map(n->_idx, NULL);   \/\/ Grow the types array as needed.\n+      _types.map(n->_idx, nullptr);   \/\/ Grow the types array as needed.\n@@ -261,1 +261,1 @@\n-    return (t != NULL && t->is_con()) ? t->get_con() : value_if_unknown;\n+    return (t != nullptr && t->is_con()) ? t->get_con() : value_if_unknown;\n@@ -265,1 +265,1 @@\n-    return (t != NULL && t->is_con()) ? t->get_con() : value_if_unknown;\n+    return (t != nullptr && t->is_con()) ? t->get_con() : value_if_unknown;\n@@ -272,1 +272,1 @@\n-  { ShouldNotCallThis(); return NULL; }\n+  { ShouldNotCallThis(); return nullptr; }\n@@ -336,1 +336,1 @@\n-  { ShouldNotCallThis(); return NULL; }\n+  { ShouldNotCallThis(); return nullptr; }\n@@ -374,1 +374,1 @@\n-  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : NULL; }\n+  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : nullptr; }\n@@ -496,1 +496,1 @@\n-  Node* register_new_node_with_optimizer(Node* n, Node* orig = NULL);\n+  Node* register_new_node_with_optimizer(Node* n, Node* orig = nullptr);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-        return NULL;\n+        return nullptr;\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    guarantee(def != NULL, \"must not resurrect dead copy\");\n+    guarantee(def != nullptr, \"must not resurrect dead copy\");\n@@ -90,4 +90,4 @@\n-  assert(value != NULL || regnd == NULL, \"sanity\");\n-  if (value != NULL && regnd != NULL && regnd->at(old_reg) == old) { \/\/ Instruction is currently available?\n-    value->map(old_reg, NULL); \/\/ Yank from value\/regnd maps\n-    regnd->map(old_reg, NULL); \/\/ This register's value is now unknown\n+  assert(value != nullptr || regnd == nullptr, \"sanity\");\n+  if (value != nullptr && regnd != nullptr && regnd->at(old_reg) == old) { \/\/ Instruction is currently available?\n+    value->map(old_reg, nullptr); \/\/ Yank from value\/regnd maps\n+    regnd->map(old_reg, nullptr); \/\/ This register's value is now unknown\n@@ -150,2 +150,2 @@\n-      if (n != NULL) {\n-        old->set_req(i, NULL);\n+      if (n != nullptr) {\n+        old->set_req(i, nullptr);\n@@ -221,1 +221,1 @@\n-    guarantee(c->in(idx) != NULL, \"must not resurrect dead copy\");\n+    guarantee(c->in(idx) != nullptr, \"must not resurrect dead copy\");\n@@ -244,1 +244,1 @@\n-    guarantee(copy != NULL, \"must not resurrect dead copy\");\n+    guarantee(copy != nullptr, \"must not resurrect dead copy\");\n@@ -261,2 +261,2 @@\n-  assert(regnd != NULL || value == NULL, \"sanity\");\n-  if (value == NULL || regnd == NULL) {\n+  assert(regnd != nullptr || value == nullptr, \"sanity\");\n+  if (value == nullptr || regnd == nullptr) {\n@@ -294,1 +294,1 @@\n-  const Type *t = val->is_Con() ? val->bottom_type() : NULL;\n+  const Type *t = val->is_Con() ? val->bottom_type() : nullptr;\n@@ -364,1 +364,1 @@\n-      value[nreg] != NULL && value[nreg]->is_Con() &&\n+      value[nreg] != nullptr && value[nreg]->is_Con() &&\n@@ -444,1 +444,1 @@\n-    if (def != NULL && lrg == _lrg_map.live_range_id(def) && def != n->in(k)) {\n+    if (def != nullptr && lrg == _lrg_map.live_range_id(def) && def != n->in(k)) {\n@@ -468,1 +468,1 @@\n-          use->replace_edge(def, merge, NULL);\n+          use->replace_edge(def, merge, nullptr);\n@@ -488,1 +488,1 @@\n-\/\/ Nodes indexed by machine register or stack slot number).  NULL means that a\n+\/\/ Nodes indexed by machine register or stack slot number).  null means that a\n@@ -491,1 +491,1 @@\n-\/\/ updating the mapping as we go.  At merge points we force a NULL if we have\n+\/\/ updating the mapping as we go.  At merge points we force a null if we have\n@@ -539,1 +539,1 @@\n-    Block *freed = NULL;\n+    Block *freed = nullptr;\n@@ -589,1 +589,1 @@\n-      \/\/ Merge all inputs together, setting to NULL any conflicts.\n+      \/\/ Merge all inputs together, setting to null any conflicts.\n@@ -598,2 +598,2 @@\n-            value.map(k, NULL); \/\/ Then no value handy\n-            regnd.map(k, NULL);\n+            value.map(k, nullptr); \/\/ Then no value handy\n+            regnd.map(k, nullptr);\n@@ -613,1 +613,1 @@\n-      Node *u = NULL;\n+      Node *u = nullptr;\n@@ -666,1 +666,1 @@\n-        guarantee(def != NULL, \"no disconnected nodes at this point\");\n+        guarantee(def != nullptr, \"no disconnected nodes at this point\");\n@@ -674,1 +674,1 @@\n-                   def->in(idx) != NULL &&  \/\/ NULL should not happen\n+                   def->in(idx) != nullptr &&  \/\/ null should not happen\n@@ -720,3 +720,3 @@\n-      if (regnd[nreg] != NULL && regnd[nreg]->outcnt() == 0) {\n-        regnd.map(nreg, NULL);\n-        value.map(nreg, NULL);\n+      if (regnd[nreg] != nullptr && regnd[nreg]->outcnt() == 0) {\n+        regnd.map(nreg, nullptr);\n+        value.map(nreg, nullptr);\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -72,1 +72,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -167,1 +167,1 @@\n-  Node *spill = get_spillcopy_wide(MachSpillCopyNode::Definition, def, NULL, 0);\n+  Node *spill = get_spillcopy_wide(MachSpillCopyNode::Definition, def, nullptr, 0);\n@@ -366,1 +366,1 @@\n-  if (spill == NULL || C->check_node_count(NodeLimitFudgeFactor, out_of_nodes)) {\n+  if (spill == nullptr || C->check_node_count(NodeLimitFudgeFactor, out_of_nodes)) {\n@@ -564,1 +564,1 @@\n-      Reachblock[slidx] = NULL;  \/\/ Assume that no def is present\n+      Reachblock[slidx] = nullptr;  \/\/ Assume that no def is present\n@@ -655,2 +655,2 @@\n-        \/\/ Preserve a non-NULL predecessor for later type referencing\n-        if( (n3 == NULL) && (n2 != NULL) ){\n+        \/\/ Preserve a non-null predecessor for later type referencing\n+        if( (n3 == nullptr) && (n2 != nullptr) ){\n@@ -666,2 +666,2 @@\n-        phi = n1->is_Phi() ? n1->as_Phi() : NULL;\n-        if( phi == NULL ) {\n+        phi = n1->is_Phi() ? n1->as_Phi() : nullptr;\n+        if( phi == nullptr ) {\n@@ -690,1 +690,1 @@\n-          guarantee(n3, \"No non-NULL reaching DEF for a Phi\");\n+          guarantee(n3, \"No non-null reaching DEF for a Phi\");\n@@ -703,1 +703,1 @@\n-        assert(phi != NULL,\"Must have a Phi Node here\");\n+        assert(phi != nullptr,\"Must have a Phi Node here\");\n@@ -756,1 +756,1 @@\n-      debug_defs[insidx] = (UPblock[insidx]) ? NULL : Reachblock[insidx];\n+      debug_defs[insidx] = (UPblock[insidx]) ? nullptr : Reachblock[insidx];\n@@ -777,1 +777,1 @@\n-            Node *u = NULL;\n+            Node *u = nullptr;\n@@ -783,1 +783,1 @@\n-                if( u != NULL ) \/\/ If it's the 2nd, bail out\n+                if( u != nullptr ) \/\/ If it's the 2nd, bail out\n@@ -819,1 +819,1 @@\n-          if( n1 == NULL ) continue;\n+          if( n1 == nullptr ) continue;\n@@ -829,1 +829,1 @@\n-              if( debug_defs[slidx] != NULL ) {\n+              if( debug_defs[slidx] != nullptr ) {\n@@ -864,1 +864,1 @@\n-                \/\/ Spill of NULL check mem op goes into the following block.\n+                \/\/ Spill of null check mem op goes into the following block.\n@@ -894,1 +894,1 @@\n-        n->set_req( copyidx, NULL );\n+        n->set_req( copyidx, nullptr );\n@@ -928,1 +928,1 @@\n-            assert( def != NULL, \"Using Undefined Value in Split()\\n\");\n+            assert( def != nullptr, \"Using Undefined Value in Split()\\n\");\n@@ -937,1 +937,1 @@\n-              if (def == NULL || C->check_node_count(NodeLimitFudgeFactor, out_of_nodes)) {\n+              if (def == nullptr || C->check_node_count(NodeLimitFudgeFactor, out_of_nodes)) {\n@@ -955,1 +955,1 @@\n-            MachNode *mach = n->is_Mach() ? n->as_Mach() : NULL;\n+            MachNode *mach = n->is_Mach() ? n->as_Mach() : nullptr;\n@@ -984,1 +984,1 @@\n-                    derived_debug != NULL &&\n+                    derived_debug != nullptr &&\n@@ -1012,1 +1012,1 @@\n-              if ((debug_start <= inpidx) && (debug_defs[slidx] != NULL)) {\n+              if ((debug_start <= inpidx) && (debug_defs[slidx] != nullptr)) {\n@@ -1233,1 +1233,1 @@\n-          debug_defs[slidx] = defup ? NULL : n;\n+          debug_defs[slidx] = defup ? nullptr : n;\n@@ -1297,1 +1297,1 @@\n-        Reachblock[slidx] = NULL;\n+        Reachblock[slidx] = nullptr;\n@@ -1299,1 +1299,1 @@\n-        assert(Reachblock[slidx] != NULL,\"No reaching definition for liveout value\");\n+        assert(Reachblock[slidx] != nullptr,\"No reaching definition for liveout value\");\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  if (_replaced_nodes == NULL) {\n+  if (_replaced_nodes == nullptr) {\n@@ -38,1 +38,1 @@\n-  return _replaced_nodes == NULL || _replaced_nodes->length() == 0;\n+  return _replaced_nodes == nullptr || _replaced_nodes->length() == 0;\n@@ -81,1 +81,1 @@\n-  if (_replaced_nodes != NULL) {\n+  if (_replaced_nodes != nullptr) {\n@@ -89,1 +89,1 @@\n-  if (_replaced_nodes != NULL) {\n+  if (_replaced_nodes != nullptr) {\n@@ -133,1 +133,1 @@\n-    assert (ctl != NULL && !ctl->is_top(), \"replaced node should have actual control\");\n+    assert (ctl != nullptr && !ctl->is_top(), \"replaced node should have actual control\");\n@@ -153,1 +153,1 @@\n-        if (n->is_CFG() || (n->in(0) != NULL && !n->in(0)->is_top())) {\n+        if (n->is_CFG() || (n->in(0) != nullptr && !n->in(0)->is_top())) {\n@@ -167,1 +167,1 @@\n-            if (depth >= 100 || n == NULL) {\n+            if (depth >= 100 || n == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    ReplacedNode() : _initial(NULL), _improved(NULL) {}\n+    ReplacedNode() : _initial(nullptr), _improved(nullptr) {}\n@@ -68,1 +68,1 @@\n-    : _replaced_nodes(NULL) {}\n+    : _replaced_nodes(nullptr) {}\n","filename":"src\/hotspot\/share\/opto\/replacednodes.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  return modified ? this : NULL;\n+  return modified ? this : nullptr;\n@@ -81,1 +81,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n","filename":"src\/hotspot\/share\/opto\/rootnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,16 +95,16 @@\n-address OptoRuntime::_new_instance_Java                           = NULL;\n-address OptoRuntime::_new_array_Java                              = NULL;\n-address OptoRuntime::_new_array_nozero_Java                       = NULL;\n-address OptoRuntime::_multianewarray2_Java                        = NULL;\n-address OptoRuntime::_multianewarray3_Java                        = NULL;\n-address OptoRuntime::_multianewarray4_Java                        = NULL;\n-address OptoRuntime::_multianewarray5_Java                        = NULL;\n-address OptoRuntime::_multianewarrayN_Java                        = NULL;\n-address OptoRuntime::_vtable_must_compile_Java                    = NULL;\n-address OptoRuntime::_complete_monitor_locking_Java               = NULL;\n-address OptoRuntime::_monitor_notify_Java                         = NULL;\n-address OptoRuntime::_monitor_notifyAll_Java                      = NULL;\n-address OptoRuntime::_rethrow_Java                                = NULL;\n-\n-address OptoRuntime::_slow_arraycopy_Java                         = NULL;\n-address OptoRuntime::_register_finalizer_Java                     = NULL;\n+address OptoRuntime::_new_instance_Java                           = nullptr;\n+address OptoRuntime::_new_array_Java                              = nullptr;\n+address OptoRuntime::_new_array_nozero_Java                       = nullptr;\n+address OptoRuntime::_multianewarray2_Java                        = nullptr;\n+address OptoRuntime::_multianewarray3_Java                        = nullptr;\n+address OptoRuntime::_multianewarray4_Java                        = nullptr;\n+address OptoRuntime::_multianewarray5_Java                        = nullptr;\n+address OptoRuntime::_multianewarrayN_Java                        = nullptr;\n+address OptoRuntime::_vtable_must_compile_Java                    = nullptr;\n+address OptoRuntime::_complete_monitor_locking_Java               = nullptr;\n+address OptoRuntime::_monitor_notify_Java                         = nullptr;\n+address OptoRuntime::_monitor_notifyAll_Java                      = nullptr;\n+address OptoRuntime::_rethrow_Java                                = nullptr;\n+\n+address OptoRuntime::_slow_arraycopy_Java                         = nullptr;\n+address OptoRuntime::_register_finalizer_Java                     = nullptr;\n@@ -129,1 +129,1 @@\n-  if (var == NULL) { return false; }\n+  if (var == nullptr) { return false; }\n@@ -180,1 +180,1 @@\n-  assert(rs != NULL && rs->is_runtime_stub(), \"not a runtime stub\");\n+  assert(rs != nullptr && rs->is_runtime_stub(), \"not a runtime stub\");\n@@ -302,1 +302,1 @@\n-  if ((len > 0) && (result != NULL) &&\n+  if ((len > 0) && (result != nullptr) &&\n@@ -608,1 +608,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -613,1 +613,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -757,1 +757,1 @@\n-    fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+    fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -799,1 +799,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -820,1 +820,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -975,1 +975,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1021,1 +1021,1 @@\n-  fields[TypeFunc::Parms+0] = NULL;\n+  fields[TypeFunc::Parms+0] = nullptr;\n@@ -1041,1 +1041,1 @@\n-  fields[TypeFunc::Parms+0] = NULL;\n+  fields[TypeFunc::Parms+0] = nullptr;\n@@ -1129,1 +1129,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL;\n+  fields[TypeFunc::Parms + 0] = nullptr;\n@@ -1169,1 +1169,1 @@\n-    fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+    fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1190,1 +1190,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n@@ -1227,1 +1227,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1261,2 +1261,2 @@\n-  assert(current->exception_oop() != NULL, \"exception oop is found\");\n-  address handler_address = NULL;\n+  assert(current->exception_oop() != nullptr, \"exception oop is found\");\n+  address handler_address = nullptr;\n@@ -1295,1 +1295,1 @@\n-  assert(nm != NULL, \"No NMethod found\");\n+  assert(nm != nullptr, \"No NMethod found\");\n@@ -1333,1 +1333,1 @@\n-        force_unwind ? NULL : nm->handler_for_exception_and_pc(exception, pc);\n+        force_unwind ? nullptr : nm->handler_for_exception_and_pc(exception, pc);\n@@ -1335,1 +1335,1 @@\n-      if (handler_address == NULL) {\n+      if (handler_address == nullptr) {\n@@ -1338,1 +1338,1 @@\n-        assert (handler_address != NULL, \"must have compiled handler\");\n+        assert (handler_address != nullptr, \"must have compiled handler\");\n@@ -1384,2 +1384,2 @@\n-  nmethod* nm = NULL;\n-  address handler_address = NULL;\n+  nmethod* nm = nullptr;\n+  address handler_address = nullptr;\n@@ -1398,1 +1398,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -1446,1 +1446,1 @@\n-  assert (exception != NULL, \"should have thrown a NULLPointerException\");\n+  assert (exception != nullptr, \"should have thrown a NullPointerException\");\n@@ -1579,1 +1579,1 @@\n-NamedCounter * volatile OptoRuntime::_named_counters = NULL;\n+NamedCounter * volatile OptoRuntime::_named_counters = nullptr;\n@@ -1641,1 +1641,1 @@\n-    ciMethod* m = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* m = jvms->has_method() ? jvms->method() : nullptr;\n@@ -1649,1 +1649,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1670,1 +1670,1 @@\n-    c->set_next(NULL);\n+    c->set_next(nullptr);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":45,"deletions":45,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    _name(n == NULL ? NULL : os::strdup(n)),\n+    _name(n == nullptr ? nullptr : os::strdup(n)),\n@@ -81,1 +81,1 @@\n-    _next(NULL) {}\n+    _next(nullptr) {}\n@@ -84,1 +84,1 @@\n-    if (_name != NULL) {\n+    if (_name != nullptr) {\n@@ -97,1 +97,1 @@\n-    assert(_next == NULL || next == NULL, \"already set\");\n+    assert(_next == nullptr || next == nullptr, \"already set\");\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-        Node* bol = clone_skeleton_predicate_bool(m, NULL, NULL, m->in(0));\n+        Node* bol = clone_skeleton_predicate_bool(m, nullptr, nullptr, m->in(0));\n@@ -255,1 +255,1 @@\n-  const Type* rtype = NULL;\n+  const Type* rtype = nullptr;\n@@ -265,1 +265,1 @@\n-    if (rtype != NULL) x->as_Type()->set_type(rtype);\n+    if (rtype != nullptr) x->as_Type()->set_type(rtype);\n@@ -415,1 +415,1 @@\n-  if (use_blk == NULL) {        \/\/ He's dead, Jim\n+  if (use_blk == nullptr) {        \/\/ He's dead, Jim\n@@ -493,1 +493,1 @@\n-        if (_nodes[m->_idx] == NULL) {\n+        if (_nodes[m->_idx] == nullptr) {\n@@ -517,2 +517,2 @@\n-  Node *old_false = NULL, *old_true = NULL;\n-  Node *new_false = NULL, *new_true = NULL;\n+  Node *old_false = nullptr, *old_true = nullptr;\n+  Node *new_false = nullptr, *new_true = nullptr;\n@@ -554,1 +554,1 @@\n-  region->set_req(0, NULL);        \/\/ Break the self-cycle. Required for lazy_update to work on region\n+  region->set_req(0, nullptr);        \/\/ Break the self-cycle. Required for lazy_update to work on region\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-    _string_alloc(NULL),\n-    _begin(NULL),\n+    _string_alloc(nullptr),\n+    _begin(nullptr),\n@@ -92,1 +92,1 @@\n-    if (endprojs.resproj != NULL) {\n+    if (endprojs.resproj != nullptr) {\n@@ -95,1 +95,1 @@\n-        if (use != NULL && use->method() != NULL &&\n+        if (use != nullptr && use->method() != nullptr &&\n@@ -147,1 +147,1 @@\n-      if (m != NULL &&\n+      if (m != nullptr &&\n@@ -159,1 +159,1 @@\n-    \/\/ (Proj == NULL) ? \"null\":\"CastPP(Proj)#NotNULL\n+    \/\/ (Proj == nullptr) ? \"null\":\"CastPP(Proj)#Notnull\n@@ -220,1 +220,1 @@\n-    if (log != NULL) {\n+    if (log != nullptr) {\n@@ -223,1 +223,1 @@\n-                _string_alloc != NULL,\n+                _string_alloc != nullptr,\n@@ -226,1 +226,1 @@\n-      while (p != NULL) {\n+      while (p != nullptr) {\n@@ -241,1 +241,1 @@\n-      const TypePtr* no_memory_effects = NULL;\n+      const TypePtr* no_memory_effects = nullptr;\n@@ -353,1 +353,1 @@\n-  if (projs.fallthrough_catchproj != NULL) {\n+  if (projs.fallthrough_catchproj != nullptr) {\n@@ -356,1 +356,1 @@\n-  if (projs.fallthrough_memproj != NULL) {\n+  if (projs.fallthrough_memproj != nullptr) {\n@@ -359,1 +359,1 @@\n-  if (projs.catchall_memproj != NULL) {\n+  if (projs.catchall_memproj != nullptr) {\n@@ -362,1 +362,1 @@\n-  if (projs.fallthrough_ioproj != NULL) {\n+  if (projs.fallthrough_ioproj != nullptr) {\n@@ -365,1 +365,1 @@\n-  if (projs.catchall_ioproj != NULL) {\n+  if (projs.catchall_ioproj != nullptr) {\n@@ -368,1 +368,1 @@\n-  if (projs.catchall_catchproj != NULL) {\n+  if (projs.catchall_catchproj != nullptr) {\n@@ -380,1 +380,1 @@\n-  if (projs.resproj != NULL) {\n+  if (projs.resproj != nullptr) {\n@@ -393,1 +393,1 @@\n-  if (ctrl_proj != NULL) {\n+  if (ctrl_proj != nullptr) {\n@@ -397,1 +397,1 @@\n-  if (mem_proj != NULL) {\n+  if (mem_proj != nullptr) {\n@@ -414,1 +414,1 @@\n-    if (n != NULL && !_visited.test_set(n->_idx)) {\n+    if (n != nullptr && !_visited.test_set(n->_idx)) {\n@@ -425,1 +425,1 @@\n-    if (ctrl->in(0) != NULL && !_visited.test_set(ctrl->in(0)->_idx)) {\n+    if (ctrl->in(0) != nullptr && !_visited.test_set(ctrl->in(0)->_idx)) {\n@@ -430,1 +430,1 @@\n-        if (ctrl->in(i) != NULL && !_visited.test_set(ctrl->in(i)->_idx)) {\n+        if (ctrl->in(i) != nullptr && !_visited.test_set(ctrl->in(i)->_idx)) {\n@@ -454,1 +454,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -465,2 +465,2 @@\n-  AllocateNode* alloc = NULL;\n-  InitializeNode* init = NULL;\n+  AllocateNode* alloc = nullptr;\n+  InitializeNode* init = nullptr;\n@@ -476,1 +476,1 @@\n-    if (cnode == NULL) {\n+    if (cnode == nullptr) {\n@@ -478,1 +478,1 @@\n-      if (alloc == NULL) {\n+      if (alloc == nullptr) {\n@@ -483,1 +483,1 @@\n-      if (result == NULL || !result->is_CheckCastPP() || alloc->in(TypeFunc::Memory)->is_top()) {\n+      if (result == nullptr || !result->is_CheckCastPP() || alloc->in(TypeFunc::Memory)->is_top()) {\n@@ -493,1 +493,1 @@\n-      Node* constructor = NULL;\n+      Node* constructor = nullptr;\n@@ -496,2 +496,2 @@\n-        if (use != NULL &&\n-            use->method() != NULL &&\n+        if (use != nullptr &&\n+            use->method() != nullptr &&\n@@ -508,1 +508,1 @@\n-              assert(use->in(TypeFunc::Parms + 1) != NULL, \"what?\");\n+              assert(use->in(TypeFunc::Parms + 1) != nullptr, \"what?\");\n@@ -519,1 +519,1 @@\n-                return NULL;\n+                return nullptr;\n@@ -526,1 +526,1 @@\n-              assert(parm != NULL, \"must exist\");\n+              assert(parm != nullptr, \"must exist\");\n@@ -539,1 +539,1 @@\n-                return NULL;\n+                return nullptr;\n@@ -558,1 +558,1 @@\n-      if (constructor == NULL) {\n+      if (constructor == nullptr) {\n@@ -579,1 +579,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -581,1 +581,1 @@\n-    } else if (cnode->method() == NULL) {\n+    } else if (cnode->method() == nullptr) {\n@@ -591,1 +591,1 @@\n-      if (arg == NULL || arg->is_top()) {\n+      if (arg == nullptr || arg->is_top()) {\n@@ -607,1 +607,1 @@\n-          if (csj->method() != NULL &&\n+          if (csj->method() != nullptr &&\n@@ -639,1 +639,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -651,1 +651,1 @@\n-  if (size_table_field == NULL) {\n+  if (size_table_field == nullptr) {\n@@ -670,1 +670,1 @@\n-    if (sc != NULL) {\n+    if (sc != nullptr) {\n@@ -797,1 +797,1 @@\n-        assert(mem != NULL, \"calls should have memory edge\");\n+        assert(mem != nullptr, \"calls should have memory edge\");\n@@ -854,2 +854,2 @@\n-        IfNode* iff = NULL;\n-        RegionNode* copy = NULL;\n+        IfNode* iff = nullptr;\n+        RegionNode* copy = nullptr;\n@@ -865,2 +865,2 @@\n-                     ctrl->in(1) != NULL && ctrl->in(1)->is_Proj() &&\n-                     ctrl->in(2) != NULL && ctrl->in(2)->is_Proj() &&\n+                     ctrl->in(1) != nullptr && ctrl->in(1)->is_Proj() &&\n+                     ctrl->in(2) != nullptr && ctrl->in(2)->is_Proj() &&\n@@ -868,1 +868,1 @@\n-                     ctrl->in(1)->in(0) != NULL && ctrl->in(1)->in(0)->is_If(),\n+                     ctrl->in(1)->in(0) != nullptr && ctrl->in(1)->in(0)->is_If(),\n@@ -952,1 +952,1 @@\n-      if (catchproj != NULL) {\n+      if (catchproj != nullptr) {\n@@ -973,1 +973,1 @@\n-      if (b == NULL) {\n+      if (b == nullptr) {\n@@ -994,1 +994,1 @@\n-        \/\/ NULL check of the return value of the append\n+        \/\/ null check of the return value of the append\n@@ -998,1 +998,1 @@\n-          if (call != NULL && call->_name != NULL && strcmp(call->_name, \"uncommon_trap\") == 0) {\n+          if (call != nullptr && call->_name != nullptr && strcmp(call->_name, \"uncommon_trap\") == 0) {\n@@ -1012,1 +1012,1 @@\n-        if (call != NULL && call->_name != NULL && strcmp(call->_name, \"uncommon_trap\") == 0) {\n+        if (call != nullptr && call->_name != nullptr && strcmp(call->_name, \"uncommon_trap\") == 0) {\n@@ -1053,1 +1053,1 @@\n-      if (copy != NULL) {\n+      if (copy != nullptr) {\n@@ -1058,2 +1058,2 @@\n-          ptr->in(1) != NULL && ptr->in(1)->is_Proj() &&\n-          ptr->in(2) != NULL && ptr->in(2)->is_Proj() &&\n+          ptr->in(1) != nullptr && ptr->in(1)->is_Proj() &&\n+          ptr->in(2) != nullptr && ptr->in(2)->is_Proj() &&\n@@ -1061,1 +1061,1 @@\n-          ptr->in(1)->in(0) != NULL && ptr->in(1)->in(0)->is_If()) {\n+          ptr->in(1)->in(0) != nullptr && ptr->in(1)->in(0)->is_If()) {\n@@ -1114,1 +1114,1 @@\n-    if (cnode != NULL) {\n+    if (cnode != nullptr) {\n@@ -1117,2 +1117,2 @@\n-    Node* result = cnode != NULL ? cnode->proj_out_or_null(TypeFunc::Parms) : NULL;\n-    if (result != NULL && result != final_result) {\n+    Node* result = cnode != nullptr ? cnode->proj_out_or_null(TypeFunc::Parms) : nullptr;\n+    if (result != nullptr && result != final_result) {\n@@ -1123,1 +1123,1 @@\n-  Node* last_result = NULL;\n+  Node* last_result = nullptr;\n@@ -1195,1 +1195,1 @@\n-      assert(type != NULL, \"field singleton type must be consistent\");\n+      assert(type != nullptr, \"field singleton type must be consistent\");\n@@ -1204,1 +1204,1 @@\n-  return kit.make_load(NULL, kit.basic_plus_adr(klass_node, field->offset_in_bytes()),\n+  return kit.make_load(nullptr, kit.basic_plus_adr(klass_node, field->offset_in_bytes()),\n@@ -1508,1 +1508,1 @@\n-  Node* extra = NULL;\n+  Node* extra = nullptr;\n@@ -1685,1 +1685,1 @@\n-  bool dcon = (dst_coder != NULL) && dst_coder->is_Con();\n+  bool dcon = (dst_coder != nullptr) && dst_coder->is_Con();\n@@ -1721,1 +1721,1 @@\n-  if (ideal != NULL) {\n+  if (ideal != nullptr) {\n@@ -1725,1 +1725,1 @@\n-  Node* byte_array = NULL;\n+  Node* byte_array = nullptr;\n@@ -1742,1 +1742,1 @@\n-  if (ideal != NULL) {\n+  if (ideal != nullptr) {\n@@ -1892,2 +1892,2 @@\n-        Node* count = NULL;\n-        Node* arg_coder = NULL;\n+        Node* count = nullptr;\n+        Node* arg_coder = nullptr;\n@@ -1951,1 +1951,1 @@\n-        string_sizes->init_req(argi, NULL);\n+        string_sizes->init_req(argi, nullptr);\n@@ -2014,1 +2014,1 @@\n-    Node* dst_array = NULL;\n+    Node* dst_array = nullptr;\n@@ -2023,1 +2023,1 @@\n-      dst_array = allocate_byte_array(kit, NULL, __ LShiftI(length, coder));\n+      dst_array = allocate_byte_array(kit, nullptr, __ LShiftI(length, coder));\n@@ -2053,1 +2053,1 @@\n-    if (result == NULL) {\n+    if (result == nullptr) {\n@@ -2069,1 +2069,1 @@\n-    assert(AllocateNode::Ideal_allocation(result, _gvn) != NULL, \"should be newly allocated\");\n+    assert(AllocateNode::Ideal_allocation(result, _gvn) != nullptr, \"should be newly allocated\");\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":76,"deletions":76,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -109,1 +109,1 @@\n-  if (t != NULL) {\n+  if (t != nullptr) {\n@@ -127,1 +127,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -180,1 +180,1 @@\n-  if( t2 == Type::TOP ) return NULL;\n+  if( t2 == Type::TOP ) return nullptr;\n@@ -206,1 +206,1 @@\n-    if (tcon != NULL && tcon->is_con()) {\n+    if (tcon != nullptr && tcon->is_con()) {\n@@ -214,1 +214,1 @@\n-  if( t1 == Type::TOP ) return NULL;\n+  if( t1 == Type::TOP ) return nullptr;\n@@ -284,1 +284,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -324,1 +324,1 @@\n-  if( phase->type( in2 ) == Type::TOP ) return NULL;\n+  if( phase->type( in2 ) == Type::TOP ) return nullptr;\n@@ -349,1 +349,1 @@\n-    if (tcon != NULL && tcon->is_con()) {\n+    if (tcon != nullptr && tcon->is_con()) {\n@@ -357,1 +357,1 @@\n-  if( t1 == Type::TOP ) return NULL;\n+  if( t1 == Type::TOP ) return nullptr;\n@@ -408,1 +408,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -472,1 +472,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -507,1 +507,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -584,1 +584,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -675,1 +675,1 @@\n-  if (t != NULL) {\n+  if (t != nullptr) {\n@@ -774,1 +774,1 @@\n-  return NULL;                  \/\/ No change\n+  return nullptr;                  \/\/ No change\n@@ -785,1 +785,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -890,3 +890,3 @@\n-    AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);\n-    AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);\n-    if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {\n+    AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, nullptr);\n+    AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, nullptr);\n+    if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, nullptr)) {\n@@ -901,1 +901,1 @@\n-    ciKlass* klass0 = NULL;\n+    ciKlass* klass0 = nullptr;\n@@ -903,1 +903,1 @@\n-    ciKlass* klass1 = NULL;\n+    ciKlass* klass1 = nullptr;\n@@ -976,1 +976,1 @@\n-  \/\/   or NULL if not matching.\n+  \/\/   or nullptr if not matching.\n@@ -980,1 +980,1 @@\n-  if (n->Opcode() != Op_LoadP) return NULL;\n+  if (n->Opcode() != Op_LoadP) return nullptr;\n@@ -983,1 +983,1 @@\n-  if (!tp || tp->klass() != phase->C->env()->Class_klass()) return NULL;\n+  if (!tp || tp->klass() != phase->C->env()->Class_klass()) return nullptr;\n@@ -987,1 +987,1 @@\n-  if (adr->Opcode() != Op_LoadP || !phase->type(adr)->isa_rawptr()) return NULL;\n+  if (adr->Opcode() != Op_LoadP || !phase->type(adr)->isa_rawptr()) return nullptr;\n@@ -992,1 +992,1 @@\n-  if (k == NULL)  return NULL;\n+  if (k == nullptr)  return nullptr;\n@@ -994,1 +994,1 @@\n-  if (!tkp || off != in_bytes(Klass::java_mirror_offset())) return NULL;\n+  if (!tkp || off != in_bytes(Klass::java_mirror_offset())) return nullptr;\n@@ -1002,2 +1002,2 @@\n-  \/\/ otherwise return NULL\n-  if (!n->is_Con()) return NULL;\n+  \/\/ otherwise return null\n+  if (!n->is_Con()) return nullptr;\n@@ -1006,1 +1006,1 @@\n-  if (!tp) return NULL;\n+  if (!tp) return nullptr;\n@@ -1009,1 +1009,1 @@\n-  \/\/ TypeInstPtr::java_mirror_type() returns non-NULL for compile-\n+  \/\/ TypeInstPtr::java_mirror_type() returns non-null for compile-\n@@ -1011,1 +1011,1 @@\n-  if (!mirror_type) return NULL;\n+  if (!mirror_type) return nullptr;\n@@ -1014,1 +1014,1 @@\n-  \/\/ Return a ConP(NULL) node for this case.\n+  \/\/ Return a ConP(null) node for this case.\n@@ -1051,1 +1051,1 @@\n-      Node* rhs = (k2 != NULL) ? k2 : conk2;\n+      Node* rhs = (k2 != nullptr) ? k2 : conk2;\n@@ -1060,2 +1060,2 @@\n-  if (t2 == NULL || !t2->klass_is_exact())\n-    return NULL;\n+  if (t2 == nullptr || !t2->klass_is_exact())\n+    return nullptr;\n@@ -1070,1 +1070,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1072,1 +1072,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1077,2 +1077,2 @@\n-  if (ldk2 == NULL)\n-    return NULL;\n+  if (ldk2 == nullptr)\n+    return nullptr;\n@@ -1095,1 +1095,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1097,1 +1097,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1101,1 +1101,1 @@\n-    return NULL;                \/\/ Might be element-klass loading from array klass\n+    return nullptr;                \/\/ Might be element-klass loading from array klass\n@@ -1119,1 +1119,1 @@\n-    if (ik->has_subklass() || ik->is_interface())  return NULL;\n+    if (ik->has_subklass() || ik->is_interface())  return nullptr;\n@@ -1143,1 +1143,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1243,1 +1243,1 @@\n-  return NULL;                  \/\/ No change\n+  return nullptr;                  \/\/ No change\n@@ -1334,1 +1334,1 @@\n-  Node* cmov = CMoveNode::make(NULL, this,\n+  Node* cmov = CMoveNode::make(nullptr, this,\n@@ -1356,2 +1356,2 @@\n-    if ((r0 != NULL) && (r0 != TypeInt::INT) &&\n-        (r1 != NULL) && (r1 != TypeInt::INT) &&\n+    if ((r0 != nullptr) && (r0 != TypeInt::INT) &&\n+        (r1 != nullptr) && (r1 != TypeInt::INT) &&\n@@ -1391,1 +1391,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1396,1 +1396,1 @@\n-  return n != NULL &&\n+  return n != nullptr &&\n@@ -1398,1 +1398,1 @@\n-         n->in(0) != NULL &&\n+         n->in(0) != nullptr &&\n@@ -1408,1 +1408,1 @@\n-  if( !cmp->is_Sub() ) return NULL;\n+  if( !cmp->is_Sub() ) return nullptr;\n@@ -1410,1 +1410,1 @@\n-  if( cop == Op_FastLock || cop == Op_FastUnlock || cmp->is_SubTypeCheck()) return NULL;\n+  if( cop == Op_FastLock || cop == Op_FastUnlock || cmp->is_SubTypeCheck()) return nullptr;\n@@ -1413,1 +1413,1 @@\n-  if( !cmp1 ) return NULL;\n+  if( !cmp1 ) return nullptr;\n@@ -1416,1 +1416,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1473,1 +1473,1 @@\n-  if (cmp2_type == NULL)  return NULL;\n+  if (cmp2_type == nullptr)  return nullptr;\n@@ -1490,1 +1490,1 @@\n-    Node* bound = NULL;\n+    Node* bound = nullptr;\n@@ -1586,1 +1586,1 @@\n-      cmp1->in(2) != NULL &&\n+      cmp1->in(2) != nullptr &&\n@@ -1659,1 +1659,1 @@\n-  \/\/      return NULL;\n+  \/\/      return nullptr;\n@@ -1664,1 +1664,1 @@\n-  \/\/    if( !phase->allow_progress() ) return NULL;\n+  \/\/    if( !phase->allow_progress() ) return nullptr;\n@@ -1670,1 +1670,1 @@\n-  \/\/    if( cmp->Opcode() == Op_CmpU ) return NULL;\n+  \/\/    if( cmp->Opcode() == Op_CmpU ) return nullptr;\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":63,"deletions":63,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-  virtual const Type *sub( const Type *, const Type * ) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type *sub( const Type *, const Type * ) const { ShouldNotReachHere(); return nullptr; }\n@@ -283,1 +283,1 @@\n-  virtual const Type *sub( const Type *, const Type * ) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type *sub( const Type *, const Type * ) const { ShouldNotReachHere(); return nullptr; }\n@@ -341,1 +341,1 @@\n-  BoolNode(Node *cc, BoolTest::mask t): Node(NULL,cc), _test(t) {\n+  BoolNode(Node *cc, BoolTest::mask t): Node(nullptr,cc), _test(t) {\n@@ -515,1 +515,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    if (subk != NULL) {\n+    if (subk != nullptr) {\n@@ -110,3 +110,3 @@\n-  if (obj_or_subklass == NULL ||\n-      superklass == NULL) {\n-    return NULL;\n+  if (obj_or_subklass == nullptr ||\n+      superklass == nullptr) {\n+    return nullptr;\n@@ -120,1 +120,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -123,1 +123,1 @@\n-  Node* addr = NULL;\n+  Node* addr = nullptr;\n@@ -125,1 +125,1 @@\n-    if (obj_or_subklass->in(1) != NULL &&\n+    if (obj_or_subklass->in(1) != nullptr &&\n@@ -133,1 +133,1 @@\n-  if (addr != NULL) {\n+  if (addr != nullptr) {\n@@ -136,1 +136,1 @@\n-    if (con == oopDesc::klass_offset_in_bytes() && obj != NULL) {\n+    if (con == oopDesc::klass_offset_in_bytes() && obj != nullptr) {\n@@ -145,1 +145,1 @@\n-  if (allocated_klass != NULL) {\n+  if (allocated_klass != nullptr) {\n@@ -155,1 +155,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -206,1 +206,1 @@\n-  ciKlass* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass(); \/\/ can be NULL for bottom[]\n+  ciKlass* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass(); \/\/ can be nullptr for bottom[]\n@@ -209,2 +209,2 @@\n-  if (super_t->singleton() && subk != NULL) {\n-    Node* subklass = NULL;\n+  if (super_t->singleton() && subk != nullptr) {\n+    Node* subklass = nullptr;\n@@ -213,1 +213,1 @@\n-      subklass  = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+      subklass  = phase->transform(LoadKlassNode::make(*phase, nullptr, C->immutable_memory(), adr, TypeInstPtr::KLASS));\n@@ -226,1 +226,1 @@\n-        Node* chk_off = phase->transform(new LoadINode(NULL, C->immutable_memory(), p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n+        Node* chk_off = phase->transform(new LoadINode(nullptr, C->immutable_memory(), p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n@@ -237,1 +237,1 @@\n-          Node* nkls = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, nullptr, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  _packset(arena(), 8,  0, NULL),         \/\/ packs for the current block\n+  _packset(arena(), 8,  0, nullptr),                        \/\/ packs for the current block\n@@ -55,24 +55,24 @@\n-  _block(arena(), 8,  0, NULL),           \/\/ nodes in current block\n-  _post_block(arena(), 8, 0, NULL),       \/\/ nodes common to current block which are marked as post loop vectorizable\n-  _data_entry(arena(), 8,  0, NULL),      \/\/ nodes with all inputs from outside\n-  _mem_slice_head(arena(), 8,  0, NULL),  \/\/ memory slice heads\n-  _mem_slice_tail(arena(), 8,  0, NULL),  \/\/ memory slice tails\n-  _node_info(arena(), 8,  0, SWNodeInfo::initial), \/\/ info needed per node\n-  _clone_map(phase->C->clone_map()),      \/\/ map of nodes created in cloning\n-  _cmovev_kit(_arena, this),              \/\/ map to facilitate CMoveV creation\n-  _align_to_ref(NULL),                    \/\/ memory reference to align vectors to\n-  _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial), \/\/ runtime disambiguated pointer pairs\n-  _dg(_arena),                            \/\/ dependence graph\n-  _visited(arena()),                      \/\/ visited node set\n-  _post_visited(arena()),                 \/\/ post visited node set\n-  _n_idx_list(arena(), 8),                \/\/ scratch list of (node,index) pairs\n-  _nlist(arena(), 8, 0, NULL),            \/\/ scratch list of nodes\n-  _stk(arena(), 8, 0, NULL),              \/\/ scratch stack of nodes\n-  _lpt(NULL),                             \/\/ loop tree node\n-  _lp(NULL),                              \/\/ CountedLoopNode\n-  _pre_loop_end(NULL),                    \/\/ Pre loop CountedLoopEndNode\n-  _bb(NULL),                              \/\/ basic block\n-  _iv(NULL),                              \/\/ induction var\n-  _race_possible(false),                  \/\/ cases where SDMU is true\n-  _early_return(true),                    \/\/ analysis evaluations routine\n-  _do_vector_loop(phase->C->do_vector_loop()),  \/\/ whether to do vectorization\/simd style\n+  _block(arena(), 8,  0, nullptr),                          \/\/ nodes in current block\n+  _post_block(arena(), 8, 0, nullptr),                      \/\/ nodes common to current block which are marked as post loop vectorizable\n+  _data_entry(arena(), 8,  0, nullptr),                     \/\/ nodes with all inputs from outside\n+  _mem_slice_head(arena(), 8,  0, nullptr),                 \/\/ memory slice heads\n+  _mem_slice_tail(arena(), 8,  0, nullptr),                 \/\/ memory slice tails\n+  _node_info(arena(), 8,  0, SWNodeInfo::initial),          \/\/ info needed per node\n+  _clone_map(phase->C->clone_map()),                        \/\/ map of nodes created in cloning\n+  _cmovev_kit(_arena, this),                                \/\/ map to facilitate CMoveV creation\n+  _align_to_ref(nullptr),                                   \/\/ memory reference to align vectors to\n+  _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial),     \/\/ runtime disambiguated pointer pairs\n+  _dg(_arena),                                              \/\/ dependence graph\n+  _visited(arena()),                                        \/\/ visited node set\n+  _post_visited(arena()),                                   \/\/ post visited node set\n+  _n_idx_list(arena(), 8),                                  \/\/ scratch list of (node,index) pairs\n+  _nlist(arena(), 8, 0, nullptr),                           \/\/ scratch list of nodes\n+  _stk(arena(), 8, 0, nullptr),                             \/\/ scratch stack of nodes\n+  _lpt(nullptr),                                            \/\/ loop tree node\n+  _lp(nullptr),                                             \/\/ CountedLoopNode\n+  _pre_loop_end(nullptr),                                   \/\/ Pre loop CountedLoopEndNode\n+  _bb(nullptr),                                             \/\/ basic block\n+  _iv(nullptr),                                             \/\/ induction var\n+  _race_possible(false),                                    \/\/ cases where SDMU is true\n+  _early_return(true),                                      \/\/ analysis evaluations routine\n+  _do_vector_loop(phase->C->do_vector_loop()),              \/\/ whether to do vectorization\/simd style\n@@ -80,4 +80,4 @@\n-  _num_work_vecs(0),                      \/\/ amount of vector work we have\n-  _num_reductions(0),                     \/\/ amount of reduction work we have\n-  _ii_first(-1),                          \/\/ first loop generation index - only if do_vector_loop()\n-  _ii_last(-1),                           \/\/ last loop generation index - only if do_vector_loop()\n+  _num_work_vecs(0),                                        \/\/ amount of vector work we have\n+  _num_reductions(0),                                       \/\/ amount of reduction work we have\n+  _ii_first(-1),                                            \/\/ first loop generation index - only if do_vector_loop()\n+  _ii_last(-1),                                             \/\/ last loop generation index - only if do_vector_loop()\n@@ -88,1 +88,1 @@\n-  if (_phase->C->method() != NULL) {\n+  if (_phase->C->method() != nullptr) {\n@@ -174,1 +174,1 @@\n-    if (pre_end == NULL) {\n+    if (pre_end == nullptr) {\n@@ -299,1 +299,1 @@\n-      if (n_ctrl != NULL && lpt()->is_member(_phase->get_loop(n_ctrl))) {\n+      if (n_ctrl != nullptr && lpt()->is_member(_phase->get_loop(n_ctrl))) {\n@@ -529,1 +529,1 @@\n-    if (align_to_ref() == NULL) {\n+    if (align_to_ref() == nullptr) {\n@@ -618,1 +618,1 @@\n-  MemNode* best_align_to_mem_ref = NULL;\n+  MemNode* best_align_to_mem_ref = nullptr;\n@@ -623,1 +623,1 @@\n-    if (mem_ref == NULL) break;\n+    if (mem_ref == nullptr) break;\n@@ -627,1 +627,1 @@\n-    if (best_align_to_mem_ref == NULL) {\n+    if (best_align_to_mem_ref == nullptr) {\n@@ -636,1 +636,1 @@\n-    SWPointer align_to_ref_p(mem_ref, this, NULL, false);\n+    SWPointer align_to_ref_p(mem_ref, this, nullptr, false);\n@@ -642,1 +642,1 @@\n-        SWPointer p2(s, this, NULL, false);\n+        SWPointer p2(s, this, nullptr, false);\n@@ -663,1 +663,1 @@\n-          SWPointer p2(best_align_to_mem_ref, this, NULL, false);\n+          SWPointer p2(best_align_to_mem_ref, this, nullptr, false);\n@@ -747,1 +747,1 @@\n-        if (best_align_to_mem_ref == NULL) {\n+        if (best_align_to_mem_ref == nullptr) {\n@@ -749,1 +749,1 @@\n-            tty->print_cr(\"SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL\");\n+            tty->print_cr(\"SuperWord::find_adjacent_refs(): best_align_to_mem_ref == nullptr\");\n@@ -762,1 +762,1 @@\n-              assert(best_align_to_mem_ref == NULL, \"sanity\");\n+              assert(best_align_to_mem_ref == nullptr, \"sanity\");\n@@ -765,1 +765,1 @@\n-            assert(best_align_to_mem_ref != NULL, \"sanity\");\n+            assert(best_align_to_mem_ref != nullptr, \"sanity\");\n@@ -814,1 +814,1 @@\n-    SWPointer p1(s1, this, NULL, false);\n+    SWPointer p1(s1, this, nullptr, false);\n@@ -824,1 +824,1 @@\n-        SWPointer p2(s2, this, NULL, false);\n+        SWPointer p2(s2, this, nullptr, false);\n@@ -845,1 +845,1 @@\n-      SWPointer p(s, this, NULL, false);\n+      SWPointer p(s, this, nullptr, false);\n@@ -868,1 +868,1 @@\n-        SWPointer p(s, this, NULL, false);\n+        SWPointer p(s, this, nullptr, false);\n@@ -906,1 +906,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -968,1 +968,1 @@\n-  if (init_nd->is_Con() && p.invar() == NULL) {\n+  if (init_nd->is_Con() && p.invar() == nullptr) {\n@@ -1024,1 +1024,1 @@\n-  SWPointer align_to_ref_p(mem_ref, this, NULL, false);\n+  SWPointer align_to_ref_p(mem_ref, this, nullptr, false);\n@@ -1094,1 +1094,1 @@\n-    DepMem* slice_sink = _dg.make_node(NULL);\n+    DepMem* slice_sink = _dg.make_node(nullptr);\n@@ -1105,1 +1105,1 @@\n-      SWPointer p1(s1->as_Mem(), this, NULL, false);\n+      SWPointer p1(s1->as_Mem(), this, nullptr, false);\n@@ -1111,1 +1111,1 @@\n-        SWPointer p2(s2->as_Mem(), this, NULL, false);\n+        SWPointer p2(s2->as_Mem(), this, nullptr, false);\n@@ -1157,1 +1157,1 @@\n-  Node* prev = NULL;\n+  Node* prev = nullptr;\n@@ -1181,1 +1181,1 @@\n-          assert(out == prev || prev == NULL, \"no branches off of store slice\");\n+          assert(out == prev || prev == nullptr, \"no branches off of store slice\");\n@@ -1257,2 +1257,2 @@\n-  SWPointer p1(s1->as_Mem(), this, NULL, false);\n-  SWPointer p2(s2->as_Mem(), this, NULL, false);\n+  SWPointer p1(s1->as_Mem(), this, nullptr, false);\n+  SWPointer p2(s2->as_Mem(), this, nullptr, false);\n@@ -1276,2 +1276,2 @@\n-    bool s1_ctrl_inv = ((s1_ctrl == NULL) ? true : lpt()->is_invariant(s1_ctrl));\n-    bool s2_ctrl_inv = ((s2_ctrl == NULL) ? true : lpt()->is_invariant(s2_ctrl));\n+    bool s1_ctrl_inv = ((s1_ctrl == nullptr) ? true : lpt()->is_invariant(s1_ctrl));\n+    bool s2_ctrl_inv = ((s2_ctrl == nullptr) ? true : lpt()->is_invariant(s2_ctrl));\n@@ -1282,1 +1282,1 @@\n-    if(s1_ctrl != NULL && s2_ctrl != NULL) {\n+    if(s1_ctrl != nullptr && s2_ctrl != nullptr) {\n@@ -1396,1 +1396,1 @@\n-  Node* use = NULL; \/\/test if the node is a candidate for CMoveV optimization, then return the size of CMov\n+  Node* use = nullptr; \/\/test if the node is a candidate for CMoveV optimization, then return the size of CMov\n@@ -1399,1 +1399,1 @@\n-    if (use != NULL) {\n+    if (use != nullptr) {\n@@ -1403,1 +1403,1 @@\n-    if (use != NULL) {\n+    if (use != nullptr) {\n@@ -1492,2 +1492,2 @@\n-  Node* u1 = NULL;\n-  Node* u2 = NULL;\n+  Node* u1 = nullptr;\n+  Node* u2 = nullptr;\n@@ -1548,1 +1548,1 @@\n-    Node_List* p2 = NULL;\n+    Node_List* p2 = nullptr;\n@@ -1555,1 +1555,1 @@\n-      p2 = NULL;\n+      p2 = nullptr;\n@@ -1558,1 +1558,1 @@\n-    if (p2 != NULL) {\n+    if (p2 != nullptr) {\n@@ -1681,1 +1681,1 @@\n-      if (p1 == NULL) continue;\n+      if (p1 == nullptr) continue;\n@@ -1685,1 +1685,1 @@\n-        if (p2 == NULL) continue;\n+        if (p2 == nullptr) continue;\n@@ -1691,1 +1691,1 @@\n-          _packset.at_put(j, NULL);\n+          _packset.at_put(j, nullptr);\n@@ -1701,1 +1701,1 @@\n-    if (p1 != NULL) {\n+    if (p1 != nullptr) {\n@@ -1710,1 +1710,1 @@\n-        _packset.at_put(i, NULL);\n+        _packset.at_put(i, nullptr);\n@@ -1723,1 +1723,1 @@\n-        _packset.at_put(i, NULL);\n+        _packset.at_put(i, nullptr);\n@@ -1731,1 +1731,1 @@\n-    if (p1 == NULL) {\n+    if (p1 == nullptr) {\n@@ -1746,1 +1746,1 @@\n-  Node_List* rslt = NULL;\n+  Node_List* rslt = nullptr;\n@@ -1752,1 +1752,1 @@\n-      if (my_pack(s) != NULL) {\n+      if (my_pack(s) != nullptr) {\n@@ -1855,3 +1855,3 @@\n-  Node* use = NULL;\n-  if (!def->is_Bool() || def->in(0) != NULL || def->outcnt() != 1) {\n-    return NULL;\n+  Node* use = nullptr;\n+  if (!def->is_Bool() || def->in(0) != nullptr || def->outcnt() != 1) {\n+    return nullptr;\n@@ -1862,1 +1862,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1869,3 +1869,3 @@\n-  Node* use = NULL;\n-  if (!def->is_Cmp() || def->in(0) != NULL || def->outcnt() != 1) {\n-    return NULL;\n+  Node* use = nullptr;\n+  if (!def->is_Cmp() || def->in(0) != nullptr || def->outcnt() != 1) {\n+    return nullptr;\n@@ -1875,2 +1875,2 @@\n-    if (!_sw->same_generation(def, use) || (use = is_Bool_candidate(use)) == NULL || !_sw->same_generation(def, use)) {\n-      return NULL;\n+    if (!_sw->same_generation(def, use) || (use = is_Bool_candidate(use)) == nullptr || !_sw->same_generation(def, use)) {\n+      return nullptr;\n@@ -1885,1 +1885,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1888,1 +1888,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1890,2 +1890,2 @@\n-  if (pack(cmovd) != NULL) { \/\/ already in the cmov pack\n-    return NULL;\n+  if (pack(cmovd) != nullptr) { \/\/ already in the cmov pack\n+    return nullptr;\n@@ -1893,1 +1893,1 @@\n-  if (cmovd->in(0) != NULL) {\n+  if (cmovd->in(0) != nullptr) {\n@@ -1895,1 +1895,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1902,2 +1902,2 @@\n-      || bol->in(0) != NULL  \/\/ BoolNode has control flow!!\n-      || _sw->my_pack(bol) == NULL) {\n+      || bol->in(0) != nullptr  \/\/ BoolNode has control flow!!\n+      || _sw->my_pack(bol) == nullptr) {\n@@ -1905,1 +1905,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1909,1 +1909,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1916,2 +1916,2 @@\n-      || cmpd->in(0) != NULL  \/\/ CmpDNode has control flow!!\n-      || _sw->my_pack(cmpd) == NULL) {\n+      || cmpd->in(0) != nullptr  \/\/ CmpDNode has control flow!!\n+      || _sw->my_pack(cmpd) == nullptr) {\n@@ -1919,1 +1919,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1923,1 +1923,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1928,1 +1928,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1964,2 +1964,2 @@\n-  if (  (in1_pk != NULL && in1_pk->size() != cmpd_pk->size())\n-     || (in2_pk != NULL && in2_pk->size() != cmpd_pk->size()) ) {\n+  if (  (in1_pk != nullptr && in1_pk->size() != cmpd_pk->size())\n+     || (in2_pk != nullptr && in2_pk->size() != cmpd_pk->size()) ) {\n@@ -1970,1 +1970,1 @@\n-  if (in1_pk == NULL) {\n+  if (in1_pk == nullptr) {\n@@ -1978,1 +1978,1 @@\n-  if (in2_pk == NULL) {\n+  if (in2_pk == nullptr) {\n@@ -2015,1 +2015,1 @@\n-  if (p0 != NULL) {\n+  if (p0 != nullptr) {\n@@ -2040,1 +2040,1 @@\n-  return _cmovev_kit.pack(p->at(0)) != NULL;\n+  return _cmovev_kit.pack(p->at(0)) != nullptr;\n@@ -2079,1 +2079,1 @@\n-    if ((second_pk == NULL) || (_num_work_vecs == _num_reductions)) {\n+    if ((second_pk == nullptr) || (_num_work_vecs == _num_reductions)) {\n@@ -2093,1 +2093,1 @@\n-    if (cnt_pk != NULL)\n+    if (cnt_pk != nullptr)\n@@ -2242,1 +2242,1 @@\n-              if (mem_pk != NULL) {\n+              if (mem_pk != nullptr) {\n@@ -2451,1 +2451,1 @@\n-      Node* vn = NULL;\n+      Node* vn = nullptr;\n@@ -2463,1 +2463,1 @@\n-        SWPointer p1(n->as_Mem(), this, NULL, false);\n+        SWPointer p1(n->as_Mem(), this, nullptr, false);\n@@ -2469,1 +2469,1 @@\n-          SWPointer p2(mem->as_Mem(), this, NULL, false);\n+          SWPointer p2(mem->as_Mem(), this, nullptr, false);\n@@ -2484,1 +2484,1 @@\n-        if (val == NULL) {\n+        if (val == nullptr) {\n@@ -2486,1 +2486,1 @@\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: val should not be NULL, exiting SuperWord\");})\n+            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: val should not be null, exiting SuperWord\");})\n@@ -2521,1 +2521,1 @@\n-        Node* in1 = NULL;\n+        Node* in1 = nullptr;\n@@ -2528,1 +2528,1 @@\n-          if (in1 == NULL) {\n+          if (in1 == nullptr) {\n@@ -2530,1 +2530,1 @@\n-              NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: in1 should not be NULL, exiting SuperWord\");})\n+              NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: in1 should not be null, exiting SuperWord\");})\n@@ -2537,1 +2537,1 @@\n-        if (in2 == NULL) {\n+        if (in2 == nullptr) {\n@@ -2539,1 +2539,1 @@\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: in2 should not be NULL, exiting SuperWord\");})\n+            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: in2 should not be null, exiting SuperWord\");})\n@@ -2552,1 +2552,1 @@\n-          vn = ReductionNode::make(opc, NULL, in1, in2, arith_type->basic_type());\n+          vn = ReductionNode::make(opc, nullptr, in1, in2, arith_type->basic_type());\n@@ -2569,1 +2569,1 @@\n-        vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));\n+        vn = VectorNode::make(opc, in, nullptr, vlen, velt_basic_type(n));\n@@ -2604,1 +2604,1 @@\n-        if (src1 == NULL) {\n+        if (src1 == nullptr) {\n@@ -2606,1 +2606,1 @@\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: src1 should not be NULL, exiting SuperWord\");})\n+            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: src1 should not be null, exiting SuperWord\");})\n@@ -2612,1 +2612,1 @@\n-        if (src2 == NULL) {\n+        if (src2 == nullptr) {\n@@ -2614,1 +2614,1 @@\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: src2 should not be NULL, exiting SuperWord\");})\n+            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: src2 should not be null, exiting SuperWord\");})\n@@ -2644,2 +2644,2 @@\n-      assert(vn != NULL, \"sanity\");\n-      if (vn == NULL) {\n+      assert(vn != nullptr, \"sanity\");\n+      if (vn == nullptr) {\n@@ -2647,1 +2647,1 @@\n-          NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: got NULL node, cannot proceed, exiting SuperWord\");})\n+          NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: got null node, cannot proceed, exiting SuperWord\");})\n@@ -2760,1 +2760,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2770,1 +2770,1 @@\n-      if (t != NULL && t->is_con()) {\n+      if (t != nullptr && t->is_con()) {\n@@ -2776,1 +2776,1 @@\n-        if (t == NULL || t->_lo < 0 || t->_hi > (int)mask) {\n+        if (t == nullptr || t->_lo < 0 || t->_hi > (int)mask) {\n@@ -2786,1 +2786,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2798,1 +2798,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2803,2 +2803,2 @@\n-    const Type* p0_t = NULL;\n-    VectorNode* vn = NULL;\n+    const Type* p0_t = nullptr;\n+    VectorNode* vn = nullptr;\n@@ -2839,2 +2839,2 @@\n-    assert(my_pack(in) == NULL, \"Should already have been unpacked\");\n-    if (my_pack(in) != NULL) {\n+    assert(my_pack(in) == nullptr, \"Should already have been unpacked\");\n+    if (my_pack(in) != nullptr) {\n@@ -2842,1 +2842,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2848,2 +2848,2 @@\n-      assert(my_pack(in2) == NULL, \"Should already have been unpacked\");\n-      if (my_pack(in2) != NULL) {\n+      assert(my_pack(in2) == nullptr, \"Should already have been unpacked\");\n+      if (my_pack(in2) != nullptr) {\n@@ -2851,1 +2851,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2886,1 +2886,1 @@\n-          if ((u_pk == NULL || !is_cmov_pack(u_pk) || use->is_CMove()) && !is_vector_use(use, k)) {\n+          if ((u_pk == nullptr || !is_cmov_pack(u_pk) || use->is_CMove()) && !is_vector_use(use, k)) {\n@@ -2921,1 +2921,1 @@\n-  if (u_pk == NULL) return false;\n+  if (u_pk == nullptr) return false;\n@@ -2925,1 +2925,1 @@\n-  if (d_pk == NULL) {\n+  if (d_pk == nullptr) {\n@@ -3271,1 +3271,1 @@\n-  SWPointer p(s, this, NULL, false);\n+  SWPointer p(s, this, nullptr, false);\n@@ -3352,1 +3352,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3361,1 +3361,1 @@\n-    set_my_pack(s, NULL);\n+    set_my_pack(s, nullptr);\n@@ -3458,1 +3458,1 @@\n-  assert(orig_limit != NULL && _igvn.type(orig_limit) != Type::TOP, \"\");\n+  assert(orig_limit != nullptr && _igvn.type(orig_limit) != Type::TOP, \"\");\n@@ -3460,1 +3460,1 @@\n-  SWPointer align_to_ref_p(align_to_ref, this, NULL, false);\n+  SWPointer align_to_ref_p(align_to_ref, this, nullptr, false);\n@@ -3524,1 +3524,1 @@\n-  if (align_to_ref_p.invar() != NULL) {\n+  if (align_to_ref_p.invar() != nullptr) {\n@@ -3536,1 +3536,1 @@\n-    if (invar_scale != NULL) {\n+    if (invar_scale != nullptr) {\n@@ -3553,1 +3553,1 @@\n-    Node* xbase = new CastP2XNode(NULL, align_to_ref_p.adr());\n+    Node* xbase = new CastP2XNode(nullptr, align_to_ref_p.adr());\n@@ -3616,2 +3616,2 @@\n-  if (cl->is_canonical_loop_entry() == NULL) {\n-    return NULL;\n+  if (cl->is_canonical_loop_entry() == nullptr) {\n+    return nullptr;\n@@ -3621,2 +3621,2 @@\n-  if (!p_f->is_IfFalse()) return NULL;\n-  if (!p_f->in(0)->is_CountedLoopEnd()) return NULL;\n+  if (!p_f->is_IfFalse()) return nullptr;\n+  if (!p_f->in(0)->is_CountedLoopEnd()) return nullptr;\n@@ -3625,1 +3625,1 @@\n-  if (loop_node == NULL || !loop_node->is_pre_loop()) return NULL;\n+  if (loop_node == nullptr || !loop_node->is_pre_loop()) return nullptr;\n@@ -3642,5 +3642,5 @@\n-  _align_to_ref = NULL;\n-  _lpt = NULL;\n-  _lp = NULL;\n-  _bb = NULL;\n-  _iv = NULL;\n+  _align_to_ref = nullptr;\n+  _lpt = nullptr;\n+  _lp = nullptr;\n+  _bb = nullptr;\n+  _iv = nullptr;\n@@ -3723,3 +3723,3 @@\n-  _mem(mem), _slp(slp),  _base(NULL),  _adr(NULL),\n-  _scale(0), _offset(0), _invar(NULL), _negate_invar(false),\n-  _invar_scale(NULL),\n+  _mem(mem), _slp(slp),  _base(nullptr),  _adr(nullptr),\n+  _scale(0), _offset(0), _invar(nullptr), _negate_invar(false),\n+  _invar_scale(nullptr),\n@@ -3792,3 +3792,3 @@\n-  _mem(p->_mem), _slp(p->_slp),  _base(NULL),  _adr(NULL),\n-  _scale(0), _offset(0), _invar(NULL), _negate_invar(false),\n-  _invar_scale(NULL),\n+  _mem(p->_mem), _slp(p->_slp),  _base(nullptr),  _adr(nullptr),\n+  _scale(0), _offset(0), _invar(nullptr), _negate_invar(false),\n+  _invar_scale(nullptr),\n@@ -3908,1 +3908,1 @@\n-    if (!has_iv() && _invar == NULL) {\n+    if (!has_iv() && _invar == nullptr) {\n@@ -3921,1 +3921,1 @@\n-        if (_invar != NULL) {\n+        if (_invar != nullptr) {\n@@ -3959,1 +3959,1 @@\n-  if (_invar != NULL) { \/\/ already has an invariant\n+  if (_invar != nullptr) { \/\/ already has an invariant\n@@ -4025,2 +4025,2 @@\n-             _base != NULL ? _base->_idx : 0,\n-             _adr  != NULL ? _adr->_idx  : 0,\n+             _base != nullptr ? _base->_idx : 0,\n+             _adr  != nullptr ? _adr->_idx  : 0,\n@@ -4028,1 +4028,1 @@\n-  if (_invar != NULL) {\n+  if (_invar != nullptr) {\n@@ -4224,1 +4224,1 @@\n-    if (invar != NULL) {\n+    if (invar != nullptr) {\n@@ -4230,1 +4230,1 @@\n-    if (invar != NULL) {\n+    if (invar != nullptr) {\n@@ -4271,1 +4271,1 @@\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: _invar != NULL: \", _invar->_idx); _invar->dump();\n+    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: _invar is not null: \", _invar->_idx); _invar->dump();\n@@ -4339,2 +4339,2 @@\n-  if (node != NULL) {\n-    assert(_map.at_grow(node->_idx) == NULL, \"one init only\");\n+  if (node != nullptr) {\n+    assert(_map.at_grow(node->_idx) == nullptr, \"one init only\");\n@@ -4360,1 +4360,1 @@\n-  for (DepEdge* e = _in_head; e != NULL; e = e->next_in()) ct++;\n+  for (DepEdge* e = _in_head; e != nullptr; e = e->next_in()) ct++;\n@@ -4367,1 +4367,1 @@\n-  for (DepEdge* e = _out_head; e != NULL; e = e->next_out()) ct++;\n+  for (DepEdge* e = _out_head; e != nullptr; e = e->next_out()) ct++;\n@@ -4375,1 +4375,1 @@\n-  for (DepEdge* p = _in_head; p != NULL; p = p->next_in()) {\n+  for (DepEdge* p = _in_head; p != nullptr; p = p->next_in()) {\n@@ -4377,1 +4377,1 @@\n-    tty->print(\" %d\", pred != NULL ? pred->_idx : 0);\n+    tty->print(\" %d\", pred != nullptr ? pred->_idx : 0);\n@@ -4380,1 +4380,1 @@\n-  for (DepEdge* s = _out_head; s != NULL; s = s->next_out()) {\n+  for (DepEdge* s = _out_head; s != nullptr; s = s->next_out()) {\n@@ -4382,1 +4382,1 @@\n-    tty->print(\" %d\", succ != NULL ? succ->_idx : 0);\n+    tty->print(\" %d\", succ != nullptr ? succ->_idx : 0);\n@@ -4415,1 +4415,1 @@\n-    _dep_next = NULL;\n+    _dep_next = nullptr;\n@@ -4422,1 +4422,1 @@\n-  if (_dep_next != NULL) {\n+  if (_dep_next != nullptr) {\n@@ -4450,1 +4450,1 @@\n-    _dep_next = NULL;\n+    _dep_next = nullptr;\n@@ -4457,1 +4457,1 @@\n-  if (_dep_next != NULL) {\n+  if (_dep_next != nullptr) {\n@@ -4471,1 +4471,1 @@\n-  return a != NULL && b != NULL && _clone_map.same_idx(a->_idx, b->_idx);\n+  return a != nullptr && b != nullptr && _clone_map.same_idx(a->_idx, b->_idx);\n@@ -4474,1 +4474,1 @@\n-  return a != NULL && b != NULL && _clone_map.same_gen(a->_idx, b->_idx);\n+  return a != nullptr && b != nullptr && _clone_map.same_gen(a->_idx, b->_idx);\n@@ -4486,1 +4486,1 @@\n-    return NULL; \/\/we think that any ld in the first gen being vectorizable\n+    return nullptr; \/\/we think that any ld in the first gen being vectorizable\n@@ -4500,1 +4500,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4509,1 +4509,1 @@\n-    return NULL; \/\/ does not depend on loop volatile node or depends on the same generation\n+    return nullptr; \/\/ does not depend on loop volatile node or depends on the same generation\n@@ -4524,1 +4524,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4542,1 +4542,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4589,1 +4589,1 @@\n-  Node *ii_err = NULL, *tail_err = NULL;\n+  Node *ii_err = nullptr, *tail_err = nullptr;\n@@ -4852,1 +4852,1 @@\n-    if (phi != NULL) {\n+    if (phi != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":199,"deletions":199,"binary":false,"changes":398,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  DepMem(Node* node) : _node(node), _in_head(NULL), _out_head(NULL) {}\n+  DepMem(Node* node) : _node(node), _in_head(nullptr), _out_head(nullptr) {}\n@@ -125,3 +125,3 @@\n-  DepGraph(Arena* a) : _arena(a), _map(a, 8,  0, NULL) {\n-    _root = new (_arena) DepMem(NULL);\n-    _tail = new (_arena) DepMem(NULL);\n+  DepGraph(Arena* a) : _arena(a), _map(a, 8,  0, nullptr) {\n+    _root = new (_arena) DepMem(nullptr);\n+    _tail = new (_arena) DepMem(nullptr);\n@@ -200,1 +200,1 @@\n-  SWNodeInfo() : _alignment(-1), _depth(0), _velt_type(NULL), _my_pack(NULL) {}\n+  SWNodeInfo() : _alignment(-1), _depth(0), _velt_type(nullptr), _my_pack(nullptr) {}\n@@ -213,1 +213,1 @@\n-  void map(Node* key, Node_List* val)    { assert(_dict->operator[](_2p(key)) == NULL, \"key existed\"); _dict->Insert(_2p(key), (void*)val); }\n+  void map(Node* key, Node_List* val)    { assert(_dict->operator[](_2p(key)) == nullptr, \"key existed\"); _dict->Insert(_2p(key), (void*)val); }\n@@ -217,1 +217,1 @@\n-  Node* is_CmpD_candidate(Node* nd) const; \/\/ otherwise return NULL\n+  Node* is_CmpD_candidate(Node* nd) const; \/\/ otherwise return nullptr\n@@ -230,1 +230,1 @@\n-  OrderedPair() : _p1(NULL), _p2(NULL) {}\n+  OrderedPair() : _p1(nullptr), _p2(nullptr) {}\n@@ -344,1 +344,1 @@\n-    assert(_pre_loop_end != NULL && _pre_loop_end->loopnode() != NULL, \"should find head from pre loop end\");\n+    assert(_pre_loop_end != nullptr && _pre_loop_end->loopnode() != nullptr, \"should find head from pre loop end\");\n@@ -353,2 +353,2 @@\n-    assert(_lp != NULL, \"sanity\");\n-    assert(_pre_loop_end != NULL, \"should be set when fetched\");\n+    assert(_lp != nullptr, \"sanity\");\n+    assert(_pre_loop_end != nullptr, \"should be set when fetched\");\n@@ -377,1 +377,1 @@\n-  bool in_bb(Node* n)      { return n != NULL && n->outcnt() > 0 && ctrl(n) == _bb; }\n+  bool in_bb(Node* n)      { return n != nullptr && n->outcnt() > 0 && ctrl(n) == _bb; }\n@@ -411,1 +411,1 @@\n-  Node_List* my_pack(Node* n)                 { return !in_bb(n) ? NULL : _node_info.adr_at(bb_idx(n))->_my_pack; }\n+  Node_List* my_pack(Node* n)                 { return !in_bb(n) ? nullptr : _node_info.adr_at(bb_idx(n))->_my_pack; }\n@@ -580,1 +580,1 @@\n-  Node* _base;               \/\/ NULL if unsafe nonheap reference\n+  Node* _base;               \/\/ null if unsafe nonheap reference\n@@ -585,1 +585,1 @@\n-  Node* _invar;              \/\/ invariant offset (in bytes), NULL if none\n+  Node* _invar;              \/\/ invariant offset (in bytes), null if none\n@@ -621,1 +621,1 @@\n-  bool valid()  { return _adr != NULL; }\n+  bool valid()  { return _adr != nullptr; }\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-Dict* Type::_shared_type_dict = NULL;\n+Dict* Type::_shared_type_dict = nullptr;\n@@ -136,2 +136,2 @@\n-  if (type == NULL) {\n-    return NULL;\n+  if (type == nullptr) {\n+    return nullptr;\n@@ -161,1 +161,1 @@\n-\/\/ Otherwise or if the arrays have different dimensions, return NULL.\n+\/\/ Otherwise or if the arrays have different dimensions, return null.\n@@ -165,4 +165,4 @@\n-  if (e1) *e1 = NULL;\n-  if (e2) *e2 = NULL;\n-  const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1->isa_aryptr();\n-  const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2->isa_aryptr();\n+  if (e1) *e1 = nullptr;\n+  if (e2) *e2 = nullptr;\n+  const TypeAryPtr* a1tap = (a1 == nullptr) ? nullptr : a1->isa_aryptr();\n+  const TypeAryPtr* a2tap = (a2 == nullptr) ? nullptr : a2->isa_aryptr();\n@@ -170,1 +170,1 @@\n-  if (a1tap != NULL && a2tap != NULL) {\n+  if (a1tap != nullptr && a2tap != nullptr) {\n@@ -200,1 +200,1 @@\n-  case ciTypeFlow::StateVector::T_NULL:\n+  case ciTypeFlow::StateVector::T_nullptr:\n@@ -249,1 +249,1 @@\n-        const Type* con_type = NULL;\n+        const Type* con_type = nullptr;\n@@ -273,1 +273,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -276,1 +276,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -315,1 +315,1 @@\n-    return NULL; \/\/ wrong offset\n+    return nullptr; \/\/ wrong offset\n@@ -327,1 +327,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -333,1 +333,1 @@\n-  if (type != NULL && type->is_instance_klass() && off >= InstanceMirrorKlass::offset_of_static_fields()) {\n+  if (type != nullptr && type->is_instance_klass() && off >= InstanceMirrorKlass::offset_of_static_fields()) {\n@@ -340,2 +340,2 @@\n-  if (field == NULL) {\n-    return NULL; \/\/ Wrong offset\n+  if (field == nullptr) {\n+    return nullptr; \/\/ Wrong offset\n@@ -349,1 +349,1 @@\n-    return NULL; \/\/ Non-constant field\n+    return nullptr; \/\/ Non-constant field\n@@ -355,1 +355,1 @@\n-  } else if (holder != NULL) {\n+  } else if (holder != nullptr) {\n@@ -363,1 +363,1 @@\n-    return NULL; \/\/ Not a constant\n+    return nullptr; \/\/ Not a constant\n@@ -378,1 +378,1 @@\n-  if (con_type != NULL && field->is_call_site_target()) {\n+  if (con_type != nullptr && field->is_call_site_target()) {\n@@ -550,1 +550,1 @@\n-  TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);\n+  TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, nullptr, OffsetBot);\n@@ -567,1 +567,1 @@\n-  TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL \/* current->env()->Object_klass() *\/, false, arrayOopDesc::length_offset_in_bytes());\n+  TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), nullptr \/* current->env()->Object_klass() *\/, false, arrayOopDesc::length_offset_in_bytes());\n@@ -569,1 +569,1 @@\n-  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n+  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n@@ -579,1 +579,1 @@\n-    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n+    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n@@ -589,2 +589,2 @@\n-  \/\/ Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.\n-  TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;\n+  \/\/ Nobody should ask _array_body_type[T_NARROWOOP]. Use null as assert.\n+  TypeAryPtr::_array_body_type[T_NARROWOOP] = nullptr;\n@@ -662,1 +662,1 @@\n-  _zero_type[T_CONFLICT]= NULL;\n+  _zero_type[T_CONFLICT]= nullptr;\n@@ -697,1 +697,1 @@\n-  current->set_type_dict(NULL);\n+  current->set_type_dict(nullptr);\n@@ -702,1 +702,1 @@\n-  assert(current->type_arena() != NULL, \"must have created type arena\");\n+  assert(current->type_arena() != nullptr, \"must have created type arena\");\n@@ -704,1 +704,1 @@\n-  if (_shared_type_dict == NULL) {\n+  if (_shared_type_dict == nullptr) {\n@@ -786,1 +786,1 @@\n-  if( this_ptr == NULL || t_ptr == NULL )\n+  if( this_ptr == nullptr || t_ptr == nullptr )\n@@ -805,3 +805,3 @@\n-  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n-  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n-  if (this_spec != NULL && t_spec != NULL) {\n+  const TypePtr* this_spec = isa_ptr() != nullptr ? is_ptr()->speculative() : nullptr;\n+  const TypePtr* t_spec = t->isa_ptr() != nullptr ? t->is_ptr()->speculative() : nullptr;\n+  if (this_spec != nullptr && t_spec != nullptr) {\n@@ -813,1 +813,1 @@\n-  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n+  if (this_spec != nullptr && this_spec->interface_vs_oop_helper(t)) {\n@@ -816,1 +816,1 @@\n-  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n+  if (t_spec != nullptr && interface_vs_oop_helper(t_spec)) {\n@@ -1564,1 +1564,1 @@\n-  if (old == NULL)  return this;\n+  if (old == nullptr)  return this;\n@@ -1566,1 +1566,1 @@\n-  if (ot == NULL)  return this;\n+  if (ot == nullptr)  return this;\n@@ -1595,1 +1595,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -1828,1 +1828,1 @@\n-  if (old == NULL)  return this;\n+  if (old == nullptr)  return this;\n@@ -1830,1 +1830,1 @@\n-  if (ot == NULL)  return this;\n+  if (ot == nullptr)  return this;\n@@ -1859,1 +1859,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -1893,1 +1893,1 @@\n-    if (n >= x + 10000)  return NULL;\n+    if (n >= x + 10000)  return nullptr;\n@@ -1896,1 +1896,1 @@\n-    if (n <= x - 10000)  return NULL;\n+    if (n <= x - 10000)  return nullptr;\n@@ -1914,1 +1914,1 @@\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(max_juint, \"maxuint\", buf, n)) != nullptr)\n@@ -1916,1 +1916,1 @@\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(max_jint, \"maxint\", buf, n)) != nullptr)\n@@ -1918,1 +1918,1 @@\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(min_jint, \"minint\", buf, n)) != nullptr)\n@@ -2008,1 +2008,1 @@\n-  if (recv != NULL) {\n+  if (recv != nullptr) {\n@@ -2272,1 +2272,1 @@\n-    if(this_ptr != NULL && t_ptr != NULL) {\n+    if(this_ptr != nullptr && t_ptr != nullptr) {\n@@ -2310,1 +2310,1 @@\n-  const TypeOopPtr*  toop = NULL;\n+  const TypeOopPtr*  toop = nullptr;\n@@ -2318,1 +2318,1 @@\n-  if (tklass == NULL)       return false;  \/\/ unloaded class\n+  if (tklass == nullptr)       return false;  \/\/ unloaded class\n@@ -2339,7 +2339,7 @@\n-const TypeVect *TypeVect::VECTA = NULL; \/\/ vector length agnostic\n-const TypeVect *TypeVect::VECTS = NULL; \/\/  32-bit vectors\n-const TypeVect *TypeVect::VECTD = NULL; \/\/  64-bit vectors\n-const TypeVect *TypeVect::VECTX = NULL; \/\/ 128-bit vectors\n-const TypeVect *TypeVect::VECTY = NULL; \/\/ 256-bit vectors\n-const TypeVect *TypeVect::VECTZ = NULL; \/\/ 512-bit vectors\n-const TypeVect *TypeVect::VECTMASK = NULL; \/\/ predicate\/mask vector\n+const TypeVect *TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n+const TypeVect *TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n+const TypeVect *TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n+const TypeVect *TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n+const TypeVect *TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n+const TypeVect *TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n+const TypeVect *TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n@@ -2370,1 +2370,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2530,1 +2530,1 @@\n-  if (res->isa_ptr() == NULL) {\n+  if (res->isa_ptr() == nullptr) {\n@@ -2535,2 +2535,2 @@\n-  if (res_ptr->speculative() != NULL) {\n-    \/\/ type->speculative() == NULL means that speculation is no better\n+  if (res_ptr->speculative() != nullptr) {\n+    \/\/ type->speculative() is null means that speculation is no better\n@@ -2541,1 +2541,1 @@\n-    \/\/ type and set speculative to NULL if it is the case.\n+    \/\/ type and set speculative to null if it is the case.\n@@ -2656,1 +2656,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -2660,1 +2660,1 @@\n-  return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);\n+  return make(AnyPtr, _ptr, _offset, nullptr, _inline_depth);\n@@ -2668,1 +2668,1 @@\n-  if (speculative() == NULL) {\n+  if (speculative() == nullptr) {\n@@ -2685,1 +2685,1 @@\n-      (spec_oopptr == NULL || !spec_oopptr->klass_is_exact())) {\n+      (spec_oopptr == nullptr || !spec_oopptr->klass_is_exact())) {\n@@ -2695,2 +2695,2 @@\n-  if (_speculative == NULL) {\n-    return NULL;\n+  if (_speculative == nullptr) {\n+    return nullptr;\n@@ -2707,2 +2707,2 @@\n-  bool this_has_spec = (_speculative != NULL);\n-  bool other_has_spec = (other->speculative() != NULL);\n+  bool this_has_spec = (_speculative != nullptr);\n+  bool other_has_spec = (other->speculative() != nullptr);\n@@ -2711,1 +2711,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2756,1 +2756,1 @@\n-  if (_speculative == NULL || other->speculative() == NULL) {\n+  if (_speculative == nullptr || other->speculative() == nullptr) {\n@@ -2771,1 +2771,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -2784,2 +2784,2 @@\n-  if (_speculative == NULL) {\n-    return NULL;\n+  if (_speculative == nullptr) {\n+    return nullptr;\n@@ -2794,1 +2794,1 @@\n-  if (_speculative != NULL && _speculative->isa_oopptr()) {\n+  if (_speculative != nullptr && _speculative->isa_oopptr()) {\n@@ -2800,1 +2800,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2807,1 +2807,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -2815,1 +2815,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -2828,1 +2828,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2843,1 +2843,1 @@\n-  if (exact_kls == NULL) {\n+  if (exact_kls == nullptr) {\n@@ -2850,1 +2850,1 @@\n-  if (speculative_type() == NULL) {\n+  if (speculative_type() == nullptr) {\n@@ -2893,1 +2893,1 @@\n-  if (ptr_kind == ProfileAlwaysNull && speculative() != NULL && speculative()->isa_oopptr()) {\n+  if (ptr_kind == ProfileAlwaysNull && speculative() != nullptr && speculative()->isa_oopptr()) {\n@@ -2901,1 +2901,1 @@\n-  \"TopPTR\",\"AnyNull\",\"Constant\",\"NULL\",\"NotNull\",\"BotPTR\"\n+  \"TopPTR\",\"AnyNull\",\"Constant\",\"null\",\"NotNull\",\"BotPTR\"\n@@ -2906,1 +2906,1 @@\n-  if( _ptr == Null ) st->print(\"NULL\");\n+  if( _ptr == Null ) st->print(\"null\");\n@@ -2919,1 +2919,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -2960,1 +2960,1 @@\n-  assert( ptr != Null, \"Use TypePtr for NULL\" );\n+  assert( ptr != Null, \"Use TypePtr for nullptr\" );\n@@ -2965,1 +2965,1 @@\n-  assert( bits, \"Use TypePtr for NULL\" );\n+  assert( bits, \"Use TypePtr for nullptr\" );\n@@ -2972,1 +2972,1 @@\n-  assert( ptr != Null, \"Use TypePtr for NULL\" );\n+  assert( ptr != Null, \"Use TypePtr for nullptr\" );\n@@ -3060,1 +3060,1 @@\n-  return NULL;                  \/\/ Lint noise\n+  return nullptr;                  \/\/ Lint noise\n@@ -3108,1 +3108,1 @@\n-    } else if (klass() == NULL) {\n+    } else if (klass() == nullptr) {\n@@ -3117,1 +3117,1 @@\n-      ciField* field = NULL;\n+      ciField* field = nullptr;\n@@ -3135,2 +3135,2 @@\n-          ciField* field = NULL;\n-          if (const_oop() != NULL) {\n+          ciField* field = nullptr;\n+          if (const_oop() != nullptr) {\n@@ -3140,1 +3140,1 @@\n-          if (field != NULL) {\n+          if (field != nullptr) {\n@@ -3150,1 +3150,1 @@\n-          if (field != NULL) {\n+          if (field != nullptr) {\n@@ -3174,1 +3174,1 @@\n-  ciObject* o = NULL;\n+  ciObject* o = nullptr;\n@@ -3207,1 +3207,1 @@\n-  if (k == NULL)\n+  if (k == nullptr)\n@@ -3289,1 +3289,1 @@\n-  assert(const_oop() == NULL,             \"no constants here\");\n+  assert(const_oop() == nullptr,             \"no constants here\");\n@@ -3299,1 +3299,1 @@\n-    assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+    assert((deps != nullptr) == (C->method() != nullptr && C->method()->code_size() > 0), \"sanity\");\n@@ -3307,1 +3307,1 @@\n-          && deps != NULL && UseUniqueSubclasses) {\n+          && deps != nullptr && UseUniqueSubclasses) {\n@@ -3309,1 +3309,1 @@\n-        if (sub != NULL) {\n+        if (sub != nullptr) {\n@@ -3315,1 +3315,1 @@\n-      if (!klass_is_exact && try_for_exact && deps != NULL &&\n+      if (!klass_is_exact && try_for_exact && deps != nullptr &&\n@@ -3322,1 +3322,1 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, nullptr, 0);\n@@ -3330,1 +3330,1 @@\n-    \/\/ slam NULLs down in the subarrays.\n+    \/\/ slam nullptrs down in the subarrays.\n@@ -3343,1 +3343,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3360,1 +3360,1 @@\n-      return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);\n+      return TypeInstPtr::make(TypePtr::NotNull, klass, true, nullptr, 0);\n@@ -3369,1 +3369,1 @@\n-    \/\/ slam NULLs down in the subarrays.\n+    \/\/ slam nulls down in the subarrays.\n@@ -3390,1 +3390,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3433,1 +3433,1 @@\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n+      if (ktip != nullptr && ktip->is_loaded() && ktip->klass()->is_interface()) {\n@@ -3438,2 +3438,2 @@\n-      Type::get_arrays_base_elements(ft, kills, NULL, &ktip);\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n+      Type::get_arrays_base_elements(ft, kills, nullptr, &ktip);\n+      if (ktip != nullptr && ktip->is_loaded() && ktip->klass()->is_interface()) {\n@@ -3452,1 +3452,1 @@\n-  if (ftip != NULL && ktip != NULL &&\n+  if (ftip != nullptr && ktip != nullptr &&\n@@ -3470,1 +3470,1 @@\n-  if (one == NULL || two == NULL) {\n+  if (one == nullptr || two == nullptr) {\n@@ -3525,1 +3525,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -3529,1 +3529,1 @@\n-  return make(_ptr, _offset, _instance_id, NULL, _inline_depth);\n+  return make(_ptr, _offset, _instance_id, nullptr, _inline_depth);\n@@ -3609,2 +3609,2 @@\n-   assert(k != NULL &&\n-          (k->is_loaded() || o == NULL),\n+   assert(k != nullptr &&\n+          (k->is_loaded() || o == nullptr),\n@@ -3624,1 +3624,1 @@\n-  \/\/ Either const_oop() is NULL or else ptr is Constant\n+  \/\/ Either const_oop() is null or else ptr is Constant\n@@ -3628,1 +3628,1 @@\n-  assert( ptr != Null, \"NULL pointers are not typed\" );\n+  assert( ptr != Null, \"null pointers are not typed\" );\n@@ -3652,1 +3652,1 @@\n-  assert((const_oop() != NULL), \"should be called only for constant object\");\n+  assert((const_oop() != nullptr), \"should be called only for constant object\");\n@@ -3667,1 +3667,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3724,1 +3724,1 @@\n-      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n+      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, nullptr, off, instance_id, speculative, depth); }\n@@ -3792,1 +3792,1 @@\n-                  (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : nullptr), offset, instance_id, speculative, depth);\n@@ -3820,1 +3820,1 @@\n-                  (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : nullptr), offset, instance_id, speculative, depth);\n@@ -3859,1 +3859,1 @@\n-      return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);\n+      return make(ptr, klass(), klass_is_exact(), nullptr, off, instance_id, speculative, depth);\n@@ -3922,1 +3922,1 @@\n-      ciObject* o = NULL;  \/\/ the Constant value, if any\n+      ciObject* o = nullptr;  \/\/ the Constant value, if any\n@@ -3957,1 +3957,1 @@\n-    ciKlass *subtype = NULL;\n+    ciKlass *subtype = nullptr;\n@@ -3988,1 +3988,1 @@\n-      \/\/ NotNull if they do (neither constant is NULL; that is a special case\n+      \/\/ NotNull if they do (neither constant is nullptr; that is a special case\n@@ -3990,1 +3990,1 @@\n-      ciObject* o = NULL;             \/\/ Assume not constant when done\n+      ciObject* o = nullptr;             \/\/ Assume not constant when done\n@@ -3994,1 +3994,1 @@\n-        if (this_oop != NULL && tinst_oop != NULL &&\n+        if (this_oop != nullptr && tinst_oop != nullptr &&\n@@ -4016,1 +4016,1 @@\n-    return make(ptr, k, false, NULL, off, instance_id, speculative, depth);\n+    return make(ptr, k, false, nullptr, off, instance_id, speculative, depth);\n@@ -4027,1 +4027,1 @@\n-  if( const_oop() == NULL )  return NULL;\n+  if( const_oop() == nullptr )  return nullptr;\n@@ -4030,1 +4030,1 @@\n-  if( klass() != ciEnv::current()->Class_klass() )  return NULL;\n+  if( klass() != ciEnv::current()->Class_klass() )  return nullptr;\n@@ -4119,1 +4119,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -4124,1 +4124,1 @@\n-              _instance_id, NULL, _inline_depth);\n+              _instance_id, nullptr, _inline_depth);\n@@ -4155,1 +4155,1 @@\n-  assert(!(k == NULL && ary->_elem->isa_int()),\n+  assert(!(k == nullptr && ary->_elem->isa_int()),\n@@ -4159,1 +4159,1 @@\n-  return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))->hashcons();\n+  return (TypeAryPtr*)(new TypeAryPtr(ptr, nullptr, ary, k, xk, offset, instance_id, false, speculative, inline_depth))->hashcons();\n@@ -4166,1 +4166,1 @@\n-  assert(!(k == NULL && ary->_elem->isa_int()),\n+  assert(!(k == nullptr && ary->_elem->isa_int()),\n@@ -4169,1 +4169,1 @@\n-  if (!xk)  xk = (o != NULL) || ary->ary_must_be_exact();\n+  if (!xk)  xk = (o != nullptr) || ary->ary_must_be_exact();\n@@ -4212,1 +4212,1 @@\n-\/\/ Return NULL if the resulting int type becomes empty.\n+\/\/ Return null if the resulting int type becomes empty.\n@@ -4244,1 +4244,1 @@\n-  assert(new_size != NULL, \"\");\n+  assert(new_size != nullptr, \"\");\n@@ -4259,1 +4259,1 @@\n-  if (stable_dimension > 1 && elem_ptr != NULL && elem_ptr->isa_aryptr()) {\n+  if (stable_dimension > 1 && elem_ptr != nullptr && elem_ptr->isa_aryptr()) {\n@@ -4274,1 +4274,1 @@\n-  if (elem_ptr != NULL && elem_ptr->isa_aryptr())\n+  if (elem_ptr != nullptr && elem_ptr->isa_aryptr())\n@@ -4283,1 +4283,1 @@\n-  if (etype == NULL)  return this;\n+  if (etype == nullptr)  return this;\n@@ -4343,1 +4343,1 @@\n-      return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+      return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -4373,1 +4373,1 @@\n-      return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+      return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -4392,1 +4392,1 @@\n-    ciKlass* lazy_klass = NULL;\n+    ciKlass* lazy_klass = nullptr;\n@@ -4396,1 +4396,1 @@\n-      if (_klass == NULL)\n+      if (_klass == nullptr)\n@@ -4398,1 +4398,1 @@\n-      else if (tap->_klass == NULL || tap->_klass == _klass) {\n+      else if (tap->_klass == nullptr || tap->_klass == _klass) {\n@@ -4411,1 +4411,1 @@\n-          tap->_klass != NULL  && this->_klass != NULL   &&\n+          tap->_klass != nullptr  && this->_klass != nullptr   &&\n@@ -4421,1 +4421,1 @@\n-      return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);\n+      return make(NotNull, nullptr, tary, lazy_klass, false, off, InstanceBot, speculative, depth);\n@@ -4438,1 +4438,1 @@\n-        if( tap->const_oop() != NULL && !o->equals(tap->const_oop()) ) {\n+        if( tap->const_oop() != nullptr && !o->equals(tap->const_oop()) ) {\n@@ -4441,1 +4441,1 @@\n-          o = NULL;\n+          o = nullptr;\n@@ -4464,1 +4464,1 @@\n-      return make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n+      return make(ptr, nullptr, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n@@ -4489,1 +4489,1 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, nullptr,offset, instance_id, speculative, depth);\n@@ -4503,1 +4503,1 @@\n-          return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+          return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -4515,1 +4515,1 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, nullptr, offset, instance_id, speculative, depth);\n@@ -4597,1 +4597,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -4601,1 +4601,1 @@\n-  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);\n+  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _instance_id, nullptr, _inline_depth);\n@@ -4638,1 +4638,1 @@\n-  if (tc != NULL) {\n+  if (tc != nullptr) {\n@@ -4769,1 +4769,1 @@\n-  if (one == NULL || two == NULL) {\n+  if (one == nullptr || two == nullptr) {\n@@ -4802,1 +4802,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -4903,1 +4903,1 @@\n-    return make(ptr, NULL, offset);\n+    return make(ptr, nullptr, offset);\n@@ -4950,1 +4950,1 @@\n-  assert(m == NULL || !m->is_klass(), \"wrong type\");\n+  assert(m == nullptr || !m->is_klass(), \"wrong type\");\n@@ -4970,1 +4970,1 @@\n-  assert( k != NULL, \"Expect a non-NULL klass\");\n+  assert( k != nullptr, \"Expect a non-NULL klass\");\n@@ -5011,1 +5011,1 @@\n-    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n+    if (!empty() && ktkp != nullptr && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n@@ -5019,1 +5019,1 @@\n-  if (ftkp != NULL && ktkp != NULL &&\n+  if (ftkp != nullptr && ktkp != nullptr &&\n@@ -5033,1 +5033,1 @@\n-  ciKlass* k_ary = NULL;\n+  ciKlass* k_ary = nullptr;\n@@ -5042,1 +5042,1 @@\n-  if ((tinst = el->isa_instptr()) != NULL) {\n+  if ((tinst = el->isa_instptr()) != nullptr) {\n@@ -5045,1 +5045,1 @@\n-  } else if ((tary = el->isa_aryptr()) != NULL) {\n+  } else if ((tary = el->isa_aryptr()) != nullptr) {\n@@ -5049,1 +5049,1 @@\n-    if (k_elem != NULL)\n+    if (k_elem != nullptr)\n@@ -5055,1 +5055,1 @@\n-    \/\/ Leave k_ary at NULL.\n+    \/\/ Leave k_ary at nullptr.\n@@ -5108,1 +5108,1 @@\n-    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n+    if (UseCompressedOops && k_ary != nullptr && k_ary->is_obj_array_klass() &&\n@@ -5144,1 +5144,1 @@\n-  \/\/return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);\n+  \/\/return TypeInstPtr::make(TypePtr::NotNull, k, xk, nullptr, 0);\n@@ -5146,1 +5146,1 @@\n-  guarantee(toop != NULL, \"need type for given klass\");\n+  guarantee(toop != nullptr, \"need type for given klass\");\n@@ -5256,1 +5256,1 @@\n-      \/\/ NotNull if they do (neither constant is NULL; that is a special case\n+      \/\/ NotNull if they do (neither constant is nullptr; that is a special case\n@@ -5358,1 +5358,1 @@\n-  if (tf != NULL)  return tf;  \/\/ The hit rate here is almost 50%.\n+  if (tf != nullptr)  return tf;  \/\/ The hit rate here is almost 50%.\n@@ -5361,1 +5361,1 @@\n-    domain = TypeTuple::make_domain(NULL, method->signature());\n+    domain = TypeTuple::make_domain(nullptr, method->signature());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":182,"deletions":182,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  Type( TYPES t ) : _dual(NULL),  _base(t) {} \/\/ Simple types\n+  Type( TYPES t ) : _dual(nullptr),  _base(t) {} \/\/ Simple types\n@@ -287,1 +287,1 @@\n-  const TypeInt    *isa_int() const;             \/\/ Returns NULL if not an Int\n+  const TypeInt    *isa_int() const;             \/\/ Returns nullptr if not an Int\n@@ -291,2 +291,2 @@\n-  const TypeLong   *isa_long() const;            \/\/ Returns NULL if not a Long\n-  const TypeD      *isa_double() const;          \/\/ Returns NULL if not a Double{Top,Con,Bot}\n+  const TypeLong   *isa_long() const;            \/\/ Returns nullptr if not a Long\n+  const TypeD      *isa_double() const;          \/\/ Returns nullptr if not a Double{Top,Con,Bot}\n@@ -294,2 +294,2 @@\n-  const TypeD      *isa_double_constant() const; \/\/ Returns NULL if not a DoubleCon\n-  const TypeF      *isa_float() const;           \/\/ Returns NULL if not a Float{Top,Con,Bot}\n+  const TypeD      *isa_double_constant() const; \/\/ Returns nullptr if not a DoubleCon\n+  const TypeF      *isa_float() const;           \/\/ Returns nullptr if not a Float{Top,Con,Bot}\n@@ -297,1 +297,1 @@\n-  const TypeF      *isa_float_constant() const;  \/\/ Returns NULL if not a FloatCon\n+  const TypeF      *isa_float_constant() const;  \/\/ Returns nullptr if not a FloatCon\n@@ -300,1 +300,1 @@\n-  const TypeAry    *isa_ary() const;             \/\/ Returns NULL of not ary\n+  const TypeAry    *isa_ary() const;             \/\/ Returns nullptr of not ary\n@@ -302,1 +302,1 @@\n-  const TypeVect   *isa_vect() const;            \/\/ Returns NULL if not a Vector\n+  const TypeVect   *isa_vect() const;            \/\/ Returns nullptr if not a Vector\n@@ -304,1 +304,1 @@\n-  const TypeVectMask *isa_vectmask() const;      \/\/ Returns NULL if not a Vector Predicate\/Mask\n+  const TypeVectMask *isa_vectmask() const;      \/\/ Returns nullptr if not a Vector Predicate\/Mask\n@@ -306,1 +306,1 @@\n-  const TypePtr    *isa_ptr() const;             \/\/ Returns NULL if not ptr type\n+  const TypePtr    *isa_ptr() const;             \/\/ Returns nullptr if not ptr type\n@@ -310,1 +310,1 @@\n-  const TypeNarrowOop  *isa_narrowoop() const;   \/\/ Returns NULL if not oop ptr type\n+  const TypeNarrowOop  *isa_narrowoop() const;   \/\/ Returns nullptr if not oop ptr type\n@@ -312,2 +312,2 @@\n-  const TypeNarrowKlass *isa_narrowklass() const;\/\/ Returns NULL if not oop ptr type\n-  const TypeOopPtr   *isa_oopptr() const;        \/\/ Returns NULL if not oop ptr type\n+  const TypeNarrowKlass *isa_narrowklass() const;\/\/ Returns nullptr if not oop ptr type\n+  const TypeOopPtr   *isa_oopptr() const;        \/\/ Returns nullptr if not oop ptr type\n@@ -315,1 +315,1 @@\n-  const TypeInstPtr  *isa_instptr() const;       \/\/ Returns NULL if not InstPtr\n+  const TypeInstPtr  *isa_instptr() const;       \/\/ Returns nullptr if not InstPtr\n@@ -317,1 +317,1 @@\n-  const TypeAryPtr   *isa_aryptr() const;        \/\/ Returns NULL if not AryPtr\n+  const TypeAryPtr   *isa_aryptr() const;        \/\/ Returns nullptr if not AryPtr\n@@ -320,1 +320,1 @@\n-  const TypeMetadataPtr   *isa_metadataptr() const;   \/\/ Returns NULL if not oop ptr type\n+  const TypeMetadataPtr   *isa_metadataptr() const;   \/\/ Returns nullptr if not oop ptr type\n@@ -322,1 +322,1 @@\n-  const TypeKlassPtr      *isa_klassptr() const;      \/\/ Returns NULL if not KlassPtr\n+  const TypeKlassPtr      *isa_klassptr() const;      \/\/ Returns nullptr if not KlassPtr\n@@ -388,1 +388,1 @@\n-    assert((uint)type <= T_CONFLICT && _const_basic_type[type] != NULL, \"bad type\");\n+    assert((uint)type <= T_CONFLICT && _const_basic_type[type] != nullptr, \"bad type\");\n@@ -393,1 +393,1 @@\n-  \/\/ Otherwise or if the arrays have different dimensions, return NULL.\n+  \/\/ Otherwise or if the arrays have different dimensions, return null.\n@@ -405,1 +405,1 @@\n-    assert((uint)type <= T_CONFLICT && _zero_type[type] != NULL, \"bad type\");\n+    assert((uint)type <= T_CONFLICT && _zero_type[type] != nullptr, \"bad type\");\n@@ -463,3 +463,3 @@\n-  virtual const TypePtr* speculative() const                                  { return NULL; }\n-  virtual ciKlass* speculative_type() const                                   { return NULL; }\n-  virtual ciKlass* speculative_type_not_null() const                          { return NULL; }\n+  virtual const TypePtr* speculative() const                                  { return nullptr; }\n+  virtual ciKlass* speculative_type() const                                   { return nullptr; }\n+  virtual ciKlass* speculative_type_not_null() const                          { return nullptr; }\n@@ -470,1 +470,1 @@\n-  virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }\n+  virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != nullptr; }\n@@ -878,1 +878,1 @@\n-          const TypePtr* speculative = NULL,\n+          const TypePtr* speculative = nullptr,\n@@ -927,1 +927,1 @@\n-                             const TypePtr* speculative = NULL,\n+                             const TypePtr* speculative = nullptr,\n@@ -1033,1 +1033,1 @@\n-  \/\/ Oop is NULL, unless this is a constant oop.\n+  \/\/ Oop is null, unless this is a constant oop.\n@@ -1035,1 +1035,1 @@\n-  \/\/ If _klass is NULL, then so is _sig.  This is an unloaded klass.\n+  \/\/ If _klass is null, then so is _sig.  This is an unloaded klass.\n@@ -1076,1 +1076,1 @@\n-  \/\/ If require_constant, produce a NULL if a singleton is not possible.\n+  \/\/ If require_constant, produce a nullptr if a singleton is not possible.\n@@ -1082,1 +1082,1 @@\n-                                const TypePtr* speculative = NULL,\n+                                const TypePtr* speculative = nullptr,\n@@ -1157,1 +1157,1 @@\n-    return make(ptr, klass, false, NULL, 0, InstanceBot);\n+    return make(ptr, klass, false, nullptr, 0, InstanceBot);\n@@ -1162,1 +1162,1 @@\n-    return make(ptr, klass, true, NULL, 0, InstanceBot);\n+    return make(ptr, klass, true, nullptr, 0, InstanceBot);\n@@ -1167,1 +1167,1 @@\n-    return make(ptr, klass, false, NULL, offset, InstanceBot);\n+    return make(ptr, klass, false, nullptr, offset, InstanceBot);\n@@ -1173,1 +1173,1 @@\n-                                 const TypePtr* speculative = NULL,\n+                                 const TypePtr* speculative = nullptr,\n@@ -1179,1 +1179,1 @@\n-  \/\/ If this is a java.lang.Class constant, return the type for it or NULL.\n+  \/\/ If this is a java.lang.Class constant, return the type for it or null.\n@@ -1224,1 +1224,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -1232,2 +1232,2 @@\n-        if (ck != NULL) ck->print();\n-        else tty->print(\"<NULL>\");\n+        if (ck != nullptr) ck->print();\n+        else tty->print(\"<nullptr>\");\n@@ -1259,1 +1259,1 @@\n-                                const TypePtr* speculative = NULL,\n+                                const TypePtr* speculative = nullptr,\n@@ -1264,1 +1264,1 @@\n-                                const TypePtr* speculative = NULL,\n+                                const TypePtr* speculative = nullptr,\n@@ -1309,1 +1309,1 @@\n-    assert((uint)elem <= T_CONFLICT && _array_body_type[elem] != NULL, \"bad elem type\");\n+    assert((uint)elem <= T_CONFLICT && _array_body_type[elem] != nullptr, \"bad elem type\");\n@@ -1609,1 +1609,1 @@\n-  return (isa_oopptr() != NULL && is_oopptr()->is_ptr_to_narrowoop_nv());\n+  return (isa_oopptr() != nullptr && is_oopptr()->is_ptr_to_narrowoop_nv());\n@@ -1617,1 +1617,1 @@\n-  return (isa_oopptr() != NULL && is_oopptr()->is_ptr_to_narrowklass_nv());\n+  return (isa_oopptr() != nullptr && is_oopptr()->is_ptr_to_narrowklass_nv());\n@@ -1639,1 +1639,1 @@\n-  return (((bt == T_INT && _base == Int) || (bt == T_LONG && _base == Long)) ? (TypeInteger*)this : NULL);\n+  return (((bt == T_INT && _base == Int) || (bt == T_LONG && _base == Long)) ? (TypeInteger*)this : nullptr);\n@@ -1648,1 +1648,1 @@\n-  return ( _base == Int ? (TypeInt*)this : NULL);\n+  return ( _base == Int ? (TypeInt*)this : nullptr);\n@@ -1657,1 +1657,1 @@\n-  return ( _base == Long ? (TypeLong*)this : NULL);\n+  return ( _base == Long ? (TypeLong*)this : nullptr);\n@@ -1663,1 +1663,1 @@\n-           _base == FloatBot) ? (TypeF*)this : NULL);\n+           _base == FloatBot) ? (TypeF*)this : nullptr);\n@@ -1672,1 +1672,1 @@\n-  return ( _base == FloatCon ? (TypeF*)this : NULL);\n+  return ( _base == FloatCon ? (TypeF*)this : nullptr);\n@@ -1678,1 +1678,1 @@\n-           _base == DoubleBot) ? (TypeD*)this : NULL);\n+           _base == DoubleBot) ? (TypeD*)this : nullptr);\n@@ -1687,1 +1687,1 @@\n-  return ( _base == DoubleCon ? (TypeD*)this : NULL);\n+  return ( _base == DoubleCon ? (TypeD*)this : nullptr);\n@@ -1701,1 +1701,1 @@\n-  return ((_base == Array) ? (TypeAry*)this : NULL);\n+  return ((_base == Array) ? (TypeAry*)this : nullptr);\n@@ -1710,1 +1710,1 @@\n-  return (_base == VectorMask) ? (TypeVectMask*)this : NULL;\n+  return (_base == VectorMask) ? (TypeVectMask*)this : nullptr;\n@@ -1719,1 +1719,1 @@\n-  return (_base >= VectorMask && _base <= VectorZ) ? (TypeVect*)this : NULL;\n+  return (_base >= VectorMask && _base <= VectorZ) ? (TypeVect*)this : nullptr;\n@@ -1730,1 +1730,1 @@\n-  return (_base >= AnyPtr && _base <= KlassPtr) ? (TypePtr*)this : NULL;\n+  return (_base >= AnyPtr && _base <= KlassPtr) ? (TypePtr*)this : nullptr;\n@@ -1741,1 +1741,1 @@\n-  return (_base >= OopPtr && _base <= AryPtr) ? (TypeOopPtr*)this : NULL;\n+  return (_base >= OopPtr && _base <= AryPtr) ? (TypeOopPtr*)this : nullptr;\n@@ -1745,1 +1745,1 @@\n-  return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;\n+  return (_base == RawPtr) ? (TypeRawPtr*)this : nullptr;\n@@ -1754,1 +1754,1 @@\n-  return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;\n+  return (_base == InstPtr) ? (TypeInstPtr*)this : nullptr;\n@@ -1763,1 +1763,1 @@\n-  return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;\n+  return (_base == AryPtr) ? (TypeAryPtr*)this : nullptr;\n@@ -1779,1 +1779,1 @@\n-  return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;\n+  return (_base == NarrowOop) ? (TypeNarrowOop*)this : nullptr;\n@@ -1788,1 +1788,1 @@\n-  return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;\n+  return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : nullptr;\n@@ -1798,1 +1798,1 @@\n-  return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;\n+  return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : nullptr;\n@@ -1802,1 +1802,1 @@\n-  return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;\n+  return (_base == KlassPtr) ? (TypeKlassPtr*)this : nullptr;\n@@ -1822,1 +1822,1 @@\n-                                (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);\n+                                (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : nullptr);\n@@ -1827,1 +1827,1 @@\n-                                  (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);\n+                                  (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : nullptr);\n@@ -1839,1 +1839,1 @@\n-  return (tp != NULL) && (tp->offset() == 0) &&\n+  return (tp != nullptr) && (tp->offset() == 0) &&\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-      Node* new_vbox = NULL;\n+      Node* new_vbox = nullptr;\n@@ -286,1 +286,1 @@\n-      if (debug != NULL && debug->uncast(\/*keep_deps*\/false) == vec_box) {\n+      if (debug != nullptr && debug->uncast(\/*keep_deps*\/false) == vec_box) {\n@@ -393,1 +393,1 @@\n-  assert(field != NULL, \"\");\n+  assert(field != nullptr, \"\");\n@@ -434,1 +434,1 @@\n-    assert(field != NULL, \"\");\n+    assert(field != nullptr, \"\");\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  assert(fd1 != NULL, \"element type info is missing\");\n+  assert(fd1 != nullptr, \"element type info is missing\");\n@@ -53,1 +53,1 @@\n-  assert(fd2 != NULL, \"vector length info is missing\");\n+  assert(fd2 != nullptr, \"vector length info is missing\");\n@@ -85,1 +85,1 @@\n-    return NULL; \/\/ arguments don't agree on vector shapes\n+    return nullptr; \/\/ arguments don't agree on vector shapes\n@@ -88,1 +88,1 @@\n-    return NULL; \/\/ no nulls are allowed\n+    return nullptr; \/\/ no nulls are allowed\n@@ -199,1 +199,1 @@\n-  if (vec_klass->const_oop() == NULL) {\n+  if (vec_klass->const_oop() == nullptr) {\n@@ -202,1 +202,1 @@\n-  assert(vec_klass->const_oop()->as_instance()->java_lang_Class_klass() != NULL, \"klass instance expected\");\n+  assert(vec_klass->const_oop()->as_instance()->java_lang_Class_klass() != nullptr, \"klass instance expected\");\n@@ -231,2 +231,2 @@\n-  if (opr == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n-      !opr->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n+      !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -310,1 +310,1 @@\n-  Node* opd1 = NULL; Node* opd2 = NULL; Node* opd3 = NULL;\n+  Node* opd1 = nullptr; Node* opd2 = nullptr; Node* opd3 = nullptr;\n@@ -314,1 +314,1 @@\n-      if (opd3 == NULL) {\n+      if (opd3 == nullptr) {\n@@ -325,1 +325,1 @@\n-      if (opd2 == NULL) {\n+      if (opd2 == nullptr) {\n@@ -336,1 +336,1 @@\n-      if (opd1 == NULL) {\n+      if (opd1 == nullptr) {\n@@ -348,1 +348,1 @@\n-  Node* operation = NULL;\n+  Node* operation = nullptr;\n@@ -352,1 +352,1 @@\n-    if (operation == NULL) {\n+    if (operation == nullptr) {\n@@ -396,1 +396,1 @@\n-  if (shuffle_klass == NULL || vlen == NULL || start_val == NULL || step_val == NULL || wrap == NULL) {\n+  if (shuffle_klass == nullptr || vlen == nullptr || start_val == nullptr || step_val == nullptr || wrap == nullptr) {\n@@ -400,1 +400,1 @@\n-      shuffle_klass->const_oop() == NULL || !wrap->is_con()) {\n+      shuffle_klass->const_oop() == nullptr || !wrap->is_con()) {\n@@ -489,1 +489,1 @@\n-  if (mask_klass == NULL || elem_klass == NULL || mask->is_top() || vlen == NULL) {\n+  if (mask_klass == nullptr || elem_klass == nullptr || mask->is_top() || vlen == nullptr) {\n@@ -543,1 +543,1 @@\n-  if (vector_klass == NULL || elem_klass == NULL || shuffle_klass == NULL || shuffle->is_top() || vlen == NULL) {\n+  if (vector_klass == nullptr || elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr) {\n@@ -546,1 +546,1 @@\n-  if (!vlen->is_con() || vector_klass->const_oop() == NULL || shuffle_klass->const_oop() == NULL) {\n+  if (!vlen->is_con() || vector_klass->const_oop() == nullptr || shuffle_klass->const_oop() == nullptr) {\n@@ -603,2 +603,2 @@\n-  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n-      vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n+      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -645,1 +645,1 @@\n-  Node* elem = NULL;\n+  Node* elem = nullptr;\n@@ -681,1 +681,1 @@\n-  assert(arr_type != NULL, \"unexpected\");\n+  assert(arr_type != nullptr, \"unexpected\");\n@@ -715,2 +715,2 @@\n-  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n-      vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n+      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -763,1 +763,1 @@\n-  \/\/ Can base be NULL? Otherwise, always on-heap access.\n+  \/\/ Can base be nullptr? Otherwise, always on-heap access.\n@@ -770,1 +770,1 @@\n-  bool using_byte_array = arr_type != NULL && arr_type->elem()->array_element_basic_type() == T_BYTE && elem_bt != T_BYTE;\n+  bool using_byte_array = arr_type != nullptr && arr_type->elem()->array_element_basic_type() == T_BYTE && elem_bt != T_BYTE;\n@@ -773,1 +773,1 @@\n-  if (arr_type != NULL && !using_byte_array && !is_mask && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+  if (arr_type != nullptr && !using_byte_array && !is_mask && !elem_consistent_with_arr(elem_bt, arr_type)) {\n@@ -832,1 +832,1 @@\n-    if (val == NULL) {\n+    if (val == nullptr) {\n@@ -851,1 +851,1 @@\n-    Node* vload = NULL;\n+    Node* vload = nullptr;\n@@ -901,2 +901,2 @@\n-  if (vector_klass == NULL || elem_klass == NULL || vector_idx_klass == NULL || vlen == NULL ||\n-      vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || vector_idx_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (vector_klass == nullptr || elem_klass == nullptr || vector_idx_klass == nullptr || vlen == nullptr ||\n+      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || vector_idx_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -961,1 +961,1 @@\n-  if (arr_type == NULL || (arr_type != NULL && !elem_consistent_with_arr(elem_bt, arr_type))) {\n+  if (arr_type == nullptr || (arr_type != nullptr && !elem_consistent_with_arr(elem_bt, arr_type))) {\n@@ -976,1 +976,1 @@\n-  if (vbox_idx_klass == NULL) {\n+  if (vbox_idx_klass == nullptr) {\n@@ -985,1 +985,1 @@\n-  if (index_vect == NULL) {\n+  if (index_vect == nullptr) {\n@@ -993,1 +993,1 @@\n-    if (val == NULL) {\n+    if (val == nullptr) {\n@@ -1026,2 +1026,2 @@\n-  if (opr == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n-      !opr->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n+      !opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -1069,1 +1069,1 @@\n-  if (opd == NULL) {\n+  if (opd == nullptr) {\n@@ -1074,1 +1074,1 @@\n-  Node* rn = gvn().transform(ReductionNode::make(opc, NULL, init, opd, elem_bt));\n+  Node* rn = gvn().transform(ReductionNode::make(opc, nullptr, init, opd, elem_bt));\n@@ -1076,1 +1076,1 @@\n-  Node* bits = NULL;\n+  Node* bits = nullptr;\n@@ -1114,2 +1114,2 @@\n-  if (cond == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n-      !cond->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (cond == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n+      !cond->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -1155,1 +1155,1 @@\n-  if (opd1 == NULL || opd2 == NULL) {\n+  if (opd1 == nullptr || opd2 == nullptr) {\n@@ -1178,1 +1178,1 @@\n-  if (mask_klass == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL) {\n+  if (mask_klass == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {\n@@ -1181,2 +1181,2 @@\n-  if (mask_klass->const_oop() == NULL || vector_klass->const_oop() == NULL ||\n-      elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (mask_klass->const_oop() == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -1226,1 +1226,1 @@\n-  if (v1 == NULL || v2 == NULL || mask == NULL) {\n+  if (v1 == nullptr || v2 == nullptr || mask == nullptr) {\n@@ -1252,1 +1252,1 @@\n-  if (cond == NULL || vector_klass == NULL || mask_klass == NULL || elem_klass == NULL || vlen == NULL) {\n+  if (cond == nullptr || vector_klass == nullptr || mask_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {\n@@ -1255,2 +1255,2 @@\n-  if (!cond->is_con() || vector_klass->const_oop() == NULL || mask_klass->const_oop() == NULL ||\n-      elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (!cond->is_con() || vector_klass->const_oop() == nullptr || mask_klass->const_oop() == nullptr ||\n+      elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -1312,1 +1312,1 @@\n-  if (v1 == NULL || v2 == NULL) {\n+  if (v1 == nullptr || v2 == nullptr) {\n@@ -1339,1 +1339,1 @@\n-  if (vector_klass == NULL || shuffle_klass == NULL || elem_klass == NULL || vlen == NULL) {\n+  if (vector_klass == nullptr || shuffle_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {\n@@ -1342,2 +1342,2 @@\n-  if (shuffle_klass->const_oop() == NULL || vector_klass->const_oop() == NULL ||\n-    elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (shuffle_klass->const_oop() == nullptr || vector_klass->const_oop() == nullptr ||\n+    elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -1393,1 +1393,1 @@\n-  if (v1 == NULL || shuffle == NULL) {\n+  if (v1 == nullptr || shuffle == nullptr) {\n@@ -1406,1 +1406,1 @@\n-  address addr = NULL;\n+  address addr = nullptr;\n@@ -1408,1 +1408,1 @@\n-  assert(name_ptr != NULL, \"unexpected\");\n+  assert(name_ptr != nullptr, \"unexpected\");\n@@ -1428,1 +1428,1 @@\n-      addr = NULL;\n+      addr = nullptr;\n@@ -1439,1 +1439,1 @@\n-  assert(opd1 != NULL, \"must not be null\");\n+  assert(opd1 != nullptr, \"must not be null\");\n@@ -1441,1 +1441,1 @@\n-  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != NULL ? 2 : 1, vt, vt);\n+  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != nullptr ? 2 : 1, vt, vt);\n@@ -1447,2 +1447,2 @@\n-  if (addr == NULL) {\n-    return NULL;\n+  if (addr == nullptr) {\n+    return nullptr;\n@@ -1451,1 +1451,1 @@\n-  assert(name != NULL, \"name must not be null\");\n+  assert(name[0] != '\\0', \"name must not be null\");\n@@ -1474,1 +1474,1 @@\n-  if (opr == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL) {\n+  if (opr == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {\n@@ -1477,1 +1477,1 @@\n-  if (!opr->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (!opr->is_con() || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -1528,1 +1528,1 @@\n-  if (opd1 == NULL || opd2 == NULL) {\n+  if (opd1 == nullptr || opd2 == nullptr) {\n@@ -1559,3 +1559,3 @@\n-  if (opr == NULL ||\n-      vector_klass_from == NULL || elem_klass_from == NULL || vlen_from == NULL ||\n-      vector_klass_to   == NULL || elem_klass_to   == NULL || vlen_to   == NULL) {\n+  if (opr == nullptr ||\n+      vector_klass_from == nullptr || elem_klass_from == nullptr || vlen_from == nullptr ||\n+      vector_klass_to   == nullptr || elem_klass_to   == nullptr || vlen_to   == nullptr) {\n@@ -1565,2 +1565,2 @@\n-      vector_klass_from->const_oop() == NULL || elem_klass_from->const_oop() == NULL || !vlen_from->is_con() ||\n-      vector_klass_to->const_oop() == NULL || elem_klass_to->const_oop() == NULL || !vlen_to->is_con()) {\n+      vector_klass_from->const_oop() == nullptr || elem_klass_from->const_oop() == nullptr || !vlen_from->is_con() ||\n+      vector_klass_to->const_oop() == nullptr || elem_klass_to->const_oop() == nullptr || !vlen_to->is_con()) {\n@@ -1651,1 +1651,1 @@\n-  if (opd1 == NULL) {\n+  if (opd1 == nullptr) {\n@@ -1743,1 +1743,1 @@\n-  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL || idx == NULL) {\n+  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || idx == nullptr) {\n@@ -1746,1 +1746,1 @@\n-  if (vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con() || !idx->is_con()) {\n+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {\n@@ -1783,1 +1783,1 @@\n-  if (opd == NULL) {\n+  if (opd == nullptr) {\n@@ -1788,1 +1788,1 @@\n-  assert(gvn().type(insert_val)->isa_long() != NULL, \"expected to be long\");\n+  assert(gvn().type(insert_val)->isa_long() != nullptr, \"expected to be long\");\n@@ -1836,1 +1836,1 @@\n-  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL || idx == NULL) {\n+  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || idx == nullptr) {\n@@ -1839,1 +1839,1 @@\n-  if (vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con() || !idx->is_con()) {\n+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {\n@@ -1877,1 +1877,1 @@\n-  if (opd == NULL) {\n+  if (opd == nullptr) {\n@@ -1883,1 +1883,1 @@\n-  Node* bits = NULL;\n+  Node* bits = nullptr;\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -531,1 +531,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -566,1 +566,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -586,1 +586,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -675,1 +675,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -711,1 +711,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -748,1 +748,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -768,1 +768,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -802,1 +802,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -983,1 +983,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1023,1 +1023,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1067,1 +1067,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1097,1 +1097,1 @@\n-          default: Unimplemented(); return NULL;\n+          default: Unimplemented(); return nullptr;\n@@ -1112,1 +1112,1 @@\n-          default: Unimplemented(); return NULL;\n+          default: Unimplemented(); return nullptr;\n@@ -1117,1 +1117,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1152,2 +1152,2 @@\n-  Node* shiftRCnt = NULL;\n-  Node* shiftLCnt = NULL;\n+  Node* shiftRCnt = nullptr;\n+  Node* shiftLCnt = nullptr;\n@@ -1222,1 +1222,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1232,1 +1232,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1302,1 +1302,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1348,1 +1348,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1066,1 +1066,1 @@\n-  ExtractNode(Node* src, ConINode* pos) : Node(NULL, src, (Node*)pos) {\n+  ExtractNode(Node* src, ConINode* pos) : Node(nullptr, src, (Node*)pos) {\n@@ -1230,1 +1230,1 @@\n-  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : Node(NULL, in1, in2), _predicate(predicate) {\n+  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : Node(nullptr, in1, in2), _predicate(predicate) {\n@@ -1415,1 +1415,1 @@\n-    : Node(NULL, box, val), _box_type(box_type), _vec_type(vt) {\n+    : Node(nullptr, box, val), _box_type(box_type), _vec_type(vt) {\n@@ -1420,2 +1420,2 @@\n-  const  TypeInstPtr* box_type() const { assert(_box_type != NULL, \"\"); return _box_type; };\n-  const  TypeVect*    vec_type() const { assert(_vec_type != NULL, \"\"); return _vec_type; };\n+  const  TypeInstPtr* box_type() const { assert(_box_type != nullptr, \"\"); return _box_type; };\n+  const  TypeVect*    vec_type() const { assert(_vec_type != nullptr, \"\"); return _vec_type; };\n@@ -1434,1 +1434,1 @@\n-    : CallStaticJavaNode(C, VectorBoxNode::vec_box_type(vbox_type), NULL, NULL) {\n+    : CallStaticJavaNode(C, VectorBoxNode::vec_box_type(vbox_type), nullptr, nullptr) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}