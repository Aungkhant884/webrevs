{"files":[{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+\n+\/\/ Maps Class instances to values of type T. Under memory pressure, the\n+\/\/ mapping is released (under soft references GC policy) and would be\n+\/\/ recomputed the next time it is queried. The mapping is bound to the\n+\/\/ lifetime of the class: when the class is unloaded, the mapping is\n+\/\/ removed too.\n+abstract class ClassCache<T> {\n+\n+    private static class CacheRef<T> extends SoftReference<T> {\n+        private final Class<?> type;\n+\n+        CacheRef(T referent, ReferenceQueue<T> queue, Class<?> type) {\n+            super(referent, queue);\n+            this.type = type;\n+        }\n+\n+        Class<?> getType() {\n+            return type;\n+        }\n+    }\n+\n+    private final ReferenceQueue<T> queue;\n+    private final ClassValue<SoftReference<T>> map;\n+\n+    protected abstract T computeValue(Class<?> cl);\n+\n+    protected ClassCache() {\n+        queue = new ReferenceQueue<>();\n+        map = new ClassValue<>() {\n+            @Override\n+            protected SoftReference<T> computeValue(Class<?> type) {\n+                return new CacheRef<>(ClassCache.this.computeValue(type), queue, type);\n+            }\n+        };\n+    }\n+\n+    T get(Class<?> cl) {\n+        processQueue();\n+        T val;\n+        do {\n+            SoftReference<T> ref = map.get(cl);\n+            val = ref.get();\n+            if (val == null) {\n+                map.remove(cl);\n+            }\n+        } while (val == null);\n+        return val;\n+    }\n+\n+    private void processQueue() {\n+        Reference<? extends T> ref;\n+        while((ref = queue.poll()) != null) {\n+            CacheRef<? extends T> cacheRef = (CacheRef<? extends T>)ref;\n+            map.remove(cacheRef.getType());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ClassCache.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.ref.SoftReference;\n@@ -111,2 +110,7 @@\n-        static final ConcurrentMap<WeakClassKey,Reference<?>> localDescs =\n-            new ConcurrentHashMap<>();\n+        static final ClassCache<ObjectStreamClass> localDescs =\n+            new ClassCache<>() {\n+                @Override\n+                protected ObjectStreamClass computeValue(Class<?> type) {\n+                    return new ObjectStreamClass(type);\n+                }\n+            };\n@@ -115,9 +119,7 @@\n-        static final ConcurrentMap<FieldReflectorKey,Reference<?>> reflectors =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to local classes *\/\n-        private static final ReferenceQueue<Class<?>> localDescsQueue =\n-            new ReferenceQueue<>();\n-        \/** queue for WeakReferences to field reflectors keys *\/\n-        private static final ReferenceQueue<Class<?>> reflectorsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassCache<Map<FieldReflectorKey, FieldReflector>> reflectors =\n+            new ClassCache<>() {\n+                @Override\n+                protected Map<FieldReflectorKey, FieldReflector> computeValue(Class<?> type) {\n+                    return new ConcurrentHashMap<>();\n+                }\n+            };\n@@ -365,130 +367,1 @@\n-        processQueue(Caches.localDescsQueue, Caches.localDescs);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);\n-        Reference<?> ref = Caches.localDescs.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new SoftReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.localDescs.remove(key, ref);\n-                }\n-                ref = Caches.localDescs.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {  \/\/ check common case first\n-            return (ObjectStreamClass) entry;\n-        }\n-        if (entry instanceof EntryFuture) {\n-            future = (EntryFuture) entry;\n-            if (future.getOwner() == Thread.currentThread()) {\n-                \/*\n-                 * Handle nested call situation described by 4803747: waiting\n-                 * for future value to be set by a lookup() call further up the\n-                 * stack will result in deadlock, so calculate and set the\n-                 * future value here instead.\n-                 *\/\n-                entry = null;\n-            } else {\n-                entry = future.get();\n-            }\n-        }\n-        if (entry == null) {\n-            try {\n-                entry = new ObjectStreamClass(cl);\n-            } catch (Throwable th) {\n-                entry = th;\n-            }\n-            if (future.set(entry)) {\n-                Caches.localDescs.put(key, new SoftReference<>(entry));\n-            } else {\n-                \/\/ nested lookup call already set future\n-                entry = future.get();\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {\n-            return (ObjectStreamClass) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n-        }\n-    }\n-\n-    \/**\n-     * Placeholder used in class descriptor and field reflector lookup tables\n-     * for an entry in the process of being initialized.  (Internal) callers\n-     * which receive an EntryFuture belonging to another thread as the result\n-     * of a lookup should call the get() method of the EntryFuture; this will\n-     * return the actual entry once it is ready for use and has been set().  To\n-     * conserve objects, EntryFutures synchronize on themselves.\n-     *\/\n-    private static class EntryFuture {\n-\n-        private static final Object unset = new Object();\n-        private final Thread owner = Thread.currentThread();\n-        private Object entry = unset;\n-\n-        \/**\n-         * Attempts to set the value contained by this EntryFuture.  If the\n-         * EntryFuture's value has not been set already, then the value is\n-         * saved, any callers blocked in the get() method are notified, and\n-         * true is returned.  If the value has already been set, then no saving\n-         * or notification occurs, and false is returned.\n-         *\/\n-        synchronized boolean set(Object entry) {\n-            if (this.entry != unset) {\n-                return false;\n-            }\n-            this.entry = entry;\n-            notifyAll();\n-            return true;\n-        }\n-\n-        \/**\n-         * Returns the value contained by this EntryFuture, blocking if\n-         * necessary until a value is set.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        synchronized Object get() {\n-            boolean interrupted = false;\n-            while (entry == unset) {\n-                try {\n-                    wait();\n-                } catch (InterruptedException ex) {\n-                    interrupted = true;\n-                }\n-            }\n-            if (interrupted) {\n-                AccessController.doPrivileged(\n-                    new PrivilegedAction<>() {\n-                        public Void run() {\n-                            Thread.currentThread().interrupt();\n-                            return null;\n-                        }\n-                    }\n-                );\n-            }\n-            return entry;\n-        }\n-\n-        \/**\n-         * Returns the thread that created this EntryFuture.\n-         *\/\n-        Thread getOwner() {\n-            return owner;\n-        }\n+        return Caches.localDescs.get(cl);\n@@ -2253,26 +2126,1 @@\n-            localDesc.cl : null;\n-        processQueue(Caches.reflectorsQueue, Caches.reflectors);\n-        FieldReflectorKey key = new FieldReflectorKey(cl, fields,\n-                                                      Caches.reflectorsQueue);\n-        Reference<?> ref = Caches.reflectors.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new SoftReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.reflectors.remove(key, ref);\n-                }\n-                ref = Caches.reflectors.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n-            }\n-        }\n+            localDesc.cl : Void.class;\n@@ -2280,9 +2128,8 @@\n-        if (entry instanceof FieldReflector) {  \/\/ check common case first\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof EntryFuture) {\n-            entry = ((EntryFuture) entry).get();\n-        } else if (entry == null) {\n-            try {\n-                entry = new FieldReflector(matchFields(fields, localDesc));\n-            } catch (Throwable th) {\n-                entry = th;\n+        var clReflectors = Caches.reflectors.get(cl);\n+        var key = new FieldReflectorKey(fields);\n+        var reflector = clReflectors.get(key);\n+        if (reflector == null) {\n+            reflector = new FieldReflector(matchFields(fields, localDesc));\n+            var oldReflector = clReflectors.putIfAbsent(key, reflector);\n+            if (oldReflector != null) {\n+                reflector = oldReflector;\n@@ -2290,14 +2137,0 @@\n-            future.set(entry);\n-            Caches.reflectors.put(key, new SoftReference<>(entry));\n-        }\n-\n-        if (entry instanceof FieldReflector) {\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof InvalidClassException) {\n-            throw (InvalidClassException) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n@@ -2305,0 +2138,1 @@\n+        return reflector;\n@@ -2309,1 +2143,1 @@\n-     * refer to the same class and equivalent field formats.\n+     * refer to equivalent field formats.\n@@ -2311,1 +2145,1 @@\n-    private static class FieldReflectorKey extends WeakReference<Class<?>> {\n+    private static class FieldReflectorKey {\n@@ -2315,1 +2149,0 @@\n-        private final boolean nullClass;\n@@ -2317,2 +2150,1 @@\n-        FieldReflectorKey(Class<?> cl, ObjectStreamField[] fields,\n-                          ReferenceQueue<Class<?>> queue)\n+        FieldReflectorKey(ObjectStreamField[] fields)\n@@ -2320,2 +2152,0 @@\n-            super(cl, queue);\n-            nullClass = (cl == null);\n@@ -2328,1 +2158,1 @@\n-            hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);\n+            hash = Arrays.hashCode(sigs);\n@@ -2336,13 +2166,3 @@\n-            if (obj == this) {\n-                return true;\n-            }\n-\n-            if (obj instanceof FieldReflectorKey other) {\n-                Class<?> referent;\n-                return (nullClass ? other.nullClass\n-                                  : ((referent = get()) != null) &&\n-                                    (other.refersTo(referent))) &&\n-                        Arrays.equals(sigs, other.sigs);\n-            } else {\n-                return false;\n-            }\n+            return obj == this ||\n+                   obj instanceof FieldReflectorKey other &&\n+                   Arrays.equals(sigs, other.sigs);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":32,"deletions":212,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.io.ObjectStreamClass;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+\/* @test\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive\n+ * @run testng\/othervm -Xmx10m -XX:SoftRefLRUPolicyMSPerMB=1 ObjectStreamClassCaching\n+ *\/\n+public class ObjectStreamClassCaching {\n+\n+    @Test\n+    public void testCachingEffectiveness() throws Exception {\n+        var ref = lookupObjectStreamClass(TestClass.class);\n+        System.gc();\n+        Thread.sleep(100L);\n+        \/\/ to trigger any ReferenceQueue processing...\n+        lookupObjectStreamClass(AnotherTestClass.class);\n+        assertFalse(ref.refersTo(null),\n+                    \"Cache lost entry although memory was not under pressure\");\n+    }\n+\n+    @Test\n+    public void testCacheReleaseUnderMemoryPressure() throws Exception {\n+        var ref = lookupObjectStreamClass(TestClass.class);\n+        pressMemoryHard(ref);\n+        System.gc();\n+        Thread.sleep(100L);\n+        assertTrue(ref.refersTo(null),\n+                   \"Cache still has entry although memory was pressed hard\");\n+    }\n+\n+    \/\/ separate method so that the looked-up ObjectStreamClass is not kept on stack\n+    private static WeakReference<?> lookupObjectStreamClass(Class<?> cl) {\n+        return new WeakReference<>(ObjectStreamClass.lookup(cl));\n+    }\n+\n+    private static void pressMemoryHard(Reference<?> ref) {\n+        try {\n+            var list = new ArrayList<>();\n+            while (!ref.refersTo(null)) {\n+                list.add(new byte[1024 * 1024 * 64]); \/\/ 64 MiB chunks\n+            }\n+        } catch (OutOfMemoryError e) {\n+            \/\/ release\n+        }\n+    }\n+}\n+\n+class TestClass implements Serializable {\n+}\n+\n+class AnotherTestClass implements Serializable {\n+}\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/ObjectStreamClassCaching.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.Constructor;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+\/* @test\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @build jdk.test.lib.util.ForceGC\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive\n+ * @run testng TestOSCClassLoaderLeak\n+ *\/\n+public class TestOSCClassLoaderLeak {\n+\n+    @Test\n+    public void testClassLoaderLeak() throws Exception {\n+        TestClassLoader myOwnClassLoader = new TestClassLoader();\n+        Class<?> loadClass = myOwnClassLoader.loadClass(\"ObjectStreamClass_MemoryLeakExample\");\n+        Constructor con = loadClass.getConstructor();\n+        con.setAccessible(true);\n+        Object objectStreamClass_MemoryLeakExample = con.newInstance();\n+        objectStreamClass_MemoryLeakExample.toString();\n+\n+        WeakReference<Object> myOwnClassLoaderWeakReference = new WeakReference<>(myOwnClassLoader);\n+        assertNotNull(myOwnClassLoaderWeakReference.get());\n+        objectStreamClass_MemoryLeakExample = null;\n+        myOwnClassLoader = null;\n+        loadClass = null;\n+        con = null;\n+        assertNotNull(myOwnClassLoaderWeakReference.get());\n+\n+        ForceGC gc = new ForceGC();\n+        assertTrue(gc.await(() -> myOwnClassLoaderWeakReference.get() == null));\n+    }\n+}\n+\n+class ObjectStreamClass_MemoryLeakExample {\n+    private static final ObjectStreamField[] fields = ObjectStreamClass.lookup(TestClass.class).getFields();\n+    public ObjectStreamClass_MemoryLeakExample() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Arrays.toString(fields);\n+    }\n+}\n+\n+class TestClassLoader extends ClassLoader {\n+\n+    @Override\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        if (name.equals(\"TestClass\") || name.equals(\"ObjectStreamClass_MemoryLeakExample\")) {\n+            byte[] bt = loadClassData(name);\n+            return defineClass(name, bt, 0, bt.length);\n+        } else {\n+            return super.loadClass(name);\n+        }\n+    }\n+\n+    private static byte[] loadClassData(String className) {\n+        ByteArrayOutputStream byteSt = new ByteArrayOutputStream();\n+        try (InputStream is = TestClassLoader.class.getClassLoader().getResourceAsStream(className.replace(\".\", \"\/\") + \".class\")) {\n+            int len = 0;\n+            while ((len = is.read()) != -1) {\n+                byteSt.write(len);\n+            }\n+        } catch (java.io.IOException e) {\n+            e.printStackTrace();\n+        }\n+        return byteSt.toByteArray();\n+    }\n+}\n+\n+class TestClass implements Serializable {\n+    public String x;\n+}\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/TestOSCClassLoaderLeak.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}