{"files":[{"patch":"@@ -43,1 +43,2 @@\n-  size_t _success_full_gcs;\n+  \/\/ Written by control thread, read by mutators\n+  volatile size_t _success_full_gcs;\n@@ -85,0 +86,4 @@\n+\n+  size_t full_gc_count() const {\n+    return _success_full_gcs + _alloc_failure_degenerated_upgrade_to_full;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -843,15 +843,5 @@\n-    \/\/ strategy is to try again, as long as GC makes progress.\n-    \/\/\n-    \/\/ Then, we need to make sure the allocation was retried after at least one\n-    \/\/ Full GC, which means we want to try more than ShenandoahFullGCThreshold times.\n-\n-    size_t tries = 0;\n-\n-    while (result == NULL && _progress_last_gc.is_set()) {\n-      tries++;\n-      control_thread()->handle_alloc_failure(req);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n-\n-    while (result == NULL && tries <= ShenandoahFullGCThreshold) {\n-      tries++;\n+    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n+    \/\/ one full GC has completed).\n+    size_t original_count = shenandoah_policy()->full_gc_count();\n+    while (result == NULL\n+        && (_progress_last_gc.is_set() || original_count == shenandoah_policy()->full_gc_count())) {\n@@ -861,1 +851,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"}]}