{"files":[{"patch":"@@ -463,1 +463,1 @@\n-        maybe-uninitialized class-memaccess unused-result extra\n+        maybe-uninitialized class-memaccess unused-result extra use-after-free\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,7 @@\n+  \/\/ gcc12 warns \"writing 1 byte into a region of size 0\" when T == Klass.\n+  \/\/ The warning seems to be a false positive.  And there is no warning for\n+  \/\/ other types that use the same mechanisms.  The warning also sometimes\n+  \/\/ goes away with minor code perturbations, such as replacing function calls\n+  \/\/ with equivalent code directly inlined.\n+  PRAGMA_DIAG_PUSH\n+  PRAGMA_DISABLE_GCC_WARNING(\"-Wstringop-overflow\")\n@@ -136,0 +143,1 @@\n+  PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdBits.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-      _data[i] = init;\n+      data()[i] = init;\n@@ -102,1 +102,11 @@\n-  T* data()                           { return _data; }\n+\n+  T* data() {\n+    return reinterpret_cast<T*>(\n+      reinterpret_cast<char*>(this) + base_offset_in_bytes());\n+  }\n+\n+  const T* data() const {\n+    return reinterpret_cast<const T*>(\n+      reinterpret_cast<const char*>(this) + base_offset_in_bytes());\n+  }\n+\n@@ -107,1 +117,1 @@\n-    while (i-- > 0 && _data[i] != x) ;\n+    while (i-- > 0 && data()[i] != x) ;\n@@ -115,3 +125,3 @@\n-  T    at(int i) const                 { assert(i >= 0 && i< _length, \"oob: 0 <= %d < %d\", i, _length); return _data[i]; }\n-  void at_put(const int i, const T& x) { assert(i >= 0 && i< _length, \"oob: 0 <= %d < %d\", i, _length); _data[i] = x; }\n-  T*   adr_at(const int i)             { assert(i >= 0 && i< _length, \"oob: 0 <= %d < %d\", i, _length); return &_data[i]; }\n+  T    at(int i) const                 { assert(i >= 0 && i< _length, \"oob: 0 <= %d < %d\", i, _length); return data()[i]; }\n+  void at_put(const int i, const T& x) { assert(i >= 0 && i< _length, \"oob: 0 <= %d < %d\", i, _length); data()[i] = x; }\n+  T*   adr_at(const int i)             { assert(i >= 0 && i< _length, \"oob: 0 <= %d < %d\", i, _length); return &data()[i]; }\n","filename":"src\/hotspot\/share\/oops\/array.hpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -231,0 +231,11 @@\n+const char* type2name(BasicType t) {\n+  if (t < ARRAY_SIZE(type2name_tab)) {\n+    return type2name_tab[t];\n+  } else if (t == T_ILLEGAL) {\n+    return \"*illegal*\";\n+  } else {\n+    fatal(\"invalid type %d\", t);\n+    return \"invalid type\";\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -721,2 +721,1 @@\n-extern const char* type2name_tab[T_CONFLICT+1];     \/\/ Map a BasicType to a jchar\n-inline const char* type2name(BasicType t) { return (uint)t < T_CONFLICT+1 ? type2name_tab[t] : NULL; }\n+extern const char* type2name_tab[T_CONFLICT+1];     \/\/ Map a BasicType to a char*\n@@ -725,0 +724,2 @@\n+const char* type2name(BasicType t);\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,2 @@\n-    char name[PATH_MAX + 2], *real;\n+    char name[PATH_MAX + 1], *real;\n+    int snprintf_result;\n@@ -124,2 +125,4 @@\n-    if ((JLI_StrLen(indir) + JLI_StrLen(cmd) + 1)  > PATH_MAX) return 0;\n-    JLI_Snprintf(name, sizeof(name), \"%s%c%s\", indir, FILE_SEPARATOR, cmd);\n+    snprintf_result = JLI_Snprintf(name, sizeof(name), \"%s%c%s\", indir, FILE_SEPARATOR, cmd);\n+    if ((snprintf_result < 0) || (snprintf_result >= (int)sizeof(name))) {\n+      return NULL;\n+    }\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md_common.c","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-        test(new JavaValue[]{reg.asValue()}, new JavaKind[]{JavaKind.Illegal}, 1, 0, 0);\n+        test(new JavaValue[]{reg.asValue()}, new JavaKind[]{JavaKind.Void}, 1, 0, 0);\n@@ -162,1 +162,1 @@\n-        test(new JavaValue[]{reg.asValue()}, new JavaKind[]{JavaKind.Illegal}, 1, 0, 0);\n+        test(new JavaValue[]{reg.asValue()}, new JavaKind[]{JavaKind.Void}, 1, 0, 0);\n@@ -169,1 +169,1 @@\n-        test(new JavaValue[]{value}, new JavaKind[]{JavaKind.Illegal}, 1, 0, 0);\n+        test(new JavaValue[]{value}, new JavaKind[]{JavaKind.Void}, 1, 0, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/errors\/TestInvalidDebugInfo.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}