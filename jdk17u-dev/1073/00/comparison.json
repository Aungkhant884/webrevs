{"files":[{"patch":"@@ -968,7 +968,8 @@\n-inline void\n-ReferenceProcessor::add_to_discovered_list_mt(DiscoveredList& refs_list,\n-                                              oop             obj,\n-                                              HeapWord*       discovered_addr) {\n-  assert(_discovery_is_mt, \"!_discovery_is_mt should have been handled by caller\");\n-  \/\/ First we must make sure this object is only enqueued once. CAS in a non null\n-  \/\/ discovered_addr.\n+inline bool ReferenceProcessor::set_discovered_link(HeapWord* discovered_addr, oop next_discovered) {\n+  return discovery_is_mt() ? set_discovered_link_mt(discovered_addr, next_discovered)\n+                           : set_discovered_link_st(discovered_addr, next_discovered);\n+}\n+\n+inline void ReferenceProcessor::add_to_discovered_list(DiscoveredList& refs_list,\n+                                                       oop obj,\n+                                                       HeapWord* discovered_addr) {\n@@ -976,1 +977,2 @@\n-  \/\/ The last ref must have its discovered field pointing to itself.\n+  \/\/ Prepare value to put into the discovered field. The last ref must have its\n+  \/\/ discovered field pointing to itself.\n@@ -979,1 +981,12 @@\n-  oop retest = HeapAccess<AS_NO_KEEPALIVE>::oop_atomic_cmpxchg(discovered_addr, oop(NULL), next_discovered);\n+  bool added = set_discovered_link(discovered_addr, next_discovered);\n+  if (added) {\n+    \/\/ We can always add the object without synchronization: every thread has its\n+    \/\/ own list head.\n+    refs_list.add_as_head(obj);\n+    log_develop_trace(gc, ref)(\"Discovered reference (%s) (\" INTPTR_FORMAT \": %s)\",\n+                               discovery_is_mt() ? \"mt\" : \"st\", p2i(obj), obj->klass()->internal_name());\n+  } else {\n+    log_develop_trace(gc, ref)(\"Already discovered reference (mt) (\" INTPTR_FORMAT \": %s)\",\n+                               p2i(obj), obj->klass()->internal_name());\n+  }\n+}\n@@ -981,6 +994,3 @@\n-  if (retest == NULL) {\n-    \/\/ This thread just won the right to enqueue the object.\n-    \/\/ We have separate lists for enqueueing, so no synchronization\n-    \/\/ is necessary.\n-    refs_list.set_head(obj);\n-    refs_list.inc_length(1);\n+inline bool ReferenceProcessor::set_discovered_link_st(HeapWord* discovered_addr,\n+                                                       oop next_discovered) {\n+  assert(!discovery_is_mt(), \"must be\");\n@@ -988,2 +998,4 @@\n-    log_develop_trace(gc, ref)(\"Discovered reference (mt) (\" INTPTR_FORMAT \": %s)\",\n-                               p2i(obj), obj->klass()->internal_name());\n+  if (discovery_is_atomic()) {\n+    \/\/ Do a raw store here: the field will be visited later when processing\n+    \/\/ the discovered references.\n+    RawAccess<>::oop_store(discovered_addr, next_discovered);\n@@ -991,4 +1003,1 @@\n-    \/\/ If retest was non NULL, another thread beat us to it:\n-    \/\/ The reference has already been discovered...\n-    log_develop_trace(gc, ref)(\"Already discovered reference (\" INTPTR_FORMAT \": %s)\",\n-                               p2i(obj), obj->klass()->internal_name());\n+    HeapAccess<AS_NO_KEEPALIVE>::oop_store(discovered_addr, next_discovered);\n@@ -996,0 +1005,18 @@\n+  \/\/ Always successful.\n+  return true;\n+}\n+\n+inline bool ReferenceProcessor::set_discovered_link_mt(HeapWord* discovered_addr,\n+                                                       oop next_discovered) {\n+  assert(discovery_is_mt(), \"must be\");\n+\n+  \/\/ We must make sure this object is only enqueued once. Try to CAS into the discovered_addr.\n+  oop retest;\n+  if (discovery_is_atomic()) {\n+    \/\/ Try a raw store here, still making sure that we enqueue only once: the field\n+    \/\/ will be visited later when processing the discovered references.\n+    retest = RawAccess<>::oop_atomic_cmpxchg(discovered_addr, oop(NULL), next_discovered);\n+  } else {\n+    retest = HeapAccess<AS_NO_KEEPALIVE>::oop_atomic_cmpxchg(discovered_addr, oop(NULL), next_discovered);\n+  }\n+  return retest == NULL;\n@@ -1130,8 +1157,1 @@\n-  if (_discovery_is_mt) {\n-    add_to_discovered_list_mt(*list, obj, discovered_addr);\n-  } else {\n-    \/\/ We do a raw store here: the field will be visited later when processing\n-    \/\/ the discovered references.\n-    oop current_head = list->head();\n-    \/\/ The last ref must have its discovered field pointing to itself.\n-    oop next_discovered = (current_head != NULL) ? current_head : obj;\n+  add_to_discovered_list(*list, obj, discovered_addr);\n@@ -1139,7 +1159,0 @@\n-    assert(discovered == NULL, \"control point invariant\");\n-    RawAccess<>::oop_store(discovered_addr, next_discovered);\n-    list->set_head(obj);\n-    list->inc_length(1);\n-\n-    log_develop_trace(gc, ref)(\"Discovered reference (\" INTPTR_FORMAT \": %s)\", p2i(obj), obj->klass()->internal_name());\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":49,"deletions":36,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  inline void add_as_head(oop o);\n@@ -344,2 +345,7 @@\n-  inline void add_to_discovered_list_mt(DiscoveredList& refs_list, oop obj,\n-                                        HeapWord* discovered_addr);\n+  inline bool set_discovered_link(HeapWord* discovered_addr, oop next_discovered);\n+  inline void add_to_discovered_list(DiscoveredList& refs_list, oop obj,\n+                                     HeapWord* discovered_addr);\n+  inline bool set_discovered_link_st(HeapWord* discovered_addr,\n+                                     oop next_discovered);\n+  inline bool set_discovered_link_mt(HeapWord* discovered_addr,\n+                                     oop next_discovered);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+void DiscoveredList::add_as_head(oop o) {\n+  set_head(o);\n+  inc_length(1);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}