{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-      live = new (Compile::current()->comp_arena()->Amalloc_D(sizeof(RegMask))) RegMask();\n+      live = new (Compile::current()->comp_arena()->Amalloc_4(sizeof(RegMask))) RegMask();\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -35,8 +36,3 @@\n-\/\/ The byte alignment to be used by Arena::Amalloc.  See bugid 4169348.\n-\/\/ Note: this value must be a power of 2\n-\n-#define ARENA_AMALLOC_ALIGNMENT (2*BytesPerWord)\n-\n-#define ARENA_ALIGN_M1 (((size_t)(ARENA_AMALLOC_ALIGNMENT)) - 1)\n-#define ARENA_ALIGN_MASK (~((size_t)ARENA_ALIGN_M1))\n-#define ARENA_ALIGN(x) ((((size_t)(x)) + ARENA_ALIGN_M1) & ARENA_ALIGN_MASK)\n+\/\/ The byte alignment to be used by Arena::Amalloc.\n+#define ARENA_AMALLOC_ALIGNMENT BytesPerLong\n+#define ARENA_ALIGN(x) (align_up((x), ARENA_AMALLOC_ALIGNMENT))\n@@ -139,1 +135,2 @@\n-  \/\/ Fast allocate in the arena.  Common case is: pointer test + increment.\n+  \/\/ Fast allocate in the arena.  Common case aligns to the size of jlong which is 64 bits\n+  \/\/ on both 32 and 64 bit platforms. Required for atomic jlong operations on 32 bits.\n@@ -141,1 +138,0 @@\n-    assert(is_power_of_2(ARENA_AMALLOC_ALIGNMENT) , \"should be a power of 2\");\n@@ -144,15 +140,1 @@\n-    if (!check_for_overflow(x, \"Arena::Amalloc\", alloc_failmode))\n-      return NULL;\n-    if (_hwm + x > _max) {\n-      return grow(x, alloc_failmode);\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n-  }\n-  \/\/ Further assume size is padded out to words\n-  void *Amalloc_4(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {\n-    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n-    debug_only(if (UseMallocOnly) return malloc(x);)\n-    if (!check_for_overflow(x, \"Arena::Amalloc_4\", alloc_failmode))\n+    if (!check_for_overflow(x, \"Arena::Amalloc\", alloc_failmode)) {\n@@ -160,1 +142,1 @@\n-    if (_hwm + x > _max) {\n+    } else if (_hwm + x > _max) {\n@@ -169,4 +151,4 @@\n-  \/\/ Allocate with 'double' alignment. It is 8 bytes on sparc.\n-  \/\/ In other cases Amalloc_D() should be the same as Amalloc_4().\n-  void* Amalloc_D(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {\n-    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n+  \/\/ Allocate in the arena, assuming the size has been aligned to size of pointer, which\n+  \/\/ is 4 bytes on 32 bits, hence the name.\n+  void* Amalloc_4(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {\n+    assert(is_aligned(x, BytesPerWord), \"misaligned size\");\n@@ -174,1 +156,1 @@\n-    if (!check_for_overflow(x, \"Arena::Amalloc_D\", alloc_failmode))\n+    if (!check_for_overflow(x, \"Arena::Amalloc_4\", alloc_failmode)) {\n@@ -176,2 +158,2 @@\n-    if (_hwm + x > _max) {\n-      return grow(x, alloc_failmode); \/\/ grow() returns a result aligned >= 8 bytes.\n+    } else if (_hwm + x > _max) {\n+      return grow(x, alloc_failmode);\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":15,"deletions":33,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    return C->node_arena()->Amalloc_D(x);\n+    return C->node_arena()->Amalloc_4(x);\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-  RegMask *rms = (RegMask*)C->comp_arena()->Amalloc_D(sizeof(RegMask) * NOF_STACK_MASKS);\n+  RegMask *rms = (RegMask*)C->comp_arena()->Amalloc_4(sizeof(RegMask) * NOF_STACK_MASKS);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-    _in = (Node **) ((char *) (C->node_arena()->Amalloc_D(req * sizeof(void*))));\n+    _in = (Node **) ((char *) (C->node_arena()->Amalloc_4(req * sizeof(void*))));\n@@ -502,1 +502,1 @@\n-  Node *n = (Node*)C->node_arena()->Amalloc_D(size_of() + _max*sizeof(Node*));\n+  Node *n = (Node*)C->node_arena()->Amalloc_4(size_of() + _max*sizeof(Node*));\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-    Node* n = (Node*)C->node_arena()->Amalloc_D(x);\n+    Node* n = (Node*)C->node_arena()->Amalloc_4(x);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    return compile->type_arena()->Amalloc_D(x);\n+    return compile->type_arena()->Amalloc_4(x);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}