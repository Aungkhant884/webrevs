{"files":[{"patch":"@@ -1,247 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.jdi.Bootstrap;\n-import com.sun.jdi.VMDisconnectedException;\n-import com.sun.jdi.VirtualMachine;\n-import com.sun.jdi.connect.Connector;\n-import com.sun.jdi.connect.LaunchingConnector;\n-import com.sun.jdi.event.Event;\n-import com.sun.jdi.event.EventSet;\n-import com.sun.jdi.event.MethodEntryEvent;\n-import com.sun.jdi.request.MethodEntryRequest;\n-\n-import java.security.AlgorithmParameters;\n-import java.security.KeyPair;\n-import java.security.KeyPairGenerator;\n-import java.security.SecureRandom;\n-import java.security.Signature;\n-import java.security.SignatureException;\n-import java.security.interfaces.ECPrivateKey;\n-import java.security.interfaces.ECPublicKey;\n-import java.security.spec.ECGenParameterSpec;\n-import java.security.spec.ECParameterSpec;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-\n-\/*\n- * @test\n- * @bug 8237218 8239928\n- * @modules jdk.crypto.ec\n- *          jdk.jdi\n- * @requires os.family != \"windows\"\n- * @run main ECDSAJavaVerify debug\n- * @summary Support NIST Curves verification in java implementation.\n- *  This test does not run stable on Windows. VMDisconnectedException\n- *  might not be thrown at all.\n- *\/\n-\n-\/\/ ATTENTION: This test depends on method names inside the non-exported\n-\/\/ class sun.security.ec.ECDSASignature.\n-public class ECDSAJavaVerify {\n-\n-    static final String[] ALL_ALGS = new String[] {\n-            \"SHA1withECDSA\", \"SHA256withECDSA\", \"SHA384withECDSA\", \"SHA512withECDSA\"};\n-\n-    static final String[] ALL_CURVES = new String[] {\n-            \"secp256r1\", \"secp384r1\", \"secp521r1\"};\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 1) {\n-            \/\/ Debugging a new process with no arg\n-            debug();\n-        } else if (args.length == 3) {\n-            \/\/ If one test case fail, re-run it with first 3 columns\n-            new Test().run(Integer.parseInt(args[0]), args[1], args[2]);\n-        } else {\n-            \/\/ Run all test cases\n-            Test t = new Test();\n-            Random r = new Random();\n-\n-            for (String sigAlg : ALL_ALGS) {\n-                for (String curve : ALL_CURVES) {\n-                    t.run(r.nextInt(1000000), sigAlg, curve);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void debug() throws Exception {\n-\n-        LaunchingConnector launchingConnector = Bootstrap\n-                .virtualMachineManager().defaultConnector();\n-\n-        Map<String, Connector.Argument> arguments\n-                = launchingConnector.defaultArguments();\n-        arguments.get(\"main\").setValue(ECDSAJavaVerify.class.getName());\n-        arguments.get(\"options\").setValue(\n-                \"-cp \" + System.getProperty(\"test.classes\"));\n-        VirtualMachine vm = launchingConnector.launch(arguments);\n-\n-        MethodEntryRequest req = vm.eventRequestManager()\n-                .createMethodEntryRequest();\n-        req.addClassFilter(\"sun.security.ec.ECDSASignature\");\n-        req.enable();\n-\n-        int numberOfTests = ALL_ALGS.length * ALL_CURVES.length * 2;\n-\n-        \/\/ Expected methods to call. 'J' for java impl, 'N' for native impl\n-        char[] expected = new char[numberOfTests];\n-\n-        int pos = 0;\n-        for (String dummy : ALL_ALGS) {\n-            for (String curve : ALL_CURVES) {\n-                char caller = 'J';\n-                \/\/ For each case, Signature::verify is called twice\n-                expected[pos++] = caller;\n-                expected[pos++] = caller;\n-            }\n-        }\n-\n-        \/\/ Test result\n-        \/\/ '.': not run yet\n-        \/\/ '-': enter engineVerify\n-        \/\/ 'v': expected impl called\n-        \/\/ 'x': unexpected impl called\n-        \/\/ Note: some error cases fail before any impl called. Ex: if there\n-        \/\/ is a DER encoding error.\n-        char[] result = new char[numberOfTests];\n-        Arrays.fill(result, '.');\n-\n-        String stdout, stderr;\n-\n-        try {\n-            EventSet eventSet;\n-            pos = -1; \/\/ will become 0 when entering 'engineVerify'\n-            while ((eventSet = vm.eventQueue().remove()) != null) {\n-                for (Event event : eventSet) {\n-                    if (event instanceof MethodEntryEvent) {\n-                        MethodEntryEvent e = (MethodEntryEvent)event;\n-                        switch (e.method().name()) {\n-                            case \"engineVerify\":\n-                                result[++pos] = '-';\n-                                break;\n-                            case \"verifySignedDigestImpl\": \/\/ the java impl\n-                                result[pos] = expected[pos] != 'J' ? 'x' : 'v';\n-                                break;\n-                        }\n-                    }\n-                    vm.resume();\n-                }\n-            }\n-        } catch (VMDisconnectedException e) {\n-            System.out.println(\"Virtual Machine is disconnected.\");\n-        } finally {\n-            stderr = new String(vm.process().getErrorStream().readAllBytes());\n-            stdout = new String(vm.process().getInputStream().readAllBytes());\n-        }\n-\n-        int exitCode = vm.process().waitFor();\n-        System.out.println(\"  exit: \" + exitCode);\n-        System.out.println(\"stderr:\\n\" + stderr);\n-        System.out.println(\"stdout:\\n\" + stdout);\n-\n-        String sResult = new String(result);\n-\n-        System.out.println(\" Cases: \" + new String(expected));\n-        System.out.println(\"Result: \" + sResult);\n-\n-        if (pos != numberOfTests - 1 || sResult.contains(\"x\")\n-                || sResult.contains(\".\")) {\n-            throw new Exception(\"Unexpected result\");\n-        }\n-\n-        if (stdout.contains(\"fail\") || exitCode != 0) {\n-            throw new Exception(\"Test failed\");\n-        }\n-    }\n-\n-    static class Test {\n-\n-        public boolean run(int seed, String sigAlg, String curve)\n-                throws Exception {\n-\n-            \/\/ A determined SecureRandom based on seed. If there is anything\n-            \/\/ wrong, we can reproduce the problem using the seed.\n-            Random r = new Random(seed);\n-            SecureRandom rand = new SecureRandom() {\n-                @Override\n-                public void nextBytes(byte[] bytes) {\n-                    r.nextBytes(bytes);\n-                }\n-            };\n-\n-            AlgorithmParameters ap = AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n-            ap.init(new ECGenParameterSpec(curve));\n-            ECParameterSpec spec = ap.getParameterSpec(ECParameterSpec.class);\n-\n-            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n-            kpg.initialize(spec, rand);\n-            KeyPair kp = kpg.generateKeyPair();\n-            ECPrivateKey ecPrivateKey = (ECPrivateKey) kp.getPrivate();\n-            ECPublicKey ecPublicKey = (ECPublicKey) kp.getPublic();\n-\n-            Signature s1 = Signature.getInstance(sigAlg, \"SunEC\");\n-            s1.initSign(ecPrivateKey, rand);\n-            byte[] msg = new byte[1234];\n-            rand.nextBytes(msg);\n-            s1.update(msg);\n-            byte[] sig = s1.sign();\n-\n-            Signature s2 = Signature.getInstance(sigAlg, \"SunEC\");\n-            s2.initVerify(ecPublicKey);\n-            s2.update(msg);\n-\n-            boolean result1 = s2.verify(sig);\n-\n-            s2.initVerify(ecPublicKey);\n-            \/\/ modify the signature in some random manner\n-            if (rand.nextInt(10) < 8) {\n-                sig[rand.nextInt(10000) % sig.length]\n-                        = (byte) rand.nextInt(10000);\n-            } else {\n-                int newLength = rand.nextInt(100);\n-                if (newLength == sig.length) {\n-                    newLength += 1 + rand.nextInt(2);\n-                }\n-                sig = Arrays.copyOf(sig, newLength);\n-            }\n-\n-            boolean result2;\n-            try {\n-                result2 = s2.verify(sig);\n-            } catch (SignatureException se) {\n-                result2 = false;\n-            }\n-\n-            boolean finalResult = result1 && !result2;\n-            System.out.printf(\"%10d %20s %20s -- %5s %5s -- %s\\n\",\n-                    seed, sigAlg, curve, result1, result2,\n-                    finalResult ? \"succeed\" : \"fail\");\n-\n-            return finalResult;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ec\/ECDSAJavaVerify.java","additions":0,"deletions":247,"binary":false,"changes":247,"status":"deleted"}]}