{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"Executor.h\"\n@@ -160,11 +161,13 @@\n-        STARTUPINFOW si;\n-        ZeroMemory(&si, sizeof(si));\n-        si.cb = sizeof(si);\n-\n-        PROCESS_INFORMATION pi;\n-        ZeroMemory(&pi, sizeof(pi));\n-\n-        if (!CreateProcessW(launcherPath.c_str(), GetCommandLineW(),\n-                NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n-            JP_THROW(SysError(tstrings::any() << \"CreateProcessW() failed\",\n-                                                            CreateProcessW));\n+        UniqueHandle jobHandle(CreateJobObject(NULL, NULL));\n+        if (jobHandle.get() == NULL) {\n+            JP_THROW(SysError(tstrings::any() << \"CreateJobObject() failed\",\n+                                                            CreateJobObject));\n+        }\n+        JOBOBJECT_EXTENDED_LIMIT_INFORMATION jobInfo = { };\n+        jobInfo.BasicLimitInformation.LimitFlags =\n+                                          JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;\n+        if (!SetInformationJobObject(jobHandle.get(),\n+                JobObjectExtendedLimitInformation, &jobInfo, sizeof(jobInfo))) {\n+            JP_THROW(SysError(tstrings::any() <<\n+                                            \"SetInformationJobObject() failed\",\n+                                                    SetInformationJobObject));\n@@ -173,4 +176,6 @@\n-        WaitForSingleObject(pi.hProcess, INFINITE);\n-\n-        UniqueHandle childProcessHandle(pi.hProcess);\n-        UniqueHandle childThreadHandle(pi.hThread);\n+        Executor exec(launcherPath);\n+        exec.visible(true).withJobObject(jobHandle.get()).suspended(true).inherit(true);\n+        const auto args = SysInfo::getCommandArgs();\n+        std::for_each(args.begin(), args.end(), [&exec] (const tstring& arg) {\n+            exec.arg(arg);\n+        });\n@@ -178,5 +183,1 @@\n-        DWORD exitCode;\n-        if (!GetExitCodeProcess(pi.hProcess, &exitCode)) {\n-            JP_THROW(SysError(tstrings::any() << \"GetExitCodeProcess() failed\",\n-                                                        GetExitCodeProcess));\n-        }\n+        DWORD exitCode = static_cast<DWORD>(exec.execAndWaitForExit());\n","filename":"src\/jdk.jpackage\/windows\/native\/applauncher\/WinLauncher.cpp","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <algorithm>\n+#include \"Executor.h\"\n+#include \"Log.h\"\n+#include \"WinErrorHandling.h\"\n+\n+\n+namespace {\n+\n+void escapeArg(std::wstring& str) {\n+    if (str.empty()) {\n+        return;\n+    }\n+\n+    if (str.front() == L'\\\"' && str.back() == L'\\\"' && str.size() > 1) {\n+        return;\n+    }\n+\n+    if (str.find_first_of(L\" \\t\") != std::wstring::npos) {\n+        str = L'\"' + str + L'\"';\n+    }\n+}\n+\n+} \/\/ namespace\n+\n+\n+std::wstring Executor::args() const {\n+    tstring_array tmpArgs;\n+    \/\/ argv[0] is the module name.\n+    tmpArgs.push_back(appPath);\n+    tmpArgs.insert(tmpArgs.end(), argsArray.begin(), argsArray.end());\n+\n+    std::for_each(tmpArgs.begin(), tmpArgs.end(), escapeArg);\n+    return tstrings::join(tmpArgs.begin(), tmpArgs.end(), _T(\" \"));\n+}\n+\n+\n+int Executor::execAndWaitForExit() const {\n+    UniqueHandle threadHandle;\n+    UniqueHandle h = startProcess(&threadHandle);\n+\n+    if (theSuspended) {\n+        LOG_TRACE(tstrings::any() << \"ResumeThread()\");\n+        if (((DWORD)-1) == ResumeThread(threadHandle.get())) {\n+            JP_THROW(SysError(\"ResumeThread() failed\", ResumeThread));\n+        }\n+    }\n+\n+    const DWORD res = ::WaitForSingleObject(h.get(), INFINITE);\n+    if (WAIT_FAILED ==  res) {\n+        JP_THROW(SysError(\"WaitForSingleObject() failed\", WaitForSingleObject));\n+    }\n+\n+    DWORD exitCode = 0;\n+    if (!GetExitCodeProcess(h.get(), &exitCode)) {\n+        \/\/ Error reading process's exit code.\n+        JP_THROW(SysError(\"GetExitCodeProcess() failed\", GetExitCodeProcess));\n+    }\n+\n+    const DWORD processId = GetProcessId(h.get());\n+    if (!processId) {\n+        JP_THROW(SysError(\"GetProcessId() failed.\", GetProcessId));\n+    }\n+\n+    LOG_TRACE(tstrings::any() << \"Process with PID=\" << processId\n+                                << \" terminated. Exit code=\" << exitCode);\n+\n+    return static_cast<int>(exitCode);\n+}\n+\n+\n+UniqueHandle Executor::startProcess(UniqueHandle* threadHandle) const {\n+    const std::wstring argsStr = args();\n+\n+    std::vector<TCHAR> argsBuffer(argsStr.begin(), argsStr.end());\n+    argsBuffer.push_back(0); \/\/ terminating '\\0'\n+\n+    STARTUPINFO startupInfo;\n+    ZeroMemory(&startupInfo, sizeof(startupInfo));\n+    startupInfo.cb = sizeof(startupInfo);\n+\n+    PROCESS_INFORMATION processInfo;\n+    ZeroMemory(&processInfo, sizeof(processInfo));\n+\n+    DWORD creationFlags = 0;\n+\n+    if (theSuspended) {\n+        creationFlags |= CREATE_SUSPENDED;\n+    }\n+\n+    if (!theVisible) {\n+        \/\/ For GUI applications.\n+        startupInfo.dwFlags |= STARTF_USESHOWWINDOW;\n+        startupInfo.wShowWindow = SW_HIDE;\n+\n+        \/\/ For console applications.\n+        creationFlags |= CREATE_NO_WINDOW;\n+    }\n+\n+    tstrings::any msg;\n+    msg << \"CreateProcess\";\n+    if (theSuspended) {\n+        msg << \"[suspended]\";\n+    }\n+    if (theVisible) {\n+        msg << \"[visible]\";\n+    }\n+    if (theInherit) {\n+        msg << \"[inherit]\";\n+    }\n+    msg << \"(\" << appPath << \", \" << argsStr << \")\";\n+\n+    if (!CreateProcess(appPath.c_str(), argsBuffer.data(), NULL, NULL,\n+                      theInherit ? TRUE : FALSE, creationFlags, NULL, NULL,\n+                      &startupInfo, &processInfo)) {\n+        msg << \" failed\";\n+        JP_THROW(SysError(msg, CreateProcess));\n+    }\n+\n+    msg << \" succeeded; PID=\" << processInfo.dwProcessId;\n+    LOG_TRACE(msg);\n+\n+    if (threadHandle) {\n+        *threadHandle = UniqueHandle(processInfo.hThread);\n+    } else {\n+        \/\/ Close unneeded handle immediately.\n+        UniqueHandle(processInfo.hThread);\n+    }\n+\n+    if (jobHandle != NULL) {\n+        LOG_TRACE(tstrings::any() << \"AssignProcessToJobObject(PID=\"\n+                << processInfo.dwProcessId << \")\");\n+        if (!AssignProcessToJobObject(jobHandle, processInfo.hProcess)) {\n+            JP_THROW(SysError(tstrings::any() <<\n+                    \"AssignProcessToJobObject() failed\",\n+                    AssignProcessToJobObject));\n+        }\n+    }\n+\n+    \/\/ Return process handle.\n+    return UniqueHandle(processInfo.hProcess);\n+}\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Executor.cpp","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef EXECUTOR_H\n+#define EXECUTOR_H\n+\n+#include \"tstrings.h\"\n+#include \"UniqueHandle.h\"\n+\n+\n+class Executor {\n+public:\n+    explicit Executor(const std::wstring& appPath=std::wstring()) {\n+        app(appPath).visible(false).suspended(false).withJobObject(NULL).inherit(false);\n+    }\n+\n+    \/**\n+     * Returns command line configured with arg() calls so far.\n+     *\/\n+    std::wstring args() const;\n+\n+    \/**\n+     * Set path to application to execute.\n+     *\/\n+    Executor& app(const std::wstring& v) {\n+        appPath = v;\n+        return *this;\n+    }\n+\n+    \/**\n+     * Adds another command line argument.\n+     *\/\n+    Executor& arg(const std::wstring& v) {\n+        argsArray.push_back(v);\n+        return *this;\n+    }\n+\n+    \/**\n+     * Controls if application window should be visible.\n+     *\/\n+    Executor& visible(bool v) {\n+        theVisible = v;\n+        return *this;\n+    }\n+\n+    \/**\n+     * Controls if the process should inherit handles.\n+     *\/\n+    Executor& inherit(bool v) {\n+        theInherit = v;\n+        return *this;\n+    }\n+\n+    \/**\n+     * Controls if the process should be started suspended.\n+     *\/\n+    Executor& suspended(bool v) {\n+        theSuspended = v;\n+        return *this;\n+    }\n+\n+    \/**\n+     * Use the given job object with started process.\n+     *\/\n+    Executor& withJobObject(HANDLE v) {\n+        jobHandle = v;\n+        return *this;\n+    }\n+\n+    \/**\n+     * Starts application process and blocks waiting when the started\n+     * process terminates.\n+     * Returns process exit code.\n+     * Throws exception if process start failed.\n+     *\/\n+    int execAndWaitForExit() const;\n+\n+private:\n+    UniqueHandle startProcess(UniqueHandle* threadHandle=0) const;\n+\n+    bool theVisible;\n+    bool theInherit;\n+    bool theSuspended;\n+    HANDLE jobHandle;\n+    tstring_array argsArray;\n+    std::wstring appPath;\n+};\n+\n+#endif \/\/ #ifndef EXECUTOR_H\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Executor.h","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <algorithm>\n-#include \"Executor.h\"\n-#include \"Log.h\"\n-#include \"WinErrorHandling.h\"\n-\n-\n-namespace {\n-\n-void escapeArg(std::wstring& str) {\n-    if (str.empty()) {\n-        return;\n-    }\n-\n-    if (str.front() == L'\\\"' && str.back() == L'\\\"' && str.size() > 1) {\n-        return;\n-    }\n-\n-    if (str.find_first_of(L\" \\t\") != std::wstring::npos) {\n-        str = L'\"' + str + L'\"';\n-    }\n-}\n-\n-} \/\/ namespace\n-\n-\n-std::wstring Executor::args() const {\n-    tstring_array tmpArgs;\n-    \/\/ argv[0] is the module name.\n-    tmpArgs.push_back(appPath);\n-    tmpArgs.insert(tmpArgs.end(), argsArray.begin(), argsArray.end());\n-\n-    std::for_each(tmpArgs.begin(), tmpArgs.end(), escapeArg);\n-    return tstrings::join(tmpArgs.begin(), tmpArgs.end(), _T(\" \"));\n-}\n-\n-\n-int Executor::execAndWaitForExit() const {\n-    UniqueHandle h = startProcess();\n-\n-    const DWORD res = ::WaitForSingleObject(h.get(), INFINITE);\n-    if (WAIT_FAILED ==  res) {\n-        JP_THROW(SysError(\"WaitForSingleObject() failed\", WaitForSingleObject));\n-    }\n-\n-    DWORD exitCode = 0;\n-    if (!GetExitCodeProcess(h.get(), &exitCode)) {\n-        \/\/ Error reading process's exit code.\n-        JP_THROW(SysError(\"GetExitCodeProcess() failed\", GetExitCodeProcess));\n-    }\n-\n-    const DWORD processId = GetProcessId(h.get());\n-    if (!processId) {\n-        JP_THROW(SysError(\"GetProcessId() failed.\", GetProcessId));\n-    }\n-\n-    LOG_TRACE(tstrings::any() << \"Process with PID=\" << processId\n-                                << \" terminated. Exit code=\" << exitCode);\n-\n-    return static_cast<int>(exitCode);\n-}\n-\n-\n-UniqueHandle Executor::startProcess() const {\n-    const std::wstring argsStr = args();\n-\n-    std::vector<TCHAR> argsBuffer(argsStr.begin(), argsStr.end());\n-    argsBuffer.push_back(0); \/\/ terminating '\\0'\n-\n-    STARTUPINFO startupInfo;\n-    ZeroMemory(&startupInfo, sizeof(startupInfo));\n-    startupInfo.cb = sizeof(startupInfo);\n-\n-    PROCESS_INFORMATION processInfo;\n-    ZeroMemory(&processInfo, sizeof(processInfo));\n-\n-    DWORD creationFlags = 0;\n-\n-    if (!theVisible) {\n-        \/\/ For GUI applications.\n-        startupInfo.dwFlags |= STARTF_USESHOWWINDOW;\n-        startupInfo.wShowWindow = SW_HIDE;\n-\n-        \/\/ For console applications.\n-        creationFlags |= CREATE_NO_WINDOW;\n-    }\n-\n-    tstrings::any msg;\n-    msg << \"CreateProcess(\" << appPath << \", \" << argsStr << \")\";\n-\n-    if (!CreateProcess(appPath.c_str(), argsBuffer.data(), NULL, NULL, FALSE,\n-                    creationFlags, NULL, NULL, &startupInfo, &processInfo)) {\n-        msg << \" failed\";\n-        JP_THROW(SysError(msg, CreateProcess));\n-    }\n-\n-    msg << \" succeeded; PID=\" << processInfo.dwProcessId;\n-    LOG_TRACE(msg);\n-\n-    \/\/ Close unneeded handles immediately.\n-    UniqueHandle(processInfo.hThread);\n-\n-    \/\/ Return process handle.\n-    return UniqueHandle(processInfo.hProcess);\n-}\n","filename":"src\/jdk.jpackage\/windows\/native\/msiwrapper\/Executor.cpp","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef EXECUTOR_H\n-#define EXECUTOR_H\n-\n-#include \"tstrings.h\"\n-#include \"UniqueHandle.h\"\n-\n-\n-class Executor {\n-public:\n-    explicit Executor(const std::wstring& appPath=std::wstring()) {\n-        app(appPath).visible(false);\n-    }\n-\n-    \/**\n-     * Returns command line configured with arg() calls so far.\n-     *\/\n-    std::wstring args() const;\n-\n-    \/**\n-     * Set path to application to execute.\n-     *\/\n-    Executor& app(const std::wstring& v) {\n-        appPath = v;\n-        return *this;\n-    }\n-\n-    \/**\n-     * Adds another command line argument.\n-     *\/\n-    Executor& arg(const std::wstring& v) {\n-        argsArray.push_back(v);\n-        return *this;\n-    }\n-\n-    \/**\n-     * Controls if application window should be visible.\n-     *\/\n-    Executor& visible(bool v) {\n-        theVisible = v;\n-        return *this;\n-    }\n-\n-    \/**\n-     * Starts application process and blocks waiting when the started\n-     * process terminates.\n-     * Returns process exit code.\n-     * Throws exception if process start failed.\n-     *\/\n-    int execAndWaitForExit() const;\n-\n-private:\n-    UniqueHandle startProcess() const;\n-\n-    bool theVisible;\n-    tstring_array argsArray;\n-    std::wstring appPath;\n-};\n-\n-#endif \/\/ #ifndef EXECUTOR_H\n","filename":"src\/jdk.jpackage\/windows\/native\/msiwrapper\/Executor.h","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.TKit;\n+\n+\/**\n+ * Test that terminating of the parent app launcher process automatically\n+ * terminates child app launcher process.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test case for JDK-8301247\n+ * @library ..\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @build Win8301247Test\n+ * @requires (os.family == \"windows\")\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm\/timeout=360 -Xmx512m  jdk.jpackage.test.Main\n+ *  --jpt-run=Win8301247Test\n+ *\/\n+public class Win8301247Test {\n+\n+    @Test\n+    public void test() throws IOException, InterruptedException {\n+        JPackageCommand cmd = JPackageCommand.helloAppImage();\n+\n+        \/\/ Launch the app in a way it doesn't exit to let us trap app laucnher\n+        \/\/ processes in the process list\n+        cmd.addArguments(\"--java-options\", \"-Djpackage.test.noexit=true\");\n+        cmd.executeAndAssertImageCreated();\n+\n+        if (!cmd.canRunLauncher(\"Not running the test\")) {\n+            return;\n+        }\n+\n+        ExecutorService exec = null;\n+        try {\n+            \/\/ Launch the app in a separate thread\n+            exec = Executors.newSingleThreadExecutor();\n+            exec.execute(() -> {\n+                HelloApp.executeLauncher(cmd);\n+            });\n+\n+            \/\/ Wait a bit to let the app start\n+            Thread.sleep(10000);\n+\n+            \/\/ Get PID of the main app launcher process\n+            final long pid = findMainAppLauncherPID(cmd, 2).get();\n+\n+            \/\/ Kill the main app launcher process\n+            Executor.of(\"taskkill\", \"\/F\", \"\/PID\", Long.toString(pid)).\n+                    dumpOutput(true).execute();\n+\n+            \/\/ Wait a bit and check if child app launcher process is still running (it must NOT)\n+            Thread.sleep(5000);\n+\n+            findMainAppLauncherPID(cmd, 0);\n+        } finally {\n+            if (exec != null) {\n+                exec.shutdown();\n+            }\n+        }\n+    }\n+\n+    private static Optional<Long> findMainAppLauncherPID(JPackageCommand cmd,\n+            int expectedCount) {\n+        \/\/ Get the list of PIDs and PPIDs of app launcher processes.\n+        \/\/ wmic process where (name = \"foo.exe\") get ProcessID,ParentProcessID\n+        List<String> output = Executor.of(\"wmic\", \"process\", \"where\", \"(name\",\n+                \"=\",\n+                \"\\\"\" + cmd.appLauncherPath().getFileName().toString() + \"\\\"\",\n+                \")\", \"get\", \"ProcessID,ParentProcessID\").dumpOutput(true).\n+                saveOutput().executeAndGetOutput();\n+\n+        if (output.isEmpty()) {\n+            throw new NoSuchElementException();\n+        }\n+        String first = output.get(0);\n+\n+        if (expectedCount == 0) {\n+            TKit.assertEquals(\"No Instance(s) Available.\", first.\n+                    trim(), \"Check no app launcher processes found running\");\n+            return Optional.empty();\n+        }\n+\n+        String[] headers = Stream.of(first.split(\"\\\\s+\", 2)).map(\n+                String::trim).map(String::toLowerCase).toArray(String[]::new);\n+        Pattern pattern;\n+        if (headers[0].equals(\"parentprocessid\") && headers[1].equals(\n+                \"processid\")) {\n+            pattern = Pattern.compile(\"^(?<ppid>\\\\d+)\\\\s+(?<pid>\\\\d+)\\\\s+$\");\n+        } else if (headers[1].equals(\"parentprocessid\") && headers[0].equals(\n+                \"processid\")) {\n+            pattern = Pattern.compile(\"^(?<pid>\\\\d+)\\\\s+(?<ppid>\\\\d+)\\\\s+$\");\n+        } else {\n+            throw new RuntimeException(\n+                    \"Unrecognizable output of \\'wmic process\\' command\");\n+        }\n+\n+        List<long[]> processes = output.stream().skip(1).map(line -> {\n+            Matcher m = pattern.matcher(line);\n+            long[] pids = null;\n+            if (m.matches()) {\n+                pids = new long[]{Long.parseLong(m.group(\"pid\")), Long.\n+                    parseLong(m.group(\"ppid\"))};\n+            }\n+            return pids;\n+        }).filter(Objects::nonNull).toList();\n+\n+        TKit.assertEquals(expectedCount, processes.size(), String.format(\n+                \"Check [%d] app launcher processes found running\", expectedCount));\n+\n+        switch (expectedCount) {\n+            case 2 -> {\n+                if (processes.get(0)[0] == processes.get(1)[1]) {\n+                    return Optional.of(processes.get(0)[0]);\n+                } else if (processes.get(1)[0] == processes.get(0)[1]) {\n+                    return Optional.of(processes.get(1)[0]);\n+                } else {\n+                    throw new RuntimeException(\n+                            \"App launcher processes unrelated\");\n+                }\n+            }\n+            default ->\n+                throw new IllegalArgumentException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/Win8301247Test.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}