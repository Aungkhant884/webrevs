{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -648,1 +648,1 @@\n-                r = Math.nextAfter(r, origin);\n+                r = Math.nextAfter(bound, origin);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8280550\n+ * @bug 8280550 8280950\n@@ -31,0 +31,1 @@\n+import java.util.random.RandomGenerator;\n@@ -34,0 +35,5 @@\n+        negativeBounds();\n+        positiveBounds();\n+    }\n+\n+    private static void negativeBounds() {\n@@ -52,0 +58,33 @@\n+\n+    private static void positiveBounds() {\n+        double[][] originAndBounds = {{10, 100},\n+                                      {12345, 123456},\n+                                      {5432167.234, 54321678.1238}};\n+        for (double[] originAndBound : originAndBounds) {\n+            nextDoublesWithRange(originAndBound[0], originAndBound[1]);\n+        }\n+    }\n+\n+    public static void nextDoublesWithRange(double origin, double bound) {\n+        RandomGenerator rg = new RandomGenerator() {\n+            @Override\n+            public double nextDouble() {\n+                return Double.MAX_VALUE;\n+            }\n+\n+            @Override\n+            public long nextLong() {\n+                return 0;\n+            }\n+        };\n+        double value = rg.nextDouble(origin, bound);\n+\n+        assertTrue(value >= origin);\n+        assertTrue(value < bound);\n+    }\n+\n+    public static void assertTrue(boolean condition) {\n+        if (!condition) {\n+            throw new AssertionError();\n+        }\n+    }\n","filename":"test\/jdk\/java\/util\/Random\/RandomNextDoubleBoundary.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"}]}