{"files":[{"patch":"@@ -640,1 +640,0 @@\n-javax\/net\/ssl\/SSLEngine\/CheckStatus.java                        8298872 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,714 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4948079\n- * @summary SSLEngineResult needs updating [none yet]\n- *\n- * @run main\/othervm -Djsse.enableCBCProtection=false CheckStatus\n- *\n- * @author Brad Wetmore\n- *\/\n-\n-\/*\n- * This is a simple hack to test a bunch of conditions and check\n- * their return codes.\n- *\/\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n-\n-public class CheckStatus {\n-\n-    private static boolean debug = true;\n-\n-    private SSLContext sslc;\n-    private SSLEngine ssle1;    \/\/ client\n-    private SSLEngine ssle2;    \/\/ server\n-\n-    private static String pathToStores = \"..\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-    private ByteBuffer appOut1;         \/\/ write side of ssle1\n-    private ByteBuffer appIn1;          \/\/ read side of ssle1\n-    private ByteBuffer appOut2;         \/\/ write side of ssle2\n-    private ByteBuffer appIn2;          \/\/ read side of ssle2\n-\n-    private ByteBuffer oneToTwo;        \/\/ \"reliable\" transport ssle1->ssle2\n-    private ByteBuffer twoToOne;        \/\/ \"reliable\" transport ssle2->ssle1\n-\n-    \/*\n-     * Majority of the test case is here, setup is done below.\n-     *\/\n-\n-    private void createSSLEngines() throws Exception {\n-        ssle1 = sslc.createSSLEngine(\"client\", 1);\n-        ssle1.setUseClientMode(true);\n-\n-        ssle2 = sslc.createSSLEngine(\"server\", 2);\n-        ssle2.setUseClientMode(false);\n-    }\n-\n-    private boolean isHandshaking(SSLEngine e) {\n-        return (e.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING);\n-    }\n-\n-    private void checkResult(ByteBuffer bbIn, ByteBuffer bbOut,\n-            SSLEngineResult result,\n-            Status status, HandshakeStatus hsStatus,\n-            int consumed, int produced)\n-            throws Exception {\n-\n-        if ((status != null) && (result.getStatus() != status)) {\n-            throw new Exception(\"Unexpected Status: need = \" + status +\n-                \" got = \" + result.getStatus());\n-        }\n-\n-        if ((hsStatus != null) && (result.getHandshakeStatus() != hsStatus)) {\n-            throw new Exception(\"Unexpected hsStatus: need = \" + hsStatus +\n-                \" got = \" + result.getHandshakeStatus());\n-        }\n-\n-        if ((consumed != -1) && (consumed != result.bytesConsumed())) {\n-            throw new Exception(\"Unexpected consumed: need = \" + consumed +\n-                \" got = \" + result.bytesConsumed());\n-        }\n-\n-        if ((produced != -1) && (produced != result.bytesProduced())) {\n-            throw new Exception(\"Unexpected produced: need = \" + produced +\n-                \" got = \" + result.bytesProduced());\n-        }\n-\n-        if ((consumed != -1) && (bbIn.position() != result.bytesConsumed())) {\n-            throw new Exception(\"Consumed \" + bbIn.position() +\n-                \" != \" + consumed);\n-        }\n-\n-        if ((produced != -1) && (bbOut.position() != result.bytesProduced())) {\n-            throw new Exception(\"produced \" + bbOut.position() +\n-                \" != \" + produced);\n-        }\n-    }\n-\n-    private void test() throws Exception {\n-        createSSLEngines();\n-        createBuffers();\n-\n-        SSLEngineResult result1;        \/\/ ssle1's results from last operation\n-        SSLEngineResult result2;        \/\/ ssle2's results from last operation\n-\n-        String [] suite1 = new String [] {\n-            \"SSL_RSA_WITH_RC4_128_MD5\" };\n-        String [] suite2 = new String [] {\n-            \"SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA\" };\n-\n-        ssle1.setEnabledCipherSuites(suite1);\n-        ssle2.setEnabledCipherSuites(suite1);\n-\n-        log(\"================\");\n-\n-        log(\"unexpected empty unwrap\");\n-        twoToOne.limit(0);\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_WRAP, 0, 0);\n-        twoToOne.limit(twoToOne.capacity());\n-\n-        log(\"======================================\");\n-        log(\"client hello\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n-        runDelegatedTasks(ssle2);\n-\n-        oneToTwo.compact();\n-\n-        log(\"Check for unwrap when wrap needed\");\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result2,\n-            Status.OK, HandshakeStatus.NEED_WRAP, 0, 0);\n-\n-        log(\"======================================\");\n-        log(\"ServerHello\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        runDelegatedTasks(ssle1);\n-\n-        log(\"======================================\");\n-        log(\"Key Exchange\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n-        runDelegatedTasks(ssle2);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CCS\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP,\n-             result1.bytesProduced(), 0);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"Finished\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_WRAP, result1.bytesProduced(), 0);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CCS\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        log(\"======================================\");\n-        log(\"FINISHED\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.FINISHED, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        log(\"======================================\");\n-        log(\"Check Session\/Ciphers\");\n-\n-        String suite = ssle1.getSession().getCipherSuite();\n-        if (!suite.equals(suite1[0])) {\n-            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n-                suite1[0]);\n-        }\n-\n-        suite = ssle2.getSession().getCipherSuite();\n-        if (!suite.equals(suite1[0])) {\n-            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n-                suite1[0]);\n-        }\n-\n-        log(\"======================================\");\n-        log(\"DATA\");\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            appOut1.capacity(), -1);\n-        oneToTwo.flip();\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            appOut2.capacity(), -1);\n-        twoToOne.flip();\n-\n-        SSLEngineResult result3 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result3,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            result2.bytesProduced(), result2.bytesConsumed());\n-        twoToOne.compact();\n-\n-        SSLEngineResult result4 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result4,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            result1.bytesProduced(), result1.bytesConsumed());\n-        oneToTwo.compact();\n-\n-        appIn1.clear();\n-        appIn2.clear();\n-        appOut1.rewind();\n-        appOut2.rewind();\n-\n-        log(\"======================================\");\n-        log(\"RENEGOTIATE\");\n-\n-        ssle2.getSession().invalidate();\n-        ssle2.setNeedClientAuth(true);\n-\n-        ssle1.setEnabledCipherSuites(suite2);\n-        ssle2.setEnabledCipherSuites(suite2);\n-\n-        ssle2.beginHandshake();\n-\n-        log(\"======================================\");\n-        log(\"HelloRequest\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        runDelegatedTasks(ssle1);\n-\n-        log(\"======================================\");\n-        log(\"ClientHello\");\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n-        runDelegatedTasks(ssle2);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CLIENT->SERVER DATA IN MIDDLE OF HANDSHAKE\");\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP,\n-            appOut1.capacity(), -1);\n-        oneToTwo.flip();\n-\n-        result4 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result4,\n-            Status.OK, HandshakeStatus.NEED_WRAP,\n-            result1.bytesProduced(), result1.bytesConsumed());\n-        oneToTwo.compact();\n-\n-        appIn2.clear();\n-        appOut1.rewind();\n-\n-        log(\"======================================\");\n-        log(\"ServerHello\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        runDelegatedTasks(ssle1);\n-\n-        log(\"======================================\");\n-        log(\"SERVER->CLIENT DATA IN MIDDLE OF HANDSHAKE\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP,\n-            appOut2.capacity(), -1);\n-        twoToOne.flip();\n-\n-        result3 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result3,\n-            Status.OK, HandshakeStatus.NEED_WRAP,\n-            result2.bytesProduced(), result2.bytesConsumed());\n-        twoToOne.compact();\n-\n-        appIn1.clear();\n-        appOut2.rewind();\n-\n-        log(\"======================================\");\n-        log(\"Client Cert and Key Exchange\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n-        runDelegatedTasks(ssle2);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CCS\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP,\n-             result1.bytesProduced(), 0);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"Finished\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_WRAP, result1.bytesProduced(), 0);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CCS\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        log(\"======================================\");\n-        log(\"FINISHED\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.FINISHED, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        log(\"======================================\");\n-        log(\"Check Session\/Ciphers\");\n-\n-        suite = ssle1.getSession().getCipherSuite();\n-        if (!suite.equals(suite2[0])) {\n-            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n-                suite2[0]);\n-        }\n-\n-        suite = ssle2.getSession().getCipherSuite();\n-        if (!suite.equals(suite2[0])) {\n-            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n-                suite2[0]);\n-        }\n-\n-        log(\"======================================\");\n-        log(\"DATA USING NEW SESSION\");\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            appOut1.capacity(), -1);\n-        oneToTwo.flip();\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            appOut2.capacity(), -1);\n-        twoToOne.flip();\n-\n-        result3 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result3,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            result2.bytesProduced(), result2.bytesConsumed());\n-        twoToOne.compact();\n-\n-        result4 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result4,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            result1.bytesProduced(), result1.bytesConsumed());\n-        oneToTwo.compact();\n-\n-        appIn1.clear();\n-        appIn2.clear();\n-        appOut1.rewind();\n-        appOut2.rewind();\n-\n-        log(\"======================================\");\n-        log(\"CN\");\n-\n-        if (isHandshaking(ssle1)) {\n-            throw new Exception(\"ssle1 IS handshaking\");\n-        }\n-\n-        if (isHandshaking(ssle2)) {\n-            throw new Exception(\"ssle2 IS handshaking\");\n-        }\n-\n-        ssle2.closeOutbound();\n-\n-        if (!isHandshaking(ssle2)) {\n-            throw new Exception(\"ssle1 IS NOT handshaking\");\n-        }\n-\n-        appOut1.rewind();\n-        appOut2.rewind();\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.CLOSED, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        if (ssle1.isInboundDone()) {\n-            throw new Exception(\"ssle1 inboundDone\");\n-        }\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.CLOSED, HandshakeStatus.NEED_WRAP,\n-            result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        if (!ssle1.isInboundDone()) {\n-            throw new Exception(\"ssle1 inboundDone\");\n-        }\n-\n-        if (!isHandshaking(ssle1)) {\n-            throw new Exception(\"ssle1 IS NOT handshaking\");\n-        }\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.CLOSED, HandshakeStatus.NEED_UNWRAP, 0, 0);\n-        twoToOne.flip();\n-\n-        log(\"======================================\");\n-        log(\"CN response\");\n-\n-        if (ssle1.isOutboundDone()) {\n-            throw new Exception(\"ssle1 outboundDone\");\n-        }\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING, 0, -1);\n-\n-        if (!ssle1.isOutboundDone()) {\n-            throw new Exception(\"ssle1 outboundDone is NOT done\");\n-        }\n-\n-        if (isHandshaking(ssle1)) {\n-            throw new Exception(\"ssle1 IS handshaking\");\n-        }\n-\n-        oneToTwo.flip();\n-\n-        if (!ssle2.isOutboundDone()) {\n-            throw new Exception(\"ssle1 outboundDone\");\n-        }\n-\n-        if (ssle2.isInboundDone()) {\n-            throw new Exception(\"ssle1 inboundDone\");\n-        }\n-\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING,\n-             result1.bytesProduced(), 0);\n-\n-        if (!ssle2.isOutboundDone()) {\n-            throw new Exception(\"ssle1 outboundDone is NOT done\");\n-        }\n-\n-        if (!ssle2.isInboundDone()) {\n-            throw new Exception(\"ssle1 inboundDone is NOT done\");\n-        }\n-\n-        if (isHandshaking(ssle2)) {\n-            throw new Exception(\"ssle1 IS handshaking\");\n-        }\n-\n-        oneToTwo.compact();\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        \/\/ reset the security property to make sure that the algorithms\n-        \/\/ and keys used in this test are not disabled.\n-        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n-\n-        CheckStatus cs;\n-\n-        cs = new CheckStatus();\n-\n-        cs.createSSLEngines();\n-\n-        cs.test();\n-\n-        System.out.println(\"Test Passed.\");\n-    }\n-\n-    \/*\n-     * **********************************************************\n-     * Majority of the test case is above, below is just setup stuff\n-     * **********************************************************\n-     *\/\n-\n-    public CheckStatus() throws Exception {\n-        sslc = getSSLContext(keyFilename, trustFilename);\n-    }\n-\n-    \/*\n-     * Create an initialized SSLContext to use for this test.\n-     *\/\n-    private SSLContext getSSLContext(String keyFile, String trustFile)\n-            throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFile), passphrase);\n-        ts.load(new FileInputStream(trustFile), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        return sslCtx;\n-    }\n-\n-    private void createBuffers() {\n-        \/\/ Size the buffers as appropriate.\n-\n-        SSLSession session = ssle1.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        appIn1 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-        appIn2 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-\n-        oneToTwo = ByteBuffer.allocateDirect(netBufferMax);\n-        twoToOne = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        appOut1 = ByteBuffer.wrap(\"Hi Engine2, I'm SSLEngine1\".getBytes());\n-        appOut2 = ByteBuffer.wrap(\"Hello Engine1, I'm SSLEngine2\".getBytes());\n-\n-        log(\"AppOut1 = \" + appOut1);\n-        log(\"AppOut2 = \" + appOut2);\n-        log(\"\");\n-    }\n-\n-    private static void runDelegatedTasks(SSLEngine engine) throws Exception {\n-\n-        Runnable runnable;\n-        while ((runnable = engine.getDelegatedTask()) != null) {\n-            log(\"running delegated task...\");\n-            runnable.run();\n-        }\n-    }\n-\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"Data transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n-\n-    private static void log(String str) {\n-        if (debug) {\n-            System.out.println(str);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/CheckStatus.java","additions":0,"deletions":714,"binary":false,"changes":714,"status":"deleted"},{"patch":"@@ -0,0 +1,709 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4948079\n+ * @summary Verify return values from SSLEngine wrap\/unwrap (TLSv1.2) operations\n+ *\n+ * @run main CheckTlsEngineResults\n+ *\n+ * @author Brad Wetmore\n+ *\/\n+\n+\/*\n+ * This is a simple hack to test a bunch of conditions and check\n+ * their return codes.\n+ *\/\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.*;\n+import java.io.*;\n+import java.security.*;\n+import java.nio.*;\n+\n+public class CheckTlsEngineResults {\n+\n+    private final SSLContext SSL_CONTEXT;\n+    private SSLEngine clientEngine;    \/\/ client\n+    private SSLEngine serverEngine;    \/\/ server\n+\n+    private static final String PATH_TO_STORES = \"..\/etc\";\n+\n+    private static final String KEYSTORE_FILE = \"keystore\";\n+    private static final String TRUSTSTORE_FILE = \"truststore\";\n+\n+    private static final String keyFilename =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + KEYSTORE_FILE;\n+    private static final String trustFilename =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + TRUSTSTORE_FILE;\n+\n+    private ByteBuffer clientOut;         \/\/ write side of clientEngine\n+    private ByteBuffer clientIn;          \/\/ read side of clientEngine\n+    private ByteBuffer serverOut;         \/\/ write side of serverEngine\n+    private ByteBuffer serverIn;          \/\/ read side of serverEngine\n+\n+    private ByteBuffer clientToServer;        \/\/ \"reliable\" transport clientEngine->serverEngine\n+    private ByteBuffer serverToClient;        \/\/ \"reliable\" transport serverEngine->clientEngine\n+\n+    \/*\n+     * Majority of the test case is here, setup is done below.\n+     *\/\n+\n+    private void createSSLEngines() throws Exception {\n+        clientEngine = SSL_CONTEXT.createSSLEngine(\"client\", 1);\n+        clientEngine.setUseClientMode(true);\n+\n+        serverEngine = SSL_CONTEXT.createSSLEngine(\"server\", 2);\n+        serverEngine.setUseClientMode(false);\n+    }\n+\n+    private boolean isHandshaking(SSLEngine e) {\n+        return (e.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING);\n+    }\n+\n+    private void checkResult(ByteBuffer bbIn, ByteBuffer bbOut,\n+            SSLEngineResult result,\n+            Status status, HandshakeStatus hsStatus,\n+            int consumed, int produced)\n+            throws Exception {\n+\n+        if ((status != null) && (result.getStatus() != status)) {\n+            throw new Exception(\"Unexpected Status: need = \" + status +\n+                \" got = \" + result.getStatus());\n+        }\n+\n+        if ((hsStatus != null) && (result.getHandshakeStatus() != hsStatus)) {\n+            throw new Exception(\"Unexpected hsStatus: need = \" + hsStatus +\n+                \" got = \" + result.getHandshakeStatus());\n+        }\n+\n+        if ((consumed != -1) && (consumed != result.bytesConsumed())) {\n+            throw new Exception(\"Unexpected consumed: need = \" + consumed +\n+                \" got = \" + result.bytesConsumed());\n+        }\n+\n+        if ((produced != -1) && (produced != result.bytesProduced())) {\n+            throw new Exception(\"Unexpected produced: need = \" + produced +\n+                \" got = \" + result.bytesProduced());\n+        }\n+\n+        if ((consumed != -1) && (bbIn.position() != result.bytesConsumed())) {\n+            throw new Exception(\"Consumed \" + bbIn.position() +\n+                \" != \" + consumed);\n+        }\n+\n+        if ((produced != -1) && (bbOut.position() != result.bytesProduced())) {\n+            throw new Exception(\"produced \" + bbOut.position() +\n+                \" != \" + produced);\n+        }\n+    }\n+\n+    private void test() throws Exception {\n+        createSSLEngines();\n+        createBuffers();\n+\n+        SSLEngineResult result1;        \/\/ clientEngine's results from last operation\n+        SSLEngineResult result2;        \/\/ serverEngine's results from last operation\n+        String [] suite1 = new String [] {\n+            \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\" };\n+        String [] suite2 = new String [] {\n+            \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\" };\n+\n+        clientEngine.setEnabledCipherSuites(suite1);\n+        serverEngine.setEnabledCipherSuites(suite1);\n+\n+        log(\"================\");\n+\n+        log(\"unexpected empty unwrap\");\n+        serverToClient.limit(0);\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, 0);\n+        serverToClient.limit(serverToClient.capacity());\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [ClientHello]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n+        runDelegatedTasks(serverEngine);\n+\n+        clientToServer.compact();\n+\n+        log(\"Check for unwrap when wrap needed\");\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+        checkResult(clientToServer, serverIn, result2,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, 0);\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [ServerHello]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        runDelegatedTasks(clientEngine);\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [ClientKeyExchange]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n+        runDelegatedTasks(serverEngine);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [ChangeCipherSpec]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP,\n+             result1.bytesProduced(), 0);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [Finished]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_WRAP, result1.bytesProduced(), 0);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [NewSessionTicket]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [ChangeCipherSpec]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [Finished]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+                Status.OK, HandshakeStatus.FINISHED, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+                Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+\n+        log(\"======================================\");\n+        log(\"Check Session\/Ciphers\");\n+\n+        String suite = clientEngine.getSession().getCipherSuite();\n+        if (!suite.equals(suite1[0])) {\n+            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n+                suite1[0]);\n+        }\n+\n+        suite = serverEngine.getSession().getCipherSuite();\n+        if (!suite.equals(suite1[0])) {\n+            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n+                suite1[0]);\n+        }\n+\n+        log(\"======================================\");\n+        log(\"DATA\");\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            clientOut.capacity(), -1);\n+        clientToServer.flip();\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            serverOut.capacity(), -1);\n+        serverToClient.flip();\n+\n+        SSLEngineResult result3 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result3,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            result2.bytesProduced(), result2.bytesConsumed());\n+        serverToClient.compact();\n+\n+        SSLEngineResult result4 = serverEngine.unwrap(clientToServer, serverIn);\n+        checkResult(clientToServer, serverIn, result4,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            result1.bytesProduced(), result1.bytesConsumed());\n+        clientToServer.compact();\n+\n+        clientIn.clear();\n+        serverIn.clear();\n+        clientOut.rewind();\n+        serverOut.rewind();\n+\n+        log(\"======================================\");\n+        log(\"RENEGOTIATE\");\n+\n+        serverEngine.getSession().invalidate();\n+        serverEngine.setNeedClientAuth(true);\n+\n+        clientEngine.setEnabledCipherSuites(suite2);\n+        serverEngine.setEnabledCipherSuites(suite2);\n+\n+        serverEngine.beginHandshake();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [HelloRequest]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        runDelegatedTasks(clientEngine);\n+\n+        log(\"======================================\");\n+        log(\"CLient -> Server [ClientHello]\");\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n+        runDelegatedTasks(serverEngine);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"CLIENT->SERVER DATA IN MIDDLE OF HANDSHAKE\");\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP,\n+            clientOut.capacity(), -1);\n+        clientToServer.flip();\n+\n+        result4 = serverEngine.unwrap(clientToServer, serverIn);\n+        checkResult(clientToServer, serverIn, result4,\n+            Status.OK, HandshakeStatus.NEED_WRAP,\n+            result1.bytesProduced(), result1.bytesConsumed());\n+        clientToServer.compact();\n+\n+        serverIn.clear();\n+        clientOut.rewind();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [ServerHello]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        runDelegatedTasks(clientEngine);\n+\n+        log(\"======================================\");\n+        log(\"SERVER->CLIENT DATA IN MIDDLE OF HANDSHAKE\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP,\n+            serverOut.capacity(), -1);\n+        serverToClient.flip();\n+\n+        result3 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result3,\n+            Status.OK, HandshakeStatus.NEED_WRAP,\n+            result2.bytesProduced(), result2.bytesConsumed());\n+        serverToClient.compact();\n+\n+        clientIn.clear();\n+        serverOut.rewind();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [Certificate] and [ClientKeyExchange]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n+        runDelegatedTasks(serverEngine);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [ChangeCipherSpec]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP,\n+             result1.bytesProduced(), 0);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [Finished]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_WRAP, result1.bytesProduced(), 0);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [NewSessionTicket]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [ChangeCipherSpec]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+                Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+                Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [Finished]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.FINISHED, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Check Session\/Ciphers\");\n+\n+        suite = clientEngine.getSession().getCipherSuite();\n+        if (!suite.equals(suite2[0])) {\n+            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n+                suite2[0]);\n+        }\n+\n+        suite = serverEngine.getSession().getCipherSuite();\n+        if (!suite.equals(suite2[0])) {\n+            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n+                suite2[0]);\n+        }\n+\n+        log(\"======================================\");\n+        log(\"DATA USING NEW SESSION\");\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            clientOut.capacity(), -1);\n+        clientToServer.flip();\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            serverOut.capacity(), -1);\n+        serverToClient.flip();\n+\n+        result3 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result3,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            result2.bytesProduced(), result2.bytesConsumed());\n+        serverToClient.compact();\n+\n+        result4 = serverEngine.unwrap(clientToServer, serverIn);\n+        checkResult(clientToServer, serverIn, result4,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            result1.bytesProduced(), result1.bytesConsumed());\n+        clientToServer.compact();\n+\n+        clientIn.clear();\n+        serverIn.clear();\n+        clientOut.rewind();\n+        serverOut.rewind();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [CloseNotify]\");\n+\n+        if (isHandshaking(clientEngine)) {\n+            throw new Exception(\"clientEngine IS handshaking\");\n+        }\n+\n+        if (isHandshaking(serverEngine)) {\n+            throw new Exception(\"serverEngine IS handshaking\");\n+        }\n+\n+        serverEngine.closeOutbound();\n+\n+        if (!isHandshaking(serverEngine)) {\n+            throw new Exception(\"serverEngine IS NOT handshaking\");\n+        }\n+\n+        clientOut.rewind();\n+        serverOut.rewind();\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING, 0, -1);\n+        serverToClient.flip();\n+\n+        if (clientEngine.isInboundDone()) {\n+            throw new Exception(\"clientEngine inboundDone\");\n+        }\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.CLOSED, HandshakeStatus.NEED_WRAP,\n+            result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        if (!clientEngine.isInboundDone()) {\n+            throw new Exception(\"clientEngine inboundDone\");\n+        }\n+\n+        if (!isHandshaking(clientEngine)) {\n+            throw new Exception(\"clientEngine IS NOT handshaking\");\n+        }\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING, 0, 0);\n+        serverToClient.flip();\n+\n+        log(\"======================================\");\n+        log(\"CloseNotify response\");\n+\n+        if (clientEngine.isOutboundDone()) {\n+            throw new Exception(\"clientEngine outboundDone\");\n+        }\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+                        Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING, 0, -1);\n+\n+        if (!clientEngine.isOutboundDone()) {\n+            throw new Exception(\"clientEngine outboundDone is NOT done\");\n+        }\n+\n+        if (isHandshaking(clientEngine)) {\n+            throw new Exception(\"clientEngine IS handshaking\");\n+        }\n+\n+        clientToServer.flip();\n+\n+        if (!serverEngine.isOutboundDone()) {\n+            throw new Exception(\"clientEngine outboundDone\");\n+        }\n+\n+        if (serverEngine.isInboundDone()) {\n+            throw new Exception(\"clientEngine inboundDone\");\n+        }\n+\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING,\n+             result1.bytesProduced(), 0);\n+\n+        if (!serverEngine.isOutboundDone()) {\n+            throw new Exception(\"clientEngine outboundDone is NOT done\");\n+        }\n+\n+        if (!serverEngine.isInboundDone()) {\n+            throw new Exception(\"clientEngine inboundDone is NOT done\");\n+        }\n+\n+        if (isHandshaking(serverEngine)) {\n+            throw new Exception(\"clientEngine IS handshaking\");\n+        }\n+\n+        clientToServer.compact();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        CheckTlsEngineResults cs = new CheckTlsEngineResults();\n+        cs.test();\n+        System.out.println(\"Test Passed.\");\n+    }\n+\n+    \/*\n+     * **********************************************************\n+     * Majority of the test case is above, below is just setup stuff\n+     * **********************************************************\n+     *\/\n+\n+    public CheckTlsEngineResults() throws Exception {\n+        SSL_CONTEXT = getSSLContext(keyFilename, trustFilename);\n+    }\n+\n+    \/*\n+     * Create an initialized SSLContext to use for this test.\n+     *\/\n+    private SSLContext getSSLContext(String keyFile, String trustFile)\n+            throws Exception {\n+\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+\n+        char[] passphrase = \"passphrase\".toCharArray();\n+\n+        ks.load(new FileInputStream(keyFile), passphrase);\n+        ts.load(new FileInputStream(trustFile), passphrase);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(\"TLSv1.2\");\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return sslCtx;\n+    }\n+\n+    private void createBuffers() {\n+        \/\/ Size the buffers as appropriate.\n+\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        clientIn = ByteBuffer.allocateDirect(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocateDirect(appBufferMax + 50);\n+\n+        clientToServer = ByteBuffer.allocateDirect(netBufferMax);\n+        serverToClient = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+\n+        log(\"Client out = \" + clientOut);\n+        log(\"Server out = \" + serverOut);\n+        log(\"\");\n+    }\n+\n+    private static void runDelegatedTasks(SSLEngine engine) {\n+\n+        Runnable runnable;\n+        while ((runnable = engine.getDelegatedTask()) != null) {\n+            log(\"Running delegated task...\");\n+            runnable.run();\n+        }\n+    }\n+\n+    private static void log(String str) {\n+        System.out.println(str);\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/CheckTlsEngineResults.java","additions":709,"deletions":0,"binary":false,"changes":709,"status":"added"}]}