{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -41,0 +42,1 @@\n+        private T strongReferent;\n@@ -45,0 +47,1 @@\n+            this.strongReferent = referent;\n@@ -50,0 +53,8 @@\n+\n+        T getStrong() {\n+            return strongReferent;\n+        }\n+\n+        void clearStrong() {\n+            strongReferent = null;\n+        }\n@@ -53,1 +64,1 @@\n-    private final ClassValue<SoftReference<T>> map;\n+    private final ClassValue<CacheRef<T>> map;\n@@ -61,2 +72,4 @@\n-            protected SoftReference<T> computeValue(Class<?> type) {\n-                return new CacheRef<>(ClassCache.this.computeValue(type), queue, type);\n+            protected CacheRef<T> computeValue(Class<?> type) {\n+                T v = ClassCache.this.computeValue(type);\n+                Objects.requireNonNull(v);\n+                return new CacheRef<>(v, queue, type);\n@@ -68,7 +81,20 @@\n-        processQueue();\n-        T val;\n-        do {\n-            SoftReference<T> ref = map.get(cl);\n-            val = ref.get();\n-            if (val == null) {\n-                map.remove(cl);\n+        while (true) {\n+            processQueue();\n+\n+            CacheRef<T> ref = map.get(cl);\n+\n+            \/\/ Case 1: A recently created CacheRef.\n+            \/\/ We might still have strong referent, and can return it.\n+            \/\/ This guarantees progress for at least one thread on every CacheRef.\n+            \/\/ Clear the strong referent before returning to make the cache soft.\n+            T strongVal = ref.getStrong();\n+            if (strongVal != null) {\n+                ref.clearStrong();\n+                return strongVal;\n+            }\n+\n+            \/\/ Case 2: Older or recently cleared CacheRef.\n+            \/\/ Check if its soft referent is still available, and return it.\n+            T val = ref.get();\n+            if (val != null) {\n+                return val;\n@@ -76,2 +102,5 @@\n-        } while (val == null);\n-        return val;\n+\n+            \/\/ Case 3: The reference was cleared.\n+            \/\/ Clear the mapping and retry.\n+            map.remove(cl);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ClassCache.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"}]}