{"files":[{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.micro.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n+public class Base64Decode {\n+\n+    private Base64.Encoder encoder, mimeEncoder;\n+    private Base64.Decoder decoder, mimeDecoder;\n+    private ArrayList<byte[]> encoded, mimeEncoded, errorEncoded;\n+    private byte[] decoded, mimeDecoded, errorDecoded;\n+\n+    private static final int TESTSIZE = 1000;\n+\n+    @Param({\"1\", \"3\", \"7\", \"32\", \"64\", \"80\", \"96\",\n+            \"112\", \"512\", \"1000\", \"20000\", \"50000\"})\n+    private int maxNumBytes;\n+\n+    @Param({\"4\"})\n+    private int lineSize;\n+\n+    private byte[] lineSeparator = {'\\r', '\\n'};\n+\n+    \/* Other value can be tested by passing parameters to the JMH\n+       tests: -p errorIndex=3,64,144,208,272,1000,20000. *\/\n+    @Param({\"144\"})\n+    private int errorIndex;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        decoded = new byte[maxNumBytes + 1];\n+        encoder = Base64.getEncoder();\n+        decoder = Base64.getDecoder();\n+        encoded = new ArrayList<byte[]> ();\n+\n+        mimeDecoded = new byte[maxNumBytes + 1];\n+        mimeEncoder = Base64.getMimeEncoder(lineSize, lineSeparator);\n+        mimeDecoder = Base64.getMimeDecoder();\n+        mimeEncoded = new ArrayList<byte[]> ();\n+\n+        errorDecoded = new byte[errorIndex + 100];\n+        errorEncoded = new ArrayList<byte[]> ();\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            int srcLen = 1 + r.nextInt(maxNumBytes);\n+            byte[] src = new byte[srcLen];\n+            byte[] dst = new byte[((srcLen + 2) \/ 3) * 4];\n+            r.nextBytes(src);\n+            encoder.encode(src, dst);\n+            encoded.add(dst);\n+\n+            int mimeSrcLen = 1 + r.nextInt(maxNumBytes);\n+            byte[] mimeSrc = new byte[mimeSrcLen];\n+            byte[] mimeDst = new byte[((mimeSrcLen + 2) \/ 3) * 4 * (lineSize + lineSeparator.length) \/ lineSize];\n+            r.nextBytes(mimeSrc);\n+            mimeEncoder.encode(mimeSrc, mimeDst);\n+            mimeEncoded.add(mimeDst);\n+\n+            int errorSrcLen = errorIndex + r.nextInt(100);\n+            byte[] errorSrc = new byte[errorSrcLen];\n+            byte[] errorDst = new byte[(errorSrcLen + 2) \/ 3 * 4];\n+            r.nextBytes(errorSrc);\n+            encoder.encode(errorSrc, errorDst);\n+            errorEncoded.add(errorDst);\n+            errorDst[errorIndex] = (byte) '?';\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testBase64Decode(Blackhole bh) {\n+        for (byte[] s : encoded) {\n+            decoder.decode(s, decoded);\n+            bh.consume(decoded);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testBase64MIMEDecode(Blackhole bh) {\n+        for (byte[] s : mimeEncoded) {\n+            mimeDecoder.decode(s, mimeDecoded);\n+            bh.consume(mimeDecoded);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testBase64WithErrorInputsDecode (Blackhole bh) {\n+        for (byte[] s : errorEncoded) {\n+            try {\n+                 decoder.decode(s, errorDecoded);\n+                 bh.consume(errorDecoded);\n+            } catch (IllegalArgumentException e) {\n+                 bh.consume(e);\n+            }\n+        }\n+    }\n+}\n","filename":"micros-jdk8\/src\/main\/java\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.micro.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n+public class Base64Encode {\n+\n+    private Base64.Encoder encoder;\n+    private ArrayList<byte[]> unencoded;\n+    private byte[] encoded;\n+\n+    private static final int TESTSIZE = 1000;\n+\n+    @Param({\"1\", \"2\", \"3\", \"6\", \"7\", \"9\", \"10\", \"48\", \"512\", \"1000\", \"20000\"})\n+    private int maxNumBytes;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        int dstLen = ((maxNumBytes + 16) \/ 3) * 4;\n+\n+        encoder = Base64.getEncoder();\n+        unencoded = new ArrayList<byte[]> ();\n+        encoded = new byte[dstLen];\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            int srcLen = 1 + r.nextInt(maxNumBytes);\n+            byte[] src = new byte[srcLen];\n+            r.nextBytes(src);\n+            unencoded.add(src);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testBase64Encode(Blackhole bh) {\n+        for (byte[] s : unencoded) {\n+            encoder.encode(s, encoded);\n+            bh.consume(encoded);\n+        }\n+    }\n+}\n","filename":"micros-jdk8\/src\/main\/java\/org\/openjdk\/bench\/java\/util\/Base64Encode.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle America, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *  * Redistributions of source code must retain the above copyright notice,\n+ *    this list of conditions and the following disclaimer.\n+ *\n+ *  * Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ *\n+ *  * Neither the name of Oracle nor the names of its contributors may be used\n+ *    to endorse or promote products derived from this software without\n+ *    specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+package org.openjdk.micro.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.*;\n+\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n+public class Base64VarLenDecode {\n+\n+    @State(Scope.Thread)\n+    public static class MyState {\n+\n+        @Setup(Level.Trial)\n+        public void doSetupTrial() {\n+            ran = new Random(10101); \/\/ fixed seed for repeatability\n+            encoder = Base64.getEncoder();\n+            decoder = Base64.getDecoder();\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void doSetupInvocation() {\n+            bin_src_len = 8 + ran.nextInt(20000);\n+            base64_len = ((bin_src_len + 2) \/ 3) * 4;\n+            unencoded = new byte[bin_src_len];\n+            encoded = new byte[base64_len];\n+            decoded = new byte[bin_src_len];\n+            ran.nextBytes(unencoded);\n+            encoder.encode(unencoded, encoded);\n+        }\n+\n+        @TearDown(Level.Invocation)\n+        public void doTearDownInvocation() {\n+            \/\/ This isn't really a teardown.  It's a check for correct functionality.\n+            \/\/ Each iteration should produce a correctly decoded buffer that's equal\n+            \/\/ to the unencoded data.\n+            if (!Arrays.equals(unencoded, decoded)) {\n+                System.out.println(\"Original data and decoded data are not equal!\");\n+                for (int j = 0; j < unencoded.length; j++) {\n+                    if (unencoded[j] != decoded[j]) {\n+                        System.out.format(\"%06x: %02x %02x\\n\", j, unencoded[j], decoded[j]);\n+                    }\n+                }\n+                System.exit(1);\n+            }\n+        }\n+\n+        public Random ran;\n+        public Base64.Encoder encoder;\n+        public Base64.Decoder decoder;\n+        public int bin_src_len;\n+        public int base64_len;\n+        public byte[] unencoded;\n+        public byte[] encoded;\n+        public byte[] decoded;\n+    }\n+\n+    @Benchmark\n+    public void decodeMethod(MyState state) {\n+       state.decoder.decode(state.encoded, state.decoded);\n+    }\n+}\n","filename":"micros-jdk8\/src\/main\/java\/org\/openjdk\/bench\/java\/util\/Base64VarLenDecode.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}