{"files":[{"patch":"@@ -735,2 +735,3 @@\n-          \"off). The check is performed on GuaranteedSafepointInterval \"    \\\n-          \"or AsyncDeflationInterval.\")                                     \\\n+          \"off). The check is performed on GuaranteedSafepointInterval, \"   \\\n+          \"AsyncDeflationInterval or GuaranteedAsyncDeflationInterval, \"    \\\n+          \"whichever is lower.\")                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,3 +51,30 @@\n-  \/\/ We wait for GuaranteedSafepointInterval so that is_async_deflation_needed() is checked\n-  \/\/ at the same interval, unless GuaranteedAsyncDeflationInterval is lower.\n-  const intx wait_time = MIN2(GuaranteedSafepointInterval, GuaranteedAsyncDeflationInterval);\n+  \/\/ We wait for the lowest of these three intervals:\n+  \/\/  - GuaranteedSafepointInterval\n+  \/\/      While deflation is not related to safepoint anymore, this keeps compatibility with\n+  \/\/      the old behavior when deflation also happened at safepoints. Users who set this\n+  \/\/      option to get more\/less frequent deflations would be served with this option.\n+  \/\/  - AsyncDeflationInterval\n+  \/\/      Normal threshold-based deflation heuristic checks the conditions at this interval.\n+  \/\/      See is_async_deflation_needed().\n+  \/\/  - GuaranteedAsyncDeflationInterval\n+  \/\/      Backup deflation heuristic checks the conditions at this interval.\n+  \/\/      See is_async_deflation_needed().\n+  \/\/\n+  intx wait_time = max_intx;\n+  if (GuaranteedSafepointInterval > 0) {\n+    wait_time = MIN2(wait_time, GuaranteedSafepointInterval);\n+  }\n+  if (AsyncDeflationInterval > 0) {\n+    wait_time = MIN2(wait_time, AsyncDeflationInterval);\n+  }\n+  if (GuaranteedAsyncDeflationInterval > 0) {\n+    wait_time = MIN2(wait_time, GuaranteedAsyncDeflationInterval);\n+  }\n+\n+  \/\/ If all options are disabled, then wait time is not defined, and the deflation\n+  \/\/ is effectively disabled. In that case, exit the thread immediately after printing\n+  \/\/ a warning message.\n+  if (wait_time == max_intx) {\n+    warning(\"Async deflation is disabled\");\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,355 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test id=defaults\n+ * @bug 8305994 8306825\n+ * @summary Test the deflation intervals options\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest defaults\n+ *\/\n+\n+\/*\n+ * @test id=allIntervalsZero\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest allIntervalsZero\n+ *\/\n+\n+\/*\n+ * @test id=allThresholdsZero\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest allThresholdsZero\n+ *\/\n+\n+\/*\n+ * @test id=guaranteed_noThresholdMUDT_noSafepoint\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest guaranteed_noThresholdMUDT_noSafepoint\n+ *\/\n+\n+\/*\n+ * @test id=guaranteed_noThresholdMUDT_safepoint\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest guaranteed_noThresholdMUDT_safepoint\n+ *\/\n+\n+\/*\n+ * @test id=guaranteed_noThresholdADI_noSafepoint\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest guaranteed_noThresholdADI_noSafepoint\n+ *\/\n+\n+\/*\n+ * @test id=guaranteed_noThresholdADI_safepoint\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest guaranteed_noThresholdADI_safepoint\n+ *\/\n+\n+\/*\n+ * @test id=noGuaranteedGADT_threshold_noSafepoint\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest noGuaranteedGADT_threshold_noSafepoint\n+ *\/\n+\n+\/*\n+ * @test id=noGuaranteedGADT_threshold_safepoint\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest noGuaranteedGADT_threshold_safepoint\n+ *\/\n+\n+\/*\n+ * @test id=guaranteed_threshold_noSafepoint\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest guaranteed_threshold_noSafepoint\n+ *\/\n+\n+\/*\n+ * @test id=guaranteed_threshold_safepoint\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver DeflationIntervalsTest guaranteed_threshold_safepoint\n+ *\/\n+\n+public class DeflationIntervalsTest {\n+\n+    public static class Test {\n+        \/\/ Inflate a lot of monitors, so that threshold heuristics definitely fires\n+        private static final int MONITORS = 10_000;\n+\n+        \/\/ Use a handful of threads to inflate the monitors, to eat the cost of\n+        \/\/ wait(1) calls. This can be larger than available parallelism, since threads\n+        \/\/ would be time-waiting.\n+        private static final int THREADS = 16;\n+\n+        private static Thread[] threads;\n+        private static Object[] monitors;\n+\n+        public static void main(String... args) throws Exception {\n+            monitors = new Object[MONITORS];\n+            threads = new Thread[THREADS];\n+\n+            for (int t = 0; t < THREADS; t++) {\n+                int monStart = t * MONITORS \/ THREADS;\n+                int monEnd = (t + 1) * MONITORS \/ THREADS;\n+                threads[t] = new Thread(() -> {\n+                    for (int m = monStart; m < monEnd; m++) {\n+                        Object o = new Object();\n+                        synchronized (o) {\n+                            try {\n+                                o.wait(1);\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                        monitors[m] = o;\n+                    }\n+                });\n+                threads[t].start();\n+            }\n+\n+            for (Thread t : threads) {\n+                t.join();\n+            }\n+\n+            try {\n+                Thread.sleep(10_000);\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Expect the test label\");\n+        }\n+\n+        String test = args[0];\n+        switch (test) {\n+            case \"defaults\":\n+                \/\/ Try with all defaults\n+                test(Disabled.NO, Guaranteed.MAYBE, Threshold.MAYBE);\n+                break;\n+\n+            case \"allIntervalsZero\":\n+                \/\/ Try with all deflation intervals at zero\n+                test(Disabled.YES, Guaranteed.NO, Threshold.NO,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=0\",\n+                    \"-XX:AsyncDeflationInterval=0\",\n+                    \"-XX:GuaranteedSafepointInterval=0\"\n+                );\n+                break;\n+\n+            case \"allThresholdsZero\":\n+                \/\/ Try with all heuristics thresholds at zero\n+                test(Disabled.NO, Guaranteed.MAYBE, Threshold.NO,\n+                    \"-XX:MonitorUsedDeflationThreshold=0\"\n+                );\n+                break;\n+\n+            \/\/ Try with guaranteed interval only enabled, threshold heuristics disabled via MUDT,\n+            \/\/ with and without guaranteed safepoints\n+\n+            case \"guaranteed_noThresholdMUDT_noSafepoint\":\n+                test(Disabled.NO, Guaranteed.YES, Threshold.NO,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=100\",\n+                    \"-XX:MonitorUsedDeflationThreshold=0\",\n+                    \"-XX:GuaranteedSafepointInterval=0\"\n+                );\n+                break;\n+\n+            case \"guaranteed_noThresholdMUDT_safepoint\":\n+                test(Disabled.NO, Guaranteed.YES, Threshold.NO,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=100\",\n+                    \"-XX:MonitorUsedDeflationThreshold=0\"\n+                );\n+                break;\n+\n+            \/\/ Try with guaranteed interval only enabled, threshold heuristics disabled via ADI\n+            \/\/ with and without guaranteed safepoints\n+\n+            case \"guaranteed_noThresholdADI_noSafepoint\":\n+                test(Disabled.NO, Guaranteed.YES, Threshold.NO,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=100\",\n+                    \"-XX:AsyncDeflationInterval=0\",\n+                    \"-XX:GuaranteedSafepointInterval=0\"\n+                );\n+                break;\n+\n+            case \"guaranteed_noThresholdADI_safepoint\":\n+                test(Disabled.NO, Guaranteed.YES, Threshold.NO,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=100\",\n+                    \"-XX:AsyncDeflationInterval=0\"\n+                );\n+                break;\n+\n+            \/\/ Try with only threshold heuristics, guaranteed is disabled with GADT\n+            \/\/ with and without guaranteed safepoints\n+\n+            case \"noGuaranteedGADT_threshold_noSafepoint\":\n+                test(Disabled.NO, Guaranteed.NO, Threshold.YES,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=0\",\n+                    \"-XX:MonitorUsedDeflationThreshold=1\",\n+                    \"-XX:GuaranteedSafepointInterval=0\"\n+                );\n+                break;\n+\n+            case \"noGuaranteedGADT_threshold_safepoint\":\n+                test(Disabled.NO, Guaranteed.NO, Threshold.YES,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=0\",\n+                    \"-XX:MonitorUsedDeflationThreshold=1\"\n+                );\n+                break;\n+\n+            \/\/ Try with both threshold heuristics and guaranteed interval enabled\n+            \/\/ with and without guaranteed safepoints\n+\n+            case \"guaranteed_threshold_noSafepoint\":\n+                test(Disabled.NO, Guaranteed.YES, Threshold.YES,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=5000\",\n+                    \"-XX:MonitorUsedDeflationThreshold=1\",\n+                    \"-XX:GuaranteedSafepointInterval=0\"\n+                );\n+                break;\n+\n+            case \"guaranteed_threshold_safepoint\":\n+                \/\/ Try with both threshold heuristics and guaranteed interval enabled\n+                test(Disabled.NO, Guaranteed.YES, Threshold.YES,\n+                    \"-XX:GuaranteedAsyncDeflationInterval=5000\",\n+                    \"-XX:MonitorUsedDeflationThreshold=1\"\n+                );\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unknown test: \" + test);\n+        }\n+    }\n+\n+    static final String MSG_THRESHOLD  = \"Async deflation needed: monitors used are above the threshold\";\n+    static final String MSG_GUARANTEED = \"Async deflation needed: guaranteed interval\";\n+    static final String MSG_DISABLED   = \"Async deflation is disabled\";\n+\n+    public static void test(Disabled disabled, Guaranteed guaranteed, Threshold threshold, String... args) throws Exception {\n+        List<String> opts = new ArrayList<>();\n+        opts.add(\"-Xmx128M\");\n+        opts.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        opts.add(\"-Xlog:monitorinflation=info\");\n+        opts.addAll(Arrays.asList(args));\n+        opts.add(\"DeflationIntervalsTest$Test\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(opts);\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldHaveExitValue(0);\n+\n+        switch (disabled) {\n+            case YES: oa.shouldContain(MSG_DISABLED);    break;\n+            case NO:  oa.shouldNotContain(MSG_DISABLED); break;\n+            case MAYBE:                                  break;\n+        }\n+\n+        switch (threshold) {\n+            case YES: oa.shouldContain(MSG_THRESHOLD);    break;\n+            case NO:  oa.shouldNotContain(MSG_THRESHOLD); break;\n+            case MAYBE:                                   break;\n+        }\n+\n+        switch (guaranteed) {\n+            case YES: oa.shouldContain(MSG_GUARANTEED);    break;\n+            case NO:  oa.shouldNotContain(MSG_GUARANTEED); break;\n+            case MAYBE:                                    break;\n+        }\n+\n+        if (threshold == Threshold.YES || guaranteed == Guaranteed.YES) {\n+            assertDeflations(oa);\n+        } else if (threshold == Threshold.NO && guaranteed == Guaranteed.NO) {\n+            assertNoDeflations(oa);\n+        } else {\n+            \/\/ Don't know\n+        }\n+    }\n+\n+    static final String MSG_FINAL_AUDIT = \"Starting the final audit\";\n+    static final String MSG_BEGIN_DEFLATING = \"begin deflating\";\n+\n+    private static void assertNoDeflations(OutputAnalyzer oa) {\n+        for (String line : oa.asLines()) {\n+            if (line.contains(MSG_FINAL_AUDIT)) {\n+                \/\/ Final deflations started, with no prior deflations, good.\n+                return;\n+            }\n+            if (line.contains(MSG_BEGIN_DEFLATING)) {\n+                \/\/ Deflations detected before final ones, bad\n+                oa.reportDiagnosticSummary();\n+                throw new IllegalStateException(\"FAILED\");\n+            }\n+        }\n+    }\n+\n+    private static void assertDeflations(OutputAnalyzer oa) {\n+        for (String line : oa.asLines()) {\n+            if (line.contains(MSG_FINAL_AUDIT)) {\n+                \/\/ Final deflations started, with no prior deflations, bad.\n+                oa.reportDiagnosticSummary();\n+                throw new IllegalStateException(\"FAILED\");\n+            }\n+            if (line.contains(MSG_BEGIN_DEFLATING)) {\n+                \/\/ Deflations detected before final ones, good\n+                return;\n+            }\n+        }\n+    }\n+\n+    enum Disabled {\n+        YES,\n+        NO,\n+        MAYBE,\n+    }\n+\n+    enum Threshold {\n+        YES,\n+        NO,\n+        MAYBE,\n+    }\n+\n+    enum Guaranteed {\n+        YES,\n+        NO,\n+        MAYBE,\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/DeflationIntervalsTest.java","additions":355,"deletions":0,"binary":false,"changes":355,"status":"added"}]}