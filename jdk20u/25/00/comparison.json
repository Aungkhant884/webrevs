{"files":[{"patch":"@@ -1569,0 +1569,3 @@\n+  bool cannot_split_division(const Node* n, const Node* region) const;\n+  static bool is_divisor_counted_loop_phi(const Node* divisor, const Node* loop);\n+  bool loop_phi_backedge_type_contains_zero(const Node* phi_divisor, const Type* zero) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,13 +64,2 @@\n-  \/\/ Bail out if 'n' is a Div or Mod node whose zero check was removed earlier (i.e. control is NULL) and its divisor is an induction variable\n-  \/\/ phi p of a trip-counted (integer) loop whose inputs could be zero (include zero in their type range). p could have a more precise type\n-  \/\/ range that does not necessarily include all values of its inputs. Since each of these inputs will be a divisor of the newly cloned nodes\n-  \/\/ of 'n', we need to bail out of one of these divisors could be zero (zero in its type range).\n-  if ((n->Opcode() == Op_DivI || n->Opcode() == Op_ModI) && n->in(0) == NULL\n-      && region->is_CountedLoop() && n->in(2) == region->as_CountedLoop()->phi()) {\n-    Node* phi = region->as_CountedLoop()->phi();\n-    for (uint i = 1; i < phi->req(); i++) {\n-      if (_igvn.type(phi->in(i))->filter_speculative(TypeInt::ZERO) != Type::TOP) {\n-        \/\/ Zero could be a possible value but we already removed the zero check. Bail out to avoid a possible division by zero at a later point.\n-        return NULL;\n-      }\n-    }\n+  if (cannot_split_division(n, region)) {\n+    return NULL;\n@@ -228,0 +217,36 @@\n+\/\/ Return true if 'n' is a Div or Mod node (without zero check If node which was removed earlier) with a loop phi divisor\n+\/\/ of a trip-counted (integer or long) loop with a backedge input that could be zero (include zero in its type range). In\n+\/\/ this case, we cannot split the division to the backedge as it could freely float above the loop exit check resulting in\n+\/\/ a division by zero. This situation is possible because the type of an increment node of an iv phi (trip-counter) could\n+\/\/ include zero while the iv phi does not (see PhiNode::Value() for trip-counted loops where we improve types of iv phis).\n+\/\/ We also need to check other loop phis as they could have been created in the same split-if pass when applying\n+\/\/ PhaseIdealLoop::split_thru_phi() to split nodes through an iv phi.\n+bool PhaseIdealLoop::cannot_split_division(const Node* n, const Node* region) const {\n+  const Type* zero;\n+  switch (n->Opcode()) {\n+    case Op_DivI:\n+    case Op_ModI:\n+      zero = TypeInt::ZERO;\n+      break;\n+    case Op_DivL:\n+    case Op_ModL:\n+      zero = TypeLong::ZERO;\n+      break;\n+    default:\n+      return false;\n+  }\n+\n+  assert(n->in(0) == NULL, \"divisions with zero check should already have bailed out earlier in split-if\");\n+  Node* divisor = n->in(2);\n+  return is_divisor_counted_loop_phi(divisor, region) &&\n+         loop_phi_backedge_type_contains_zero(divisor, zero);\n+}\n+\n+bool PhaseIdealLoop::is_divisor_counted_loop_phi(const Node* divisor, const Node* loop) {\n+  return loop->is_BaseCountedLoop() && divisor->is_Phi() && divisor->in(0) == loop;\n+}\n+\n+bool PhaseIdealLoop::loop_phi_backedge_type_contains_zero(const Node* phi_divisor, const Type* zero) const {\n+    return _igvn.type(phi_divisor->in(LoopNode::LoopBackControl))->filter_speculative(zero) != Type::TOP;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @key stress randomness\n+* @bug 8299259\n+* @requires vm.compiler2.enabled\n+* @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+* @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM -XX:StressSeed=884154126\n+*                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+*                   compiler.splitif.TestSplitDivisionThroughPhi\n+*\/\n+\n+\/**\n+* @test\n+* @key stress randomness\n+* @bug 8299259\n+* @requires vm.compiler2.enabled\n+* @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+* @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM\n+*                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+*                   compiler.splitif.TestSplitDivisionThroughPhi\n+*\/\n+\n+package compiler.splitif;\n+\n+public class TestSplitDivisionThroughPhi {\n+    static int iFld;\n+    static long lFld;\n+    static boolean flag;\n+\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 5000; i++) {\n+            testPushDivIThruPhi();\n+            testPushDivIThruPhiInChain();\n+            testPushModIThruPhi();\n+            testPushModIThruPhiInChain();\n+            testPushDivLThruPhi();\n+            testPushDivLThruPhiInChain();\n+            testPushModLThruPhi();\n+            testPushModLThruPhiInChain();\n+        }\n+    }\n+\n+    \/\/ Already fixed by JDK-8248552.\n+    static void testPushDivIThruPhi() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            \/\/ The Div node is only split in later loop opts phase because the zero divisor check is only removed\n+            \/\/ in IGVN after the first loop opts phase.\n+            \/\/\n+            \/\/ iv phi i type: [2..10]\n+            \/\/ When splitting the DivI through the iv phi, it ends up on the back edge with the trip count decrement\n+            \/\/ as input which has type [0..8]. We end up executing a division by zero on the last iteration because\n+            \/\/ the DivI it is not pinned to the loop exit test and can freely float above the loop exit check.\n+            iFld = 10 \/ i;\n+        }\n+    }\n+\n+   \/\/ Same as above but with an additional Mul node between the iv phi and the Div node. Both nodes are split through\n+   \/\/ the iv phi in one pass of Split If.\n+    static void testPushDivIThruPhiInChain() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            \/\/ Empty one iteration loop which is only removed after split if in first loop opts phase. This prevents\n+            \/\/ that the Mul node is already split through the iv phi while the Div node cannot be split yet due to\n+            \/\/ the zero divisor check which can only be removed in the IGVN after the first loop opts pass.\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            iFld = 10 \/ (i * 100);\n+        }\n+    }\n+\n+    \/\/ Already fixed by JDK-8248552.\n+    static void testPushModIThruPhi() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            iFld = 10 \/ i;\n+        }\n+    }\n+\n+    \/\/ Same as above but with ModI.\n+    static void testPushModIThruPhiInChain() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            iFld = 10 \/ (i * 100);\n+        }\n+    }\n+\n+    \/\/ Long cases only trigger since JDK-8256655.\n+\n+    \/\/ Same as above but with DivL.\n+    static void testPushDivLThruPhi() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10L \/ i;\n+\n+            \/\/ Loop that is not removed such that we do not transform the outer LongCountedLoop (only done if innermost)\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with DivL.\n+    static void testPushDivLThruPhiInChain() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            lFld = 10L \/ (i * 100L);\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with ModL\n+    static void testPushModLThruPhi() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10L % i;\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with ModL\n+    static void testPushModLThruPhiInChain() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            lFld = 10L % (i * 100L);\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivisionThroughPhi.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"}]}