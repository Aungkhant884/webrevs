{"files":[{"patch":"@@ -714,0 +714,7 @@\n+  \/* notice: the max range value here is max_jint, not max_intx  *\/         \\\n+  \/* because of overflow issue                                   *\/         \\\n+  product(intx, GuaranteedAsyncDeflationInterval, 60000, DIAGNOSTIC,        \\\n+          \"Async deflate idle monitors every so many milliseconds even \"    \\\n+          \"when MonitorUsedDeflationThreshold is NOT exceeded (0 is off).\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,0 +50,5 @@\n+\n+  \/\/ We wait for GuaranteedSafepointInterval so that is_async_deflation_needed() is checked\n+  \/\/ at the same interval, unless GuaranteedAsyncDeflationInterval is lower.\n+  const intx wait_time = MIN2(GuaranteedSafepointInterval, GuaranteedAsyncDeflationInterval);\n+\n@@ -61,3 +66,1 @@\n-        \/\/ We wait for GuaranteedSafepointInterval so that\n-        \/\/ is_async_deflation_needed() is checked at the same interval.\n-        ml.wait(GuaranteedSafepointInterval);\n+        ml.wait(wait_time);\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -257,0 +257,3 @@\n+\n+  \/\/ Start the timer for deflations, so it does not trigger immediately.\n+  _last_async_deflation_time_ns = os::javaTimeNanos();\n@@ -285,0 +288,1 @@\n+static bool _no_progress_skip_increment = false;\n@@ -1111,1 +1115,8 @@\n-  return int(monitor_usage) > MonitorUsedDeflationThreshold;\n+  if (int(monitor_usage) > MonitorUsedDeflationThreshold) {\n+    log_info(monitorinflation)(\"monitors_used=\" SIZE_FORMAT \", ceiling=\" SIZE_FORMAT\n+                               \", monitor_usage=\" SIZE_FORMAT \", threshold=\" INTX_FORMAT,\n+                               monitors_used, ceiling, monitor_usage, MonitorUsedDeflationThreshold);\n+    return true;\n+  }\n+\n+  return false;\n@@ -1133,0 +1144,1 @@\n+    log_info(monitorinflation)(\"Async deflation needed: explicit request\");\n@@ -1135,0 +1147,3 @@\n+\n+  jlong time_since_last = time_since_last_async_deflation_ms();\n+\n@@ -1136,1 +1151,1 @@\n-      time_since_last_async_deflation_ms() > AsyncDeflationInterval &&\n+      time_since_last > AsyncDeflationInterval &&\n@@ -1142,0 +1157,1 @@\n+    log_info(monitorinflation)(\"Async deflation needed: monitors used are above the threshold\");\n@@ -1144,0 +1160,27 @@\n+\n+  if (GuaranteedAsyncDeflationInterval > 0 &&\n+      time_since_last > GuaranteedAsyncDeflationInterval) {\n+    \/\/ It's been longer than our specified guaranteed deflate interval.\n+    \/\/ We need to clean up the used monitors even if the threshold is\n+    \/\/ not reached, to keep the memory utilization at bay when many threads\n+    \/\/ touched many monitors.\n+    log_info(monitorinflation)(\"Async deflation needed: guaranteed interval (\" INTX_FORMAT \" ms) \"\n+                               \"is greater than time since last deflation (\" JLONG_FORMAT \" ms)\",\n+                               GuaranteedAsyncDeflationInterval, time_since_last);\n+\n+    \/\/ If this deflation has no progress, then it should not affect the no-progress\n+    \/\/ tracking, otherwise threshold heuristics would think it was triggered, experienced\n+    \/\/ no progress, and needs to backoff more aggressively. In this \"no progress\" case,\n+    \/\/ the generic code would bump the no-progress counter, and we compensate for that\n+    \/\/ by telling it to skip the update.\n+    \/\/\n+    \/\/ If this deflation has progress, then it should let non-progress tracking\n+    \/\/ know about this, otherwise the threshold heuristics would kick in, potentially\n+    \/\/ experience no-progress due to aggressive cleanup by this deflation, and think\n+    \/\/ it is still in no-progress stride. In this \"progress\" case, the generic code would\n+    \/\/ zero the counter, and we allow it to happen.\n+    _no_progress_skip_increment = true;\n+\n+    return true;\n+  }\n+\n@@ -1561,0 +1604,2 @@\n+  } else if (_no_progress_skip_increment) {\n+    _no_progress_skip_increment = false;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test id=allDisabled\n+ * @bug 8305994\n+ * @summary Test the GuaranteedAsyncDeflationInterval option\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver GuaranteedAsyncDeflationIntervalTest allDisabled\n+ *\/\n+\n+\/*\n+ * @test id=guaranteedNoMUDT\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver GuaranteedAsyncDeflationIntervalTest guaranteedNoMUDT\n+ *\/\n+\n+\/*\n+ * @test id=guaranteedNoADI\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver GuaranteedAsyncDeflationIntervalTest guaranteedNoADI\n+ *\/\n+\n+\/*\n+ * @test id=allEnabled\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver GuaranteedAsyncDeflationIntervalTest allEnabled\n+ *\/\n+\n+public class GuaranteedAsyncDeflationIntervalTest {\n+\n+    public static class Test {\n+        \/\/ Inflate a lot of monitors, so that threshold heuristics definitely fires\n+        private static final int MONITORS = 10_000;\n+\n+        \/\/ Use a handful of threads to inflate the monitors, to eat the cost of\n+        \/\/ wait(1) calls. This can be larger than available parallelism, since threads\n+        \/\/ would be time-waiting.\n+        private static final int THREADS = 16;\n+\n+        private static Thread[] threads;\n+        private static Object[] monitors;\n+\n+        public static void main(String... args) throws Exception {\n+            monitors = new Object[MONITORS];\n+            threads = new Thread[THREADS];\n+\n+            for (int t = 0; t < THREADS; t++) {\n+                int monStart = t * MONITORS \/ THREADS;\n+                int monEnd = (t + 1) * MONITORS \/ THREADS;\n+                threads[t] = new Thread(() -> {\n+                    for (int m = monStart; m < monEnd; m++) {\n+                        Object o = new Object();\n+                        synchronized (o) {\n+                            try {\n+                                o.wait(1);\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                        monitors[m] = o;\n+                    }\n+                });\n+                threads[t].start();\n+            }\n+\n+            for (Thread t : threads) {\n+                t.join();\n+            }\n+\n+            try {\n+                Thread.sleep(10_000);\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Expect the test label\");\n+        }\n+\n+        String test = args[0];\n+        switch (test) {\n+            case \"allDisabled\":\n+                testAllDisabled();\n+                break;\n+            case \"guaranteedNoMUDT\":\n+                testGuaranteedNoMUDT();\n+                break;\n+            case \"guaranteedNoADI\":\n+                testGuaranteedNoADI();\n+                break;\n+            case \"allEnabled\":\n+                testAllEnabled();\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown test: \" + test);\n+        }\n+    }\n+\n+    static final String MSG_THRESHOLD  = \"Async deflation needed: monitors used are above the threshold\";\n+    static final String MSG_GUARANTEED = \"Async deflation needed: guaranteed interval\";\n+\n+    \/\/ Try with all heuristics disabled\n+    public static void testAllDisabled() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx100M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:GuaranteedAsyncDeflationInterval=0\",\n+            \"-XX:AsyncDeflationInterval=0\",\n+            \"-XX:MonitorUsedDeflationThreshold=0\",\n+            \"-Xlog:monitorinflation=info\",\n+            \"GuaranteedAsyncDeflationIntervalTest$Test\");\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldHaveExitValue(0);\n+\n+        oa.shouldNotContain(MSG_THRESHOLD);\n+        oa.shouldNotContain(MSG_GUARANTEED);\n+        assertNoDeflations(oa);\n+    }\n+\n+    \/\/ Try with guaranteed interval only enabled, threshold heuristics disabled via MUDT\n+    public static void testGuaranteedNoMUDT() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx100M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:GuaranteedAsyncDeflationInterval=100\",\n+            \"-XX:MonitorUsedDeflationThreshold=0\",\n+            \"-Xlog:monitorinflation=info\",\n+            \"GuaranteedAsyncDeflationIntervalTest$Test\");\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldHaveExitValue(0);\n+\n+        oa.shouldNotContain(MSG_THRESHOLD);\n+        oa.shouldContain(MSG_GUARANTEED);\n+        assertDeflations(oa);\n+    }\n+\n+    \/\/ Try with guaranteed interval only enabled, threshold heuristics disabled via ADI\n+    public static void testGuaranteedNoADI() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx100M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:GuaranteedAsyncDeflationInterval=100\",\n+            \"-XX:AsyncDeflationInterval=0\",\n+            \"-Xlog:monitorinflation=info\",\n+            \"GuaranteedAsyncDeflationIntervalTest$Test\");\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldHaveExitValue(0);\n+\n+        oa.shouldNotContain(MSG_THRESHOLD);\n+        oa.shouldContain(MSG_GUARANTEED);\n+        assertDeflations(oa);\n+    }\n+\n+    \/\/ Try with both threshold heuristics and guaranteed interval enabled\n+    public static void testAllEnabled() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx100M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:GuaranteedAsyncDeflationInterval=5000\",\n+            \"-XX:MonitorUsedDeflationThreshold=1\",\n+            \"-Xlog:monitorinflation=info\",\n+            \"GuaranteedAsyncDeflationIntervalTest$Test\");\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldHaveExitValue(0);\n+\n+        oa.shouldContain(MSG_THRESHOLD);\n+        oa.shouldContain(MSG_GUARANTEED);\n+        assertDeflations(oa);\n+    }\n+\n+    private static void assertNoDeflations(OutputAnalyzer oa) {\n+        for (String line : oa.asLines()) {\n+            if (line.contains(\"Starting the final audit\")) {\n+                \/\/ Final deflations started, with no prior deflations, good.\n+                return;\n+            }\n+            if (line.contains(\"begin deflating\")) {\n+                \/\/ Deflations detected before final ones, bad\n+                oa.reportDiagnosticSummary();\n+                throw new IllegalStateException(\"FAILED\");\n+            }\n+        }\n+    }\n+\n+    private static void assertDeflations(OutputAnalyzer oa) {\n+        for (String line : oa.asLines()) {\n+            if (line.contains(\"Starting the final audit\")) {\n+                \/\/ Final deflations started, with no prior deflations, bad.\n+                oa.reportDiagnosticSummary();\n+                throw new IllegalStateException(\"FAILED\");\n+            }\n+            if (line.contains(\"begin deflating\")) {\n+                \/\/ Deflations detected before final ones, good\n+                return;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/GuaranteedAsyncDeflationIntervalTest.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}