{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023 SAP SE. All rights reserved.\n@@ -60,1 +60,1 @@\n-  const int abi_scratch = frame::abi_reg_args_size;\n+  const int abi_scratch = frame::top_ijava_frame_abi_size;\n@@ -79,2 +79,2 @@\n-  const int abi_scratch = is_top_frame ? (frame::abi_reg_args_size \/ Interpreter::stackElementSize) :\n-                                         (frame::abi_minframe_size \/ Interpreter::stackElementSize);\n+  const int abi_scratch = is_top_frame ? (frame::top_ijava_frame_abi_size \/ Interpreter::stackElementSize) :\n+                                         (frame::parent_ijava_frame_abi_size \/ Interpreter::stackElementSize);\n@@ -125,2 +125,2 @@\n-  const int abi_scratch = is_top_frame ? (frame::abi_reg_args_size \/ Interpreter::stackElementSize) :\n-                                         (frame::abi_minframe_size \/ Interpreter::stackElementSize);\n+  const int abi_scratch = is_top_frame ? (frame::top_ijava_frame_abi_size \/ Interpreter::stackElementSize) :\n+                                         (frame::parent_ijava_frame_abi_size \/ Interpreter::stackElementSize);\n@@ -130,1 +130,1 @@\n-    caller->sp() + method->max_locals() - 1 + (frame::abi_minframe_size \/ Interpreter::stackElementSize);\n+    caller->sp() + method->max_locals() - 1 + (frame::java_abi_size \/ Interpreter::stackElementSize);\n@@ -137,2 +137,2 @@\n-  intptr_t* sender_sp    = caller->sp() + (frame::abi_minframe_size - frame::abi_reg_args_size) \/ Interpreter::stackElementSize;\n-  intptr_t* top_frame_sp = is_top_frame ? sp : sp + (frame::abi_minframe_size - frame::abi_reg_args_size) \/ Interpreter::stackElementSize;\n+  intptr_t* sender_sp    = caller->sp() + (frame::parent_ijava_frame_abi_size - frame::top_ijava_frame_abi_size) \/ Interpreter::stackElementSize;\n+  intptr_t* top_frame_sp = is_top_frame ? sp : sp + (frame::parent_ijava_frame_abi_size - frame::top_ijava_frame_abi_size) \/ Interpreter::stackElementSize;\n","filename":"src\/hotspot\/cpu\/ppc\/abstractInterpreter_ppc.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -1833,1 +1833,1 @@\n-  const int frame_resize = frame::abi_reg_args_size - sizeof(frame::jit_abi); \/\/ C calls need larger frame.\n+  const int frame_resize = frame::native_abi_reg_args_size - sizeof(frame::java_abi); \/\/ C calls need larger frame.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -156,1 +156,1 @@\n-  assert(frame_size_in_bytes > frame::abi_reg_args_size, \"init\");\n+  assert(frame_size_in_bytes > frame::native_abi_reg_args_size, \"init\");\n@@ -244,1 +244,1 @@\n-  int sp_offset = frame::abi_reg_args_size;\n+  int sp_offset = frame::native_abi_reg_args_size;\n@@ -490,3 +490,3 @@\n-        __ push_frame(frame::abi_reg_args_size, R0); \/\/ Empty dummy frame (no callee-save regs).\n-        sasm->set_frame_size(frame::abi_reg_args_size \/ BytesPerWord);\n-        OopMap* oop_map = new OopMap(frame::abi_reg_args_size \/ sizeof(jint), 0);\n+        __ push_frame(frame::native_abi_reg_args_size, R0); \/\/ Empty dummy frame (no callee-save regs).\n+        sasm->set_frame_size(frame::native_abi_reg_args_size \/ BytesPerWord);\n+        OopMap* oop_map = new OopMap(frame::native_abi_reg_args_size \/ sizeof(jint), 0);\n@@ -735,3 +735,3 @@\n-        __ push_frame(frame::abi_reg_args_size, R0); \/\/ empty dummy frame\n-        sasm->set_frame_size(frame::abi_reg_args_size \/ BytesPerWord);\n-        OopMap* oop_map = new OopMap(frame::abi_reg_args_size \/ sizeof(jint), 0);\n+        __ push_frame(frame::native_abi_reg_args_size, R0); \/\/ empty dummy frame\n+        sasm->set_frame_size(frame::native_abi_reg_args_size \/ BytesPerWord);\n+        OopMap* oop_map = new OopMap(frame::native_abi_reg_args_size \/ sizeof(jint), 0);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, 2023 SAP SE. All rights reserved.\n@@ -32,1 +32,1 @@\n-  frame::abi_reg_args _abi;\n+  frame::native_abi_reg_args _abi;\n","filename":"src\/hotspot\/cpu\/ppc\/continuationEntry_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-\/\/     | frame::abi_minframe    |                          |                        |\n+\/\/     | frame::java_abi        |                          |                        |\n@@ -143,1 +143,1 @@\n-\/\/     | frame::abi_minframe    |                    |     | Lm                     |\n+\/\/     | frame::java_abi        |                    |     | Lm                     |\n@@ -145,1 +145,1 @@\n-\/\/     ==========================   of caller      -----   | frame::abi_minframe    |\n+\/\/     ==========================   of caller      -----   | frame::java_abi        |\n@@ -156,1 +156,1 @@\n-\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | frame::java_abi        |\n@@ -166,1 +166,1 @@\n-\/\/     | frame::abi_minframe    |                          |                        |\n+\/\/     | frame::java_abi        |                          |                        |\n@@ -172,1 +172,1 @@\n-\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | frame::java_abi        |                          | frame::java_abi        |\n@@ -180,1 +180,1 @@\n-\/\/      f is the frame to be relocated on the heap         | frame::abi_minframe    |\n+\/\/      f is the frame to be relocated on the heap         | frame::java_abi        |\n@@ -191,1 +191,1 @@\n-\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | frame::java_abi        |\n@@ -211,1 +211,1 @@\n-\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | frame::java_abi        |                          | frame::java_abi        |\n@@ -221,1 +221,1 @@\n-\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | frame::java_abi        |                          | frame::java_abi        |\n@@ -227,1 +227,1 @@\n-\/\/      f is the frame to be relocated on the heap         | frame::abi_minframe    |\n+\/\/      f is the frame to be relocated on the heap         | frame::java_abi        |\n@@ -233,1 +233,1 @@\n-\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | frame::java_abi        |\n@@ -241,1 +241,1 @@\n-\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | frame::java_abi        |                          | frame::java_abi        |\n@@ -250,1 +250,1 @@\n-\/\/     | frame::abi_minframe    |                     |    | frame::abi_minframe    |\n+\/\/     | frame::java_abi        |                     |    | frame::java_abi        |\n@@ -256,1 +256,1 @@\n-\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | frame::java_abi        |\n@@ -348,1 +348,1 @@\n-    address pc = (address)((frame::abi_minframe*) sp)->lr;\n+    address pc = (address)((frame::java_abi*) sp)->lr;\n@@ -359,1 +359,1 @@\n-    ((frame::abi_minframe*) sp)->callers_sp = (intptr_t) callers_sp;\n+    ((frame::java_abi*) sp)->callers_sp = (intptr_t) callers_sp;\n@@ -378,1 +378,1 @@\n-\/\/     |----------------------|    ^                                       | frame::abi_minframe  |<- unextended SP\n+\/\/     |----------------------|    ^                                       | frame::java_abi      |<- unextended SP\n@@ -385,1 +385,1 @@\n-\/\/     | frame::abi_minframe  |    |                                       | :                    |\n+\/\/     | frame::java_abi      |    |                                       | :                    |\n@@ -390,1 +390,1 @@\n-\/\/     |----------------------|    |                                    |  | frame::abi_minframe  |<- new SP of caller\n+\/\/     |----------------------|    |                                    |  | frame::java_abi      |<- new SP of caller\n@@ -397,1 +397,1 @@\n-\/\/     | frame::abi_minframe  |<- SP \/ unextended SP                    |  | :                    |\n+\/\/     | frame::java_abi      |<- SP \/ unextended SP                    |  | :                    |\n@@ -400,1 +400,1 @@\n-\/\/                                           | Growth |                 v  | frame::abi_minframe  |<- unextended SP \/ SP of new frame\n+\/\/                                           | Growth |                 v  | frame::java_abi      |<- unextended SP \/ SP of new frame\n@@ -417,1 +417,1 @@\n-\/\/     | frame::abi_minframe  |<- unextended SP            v            |  | :                    |   (unaligned)\n+\/\/     | frame::java_abi      |<- unextended SP            v            |  | :                    |   (unaligned)\n@@ -423,1 +423,1 @@\n-\/\/                                                                      |  | frame::abi_minframe  |<- new SP of caller\n+\/\/                                                                      |  | frame::java_abi      |<- new SP of caller\n@@ -433,1 +433,1 @@\n-\/\/                                                                      v  | frame::abi_minframe  |<- unextended SP \/ SP of new frame\n+\/\/                                                                      v  | frame::java_abi      |<- unextended SP \/ SP of new frame\n@@ -461,2 +461,2 @@\n-\/\/   a    |----------------------|                     | frame::abi_minframe  |\n-\/\/   l    | frame::abi_minframe  |<- unext. SP \/ SP    | (unused)             |<- unal.unext.SP\n+\/\/   a    |----------------------|                     | frame::java_abi      |\n+\/\/   l    | frame::java_abi      |<- unext. SP \/ SP    | (unused)             |<- unal.unext.SP\n@@ -467,1 +467,1 @@\n-\/\/        | frame::abi_minframe  |<- unext. SP \/ SP    | (if any)             |\n+\/\/        | frame::java_abi      |<- unext. SP \/ SP    | (if any)             |\n@@ -469,1 +469,1 @@\n-\/\/    r                                                | frame::abi_minframe  |<- caller's SP\n+\/\/    r                                                | frame::java_abi      |<- caller's SP\n@@ -474,1 +474,1 @@\n-\/\/                                                     | frame::abi_minframe  |<- unext. SP \/ SP\n+\/\/                                                     | frame::java_abi      |<- unext. SP \/ SP\n@@ -579,2 +579,2 @@\n-\/\/ | Minimal ABI          |                 | Minimal ABI          |                      | Minimal ABI          |\n-\/\/ | (frame::abi_minframe)|                 | (frame::abi_minframe)|                      | (frame::abi_minframe)|\n+\/\/ |                      |                 |                      |                      |                      |\n+\/\/ | (frame::java_abi)    |                 | (frame::java_abi)    |                      | (frame::java_abi)    |\n@@ -596,2 +596,2 @@\n-\/\/ |----------------------|   ::_max_stack  | Minimal ABI          |                      | Minimal ABI          |\n-\/\/ | Opt. Alignm. Padding |                 | (frame::abi_minframe)|                      | (frame::abi_minframe)|\n+\/\/ |----------------------|   ::_max_stack  |                      |                      |                      |\n+\/\/ | Opt. Alignm. Padding |                 | (frame::java_abi)    |                      | (frame::java_abi)    |\n@@ -601,2 +601,2 @@\n-\/\/ | (frame::abi_reg_args)|                                                               | frame::              |   (aligned)\n-\/\/ |                      |                                                               | ijava_state          |\n+\/\/ | (frame::             |                                                               | frame::              |   (aligned)\n+\/\/ |  native_abi_reg_args)|                                                               | ijava_state          |\n@@ -618,2 +618,2 @@\n-\/\/                                                                                        | (frame::abi_reg_args)|\n-\/\/                                                                                        |                      |\n+\/\/                                                                                        | (frame::             |\n+\/\/                                                                                        |  native_abi_reg_args)|\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  Unimplemented();\n+  \/\/ Currently all registers are considered to be volatile and saved in the caller (java) frame if needed\n@@ -50,1 +50,1 @@\n-  Unimplemented();\n+  \/\/ Currently all registers are considered to be volatile and saved in the caller (java) frame if needed\n@@ -110,1 +110,1 @@\n-\/\/                     | (frame::abi_minframe)|\n+\/\/                     | (frame::java_abi)    |\n@@ -127,1 +127,1 @@\n-\/\/                     | (frame::abi_minframe)|\n+\/\/                     | (frame::java_abi)    |\n@@ -148,1 +148,1 @@\n-\/\/                     | (frame::abi_minframe)|\n+\/\/                     | (frame::java_abi)    |\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -120,1 +120,1 @@\n-    abi_minframe* sender_abi = (abi_minframe*) fp;\n+    common_abi* sender_abi = (common_abi*) fp;\n@@ -284,1 +284,1 @@\n-  int min_frame_slots = (abi_minframe_size + ijava_state_size) \/ sizeof(intptr_t);\n+  int min_frame_slots = (parent_ijava_frame_abi_size + ijava_state_size) \/ sizeof(intptr_t);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  \/\/  ABI_48:\n+  \/\/  ABI_MINFRAME:\n@@ -69,2 +69,2 @@\n-  \/\/    24      reserved\n-  \/\/    32      reserved\n+  \/\/    24      reserved (ABI_ELFv2 only)\n+  \/\/    32      reserved (ABI_ELFv2 only)\n@@ -74,1 +74,1 @@\n-  \/\/    0       [ABI_48]\n+  \/\/    0       [ABI_MINFRAME]\n@@ -85,2 +85,2 @@\n-  \/\/ ABI_MINFRAME:\n-  struct abi_minframe {\n+  \/\/ Common ABI. On top of all frames, C and Java\n+  struct common_abi {\n@@ -88,1 +88,1 @@\n-    uint64_t cr;                                  \/\/_16\n+    uint64_t cr;\n@@ -90,0 +90,4 @@\n+  };\n+\n+  \/\/ ABI_MINFRAME. Used for native C frames.\n+  struct native_abi_minframe : common_abi {\n@@ -99,5 +103,1 @@\n-  enum {\n-    abi_minframe_size = sizeof(abi_minframe)\n-  };\n-\n-  struct abi_reg_args : abi_minframe {\n+  struct native_abi_reg_args : native_abi_minframe {\n@@ -116,1 +116,2 @@\n-    abi_reg_args_size = sizeof(abi_reg_args)\n+    native_abi_minframe_size = sizeof(native_abi_minframe),\n+    native_abi_reg_args_size = sizeof(native_abi_reg_args)\n@@ -120,1 +121,1 @@\n-          (offset_of(frame::abi_reg_args, _component))\n+          (offset_of(frame::native_abi_reg_args, _component))\n@@ -122,1 +123,1 @@\n-  struct abi_reg_args_spill : abi_reg_args {\n+  struct native_abi_reg_args_spill : native_abi_reg_args {\n@@ -130,1 +131,1 @@\n-    abi_reg_args_spill_size = sizeof(abi_reg_args_spill)\n+    native_abi_reg_args_spill_size = sizeof(native_abi_reg_args_spill)\n@@ -133,2 +134,2 @@\n-  #define _abi_reg_args_spill(_component) \\\n-          (offset_of(frame::abi_reg_args_spill, _component))\n+  #define _native_abi_reg_args_spill(_component) \\\n+          (offset_of(frame::native_abi_reg_args_spill, _component))\n@@ -189,0 +190,4 @@\n+  \/\/ We differnetiate between TOP and PARENT frames.\n+  \/\/ TOP frames allow for calling native C code.\n+  \/\/ A TOP frame is trimmed to a PARENT frame when calling a Java method.\n+  \/\/\n@@ -230,1 +235,3 @@\n-  struct parent_ijava_frame_abi : abi_minframe {\n+  \/\/ ABI for every Java frame, compiled and interpreted\n+  struct java_abi : common_abi {\n+    uint64_t toc;\n@@ -233,2 +240,1 @@\n-  enum {\n-    parent_ijava_frame_abi_size = sizeof(parent_ijava_frame_abi)\n+  struct parent_ijava_frame_abi : java_abi {\n@@ -240,1 +246,1 @@\n-  struct top_ijava_frame_abi : abi_reg_args {\n+  struct top_ijava_frame_abi : native_abi_reg_args {\n@@ -244,0 +250,2 @@\n+    java_abi_size = sizeof(java_abi),\n+    parent_ijava_frame_abi_size = sizeof(parent_ijava_frame_abi),\n@@ -321,10 +329,2 @@\n-  \/\/ JIT_ABI (TOP and PARENT)\n-\n-  struct jit_abi {\n-    uint64_t callers_sp;\n-    uint64_t cr;\n-    uint64_t lr;\n-    uint64_t toc;\n-    \/\/ Nothing to add here!\n-    \/\/ NOT ALIGNED to frame::alignment_in_bytes (16).\n-  };\n+  \/\/ For JIT frames we don't differentiate between TOP and PARENT frames.\n+  \/\/ Runtime calls go through stubs which push a new frame.\n@@ -332,1 +332,1 @@\n-  struct jit_out_preserve : jit_abi {\n+  struct jit_out_preserve : java_abi {\n@@ -383,2 +383,2 @@\n-  inline abi_minframe* own_abi()     const { return (abi_minframe*) _sp; }\n-  inline abi_minframe* callers_abi() const { return (abi_minframe*) _fp; }\n+  inline common_abi* own_abi()     const { return (common_abi*) _sp; }\n+  inline common_abi* callers_abi() const { return (common_abi*) _fp; }\n@@ -432,1 +432,1 @@\n-    metadata_words                         = sizeof(abi_minframe) >> LogBytesPerWord,\n+    metadata_words                         = sizeof(java_abi) >> LogBytesPerWord,\n@@ -439,1 +439,1 @@\n-    metadata_words_at_top                  = sizeof(abi_minframe) >> LogBytesPerWord,\n+    metadata_words_at_top                  = sizeof(java_abi) >> LogBytesPerWord,\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023 SAP SE. All rights reserved.\n@@ -57,1 +57,1 @@\n-    const int frame_size = align_up(frame::abi_reg_args_size + spill_slots * BytesPerWord, frame::alignment_in_bytes);\n+    const int frame_size = align_up(frame::native_abi_reg_args_size + spill_slots * BytesPerWord, frame::alignment_in_bytes);\n@@ -101,1 +101,1 @@\n-  const int frame_size = align_up(frame::abi_reg_args_size + spill_slots * BytesPerWord, frame::alignment_in_bytes);\n+  const int frame_size = align_up(frame::native_abi_reg_args_size + spill_slots * BytesPerWord, frame::alignment_in_bytes);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023 SAP SE. All rights reserved.\n@@ -414,1 +414,1 @@\n-                  + frame::abi_reg_args_size;\n+                  + frame::native_abi_reg_args_size;\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1160,1 +1160,1 @@\n-  addi(Rscratch2, R15_esp, Interpreter::stackElementSize - frame::abi_reg_args_size);\n+  addi(Rscratch2, R15_esp, Interpreter::stackElementSize - frame::top_ijava_frame_abi_size);\n@@ -2175,1 +2175,1 @@\n-    \/\/ After thawing the top frame of a continuation we reach here with frame::abi_minframe.\n+    \/\/ After thawing the top frame of a continuation we reach here with frame::java_abi.\n@@ -2198,1 +2198,1 @@\n-    cmpdi(CCR0, R0, frame::abi_reg_args_size + frame::ijava_state_size);\n+    cmpdi(CCR0, R0, frame::top_ijava_frame_abi_size + frame::ijava_state_size);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -733,1 +733,1 @@\n-    std(tmp, frame::abi_minframe_size + m * 8, R1_SP);\n+    std(tmp, frame::native_abi_minframe_size + m * 8, R1_SP);\n@@ -979,1 +979,1 @@\n-\/\/ Push a frame of size `bytes' plus abi_reg_args on top.\n+\/\/ Push a frame of size `bytes' plus native_abi_reg_args on top.\n@@ -981,1 +981,1 @@\n-  push_frame(bytes + frame::abi_reg_args_size, tmp);\n+  push_frame(bytes + frame::native_abi_reg_args_size, tmp);\n@@ -988,1 +988,1 @@\n-  push_frame(bytes + frame::abi_reg_args_size + frame::spill_nonvolatiles_size, tmp);\n+  push_frame(bytes + frame::native_abi_reg_args_size + frame::spill_nonvolatiles_size, tmp);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -319,1 +319,1 @@\n-  \/\/ Push a frame of size `bytes' plus abi_reg_args on top.\n+  \/\/ Push a frame of size `bytes' plus native_abi_reg_args on top.\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -511,1 +511,1 @@\n-    const int abi_offset = frame::abi_reg_args_size \/ 8;\n+    const int abi_offset = frame::native_abi_reg_args_size \/ 8;\n@@ -515,1 +515,1 @@\n-      \/\/ The registers are stored in reverse order on the stack (by save_volatile_gprs(R1_SP, abi_reg_args_size)).\n+      \/\/ The registers are stored in reverse order on the stack (by save_volatile_gprs(R1_SP, native_abi_reg_args_size)).\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3789,1 +3789,1 @@\n-  varargs_C_out_slots_killed(((frame::abi_reg_args_size - frame::jit_out_preserve_size) \/ VMRegImpl::stack_slot_size));\n+  varargs_C_out_slots_killed(((frame::native_abi_reg_args_size - frame::jit_out_preserve_size) \/ VMRegImpl::stack_slot_size));\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -80,1 +80,1 @@\n-  int frame_size_in_bytes = frame::abi_reg_args_size;\n+  int frame_size_in_bytes = frame::native_abi_reg_args_size;\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -275,1 +275,1 @@\n-                                   + frame::abi_reg_args_size;\n+                                   + frame::native_abi_reg_args_size;\n@@ -793,1 +793,1 @@\n-  int stk = (frame::abi_reg_args_size - frame::jit_out_preserve_size) \/ VMRegImpl::stack_slot_size;\n+  int stk = (frame::native_abi_reg_args_size - frame::jit_out_preserve_size) \/ VMRegImpl::stack_slot_size;\n@@ -1954,1 +1954,1 @@\n-  const int framesize_bytes = (int)align_up((int)frame::abi_reg_args_size, frame::alignment_in_bytes);\n+  const int framesize_bytes = (int)align_up((int)frame::native_abi_reg_args_size, frame::alignment_in_bytes);\n@@ -2481,1 +2481,1 @@\n-    int frame_size = frame::abi_reg_args_size + align_up(total_c_args * wordSize, frame::alignment_in_bytes);\n+    int frame_size = frame::native_abi_reg_args_size + align_up(total_c_args * wordSize, frame::alignment_in_bytes);\n@@ -2951,1 +2951,1 @@\n-  const int frame_size_in_bytes = frame::abi_reg_args_spill_size;\n+  const int frame_size_in_bytes = frame::native_abi_reg_args_spill_size;\n@@ -3113,2 +3113,2 @@\n-  __ std( R3_RET, _abi_reg_args_spill(spill_ret),  R1_SP);\n-  __ stfd(F1_RET, _abi_reg_args_spill(spill_fret), R1_SP);\n+  __ std( R3_RET, _native_abi_reg_args_spill(spill_ret),  R1_SP);\n+  __ stfd(F1_RET, _native_abi_reg_args_spill(spill_fret), R1_SP);\n@@ -3126,2 +3126,2 @@\n-  __ ld( R3_RET, _abi_reg_args_spill(spill_ret),  R1_SP);\n-  __ lfd(F1_RET, _abi_reg_args_spill(spill_fret), R1_SP);\n+  __ ld( R3_RET, _native_abi_reg_args_spill(spill_ret),  R1_SP);\n+  __ lfd(F1_RET, _native_abi_reg_args_spill(spill_fret), R1_SP);\n@@ -3173,1 +3173,1 @@\n-  int frame_size_in_bytes = frame::abi_reg_args_size;\n+  int frame_size_in_bytes = frame::native_abi_reg_args_size;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  return (address)((frame::abi_minframe*) _sp)->lr;\n+  return (address)((frame::common_abi*) _sp)->lr;\n@@ -64,1 +64,1 @@\n-  intptr_t* fp_addr = (intptr_t*)&((frame::abi_minframe*)_sp)->callers_sp;\n+  intptr_t* fp_addr = (intptr_t*)&((frame::common_abi*)_sp)->callers_sp;\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -94,2 +94,2 @@\n-    assert((sizeof(frame::abi_minframe) % 16) == 0,           \"unaligned\");\n-    assert((sizeof(frame::abi_reg_args) % 16) == 0,           \"unaligned\");\n+    assert((sizeof(frame::native_abi_minframe) % 16) == 0,    \"unaligned\");\n+    assert((sizeof(frame::native_abi_reg_args) % 16) == 0,    \"unaligned\");\n@@ -543,1 +543,1 @@\n-    int frame_size_in_bytes = frame::abi_reg_args_size;\n+    int frame_size_in_bytes = frame::native_abi_reg_args_size;\n@@ -4556,1 +4556,1 @@\n-    __ addi(R3_RET, R3_RET, frame::abi_reg_args_size); \/\/ Large abi required for C++ calls.\n+    __ addi(R3_RET, R3_RET, frame::native_abi_reg_args_size); \/\/ Large abi required for C++ calls.\n@@ -4620,1 +4620,1 @@\n-    int framesize = frame::abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -975,1 +975,1 @@\n-  __ addi(Rtop_frame_size, Rtop_frame_size, frame::abi_reg_args_size + frame::ijava_state_size);\n+  __ addi(Rtop_frame_size, Rtop_frame_size, frame::top_ijava_frame_abi_size + frame::ijava_state_size);\n@@ -978,1 +978,1 @@\n-  __ addi(Rparent_frame_resize, Rparent_frame_resize, frame::abi_minframe_size - Interpreter::stackElementSize);\n+  __ addi(Rparent_frame_resize, Rparent_frame_resize, frame::parent_ijava_frame_abi_size - Interpreter::stackElementSize);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-  static const int doYield_stub_frame_size = frame::abi_reg_args_size >> LogBytesPerWord;\n+  static const int doYield_stub_frame_size = frame::native_abi_reg_args_size >> LogBytesPerWord;\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import sun.nio.ch.Pollset;\n@@ -37,1 +38,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -45,2 +45,0 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n@@ -49,1 +47,1 @@\n-        init();\n+        Pollset.init();\n@@ -52,20 +50,0 @@\n-    \/**\n-     * struct pollfd {\n-     *     int fd;\n-     *     short events;\n-     *     short revents;\n-     * }\n-     *\/\n-    private static final int SIZEOF_POLLFD    = eventSize();\n-    private static final int OFFSETOF_EVENTS  = eventsOffset();\n-    private static final int OFFSETOF_REVENTS = reventsOffset();\n-    private static final int OFFSETOF_FD      = fdOffset();\n-\n-    \/\/ opcodes\n-    private static final int PS_ADD     = 0x0;\n-    private static final int PS_MOD     = 0x1;\n-    private static final int PS_DELETE  = 0x2;\n-\n-    \/\/ maximum number of events to poll at a time\n-    private static final int MAX_POLL_EVENTS = 512;\n-\n@@ -91,0 +69,3 @@\n+    \/\/ maximum number of events to poll at a time\n+    private static final int MAX_EVENTS_TO_POLL = 512;\n+\n@@ -145,1 +126,1 @@\n-        this.pollset = pollsetCreate();\n+        this.pollset = Pollset.pollsetCreate();\n@@ -150,1 +131,1 @@\n-            socketpair(sv);\n+            Pollset.socketpair(sv);\n@@ -152,1 +133,1 @@\n-            pollsetCtl(pollset, PS_ADD, sv[0], Net.POLLIN);\n+            Pollset.pollsetCtl(pollset, Pollset.PS_ADD, sv[0], Net.POLLIN);\n@@ -154,1 +135,1 @@\n-            pollsetDestroy(pollset);\n+            Pollset.pollsetDestroy(pollset);\n@@ -162,1 +143,1 @@\n-            socketpair(sv);\n+            Pollset.socketpair(sv);\n@@ -164,1 +145,1 @@\n-            pollsetCtl(pollset, PS_ADD, sv[0], Net.POLLIN);\n+            Pollset.pollsetCtl(pollset, Pollset.PS_ADD, sv[0], Net.POLLIN);\n@@ -166,1 +147,1 @@\n-            pollsetDestroy(pollset);\n+            Pollset.pollsetDestroy(pollset);\n@@ -172,1 +153,1 @@\n-        this.address = allocatePollArray(MAX_POLL_EVENTS);\n+        this.address = Pollset.allocatePollArray(MAX_EVENTS_TO_POLL);\n@@ -176,1 +157,1 @@\n-        this.queue = new ArrayBlockingQueue<Event>(MAX_POLL_EVENTS);\n+        this.queue = new ArrayBlockingQueue<Event>(MAX_EVENTS_TO_POLL);\n@@ -194,6 +175,6 @@\n-        freePollArray(address);\n-        close0(sp[0]);\n-        close0(sp[1]);\n-        close0(ctlSp[0]);\n-        close0(ctlSp[1]);\n-        pollsetDestroy(pollset);\n+        Pollset.freePollArray(address);\n+        Pollset.close0(sp[0]);\n+        Pollset.close0(sp[1]);\n+        Pollset.close0(ctlSp[0]);\n+        Pollset.close0(ctlSp[1]);\n+        Pollset.pollsetDestroy(pollset);\n@@ -202,1 +183,1 @@\n-    private void wakeup() {\n+    void wakeup() {\n@@ -206,1 +187,1 @@\n-                interrupt(sp[1]);\n+                Pollset.interrupt(sp[1]);\n@@ -261,1 +242,1 @@\n-                interrupt(ctlSp[1]);\n+                Pollset.interrupt(ctlSp[1]);\n@@ -302,1 +283,1 @@\n-                pollsetCtl(pollset, PS_DELETE, ev.fd(), 0);\n+                Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, ev.fd(), 0);\n@@ -304,1 +285,1 @@\n-                    ev.setError(pollsetCtl(pollset, PS_MOD, ev.fd(), ev.events()));\n+                    ev.setError(Pollset.pollsetCtl(pollset, Pollset.PS_MOD, ev.fd(), ev.events()));\n@@ -328,1 +309,2 @@\n-                        n = pollsetPoll(pollset, address, MAX_POLL_EVENTS);\n+                        n = Pollset.pollsetPoll(pollset, address,\n+                                     MAX_EVENTS_TO_POLL, Pollset.PS_NO_TIMEOUT);\n@@ -341,2 +323,2 @@\n-                            long eventAddress = getEvent(address, n);\n-                            int fd = getDescriptor(eventAddress);\n+                            long eventAddress = Pollset.getEvent(address, n);\n+                            int fd = Pollset.getDescriptor(eventAddress);\n@@ -348,1 +330,1 @@\n-                                    pollsetCtl(pollset, PS_DELETE, fd, 0);\n+                                    Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, fd, 0);\n@@ -356,1 +338,1 @@\n-                                    drain1(sp[0]);\n+                                    Pollset.drain1(sp[0]);\n@@ -371,1 +353,1 @@\n-                                    drain1(ctlSp[0]);\n+                                    Pollset.drain1(ctlSp[0]);\n@@ -382,1 +364,1 @@\n-                                int events = getRevents(eventAddress);\n+                                int events = Pollset.getRevents(eventAddress);\n@@ -470,71 +452,0 @@\n-\n-    \/**\n-     * Allocates a poll array to handle up to {@code count} events.\n-     *\/\n-    private static long allocatePollArray(int count) {\n-        return unsafe.allocateMemory(count * SIZEOF_POLLFD);\n-    }\n-\n-    \/**\n-     * Free a poll array\n-     *\/\n-    private static void freePollArray(long address) {\n-        unsafe.freeMemory(address);\n-    }\n-\n-    \/**\n-     * Returns event[i];\n-     *\/\n-    private static long getEvent(long address, int i) {\n-        return address + (SIZEOF_POLLFD*i);\n-    }\n-\n-    \/**\n-     * Returns event->fd\n-     *\/\n-    private static int getDescriptor(long eventAddress) {\n-        return unsafe.getInt(eventAddress + OFFSETOF_FD);\n-    }\n-\n-    \/**\n-     * Returns event->events\n-     *\/\n-    private static int getEvents(long eventAddress) {\n-        return unsafe.getChar(eventAddress + OFFSETOF_EVENTS);\n-    }\n-\n-    \/**\n-     * Returns event->revents\n-     *\/\n-    private static int getRevents(long eventAddress) {\n-        return unsafe.getChar(eventAddress + OFFSETOF_REVENTS);\n-    }\n-\n-    \/\/ -- Native methods --\n-\n-    private static native void init();\n-\n-    private static native int eventSize();\n-\n-    private static native int eventsOffset();\n-\n-    private static native int reventsOffset();\n-\n-    private static native int fdOffset();\n-\n-    private static native int pollsetCreate() throws IOException;\n-\n-    private static native int pollsetCtl(int pollset, int opcode, int fd, int events);\n-\n-    private static native int pollsetPoll(int pollset, long pollAddress, int numfds)\n-        throws IOException;\n-\n-    private static native void pollsetDestroy(int pollset);\n-\n-    private static native void socketpair(int[] sv) throws IOException;\n-\n-    private static native void interrupt(int fd) throws IOException;\n-\n-    private static native void drain1(int fd) throws IOException;\n-\n-    private static native void close0(int fd);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/AixPollPort.java","additions":34,"deletions":123,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, IBM Corp.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.IOException;\n+import jdk.internal.misc.Unsafe;\n+\n+public class Pollset {\n+\n+    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+\n+   \/**\n+     * struct pollfd {\n+     *     int fd;\n+     *     short events;\n+     *     short revents;\n+     * }\n+     *\/\n+    public static final int SIZEOF_POLLFD    = eventSize();\n+    public static final int OFFSETOF_EVENTS  = eventsOffset();\n+    public static final int OFFSETOF_REVENTS = reventsOffset();\n+    public static final int OFFSETOF_FD      = fdOffset();\n+\n+    \/\/ opcodes\n+    public static final int PS_ADD     = 0x0;\n+    public static final int PS_MOD     = 0x1;\n+    public static final int PS_DELETE  = 0x2;\n+\n+    \/\/ event\n+    public static final int PS_POLLPRI = 0x4;\n+\n+    \/\/ revent errcodes\n+    public static final char PS_POLLNVAL = 0x8000;\n+    public static final char PS_POLLERR  = 0x4000;\n+\n+    public static final int PS_NO_TIMEOUT = -1;\n+\n+    \/**\n+     * Allocates a poll array to handle up to {@code count} events.\n+     *\/\n+    public static long allocatePollArray(int count) {\n+        return unsafe.allocateMemory(count * SIZEOF_POLLFD);\n+    }\n+\n+    \/**\n+     * Free a poll array\n+     *\/\n+    public static void freePollArray(long address) {\n+        unsafe.freeMemory(address);\n+    }\n+\n+    \/**\n+     * Returns event[i];\n+     *\/\n+    public static long getEvent(long address, int i) {\n+        return address + (SIZEOF_POLLFD * i);\n+    }\n+\n+    \/**\n+     * Returns event->fd\n+     *\/\n+    public static int getDescriptor(long eventAddress) {\n+        return unsafe.getInt(eventAddress + OFFSETOF_FD);\n+    }\n+\n+    \/**\n+     * Returns event->events\n+     *\/\n+    public static int getEvents(long eventAddress) {\n+        return unsafe.getChar(eventAddress + OFFSETOF_EVENTS);\n+    }\n+\n+    \/**\n+     * Returns event->revents\n+     *\/\n+    public static char getRevents(long eventAddress) {\n+        return unsafe.getChar(eventAddress + OFFSETOF_REVENTS);\n+    }\n+\n+    public static boolean isReventsError(long eventAddress) {\n+        char revents = getRevents(eventAddress);\n+        return (revents & PS_POLLNVAL) != 0 || (revents & PS_POLLERR) != 0;\n+    }\n+\n+    \/\/ -- Native methods --\n+    public static native int pollsetCreate() throws IOException;\n+    public static native int pollsetCtl(int pollset, int opcode, int fd, int events);\n+    public static native int pollsetPoll(int pollset, long pollAddress, int numfds, int timeout)\n+        throws IOException;\n+    public static native void pollsetDestroy(int pollset);\n+    public static native void init();\n+    public static native int eventSize();\n+    public static native int eventsOffset();\n+    public static native int reventsOffset();\n+    public static native int fdOffset();\n+    public static native void socketpair(int[] sv) throws IOException;\n+    public static native void interrupt(int fd) throws IOException;\n+    public static native void drain1(int fd) throws IOException;\n+    public static native void close0(int fd);\n+}\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/Pollset.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, IBM Corp.\n@@ -28,0 +29,2 @@\n+import java.time.Instant;\n+import sun.nio.ch.Pollset;\n@@ -35,0 +38,10 @@\n+    private static final int MAX_EVENTS_TO_POLL;\n+\n+    static {\n+        Pollset.init(); \/* Dynamically loads pollset C functions *\/\n+        MAX_EVENTS_TO_POLL = 512;\n+    }\n+\n+    private final int setid;\n+    private final long pollBuffer;\n+\n@@ -37,0 +50,2 @@\n+        this.setid = Pollset.pollsetCreate();\n+        this.pollBuffer = Pollset.allocatePollArray(MAX_EVENTS_TO_POLL);\n@@ -41,2 +56,1 @@\n-        \/\/ Stub\n-        throw new UnsupportedOperationException(\"Unimplemented on AIX\");\n+        return setid;\n@@ -46,3 +60,6 @@\n-    void implRegister(int fdVal) throws IOException {\n-        \/\/ Stub\n-        throw new UnsupportedOperationException(\"Unimplemented on AIX\");\n+    void implRegister(int fd) throws IOException {\n+        int ret = Pollset.pollsetCtl(setid, Pollset.PS_MOD, fd,\n+                          Pollset.PS_POLLPRI | (this.reading() ? Net.POLLIN : Net.POLLOUT));\n+        if (ret != 0) {\n+            throw new IOException(\"Unable to register fd \" + fd);\n+        }\n@@ -52,3 +69,3 @@\n-    void implDeregister(int fdVal) {\n-        \/\/ Stub\n-        throw new UnsupportedOperationException(\"Unimplemented on AIX\");\n+    void implDeregister(int fd) {\n+        int ret = Pollset.pollsetCtl(setid, Pollset.PS_DELETE, fd, 0);\n+        assert ret == 0;\n@@ -57,0 +74,6 @@\n+    \/**\n+      * Main poll method. The AIX Pollset library does not appear to pick up changes to the pollset\n+      * (the set of fds being polled) while blocked on a call to this method. These changes happen\n+      * regularly in the poll-loop thread and update thread from Poller.java.\n+      * To address this difficulty, we break poll calls into 100ms sub-calls and emulate the timout.\n+      *\/\n@@ -59,2 +82,24 @@\n-        \/\/ Stub\n-        throw new UnsupportedOperationException(\"Unimplemented on AIX\");\n+        int n;\n+        switch (timeout) {\n+            case 0:\n+                n = pollInner(0);\n+                break;\n+            case Pollset.PS_NO_TIMEOUT:\n+                do { n = pollInner(100); } while (n == 0);\n+                break;\n+            default:\n+                Instant end = Instant.now().plusMillis(timeout);\n+                do { n = pollInner(100); } while (n == 0 && Instant.now().isBefore(end));\n+                break;\n+        }\n+        return n;\n+    }\n+\n+    int pollInner(int subInterval) throws IOException {\n+        int n = Pollset.pollsetPoll(setid, pollBuffer, MAX_EVENTS_TO_POLL, subInterval);\n+        for (int i=0; i<n; i++) {\n+            long eventAddress = Pollset.getEvent(pollBuffer, i);\n+            int fd = Pollset.getDescriptor(eventAddress);\n+            polled(fd);\n+        }\n+        return n;\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/PollsetPoller.java","additions":56,"deletions":11,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-\n-#include \"sun_nio_ch_AixPollPort.h\"\n-\n-#include <unistd.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <poll.h>\n-#include <sys\/pollset.h>\n-#include <fcntl.h>\n-#include <stddef.h>\n-#include <dlfcn.h>\n-#include <errno.h>\n-\n-\/* Initially copied from src\/solaris\/native\/sun\/nio\/ch\/nio_util.h *\/\n-#define RESTARTABLE(_cmd, _result) do { \\\n-  do { \\\n-    _result = _cmd; \\\n-  } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-typedef pollset_t pollset_create_func(int maxfd);\n-typedef int pollset_destroy_func(pollset_t ps);\n-typedef int pollset_ctl_func(pollset_t ps, struct poll_ctl *pollctl_array, int array_length);\n-typedef int pollset_poll_func(pollset_t ps, struct pollfd *polldata_array, int array_length, int timeout);\n-static pollset_create_func* _pollset_create = NULL;\n-static pollset_destroy_func* _pollset_destroy = NULL;\n-static pollset_ctl_func* _pollset_ctl = NULL;\n-static pollset_poll_func* _pollset_poll = NULL;\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_init(JNIEnv* env, jclass this) {\n-    _pollset_create = (pollset_create_func*) dlsym(RTLD_DEFAULT, \"pollset_create\");\n-    _pollset_destroy = (pollset_destroy_func*) dlsym(RTLD_DEFAULT, \"pollset_destroy\");\n-    _pollset_ctl = (pollset_ctl_func*) dlsym(RTLD_DEFAULT, \"pollset_ctl\");\n-    _pollset_poll = (pollset_poll_func*) dlsym(RTLD_DEFAULT, \"pollset_poll\");\n-    if (_pollset_create == NULL || _pollset_destroy == NULL ||\n-        _pollset_ctl == NULL || _pollset_poll == NULL) {\n-        JNU_ThrowInternalError(env, \"unable to get address of pollset functions\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_eventSize(JNIEnv* env, jclass this) {\n-    return sizeof(struct pollfd);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_eventsOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, events);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_reventsOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, revents);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_fdOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, fd);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_pollsetCreate(JNIEnv *env, jclass c) {\n-    \/* pollset_create can take the maximum number of fds, but we\n-     * cannot predict this number so we leave it at OPEN_MAX. *\/\n-    pollset_t ps = _pollset_create(-1);\n-    if (ps < 0) {\n-       JNU_ThrowIOExceptionWithLastError(env, \"pollset_create failed\");\n-    }\n-    return (int)ps;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_pollsetCtl(JNIEnv *env, jclass c, jint ps,\n-                                       jint opcode, jint fd, jint events) {\n-    struct poll_ctl event;\n-    int res;\n-\n-    event.cmd = opcode;\n-    event.events = events;\n-    event.fd = fd;\n-\n-    RESTARTABLE(_pollset_ctl((pollset_t)ps, &event, 1 \/* length *\/), res);\n-\n-    return (res == 0) ? 0 : errno;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_pollsetPoll(JNIEnv *env, jclass c,\n-                                        jint ps, jlong address, jint numfds) {\n-    struct pollfd *events = jlong_to_ptr(address);\n-    int res;\n-\n-    RESTARTABLE(_pollset_poll(ps, events, numfds, -1), res);\n-    if (res < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"pollset_poll failed\");\n-    }\n-    return res;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_pollsetDestroy(JNIEnv *env, jclass c, jint ps) {\n-    int res;\n-    RESTARTABLE(_pollset_destroy((pollset_t)ps), res);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_socketpair(JNIEnv* env, jclass clazz, jintArray sv) {\n-    int sp[2];\n-    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n-    } else {\n-        jint res[2];\n-        res[0] = (jint)sp[0];\n-        res[1] = (jint)sp[1];\n-        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_interrupt(JNIEnv *env, jclass c, jint fd) {\n-    int res;\n-    int buf[1];\n-    buf[0] = 1;\n-    RESTARTABLE(write(fd, buf, 1), res);\n-    if (res < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"write failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_drain1(JNIEnv *env, jclass cl, jint fd) {\n-    int res;\n-    char buf[1];\n-    RESTARTABLE(read(fd, buf, 1), res);\n-    if (res < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"drain1 failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_close0(JNIEnv *env, jclass c, jint fd) {\n-    int res;\n-    RESTARTABLE(close(fd), res);\n-}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/AixPollPort.c","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+\n+#include \"sun_nio_ch_Pollset.h\"\n+\n+#include <dlfcn.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stddef.h>\n+#include <sys\/pollset.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <unistd.h>\n+\n+\/* Initially copied from src\/solaris\/native\/sun\/nio\/ch\/nio_util.h *\/\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+typedef pollset_t pollset_create_func(int maxfd);\n+typedef int pollset_destroy_func(pollset_t ps);\n+typedef int pollset_ctl_func(pollset_t ps, struct poll_ctl *pollctl_array, int array_length);\n+typedef int pollset_poll_func(pollset_t ps, struct pollfd *polldata_array, int array_length, int timeout);\n+static pollset_create_func* _pollset_create = NULL;\n+static pollset_destroy_func* _pollset_destroy = NULL;\n+static pollset_ctl_func* _pollset_ctl = NULL;\n+static pollset_poll_func* _pollset_poll = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_init(JNIEnv* env, jclass this) {\n+    _pollset_create = (pollset_create_func*) dlsym(RTLD_DEFAULT, \"pollset_create\");\n+    _pollset_destroy = (pollset_destroy_func*) dlsym(RTLD_DEFAULT, \"pollset_destroy\");\n+    _pollset_ctl = (pollset_ctl_func*) dlsym(RTLD_DEFAULT, \"pollset_ctl\");\n+    _pollset_poll = (pollset_poll_func*) dlsym(RTLD_DEFAULT, \"pollset_poll\");\n+    if (_pollset_create == NULL || _pollset_destroy == NULL ||\n+        _pollset_ctl == NULL || _pollset_poll == NULL) {\n+        JNU_ThrowInternalError(env, \"unable to get address of pollset functions\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_eventSize(JNIEnv* env, jclass this) {\n+    return sizeof(struct pollfd);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_eventsOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, events);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_reventsOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, revents);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_fdOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, fd);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_pollsetCreate(JNIEnv *env, jclass c) {\n+    \/* pollset_create can take the maximum number of fds, but we\n+     * cannot predict this number so we leave it at OPEN_MAX. *\/\n+    pollset_t ps = _pollset_create(-1);\n+    if (ps < 0) {\n+       JNU_ThrowIOExceptionWithLastError(env, \"pollset_create failed\");\n+    }\n+    return (int)ps;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_pollsetCtl(JNIEnv *env, jclass c, jint ps,\n+                                       jint opcode, jint fd, jint events) {\n+    struct poll_ctl event;\n+    int res;\n+\n+    event.cmd = opcode;\n+    event.events = events;\n+    event.fd = fd;\n+\n+    RESTARTABLE(_pollset_ctl((pollset_t)ps, &event, 1 \/* length *\/), res);\n+\n+    return (res == 0) ? 0 : errno;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_pollsetPoll(JNIEnv *env, jclass c,\n+                                        jint ps, jlong address, jint numfds, jint timeout) {\n+    struct pollfd *events = jlong_to_ptr(address);\n+    int res;\n+\n+    RESTARTABLE(_pollset_poll(ps, events, numfds, timeout), res);\n+    if (res < 0) {\n+        perror(\"pollset_poll failed\");\n+        JNU_ThrowIOExceptionWithLastError(env, \"pollset_poll failed\");\n+    }\n+    return res;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_pollsetDestroy(JNIEnv *env, jclass c, jint ps) {\n+    int res;\n+    RESTARTABLE(_pollset_destroy((pollset_t)ps), res);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_socketpair(JNIEnv* env, jclass clazz, jintArray sv) {\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n+    } else {\n+        jint res[2];\n+        res[0] = (jint)sp[0];\n+        res[1] = (jint)sp[1];\n+        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_interrupt(JNIEnv *env, jclass c, jint fd) {\n+    int res;\n+    int buf[1];\n+    buf[0] = 1;\n+    RESTARTABLE(write(fd, buf, 1), res);\n+    if (res < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"write failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_drain1(JNIEnv *env, jclass cl, jint fd) {\n+    int res;\n+    char buf[1];\n+    RESTARTABLE(read(fd, buf, 1), res);\n+    if (res < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"drain1 failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_close0(JNIEnv *env, jclass c, jint fd) {\n+    int res;\n+    RESTARTABLE(close(fd), res);\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/Pollset.c","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-            poll1(fdVal, nanos, supplier);\n+            pollDirect(fdVal, nanos, supplier);\n@@ -102,1 +102,1 @@\n-            poll2(fdVal, nanos, supplier);\n+            pollIndirect(fdVal, nanos, supplier);\n@@ -110,1 +110,1 @@\n-    private void poll1(int fdVal, long nanos, BooleanSupplier supplier) throws IOException {\n+    private void pollDirect(int fdVal, long nanos, BooleanSupplier supplier) throws IOException {\n@@ -131,1 +131,1 @@\n-    private void poll2(int fdVal, long nanos, BooleanSupplier supplier) {\n+    private void pollIndirect(int fdVal, long nanos, BooleanSupplier supplier) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Poller.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}