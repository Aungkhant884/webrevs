{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## Independent JPEG Group (IJG) JPEG v9d\n+## Independent JPEG Group (IJG) JPEG v9e\n@@ -21,1 +21,1 @@\n-This software is copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.\n+This software is copyright (C) 1991-2022, Thomas G. Lane, Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/legal\/jpeg_fx.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-README for release 9d of 12-Jan-2020\n+README for release 9e of 16-Jan-2022\n@@ -41,0 +41,1 @@\n+  cdaltui.txt       Description of alternate user interface for cjpeg\/djpeg.\n@@ -118,1 +119,1 @@\n-This software is copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.\n+This software is copyright (C) 1991-2022, Thomas G. Lane, Guido Vollbeding.\n@@ -168,1 +169,1 @@\n-available at http:\/\/www.ijg.org\/files\/Wallace.JPEG.pdf.  The file (actually\n+available at https:\/\/www.ijg.org\/files\/Wallace.JPEG.pdf.  The file (actually\n@@ -212,2 +213,1 @@\n-WG1 N 6080 with title \"JPEG 9 Lossless Coding\", June\/July 2012, Paris,\n-France.\n+WG1 N 6080 with title \"JPEG 9 Lossless Coding\", June\/July 2012, Paris, France.\n@@ -220,1 +220,1 @@\n-free download in PDF file format from http:\/\/www.itu.int\/rec\/T-REC-T.871.\n+free download in PDF file format from https:\/\/www.itu.int\/rec\/T-REC-T.871.\n@@ -222,1 +222,1 @@\n-http:\/\/www.w3.org\/Graphics\/JPEG\/jfif3.pdf.\n+https:\/\/www.w3.org\/Graphics\/JPEG\/jfif3.pdf.\n@@ -230,1 +230,1 @@\n-http:\/\/www.ijg.org\/files\/.  It is expected that the next revision\n+https:\/\/www.ijg.org\/files\/.  It is expected that the next revision\n@@ -241,3 +241,5 @@\n-directory \"files\".  This particular version will be archived as\n-http:\/\/www.ijg.org\/files\/jpegsrc.v9d.tar.gz, and in Windows-compatible\n-\"zip\" archive format as http:\/\/www.ijg.org\/files\/jpegsr9d.zip.\n+directory \"files\".  This particular version will be archived\n+in Windows-compatible \"zip\" archive format as\n+https:\/\/www.ijg.org\/files\/jpegsr9e.zip, and\n+in Unix-compatible \"tar.gz\" archive format as\n+https:\/\/www.ijg.org\/files\/jpegsrc.v9e.tar.gz.\n@@ -289,2 +291,2 @@\n-Thank to Thomas G. Lane for the original design and development of\n-this singular software package.\n+Thank to Thomas G. Lane for the original design and development\n+of this singular software package.\n@@ -292,2 +294,3 @@\n-Thank to Lars Goehler, Andreas Heinecke, Sebastian Fuss, Yvonne Roebert,\n-Andrej Werner, and Ulf-Dietrich Braumann for support and public relations.\n+Thank to Lars Goehler, Andreas Heinecke, Sebastian Fuss,\n+Yvonne Roebert, Andrej Werner, Ulf-Dietrich Braumann,\n+and Nina Ssymank for support and public relations.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/README","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2003-2011 by Guido Vollbeding.\n+ * Modified 2003-2020 by Guido Vollbeding.\n@@ -39,1 +39,1 @@\n-  JDIMENSION mcu_ctr;        \/* counts MCUs processed in current row *\/\n+  JDIMENSION MCU_ctr;        \/* counts MCUs processed in current row *\/\n@@ -44,5 +44,3 @@\n-   * (although this may prove a bit slow in practice).  We allocate a\n-   * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it for each\n-   * MCU constructed and sent.  (On 80x86, the workspace is FAR even though\n-   * it's not really very big; this is to keep the module interfaces unchanged\n-   * when a large coefficient buffer is necessary.)\n+   * (although this may prove a bit slow in practice).  We append a\n+   * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it\n+   * for each MCU constructed and sent.\n@@ -56,0 +54,3 @@\n+\n+  \/* Workspace for single-pass compression (omitted otherwise). *\/\n+  JBLOCK blk_buffer[C_MAX_BLOCKS_IN_MCU];\n@@ -91,1 +92,1 @@\n-  coef->mcu_ctr = 0;\n+  coef->MCU_ctr = 0;\n@@ -128,1 +129,0 @@\n-    break;\n@@ -150,2 +150,4 @@\n-  int blkn, bi, ci, yindex, yoffset, blockcnt;\n-  JDIMENSION ypos, xpos;\n+  int ci, xindex, yindex, yoffset, blockcnt;\n+  JBLOCKROW blkp;\n+  JSAMPARRAY input_ptr;\n+  JDIMENSION xpos;\n@@ -158,1 +160,1 @@\n-    for (MCU_col_num = coef->mcu_ctr; MCU_col_num <= last_MCU_col;\n+    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;\n@@ -161,3 +163,2 @@\n-       * Each call on forward_DCT processes a horizontal row of DCT blocks\n-       * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks\n-       * sequentially.  Dummy blocks at the right or bottom edge are filled in\n+       * Each call on forward_DCT processes a horizontal row of DCT blocks as\n+       * wide as an MCU.  Dummy blocks at the right or bottom edge are filled in\n@@ -169,1 +170,1 @@\n-      blkn = 0;\n+      blkp = coef->blk_buffer;    \/* pointer to current DCT block within MCU *\/\n@@ -173,0 +174,3 @@\n+    input_ptr = input_buf[compptr->component_index] +\n+      yoffset * compptr->DCT_v_scaled_size;\n+    \/* ypos == (yoffset + yindex) * compptr->DCT_v_scaled_size *\/\n@@ -176,2 +180,0 @@\n-    ypos = yoffset * compptr->DCT_v_scaled_size;\n-    \/* ypos == (yoffset+yindex) * DCTSIZE *\/\n@@ -180,13 +182,8 @@\n-          yoffset+yindex < compptr->last_row_height) {\n-        (*forward_DCT) (cinfo, compptr,\n-                input_buf[compptr->component_index],\n-                coef->MCU_buffer[blkn],\n-                ypos, xpos, (JDIMENSION) blockcnt);\n-        if (blockcnt < compptr->MCU_width) {\n-          \/* Create some dummy blocks at the right edge of the image. *\/\n-          FMEMZERO((void FAR *) coef->MCU_buffer[blkn + blockcnt],\n-               (compptr->MCU_width - blockcnt) * SIZEOF(JBLOCK));\n-          for (bi = blockcnt; bi < compptr->MCU_width; bi++) {\n-        coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn+bi-1][0][0];\n-          }\n-        }\n+          yoffset + yindex < compptr->last_row_height) {\n+        (*forward_DCT) (cinfo, compptr, input_ptr, blkp,\n+                xpos, (JDIMENSION) blockcnt);\n+        input_ptr += compptr->DCT_v_scaled_size;\n+        blkp += blockcnt;\n+        \/* Dummy blocks at right edge *\/\n+        if ((xindex = compptr->MCU_width - blockcnt) == 0)\n+          continue;\n@@ -194,6 +191,2 @@\n-        \/* Create a row of dummy blocks at the bottom of the image. *\/\n-        FMEMZERO((void FAR *) coef->MCU_buffer[blkn],\n-             compptr->MCU_width * SIZEOF(JBLOCK));\n-        for (bi = 0; bi < compptr->MCU_width; bi++) {\n-          coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn-1][0][0];\n-        }\n+        \/* At bottom of image, need a whole row of dummy blocks *\/\n+        xindex = compptr->MCU_width;\n@@ -201,2 +194,6 @@\n-      blkn += compptr->MCU_width;\n-      ypos += compptr->DCT_v_scaled_size;\n+      \/* Fill in any dummy blocks needed in this row *\/\n+      MEMZERO(blkp, xindex * SIZEOF(JBLOCK));\n+      do {\n+        blkp[0][0] = blkp[-1][0];\n+        blkp++;\n+      } while (--xindex);\n@@ -211,1 +208,1 @@\n-    coef->mcu_ctr = MCU_col_num;\n+    coef->MCU_ctr = MCU_col_num;\n@@ -216,1 +213,1 @@\n-    coef->mcu_ctr = 0;\n+    coef->MCU_ctr = 0;\n@@ -259,0 +256,1 @@\n+  JSAMPARRAY input_ptr;\n@@ -283,0 +281,1 @@\n+    input_ptr = input_buf[ci];\n@@ -288,2 +287,1 @@\n-      (*forward_DCT) (cinfo, compptr, input_buf[ci], thisblockrow,\n-              (JDIMENSION) (block_row * compptr->DCT_v_scaled_size),\n+      (*forward_DCT) (cinfo, compptr, input_ptr, thisblockrow,\n@@ -291,0 +289,1 @@\n+      input_ptr += compptr->DCT_v_scaled_size;\n@@ -306,1 +305,1 @@\n-    if (coef->iMCU_row_num == last_iMCU_row) {\n+    if (block_row < compptr->v_samp_factor) {\n@@ -309,2 +308,1 @@\n-      for (block_row = block_rows; block_row < compptr->v_samp_factor;\n-       block_row++) {\n+      do {\n@@ -314,1 +312,1 @@\n-         (size_t) (blocks_across * SIZEOF(JBLOCK)));\n+         (size_t) blocks_across * SIZEOF(JBLOCK));\n@@ -323,1 +321,1 @@\n-      }\n+      } while (++block_row < compptr->v_samp_factor);\n@@ -350,1 +348,1 @@\n-  int blkn, ci, xindex, yindex, yoffset;\n+  int ci, xindex, yindex, yoffset;\n@@ -352,0 +350,1 @@\n+  JBLOCKARRAY blkp;\n@@ -371,1 +370,1 @@\n-    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;\n+    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;\n@@ -374,1 +373,1 @@\n-      blkn = 0;            \/* index of current DCT block within MCU *\/\n+      blkp = coef->MCU_buffer;    \/* pointer to current DCT block within MCU *\/\n@@ -379,4 +378,5 @@\n-      buffer_ptr = buffer[ci][yindex+yoffset] + start_col;\n-      for (xindex = 0; xindex < compptr->MCU_width; xindex++) {\n-        coef->MCU_buffer[blkn++] = buffer_ptr++;\n-      }\n+      buffer_ptr = buffer[ci][yoffset + yindex] + start_col;\n+      xindex = compptr->MCU_width;\n+      do {\n+        *blkp++ = buffer_ptr++;\n+      } while (--xindex);\n@@ -389,1 +389,1 @@\n-    coef->mcu_ctr = MCU_col_num;\n+    coef->MCU_ctr = MCU_col_num;\n@@ -394,1 +394,1 @@\n-    coef->mcu_ctr = 0;\n+    coef->MCU_ctr = 0;\n@@ -414,7 +414,0 @@\n-  coef = (my_coef_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_coef_controller));\n-  cinfo->coef = (struct jpeg_c_coef_controller *) coef;\n-  coef->pub.start_pass = start_pass_coef;\n-\n-  \/* Create the coefficient buffer. *\/\n@@ -428,0 +421,3 @@\n+    coef = (my_coef_ptr) (*cinfo->mem->alloc_small)\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE,\n+       SIZEOF(my_coef_controller) - SIZEOF(coef->blk_buffer));\n@@ -443,9 +439,12 @@\n-    JBLOCKROW buffer;\n-    int i;\n-\n-    buffer = (JBLOCKROW)\n-      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                  C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n-    for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {\n-      coef->MCU_buffer[i] = buffer + i;\n-    }\n+    JBLOCKARRAY blkp;\n+    JBLOCKROW buffer_ptr;\n+    int bi;\n+\n+    coef = (my_coef_ptr) (*cinfo->mem->alloc_small)\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_coef_controller));\n+    blkp = coef->MCU_buffer;\n+    buffer_ptr = coef->blk_buffer;\n+    bi = C_MAX_BLOCKS_IN_MCU;\n+    do {\n+      *blkp++ = buffer_ptr++;\n+    } while (--bi);\n@@ -454,0 +453,3 @@\n+\n+  coef->pub.start_pass = start_pass_coef;\n+  cinfo->coef = &coef->pub;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jccoefct.c","additions":75,"deletions":73,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2003-2013 by Guido Vollbeding.\n+ * Modified 2003-2020 by Guido Vollbeding.\n@@ -69,2 +69,2 @@\n- * position start_row\/start_col, and moving to the right for any additional\n- * blocks. The quantized coefficients are returned in coef_blocks[].\n+ * position start_col, and moving to the right for any additional blocks.\n+ * The quantized coefficients are returned in coef_blocks[].\n@@ -76,2 +76,1 @@\n-         JDIMENSION start_row, JDIMENSION start_col,\n-         JDIMENSION num_blocks)\n+         JDIMENSION start_col, JDIMENSION num_blocks)\n@@ -87,2 +86,0 @@\n-  sample_data += start_row;    \/* fold in the vertical offset once *\/\n-\n@@ -139,2 +136,1 @@\n-           JDIMENSION start_row, JDIMENSION start_col,\n-           JDIMENSION num_blocks)\n+           JDIMENSION start_col, JDIMENSION num_blocks)\n@@ -150,2 +146,0 @@\n-  sample_data += start_row;    \/* fold in the vertical offset once *\/\n-\n@@ -350,1 +344,0 @@\n-    break;\n@@ -356,1 +349,0 @@\n-      break;\n@@ -447,1 +439,0 @@\n-      break;\n@@ -464,3 +455,2 @@\n-  fdct = (my_fdct_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_fdct_controller));\n+  fdct = (my_fdct_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_fdct_controller));\n@@ -473,3 +463,2 @@\n-    compptr->dct_table =\n-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                  SIZEOF(divisor_table));\n+    compptr->dct_table = (*cinfo->mem->alloc_small)\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(divisor_table));\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcdctmgr.c","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -547,1 +547,1 @@\n-encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n+encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -630,1 +630,1 @@\n-encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n+encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -741,1 +741,1 @@\n-encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n+encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -784,1 +784,1 @@\n-encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n+encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -1016,1 +1016,1 @@\n-encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n+encode_mcu_huff (j_compress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -1197,1 +1197,1 @@\n-encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n+encode_mcu_gather (j_compress_ptr cinfo, JBLOCKARRAY MCU_data)\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jchuff.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -435,3 +435,1 @@\n-    cinfo->MCU_rows_in_scan = (JDIMENSION)\n-      jdiv_round_up((long) cinfo->jpeg_height,\n-            (long) (cinfo->max_v_samp_factor * cinfo->block_size));\n+    cinfo->MCU_rows_in_scan = cinfo->total_iMCU_rows;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcmaster.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  17,  18,  24,  47,  99,  99,  99,  99,\n+  16,  18,  24,  47,  99,  99,  99,  99,\n@@ -382,1 +382,2 @@\n-    SET_COMP(0, 0x52 \/* 'R' *\/, 1,1, 0,\n+    SET_COMP(0, 0x52 \/* 'R' *\/, 1,1,\n+        cinfo->color_transform == JCT_SUBTRACT_GREEN ? 1 : 0,\n@@ -386,1 +387,2 @@\n-    SET_COMP(2, 0x42 \/* 'B' *\/, 1,1, 0,\n+    SET_COMP(2, 0x42 \/* 'B' *\/, 1,1,\n+        cinfo->color_transform == JCT_SUBTRACT_GREEN ? 1 : 0,\n@@ -420,1 +422,2 @@\n-    SET_COMP(0, 0x72 \/* 'r' *\/, 1,1, 0,\n+    SET_COMP(0, 0x72 \/* 'r' *\/, 1,1,\n+        cinfo->color_transform == JCT_SUBTRACT_GREEN ? 1 : 0,\n@@ -424,1 +427,2 @@\n-    SET_COMP(2, 0x62 \/* 'b' *\/, 1,1, 0,\n+    SET_COMP(2, 0x62 \/* 'b' *\/, 1,1,\n+        cinfo->color_transform == JCT_SUBTRACT_GREEN ? 1 : 0,\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcparam.c","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-    jcopy_sample_rows(image_data, input_rows-1, image_data, row,\n+    jcopy_sample_rows(image_data + input_rows - 1,\n+              image_data + row,\n@@ -223,2 +224,2 @@\n-        jcopy_sample_rows(prep->color_buf[ci], 0,\n-                  prep->color_buf[ci], -row,\n+        jcopy_sample_rows(prep->color_buf[ci],\n+                  prep->color_buf[ci] - row,\n@@ -280,4 +281,3 @@\n-  fake_buffer = (JSAMPARRAY)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                (cinfo->num_components * 5 * rgroup_height) *\n-                SIZEOF(JSAMPROW));\n+  fake_buffer = (JSAMPARRAY) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE,\n+     (cinfo->num_components * 5 * rgroup_height) * SIZEOF(JSAMPROW));\n@@ -327,4 +327,3 @@\n-  prep = (my_prep_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_prep_controller));\n-  cinfo->prep = (struct jpeg_c_prep_controller *) prep;\n+  prep = (my_prep_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_prep_controller));\n+  cinfo->prep = &prep->pub;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcprepct.c","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  jcopy_sample_rows(input_data, 0, output_data, 0,\n+  jcopy_sample_rows(input_data, output_data,\n@@ -486,4 +486,3 @@\n-  downsample = (my_downsample_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_downsampler));\n-  cinfo->downsample = (struct jpeg_downsampler *) downsample;\n+  downsample = (my_downsample_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_downsampler));\n+  cinfo->downsample = &downsample->pub;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcsample.c","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-  JDIMENSION mcu_ctr;        \/* counts MCUs processed in current row *\/\n+  JDIMENSION MCU_ctr;        \/* counts MCUs processed in current row *\/\n@@ -235,1 +235,1 @@\n-  JBLOCKROW dummy_buffer[C_MAX_BLOCKS_IN_MCU];\n+  JBLOCK dummy_buffer[C_MAX_BLOCKS_IN_MCU];\n@@ -260,1 +260,1 @@\n-  coef->mcu_ctr = 0;\n+  coef->MCU_ctr = 0;\n@@ -318,1 +318,1 @@\n-    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;\n+    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;\n@@ -324,1 +324,0 @@\n-    start_col = MCU_col_num * compptr->MCU_width;\n@@ -327,0 +326,1 @@\n+    start_col = MCU_col_num * compptr->MCU_width;\n@@ -329,1 +329,1 @@\n-          yindex+yoffset < compptr->last_row_height) {\n+          yoffset + yindex < compptr->last_row_height) {\n@@ -331,2 +331,3 @@\n-        buffer_ptr = buffer[ci][yindex+yoffset] + start_col;\n-        for (xindex = 0; xindex < blockcnt; xindex++)\n+        buffer_ptr = buffer[ci][yoffset + yindex] + start_col;\n+        xindex = blockcnt;\n+        do {\n@@ -334,0 +335,3 @@\n+        } while (--xindex);\n+        if ((xindex = compptr->MCU_width - blockcnt) == 0)\n+          continue;\n@@ -336,1 +340,1 @@\n-        xindex = 0;\n+        xindex = compptr->MCU_width;\n@@ -344,5 +348,5 @@\n-      for (; xindex < compptr->MCU_width; xindex++) {\n-        MCU_buffer[blkn] = coef->dummy_buffer[blkn];\n-        MCU_buffer[blkn][0][0] = MCU_buffer[blkn-1][0][0];\n-        blkn++;\n-      }\n+      buffer_ptr = coef->dummy_buffer + blkn;\n+      do {\n+        buffer_ptr[0][0] = MCU_buffer[blkn-1][0][0];\n+        MCU_buffer[blkn++] = buffer_ptr++;\n+      } while (--xindex);\n@@ -355,1 +359,1 @@\n-    coef->mcu_ctr = MCU_col_num;\n+    coef->MCU_ctr = MCU_col_num;\n@@ -360,1 +364,1 @@\n-    coef->mcu_ctr = 0;\n+    coef->MCU_ctr = 0;\n@@ -382,2 +386,0 @@\n-  JBLOCKROW buffer;\n-  int i;\n@@ -385,3 +387,2 @@\n-  coef = (my_coef_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_coef_controller));\n+  coef = (my_coef_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_coef_controller));\n@@ -396,7 +397,1 @@\n-  buffer = (JBLOCKROW)\n-    (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n-  FMEMZERO((void FAR *) buffer, C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n-  for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {\n-    coef->dummy_buffer[i] = buffer + i;\n-  }\n+  MEMZERO(coef->dummy_buffer, SIZEOF(coef->dummy_buffer));\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jctrans.c","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  int cid0, cid1, cid2;\n+  int cid0, cid1, cid2, cid3;\n@@ -154,1 +154,0 @@\n-    break;\n@@ -165,1 +164,9 @@\n-    if (cinfo->saw_Adobe_marker) {\n+    cid0 = cinfo->comp_info[0].component_id;\n+    cid1 = cinfo->comp_info[1].component_id;\n+    cid2 = cinfo->comp_info[2].component_id;\n+    cid3 = cinfo->comp_info[3].component_id;\n+    if      (cid0 == 0x01 && cid1 == 0x02 && cid2 == 0x03 && cid3 == 0x04)\n+      cinfo->jpeg_color_space = JCS_YCCK;\n+    else if (cid0 == 0x43 && cid1 == 0x4D && cid2 == 0x59 && cid3 == 0x4B)\n+      cinfo->jpeg_color_space = JCS_CMYK;   \/* ASCII 'C', 'M', 'Y', 'K' *\/\n+    else if (cinfo->saw_Adobe_marker) {\n@@ -176,1 +183,0 @@\n-    break;\n@@ -188,1 +194,0 @@\n-    break;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdapimin.c","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2002-2011 by Guido Vollbeding.\n+ * Modified 2002-2020 by Guido Vollbeding.\n@@ -22,0 +22,1 @@\n+\n@@ -27,0 +28,1 @@\n+\n@@ -41,1 +43,1 @@\n-   * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,\n+   * We append a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,\n@@ -43,3 +45,0 @@\n-   * (On 80x86, the workspace is FAR even though it's not really very big;\n-   * this is to keep the module interfaces unchanged when a large coefficient\n-   * buffer is necessary.)\n@@ -61,0 +60,3 @@\n+\n+  \/* Workspace for single-pass modes (omitted otherwise). *\/\n+  JBLOCK blk_buffer[D_MAX_BLOCKS_IN_MCU];\n@@ -65,0 +67,1 @@\n+\n@@ -154,1 +157,2 @@\n-  int blkn, ci, xindex, yindex, yoffset, useful_width;\n+  int ci, xindex, yindex, yoffset, useful_width;\n+  JBLOCKROW blkp;\n@@ -165,0 +169,1 @@\n+      blkp = coef->blk_buffer;    \/* pointer to current DCT block within MCU *\/\n@@ -167,2 +172,1 @@\n-    FMEMZERO((void FAR *) coef->MCU_buffer[0],\n-         (size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));\n+    MEMZERO(blkp, cinfo->blocks_in_MCU * SIZEOF(JBLOCK));\n@@ -176,3 +180,2 @@\n-       * We skip dummy blocks at the right and bottom edges (but blkn gets\n-       * incremented past them!).  Note the inner loop relies on having\n-       * allocated the MCU_buffer[] blocks sequentially.\n+       * We skip dummy blocks at the right and bottom edges (but blkp gets\n+       * incremented past them!).\n@@ -180,1 +183,0 @@\n-      blkn = 0;            \/* index of current DCT block within MCU *\/\n@@ -185,1 +187,1 @@\n-      blkn += compptr->MCU_blocks;\n+      blkp += compptr->MCU_blocks;\n@@ -189,2 +191,0 @@\n-    useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width\n-                            : compptr->last_col_width;\n@@ -193,0 +193,2 @@\n+    useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width\n+                            : compptr->last_col_width;\n@@ -196,1 +198,1 @@\n-          yoffset+yindex < compptr->last_row_height) {\n+          yoffset + yindex < compptr->last_row_height) {\n@@ -199,2 +201,1 @@\n-          (*inverse_DCT) (cinfo, compptr,\n-                  (JCOEFPTR) coef->MCU_buffer[blkn+xindex],\n+          (*inverse_DCT) (cinfo, compptr, (JCOEFPTR) (blkp + xindex),\n@@ -204,0 +205,1 @@\n+        output_ptr += compptr->DCT_v_scaled_size;\n@@ -205,2 +207,1 @@\n-      blkn += compptr->MCU_width;\n-      output_ptr += compptr->DCT_v_scaled_size;\n+      blkp += compptr->MCU_width;\n@@ -215,1 +216,1 @@\n-  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\n+  if (++(cinfo->input_iMCU_row) <= last_iMCU_row) {\n@@ -250,1 +251,1 @@\n-  int blkn, ci, xindex, yindex, yoffset;\n+  int ci, xindex, yindex, yoffset;\n@@ -252,0 +253,1 @@\n+  JBLOCKARRAY blkp;\n@@ -275,1 +277,1 @@\n-      blkn = 0;            \/* index of current DCT block within MCU *\/\n+      blkp = coef->MCU_buffer;    \/* pointer to current DCT block within MCU *\/\n@@ -280,4 +282,5 @@\n-      buffer_ptr = buffer[ci][yindex+yoffset] + start_col;\n-      for (xindex = 0; xindex < compptr->MCU_width; xindex++) {\n-        coef->MCU_buffer[blkn++] = buffer_ptr++;\n-      }\n+      buffer_ptr = buffer[ci][yoffset + yindex] + start_col;\n+      xindex = compptr->MCU_width;\n+      do {\n+        *blkp++ = buffer_ptr++;\n+      } while (--xindex);\n@@ -373,1 +376,1 @@\n-  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\n+  if (++(cinfo->output_iMCU_row) <= last_iMCU_row)\n@@ -422,4 +425,3 @@\n-    coef->coef_bits_latch = (int *)\n-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                  cinfo->num_components *\n-                  (SAVED_COEFS * SIZEOF(int)));\n+    coef->coef_bits_latch = (int *) (*cinfo->mem->alloc_small)\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE,\n+       cinfo->num_components * (SAVED_COEFS * SIZEOF(int)));\n@@ -665,1 +667,1 @@\n-  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\n+  if (++(cinfo->output_iMCU_row) <= last_iMCU_row)\n@@ -682,11 +684,0 @@\n-  coef = (my_coef_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_coef_controller));\n-  cinfo->coef = (struct jpeg_d_coef_controller *) coef;\n-  coef->pub.start_input_pass = start_input_pass;\n-  coef->pub.start_output_pass = start_output_pass;\n-#ifdef BLOCK_SMOOTHING_SUPPORTED\n-  coef->coef_bits_latch = NULL;\n-#endif\n-\n-  \/* Create the coefficient buffer. *\/\n@@ -701,0 +692,3 @@\n+    coef = (my_coef_ptr) (*cinfo->mem->alloc_small)\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE,\n+       SIZEOF(my_coef_controller) - SIZEOF(coef->blk_buffer));\n@@ -725,9 +719,7 @@\n-    JBLOCKROW buffer;\n-    int i;\n-\n-    buffer = (JBLOCKROW)\n-      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n-    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {\n-      coef->MCU_buffer[i] = buffer + i;\n-    }\n+    JBLOCKARRAY blkp;\n+    JBLOCKROW buffer_ptr;\n+    int bi;\n+\n+    coef = (my_coef_ptr) (*cinfo->mem->alloc_small)\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_coef_controller));\n+    buffer_ptr = coef->blk_buffer;\n@@ -735,2 +727,6 @@\n-      FMEMZERO((void FAR *) buffer,\n-           (size_t) (D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK)));\n+      MEMZERO(buffer_ptr, SIZEOF(coef->blk_buffer));\n+    blkp = coef->MCU_buffer;\n+    bi = D_MAX_BLOCKS_IN_MCU;\n+    do {\n+      *blkp++ = buffer_ptr++;\n+    } while (--bi);\n@@ -741,0 +737,7 @@\n+\n+  coef->pub.start_input_pass = start_input_pass;\n+  coef->pub.start_output_pass = start_output_pass;\n+#ifdef BLOCK_SMOOTHING_SUPPORTED\n+  coef->coef_bits_latch = NULL;\n+#endif\n+  cinfo->coef = &coef->pub;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdcoefct.c","additions":58,"deletions":55,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-  register int num_comps = cinfo->num_components;\n+  register int out_comps = cinfo->out_color_components;\n@@ -436,0 +436,1 @@\n+  JSAMPROW startptr;\n@@ -437,0 +438,1 @@\n+  jpeg_component_info *compptr;\n@@ -440,1 +442,5 @@\n-    for (ci = 0; ci < num_comps; ci++) {\n+    startptr = *output_buf++;\n+    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n+     ci++, compptr++) {\n+      if (! compptr->component_needed)\n+    continue;        \/* skip uninteresting component *\/\n@@ -442,1 +448,1 @@\n-      outptr = output_buf[0] + ci;\n+      outptr = startptr++;\n@@ -445,1 +451,1 @@\n-    outptr += num_comps;\n+    outptr += out_comps;\n@@ -449,1 +455,0 @@\n-    output_buf++;\n@@ -465,1 +470,1 @@\n-  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,\n+  jcopy_sample_rows(input_buf[0] + input_row, output_buf,\n@@ -664,0 +669,38 @@\n+\/*\n+ * Convert CMYK to YK part of YCCK for colorless output.\n+ * We assume build_rgb_y_table has been called.\n+ *\/\n+\n+METHODDEF(void)\n+cmyk_yk_convert (j_decompress_ptr cinfo,\n+         JSAMPIMAGE input_buf, JDIMENSION input_row,\n+         JSAMPARRAY output_buf, int num_rows)\n+{\n+  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\n+  register int r, g, b;\n+  register INT32 * ctab = cconvert->rgb_y_tab;\n+  register JSAMPROW outptr;\n+  register JSAMPROW inptr0, inptr1, inptr2, inptr3;\n+  register JDIMENSION col;\n+  JDIMENSION num_cols = cinfo->output_width;\n+  while (--num_rows >= 0) {\n+    inptr0 = input_buf[0][input_row];\n+    inptr1 = input_buf[1][input_row];\n+    inptr2 = input_buf[2][input_row];\n+    inptr3 = input_buf[3][input_row];\n+    input_row++;\n+    outptr = *output_buf++;\n+    for (col = 0; col < num_cols; col++) {\n+      r = MAXJSAMPLE - GETJSAMPLE(inptr0[col]);\n+      g = MAXJSAMPLE - GETJSAMPLE(inptr1[col]);\n+      b = MAXJSAMPLE - GETJSAMPLE(inptr2[col]);\n+      outptr[0] = (JSAMPLE)\n+        ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\n+         >> SCALEBITS);\n+      outptr[1] = inptr3[col];    \/* don't need GETJSAMPLE here *\/\n+      outptr += 2;\n+    }\n+  }\n+}\n+\n+\n@@ -683,1 +726,1 @@\n-  int ci;\n+  int ci, i;\n@@ -796,1 +839,0 @@\n-    cinfo->out_color_components = RGB_PIXELSIZE;\n@@ -799,0 +841,1 @@\n+    cinfo->out_color_components = RGB_PIXELSIZE;\n@@ -812,0 +855,2 @@\n+    if (cinfo->jpeg_color_space != JCS_YCCK)\n+      goto def_label;\n@@ -813,2 +858,0 @@\n-    switch (cinfo->jpeg_color_space) {\n-    case JCS_YCCK:\n@@ -818,6 +861,12 @@\n-    case JCS_CMYK:\n-      cconvert->pub.color_convert = null_convert;\n-      break;\n-    default:\n-      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n-    }\n+  case JCS_YCCK:\n+    if (cinfo->jpeg_color_space != JCS_CMYK ||\n+    ! cinfo->comp_info[0].component_needed ||\n+      cinfo->comp_info[1].component_needed ||\n+      cinfo->comp_info[2].component_needed ||\n+    ! cinfo->comp_info[3].component_needed)\n+      goto def_label;\n+    cinfo->out_color_components = 2;\n+    cinfo->comp_info[1].component_needed = TRUE;\n+    cinfo->comp_info[2].component_needed = TRUE;\n+    cconvert->pub.color_convert = cmyk_yk_convert;\n+    build_rgb_y_table(cinfo);\n@@ -826,1 +875,1 @@\n-  default:        \/* permit null conversion to same output space *\/\n+  default: def_label:    \/* permit null conversion to same output space *\/\n@@ -830,1 +879,5 @@\n-    cinfo->out_color_components = cinfo->num_components;\n+    i = 0;\n+    for (ci = 0; ci < cinfo->num_components; ci++)\n+      if (cinfo->comp_info[ci].component_needed)\n+    i++;        \/* count output color components *\/\n+    cinfo->out_color_components = i;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdcolor.c","additions":71,"deletions":18,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -711,1 +711,1 @@\n-decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n+decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -783,1 +783,1 @@\n-decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n+decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -871,1 +871,1 @@\n-decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n+decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -920,1 +920,1 @@\n-decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n+decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -1079,1 +1079,1 @@\n-decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n+decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKARRAY MCU_data)\n@@ -1208,1 +1208,1 @@\n-decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n+decode_mcu (j_decompress_ptr cinfo, JBLOCKARRAY MCU_data)\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdhuff.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-      break;\n@@ -432,3 +431,1 @@\n-    cinfo->MCU_rows_in_scan = (JDIMENSION)\n-      jdiv_round_up((long) cinfo->image_height,\n-            (long) (cinfo->max_v_samp_factor * cinfo->block_size));\n+    cinfo->MCU_rows_in_scan = cinfo->total_iMCU_rows;\n@@ -504,3 +501,2 @@\n-    qtbl = (JQUANT_TBL *)\n-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                  SIZEOF(JQUANT_TBL));\n+    qtbl = (JQUANT_TBL *) (*cinfo->mem->alloc_small)\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(JQUANT_TBL));\n@@ -647,3 +643,2 @@\n-  inputctl = (my_inputctl_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n-                SIZEOF(my_input_controller));\n+  inputctl = (my_inputctl_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_PERMANENT, SIZEOF(my_input_controller));\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdinput.c","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -173,2 +173,2 @@\n-  mainp->xbuffer[0] = (JSAMPIMAGE)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n+  mainp->xbuffer[0] = (JSAMPIMAGE) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE,\n@@ -180,0 +180,2 @@\n+    if (! compptr->component_needed)\n+      continue;            \/* skip uninteresting component *\/\n@@ -185,3 +187,2 @@\n-    xbuf = (JSAMPARRAY)\n-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));\n+    xbuf = (JSAMPARRAY) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo,\n+      JPOOL_IMAGE, 2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));\n@@ -213,0 +214,2 @@\n+    if (! compptr->component_needed)\n+      continue;            \/* skip uninteresting component *\/\n@@ -253,0 +256,2 @@\n+    if (! compptr->component_needed)\n+      continue;            \/* skip uninteresting component *\/\n@@ -281,0 +286,2 @@\n+    if (! compptr->component_needed)\n+      continue;            \/* skip uninteresting component *\/\n@@ -336,1 +343,0 @@\n-    break;\n@@ -347,3 +353,2 @@\n-process_data_simple_main (j_decompress_ptr cinfo,\n-              JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n-              JDIMENSION out_rows_avail)\n+process_data_simple_main (j_decompress_ptr cinfo, JSAMPARRAY output_buf,\n+              JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n@@ -378,3 +383,2 @@\n-process_data_context_main (j_decompress_ptr cinfo,\n-               JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n-               JDIMENSION out_rows_avail)\n+process_data_context_main (j_decompress_ptr cinfo, JSAMPARRAY output_buf,\n+               JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n@@ -452,3 +456,2 @@\n-process_data_crank_post (j_decompress_ptr cinfo,\n-             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n-             JDIMENSION out_rows_avail)\n+process_data_crank_post (j_decompress_ptr cinfo, JSAMPARRAY output_buf,\n+             JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n@@ -475,3 +478,2 @@\n-  mainp = (my_main_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_main_controller));\n+  mainp = (my_main_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_main_controller));\n@@ -500,0 +502,2 @@\n+    if (! compptr->component_needed)\n+      continue;            \/* skip uninteresting component *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdmainct.c","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -106,2 +106,1 @@\n-#ifdef IDCT_SCALING_SUPPORTED\n-  int ci, ssize;\n+  int ci, i;\n@@ -109,1 +108,0 @@\n-#endif\n@@ -127,1 +125,1 @@\n-    ssize = 1;\n+    int ssize = 1;\n@@ -176,1 +174,0 @@\n-#if RGB_PIXELSIZE != 3\n@@ -179,9 +176,0 @@\n-#endif \/* else share code with YCbCr *\/\n-  case JCS_YCbCr:\n-  case JCS_BG_YCC:\n-    cinfo->out_color_components = 3;\n-    break;\n-  case JCS_CMYK:\n-  case JCS_YCCK:\n-    cinfo->out_color_components = 4;\n-    break;\n@@ -189,1 +177,6 @@\n-    cinfo->out_color_components = cinfo->num_components;\n+    i = 0;\n+    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n+     ci++, compptr++)\n+      if (compptr->component_needed)\n+    i++;    \/* count output color components *\/\n+    cinfo->out_color_components = i;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdmaster.c","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,\n+    jcopy_sample_rows(& upsample->spare_row, output_buf + *out_row_ctr,\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdmerge.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-         JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));\n+         JSAMPARRAY input_data, JSAMPIMAGE output_data_ptr));\n@@ -105,0 +105,2 @@\n+      if (! compptr->component_needed)\n+    continue;\n@@ -159,1 +161,1 @@\n-           JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\n+           JSAMPARRAY input_data, JSAMPIMAGE output_data_ptr)\n@@ -162,1 +164,0 @@\n-}\n@@ -170,5 +171,0 @@\n-METHODDEF(void)\n-noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n-           JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\n-{\n-  *output_data_ptr = NULL;    \/* safety check *\/\n@@ -191,1 +187,1 @@\n-          JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\n+          JSAMPARRAY input_data, JSAMPIMAGE output_data_ptr)\n@@ -194,1 +190,1 @@\n-  JSAMPARRAY output_data = *output_data_ptr;\n+  JSAMPARRAY output_data, output_end;\n@@ -200,1 +196,0 @@\n-  int inrow, outrow;\n@@ -205,2 +200,3 @@\n-  inrow = outrow = 0;\n-  while (outrow < cinfo->max_v_samp_factor) {\n+  output_data = *output_data_ptr;\n+  output_end = output_data + cinfo->max_v_samp_factor;\n+  for (; output_data < output_end; output_data += v_expand) {\n@@ -208,2 +204,2 @@\n-    inptr = input_data[inrow];\n-    outptr = output_data[outrow];\n+    inptr = *input_data++;\n+    outptr = *output_data;\n@@ -219,1 +215,1 @@\n-      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,\n+      jcopy_sample_rows(output_data, output_data + 1,\n@@ -222,2 +218,0 @@\n-    inrow++;\n-    outrow += v_expand;\n@@ -235,1 +229,1 @@\n-           JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\n+           JSAMPARRAY input_data, JSAMPIMAGE output_data_ptr)\n@@ -263,1 +257,1 @@\n-           JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)\n+           JSAMPARRAY input_data, JSAMPIMAGE output_data_ptr)\n@@ -265,1 +259,1 @@\n-  JSAMPARRAY output_data = *output_data_ptr;\n+  JSAMPARRAY output_data, output_end;\n@@ -269,1 +263,0 @@\n-  int inrow, outrow;\n@@ -271,4 +264,5 @@\n-  inrow = outrow = 0;\n-  while (outrow < cinfo->max_v_samp_factor) {\n-    inptr = input_data[inrow];\n-    outptr = output_data[outrow];\n+  output_data = *output_data_ptr;\n+  output_end = output_data + cinfo->max_v_samp_factor;\n+  for (; output_data < output_end; output_data += 2) {\n+    inptr = *input_data++;\n+    outptr = *output_data;\n@@ -281,1 +275,1 @@\n-    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,\n+    jcopy_sample_rows(output_data, output_data + 1,\n@@ -283,2 +277,0 @@\n-    inrow++;\n-    outrow += 2;\n@@ -301,3 +293,2 @@\n-  upsample = (my_upsample_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_upsampler));\n+  upsample = (my_upsample_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_upsampler));\n@@ -317,0 +308,2 @@\n+    if (! compptr->component_needed)\n+      continue;\n@@ -327,1 +320,0 @@\n-    if (! compptr->component_needed) {\n@@ -329,3 +321,0 @@\n-      upsample->methods[ci] = noop_upsample;\n-      continue;        \/* don't need to allocate buffer *\/\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdsample.c","additions":25,"deletions":36,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -106,2 +106,1 @@\n-         JDIMENSION start_row, JDIMENSION start_col,\n-         JDIMENSION num_blocks));\n+         JDIMENSION start_col, JDIMENSION num_blocks));\n@@ -118,1 +117,1 @@\n-  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));\n+  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKARRAY MCU_data));\n@@ -214,1 +213,1 @@\n-  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo, JBLOCKROW *MCU_data));\n+  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo, JBLOCKARRAY MCU_data));\n@@ -419,2 +418,2 @@\n-EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,\n-                    JSAMPARRAY output_array, int dest_row,\n+EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array,\n+                    JSAMPARRAY output_array,\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jpegint.h","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define JPEG_LIB_VERSION_MINOR  4\n+#define JPEG_LIB_VERSION_MINOR  5\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jpeglib.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,2 +296,1 @@\n-  colormap = (*cinfo->mem->alloc_sarray)\n-    ((j_common_ptr) cinfo, JPOOL_IMAGE,\n+  colormap = (*cinfo->mem->alloc_sarray) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n@@ -403,3 +402,2 @@\n-  odither = (ODITHER_MATRIX_PTR)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(ODITHER_MATRIX));\n+  odither = (ODITHER_MATRIX_PTR) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(ODITHER_MATRIX));\n@@ -534,2 +532,1 @@\n-    FMEMZERO((void FAR *) output_buf[row],\n-         (size_t) (width * SIZEOF(JSAMPLE)));\n+    FMEMZERO((void FAR *) output_buf[row], (size_t) width * SIZEOF(JSAMPLE));\n@@ -639,2 +636,1 @@\n-    FMEMZERO((void FAR *) output_buf[row],\n-         (size_t) (width * SIZEOF(JSAMPLE)));\n+    FMEMZERO((void FAR *) output_buf[row], (size_t) width * SIZEOF(JSAMPLE));\n@@ -729,1 +725,1 @@\n-  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));\n+  arraysize = ((size_t) cinfo->output_width + (size_t) 2) * SIZEOF(FSERROR);\n@@ -731,2 +727,2 @@\n-    cquantize->fserrors[i] = (FSERRPTR)\n-      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);\n+    cquantize->fserrors[i] = (FSERRPTR) (*cinfo->mem->alloc_large)\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);\n@@ -783,1 +779,1 @@\n-    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));\n+    arraysize = ((size_t) cinfo->output_width + (size_t) 2) * SIZEOF(FSERROR);\n@@ -789,1 +785,0 @@\n-    break;\n@@ -826,4 +821,3 @@\n-  cquantize = (my_cquantize_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_cquantizer));\n-  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;\n+  cquantize = (my_cquantize_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_cquantizer));\n+  cinfo->cquantize = &cquantize->pub;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jquant1.c","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1200,2 +1200,2 @@\n-      size_t arraysize = (size_t) ((cinfo->output_width + 2) *\n-                   (3 * SIZEOF(FSERROR)));\n+      size_t arraysize = ((size_t) cinfo->output_width + (size_t) 2)\n+    * (3 * SIZEOF(FSERROR));\n@@ -1250,4 +1250,3 @@\n-  cquantize = (my_cquantize_ptr)\n-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n-                SIZEOF(my_cquantizer));\n-  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;\n+  cquantize = (my_cquantize_ptr) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_cquantizer));\n+  cinfo->cquantize = &cquantize->pub;\n@@ -1287,1 +1286,2 @@\n-      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);\n+      ((j_common_ptr) cinfo, JPOOL_IMAGE,\n+       (JDIMENSION) desired, (JDIMENSION) 3);\n@@ -1305,1 +1305,1 @@\n-       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));\n+       ((size_t) cinfo->output_width + (size_t) 2) * (3 * SIZEOF(FSERROR)));\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jquant2.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -177,2 +177,2 @@\n-jcopy_sample_rows (JSAMPARRAY input_array, int source_row,\n-           JSAMPARRAY output_array, int dest_row,\n+jcopy_sample_rows (JSAMPARRAY input_array,\n+           JSAMPARRAY output_array,\n@@ -194,2 +194,0 @@\n-  input_array += source_row;\n-  output_array += dest_row;\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jutils.c","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-#define JVERSION    \"9d  12-Jan-2020\"\n+#define JVERSION    \"9e  16-Jan-2022\"\n@@ -14,1 +14,1 @@\n-#define JCOPYRIGHT    \"Copyright (C) 2020, Thomas G. Lane, Guido Vollbeding\"\n+#define JCOPYRIGHT    \"Copyright (C) 2022, Thomas G. Lane, Guido Vollbeding\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jversion.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}