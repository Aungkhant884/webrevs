{"files":[{"patch":"@@ -54,5 +54,0 @@\n-  MTL_OP_FILL_PARALLELOGRAM,\n-  MTL_OP_FILL_RECT,\n-  MTL_OP_DRAW_LINE,\n-  MTL_OP_DRAW_RECT,\n-  MTL_OP_DRAW_PARALLELOGRAM,\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.h","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,12 +51,0 @@\n-bool isDrawOp (jint op) {\n-     switch(op) {\n-        case MTL_OP_DRAW_LINE:\n-        case MTL_OP_DRAW_RECT:\n-        case MTL_OP_DRAW_PARALLELOGRAM:\n-        case MTL_OP_FILL_RECT:\n-        case MTL_OP_FILL_PARALLELOGRAM:\n-             return true;\n-        default: return false;\n-     }\n-}\n-\n@@ -70,10 +58,0 @@\n-    if (isDrawOp(mtlPreviousOp)) {\n-        \/\/ submit the vertex batch\n-        MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n-        if (isDrawOp(op)) {\n-            \/\/ Do not cause endEncoder if we continue with Draw operations\n-            mtlPreviousOp = op;\n-            return;\n-        }\n-    }\n-\n@@ -153,1 +131,1 @@\n-                    CHECK_PREVIOUS_OP(MTL_OP_DRAW_LINE);\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n@@ -169,1 +147,1 @@\n-                    CHECK_PREVIOUS_OP(MTL_OP_DRAW_RECT);\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n@@ -172,1 +150,0 @@\n-\n@@ -254,1 +231,1 @@\n-                    CHECK_PREVIOUS_OP(MTL_OP_DRAW_PARALLELOGRAM);\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n@@ -302,1 +279,1 @@\n-                    CHECK_PREVIOUS_OP(MTL_OP_FILL_RECT);\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n@@ -334,1 +311,1 @@\n-                    CHECK_PREVIOUS_OP(MTL_OP_FILL_PARALLELOGRAM);\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n@@ -608,1 +585,0 @@\n-                        MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n@@ -636,1 +612,0 @@\n-                                MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n@@ -906,2 +881,0 @@\n-            MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n-\n@@ -953,3 +926,0 @@\n-\n-    MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.m","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -75,4 +75,0 @@\n-void MTLRenderer_AddVertexToBatch(float x, float y);\n-void MTLRenderer_SubmitVertexBatch(MTLContext* mtlc, BMTLSDOps* dstOps);\n-void MTLRenderer_SetPrimitiveType(MTLPrimitiveType type);\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.h","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,89 +38,0 @@\n-\/**\n- * The max size of the vertex batch.\n- *\n- * Note:\n- * This is the max number of vertices (of struct Vertex - 8 bytes)\n- * that can be accommodated in 4KB.\n- *\n- * [MTLRenderCommandEncoder setVertexBytes] expects the data size\n- * to be less than or equal to 4KB.\n- *\/\n-static const int VERTEX_BATCH_SIZE = 510;\n-\n-static const int MAX_NO_OF_BATCHES = 20;\n-\n-struct primDetail {\n-    MTLPrimitiveType type;\n-    int vertexStart;\n-    int vertexEnd;\n-};\n-\n-static struct Vertex vertexBatch[VERTEX_BATCH_SIZE];\n-static struct primDetail PrimitivesBatch[MAX_NO_OF_BATCHES];\n-static int currentIndexInBatch = 0;\n-static MTLPrimitiveType currentMTLPrimitiveType = MTLPrimitiveTypeTriangleStrip; \/\/ invalid type that we do not use in this renderer\n-static int currentBatchNo = -1;\n-\n-\n-void MTLRenderer_SetPrimitiveType(MTLPrimitiveType type) {\n-    if (type != currentMTLPrimitiveType) {\n-\n-        if (currentBatchNo != -1) {\n-            \/\/ close the current batch\n-            PrimitivesBatch[currentBatchNo].vertexEnd = currentIndexInBatch - 1;\n-        }\n-\n-        \/\/ Start a new batch\n-        currentBatchNo++;\n-        PrimitivesBatch[currentBatchNo].type = type;\n-        PrimitivesBatch[currentBatchNo].vertexStart = currentIndexInBatch;\n-        PrimitivesBatch[currentBatchNo].vertexEnd = currentIndexInBatch;\n-        J2dRlsTraceLn1(J2D_TRACE_ERROR, \"MTLRenderer_SetPrimitiveType: starting a new batch : batch %d\", currentBatchNo);\n-\n-        currentMTLPrimitiveType = type;\n-    }\n-}\n-\n-inline void MTLRenderer_AddVertexToBatch(float x, float y)\n-{\n-   vertexBatch[currentIndexInBatch].position[0] = x;\n-   vertexBatch[currentIndexInBatch].position[1] = y;\n-\n-   currentIndexInBatch++;\n-}\n-\n-void MTLRenderer_SubmitVertexBatch(MTLContext *mtlc, BMTLSDOps * dstOps)\n-{\n-    if (currentIndexInBatch == 0) return;\n-    if (currentBatchNo == -1) return;\n-\n-    \/\/ close the current batch\n-    PrimitivesBatch[currentBatchNo].vertexEnd = currentIndexInBatch - 1;\n-\n-    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n-\n-    if (mtlEncoder == nil) {\n-        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_SubmitVertexBatch: error creating MTLRenderCommandEncoder.\");\n-        return;\n-    }\n-\n-    [mtlEncoder setVertexBytes:vertexBatch length:currentIndexInBatch * sizeof(struct Vertex) atIndex:MeshVertexBuffer];\n-\n-    \/\/ Iterate through PrimitivesBatch array\n-    for (int i = 0; i <= currentBatchNo; i++) {\n-        int numVertices = PrimitivesBatch[i].vertexEnd - PrimitivesBatch[i].vertexStart + 1;\n-        J2dRlsTraceLn2(J2D_TRACE_ERROR, \"MTLRenderer_SubmitVertexBatch: total vertices in batch %d = %d\", i, numVertices);\n-        [mtlEncoder drawPrimitives: PrimitivesBatch[i].type\n-                       vertexStart: PrimitivesBatch[i].vertexStart\n-                       vertexCount: numVertices];\n-    }\n-\n-    \/\/ Reset the index\n-    currentIndexInBatch = 0;\n-\n-    \/\/ Reset the batches\n-    currentBatchNo = -1;\n-\n-     \/\/ Reset to type that we do not use in this renderer\n-    currentMTLPrimitiveType = MTLPrimitiveTypeTriangleStrip;\n-}\n@@ -157,8 +68,3 @@\n-    \/\/ Make sure we have space for 2 more vertices in the batch\n-    if (((currentIndexInBatch + 2) > VERTEX_BATCH_SIZE) ||\n-         (currentBatchNo == (MAX_NO_OF_BATCHES - 1))) {\n-        \/\/ encode the vertex batch\n-        MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n-    }\n-\n-    MTLRenderer_SetPrimitiveType(MTLPrimitiveTypeLine);\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+    if (mtlEncoder == nil)\n+        return;\n@@ -167,0 +73,1 @@\n+    struct Vertex verts[2];\n@@ -176,2 +83,5 @@\n-        MTLRenderer_AddVertexToBatch(fx1 + 0.2f, fy);\n-        MTLRenderer_AddVertexToBatch(fx2 + 1.2f, fy);\n+\n+        verts[0].position[0] = fx1 + 0.2f;\n+        verts[0].position[1] = fy;\n+        verts[1].position[0] = fx2 + 1.2f;\n+        verts[1].position[1] = fy;\n@@ -187,2 +97,5 @@\n-        MTLRenderer_AddVertexToBatch(fx, fy1 + 0.2f);\n-        MTLRenderer_AddVertexToBatch(fx, fy2 + 1.2f);\n+\n+        verts[0].position[0] = fx;\n+        verts[0].position[1] = fy1 + 0.2f;\n+        verts[1].position[0] = fx;\n+        verts[1].position[1] = fy2 + 1.2f;\n@@ -211,3 +124,4 @@\n-\n-        MTLRenderer_AddVertexToBatch(fx1, fy1);\n-        MTLRenderer_AddVertexToBatch(fx2, fy2);\n+        verts[0].position[0] = fx1;\n+        verts[0].position[1] = fy1;\n+        verts[1].position[0] = fx2;\n+        verts[1].position[1] = fy2;\n@@ -215,0 +129,3 @@\n+\n+    [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypeLine vertexStart:0 vertexCount:2];\n@@ -248,10 +165,4 @@\n-    \/\/ Make sure we have space for 8 more vertices in the batch\n-    if ( ((currentIndexInBatch + 8) > VERTEX_BATCH_SIZE) ||\n-         (currentBatchNo == (MAX_NO_OF_BATCHES - 1))) {\n-\n-        \/\/ encode the vertex batch\n-        MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n-    }\n-\n-    MTLRenderer_SetPrimitiveType(MTLPrimitiveTypeLine);\n-\n+    \/\/ TODO: use DrawParallelogram(x, y, w, h, lw=1, lh=1)\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+    if (mtlEncoder == nil)\n+        return;\n@@ -261,0 +172,1 @@\n+    const int verticesCount = 5;\n@@ -265,12 +177,9 @@\n-\n-    MTLRenderer_AddVertexToBatch(fx, fy);\n-    MTLRenderer_AddVertexToBatch(fx+fw, fy);\n-\n-    MTLRenderer_AddVertexToBatch(fx+fw, fy);\n-    MTLRenderer_AddVertexToBatch(fx+fw, fy+fh);\n-\n-    MTLRenderer_AddVertexToBatch(fx+fw, fy+fh);\n-    MTLRenderer_AddVertexToBatch(fx, fy+fh);\n-\n-    MTLRenderer_AddVertexToBatch(fx, fy+fh);\n-    MTLRenderer_AddVertexToBatch(fx, fy);\n+    struct Vertex vertices[5] = {\n+            {{fx, fy}},\n+            {{fx + fw, fy}},\n+            {{fx + fw, fy + fh}},\n+            {{fx, fy + fh}},\n+            {{fx, fy}},\n+    };\n+    [mtlEncoder setVertexBytes:vertices length:sizeof(vertices) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypeLineStrip vertexStart:0 vertexCount:verticesCount];\n@@ -509,6 +418,6 @@\n-    \/\/ Make sure we have space for 6 more vertices in the batch\n-    if ( ((currentIndexInBatch + 6) > VERTEX_BATCH_SIZE) ||\n-         (currentBatchNo == (MAX_NO_OF_BATCHES - 1))) {\n-        \/\/ encode the vertex batch\n-        MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n-    }\n+    struct Vertex verts[QUAD_VERTEX_COUNT] = {\n+        { {x, y}},\n+        { {x, y+h}},\n+        { {x+w, y}},\n+        { {x+w, y+h}\n+    }};\n@@ -516,1 +425,0 @@\n-    MTLRenderer_SetPrimitiveType(MTLPrimitiveTypeTriangle);\n@@ -518,0 +426,2 @@\n+    id<MTLTexture> dest = dstOps->pTexture;\n+    J2dTraceLn5(J2D_TRACE_INFO, \"MTLRenderer_FillRect (x=%d y=%d w=%d h=%d), dst tex=%p\", x, y, w, h, dest);\n@@ -519,3 +429,4 @@\n-    MTLRenderer_AddVertexToBatch(x, y);\n-    MTLRenderer_AddVertexToBatch(x, y+h);\n-    MTLRenderer_AddVertexToBatch(x+w, y);\n+    \/\/ Encode render command.\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+    if (mtlEncoder == nil)\n+        return;\n@@ -523,3 +434,2 @@\n-    MTLRenderer_AddVertexToBatch(x, y+h);\n-    MTLRenderer_AddVertexToBatch(x+w, y);\n-    MTLRenderer_AddVertexToBatch(x+w, y+h);\n+    [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypeTriangleStrip vertexStart:0 vertexCount: QUAD_VERTEX_COUNT];\n@@ -646,6 +556,6 @@\n-    \/\/ Make sure we have space for 6 more vertices in the batch\n-    if ( ((currentIndexInBatch + 6) > VERTEX_BATCH_SIZE) ||\n-         (currentBatchNo == (MAX_NO_OF_BATCHES - 1))) {\n-        \/\/ encode the vertex batch\n-        MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n-    }\n+    struct Vertex verts[QUAD_VERTEX_COUNT] = {\n+            { {fx11, fy11}},\n+            { {fx11+dx21, fy11+dy21}},\n+            { {fx11+dx12, fy11+dy12}},\n+            { {fx11 + dx21 + dx12, fy11+ dy21 + dy12}\n+        }};\n@@ -653,1 +563,2 @@\n-    MTLRenderer_SetPrimitiveType(MTLPrimitiveTypeTriangle);\n+    \/\/ Encode render command.\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];;\n@@ -655,3 +566,4 @@\n-    MTLRenderer_AddVertexToBatch(fx11, fy11);\n-    MTLRenderer_AddVertexToBatch(fx11+dx21, fy11+dy21);\n-    MTLRenderer_AddVertexToBatch(fx11 + dx21 + dx12, fy11+ dy21 + dy12);\n+    if (mtlEncoder == nil) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_FillParallelogram: error creating MTLRenderCommandEncoder.\");\n+        return;\n+    }\n@@ -659,3 +571,2 @@\n-    MTLRenderer_AddVertexToBatch(fx11 + dx21 + dx12, fy11+ dy21 + dy12);\n-    MTLRenderer_AddVertexToBatch(fx11 + dx12, fy11+dy12);\n-    MTLRenderer_AddVertexToBatch(fx11, fy11);\n+    [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypeTriangleStrip vertexStart:0 vertexCount: QUAD_VERTEX_COUNT];\n@@ -723,1 +634,0 @@\n-\n@@ -725,8 +635,2 @@\n-        \/\/ Make sure we have space for 24 more vertices in the batch\n-        if ( ((currentIndexInBatch + TOTAL_VERTICES) > VERTEX_BATCH_SIZE) ||\n-             (currentBatchNo == (MAX_NO_OF_BATCHES - 1))) {\n-            \/\/ encode the vertex batch\n-            MTLRenderer_SubmitVertexBatch(mtlc, dstOps);\n-        }\n-        MTLRenderer_SetPrimitiveType(MTLPrimitiveTypeTriangle);\n-\n+        struct Vertex vertexList[TOTAL_VERTICES];\n+        int i = 0;\n@@ -739,3 +643,3 @@\n-        MTLRenderer_AddVertexToBatch(fx11, fy11);\n-        MTLRenderer_AddVertexToBatch(fx11 + dx21, fy11 + dy21);\n-        MTLRenderer_AddVertexToBatch(fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + dx21, fy11 + dy21);\n+        fillVertex(vertexList + (i++), fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n@@ -743,3 +647,3 @@\n-        MTLRenderer_AddVertexToBatch(fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n-        MTLRenderer_AddVertexToBatch(fx11 + ldx12, fy11 + ldy12);\n-        MTLRenderer_AddVertexToBatch(fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n+        fillVertex(vertexList + (i++), fx11 + ldx12, fy11 + ldy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n@@ -751,3 +655,3 @@\n-        MTLRenderer_AddVertexToBatch(fx11, fy11);\n-        MTLRenderer_AddVertexToBatch(fx11 + ldx21, fy11 + ldy21);\n-        MTLRenderer_AddVertexToBatch(fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + ldx21, fy11 + ldy21);\n+        fillVertex(vertexList + (i++), fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n@@ -755,3 +659,3 @@\n-        MTLRenderer_AddVertexToBatch(fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n-        MTLRenderer_AddVertexToBatch(fx11 + dx12, fy11 + dy12);\n-        MTLRenderer_AddVertexToBatch(fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n+        fillVertex(vertexList + (i++), fx11 + dx12, fy11 + dy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n@@ -763,3 +667,3 @@\n-        MTLRenderer_AddVertexToBatch(fx11, fy11);\n-        MTLRenderer_AddVertexToBatch(fx11 + dx21, fy11 + dy21);\n-        MTLRenderer_AddVertexToBatch(fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + dx21, fy11 + dy21);\n+        fillVertex(vertexList + (i++), fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n@@ -767,3 +671,3 @@\n-        MTLRenderer_AddVertexToBatch(fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n-        MTLRenderer_AddVertexToBatch(fx11 + ldx12, fy11 + ldy12);\n-        MTLRenderer_AddVertexToBatch(fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n+        fillVertex(vertexList + (i++), fx11 + ldx12, fy11 + ldy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n@@ -775,3 +679,3 @@\n-        MTLRenderer_AddVertexToBatch(fx11, fy11);\n-        MTLRenderer_AddVertexToBatch(fx11 + ldx21, fy11 + ldy21);\n-        MTLRenderer_AddVertexToBatch(fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + ldx21, fy11 + ldy21);\n+        fillVertex(vertexList + (i++), fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n@@ -779,3 +683,6 @@\n-        MTLRenderer_AddVertexToBatch(fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n-        MTLRenderer_AddVertexToBatch(fx11 + dx12, fy11 + dy12);\n-        MTLRenderer_AddVertexToBatch(fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n+        fillVertex(vertexList + (i++), fx11 + dx12, fy11 + dy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+\n+        \/\/ Encode render command.\n+        id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n@@ -783,0 +690,7 @@\n+        if (mtlEncoder == nil) {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_DrawParallelogram: error creating MTLRenderCommandEncoder.\");\n+            return;\n+        }\n+\n+        [mtlEncoder setVertexBytes:vertexList length:sizeof(vertexList) atIndex:MeshVertexBuffer];\n+        [mtlEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:TOTAL_VERTICES];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.m","additions":99,"deletions":185,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @key headful\n- * @bug 8287600 8291266\n- * @requires os.family == \"mac\"\n- * @summary [macosx] Some primitives do not render in metal pipeline\n- * @run main DrawPrimitivesTest\n- *\/\n-\n-import java.awt.AWTException;\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.Point;\n-import java.awt.RenderingHints;\n-import java.awt.Robot;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.concurrent.CountDownLatch;\n-import javax.swing.JFrame;\n-import javax.swing.JPanel;\n-import javax.swing.SwingUtilities;\n-\n-public abstract class DrawPrimitivesTest extends JFrame {\n-    private final static int W = 800;\n-    private final static int H = 800;\n-    private final static Color[] color = { Color.RED, Color.BLUE, Color.GREEN};\n-    private final static int COLOR_TOLERANCE = 10;\n-    private final CountDownLatch latchRender = new CountDownLatch(1);\n-    private volatile int frameX0 = 0;\n-    private volatile int frameY0 = 0;\n-    private final String name;\n-\n-\n-    private static boolean isAlmostEqual(Color c1, Color c2) {\n-        return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE &&\n-                Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE &&\n-                Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE;\n-\n-    }\n-\n-    public static void main(String[] args) throws InterruptedException, AWTException, InvocationTargetException {\n-        new DrawPrimitivesTest(\"drawLine\") {\n-            public void renderPrimitive(Graphics2D g2d, int x0, int y0, int w, int h) {\n-                g2d.drawLine(x0, y0, x0+w, y0+h);\n-            }\n-        }.runTest();\n-\n-        new DrawPrimitivesTest(\"fillRect\") {\n-            public void renderPrimitive(Graphics2D g2d, int x0, int y0, int w, int h) {\n-                g2d.fillRect(x0, y0, w, h);\n-            }\n-        }.runTest();\n-\n-        new DrawPrimitivesTest(\"fillOvalAA\") {\n-            public void renderPrimitive(Graphics2D g2d, int x0, int y0, int w, int h) {\n-                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n-                g2d.fillOval(x0, y0, w, h);\n-            }\n-        }.runTest();\n-    }\n-\n-    public abstract void renderPrimitive(Graphics2D g2d, int x0, int y0, int w, int h);\n-\n-    public DrawPrimitivesTest(String name) {\n-        super();\n-        this.name = name;\n-    }\n-\n-    public void runTest() throws InterruptedException, InvocationTargetException, AWTException {\n-        SwingUtilities.invokeLater(() -> {\n-            add(new JPanel() {\n-                @Override\n-                public Dimension getPreferredSize() {\n-                    return new Dimension(W, H);\n-                }\n-\n-                @Override\n-                public void paintComponent(Graphics g) {\n-                    Graphics2D g2d = (Graphics2D) g;\n-                    g2d.setColor(Color.YELLOW);\n-                    int c = 0;\n-                    for (int i = 0; i < W; i += 10) {\n-                        for (int j = 0; j < H; j += 10) {\n-                            c = (c + 1) % color.length;\n-                            g2d.setColor(color[c]);\n-                            renderPrimitive(g2d, i, j, 10, 10);\n-                        }\n-                    }\n-                    Point p = getLocationOnScreen();\n-                    frameX0 = p.x;\n-                    frameY0 = p.y - getInsets().top;\n-\n-                    latchRender.countDown();\n-                }\n-            });\n-            setPreferredSize(new Dimension(W, H));\n-            pack();\n-            setVisible(true);\n-        });\n-\n-        latchRender.await();\n-        Thread.sleep(1000);\n-\n-        Robot robot = new Robot();\n-\n-        boolean hasEmptyContent = true;\n-        l:for (int i = frameX0 + W\/3; i < frameX0 + (2*W)\/3; i++) {\n-            for (int j = 0; j < 10; j += 2) {\n-                if (isAlmostEqual(robot.getPixelColor(i, frameY0 + H \/ 2 + j), Color.RED)) {\n-                    hasEmptyContent = false;\n-                    break l;\n-                }\n-            }\n-        }\n-\n-        SwingUtilities.invokeAndWait(() -> {\n-            setVisible(false);\n-            dispose();\n-        });\n-\n-        if (hasEmptyContent) {\n-            throw new RuntimeException(name + \": Empty content\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/Graphics2D\/DrawPrimitivesTest.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"}]}