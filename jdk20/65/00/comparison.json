{"files":[{"patch":"@@ -1708,1 +1708,1 @@\n-  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit);\n+  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit, b_test);\n@@ -1997,1 +1997,1 @@\n-  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr);\n+  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr, main_end->test_trip());\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"subnode.hpp\"\n@@ -75,1 +76,5 @@\n-  OpaqueZeroTripGuardNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  \/\/ This captures the test that returns true when the loop is entered. It depends on whether the loop goes up or down.\n+  \/\/ This is used by CmpINode::Value.\n+  BoolTest::mask _loop_entered_mask;\n+  OpaqueZeroTripGuardNode(Compile* C, Node* n, BoolTest::mask loop_entered_test) :\n+          Opaque1Node(C, n), _loop_entered_mask(loop_entered_test) {\n@@ -78,0 +83,3 @@\n+  virtual uint size_of() const {\n+    return sizeof(*this);\n+  }\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1681,0 +1681,7 @@\n+    if (use->Opcode() == Op_OpaqueZeroTripGuard) {\n+      assert(use->outcnt() <= 1, \"OpaqueZeroTripGuard can't be shared\");\n+      if (use->outcnt() == 1) {\n+        Node* cmp = use->unique_out();\n+        _worklist.push(cmp);\n+      }\n+    }\n@@ -1851,0 +1858,1 @@\n+  push_opaque_zero_trip_guard(worklist, use);\n@@ -1971,0 +1979,6 @@\n+void PhaseCCP::push_opaque_zero_trip_guard(Unique_Node_List& worklist, const Node* use) const {\n+  if (use->Opcode() == Op_OpaqueZeroTripGuard) {\n+    push_if_not_bottom_type(worklist, use->unique_out());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -599,0 +599,1 @@\n+  void push_opaque_zero_trip_guard(Unique_Node_List& worklist, const Node* use) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -664,0 +665,41 @@\n+const Type* CmpINode::Value(PhaseGVN* phase) const {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  \/\/ If this test is the zero trip guard for a main or post loop, check whether, with the opaque node removed, the test\n+  \/\/ would constant fold so the loop is never entered. If so return the type of the test without the opaque node removed:\n+  \/\/ make the loop unreachable.\n+  \/\/ The reason for this is that the iv phi captures the bounds of the loop and if the loop becomes unreachable, it can\n+  \/\/ become top. In that case, the loop must be removed.\n+  \/\/ This is safe because:\n+  \/\/ - as optimizations proceed, the range of iterations executed by the main loop narrows. If no iterations remain, then\n+  \/\/ we're done with optimizations for that loop.\n+  \/\/ - the post loop is initially not reachable but as long as there's a main loop, the zero trip guard for the post\n+  \/\/ loop takes a phi that merges the pre and main loop's iv and can't constant fold the zero trip guard. Once, the main\n+  \/\/ loop is removed, there's no need to preserve the zero trip guard for the post loop anymore.\n+  if (in1 != NULL && in2 != NULL) {\n+    uint input = 0;\n+    Node* cmp = NULL;\n+    BoolTest::mask test;\n+    if (in1->Opcode() == Op_OpaqueZeroTripGuard && phase->type(in1) != Type::TOP) {\n+      cmp = new CmpINode(in1->in(1), in2);\n+      test = ((OpaqueZeroTripGuardNode*)in1)->_loop_entered_mask;\n+    }\n+    if (in2->Opcode() == Op_OpaqueZeroTripGuard && phase->type(in2) != Type::TOP) {\n+      assert(cmp == NULL, \"A cmp with 2 OpaqueZeroTripGuard inputs\");\n+      cmp = new CmpINode(in1, in2->in(1));\n+      test = ((OpaqueZeroTripGuardNode*)in2)->_loop_entered_mask;\n+    }\n+    if (cmp != NULL) {\n+      const Type* cmp_t = cmp->Value(phase);\n+      const Type* t = BoolTest(test).cc2logical(cmp_t);\n+      cmp->destruct(phase);\n+      if (t == TypeInt::ZERO) {\n+        return cmp_t;\n+      }\n+    }\n+  }\n+\n+  return SubNode::Value(phase);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298176\n+ * @summary Must remove OpaqueZeroTripGuardPostLoop after main loop disappears else\n+ *          the zero-trip-guard of the post loop cannot die and leaves an inconsistent\n+ *          graph behind.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,TestOpaqueZeroTripGuardPostLoopRemoval::test*\n+ *      -XX:CompileCommand=dontinline,TestOpaqueZeroTripGuardPostLoopRemoval::*\n+ *      TestOpaqueZeroTripGuardPostLoopRemoval\n+ *\/\n+\n+public class TestOpaqueZeroTripGuardPostLoopRemoval {\n+    static long x;\n+\n+    public static void main(String[] strArr) {\n+        test_001();\n+        test_002();\n+        try {\n+            test_003();\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+        test_004();\n+        test_005();\n+    }\n+\n+    static void test_001() {\n+        int b = 6;\n+        for (long l = 1; l < 9; l++) {\n+            b++;\n+        }\n+        for (int i = 1; i < 1000; i*=2) {\n+            for (int j = 1; j < 2; j++) {\n+                x = b + 1;\n+            }\n+        }\n+    }\n+\n+    static void test_002() {\n+        int b = 6;\n+        for (long l = 60; l < 3000; l+=3) {\n+            \/\/ bounds of loop: no work for post loop\n+            b += 33; \/\/ any multiple of iv step\n+        }\n+        for (int i = 1; i < 1000; i*=2) {\n+            for (int j = 1; j < 2; j++) {\n+                x = b + 1;\n+            }\n+        }\n+    }\n+\n+    static void dontInline() {\n+        throw new RuntimeException();\n+    }\n+\n+    static int test_003() {\n+        int y = 3;\n+        for (int i = 0; i < 9; ) {\n+            for (long l = 1; l < 5; l++) {\n+                y *= 2;\n+            }\n+            while (true) {\n+                dontInline();\n+            }\n+        }\n+        return y;\n+    }\n+\n+    static void test_004() {\n+        for (int i2 = 4; i2 < 13; i2++) {\n+            double d = 56;\n+            for (long l = 1; l < 5; l++) {\n+                d = d + 3;\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                for (int d2 = i2; d2 < 2; d2 = 3) {\n+                }\n+            }\n+        }\n+    }\n+\n+    public static int test_005() {\n+        long arr[]=new long[400];\n+        for (int i = 3; i < 177; i++) {\n+            for (int j = 0; j < 10; j++){}\n+        }\n+        int y = 0;\n+        for (int i = 15; i < 356; i++) {\n+            \/\/ Inner loop prevents strip-mining of outer loop\n+            \/\/ later, inner loop is removed, so outer does pre-main-post without strip-mining\n+            for (int j = 0; j < 10; j++){\n+                y |= 1;\n+            }\n+        }\n+        return y;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOpaqueZeroTripGuardPostLoopRemoval.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}