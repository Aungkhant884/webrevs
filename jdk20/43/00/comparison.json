{"files":[{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import jdk.jfr.Configuration;\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.ValueDescriptor;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedClassLoader;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedObject;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.jfr.TestClassLoader;\n+\n+\/**\n+ * @test\n+ * @ignore\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jvm.TestChunkIntegrity\n+ *\/\n+public class TestChunkIntegrity {\n+\n+    static abstract class StressThread extends Thread {\n+        private volatile boolean keepAlive = true;\n+        private final Random random = new Random();\n+\n+        public void run() {\n+            try {\n+                while (keepAlive) {\n+                    int count = random.nextInt(1_000) + 1;\n+                    for (int i = 0; i < count; i++) {\n+                        stress();\n+                    }\n+                    System.out.println(count + \" \" + this.getClass().getName());\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        abstract protected void stress() throws Exception;\n+\n+        public void kill() {\n+            keepAlive = false;\n+            try {\n+                join();\n+            } catch (InterruptedException e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        Configuration c = Configuration.getConfiguration(\"profile\");\n+        Path file = Path.of(\"recording.jfr\");\n+        try (Recording r = new Recording(c)) {\n+            r.start();\n+            List<StressThread> threads = new ArrayList<>();\n+            threads.add(new ClassStressor());\n+            threads.add(new ThreadStressor());\n+            threads.add(new StringStressor());\n+            threads.forEach(StressThread::start);\n+            for (int i = 0; i < 10; i++) {\n+                try (Recording t = new Recording()) {\n+                    t.start();\n+                }\n+            }\n+            threads.forEach(StressThread::kill);\n+            r.dump(file);\n+\n+            \/\/ Split recording file\n+            Path directory = Path.of(\"disassembled\");\n+            Files.createDirectories(directory);\n+            disassemble(file, directory);\n+\n+            \/\/ Verification\n+            List<RecordedEvent> full = RecordingFile.readAllEvents(file);\n+            List<Path> chunkFiles = new ArrayList<>(Files.list(directory).toList());\n+            Collections.sort(chunkFiles);\n+            int total = 0;\n+            for (Path chunkFile : chunkFiles) {\n+                System.out.println(\"Veryfying chunk: \" + chunkFile + \" \" + total);\n+                try (RecordingFile f = new RecordingFile(chunkFile)) {\n+                    int index = 0;\n+                    while (f.hasMoreEvents()) {\n+                        RecordedEvent event = f.readEvent();\n+                        assertStressEvent(event, f, index);\n+                        assertEventEquals(full.get(total + index), event, index);\n+                        index++;\n+                    }\n+                    total += index;\n+                }\n+            }\n+            System.out.println(\"Event count: \" + total);\n+        }\n+    }\n+\n+    static void assertStressEvent(RecordedEvent event, RecordingFile f, int index) throws IOException {\n+        String name = event.getEventType().getName();\n+        if (name.equals(\"String\") || name.equals(\"Thread\") || name.equals(\"Clazz\")) {\n+            String fieldName = name.toLowerCase();\n+            Object value = event.getValue(fieldName);\n+            if (value == null) {\n+                writeFailureFile(f, index);\n+                throw new AssertionError(\"Null found in \" + name + \" event. Event number \" + index);\n+            }\n+            RecordedStackTrace stackTrace = event.getStackTrace();\n+            if (stackTrace == null) {\n+                writeFailureFile(f, index);\n+                throw new AssertionError(\"Stack trace was null. Event number \" + index);\n+            }\n+        }\n+    }\n+\n+    private static void writeFailureFile(RecordingFile f, int index) throws IOException {\n+        Path file = Path.of(\"failure.jfr\");\n+        AtomicInteger count = new AtomicInteger();\n+        f.write(file, e-> count.incrementAndGet() == index + 1);\n+        System.out.println(\"Failure file with only event \" + index + \" written to: \" + file);\n+    }\n+\n+    static void assertEventEquals(RecordedEvent a, RecordedEvent b, int index) {\n+        if (a.getEventType().getId() != b.getEventType().getId()) {\n+            printRecordedObjects(a, b);\n+            throw new AssertionError(\"Event types don't match. Event number \" + index);\n+        }\n+        for (ValueDescriptor field : a.getEventType().getFields()) {\n+            String n = field.getName();\n+            if (!isEqual(a.getValue(n), b.getValue(n))) {\n+                printRecordedObjects(a, b);\n+                throw new AssertionError(\"Events don't match. Event number \" + index);\n+            }\n+        }\n+    }\n+\n+    private static void printRecordedObjects(RecordedObject a, RecordedObject b) {\n+        System.out.println(\"Object A:\");\n+        System.out.println(a);\n+        System.out.println(\"Object B:\");\n+        System.out.println(b);\n+    }\n+\n+    private static boolean isEqual(Object a, Object b) {\n+        if (a == null && b == null) {\n+            return true;\n+        }\n+        if (a == null || b == null) {\n+            System.out.println(\"One value null\");\n+            System.out.println(\"Value A: \" + a);\n+            System.out.println(\"Value B: \" + b);\n+            return false;\n+        }\n+        if (a.getClass() != b.getClass()) {\n+            System.out.println(\"Not same class\");\n+            return false;\n+        }\n+        if (a instanceof Double d1 && b instanceof Double d2) {\n+            return Double.doubleToRawLongBits(d1) == Double.doubleToRawLongBits(d2);\n+        }\n+        if (a instanceof Float f1 && b instanceof Float f2) {\n+            return Float.floatToRawIntBits(f1) == Float.floatToRawIntBits(f2);\n+        }\n+        if (a instanceof String || a instanceof Number || a instanceof Boolean) {\n+            return Objects.equals(a, b);\n+        }\n+        \/\/ Thread name may change, so sufficient to compare ID\n+        if (a instanceof RecordedThread t1 && b instanceof RecordedThread t2) {\n+            return t1.getId() == t2.getId();\n+        }\n+        if (a instanceof RecordedObject r1 && b instanceof RecordedObject r2) {\n+            for (ValueDescriptor field : r1.getFields()) {\n+                String n = field.getName();\n+                if (!isEqual(r1.getValue(n), r2.getValue(n))) {\n+                    System.out.println(\"Field \" + n + \" doesn't match\");\n+                    System.out.println(\"Value A: \" + r1.getValue(n));\n+                    System.out.println(\"Value B: \" + r2.getValue(n));\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        if (a.getClass().isArray()) {\n+            Object[] array = (Object[]) a;\n+            Object[] brray = (Object[]) b;\n+            if (array.length != brray.length) {\n+                System.out.println(\"Array size doesn't match\");\n+                return false;\n+            }\n+            for (int i = 0; i < array.length; i++) {\n+                if (!isEqual(array[i], brray[i])) {\n+                    System.out.println(\"Array contents doesn't match\");\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        throw new AssertionError(\"Unknown object type \" + a.getClass() + \" found\");\n+    }\n+\n+    public static void disassemble(Path file, Path output) throws Throwable {\n+        JDKToolLauncher l = JDKToolLauncher.createUsingTestJDK(\"jfr\");\n+        l.addToolArg(\"disassemble\");\n+        l.addToolArg(\"--output\");\n+        l.addToolArg(output.toAbsolutePath().toString());\n+        l.addToolArg(\"--max-chunks\");\n+        l.addToolArg(\"1\");\n+        l.addToolArg(file.toAbsolutePath().toString());\n+        ProcessTools.executeCommand(l.getCommand());\n+    }\n+\n+    static class MyClass {\n+    }\n+\n+    static class ClassStressor extends StressThread {\n+        @Name(\"Clazz\")\n+        static class ClassEvent extends Event {\n+            Class<?> clazz;\n+        }\n+\n+        @Override\n+        protected void stress() throws Exception {\n+            TestClassLoader loader = new TestClassLoader();\n+            Class<?> clazz = loader.loadClass(MyClass.class.getName());\n+            if (clazz == null) {\n+                throw new AssertionError(\"No class generated\");\n+            }\n+            ClassEvent e = new ClassEvent();\n+            e.clazz = clazz;\n+            e.commit();\n+        }\n+    }\n+\n+    static class ThreadStressor extends StressThread {\n+        @Name(\"Thread\")\n+        static class ThreadEvent extends Event {\n+            Thread thread;\n+        }\n+\n+        @Override\n+        protected void stress() throws Exception {\n+            Thread t = new Thread(() -> {\n+                ThreadEvent e = new ThreadEvent();\n+                e.thread = this;\n+                e.commit();\n+            });\n+            t.start();\n+            t.join();\n+        }\n+    }\n+\n+    static class StringStressor extends StressThread {\n+        @Name(\"String\")\n+        static class StringEvent extends Event {\n+            String string;\n+        }\n+\n+        private long counter = 0;\n+\n+        @Override\n+        protected void stress() throws Exception {\n+            String text = String.valueOf(counter) + \"012345678901234567890\";\n+            \/\/ Repeat string so characters are stored in check point event\n+            for (int i = 0; i < 10; i++) {\n+                StringEvent e = new StringEvent();\n+                e.string = text;\n+                e.commit();\n+            }\n+            counter++;\n+            Thread.sleep(1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestChunkIntegrity.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"}]}