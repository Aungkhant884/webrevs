{"files":[{"patch":"@@ -403,0 +403,2 @@\n+  OpaqueZeroTripGuardNode* find_opaque_zero_trip_guard() const;\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,4 +410,3 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n-  uint next = 0;\n-  while (next < useful.size()) {\n-    Node *n = useful.at(next++);\n+void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist, PhaseIterGVN* igvn) {\n+  for (uint i = 0; i < useful.size(); i++) {\n+    Node *n = useful.at(i);\n@@ -432,0 +431,14 @@\n+    if (n->is_If() && n->outcnt() < 2) {\n+      IfNode* iff = n->as_If();\n+      OpaqueZeroTripGuardNode* opaq = iff->find_opaque_zero_trip_guard();\n+      if (opaq != nullptr) {\n+        \/\/ We removed the LoopNode during CCP, but still have the zero trip guard\n+        \/\/ which did not collapse because of the Opaque node, remove it now.\n+        \/\/ If the LoopNode dies during IGVN, we catch that in RegionNode::Ideal\n+        \/\/ and remove the respective Opaque node there.\n+        ProjNode* proj = iff->unique_ctrl_out()->as_Proj();\n+        assert(igvn != nullptr, \"must happen when we have igvn\");\n+        ConNode* con = igvn->intcon(proj->_con);\n+        igvn->replace_input_of(iff, 1, con);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -953,1 +953,1 @@\n-  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n+  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist, PhaseIterGVN* igvn = nullptr);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1741,0 +1741,23 @@\n+\/\/ Find this pattern: If -> Bool -> CmpI -> OpaqueZeroTripGuard\n+\/\/ For the main loop, the opaque node is the second input to cmp,\n+\/\/ for the post loop it's the first input node.\n+OpaqueZeroTripGuardNode* IfNode::find_opaque_zero_trip_guard() const {\n+  Node* bol = in(1);\n+  if (bol != nullptr && bol->is_Bool()) {\n+    Node* cmp = bol->in(1);\n+    if (cmp != nullptr && cmp->Opcode() == Op_CmpI) {\n+      Node* in1 = (cmp->req() > 1) ? cmp->in(1) : nullptr;\n+      if (in1 != nullptr && in1->is_OpaqueZeroTripGuard()) {\n+        assert(in1->is_OpaqueZeroTripGuardPostLoop(), \"post loop pattern\");\n+        return in1->as_OpaqueZeroTripGuard();\n+      }\n+      Node* in2 = (cmp->req() > 2) ? cmp->in(2) : nullptr;\n+      if (in2 != nullptr && in2->is_OpaqueZeroTripGuard()) {\n+        assert(in2->is_OpaqueZeroTripGuardMainLoop(), \"main loop pattern\");\n+        return in2->as_OpaqueZeroTripGuard();\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1297,9 +1297,5 @@\n-  Node* zer_bol = node->in(0)->in(1);\n-  assert(zer_bol != NULL && zer_bol->is_Bool(), \"must be Bool\");\n-  Node* zer_cmp = zer_bol->in(1);\n-  assert(zer_cmp != NULL && zer_cmp->Opcode() == Op_CmpI, \"must be CmpI\");\n-  \/\/ For the main loop, the opaque node is the second input to zer_cmp, for the post loop it's the first input node\n-  Node* zer_opaq = zer_cmp->in(is_main_loop ? 2 : 1);\n-  assert(zer_opaq != NULL &&\n-         (is_main_loop ? zer_opaq->is_OpaqueZeroTripGuardMainLoop()\n-                       : zer_opaq->is_OpaqueZeroTripGuardPostLoop()),\n+  IfNode* iff = node->in(0)->as_If();\n+  OpaqueZeroTripGuardNode* opaq = iff->find_opaque_zero_trip_guard();\n+  assert(opaq != NULL &&\n+         (is_main_loop ? opaq->is_OpaqueZeroTripGuardMainLoop()\n+                       : opaq->is_OpaqueZeroTripGuardPostLoop()),\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5454,1 +5454,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5457,14 +5457,1 @@\n-\n-  if (ctrl == NULL || (!ctrl->is_IfTrue() && !ctrl->is_IfFalse())) {\n-    return NULL;\n-  }\n-  Node* iffm = ctrl->in(0);\n-  if (iffm == NULL || !iffm->is_If()) {\n-    return NULL;\n-  }\n-  Node* bolzm = iffm->in(1);\n-  if (bolzm == NULL || !bolzm->is_Bool()) {\n-    return NULL;\n-  }\n-  Node* cmpzm = bolzm->in(1);\n-  if (cmpzm == NULL || !cmpzm->is_Cmp()) {\n+  if (ctrl == nullptr || (!ctrl->is_IfTrue() && !ctrl->is_IfFalse())) {\n@@ -5473,3 +5460,2 @@\n-\n-  uint input = is_main_loop() ? 2 : 1;\n-  if (input >= cmpzm->req() || cmpzm->in(input) == NULL) {\n+  Node* iff = ctrl->in(0);\n+  if (iff == NULL || !iff->is_If()) {\n@@ -5478,13 +5464,1 @@\n-  bool res = cmpzm->in(input)->is_OpaqueZeroTripGuard();\n-#ifdef ASSERT\n-  bool found_opaque = false;\n-  for (uint i = 1; i < cmpzm->req(); i++) {\n-    Node* opnd = cmpzm->in(i);\n-    if (opnd && opnd->is_Opaque1()) {\n-      found_opaque = true;\n-      break;\n-    }\n-  }\n-  assert(found_opaque == res, \"wrong pattern\");\n-#endif\n-  return res ? cmpzm->in(input) : NULL;\n+  return iff->as_If()->find_opaque_zero_trip_guard();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2045,1 +2045,1 @@\n-  C->disconnect_useless_nodes(useful, &_worklist);\n+  C->disconnect_useless_nodes(useful, &_worklist, this);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}