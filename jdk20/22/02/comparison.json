{"files":[{"patch":"@@ -620,3 +620,3 @@\n-          \/\/ This is not a loop anymore. No need to keep the Opaque1 node on the test that guards the loop as it won't be\n-          \/\/ subject to further loop opts.\n-          assert(opaq->Opcode() == Op_OpaqueZeroTripGuard, \"\");\n+          \/\/ This is not a loop anymore. No need to keep the OpaqueZeroTripGuard node\n+          \/\/ on the test that guards the loop as it won't be subject to further loop opts.\n+          assert(opaq->is_OpaqueZeroTripGuard(), \"must be zero trip guard\");\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -272,0 +272,2 @@\n+macro(OpaqueZeroTripGuardMainLoop)\n+macro(OpaqueZeroTripGuardPostLoop)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1303,1 +1303,4 @@\n-  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_OpaqueZeroTripGuard, \"must be OpaqueZeroTripGuard\");\n+  assert(zer_opaq != NULL &&\n+         (is_main_loop ? zer_opaq->is_OpaqueZeroTripGuardMainLoop()\n+                       : zer_opaq->is_OpaqueZeroTripGuardPostLoop()),\n+         \"must be OpaqueZeroTripGuard for main or post loop\");\n@@ -1708,3 +1711,3 @@\n-  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit);\n-  Node *min_cmp  = new CmpINode(pre_incr, min_opaq);\n-  Node *min_bol  = new BoolNode(min_cmp, b_test);\n+  Node* min_opaq = new OpaqueZeroTripGuardMainLoopNode(C, limit);\n+  Node* min_cmp  = new CmpINode(pre_incr, min_opaq);\n+  Node* min_bol  = new BoolNode(min_cmp, b_test);\n@@ -1997,3 +2000,3 @@\n-  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr);\n-  Node *zer_cmp = new CmpINode(zer_opaq, limit);\n-  Node *zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n+  Node* zer_opaq = new OpaqueZeroTripGuardPostLoopNode(C, incr);\n+  Node* zer_cmp = new CmpINode(zer_opaq, limit);\n+  Node* zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n@@ -3581,1 +3584,1 @@\n-  assert(main_cmp->in(2)->Opcode() == Op_OpaqueZeroTripGuard, \"main loop has no opaque node?\");\n+  assert(main_cmp->in(2)->is_OpaqueZeroTripGuardMainLoop(), \"main loop has no opaque node?\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -5478,1 +5478,1 @@\n-  bool res = cmpzm->in(input)->Opcode() == Op_OpaqueZeroTripGuard;\n+  bool res = cmpzm->in(input)->is_OpaqueZeroTripGuard();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,0 +133,5 @@\n+class OpaqueLoopInitNode;\n+class OpaqueLoopStrideNode;\n+class OpaqueZeroTripGuardNode;\n+class OpaqueZeroTripGuardMainLoopNode;\n+class OpaqueZeroTripGuardPostLoopNode;\n@@ -763,0 +768,5 @@\n+        DEFINE_CLASS_ID(OpaqueLoopInit,      Opaque1, 0)\n+        DEFINE_CLASS_ID(OpaqueLoopStride,    Opaque1, 1)\n+        DEFINE_CLASS_ID(OpaqueZeroTripGuard, Opaque1, 2)\n+            DEFINE_CLASS_ID(OpaqueZeroTripGuardMainLoop, OpaqueZeroTripGuard, 0)\n+            DEFINE_CLASS_ID(OpaqueZeroTripGuardPostLoop, OpaqueZeroTripGuard, 1)\n@@ -926,0 +936,5 @@\n+  DEFINE_CLASS_QUERY(OpaqueLoopInit)\n+  DEFINE_CLASS_QUERY(OpaqueLoopStride)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuard)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuardMainLoop)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuardPostLoop)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-  OpaqueLoopInitNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueLoopInitNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueLoopInit);\n@@ -68,1 +69,2 @@\n-  OpaqueLoopStrideNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueLoopStrideNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueLoopStride);\n@@ -75,1 +77,18 @@\n-  OpaqueZeroTripGuardNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueZeroTripGuardNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuard);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class OpaqueZeroTripGuardMainLoopNode : public OpaqueZeroTripGuardNode {\n+public:\n+  OpaqueZeroTripGuardMainLoopNode(Compile* C, Node* n) : OpaqueZeroTripGuardNode(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuardMainLoop);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class OpaqueZeroTripGuardPostLoopNode : public OpaqueZeroTripGuardNode {\n+public:\n+  OpaqueZeroTripGuardPostLoopNode(Compile* C, Node* n) : OpaqueZeroTripGuardNode(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuardPostLoop);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n+  if (n->is_OpaqueZeroTripGuard()) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1447,1 +1447,1 @@\n-  if (con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_OpaqueZeroTripGuard &&\n+  if (con->is_Con() && !cmp2->is_Con() && !cmp2->is_OpaqueZeroTripGuard() &&\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298176\n+ * @summary Must remove OpaqueZeroTripGuardPostLoop after main loop disappears else\n+ *          the zero-trip-guard of the post loop cannot die and leaves an inconsistent\n+ *          graph behind.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,TestOpaqueZeroTripGuardPostLoopRemoval::test*\n+ *      -XX:CompileCommand=dontinline,TestOpaqueZeroTripGuardPostLoopRemoval::*\n+ *      TestOpaqueZeroTripGuardPostLoopRemoval\n+ *\/\n+\n+public class TestOpaqueZeroTripGuardPostLoopRemoval {\n+    static long x;\n+\n+    public static void main(String[] strArr) {\n+        test_001();\n+        test_002();\n+        try {\n+            test_003();\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+        test_004();\n+        test_005();\n+    }\n+\n+    static void test_001() {\n+        int b = 6;\n+        for (long l = 1; l < 9; l++) {\n+            b++;\n+        }\n+        for (int i = 1; i < 1000; i*=2) {\n+            for (int j = 1; j < 2; j++) {\n+                x = b + 1;\n+            }\n+        }\n+    }\n+\n+    static void test_002() {\n+        int b = 6;\n+        for (long l = 60; l < 3000; l+=3) {\n+            \/\/ bounds of loop: no work for post loop\n+            b += 33; \/\/ any multiple of iv step\n+        }\n+        for (int i = 1; i < 1000; i*=2) {\n+            for (int j = 1; j < 2; j++) {\n+                x = b + 1;\n+            }\n+        }\n+    }\n+\n+    static void dontInline() {\n+        throw new RuntimeException();\n+    }\n+\n+    static int test_003() {\n+        int y = 3;\n+        for (int i = 0; i < 9; ) {\n+            for (long l = 1; l < 5; l++) {\n+                y *= 2;\n+            }\n+            while (true) {\n+                dontInline();\n+            }\n+        }\n+        return y;\n+    }\n+\n+    static void test_004() {\n+        for (int i2 = 4; i2 < 13; i2++) {\n+            double d = 56;\n+            for (long l = 1; l < 5; l++) {\n+                d = d + 3;\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                for (int d2 = i2; d2 < 2; d2 = 3) {\n+                }\n+            }\n+        }\n+    }\n+\n+    public static int test_005() {\n+        long arr[]=new long[400];\n+        for (int i = 3; i < 177; i++) {\n+            for (int j = 0; j < 10; j++){}\n+        }\n+        int y = 0;\n+        for (int i = 15; i < 356; i++) {\n+            \/\/ Inner loop prevents strip-mining of outer loop\n+            \/\/ later, inner loop is removed, so outer does pre-main-post without strip-mining\n+            for (int j = 0; j < 10; j++){\n+                y |= 1;\n+            }\n+        }\n+        return y;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOpaqueZeroTripGuardPostLoopRemoval.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}