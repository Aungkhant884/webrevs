{"files":[{"patch":"@@ -2970,3 +2970,8 @@\n-    OuterStripMinedLoopNode* head = loopnode();\n-    if (head != nullptr && head->find_out_with(Op_Phi) != nullptr) {\n-      return true;\n+    Node* backedge = proj_out_or_null(true);\n+    if (backedge != NULL) {\n+      Node* head = backedge->unique_ctrl_out_or_null();\n+      if (head != NULL && head->is_OuterStripMinedLoop()) {\n+        if (head->find_out_with(Op_Phi) != NULL) {\n+          return true;\n+        }\n+      }\n@@ -2978,11 +2983,0 @@\n-OuterStripMinedLoopNode* OuterStripMinedLoopEndNode::loopnode() const {\n-  Node* backedge = proj_out_or_null(true);\n-  if (backedge != nullptr) {\n-    Node* head = backedge->unique_ctrl_out_or_null();\n-    if (head != nullptr && head->is_OuterStripMinedLoop()) {\n-      return head->as_OuterStripMinedLoop();\n-    }\n-  }\n-  return nullptr; \/\/ not found\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -595,1 +595,0 @@\n-  OuterStripMinedLoopNode* loopnode() const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"opto\/loopnode.hpp\"\n@@ -48,93 +47,0 @@\n-\/\/ Is there to hold off with optimizing post loop based on type of limit\n-\/\/ as long as main loop is around and can still change the limit due to\n-\/\/ unrolling. Pattern we are looking for:\n-\/\/\n-\/\/               +--------+\n-\/\/               |        |\n-\/\/      strip_mined_head  |\n-\/\/       |                |\n-\/\/      main_head (main)  |\n-\/\/       |                |\n-\/\/      ...               |\n-\/\/       |                |\n-\/\/      strip_mined_end   |\n-\/\/       |           |    |\n-\/\/       |           +----+     opaq (this)\n-\/\/       |                       |\n-\/\/      main_exit               zer_cmp\n-\/\/       |                       |\n-\/\/   main_zer_region            zer_bol\n-\/\/    |                          |\n-\/\/    +-----------+  +-----------+\n-\/\/                |  |\n-\/\/               zer_if (zero trip guard post loop)\n-\/\/\n-\/\/ In some cases, the main-loop is not strip-mined:\n-\/\/\n-\/\/               +--------+\n-\/\/               |        |\n-\/\/      main_head (main)  |\n-\/\/       |                |\n-\/\/      ...               |\n-\/\/       |                |\n-\/\/      main_end          |\n-\/\/       |    |           |\n-\/\/       |    +-----------+     opaq (this)\n-\/\/       |                       |\n-\/\/      main_exit               zer_cmp\n-\/\/       |                       |\n-\/\/   main_zer_region            zer_bol\n-\/\/    |                          |\n-\/\/    +-----------+  +-----------+\n-\/\/                |  |\n-\/\/               zer_if (zero trip guard post loop)\n-\/\/\n-Node* OpaqueZeroTripGuardPostLoopNode::Identity(PhaseGVN* phase) {\n-  Node* result = OpaqueZeroTripGuardNode::Identity(phase);\n-  if (result != this) {\n-    return result;\n-  }\n-  \/\/ If must still be there, after all we are guarding it\n-  Node* zer_cmp = unique_out();\n-  assert(zer_cmp->Opcode() == Op_CmpI, \"Opaque guards CmpI\");\n-  Node* zer_bol = zer_cmp->unique_out();\n-  assert(zer_bol->is_Bool(), \"Opaque guards Bool\");\n-  Node* zer_if = zer_bol->unique_out();\n-  assert(zer_if->is_If(), \"Opaque guards If\");\n-  \/\/ From here, no assumption is given, the graph may be degenerate\n-  Node* main_zer_region = zer_if->in(0);\n-  if (main_zer_region == nullptr ||\n-      !main_zer_region->is_Region() ||\n-      main_zer_region->req() != 3) {\n-    return in(1); \/\/ degenerate at region, remove Opaque\n-  }\n-  Node* main_exit = main_zer_region->in(2);\n-  if (main_exit == nullptr ||\n-      !main_exit->is_IfProj()) {\n-    return in(1); \/\/ degenerate at main exit, remove Opaque\n-  }\n-  Node* outer_end = main_exit->in(0);\n-  if (outer_end == nullptr) {\n-    return in(1); \/\/ degenerate at outer end, remove Opaque\n-  }\n-  \/\/ find main_head, with or without strip-mining\n-  Node* main_head = nullptr;\n-  if (outer_end->is_OuterStripMinedLoopEnd()) {\n-    OuterStripMinedLoopNode* strip_mined_head = outer_end->as_OuterStripMinedLoopEnd()->loopnode();\n-    if (strip_mined_head == nullptr) {\n-      return in(1); \/\/ degenerate at outer loopnode, remove Opaque\n-    }\n-    main_head = strip_mined_head->unique_ctrl_out_or_null();\n-  } else if (outer_end->is_BaseCountedLoopEnd()) {\n-    main_head = outer_end->as_BaseCountedLoopEnd()->loopnode();\n-  } else {\n-    return in(1); \/\/ degenerate at outer end, remove Opaque\n-  }\n-  if (main_head == nullptr ||\n-      !main_head->is_CountedLoop() ||\n-      !main_head->as_CountedLoop()->is_main_loop()) {\n-    return in(1); \/\/ degenerate at main loop, remove Opaque\n-  }\n-  return this; \/\/ main loop still here, keep this Opaque\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":0,"deletions":94,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}