{"files":[{"filename":"src\/hotspot\/share\/opto\/.opaquenode.cpp.swp","binary":true,"status":"added"},{"filename":"src\/hotspot\/share\/opto\/.opaquenode.hpp.swp","binary":true,"status":"added"},{"patch":"@@ -620,3 +620,3 @@\n-          \/\/ This is not a loop anymore. No need to keep the Opaque1 node on the test that guards the loop as it won't be\n-          \/\/ subject to further loop opts.\n-          assert(opaq->Opcode() == Op_OpaqueZeroTripGuard, \"\");\n+          \/\/ This is not a loop anymore. No need to keep the OpaqueZeroTripGuard node\n+          \/\/ on the test that guards the loop as it won't be subject to further loop opts.\n+          assert(opaq->is_OpaqueZeroTripGuard(), \"must be zero trip guard\");\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -272,0 +272,2 @@\n+macro(OpaqueZeroTripGuardMainLoop)\n+macro(OpaqueZeroTripGuardPostLoop)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1303,1 +1303,4 @@\n-  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_OpaqueZeroTripGuard, \"must be OpaqueZeroTripGuard\");\n+  assert(zer_opaq != NULL &&\n+         (is_main_loop ? zer_opaq->is_OpaqueZeroTripGuardMainLoop()\n+                       : zer_opaq->is_OpaqueZeroTripGuardPostLoop()),\n+         \"must be OpaqueZeroTripGuard for main or post loop\");\n@@ -1708,3 +1711,3 @@\n-  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit);\n-  Node *min_cmp  = new CmpINode(pre_incr, min_opaq);\n-  Node *min_bol  = new BoolNode(min_cmp, b_test);\n+  Node* min_opaq = new OpaqueZeroTripGuardMainLoopNode(C, limit);\n+  Node* min_cmp  = new CmpINode(pre_incr, min_opaq);\n+  Node* min_bol  = new BoolNode(min_cmp, b_test);\n@@ -1997,3 +2000,3 @@\n-  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr);\n-  Node *zer_cmp = new CmpINode(zer_opaq, limit);\n-  Node *zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n+  Node* zer_opaq = new OpaqueZeroTripGuardPostLoopNode(C, incr);\n+  Node* zer_cmp = new CmpINode(zer_opaq, limit);\n+  Node* zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n@@ -3581,1 +3584,1 @@\n-  assert(main_cmp->in(2)->Opcode() == Op_OpaqueZeroTripGuard, \"main loop has no opaque node?\");\n+  assert(main_cmp->in(2)->is_OpaqueZeroTripGuardMainLoop(), \"main loop has no opaque node?\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2970,8 +2970,3 @@\n-    Node* backedge = proj_out_or_null(true);\n-    if (backedge != NULL) {\n-      Node* head = backedge->unique_ctrl_out_or_null();\n-      if (head != NULL && head->is_OuterStripMinedLoop()) {\n-        if (head->find_out_with(Op_Phi) != NULL) {\n-          return true;\n-        }\n-      }\n+    OuterStripMinedLoopNode* head = loopnode();\n+    if (head != nullptr && head->find_out_with(Op_Phi) != nullptr) {\n+      return true;\n@@ -2983,0 +2978,11 @@\n+OuterStripMinedLoopNode* OuterStripMinedLoopEndNode::loopnode() const {\n+  Node* backedge = proj_out_or_null(true);\n+  if (backedge != nullptr) {\n+    Node* head = backedge->unique_ctrl_out_or_null();\n+    if (head != nullptr && head->is_OuterStripMinedLoop()) {\n+      return head->as_OuterStripMinedLoop();\n+    }\n+  }\n+  return nullptr; \/\/ not found\n+}\n+\n@@ -5478,1 +5484,1 @@\n-  bool res = cmpzm->in(input)->Opcode() == Op_OpaqueZeroTripGuard;\n+  bool res = cmpzm->in(input)->is_OpaqueZeroTripGuard();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -595,0 +595,1 @@\n+  OuterStripMinedLoopNode* loopnode() const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -133,0 +133,5 @@\n+class OpaqueLoopInitNode;\n+class OpaqueLoopStrideNode;\n+class OpaqueZeroTripGuardNode;\n+class OpaqueZeroTripGuardMainLoopNode;\n+class OpaqueZeroTripGuardPostLoopNode;\n@@ -763,0 +768,5 @@\n+        DEFINE_CLASS_ID(OpaqueLoopInit,      Opaque1, 0)\n+        DEFINE_CLASS_ID(OpaqueLoopStride,    Opaque1, 1)\n+        DEFINE_CLASS_ID(OpaqueZeroTripGuard, Opaque1, 2)\n+            DEFINE_CLASS_ID(OpaqueZeroTripGuardMainLoop, OpaqueZeroTripGuard, 0)\n+            DEFINE_CLASS_ID(OpaqueZeroTripGuardPostLoop, OpaqueZeroTripGuard, 1)\n@@ -926,0 +936,5 @@\n+  DEFINE_CLASS_QUERY(OpaqueLoopInit)\n+  DEFINE_CLASS_QUERY(OpaqueLoopStride)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuard)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuardMainLoop)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuardPostLoop)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/loopnode.hpp\"\n@@ -47,0 +48,93 @@\n+\/\/ Is there to hold off with optimizing post loop based on type of limit\n+\/\/ as long as main loop is around and can still change the limit due to\n+\/\/ unrolling. Pattern we are looking for:\n+\/\/\n+\/\/               +--------+\n+\/\/               |        |\n+\/\/      strip_mined_head  |\n+\/\/       |                |\n+\/\/      main_head (main)  |\n+\/\/       |                |\n+\/\/      ...               |\n+\/\/       |                |\n+\/\/      strip_mined_end   |\n+\/\/       |           |    |\n+\/\/       |           +----+     opaq (this)\n+\/\/       |                       |\n+\/\/      main_exit               zer_cmp\n+\/\/       |                       |\n+\/\/   main_zer_region            zer_bol\n+\/\/    |                          |\n+\/\/    +-----------+  +-----------+\n+\/\/                |  |\n+\/\/               zer_if (zero trip guard post loop)\n+\/\/\n+\/\/ In some cases, the main-loop is not strip-mined:\n+\/\/\n+\/\/               +--------+\n+\/\/               |        |\n+\/\/      main_head (main)  |\n+\/\/       |                |\n+\/\/      ...               |\n+\/\/       |                |\n+\/\/      main_end          |\n+\/\/       |    |           |\n+\/\/       |    +-----------+     opaq (this)\n+\/\/       |                       |\n+\/\/      main_exit               zer_cmp\n+\/\/       |                       |\n+\/\/   main_zer_region            zer_bol\n+\/\/    |                          |\n+\/\/    +-----------+  +-----------+\n+\/\/                |  |\n+\/\/               zer_if (zero trip guard post loop)\n+\/\/\n+Node* OpaqueZeroTripGuardPostLoopNode::Identity(PhaseGVN* phase) {\n+  Node* result = OpaqueZeroTripGuardNode::Identity(phase);\n+  if (result != this) {\n+    return result;\n+  }\n+  \/\/ If must still be there, after all we are guarding it\n+  Node* zer_cmp = unique_out();\n+  assert(zer_cmp->Opcode() == Op_CmpI, \"Opaque guards CmpI\");\n+  Node* zer_bol = zer_cmp->unique_out();\n+  assert(zer_bol->is_Bool(), \"Opaque guards Bool\");\n+  Node* zer_if = zer_bol->unique_out();\n+  assert(zer_if->is_If(), \"Opaque guards If\");\n+  \/\/ From here, no assumption is given, the graph may be degenerate\n+  Node* main_zer_region = zer_if->in(0);\n+  if (main_zer_region == nullptr ||\n+      !main_zer_region->is_Region() ||\n+      main_zer_region->req() != 3) {\n+    return in(1); \/\/ degenerate at region, remove Opaque\n+  }\n+  Node* main_exit = main_zer_region->in(2);\n+  if (main_exit == nullptr ||\n+      !main_exit->is_IfProj()) {\n+    return in(1); \/\/ degenerate at main exit, remove Opaque\n+  }\n+  Node* outer_end = main_exit->in(0);\n+  if (outer_end == nullptr) {\n+    return in(1); \/\/ degenerate at outer end, remove Opaque\n+  }\n+  \/\/ find main_head, with or without strip-mining\n+  Node* main_head = nullptr;\n+  if (outer_end->is_OuterStripMinedLoopEnd()) {\n+    OuterStripMinedLoopNode* strip_mined_head = outer_end->as_OuterStripMinedLoopEnd()->loopnode();\n+    if (strip_mined_head == nullptr) {\n+      return in(1); \/\/ degenerate at outer loopnode, remove Opaque\n+    }\n+    main_head = strip_mined_head->unique_ctrl_out_or_null();\n+  } else if (outer_end->is_BaseCountedLoopEnd()) {\n+    main_head = outer_end->as_BaseCountedLoopEnd()->loopnode();\n+  } else {\n+    return in(1); \/\/ degenerate at outer end, remove Opaque\n+  }\n+  if (main_head == nullptr ||\n+      !main_head->is_CountedLoop() ||\n+      !main_head->as_CountedLoop()->is_main_loop()) {\n+    return in(1); \/\/ degenerate at main loop, remove Opaque\n+  }\n+  return this; \/\/ main loop still here, keep this Opaque\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-  OpaqueLoopInitNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueLoopInitNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueLoopInit);\n@@ -68,1 +69,2 @@\n-  OpaqueLoopStrideNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueLoopStrideNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueLoopStride);\n@@ -75,1 +77,2 @@\n-  OpaqueZeroTripGuardNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueZeroTripGuardNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuard);\n@@ -80,0 +83,17 @@\n+class OpaqueZeroTripGuardMainLoopNode : public OpaqueZeroTripGuardNode {\n+public:\n+  OpaqueZeroTripGuardMainLoopNode(Compile* C, Node* n) : OpaqueZeroTripGuardNode(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuardMainLoop);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class OpaqueZeroTripGuardPostLoopNode : public OpaqueZeroTripGuardNode {\n+public:\n+  OpaqueZeroTripGuardPostLoopNode(Compile* C, Node* n) : OpaqueZeroTripGuardNode(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuardPostLoop);\n+  }\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n+  if (n->is_OpaqueZeroTripGuard()) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1447,1 +1447,1 @@\n-  if (con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_OpaqueZeroTripGuard &&\n+  if (con->is_Con() && !cmp2->is_Con() && !cmp2->is_OpaqueZeroTripGuard() &&\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298176\n+ * @summary Must remove OpaqueZeroTripGuardPostLoop after main loop disappears else\n+ *          the zero-trip-guard of the post loop cannot die and leaves an inconsistent\n+ *          graph behind.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,TestOpaqueZeroTripGuardPostLoopRemoval::test*\n+ *      -XX:CompileCommand=dontinline,TestOpaqueZeroTripGuardPostLoopRemoval::*\n+ *      TestOpaqueZeroTripGuardPostLoopRemoval\n+ *\/\n+\n+public class TestOpaqueZeroTripGuardPostLoopRemoval {\n+    static long x;\n+\n+    public static void main(String[] strArr) {\n+        test_001();\n+        test_002();\n+        try {\n+            test_003();\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+        test_004();\n+        test_005();\n+    }\n+\n+    static void test_001() {\n+        int b = 6;\n+        for (long l = 1; l < 9; l++) {\n+            b++;\n+        }\n+        for (int i = 1; i < 1000; i*=2) {\n+            for (int j = 1; j < 2; j++) {\n+                x = b + 1;\n+            }\n+        }\n+    }\n+\n+    static void test_002() {\n+        int b = 6;\n+        for (long l = 60; l < 3000; l+=3) {\n+            \/\/ bounds of loop: no work for post loop\n+            b += 33; \/\/ any multiple of iv step\n+        }\n+        for (int i = 1; i < 1000; i*=2) {\n+            for (int j = 1; j < 2; j++) {\n+                x = b + 1;\n+            }\n+        }\n+    }\n+\n+    static void dontInline() {\n+        throw new RuntimeException();\n+    }\n+\n+    static int test_003() {\n+        int y = 3;\n+        for (int i = 0; i < 9; ) {\n+            for (long l = 1; l < 5; l++) {\n+                y *= 2;\n+            }\n+            while (true) {\n+                dontInline();\n+            }\n+        }\n+        return y;\n+    }\n+\n+    static void test_004() {\n+        for (int i2 = 4; i2 < 13; i2++) {\n+            double d = 56;\n+            for (long l = 1; l < 5; l++) {\n+                d = d + 3;\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                for (int d2 = i2; d2 < 2; d2 = 3) {\n+                }\n+            }\n+        }\n+    }\n+\n+    public static int test_005() {\n+        long arr[]=new long[400];\n+        for (int i = 3; i < 177; i++) {\n+            for (int j = 0; j < 10; j++){}\n+        }\n+        int y = 0;\n+        for (int i = 15; i < 356; i++) {\n+            \/\/ Inner loop prevents strip-mining of outer loop\n+            \/\/ later, inner loop is removed, so outer does pre-main-post without strip-mining\n+            for (int j = 0; j < 10; j++){\n+                y |= 1;\n+            }\n+        }\n+        return y;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOpaqueZeroTripGuardPostLoopRemoval.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}