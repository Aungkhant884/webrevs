{"files":[{"patch":"@@ -620,3 +620,3 @@\n-          \/\/ This is not a loop anymore. No need to keep the Opaque1 node on the test that guards the loop as it won't be\n-          \/\/ subject to further loop opts.\n-          assert(opaq->Opcode() == Op_OpaqueZeroTripGuard, \"\");\n+          \/\/ This is not a loop anymore. No need to keep the OpaqueZeroTripGuard node\n+          \/\/ on the test that guards the loop as it won't be subject to further loop opts.\n+          assert(opaq->is_OpaqueZeroTripGuard(), \"must be zero trip guard\");\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -403,0 +403,2 @@\n+  OpaqueZeroTripGuardNode* find_opaque_zero_trip_guard() const;\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,0 +272,2 @@\n+macro(OpaqueZeroTripGuardMainLoop)\n+macro(OpaqueZeroTripGuardPostLoop)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,4 +410,3 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n-  uint next = 0;\n-  while (next < useful.size()) {\n-    Node *n = useful.at(next++);\n+void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist, PhaseIterGVN* igvn) {\n+  for (uint i = 0; i < useful.size(); i++) {\n+    Node *n = useful.at(i);\n@@ -432,0 +431,14 @@\n+    if (n->is_If() && n->outcnt() < 2) {\n+      IfNode* iff = n->as_If();\n+      OpaqueZeroTripGuardNode* opaq = iff->find_opaque_zero_trip_guard();\n+      if (opaq != nullptr) {\n+        \/\/ We removed the LoopNode during CCP, but still have the zero trip guard\n+        \/\/ which did not collapse because of the Opaque node, remove it now.\n+        \/\/ If the LoopNode dies during IGVN, we catch that in RegionNode::Ideal\n+        \/\/ and remove the respective Opaque node there.\n+        ProjNode* proj = iff->unique_ctrl_out()->as_Proj();\n+        assert(igvn != nullptr, \"must happen when we have igvn\");\n+        ConNode* con = igvn->intcon(proj->_con);\n+        igvn->replace_input_of(iff, 1, con);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -953,1 +953,1 @@\n-  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n+  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist, PhaseIterGVN* igvn = nullptr);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1741,0 +1741,23 @@\n+\/\/ Find this pattern: If -> Bool -> CmpI -> OpaqueZeroTripGuard\n+\/\/ For the main loop, the opaque node is the second input to cmp,\n+\/\/ for the post loop it's the first input node.\n+OpaqueZeroTripGuardNode* IfNode::find_opaque_zero_trip_guard() const {\n+  Node* bol = in(1);\n+  if (bol != nullptr && bol->is_Bool()) {\n+    Node* cmp = bol->in(1);\n+    if (cmp != nullptr && cmp->Opcode() == Op_CmpI) {\n+      Node* in1 = (cmp->req() > 1) ? cmp->in(1) : nullptr;\n+      if (in1 != nullptr && in1->is_OpaqueZeroTripGuard()) {\n+        assert(in1->is_OpaqueZeroTripGuardPostLoop(), \"post loop pattern\");\n+        return in1->as_OpaqueZeroTripGuard();\n+      }\n+      Node* in2 = (cmp->req() > 2) ? cmp->in(2) : nullptr;\n+      if (in2 != nullptr && in2->is_OpaqueZeroTripGuard()) {\n+        assert(in2->is_OpaqueZeroTripGuardMainLoop(), \"main loop pattern\");\n+        return in2->as_OpaqueZeroTripGuard();\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1297,7 +1297,6 @@\n-  Node* zer_bol = node->in(0)->in(1);\n-  assert(zer_bol != NULL && zer_bol->is_Bool(), \"must be Bool\");\n-  Node* zer_cmp = zer_bol->in(1);\n-  assert(zer_cmp != NULL && zer_cmp->Opcode() == Op_CmpI, \"must be CmpI\");\n-  \/\/ For the main loop, the opaque node is the second input to zer_cmp, for the post loop it's the first input node\n-  Node* zer_opaq = zer_cmp->in(is_main_loop ? 2 : 1);\n-  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_OpaqueZeroTripGuard, \"must be OpaqueZeroTripGuard\");\n+  IfNode* iff = node->in(0)->as_If();\n+  OpaqueZeroTripGuardNode* opaq = iff->find_opaque_zero_trip_guard();\n+  assert(opaq != NULL &&\n+         (is_main_loop ? opaq->is_OpaqueZeroTripGuardMainLoop()\n+                       : opaq->is_OpaqueZeroTripGuardPostLoop()),\n+         \"must be OpaqueZeroTripGuard for main or post loop\");\n@@ -1708,3 +1707,3 @@\n-  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit);\n-  Node *min_cmp  = new CmpINode(pre_incr, min_opaq);\n-  Node *min_bol  = new BoolNode(min_cmp, b_test);\n+  Node* min_opaq = new OpaqueZeroTripGuardMainLoopNode(C, limit);\n+  Node* min_cmp  = new CmpINode(pre_incr, min_opaq);\n+  Node* min_bol  = new BoolNode(min_cmp, b_test);\n@@ -1997,3 +1996,3 @@\n-  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr);\n-  Node *zer_cmp = new CmpINode(zer_opaq, limit);\n-  Node *zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n+  Node* zer_opaq = new OpaqueZeroTripGuardPostLoopNode(C, incr);\n+  Node* zer_cmp = new CmpINode(zer_opaq, limit);\n+  Node* zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n@@ -3581,1 +3580,1 @@\n-  assert(main_cmp->in(2)->Opcode() == Op_OpaqueZeroTripGuard, \"main loop has no opaque node?\");\n+  assert(main_cmp->in(2)->is_OpaqueZeroTripGuardMainLoop(), \"main loop has no opaque node?\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -5454,1 +5454,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5457,14 +5457,1 @@\n-\n-  if (ctrl == NULL || (!ctrl->is_IfTrue() && !ctrl->is_IfFalse())) {\n-    return NULL;\n-  }\n-  Node* iffm = ctrl->in(0);\n-  if (iffm == NULL || !iffm->is_If()) {\n-    return NULL;\n-  }\n-  Node* bolzm = iffm->in(1);\n-  if (bolzm == NULL || !bolzm->is_Bool()) {\n-    return NULL;\n-  }\n-  Node* cmpzm = bolzm->in(1);\n-  if (cmpzm == NULL || !cmpzm->is_Cmp()) {\n+  if (ctrl == nullptr || (!ctrl->is_IfTrue() && !ctrl->is_IfFalse())) {\n@@ -5473,3 +5460,2 @@\n-\n-  uint input = is_main_loop() ? 2 : 1;\n-  if (input >= cmpzm->req() || cmpzm->in(input) == NULL) {\n+  Node* iff = ctrl->in(0);\n+  if (iff == NULL || !iff->is_If()) {\n@@ -5478,13 +5464,1 @@\n-  bool res = cmpzm->in(input)->Opcode() == Op_OpaqueZeroTripGuard;\n-#ifdef ASSERT\n-  bool found_opaque = false;\n-  for (uint i = 1; i < cmpzm->req(); i++) {\n-    Node* opnd = cmpzm->in(i);\n-    if (opnd && opnd->is_Opaque1()) {\n-      found_opaque = true;\n-      break;\n-    }\n-  }\n-  assert(found_opaque == res, \"wrong pattern\");\n-#endif\n-  return res ? cmpzm->in(input) : NULL;\n+  return iff->as_If()->find_opaque_zero_trip_guard();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -133,0 +133,5 @@\n+class OpaqueLoopInitNode;\n+class OpaqueLoopStrideNode;\n+class OpaqueZeroTripGuardNode;\n+class OpaqueZeroTripGuardMainLoopNode;\n+class OpaqueZeroTripGuardPostLoopNode;\n@@ -763,0 +768,5 @@\n+        DEFINE_CLASS_ID(OpaqueLoopInit,      Opaque1, 0)\n+        DEFINE_CLASS_ID(OpaqueLoopStride,    Opaque1, 1)\n+        DEFINE_CLASS_ID(OpaqueZeroTripGuard, Opaque1, 2)\n+            DEFINE_CLASS_ID(OpaqueZeroTripGuardMainLoop, OpaqueZeroTripGuard, 0)\n+            DEFINE_CLASS_ID(OpaqueZeroTripGuardPostLoop, OpaqueZeroTripGuard, 1)\n@@ -926,0 +936,5 @@\n+  DEFINE_CLASS_QUERY(OpaqueLoopInit)\n+  DEFINE_CLASS_QUERY(OpaqueLoopStride)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuard)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuardMainLoop)\n+  DEFINE_CLASS_QUERY(OpaqueZeroTripGuardPostLoop)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-  OpaqueLoopInitNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueLoopInitNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueLoopInit);\n@@ -68,1 +69,2 @@\n-  OpaqueLoopStrideNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueLoopStrideNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueLoopStride);\n@@ -75,1 +77,18 @@\n-  OpaqueZeroTripGuardNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  OpaqueZeroTripGuardNode(Compile* C, Node* n) : Opaque1Node(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuard);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class OpaqueZeroTripGuardMainLoopNode : public OpaqueZeroTripGuardNode {\n+public:\n+  OpaqueZeroTripGuardMainLoopNode(Compile* C, Node* n) : OpaqueZeroTripGuardNode(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuardMainLoop);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class OpaqueZeroTripGuardPostLoopNode : public OpaqueZeroTripGuardNode {\n+public:\n+  OpaqueZeroTripGuardPostLoopNode(Compile* C, Node* n) : OpaqueZeroTripGuardNode(C, n) {\n+    init_class_id(Class_OpaqueZeroTripGuardPostLoop);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2045,1 +2045,1 @@\n-  C->disconnect_useless_nodes(useful, &_worklist);\n+  C->disconnect_useless_nodes(useful, &_worklist, this);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n+  if (n->is_OpaqueZeroTripGuard()) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1447,1 +1447,1 @@\n-  if (con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_OpaqueZeroTripGuard &&\n+  if (con->is_Con() && !cmp2->is_Con() && !cmp2->is_OpaqueZeroTripGuard() &&\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298176\n+ * @summary Must remove OpaqueZeroTripGuardPostLoop after main loop disappears else\n+ *          the zero-trip-guard of the post loop cannot die and leaves an inconsistent\n+ *          graph behind.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,TestOpaqueZeroTripGuardPostLoopRemoval::test*\n+ *      -XX:CompileCommand=dontinline,TestOpaqueZeroTripGuardPostLoopRemoval::*\n+ *      TestOpaqueZeroTripGuardPostLoopRemoval\n+ *\/\n+\n+public class TestOpaqueZeroTripGuardPostLoopRemoval {\n+    static long x;\n+\n+    public static void main(String[] strArr) {\n+        test_001();\n+        test_002();\n+        try {\n+            test_003();\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+        test_004();\n+        test_005();\n+    }\n+\n+    static void test_001() {\n+        int b = 6;\n+        for (long l = 1; l < 9; l++) {\n+            b++;\n+        }\n+        for (int i = 1; i < 1000; i*=2) {\n+            for (int j = 1; j < 2; j++) {\n+                x = b + 1;\n+            }\n+        }\n+    }\n+\n+    static void test_002() {\n+        int b = 6;\n+        for (long l = 60; l < 3000; l+=3) {\n+            \/\/ bounds of loop: no work for post loop\n+            b += 33; \/\/ any multiple of iv step\n+        }\n+        for (int i = 1; i < 1000; i*=2) {\n+            for (int j = 1; j < 2; j++) {\n+                x = b + 1;\n+            }\n+        }\n+    }\n+\n+    static void dontInline() {\n+        throw new RuntimeException();\n+    }\n+\n+    static int test_003() {\n+        int y = 3;\n+        for (int i = 0; i < 9; ) {\n+            for (long l = 1; l < 5; l++) {\n+                y *= 2;\n+            }\n+            while (true) {\n+                dontInline();\n+            }\n+        }\n+        return y;\n+    }\n+\n+    static void test_004() {\n+        for (int i2 = 4; i2 < 13; i2++) {\n+            double d = 56;\n+            for (long l = 1; l < 5; l++) {\n+                d = d + 3;\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                for (int d2 = i2; d2 < 2; d2 = 3) {\n+                }\n+            }\n+        }\n+    }\n+\n+    public static int test_005() {\n+        long arr[]=new long[400];\n+        for (int i = 3; i < 177; i++) {\n+            for (int j = 0; j < 10; j++){}\n+        }\n+        int y = 0;\n+        for (int i = 15; i < 356; i++) {\n+            \/\/ Inner loop prevents strip-mining of outer loop\n+            \/\/ later, inner loop is removed, so outer does pre-main-post without strip-mining\n+            for (int j = 0; j < 10; j++){\n+                y |= 1;\n+            }\n+        }\n+        return y;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOpaqueZeroTripGuardPostLoopRemoval.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}