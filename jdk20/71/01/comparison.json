{"files":[{"patch":"@@ -391,0 +391,1 @@\n+  _completed_mark_cycles(0),\n@@ -1013,1 +1014,5 @@\n-void G1ConcurrentMark::concurrent_cycle_end() {\n+uint G1ConcurrentMark::completed_mark_cycles() const {\n+  return Atomic::load(&_completed_mark_cycles);\n+}\n+\n+void G1ConcurrentMark::concurrent_cycle_end(bool mark_cycle_completed) {\n@@ -1018,0 +1023,4 @@\n+  if (mark_cycle_completed) {\n+    Atomic::inc(&_completed_mark_cycles, memory_order_relaxed);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -330,0 +330,3 @@\n+  \/\/ Number of completed mark cycles.\n+  volatile uint           _completed_mark_cycles;\n+\n@@ -504,1 +507,1 @@\n-  void concurrent_cycle_end();\n+  void concurrent_cycle_end(bool mark_cycle_completed);\n@@ -596,0 +599,2 @@\n+  uint completed_mark_cycles() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  _cm->concurrent_cycle_end();\n+  _cm->concurrent_cycle_end(mark_cycle_completed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))\n+WB_ENTRY(jint, WB_G1CompletedConcurrentMarkCycles(JNIEnv* env, jobject o))\n@@ -503,5 +503,2 @@\n-    if (!g1h->concurrent_mark()->cm_thread()->in_progress()) {\n-      g1h->collect(GCCause::_wb_conc_mark);\n-      return true;\n-    }\n-    return false;\n+    G1ConcurrentMark* cm = g1h->concurrent_mark();\n+    return cm->completed_mark_cycles();\n@@ -509,1 +506,1 @@\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_G1StartMarkCycle: G1 GC is not enabled\");\n+  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_G1CompletedConcurrentMarkCycles: G1 GC is not enabled\");\n@@ -2536,0 +2533,1 @@\n+  {CC\"g1CompletedConcurrentMarkCycles\", CC\"()I\",      (void*)&WB_G1CompletedConcurrentMarkCycles},\n@@ -2542,1 +2540,0 @@\n-  {CC\"g1StartConcMarkCycle\",       CC\"()Z\",           (void*)&WB_G1StartMarkCycle  },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-            WB.g1StartConcMarkCycle();\n+            WB.g1StartConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,6 +68,1 @@\n-\n-            \/\/ Trigger a concurrent cycle and wait until the Remark pause\n-            wb.g1StartConcMarkCycle();\n-            while (wb.g1InConcurrentMark()) {\n-                Thread.sleep(200);\n-            }\n+            wb.g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousRemsetsMatch.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,6 +138,1 @@\n-            wb.g1StartConcMarkCycle(); \/\/ concurrent-start, remark and cleanup\n-\n-            \/\/ Sleep to make sure concurrent cycle is done\n-            while (wb.g1InConcurrentMark()) {\n-                Thread.sleep(1000);\n-            }\n+            wb.g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestMixedGCLiveThreshold.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,4 +81,1 @@\n-        wb.g1StartConcMarkCycle();\n-        while (wb.g1InConcurrentMark()) {\n-            Thread.sleep(100);\n-        }\n+        wb.g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestNoEagerReclaimOfHumongousRegions.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,4 +47,1 @@\n-      wb.g1StartConcMarkCycle();\n-      while (wb.g1InConcurrentMark()) {\n-          Thread.sleep(100);\n-      }\n+      wb.g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestRegionLivenessPrint.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +43,2 @@\n+import static jdk.test.whitebox.WhiteBox.getWhiteBox;\n+\n@@ -46,1 +49,0 @@\n-import gc.testlibrary.g1.MixedGCProvoker;\n@@ -63,1 +65,1 @@\n-        MixedGCProvoker.provokeConcMarkCycle();\n+        getWhiteBox().g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestRemarkCleanupMXBean.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,7 +70,1 @@\n-            wb.g1StartConcMarkCycle(); \/\/ concurrent-start, remark and cleanup\n-\n-            \/\/ Sleep to make sure concurrent cycle is done\n-            while (wb.g1InConcurrentMark()) {\n-                Thread.sleep(1000);\n-            }\n-\n+            wb.g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestSkipRebuildRemsetPhase.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -276,2 +276,0 @@\n-            wb.g1StartConcMarkCycle(); \/\/ concurrent-start, remark and cleanup\n-            partialFree(used);\n@@ -279,4 +277,4 @@\n-            \/\/ Sleep to make sure concurrent cycle is done\n-            while (wb.g1InConcurrentMark()) {\n-                Thread.sleep(1000);\n-            }\n+            wb.concurrentGCAcquireControl();\n+            try {\n+                wb.concurrentGCRunTo(wb.AFTER_MARKING_STARTED);\n+                partialFree(used);\n@@ -284,4 +282,1 @@\n-            \/\/ Trigger two young GCs, first will be young-prepare-mixed, second will be mixed.\n-            used = alloc1M();\n-            wb.youngGC(); \/\/ young-prepare-mixed\n-            partialFree(used);\n+                wb.concurrentGCRunToIdle();\n@@ -289,3 +284,12 @@\n-            used = alloc1M();\n-            wb.youngGC(); \/\/ mixed\n-            partialFree(used);\n+                \/\/ Trigger two young GCs while preventing a new concurrent GC.\n+                \/\/ First will be young-prepare-mixed, second will be mixed.\n+                used = alloc1M();\n+                wb.youngGC(); \/\/ young-prepare-mixed\n+                partialFree(used);\n+\n+                used = alloc1M();\n+                wb.youngGC(); \/\/ mixed\n+                partialFree(used);\n+            } finally {\n+                wb.concurrentGCReleaseControl();\n+            }\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -129,3 +129,1 @@\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-                WHITE_BOX.g1StartConcMarkCycle();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n+                WHITE_BOX.g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousClassLoader.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,3 +82,1 @@\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-                WHITE_BOX.g1StartConcMarkCycle();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n+                WHITE_BOX.g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestObjectCollected.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,3 +44,1 @@\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-                WHITE_BOX.g1StartConcMarkCycle();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n+                WHITE_BOX.g1RunConcurrentGC();\n@@ -70,7 +68,9 @@\n-                WHITE_BOX.youngGC();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-                WHITE_BOX.youngGC();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-\n-                WHITE_BOX.g1StartConcMarkCycle();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n+                WHITE_BOX.concurrentGCAcquireControl();\n+                try {\n+                    WHITE_BOX.youngGC();\n+                    WHITE_BOX.youngGC();\n+                    WHITE_BOX.concurrentGCRunTo(WHITE_BOX.AFTER_MARKING_STARTED);\n+                    WHITE_BOX.concurrentGCRunToIdle();\n+                } finally {\n+                    WHITE_BOX.concurrentGCReleaseControl();\n+                }\n@@ -144,13 +144,12 @@\n-                WHITE_BOX.youngGC();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-                WHITE_BOX.youngGC();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-\n-                WHITE_BOX.g1StartConcMarkCycle();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-\n-                WHITE_BOX.youngGC();\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n-                \/\/ Provoking Mixed GC\n-                WHITE_BOX.youngGC();\/\/ second evacuation pause will be mixed\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 0);\n+                WHITE_BOX.concurrentGCAcquireControl();\n+                try {\n+                    WHITE_BOX.youngGC();\n+                    WHITE_BOX.youngGC();\n+                    WHITE_BOX.concurrentGCRunTo(WHITE_BOX.AFTER_MARKING_STARTED);\n+                    WHITE_BOX.concurrentGCRunToIdle();\n+                    WHITE_BOX.youngGC();\n+                    \/\/ Provoking Mixed GC\n+                    WHITE_BOX.youngGC();\/\/ second evacuation pause will be mixed\n+                } finally {\n+                    WHITE_BOX.concurrentGCReleaseControl();\n+                }\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/GC.java","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    public static final String WB_INITIATED_CMC = \"WhiteBox Initiated Concurrent Mark\";\n+    public static final String WB_INITIATED_CMC = \"WhiteBox Initiated Run to Breakpoint\";\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/objectGraphTest\/GCTokens.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,0 +273,3 @@\n+        \/\/ Only one thread at a time can be controlling concurrent GC.\n+        static final Object concGCMonitor = new Object();\n+        static Shifter concGCController = null;\n@@ -295,1 +298,12 @@\n-                    if (!WB.g1InConcurrentMark()) {\n+                    \/\/ If no currently controlling thread and no concurrent GC\n+                    \/\/ in progress, then claim control.\n+                    synchronized (concGCMonitor) {\n+                        if ((concGCController == null) && !WB.g1InConcurrentMark()) {\n+                            concGCController = this;\n+                        }\n+                    }\n+                    if (concGCController == this) {\n+                        \/\/ If we've claimed control then take control, start a\n+                        \/\/ concurrent GC, and release control and the claim,\n+                        \/\/ letting the GC run to completion while we continue\n+                        \/\/ doing work.\n@@ -297,1 +311,9 @@\n-                        WB.g1StartConcMarkCycle();\n+                        WB.concurrentGCAcquireControl();\n+                        try {\n+                            WB.concurrentGCRunTo(WB.AFTER_MARKING_STARTED, false);\n+                        } finally {\n+                            WB.concurrentGCReleaseControl();\n+                            synchronized (concGCMonitor) {\n+                                concGCController = null;\n+                            }\n+                        }\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -296,4 +296,1 @@\n-                    WB.g1StartConcMarkCycle();\n-                    while (WB.g1InConcurrentMark()) {\n-                        Thread.sleep(1);\n-                    }\n+                    WB.g1RunConcurrentGC(false);\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,10 +76,2 @@\n-     * Provoke a concurrent mark cycle, and wait for it to end.\n-     *\/\n-    public static void provokeConcMarkCycle() {\n-        Helpers.waitTillCMCFinished(getWhiteBox(), 10);\n-        getWhiteBox().g1StartConcMarkCycle();\n-        Helpers.waitTillCMCFinished(getWhiteBox(), 10);\n-    }\n-\n-    \/**\n-     * Provoke at least one mixed gc by starting a marking cycle, waiting for its end and triggering two GCs.\n+     * Provoke at least one mixed gc by performing a concurrent collection\n+     * and triggering two GCs.\n@@ -89,1 +81,1 @@\n-        provokeConcMarkCycle();\n+        getWhiteBox().g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/gc\/testlibrary\/g1\/MixedGCProvoker.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.whitebox;\n-\n-\/*\n- * @test TestConMarkCycleWB\n- * @bug 8065579\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.compiler\n- *          java.management\n- *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC gc.whitebox.TestConcMarkCycleWB\n- * @summary Verifies that ConcurrentMarking-related WB works properly\n- *\/\n-import static jdk.test.lib.Asserts.assertTrue;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class TestConcMarkCycleWB {\n-\n-    public static void main(String[] args) throws Exception {\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-        wb.youngGC();\n-        assertTrue(wb.g1StartConcMarkCycle());\n-        while (wb.g1InConcurrentMark()) {\n-            Thread.sleep(5);\n-        }\n-\n-        wb.fullGC();\n-        assertTrue(wb.g1StartConcMarkCycle());\n-        while (wb.g1InConcurrentMark()) {\n-            Thread.sleep(5);\n-        }\n-        assertTrue(wb.g1StartConcMarkCycle());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/whitebox\/TestConcMarkCycleWB.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -53,11 +53,0 @@\n-    private static void waitUntilConcMarkFinished() throws Exception {\n-        while (wb.g1InConcurrentMark()) {\n-            try {\n-                Thread.sleep(1);\n-            } catch (InterruptedException e) {\n-                System.out.println(\"Got InterruptedException while waiting for concurrent mark to finish\");\n-                throw e;\n-            }\n-        }\n-    }\n-\n@@ -65,5 +54,2 @@\n-        \/\/ Try to unload classes using concurrent mark. First wait for any currently running concurrent\n-        \/\/ cycle.\n-        waitUntilConcMarkFinished();\n-        wb.g1StartConcMarkCycle();\n-        waitUntilConcMarkFinished();\n+        \/\/ Try to unload classes using concurrent mark.\n+        wb.g1RunConcurrentGC();\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/UnloadTestWithVerifyDuringGC.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -50,1 +51,0 @@\n-import gc.testlibrary.g1.MixedGCProvoker;\n@@ -109,1 +109,1 @@\n-            MixedGCProvoker.provokeConcMarkCycle();\n+            WhiteBox.getWhiteBox().g1RunConcurrentGC();\n","filename":"test\/jdk\/com\/sun\/management\/GarbageCollectorMXBean\/GarbageCollectionNotificationContentTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -50,1 +51,0 @@\n-import gc.testlibrary.g1.MixedGCProvoker;\n@@ -110,1 +110,1 @@\n-            MixedGCProvoker.provokeConcMarkCycle();\n+            WhiteBox.getWhiteBox().g1RunConcurrentGC();\n","filename":"test\/jdk\/com\/sun\/management\/GarbageCollectorMXBean\/GarbageCollectionNotificationTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+\n@@ -169,0 +170,44 @@\n+  public native int g1CompletedConcurrentMarkCycles();\n+\n+  \/\/ Perform a complete concurrent GC cycle, using concurrent GC breakpoints.\n+  \/\/ Completes any in-progress cycle before performing the requested cycle.\n+  \/\/ Returns true if the cycle completed successfully.  If the cycle was not\n+  \/\/ successful (e.g. it was aborted), then throws RuntimeException if\n+  \/\/ errorIfFail is true, returning false otherwise.\n+  public boolean g1RunConcurrentGC(boolean errorIfFail) {\n+    try {\n+      \/\/ Take control, waiting until any in-progress cycle completes.\n+      concurrentGCAcquireControl();\n+      int count = g1CompletedConcurrentMarkCycles();\n+      concurrentGCRunTo(AFTER_MARKING_STARTED, false);\n+      concurrentGCRunToIdle();\n+      if (count < g1CompletedConcurrentMarkCycles()) {\n+        return true;\n+      } else if (errorIfFail) {\n+        throw new RuntimeException(\"Concurrent GC aborted\");\n+      } else {\n+        return false;\n+      }\n+    } finally {\n+      concurrentGCReleaseControl();\n+    }\n+  }\n+\n+  public void g1RunConcurrentGC() {\n+    g1RunConcurrentGC(true);\n+  }\n+\n+  \/\/ Start a concurrent GC cycle, using concurrent GC breakpoints.\n+  \/\/ The concurrent GC will continue in parallel with the caller.\n+  \/\/ Completes any in-progress cycle before starting the requested cycle.\n+  public void g1StartConcurrentGC() {\n+    try {\n+      \/\/ Take control, waiting until any in-progress cycle completes.\n+      concurrentGCAcquireControl();\n+      concurrentGCRunTo(AFTER_MARKING_STARTED, false);\n+    } finally {\n+      \/\/ Release control, permitting the cycle to complete.\n+      concurrentGCReleaseControl();\n+    }\n+  }\n+\n@@ -543,4 +588,0 @@\n-  \/\/ Method tries to start concurrent mark cycle.\n-  \/\/ It returns false if CM Thread is always in concurrent cycle.\n-  public native boolean g1StartConcMarkCycle();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"}]}