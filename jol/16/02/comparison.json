{"files":[{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-\/**\n- * This class is needed to work around the protection that disallows polling objectFieldOffset\n- * on Records and hidden classes:\n- *   https:\/\/bugs.openjdk.java.net\/browse\/JDK-8247444\n- *   https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/ae002489df78\/src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java#l640\n- *\n- * It does so by injecting this class with elevated protection levels with sun.misc.Unsafe.defineAnonymousClass,\n- * and accessing the jdk.internal.misc.Unsafe.objectFieldOffset that does not have\n- * this protection. The class would be injected with java.lang.Object privileges, which\n- * also breaks through the module system protections.\n- *\n- * Since j.i.m.Unsafe is not accessible on every JDK, this code falls back gracefully when\n- * it is not available. Since we want to be compilable on lower JDKs (for example 8), we\n- * have to do reflective invocations as well.\n- *\n- * This file is normally compiled to bytecode for easier injection. We might have constructed\n- * it at runtime with bytecode manipulation tools.\n- *\n- * The whole thing is slow, because it requires going through reflection a few times, but it\n- * should be fine for introspection uses in JOL.\n- *\/\n-public class JOLUnsafeTrampoline {\n-\n-    static volatile Object unsafe;\n-    static volatile Method trampoline;\n-    static volatile RuntimeException failed;\n-\n-    public static long objectFieldOffset(Field f) {\n-        if (failed != null) {\n-            throw failed;\n-        }\n-\n-        if (trampoline != null) {\n-            try {\n-                return (long) trampoline.invoke(unsafe, f);\n-            } catch (IllegalAccessException | InvocationTargetException e) {\n-                failed = new IllegalStateException(e);\n-                throw failed;\n-            }\n-        }\n-\n-        try {\n-            Class<?> cl = Class.forName(\"jdk.internal.misc.Unsafe\");\n-            Method m = cl.getMethod(\"getUnsafe\");\n-            unsafe = m.invoke(null);\n-            trampoline = unsafe.getClass().getMethod(\"objectFieldOffset\", Field.class);\n-            return (long) trampoline.invoke(unsafe, f);\n-        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n-            failed = new IllegalStateException(e);\n-            throw failed;\n-        }\n-    }\n-\n-}\n","filename":"jol-core\/src\/main\/java\/java\/lang\/JOLUnsafeTrampoline.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import org.openjdk.jol.util.IOUtils;\n@@ -34,1 +33,0 @@\n-import java.io.InputStream;\n@@ -38,1 +36,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -46,0 +43,17 @@\n+    \/*\n+        The reason why this option exists is public Unsafe.objectFieldOffset\n+        refusing to tell the field offset in Records, Hidden Classes and probably\n+        other future new Java object flavors:\n+            * https:\/\/bugs.openjdk.java.net\/browse\/JDK-8247444\n+            * https:\/\/github.com\/openjdk\/jdk\/blob\/de784312c340b4a4f4c4d11854bfbe9e9e826ea3\/src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java#L644-L649\n+\n+        Internal Unsafe still allows field offset access, but it requires several\n+        very dirty moves to access. Since the magic field offset code pokes (*writes*)\n+        into object internals, it is dangerous to use, and while the code tries to be\n+        as defensive as possible, it might still cause issues.\n+    *\/\n+    private static final String MAGIC_FIELD_OFFSET_OPTION = \"jol.magicFieldOffset\";\n+\n+    private static final boolean MAGIC_FIELD_OFFSET =\n+            Boolean.parseBoolean(System.getProperty(MAGIC_FIELD_OFFSET_OPTION, \"false\"));\n+\n@@ -68,2 +82,3 @@\n-    private volatile boolean trampolineOffsetInitialized;\n-    private Method trampolineOffset;\n+    private volatile boolean mfoInitialized;\n+    private Object mfoUnsafe;\n+    private Method mfoMethod;\n@@ -157,31 +172,0 @@\n-    private Method getTrampolineOffset() {\n-        if (trampolineOffsetInitialized) {\n-            return trampolineOffset;\n-        }\n-\n-        Method to;\n-\n-        String name = \"\/java\/lang\/JOLUnsafeTrampoline.class\";\n-        try (InputStream is = getClass().getResourceAsStream(name)) {\n-            byte[] bytes = IOUtils.readAllBytes(is);\n-\n-            \/\/ Define the trampoline class with elevated privileges.\n-            \/\/ Use the full-privileged Lookup object, and use defineClass from there.\n-            \/\/ Lookup::defineClass is available only from 9+, so fail gracefully here.\n-            Method mDefCl = MethodHandles.Lookup.class.getMethod(\"defineClass\", byte[].class);\n-            Field fImplLookup = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n-            fImplLookup.setAccessible(true);\n-            MethodHandles.Lookup lookup = (MethodHandles.Lookup)fImplLookup.get(null);\n-            Class<?> tramCl = (Class<?>) mDefCl.invoke(lookup, bytes);\n-\n-            \/\/ Call the trampoline\n-            to = tramCl.getMethod(\"objectFieldOffset\", Field.class);\n-        } catch (Exception e) {\n-            to = null;\n-        }\n-\n-        trampolineOffset = to;\n-        trampolineOffsetInitialized = true;\n-        return to;\n-    }\n-\n@@ -473,4 +457,5 @@\n-            \/\/ Access denied? Try again with trampoline.\n-            Method to = getTrampolineOffset();\n-            if (to == null) {\n-                throw uoe;\n+            if (MAGIC_FIELD_OFFSET) {\n+                \/\/ Access denied? Try again with magic method.\n+                return magicFieldOffset(field, uoe);\n+            } else {\n+                throw new RuntimeException(\"Cannot get the field offset, try with -D\" + MAGIC_FIELD_OFFSET_OPTION + \"=true\", uoe);\n@@ -478,0 +463,2 @@\n+        }\n+    }\n@@ -479,0 +466,5 @@\n+    private long magicFieldOffset(Field field, RuntimeException original) {\n+        if (!mfoInitialized) {\n+            \/\/ YOLO Engineering, part (N+1):\n+            \/\/ Guess where the magic boolean field is in AccessibleObject.\n+            long magicOffset = -1;\n@@ -480,1 +472,38 @@\n-                return (long) to.invoke(null, field);\n+                \/\/ Candidates for testing: one with setAccessible \"true\", another with \"false\".\n+                \/\/ The experiment would try to figure out what object field offset differ.\n+                \/\/ Note that setAccessible should always work here, since we are reflecting\n+                \/\/ to ourselves.\n+                Method acFalse = HotspotUnsafe.class.getDeclaredMethod(\"magicFieldOffset\",\n+                        Field.class, RuntimeException.class);\n+                Method acTrue = HotspotUnsafe.class.getDeclaredMethod(\"magicFieldOffset\",\n+                        Field.class, RuntimeException.class);\n+                acFalse.setAccessible(false);\n+                acTrue.setAccessible(true);\n+\n+                \/\/ Victim candidate to juggle the setAccessible back and forth for more testing.\n+                Method acTest = HotspotUnsafe.class.getDeclaredMethod(\"magicFieldOffset\",\n+                        Field.class, RuntimeException.class);\n+\n+                \/\/ Try to find the last plausible offset.\n+                long sizeOf = sizeOf(acFalse);\n+                for (long off = 0; off < sizeOf; off++) {\n+                    boolean vFalse = U.getBoolean(acFalse, off);\n+                    boolean vTrue  = U.getBoolean(acTrue, off);\n+                    if (!vFalse && vTrue) {\n+                        \/\/ Potential candidate offset. Verify:\n+                        Random r = new Random();\n+                        boolean good = true;\n+                        for (int t = 0; t < 1000; t++) {\n+                            boolean test = r.nextBoolean();\n+                            acTest.setAccessible(test);\n+                            if (U.getBoolean(acTest, off) != test) {\n+                                good = false;\n+                                break;\n+                            }\n+                        }\n+                        if (good) {\n+                            \/\/ The confidence is HIGH. Remember it.\n+                            magicOffset = off;\n+                        }\n+                    }\n+                }\n@@ -482,4 +511,1 @@\n-                RuntimeException ex = new IllegalStateException(\"Unable to get the offset for \" + field);\n-                ex.addSuppressed(uoe);\n-                ex.addSuppressed(e);\n-                throw ex;\n+                \/\/ Do nothing.\n@@ -487,0 +513,55 @@\n+\n+            if (magicOffset != -1) {\n+                try {\n+                    \/\/ Figure out the way to internal Unsafe\n+                    Class<?> cl = Class.forName(\"jdk.internal.misc.Unsafe\");\n+                    Field fu = cl.getDeclaredField(\"theUnsafe\");\n+                    mfoUnsafe = U.getObject(U.staticFieldBase(fu), U.staticFieldOffset(fu));\n+\n+                    \/\/ Figure out the magic accessor\n+                    Method mfo = mfoUnsafe.getClass().getMethod(\"objectFieldOffset\", Field.class);\n+\n+                    \/\/ Check if magic accessor is accessible.\n+                    Method canAccess = Method.class.getMethod(\"canAccess\", Object.class);\n+                    if (!(boolean)canAccess.invoke(mfo, mfoUnsafe)) {\n+                        \/\/ Not accessible. Nothing we can do, except this last-ditch...\n+                        \/\/ DIRTY HACK: Side-step module protections by overriding the access\n+                        \/\/ control check. This allows calling internal Unsafe methods that is\n+                        \/\/ normally disallowed.\n+\n+                        \/\/ Save the old int-aligned slot for the fallback\n+                        long slotOffset = (magicOffset >> 2) << 2;\n+                        int old = U.getInt(mfo, slotOffset);\n+\n+                        \/\/ NAKED MEMORY STORE. Here be dragons.\n+                        U.putBoolean(mfo, magicOffset, true);\n+\n+                        \/\/ Check that we succeeded?\n+                        if (!(boolean)canAccess.invoke(mfo, mfoUnsafe)) {\n+                            \/\/ Failed! Put the old value back in.\n+                            U.putInt(mfo, slotOffset, old);\n+                            throw new IllegalStateException(\"Hard failure: magic offset calculation must be wrong\");\n+                        }\n+                    }\n+\n+                    \/\/ All good? Install the method as resolved.\n+                    mfoMethod = mfo;\n+                } catch (Exception e) {\n+                    \/\/ Do nothing.\n+                }\n+            }\n+\n+            mfoInitialized = true;\n+        }\n+\n+        if (mfoMethod == null || mfoUnsafe == null) {\n+            throw original;\n+        }\n+\n+        try {\n+            return (long) mfoMethod.invoke(mfoUnsafe, field);\n+        } catch (Exception e) {\n+            RuntimeException ex = new IllegalStateException(\"Unable to get the offset for \" + field);\n+            ex.addSuppressed(original);\n+            ex.addSuppressed(e);\n+            throw ex;\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/vm\/HotspotUnsafe.java","additions":126,"deletions":45,"binary":false,"changes":171,"status":"modified"}]}