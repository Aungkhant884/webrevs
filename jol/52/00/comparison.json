{"files":[{"patch":"@@ -36,1 +36,1 @@\n-    private static SortedMap<String, Operation> operations = new TreeMap<>();\n+    private static final SortedMap<String, Operation> OPERATIONS = new TreeMap<>();\n@@ -41,1 +41,1 @@\n-        registerOperation(new ObjectEstimates());\n+        registerOperation(new ObjectInternalsEstimates());\n@@ -43,2 +43,0 @@\n-        registerOperation(new ObjectShapes());\n-        registerOperation(new StringCompress());\n@@ -50,1 +48,1 @@\n-        operations.put(op.label(), op);\n+        OPERATIONS.put(op.label(), op);\n@@ -54,1 +52,1 @@\n-        String mode = (args.length >= 1) ? args[0] : \"help\";\n+        String operation = (args.length >= 1) ? args[0] : \"help\";\n@@ -56,1 +54,1 @@\n-        Operation op = operations.get(mode);\n+        Operation op = OPERATIONS.get(operation);\n@@ -61,2 +59,2 @@\n-            if (!mode.equals(\"help\")) {\n-                System.err.println(\"Unknown mode: \" + mode);\n+            if (!operation.equals(\"help\")) {\n+                System.err.println(\"Unknown operation: \" + operation);\n@@ -74,1 +72,1 @@\n-        pw.println(\"Usage: jol-cli.jar <mode> [optional arguments]*\");\n+        pw.println(\"Usage: jol-cli.jar <operation> [optional arguments]*\");\n@@ -77,3 +75,3 @@\n-        pw.println(\"Available modes: \");\n-        for (Operation lop : operations.values()) {\n-            pw.printf(\"  %20s: %s%n\", lop.label(), lop.description());\n+        pw.println(\"Available operations: \");\n+        for (Operation op : OPERATIONS.values()) {\n+            pw.printf(\"  %20s: %s%n\", op.label(), op.description());\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/Main.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -48,2 +49,4 @@\n-        OptionSpec<String> optClassPath = parser.accepts(\"cp\", \"Additional classpath entries, where to look for the referenced classes.\")\n-                .withRequiredArg().ofType(String.class).describedAs(\"classpath\").withValuesSeparatedBy(getProperty(\"path.separator\"));\n+        OptionSpec<String> optClassPath = parser.acceptsAll(Arrays.asList(\"cp\", \"classpath\"),\n+                        \"Additional classpath entries, where to look for the referenced classes.\")\n+                .withRequiredArg().ofType(String.class).describedAs(\"classpath\")\n+                .withValuesSeparatedBy(getProperty(\"path.separator\"));\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/ClasspathedOperation.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        return \"Consume the heap dump and simulate the class layout in different VM modes\";\n+        return \"Read a heap dump and estimate footprint in different VM modes\";\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/HeapDumpEstimates.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        return \"heapdumpstats\";\n+        return \"heapdump-stats\";\n@@ -54,1 +54,1 @@\n-        return \"Consume the heap dump and print the most frequent instances.\";\n+        return \"Read a heap dump and print simple statistics\";\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/HeapDumpStats.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jol.operations;\n-\n-import org.openjdk.jol.datamodel.*;\n-import org.openjdk.jol.info.ClassLayout;\n-import org.openjdk.jol.layouters.HotSpotLayouter;\n-import org.openjdk.jol.layouters.Layouter;\n-import org.openjdk.jol.layouters.RawLayouter;\n-\n-import static java.lang.System.out;\n-\n-\/**\n- * @author Aleksey Shipilev\n- *\/\n-public class ObjectEstimates extends ClasspathedOperation {\n-\n-    @Override\n-    public String label() {\n-        return \"estimates\";\n-    }\n-\n-    @Override\n-    public String description() {\n-        return \"Simulate the class layout in different VM modes.\";\n-    }\n-\n-    @Override\n-    protected void runWith(Class<?> klass) {\n-        for (DataModel model : EstimatedModels.MODELS_JDK8) {\n-            Layouter l = new HotSpotLayouter(model, 8);\n-            out.println(\"***** \" + l);\n-            out.println(ClassLayout.parseClass(klass, l).toPrintable());\n-        }\n-\n-        for (DataModel model : EstimatedModels.MODELS_JDK8) {\n-            Layouter l = new HotSpotLayouter(model, 15);\n-            out.println(\"***** \" + l);\n-            out.println(ClassLayout.parseClass(klass, l).toPrintable());\n-        }\n-\n-        for (DataModel model : EstimatedModels.MODELS_JDK15) {\n-            Layouter l = new HotSpotLayouter(model, 15);\n-            out.println(\"***** \" + l);\n-            out.println(ClassLayout.parseClass(klass, l).toPrintable());\n-        }\n-\n-        for (DataModel model : EstimatedModels.MODELS_LILLIPUT) {\n-            Layouter l = new HotSpotLayouter(model, 99);\n-            out.println(\"***** \" + l);\n-            out.println(ClassLayout.parseClass(klass, l).toPrintable());\n-        }\n-    }\n-\n-}\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/ObjectEstimates.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -45,1 +45,1 @@\n-        return \"Show the object externals: the objects reachable from a given instance.\";\n+        return \"Show object externals: objects reachable from a given instance\";\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/ObjectExternals.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        return \"Estimate the footprint of all objects reachable from a given instance\";\n+        return \"Show the footprint of all objects reachable from a sample instance\";\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/ObjectFootprint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        return \"Show the object internals: field layout and default contents, object header\";\n+        return \"Show object internals: field layout, default contents, object header\";\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/ObjectInternals.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jol.operations;\n+\n+import org.openjdk.jol.datamodel.*;\n+import org.openjdk.jol.info.ClassLayout;\n+import org.openjdk.jol.layouters.HotSpotLayouter;\n+import org.openjdk.jol.layouters.Layouter;\n+import org.openjdk.jol.util.Multimap;\n+import org.openjdk.jol.util.Multiset;\n+\n+import java.util.*;\n+\n+import static java.lang.System.out;\n+\n+\/**\n+ * @author Aleksey Shipilev\n+ *\/\n+public class ObjectInternalsEstimates extends ClasspathedOperation {\n+\n+    @Override\n+    public String label() {\n+        return \"internals-estimates\";\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"Same as 'internals', but simulate class layout in different VM modes\";\n+    }\n+\n+    @Override\n+    protected void runWith(Class<?> klass) {\n+        List<Layouter> layouters = new ArrayList<>();\n+\n+        for (DataModel model : EstimatedModels.MODELS_JDK8) {\n+            layouters.add(new HotSpotLayouter(model, 8));\n+        }\n+\n+        for (DataModel model : EstimatedModels.MODELS_JDK8) {\n+            layouters.add(new HotSpotLayouter(model, 15));\n+        }\n+\n+        for (DataModel model : EstimatedModels.MODELS_JDK15) {\n+            layouters.add(new HotSpotLayouter(model, 15));\n+        }\n+\n+        for (DataModel model : EstimatedModels.MODELS_LILLIPUT) {\n+            layouters.add(new HotSpotLayouter(model, 99));\n+        }\n+\n+        Multimap<Wrapper, Layouter> outputs = new Multimap<>();\n+\n+        for (Layouter l : layouters) {\n+            ClassLayout cl = ClassLayout.parseClass(klass, l);\n+            outputs.put(new Wrapper(cl.toPrintable(), cl.instanceSize()), l);\n+        }\n+\n+        List<Wrapper> sortedWs = new ArrayList<>(outputs.keys());\n+        sortedWs.sort(Comparator.comparing(Wrapper::size).reversed());\n+\n+        for (Wrapper w : sortedWs) {\n+            for (Layouter l : outputs.get(w)) {\n+                out.println(\"***** \" + l);\n+            }\n+            out.println();\n+            out.println(w.output);\n+        }\n+    }\n+\n+    private static class Wrapper {\n+        final String output;\n+        final long size;\n+\n+        public Wrapper(String output, long size) {\n+            this.output = output;\n+            this.size = size;\n+        }\n+\n+        public long size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Wrapper wrapper = (Wrapper) o;\n+            return Objects.equals(output, wrapper.output);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return output.hashCode();\n+        }\n+    }\n+\n+}\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/ObjectInternalsEstimates.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jol.operations;\n-\n-import org.openjdk.jol.Operation;\n-import org.openjdk.jol.heap.HeapDumpReader;\n-import org.openjdk.jol.info.ClassData;\n-import org.openjdk.jol.info.FieldData;\n-import org.openjdk.jol.util.Multiset;\n-\n-import java.io.File;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.util.Enumeration;\n-import java.util.concurrent.*;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarFile;\n-\n-\/**\n- * @author Aleksey Shipilev\n- *\/\n-public class ObjectShapes implements Operation {\n-\n-    @Override\n-    public String label() {\n-        return \"shapes\";\n-    }\n-\n-    @Override\n-    public String description() {\n-        return \"Dump the object shapes present in JAR files or heap dumps.\";\n-    }\n-\n-    public void run(String... args) throws Exception {\n-        if (args.length == 0) {\n-            System.err.println(\"Expected one or more JAR\/heapdump file names.\");\n-            System.exit(1);\n-        }\n-\n-        ExecutorService threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n-        CompletionService<Multiset<String>> cs = new ExecutorCompletionService<>(threadPool);\n-\n-        for (final String arg : args) {\n-            if (arg.endsWith(\".jar\")) {\n-                cs.submit(() -> processJAR(arg));\n-            }\n-            if (arg.endsWith(\".dump\") || arg.endsWith(\"hprof\") || arg.endsWith(\"hprof.gz\")) {\n-                cs.submit(() -> processHeapDump(arg));\n-            }\n-        }\n-\n-        Multiset<String> shapes = new Multiset<>();\n-        for (String arg : args) {\n-            Multiset<String> ms = cs.take().get();\n-            shapes.merge(ms);\n-        }\n-\n-        threadPool.shutdown();\n-\n-        for (String key : shapes.keys()) {\n-            System.out.printf(\"%d\\t%s%n\", shapes.count(key), key);\n-        }\n-    }\n-\n-    private Multiset<String> processHeapDump(String arg) {\n-        Multiset<String> shapes = new Multiset<>();\n-        try {\n-            HeapDumpReader reader = new HeapDumpReader(new File(arg), System.out, null);\n-            Multiset<ClassData> data = reader.parse();\n-            for (ClassData cd : data.keys()) {\n-                String shape = parseClassData(cd);\n-                shapes.add(shape, data.count(cd));\n-            }\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-        return shapes;\n-    }\n-\n-    private Multiset<String> processJAR(String jarName) {\n-        Multiset<String> shapes = new Multiset<>();\n-        try (URLClassLoader cl = URLClassLoader.newInstance(new URL[]{new URL(\"jar:file:\" + jarName + \"!\/\")});\n-             JarFile jarFile = new JarFile(jarName)) {\n-\n-            Enumeration<JarEntry> e = jarFile.entries();\n-            while (e.hasMoreElements()) {\n-                JarEntry je = e.nextElement();\n-                String name = je.getName();\n-                if (je.isDirectory()) continue;\n-                if (!name.endsWith(\".class\")) continue;\n-\n-                String className = name.substring(0, name.length() - 6).replace('\/', '.');\n-                try {\n-                    Class<?> klass = cl.loadClass(className);\n-                    ClassData cd = ClassData.parseClass(klass);\n-                    String shape = parseClassData(cd);\n-                    shapes.add(shape);\n-                } catch (Throwable t) {\n-                    t.printStackTrace(System.err);\n-                }\n-            }\n-        } catch (Exception t) {\n-            \/\/ ignore\n-        }\n-        return shapes;\n-    }\n-\n-    private String parseClassData(ClassData cd) {\n-        StringBuilder sb = new StringBuilder();\n-        for (String cn : cd.classHierarchy()) {\n-            for (FieldData fd : cd.fieldsFor(cn)) {\n-                sb.append(toTypeLabel(fd.typeClass()));\n-            }\n-            sb.append(\"|\");\n-        }\n-        if (sb.length() == 0) {\n-            sb.append(\"|\");\n-        }\n-        if (sb.charAt(0) != '|') {\n-            sb.insert(0, '|');\n-        }\n-        return sb.toString();\n-    }\n-\n-    private static char toTypeLabel(String s) {\n-        if (\"boolean\".equals(s))    return 'Z';\n-        if (\"byte\".equals(s))       return 'B';\n-        if (\"char\".equals(s))       return 'C';\n-        if (\"short\".equals(s))      return 'S';\n-        if (\"int\".equals(s))        return 'I';\n-        if (\"float\".equals(s))      return 'F';\n-        if (\"long\".equals(s))       return 'L';\n-        if (\"double\".equals(s))     return 'D';\n-        return 'L';\n-    }\n-\n-}\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/ObjectShapes.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -1,283 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jol.operations;\n-\n-import org.openjdk.jol.Operation;\n-import org.openjdk.jol.datamodel.*;\n-import org.openjdk.jol.heap.HeapDumpException;\n-import org.openjdk.jol.heap.HeapDumpReader;\n-import org.openjdk.jol.info.ClassData;\n-import org.openjdk.jol.info.FieldData;\n-import org.openjdk.jol.layouters.HotSpotLayouter;\n-import org.openjdk.jol.layouters.Layouter;\n-import org.openjdk.jol.util.Multiset;\n-\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import static java.lang.System.out;\n-\n-\/**\n- * @author Aleksey Shipilev\n- *\/\n-public class StringCompress implements Operation {\n-\n-    static final String DO_MODE = System.getProperty(\"mode\", \"estimates\");\n-\n-    static final DataModel[] DATA_MODELS = new DataModel[]{\n-            new Model32(),\n-            new Model64(false, false),\n-            new Model64(true, true),\n-            new Model64(true, true, 16),\n-            new Model64(false, true),\n-            new Model64(false, true, 16),\n-    };\n-\n-\n-    @Override\n-    public String label() {\n-        return \"string-compress\";\n-    }\n-\n-    @Override\n-    public String description() {\n-        return \"Consume the heap dumps and figures out the savings attainable with compressed strings.\";\n-    }\n-\n-    public void run(String... args) throws Exception {\n-        if (args.length == 0) {\n-            System.err.println(\"Expected one or more heap dump file names.\");\n-            return;\n-        }\n-\n-        if (DO_MODE.equalsIgnoreCase(\"histo\")) {\n-            out.printf(\"%15s, %15s, %18s, %s%n\",\n-                    \"\\\"size\\\"\", \"\\\"compressible\\\"\", \"\\\"non-compressible\\\"\", \"\\\"hprof file\\\"\");\n-        } else if (DO_MODE.equalsIgnoreCase(\"estimates\")) {\n-            out.printf(\"%15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %s, %70s, %s%n\",\n-                    \"\\\"total\\\"\", \"\\\"String\\\"\", \"\\\"String+bool\\\"\", \"\\\"String+oop\\\"\", \"\\\"char[]-2b\\\"\",\n-                    \"\\\"char[]-1b\\\"\", \"\\\"char[]-1b-comp\\\"\", \"\\\"savings(same)\\\"\",  \"\\\"savings(bool)\\\"\", \"\\\"savings(oop)\\\"\", \"\\\"model\\\"\", \"\\\"hprof file\\\"\");\n-        }\n-\n-        List<Future<?>> res = new ArrayList<>();\n-        ExecutorService service = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n-        for (String arg : args) {\n-            res.add(service.submit(new Worker(arg)));\n-        }\n-\n-        for (Future<?> f : res) {\n-            try {\n-                f.get();\n-            } catch (ExecutionException e) {\n-                e.getCause().printStackTrace(System.err);\n-                \/\/ and then ignore\n-            }\n-        }\n-\n-        service.shutdown();\n-    }\n-\n-    public static class Worker implements Callable<Object> {\n-        long stringID;\n-        int stringValueIdx;\n-        int stringValueSize;\n-\n-        final Multiset<Integer> compressibleCharArrays;\n-        final Multiset<Integer> nonCompressibleCharArrays;\n-        final String path;\n-\n-        public Worker(String arg) {\n-            this.path = arg;\n-            this.compressibleCharArrays = new Multiset<>();\n-            this.nonCompressibleCharArrays = new Multiset<>();\n-        }\n-\n-        public Object call() throws Exception {\n-            final Set<Long> referencedArrays = new HashSet<>();\n-\n-            final Map<Long, Boolean> isCompressible = new HashMap<>();\n-            final Map<Long, Integer> size = new HashMap<>();\n-\n-            HeapDumpReader.Visitor visitor = new HeapDumpReader.Visitor() {\n-                @Override\n-                public void visitClass(long id, String name, List<Integer> oopIdx, int oopSize) {\n-                    if (name.equals(\"java.lang.String\")) {\n-                        stringID = id;\n-                        stringValueIdx = oopIdx.get(0);\n-                        stringValueSize = oopSize;\n-                    }\n-                }\n-\n-                @Override\n-                public void visitInstance(long id, long klassID, byte[] bytes) {\n-                    if (stringID == 0) {\n-                        throw new IllegalStateException(\"java.lang.String was not discovered yet in \" + path);\n-                    }\n-                    if (klassID == stringID) {\n-                        ByteBuffer wrap = ByteBuffer.wrap(bytes);\n-                        long arrayId;\n-                        switch (stringValueSize) {\n-                            case 4:\n-                                arrayId = wrap.getInt(stringValueIdx);\n-                                break;\n-                            case 8:\n-                                arrayId = wrap.getLong(stringValueIdx);\n-                                break;\n-                            default:\n-                                throw new IllegalStateException();\n-                        }\n-                        if (arrayId != 0) {\n-                            referencedArrays.add(arrayId);\n-                        }\n-                    }\n-                }\n-\n-                @Override\n-                public void visitPrimArray(long id, String typeClass, int count, byte[] bytes) {\n-                    if (typeClass.equals(\"char\")) {\n-                        isCompressible.put(id, isCompressible(bytes));\n-                        size.put(id, count);\n-                    }\n-                }\n-            };\n-\n-            HeapDumpReader reader = new HeapDumpReader(new File(path), null, visitor);\n-\n-            Multiset<ClassData> data = reader.parse();\n-\n-            for (Long id : referencedArrays) {\n-                Boolean compressible = isCompressible.get(id);\n-                if (compressible == null) {\n-                    throw new HeapDumpException(\"String.value array \" + id + \" is not char[] in \" + path + \", skipping\");\n-                }\n-\n-                if (compressible) {\n-                    compressibleCharArrays.add(size.get(id));\n-                } else {\n-                    nonCompressibleCharArrays.add(size.get(id));\n-                }\n-            }\n-\n-            if (DO_MODE.equalsIgnoreCase(\"histo\")) {\n-                TreeSet<Integer> sizes = new TreeSet<>();\n-                sizes.addAll(compressibleCharArrays.keys());\n-                sizes.addAll(nonCompressibleCharArrays.keys());\n-\n-                for (Integer s : sizes) {\n-                    out.printf(\"%15d, %15d, %18d, \\\"%s\\\"%n\", s, compressibleCharArrays.count(s), nonCompressibleCharArrays.count(s), path);\n-                }\n-            } else if (DO_MODE.equalsIgnoreCase(\"estimates\")) {\n-                for (DataModel model : DATA_MODELS) {\n-                    printLine(data, new HotSpotLayouter(model, 8));\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        private void printLine(Multiset<ClassData> data, Layouter l) {\n-            long strings = 0;\n-            long stringsBool = 0;\n-            long stringsOop = 0;\n-\n-            long totalFootprint = 0;\n-            for (ClassData cd : data.keys()) {\n-                long count = data.count(cd);\n-\n-                if (cd.name().equals(\"java.lang.String\")) {\n-                    ClassData mcd = ClassData.parseClass(Object.class);\n-                    mcd.addField(FieldData.create(\"Object\", \"value\", \"char[]\"));\n-                    mcd.addField(FieldData.create(\"Object\", \"hash\", \"int\"));\n-                    strings += l.layout(mcd).instanceSize() * count;\n-\n-                    ClassData mcdBool = ClassData.parseClass(Object.class);\n-                    mcdBool.addField(FieldData.create(\"Object\", \"value\", \"char[]\"));\n-                    mcdBool.addField(FieldData.create(\"Object\", \"hash\", \"int\"));\n-                    mcdBool.addField(FieldData.create(\"Object\", \"isCompressed\", \"boolean\"));\n-                    stringsBool += l.layout(mcdBool).instanceSize() * count;\n-\n-                    ClassData mcdOop = ClassData.parseClass(Object.class);\n-                    mcdOop.addField(FieldData.create(\"Object\", \"value\", \"char[]\"));\n-                    mcdOop.addField(FieldData.create(\"Object\", \"hash\", \"int\"));\n-                    mcdOop.addField(FieldData.create(\"Object\", \"coder\", \"java.lang.Object\"));\n-                    stringsOop += l.layout(mcdOop).instanceSize() * count;\n-                } else {\n-                    totalFootprint += l.layout(cd).instanceSize() * count;\n-                }\n-            }\n-\n-            long compressedBytes = 0;\n-            long compressibleBytes = 0;\n-            for (Integer len : compressibleCharArrays.keys()) {\n-                long count = compressibleCharArrays.count(len);\n-\n-                ClassData charArr = new ClassData(\"char[]\", \"char\", len);\n-                ClassData byteArr = new ClassData(\"byte[]\", \"byte\", len);\n-\n-                compressedBytes += l.layout(byteArr).instanceSize() * count;\n-                compressibleBytes += l.layout(charArr).instanceSize() * count;\n-            }\n-\n-            long nonCompressibleBytes = 0;\n-            for (Integer len : nonCompressibleCharArrays.keys()) {\n-                long count = nonCompressibleCharArrays.count(len);\n-\n-                ClassData charArr = new ClassData(\"char[]\", \"char\", len);\n-                nonCompressibleBytes += l.layout(charArr).instanceSize() * count;\n-            }\n-\n-            totalFootprint += strings;\n-\n-            double savingSame = 100.0 * ((compressibleBytes - compressedBytes)) \/ totalFootprint;\n-            double savingBool = 100.0 * ((compressibleBytes - compressedBytes) - (stringsBool - strings)) \/ totalFootprint;\n-            double savingOop  = 100.0 * ((compressibleBytes - compressedBytes) - (stringsOop - strings))  \/ totalFootprint;\n-            out.printf(\"%15d, %15d, %15d, %15d, %15d, %15d, %15d, %15.3f, %15.3f, %15.3f, %70s, \\\"%s\\\"%n\",\n-                    totalFootprint, strings, stringsBool, stringsOop, nonCompressibleBytes, compressibleBytes, compressedBytes,\n-                    savingSame, savingBool, savingOop, \"\\\"\" + l + \"\\\"\", path);\n-        }\n-\n-        public static boolean isCompressible(byte[] bytes) {\n-            ByteBuffer buf = ByteBuffer.wrap(bytes);\n-            for (int c = 0; c < bytes.length; c += 2) {\n-                if ((buf.getShort(c) & 0xFF00) != 0) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-    }\n-}\n","filename":"jol-cli\/src\/main\/java\/org\/openjdk\/jol\/operations\/StringCompress.java","additions":0,"deletions":283,"binary":false,"changes":283,"status":"deleted"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jol.util;\n+\n+import java.util.*;\n+\n+\/**\n+ * Naive HashMultimap.\n+ *\n+ * @param <K> key type\n+ * @param <V> value type\n+ *\/\n+public class Multimap<K, V> {\n+\n+    private final Map<K, List<V>> map = new HashMap<>();\n+\n+    public void put(K k, V v) {\n+        List<V> vs = map.get(k);\n+        if (vs == null) {\n+            vs = new ArrayList<>();\n+            map.put(k, vs);\n+        }\n+        vs.add(v);\n+    }\n+\n+    public List<V> get(K k) {\n+        return Collections.unmodifiableList(map.get(k));\n+    }\n+\n+    public Collection<K> keys() {\n+        return map.keySet();\n+    }\n+\n+}\n","filename":"jol-core\/src\/main\/java\/org\/openjdk\/jol\/util\/Multimap.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}