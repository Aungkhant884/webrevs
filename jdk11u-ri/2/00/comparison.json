{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,5 @@\n+        \/\/ isJavaIdentifierStart strictly conforms to code points assigned\n+        \/\/ in Unicode 10.0. Since code points {32FF} and {9FEB..9FEF} are\n+        \/\/ not from Unicode 10.0, return false.\n+        if(ch == 0x32FF || (ch >= 0x9FEB && ch <= 0x9FEF))\n+            return false;\n@@ -113,0 +118,5 @@\n+        \/\/ isJavaIdentifierPart strictly conforms to code points assigned\n+        \/\/ in Unicode 10.0. Since code points {32FF} and {9FEB..9FEF} are\n+        \/\/ not from Unicode 10.0, return false.\n+        if(ch == 0x32FF || (ch >= 0x9FEB && ch <= 0x9FEF))\n+            return false;\n","filename":"make\/data\/characterdata\/CharacterData00.java.template","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -11732,0 +11732,1 @@\n+32FF;SQUARE ERA NAME NEWERA;So;0;L;<square> 5143 53F7;;;;N;SQUARED TWO IDEOGRAPHS ERA NAME NEWERA;;;;\n@@ -12055,1 +12056,1 @@\n-9FEA;<CJK Ideograph, Last>;Lo;0;L;;;;;N;;;;;\n+9FEF;<CJK Ideograph, Last>;Lo;0;L;;;;;N;;;;;\n","filename":"make\/data\/unicodedata\/UnicodeData.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,4 +54,17 @@\n- * The file and its description are available from the Unicode Consortium at:\n- * <ul>\n- * <li><a href=\"http:\/\/www.unicode.org\">http:\/\/www.unicode.org<\/a>\n- * <\/ul>\n+ * The Java SE 11 Platform uses character information from version 10.0\n+ * of the Unicode Standard, with two extensions. First, the Java SE 11 Platform\n+ * allows an implementation of class {@code Character} to use the code points\n+ * in the range of {@code U+9FEB} to {@code U+9FEF} from the Unicode Standard\n+ * version 11.0, in order for the class to allow the \"Implementation Level 1\"\n+ * of the Chinese GB18030-2022 standard. Second, the Java SE 11 Platform\n+ * allows an implementation of class {@code Character} to use the Japanese Era\n+ * code point, {@code U+32FF}, from the Unicode Standard version 12.1.\n+ * Consequently, the behavior of\n+ * fields and methods of class {@code Character} may vary across\n+ * implementations of the Java SE 11 Platform when processing the\n+ * aforementioned code point ( outside of version 10.0 ), except for\n+ * the following methods that define Java identifiers:\n+ * {@link #isJavaIdentifierStart(int)}, {@link #isJavaIdentifierStart(char)},\n+ * {@link #isJavaIdentifierPart(int)}, and {@link #isJavaIdentifierPart(char)}.\n+ * Code points in Java identifiers must be drawn from version 10.0 of\n+ * the Unicode Standard.\n@@ -5388,1 +5401,1 @@\n-            0x32FF,   \/\/ 32FF      ; UNKNOWN\n+            0x32FF,   \/\/ 32FF      ; COMMON\n@@ -5394,2 +5407,2 @@\n-            0x4E00,   \/\/ 4E00..9FEA; HAN\n-            0x9FEB,   \/\/ 9FEB..9FFF; UNKNOWN\n+            0x4E00,   \/\/ 4E00..9FEF; HAN\n+            0x9FF0,   \/\/ 9FF0..9FFF; UNKNOWN\n@@ -6905,1 +6918,1 @@\n-            UNKNOWN,                  \/\/ 32FF\n+            COMMON,                   \/\/ 32FF\n@@ -6911,2 +6924,2 @@\n-            HAN,                      \/\/ 4E00..9FEA\n-            UNKNOWN,                  \/\/ 9FEB..9FFF\n+            HAN,                      \/\/ 4E00..9FEF\n+            UNKNOWN,                  \/\/ 9FF0..9FFF\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8202771\n+ * @bug 8202771 8301401\n@@ -43,0 +43,5 @@\n+    \/\/ Japanese Era Square character code point and GB18030-2022\n+    \/\/ code points past Unicode 10.0 are not valid identifiers for Java SE 11\n+    private static final int JAPANESE_ERA_CODEPOINT = 0x32FF;\n+    private static final int GB18030_2022_CODEPOINT_START = 0x9FEB;\n+    private static final int GB18030_2022_CODEPOINT_END = 0x9FEF;\n@@ -171,0 +176,12 @@\n+        \/\/ Since Character.isJavaIdentifierPart(int) strictly conforms to\n+        \/\/ character information from version 10.0 of the Unicode Standard,\n+        \/\/ check if code point is either a Japanese Era Square character\n+        \/\/ code point or one of the GB18030-2022 code points > Unicode 10.0.\n+        \/\/ If the code point is either a Japanese Era Square character code\n+        \/\/ point or one of the GB18030-2022 code points > Unicode 10.0,\n+        \/\/ value of variable \"expected\" is considered false.\n+        boolean expected = false;\n+        if (codePoint != JAPANESE_ERA_CODEPOINT &&\n+                !(codePoint >= GB18030_2022_CODEPOINT_START && codePoint <= GB18030_2022_CODEPOINT_END)) {\n+            expected = isJavaIdentifierStart(category);\n+        }\n@@ -172,1 +189,0 @@\n-        boolean expected = isJavaIdentifierStart(category);\n@@ -179,0 +195,12 @@\n+        \/\/ Since Character.isJavaIdentifierPart(int) strictly conforms to\n+        \/\/ character information from version 10.0 of the Unicode Standard,\n+        \/\/ check if code point is either a Japanese Era Square character\n+        \/\/ code point or one of the GB18030-2022 code points > Unicode 10.0.\n+        \/\/ If the code point is either a Japanese Era Square character code\n+        \/\/ point or one of the GB18030-2022 code points > Unicode 10.0,\n+        \/\/ value of variable \"expected\" is considered false.\n+        boolean expected = false;\n+        if (codePoint != JAPANESE_ERA_CODEPOINT &&\n+                !(codePoint >= GB18030_2022_CODEPOINT_START && codePoint <= GB18030_2022_CODEPOINT_END)) {\n+            expected = isJavaIdentifierPart(codePoint, category);\n+        }\n@@ -180,1 +208,0 @@\n-        boolean expected = isJavaIdentifierPart(codePoint, category);\n","filename":"test\/jdk\/java\/lang\/Character\/CharPropTest.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -405,0 +405,1 @@\n+32FF          ; Common # So       SQUARE ERA NAME NEWERA\n@@ -1509,1 +1510,1 @@\n-4E00..9FEA    ; Han # Lo [20971] CJK UNIFIED IDEOGRAPH-4E00..CJK UNIFIED IDEOGRAPH-9FEA\n+4E00..9FEF    ; Han # Lo [20976] CJK UNIFIED IDEOGRAPH-4E00..CJK UNIFIED IDEOGRAPH-9FEF\n","filename":"test\/jdk\/java\/lang\/Character\/Scripts.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test behavior of isJavaIdentifierXX, isJavaLetter, and\n+ *  isJavaLetterOrDigit methods for all code points.\n+ * @bug 8218915 8301401\n+ *\/\n+\n+public class TestIsJavaIdentifierMethods {\n+\n+    \/\/ Japanese Era Square character code point and GB18030-2022\n+    \/\/ code points past Unicode 10.0 are not valid identifiers for Java SE 11\n+    private static final int JAPANESE_ERA_CODEPOINT = 0x32FF;\n+    private static final int GB18030_2022_CODEPOINT_START = 0x9FEB;\n+    private static final int GB18030_2022_CODEPOINT_END = 0x9FEF;\n+\n+    public static void main(String[] args) {\n+        testIsJavaIdentifierPart_int();\n+        testIsJavaIdentifierPart_char();\n+        testIsJavaIdentifierStart_int();\n+        testIsJavaIdentifierStart_char();\n+        testIsJavaLetter();\n+        testIsJavaLetterOrDigit();\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaIdentifierPart(int\n+     * codePoint), A character may be part of a Java identifier if any of the\n+     * following are true:\n+     * <ul>\n+     * <li>it is a letter<\/li>\n+     * <li>it is a currency symbol (such as <code>'$'<\/code>)<\/li>\n+     * <li>it is a connecting punctuation character (such as <code>'_'<\/code>)\n+     * <\/li>\n+     * <li>it is a digit<\/li>\n+     * <li>it is a numeric letter (such as a Roman numeral character)<\/li>\n+     * <li>it is a combining mark<\/li>\n+     * <li>it is a non-spacing mark<\/li>\n+     * <li><code>isIdentifierIgnorable<\/code> returns <code>true<\/code> for the\n+     * character<\/li>\n+     * <\/ul>\n+     * All code points from (0x0000..0x10FFFF) are tested.\n+     *\/\n+    public static void testIsJavaIdentifierPart_int() {\n+        for (int cp = 0; cp <= Character.MAX_CODE_POINT; cp++) {\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaIdentifierPart(int) strictly conforms to\n+            \/\/ character information from version 10.0 of the Unicode Standard,\n+            \/\/ check if code point is either a Japanese Era Square character\n+            \/\/ code point or one of the GB18030-2022 code points > Unicode 10.0.\n+            \/\/ If the code point is either a Japanese Era Square character code\n+            \/\/ point or one of the GB18030-2022 code points > Unicode 10.0,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (cp != JAPANESE_ERA_CODEPOINT &&\n+                    !(cp >= GB18030_2022_CODEPOINT_START && cp <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(cp);\n+                expected = Character.isLetter(cp)\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION\n+                        || Character.isDigit(cp)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.COMBINING_SPACING_MARK\n+                        || type == Character.NON_SPACING_MARK\n+                        || Character.isIdentifierIgnorable(cp);\n+            }\n+\n+            if (Character.isJavaIdentifierPart(cp) != expected) {\n+                throw new RuntimeException(\n+                   \"Character.isJavaIdentifierPart(int) failed for codepoint \"\n+                                + Integer.toHexString(cp));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaIdentifierPart(char\n+     * ch), A character may be part of a Java identifier if any of the\n+     * following are true:\n+     * <ul>\n+     * <li>it is a letter;\n+     * <li>it is a currency symbol (such as \"$\");\n+     * <li>it is a connecting punctuation character (such as \"_\");\n+     * <li>it is a digit;\n+     * <li>it is a numeric letter (such as a Roman numeral character);\n+     * <li>it is a combining mark;\n+     * <li>it is a non-spacing mark;\n+     * <li>isIdentifierIgnorable returns true for the character.\n+     * <\/ul>\n+     * All Unicode code points in the BMP (0x0000..0xFFFF) are tested.\n+     *\/\n+    public static void testIsJavaIdentifierPart_char() {\n+        for (int i = 0; i <= Character.MAX_VALUE; ++i) {\n+            char ch = (char) i;\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaIdentifierPart(char) strictly conforms to\n+            \/\/ character information from version 10.0 of the Unicode Standard,\n+            \/\/ check if code point is either a Japanese Era Square character\n+            \/\/ code point or one of the GB18030-2022 code points > Unicode 10.0.\n+            \/\/ If the code point is either a Japanese Era Square character code\n+            \/\/ point or one of the GB18030-2022 code points > Unicode 10.0,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (i != JAPANESE_ERA_CODEPOINT &&\n+                    !(i >= GB18030_2022_CODEPOINT_START && i <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(ch);\n+                expected = Character.isLetter(ch)\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION\n+                        || Character.isDigit(ch)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.COMBINING_SPACING_MARK\n+                        || type == Character.NON_SPACING_MARK\n+                        || Character.isIdentifierIgnorable(ch);\n+            }\n+\n+            if (Character.isJavaIdentifierPart((char) i) != expected) {\n+                throw new RuntimeException(\n+                    \"Character.isJavaIdentifierPart(char) failed for codepoint \"\n+                                + Integer.toHexString(i));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaIdentifierStart(int\n+     * codePoint), A character may start a Java identifier if and only if it is\n+     * one of the following:\n+     * <ul>\n+     * <li>it is a letter;<\/li>\n+     * <li>getType(ch) returns LETTER_NUMBER;<\/li>\n+     * <li>it is a currency symbol (such as \"$\");<\/li>\n+     * <li>it is a connecting punctuation character (such as \"_\");<\/li>\n+     * <\/ul>\n+     * All Code points from (0x0000..0x10FFFF) are tested.\n+     *\/\n+    public static void testIsJavaIdentifierStart_int() {\n+        for (int cp = 0; cp <= Character.MAX_CODE_POINT; cp++) {\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaIdentifierStart(int) strictly conforms to\n+            \/\/ character information from version 10.0 of the Unicode Standard,\n+            \/\/ check if code point is either a Japanese Era Square character\n+            \/\/ code point or one of the GB18030-2022 code points > Unicode 10.0.\n+            \/\/ If the code point is either a Japanese Era Square character code\n+            \/\/ point or one of the GB18030-2022 code points > Unicode 10.0,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (cp != JAPANESE_ERA_CODEPOINT &&\n+                    !(cp >= GB18030_2022_CODEPOINT_START && cp <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(cp);\n+                expected = Character.isLetter(cp)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION;\n+            }\n+\n+            if (Character.isJavaIdentifierStart(cp) != expected) {\n+                throw new RuntimeException(\n+                        \"Character.isJavaIdentifierStart(int) failed for codepoint \"\n+                                + Integer.toHexString(cp));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaIdentifierStart(char),\n+     * A character may start a Java identifier if and only if it is\n+     * one of the following:\n+     * <ul>\n+     * <li>it is a letter;<\/li>\n+     * <li>getType(ch) returns LETTER_NUMBER;<\/li>\n+     * <li>it is a currency symbol (such as \"$\");<\/li>\n+     * <li>it is a connecting punctuation character (such as \"_\");<\/li>\n+     * <\/ul>\n+     * All Unicode code points in the BMP (0x0000..0xFFFF) are tested.\n+     *\/\n+    public static void testIsJavaIdentifierStart_char() {\n+        for (int i = 0; i <= Character.MAX_VALUE; i++) {\n+            char ch = (char) i;\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaIdentifierStart(char) strictly conforms to\n+            \/\/ character information from version 10.0 of the Unicode Standard,\n+            \/\/ check if code point is either a Japanese Era Square character\n+            \/\/ code point or one of the GB18030-2022 code points > Unicode 10.0.\n+            \/\/ If the code point is either a Japanese Era Square character code\n+            \/\/ point or one of the GB18030-2022 code points > Unicode 10.0,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (i != JAPANESE_ERA_CODEPOINT &&\n+                    !(i >= GB18030_2022_CODEPOINT_START && i <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(ch);\n+                expected = Character.isLetter(ch)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION;\n+            }\n+\n+            if (Character.isJavaIdentifierStart(ch) != expected) {\n+                throw new RuntimeException(\n+                        \"Character.isJavaIdentifierStart(char) failed for codepoint \"\n+                                + Integer.toHexString(i));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaLetter(char ch), A\n+     * character may start a Java identifier if and only if one of the following\n+     * is true:\n+     * <ul>\n+     * <li>isLetter(ch) returns true\n+     * <li>getType(ch) returns LETTER_NUMBER\n+     * <li>ch is a currency symbol (such as \"$\")\n+     * <li>ch is a connecting punctuation character (such as \"_\").\n+     * <\/ul>\n+     * All Unicode code points in the BMP (0x0000..0xFFFF) are tested.\n+     *\/\n+    public static void testIsJavaLetter() {\n+        for (int i = 0; i <= Character.MAX_VALUE; ++i) {\n+            char ch = (char) i;\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaLetter(char) strictly conforms to\n+            \/\/ character information from version 10.0 of the Unicode Standard,\n+            \/\/ check if code point is either a Japanese Era Square character\n+            \/\/ code point or one of the GB18030-2022 code points > Unicode 10.0.\n+            \/\/ If the code point is either a Japanese Era Square character code\n+            \/\/ point or one of the GB18030-2022 code points > Unicode 10.0,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (i != JAPANESE_ERA_CODEPOINT &&\n+                    !(i >= GB18030_2022_CODEPOINT_START && i <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(ch);\n+                expected = Character.isLetter(ch)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION;\n+            }\n+\n+            if (Character.isJavaLetter(ch) != expected) {\n+                throw new RuntimeException(\n+                        \"Character.isJavaLetter(ch) failed for codepoint \"\n+                                + Integer.toHexString(i));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaLetterOrDigit(char ch),\n+     * A character may be part of a Java identifier if and only if any of the\n+     * following are true:\n+     * <ul>\n+     * <li>it is a letter\n+     * <li>it is a currency symbol (such as '$')\n+     * <li>it is a connecting punctuation character (such as '_')\n+     * <li>it is a digit\n+     * <li>it is a numeric letter (such as a Roman numeral character)\n+     * <li>it is a combining mark\n+     * <li>it is a non-spacing mark\n+     * <li>isIdentifierIgnorable returns true for the character.\n+     * <\/ul>\n+     * All Unicode code points in the BMP (0x0000..0xFFFF) are tested.\n+     *\/\n+    public static void testIsJavaLetterOrDigit() {\n+        for (int i = 0; i <= Character.MAX_VALUE; ++i) {\n+            char ch = (char) i;\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaLetterOrDigit(char) strictly conforms to\n+            \/\/ character information from version 10.0 of the Unicode Standard,\n+            \/\/ check if code point is either a Japanese Era Square character\n+            \/\/ code point or one of the GB18030-2022 code points > Unicode 10.0.\n+            \/\/ If the code point is either a Japanese Era Square character code\n+            \/\/ point or one of the GB18030-2022 code points > Unicode 10.0,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (i != JAPANESE_ERA_CODEPOINT &&\n+                    !(i >= GB18030_2022_CODEPOINT_START && i <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(ch);\n+                expected = Character.isLetter(ch)\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION\n+                        || Character.isDigit(ch)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.COMBINING_SPACING_MARK\n+                        || type == Character.NON_SPACING_MARK\n+                        || Character.isIdentifierIgnorable(ch);\n+            }\n+\n+            if (Character.isJavaLetterOrDigit(ch) != expected) {\n+                throw new RuntimeException(\n+                        \"Character.isJavaLetterOrDigit(ch) failed for codepoint \"\n+                                + Integer.toHexString(i));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Character\/TestIsJavaIdentifierMethods.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -11732,0 +11732,1 @@\n+32FF;SQUARE ERA NAME NEWERA;So;0;L;<square> 5143 53F7;;;;N;SQUARED TWO IDEOGRAPHS ERA NAME NEWERA;;;;\n@@ -12055,1 +12056,1 @@\n-9FEA;<CJK Ideograph, Last>;Lo;0;L;;;;;N;;;;;\n+9FEF;<CJK Ideograph, Last>;Lo;0;L;;;;;N;;;;;\n","filename":"test\/jdk\/java\/lang\/Character\/UnicodeData.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"filename":"test\/jdk\/java\/lang\/Character\/charprop00.bin","binary":true,"status":"modified"}]}