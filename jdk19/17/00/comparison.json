{"files":[{"patch":"@@ -1166,1 +1166,1 @@\n-instruct vnotI_masked(vReg dst, vReg src, immI_M1 m1, pRegGov pg) %{\n+instruct vnotI_masked(vReg dst_src, immI_M1 m1, pRegGov pg) %{\n@@ -1168,3 +1168,3 @@\n-  match(Set dst (XorV (Binary src (ReplicateB m1)) pg));\n-  match(Set dst (XorV (Binary src (ReplicateS m1)) pg));\n-  match(Set dst (XorV (Binary src (ReplicateI m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));\n@@ -1172,1 +1172,1 @@\n-  format %{ \"sve_not $dst, $pg, $src\\t# vector (sve) B\/H\/S\" %}\n+  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) B\/H\/S\" %}\n@@ -1175,2 +1175,2 @@\n-    __ sve_not(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src$$reg));\n+    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n@@ -1181,1 +1181,1 @@\n-instruct vnotL_masked(vReg dst, vReg src, immL_M1 m1, pRegGov pg) %{\n+instruct vnotL_masked(vReg dst_src, immL_M1 m1, pRegGov pg) %{\n@@ -1183,1 +1183,1 @@\n-  match(Set dst (XorV (Binary src (ReplicateL m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));\n@@ -1185,1 +1185,1 @@\n-  format %{ \"sve_not $dst, $pg, $src\\t# vector (sve) D\" %}\n+  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) D\" %}\n@@ -1188,2 +1188,2 @@\n-    __ sve_not(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src$$reg));\n+    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n@@ -5257,1 +5257,1 @@\n-instruct gatherL(vReg dst, indirect mem, vReg idx) %{\n+instruct gatherL(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n@@ -5263,0 +5263,1 @@\n+  effect(TEMP tmp);\n@@ -5266,1 +5267,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -5268,1 +5269,1 @@\n-                       as_FloatRegister($idx$$reg));\n+                       as_FloatRegister($tmp$$reg));\n@@ -5292,1 +5293,1 @@\n-instruct gatherL_partial(vReg dst, indirect mem, vReg idx, pRegGov ptmp, rFlagsReg cr) %{\n+instruct gatherL_partial(vReg dst, indirect mem, vReg idx, vReg vtmp, pRegGov ptmp, rFlagsReg cr) %{\n@@ -5298,1 +5299,1 @@\n-  effect(TEMP ptmp, KILL cr);\n+  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -5303,1 +5304,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($vtmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -5305,1 +5306,1 @@\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                       as_Register($mem$$base), as_FloatRegister($vtmp$$reg));\n@@ -5326,1 +5327,1 @@\n-instruct gatherL_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+instruct gatherL_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n@@ -5331,0 +5332,1 @@\n+  effect(TEMP tmp);\n@@ -5334,1 +5336,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -5336,1 +5338,1 @@\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                       as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n@@ -5358,1 +5360,1 @@\n-instruct scatterL(indirect mem, vReg src, vReg idx) %{\n+instruct scatterL(indirect mem, vReg src, vReg idx, vReg tmp) %{\n@@ -5364,0 +5366,1 @@\n+  effect(TEMP tmp);\n@@ -5367,1 +5370,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -5369,1 +5372,1 @@\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n@@ -5393,1 +5396,1 @@\n-instruct scatterL_partial(indirect mem, vReg src, vReg idx, pRegGov ptmp, rFlagsReg cr) %{\n+instruct scatterL_partial(indirect mem, vReg src, vReg idx, vReg vtmp, pRegGov ptmp, rFlagsReg cr) %{\n@@ -5399,1 +5402,1 @@\n-  effect(TEMP ptmp, KILL cr);\n+  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -5404,1 +5407,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($vtmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -5406,1 +5409,1 @@\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                        as_Register($mem$$base), as_FloatRegister($vtmp$$reg));\n@@ -5427,1 +5430,1 @@\n-instruct scatterL_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n+instruct scatterL_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n@@ -5432,0 +5435,1 @@\n+  effect(TEMP tmp);\n@@ -5435,1 +5439,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -5437,1 +5441,1 @@\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":36,"deletions":32,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -660,4 +660,4 @@\n-`match(Set dst (XorV (Binary src (ReplicateB m1)) pg));\n-  match(Set dst (XorV (Binary src (ReplicateS m1)) pg));\n-  match(Set dst (XorV (Binary src (ReplicateI m1)) pg));',\n-`match(Set dst (XorV (Binary src (ReplicateL m1)) pg));')')dnl\n+`match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));',\n+`match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));')')dnl\n@@ -666,1 +666,1 @@\n-instruct vnot$1_masked`'(vReg dst, vReg src, imm$1_M1 m1, pRegGov pg) %{\n+instruct vnot$1_masked`'(vReg dst_src, imm$1_M1 m1, pRegGov pg) %{\n@@ -670,1 +670,1 @@\n-  format %{ \"sve_not $dst, $pg, $src\\t# vector (sve) $2\" %}\n+  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) $2\" %}\n@@ -673,2 +673,2 @@\n-    __ sve_not(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src$$reg));\n+    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n@@ -2827,1 +2827,1 @@\n-instruct gatherL(vReg dst, indirect mem, vReg idx) %{\n+instruct gatherL(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n@@ -2833,0 +2833,1 @@\n+  effect(TEMP tmp);\n@@ -2836,1 +2837,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -2838,1 +2839,1 @@\n-                       as_FloatRegister($idx$$reg));\n+                       as_FloatRegister($tmp$$reg));\n@@ -2862,1 +2863,1 @@\n-instruct gatherL_partial(vReg dst, indirect mem, vReg idx, pRegGov ptmp, rFlagsReg cr) %{\n+instruct gatherL_partial(vReg dst, indirect mem, vReg idx, vReg vtmp, pRegGov ptmp, rFlagsReg cr) %{\n@@ -2868,1 +2869,1 @@\n-  effect(TEMP ptmp, KILL cr);\n+  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -2873,1 +2874,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($vtmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -2875,1 +2876,1 @@\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                       as_Register($mem$$base), as_FloatRegister($vtmp$$reg));\n@@ -2896,1 +2897,1 @@\n-instruct gatherL_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+instruct gatherL_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n@@ -2901,0 +2902,1 @@\n+  effect(TEMP tmp);\n@@ -2904,1 +2906,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -2906,1 +2908,1 @@\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                       as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n@@ -2928,1 +2930,1 @@\n-instruct scatterL(indirect mem, vReg src, vReg idx) %{\n+instruct scatterL(indirect mem, vReg src, vReg idx, vReg tmp) %{\n@@ -2934,0 +2936,1 @@\n+  effect(TEMP tmp);\n@@ -2937,1 +2940,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -2939,1 +2942,1 @@\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n@@ -2963,1 +2966,1 @@\n-instruct scatterL_partial(indirect mem, vReg src, vReg idx, pRegGov ptmp, rFlagsReg cr) %{\n+instruct scatterL_partial(indirect mem, vReg src, vReg idx, vReg vtmp, pRegGov ptmp, rFlagsReg cr) %{\n@@ -2969,1 +2972,1 @@\n-  effect(TEMP ptmp, KILL cr);\n+  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -2974,1 +2977,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($vtmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -2976,1 +2979,1 @@\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                        as_Register($mem$$base), as_FloatRegister($vtmp$$reg));\n@@ -2997,1 +3000,1 @@\n-instruct scatterL_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n+instruct scatterL_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n@@ -3002,0 +3005,1 @@\n+  effect(TEMP tmp);\n@@ -3005,1 +3009,1 @@\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n@@ -3007,1 +3011,1 @@\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8288397\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @requires vm.cpu.features ~= \".*sve.*\"\n+ * @summary AArch64: Fix register issues in SVE backend match rules\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorGatherScatterTest\n+ *\/\n+\n+public class VectorGatherScatterTest {\n+    private static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES =\n+        VectorSpecies.of(int.class, VectorShape.forBitSize(L_SPECIES.vectorBitSize() \/ 2));\n+\n+    private static int LENGTH = 128;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static int[] ia;\n+    private static int[] ir;\n+    private static long[] la;\n+    private static long[] lr;\n+    private static double[] da;\n+    private static double[] dr;\n+    private static boolean[] m;\n+\n+    static {\n+        ia = new int[LENGTH];\n+        ir = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lr = new long[LENGTH];\n+        da = new double[LENGTH];\n+        dr = new double[LENGTH];\n+        m = new boolean[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = i;\n+            la[i] = RD.nextLong(25);\n+            da[i] = RD.nextDouble(25.0);\n+            m[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { \"LoadVectorGather\", \">= 1\" })\n+    public static void testLoadGather() {\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0, ia, 0);\n+        av.intoArray(lr, 0);\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ia, 0);\n+        bv.add(0).intoArray(ir, 0);\n+\n+        for(int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals(ia[i], ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { \"LoadVectorGatherMasked\", \">= 1\" })\n+    public static void testLoadGatherMasked() {\n+        VectorMask<Long> mask = VectorMask.fromArray(L_SPECIES, m, 0);\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0, ia, 0, mask);\n+        av.intoArray(lr, 0);\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ia, 0);\n+        bv.add(0).intoArray(ir, 0);\n+\n+        for(int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals(ia[i], ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { \"StoreVectorScatter\", \">= 1\" })\n+    public static void testStoreScatter() {\n+        DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, 0);\n+        av.intoArray(dr, 0, ia, 0);\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ia, 0);\n+        bv.add(0).intoArray(ir, 0);\n+\n+        for(int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals(ia[i], ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { \"StoreVectorScatterMasked\", \">= 1\" })\n+    public static void testStoreScatterMasked() {\n+        VectorMask<Double> mask = VectorMask.fromArray(D_SPECIES, m, 0);\n+        DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, 0);\n+        av.intoArray(dr, 0, ia, 0, mask);\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ia, 0);\n+        bv.add(0).intoArray(ir, 0);\n+\n+        for(int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals(ia[i], ir[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\",\n+                                   \"-XX:UseSVE=1\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherScatterTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8288397\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @requires vm.cpu.features ~= \".*sve.*\"\n+ * @summary AArch64: Fix register issues in SVE backend match rules\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorMaskedNotTest\n+ *\/\n+\n+public class VectorMaskedNotTest {\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+\n+    private static int LENGTH = 128;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static int[] ia;\n+    private static int[] ir;\n+    private static long[] la;\n+    private static long[] lr;\n+    private static boolean[] m;\n+\n+    static {\n+        ia = new int[LENGTH];\n+        ir = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lr = new long[LENGTH];\n+        m = new boolean[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = RD.nextInt(25);\n+            la[i] = RD.nextLong(25);\n+            m[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { \"sve_not\", \">= 1\" })\n+    public static void testIntNotMasked() {\n+        VectorMask<Integer> mask = VectorMask.fromArray(I_SPECIES, m, 0);\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        av.lanewise(VectorOperators.NOT, mask).add(av).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((~ia[i]) + ia[i], ir[i]);\n+            } else {\n+                Asserts.assertEquals(ia[i] + ia[i], ir[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { \"sve_not\", \">= 1\" })\n+    public static void testLongNotMasked() {\n+        VectorMask<Long> mask = VectorMask.fromArray(L_SPECIES, m, 0);\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        av.lanewise(VectorOperators.NOT, mask).add(av).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((~la[i]) + la[i], lr[i]);\n+            } else {\n+                Asserts.assertEquals(la[i] + la[i], lr[i]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\",\n+                                   \"-XX:UseSVE=1\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskedNotTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}