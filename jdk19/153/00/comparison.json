{"files":[{"patch":"@@ -1728,1 +1728,3 @@\n-    if (is_predicated_vector() && in(1)->is_predicated_vector() && in(2) == in(1)->in(2)) {\n+    if (is_predicated_vector() ^ in(1)->is_predicated_vector()) {\n+      return this;\n+    } else if (is_predicated_vector() && in(1)->is_predicated_vector() && in(2) == in(1)->in(2)) {\n@@ -1744,1 +1746,3 @@\n-    if (is_predicated_vector() && in(1)->is_predicated_vector() && in(2) == in(1)->in(2)) {\n+    if (is_predicated_vector() ^ in(1)->is_predicated_vector()) {\n+      return this;\n+    } else if (is_predicated_vector() && in(1)->is_predicated_vector() && in(2) == in(1)->in(2)) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8287794\n+ * @summary Test various reverse bytes ideal transforms(AVX2+).\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.TestReverseByteTransforms\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8287794\n+ * @summary Test various reverse bytes ideal transforms(SVE).\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*sve.*\"\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.TestReverseByteTransforms\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8287794\n+ * @summary Test various reverse bytes ideal transforms(NEON).\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*simd.*\"\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.TestReverseByteTransforms\n+ *\/\n+public class TestReverseByteTransforms {\n+    static final VectorSpecies<Long> LSPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> ISPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> SSPECIES = ShortVector.SPECIES_MAX;\n+\n+    static final int SIZE = 1024;\n+    static final int ITERS = 50000;\n+\n+    static long [] lout = new long[SIZE];\n+    static long [] linp = new long[SIZE];\n+\n+    static int [] iout = new int[SIZE];\n+    static int [] iinp = new int[SIZE];\n+\n+    static short [] sout = new short[SIZE];\n+    static short [] sinp = new short[SIZE];\n+\n+    static void init() {\n+        Random r = new Random(1024);\n+        for(int i = 0; i < SIZE; i++) {\n+            linp[i] = r.nextLong();\n+            iinp[i] = r.nextInt();\n+            sinp[i] = (short)r.nextInt();\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        init();\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"--add-modules=jdk.incubator.vector\");\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    @Test\n+    @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_long_transform1(long[] lout, long[] linp) {\n+        VectorMask<Long> mask = VectorMask.fromLong(LSPECIES, 3);\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform1(lout, linp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_long_transform2(long[] lout, long[] linp) {\n+        VectorMask<Long> mask1 = VectorMask.fromLong(LSPECIES, 3);\n+        VectorMask<Long> mask2 = VectorMask.fromLong(LSPECIES, 3);\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform2\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform2() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform2(lout, linp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_long_transform3(long[] lout, long[] linp) {\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform3\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform3() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform3(lout, linp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_int_transform1(int[] iout, int[] iinp) {\n+        VectorMask<Integer> mask = VectorMask.fromLong(ISPECIES, 3);\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform1(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_int_transform2(int[] iout, int[] iinp) {\n+        VectorMask<Integer> mask1 = VectorMask.fromLong(ISPECIES, 3);\n+        VectorMask<Integer> mask2 = VectorMask.fromLong(ISPECIES, 3);\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform2\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform2() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform2(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_int_transform3(int[] iout, int[] iinp) {\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform3\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform3() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform3(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_short_transform1(short[] sout, short[] sinp) {\n+        VectorMask<Short> mask = VectorMask.fromLong(SSPECIES, 3);\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform1(sout, sinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_short_transform2(short[] sout, short[] sinp) {\n+        VectorMask<Short> mask1 = VectorMask.fromLong(SSPECIES, 3);\n+        VectorMask<Short> mask2 = VectorMask.fromLong(SSPECIES, 3);\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask1)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask2)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform2\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform2() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform2(sout, sinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_short_transform3(short[] sout, short[] sinp) {\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .lanewise(VectorOperators.REVERSE_BYTES)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform3\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform3() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform3(sout, sinp);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransforms.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8287794\n+ * @summary Test various reverse bytes ideal transforms for targets which support direct predicated instruction.\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*sve.*\"\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run main compiler.vectorapi.TestReverseByteTransformsSVE\n+ *\/\n+\n+public class TestReverseByteTransformsSVE {\n+    static final VectorSpecies<Long> LSPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> ISPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> SSPECIES = ShortVector.SPECIES_MAX;\n+\n+    static final int SIZE = 1024;\n+    static final int ITERS = 50000;\n+\n+    static long [] lout = new long[SIZE];\n+    static long [] linp = new long[SIZE];\n+\n+    static int [] iout = new int[SIZE];\n+    static int [] iinp = new int[SIZE];\n+\n+    static short [] sout = new short[SIZE];\n+    static short [] sinp = new short[SIZE];\n+\n+    static void init() {\n+        Random r = new Random(1024);\n+        for(int i = 0; i < SIZE; i++) {\n+            linp[i] = r.nextLong();\n+            iinp[i] = r.nextInt();\n+            sinp[i] = (short)r.nextInt();\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        init();\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"--add-modules=jdk.incubator.vector\");\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_long_transform1(long[] lout, long[] linp) {\n+        VectorMask<Long> mask = VectorMask.fromLong(LSPECIES, 3);\n+        for (int i = 0; i < LSPECIES.loopBound(linp.length); i+=LSPECIES.length()) {\n+            LongVector.fromArray(LSPECIES, linp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(lout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_long_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_long_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_long_transform1(lout, linp);\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_int_transform1(int[] iout, int[] iinp) {\n+        VectorMask<Integer> mask = VectorMask.fromLong(ISPECIES, 3);\n+        for (int i = 0; i < ISPECIES.loopBound(iinp.length); i+=ISPECIES.length()) {\n+            IntVector.fromArray(ISPECIES, iinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(iout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_int_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_int_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_int_transform1(iout, iinp);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"ReverseBytesV\" , \" > 0 \"})\n+    public void test_reversebytes_short_transform1(short[] sout, short[] sinp) {\n+        VectorMask<Short> mask = VectorMask.fromLong(SSPECIES, 3);\n+        for (int i = 0; i < SSPECIES.loopBound(sinp.length); i+=SSPECIES.length()) {\n+            ShortVector.fromArray(SSPECIES, sinp, i)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .lanewise(VectorOperators.REVERSE_BYTES, mask)\n+                     .intoArray(sout, i);\n+        }\n+    }\n+\n+    @Run(test = {\"test_reversebytes_short_transform1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_reversebytes_short_transform1() {\n+        for (int i = 0; i < ITERS; i++) {\n+            test_reversebytes_short_transform1(sout, sinp);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransformsSVE.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}