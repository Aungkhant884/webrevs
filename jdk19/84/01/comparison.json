{"files":[{"patch":"@@ -1697,3 +1697,1 @@\n-            Set<Object> labels = new HashSet<>(); \/\/ The set of case labels.\n-            List<Type> coveredTypesForPatterns = List.nil();\n-            List<Type> coveredTypesForConstants = List.nil();\n+            Set<Object> constants = new HashSet<>(); \/\/ The set of case constants.\n@@ -1735,1 +1733,1 @@\n-                            } else if (!labels.add(sym)) {\n+                            } else if (!constants.add(sym)) {\n@@ -1737,2 +1735,0 @@\n-                            } else {\n-                                checkCaseLabelDominated(label.pos(), coveredTypesForConstants, sym.type);\n@@ -1768,1 +1764,1 @@\n-                                } else if (!labels.add(pattype.constValue())) {\n+                                } else if (!constants.add(pattype.constValue())) {\n@@ -1770,2 +1766,0 @@\n-                                } else {\n-                                    checkCaseLabelDominated(label.pos(), coveredTypesForConstants, types.boxedTypeOrType(pattype));\n@@ -1823,7 +1817,0 @@\n-                        checkCaseLabelDominated(pat.pos(), coveredTypesForPatterns, patternType);\n-                        if (!patternType.isErroneous()) {\n-                            coveredTypesForConstants = coveredTypesForConstants.prepend(patternType);\n-                            if (unguarded) {\n-                                coveredTypesForPatterns = coveredTypesForPatterns.prepend(patternType);\n-                            }\n-                        }\n@@ -1853,0 +1840,1 @@\n+                chk.checkSwitchCaseLabelDominated(cases);\n@@ -1878,8 +1866,0 @@\n-        private void checkCaseLabelDominated(DiagnosticPosition pos,\n-                                             List<Type> coveredTypes, Type patternType) {\n-            for (Type existing : coveredTypes) {\n-                if (types.isSubtype(patternType, existing)) {\n-                    log.error(pos, Errors.PatternDominated);\n-                }\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4376,0 +4376,89 @@\n+    void checkSwitchCaseLabelDominated(List<JCCase> cases) {\n+        List<JCCaseLabel> caseLabels = List.nil();\n+        for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+            JCCase c = l.head;\n+            for (JCCaseLabel label : c.labels) {\n+                if (label.hasTag(DEFAULTCASELABEL) || TreeInfo.isNullCaseLabel(label)) {\n+                    continue;\n+                }\n+                Type currentType = labelType(label);\n+                for (JCCaseLabel testCaseLabel : caseLabels) {\n+                    Type testType = labelType(testCaseLabel);\n+                    if (types.isSubtype(currentType, testType) &&\n+                        !currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n+                        \/\/the current label is potentially dominated by the existing (test) label, check:\n+                        boolean dominated = false;\n+                        if (label instanceof JCConstantCaseLabel) {\n+                            dominated |= !(testCaseLabel instanceof JCConstantCaseLabel);\n+                        } else if (label instanceof JCPatternCaseLabel patternCL &&\n+                                   testCaseLabel instanceof JCPatternCaseLabel testPatternCaseLabel &&\n+                                   TreeInfo.unguardedCaseLabel(testCaseLabel)) {\n+                            dominated = patternDominated(testPatternCaseLabel.pat,\n+                                                         patternCL.pat);\n+                        }\n+                        if (dominated) {\n+                            log.error(label.pos(), Errors.PatternDominated);\n+                        }\n+                    }\n+                }\n+                caseLabels = caseLabels.prepend(label);\n+            }\n+        }\n+    }\n+        \/\/where:\n+        private Type labelType(JCCaseLabel label) {\n+            return types.erasure(switch (label.getTag()) {\n+                case PATTERNCASELABEL -> ((JCPatternCaseLabel) label).pat.type;\n+                case CONSTANTCASELABEL -> types.boxedTypeOrType(((JCConstantCaseLabel) label).expr.type);\n+                default -> throw Assert.error(\"Unexpected tree kind: \" + label.getTag());\n+            });\n+        }\n+        private boolean patternDominated(JCPattern existingPattern, JCPattern currentPattern) {\n+            Type existingPatternType = types.erasure(existingPattern.type);\n+            Type currentPatternType = types.erasure(currentPattern.type);\n+            if (existingPatternType.isPrimitive() ^ currentPatternType.isPrimitive()) {\n+                return false;\n+            }\n+            if (existingPatternType.isPrimitive()) {\n+                if (!types.isSameType(existingPatternType, currentPatternType)) {\n+                    return false;\n+                }\n+            } else {\n+                if (!types.isSubtype(currentPatternType, existingPatternType)) {\n+                    return false;\n+                }\n+            }\n+            while (existingPattern instanceof JCParenthesizedPattern parenthesized) {\n+                existingPattern = parenthesized.pattern;\n+            }\n+            while (currentPattern instanceof JCParenthesizedPattern parenthesized) {\n+                currentPattern = parenthesized.pattern;\n+            }\n+            if (currentPattern instanceof JCBindingPattern) {\n+                return existingPattern instanceof JCBindingPattern;\n+            } else if (currentPattern instanceof JCRecordPattern currentRecordPattern) {\n+                if (existingPattern instanceof JCBindingPattern) {\n+                    return true;\n+                } else if (existingPattern instanceof JCRecordPattern existingRecordPattern) {\n+                    List<JCPattern> existingNested = existingRecordPattern.nested;\n+                    List<JCPattern> currentNested = currentRecordPattern.nested;\n+                    if (existingNested.size() != currentNested.size()) {\n+                        return false;\n+                    }\n+                    while (existingNested.nonEmpty()) {\n+                        if (!patternDominated(existingNested.head, currentNested.head)) {\n+                            return false;\n+                        }\n+                        existingNested = existingNested.tail;\n+                        currentNested = currentNested.tail;\n+                    }\n+                    return true;\n+                } else {\n+                    Assert.error(\"Unknown pattern: \" + existingPattern.getTag());\n+                }\n+            } else {\n+                Assert.error(\"Unknown pattern: \" + currentPattern.getTag());\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -139,0 +139,75 @@\n+    int testRecordPatternsDominated1() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R r: return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated2() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R(int a): return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated3() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R r when guard(): return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated4() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R(int a) when guard(): return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    boolean guard() {\n+        return false;\n+    }\n+\n+    int testRecordPatternsDominated5() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case ((R r)): return 1;\n+            case ((R(int a))): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated6() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case ((R(int a))): return 1;\n+            case ((R(int a))): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated7() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R r when true: return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n+\n+    int testRecordPatternsDominated8() {\n+        record R(int a) {}\n+        Object o = null;\n+        switch (o) {\n+            case R(int a) when true: return 1;\n+            case R(int a): return -1;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -13,0 +13,6 @@\n+Domination.java:144:18: compiler.err.pattern.dominated\n+Domination.java:153:18: compiler.err.pattern.dominated\n+Domination.java:184:18: compiler.err.pattern.dominated\n+Domination.java:193:18: compiler.err.pattern.dominated\n+Domination.java:202:18: compiler.err.pattern.dominated\n+Domination.java:211:18: compiler.err.pattern.dominated\n@@ -15,1 +21,1 @@\n-12 errors\n+18 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-SwitchErrors.java:200:44: compiler.err.pattern.dominated\n+SwitchErrors.java:200:44: compiler.err.flows.through.from.pattern\n@@ -39,1 +39,1 @@\n-SwitchErrors.java:232:44: compiler.err.pattern.dominated\n+SwitchErrors.java:232:44: compiler.err.flows.through.from.pattern\n@@ -58,1 +58,1 @@\n-55 errors\n+55 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}