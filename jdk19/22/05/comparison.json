{"files":[{"patch":"@@ -40,1 +40,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -774,5 +773,1 @@\n-            try {\n-                session.checkValidState();\n-            } catch (ScopedMemoryAccess.ScopedAccessError e) {\n-                throw new IllegalStateException(\"This segment is already closed\");\n-            }\n+            session.checkValidState();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -316,5 +316,1 @@\n-            try {\n-                session.checkValidState();\n-            } catch (ScopedAccessError e) {\n-                throw new IllegalStateException(\"This segment is already closed\");\n-            }\n+            session.checkValidState();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-    static final int READ_ONLY = 1;\n@@ -76,2 +75,0 @@\n-    static final int DEFAULT_MODES = 0;\n-\n@@ -81,1 +78,1 @@\n-    final int mask;\n+    final boolean readOnly;\n@@ -85,1 +82,1 @@\n-    AbstractMemorySegmentImpl(long length, int mask, MemorySession session) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySession session) {\n@@ -87,1 +84,1 @@\n-        this.mask = mask;\n+        this.readOnly = readOnly;\n@@ -91,5 +88,1 @@\n-    abstract long min();\n-\n-    abstract Object base();\n-\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n@@ -101,1 +94,1 @@\n-        return dup(0, length, mask | READ_ONLY, session);\n+        return dup(0, length, true, session);\n@@ -106,1 +99,1 @@\n-        return isSet(READ_ONLY);\n+        return readOnly;\n@@ -122,1 +115,1 @@\n-        return dup(offset, newSize, mask, session);\n+        return dup(offset, newSize, readOnly, session);\n@@ -150,1 +143,1 @@\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), base(), min(), length, value);\n+        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n@@ -179,2 +172,2 @@\n-                    this.base(), this.min(),\n-                    that.base(), that.min(),\n+                    this.unsafeGetBase(), this.unsafeGetOffset(),\n+                    that.unsafeGetBase(), that.unsafeGetOffset(),\n@@ -238,1 +231,1 @@\n-        if (isSet(READ_ONLY)) {\n+        if (readOnly) {\n@@ -263,3 +256,3 @@\n-        if (base() == that.base()) {  \/\/ both either native or heap\n-            final long thisStart = this.min();\n-            final long thatStart = that.min();\n+        if (unsafeGetBase() == that.unsafeGetBase()) {  \/\/ both either native or heap\n+            final long thisStart = this.unsafeGetOffset();\n+            final long thatStart = that.unsafeGetOffset();\n@@ -281,2 +274,2 @@\n-        if (base() == that.base()) {\n-            return that.min() - this.min();\n+        if (unsafeGetBase() == that.unsafeGetBase()) {\n+            return that.unsafeGetOffset() - this.unsafeGetOffset();\n@@ -350,0 +343,1 @@\n+    @ForceInline\n@@ -351,1 +345,1 @@\n-        if (!readOnly && isSet(READ_ONLY)) {\n+        if (!readOnly && this.readOnly) {\n@@ -358,1 +352,1 @@\n-        sessionImpl().checkValidStateSlow();\n+        sessionImpl().checkValidState();\n@@ -361,3 +355,1 @@\n-    public long unsafeGetOffset() {\n-        return min();\n-    }\n+    public abstract long unsafeGetOffset();\n@@ -365,3 +357,1 @@\n-    public Object unsafeGetBase() {\n-        return base();\n-    }\n+    public abstract Object unsafeGetBase();\n@@ -371,4 +361,0 @@\n-    private boolean isSet(int mask) {\n-        return (this.mask & mask) != 0;\n-    }\n-\n@@ -410,6 +396,0 @@\n-    @Override\n-    @ForceInline\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session);\n-    }\n-\n@@ -422,1 +402,1 @@\n-        return new IndexOutOfBoundsException(String.format(\"Out of bound access on segment %s; offset = %d; length = %d\",\n+        return new IndexOutOfBoundsException(String.format(\"Out of bound access on segment %s; new offset = %d; new length = %d\",\n@@ -428,1 +408,1 @@\n-        return Math.abs(Objects.hash(base(), min(), NONCE));\n+        return Math.abs(Objects.hash(unsafeGetBase(), unsafeGetOffset(), NONCE));\n@@ -544,2 +524,1 @@\n-        final MemorySessionImpl bufferSession;\n-        int modes;\n+        final MemorySession bufferSession;\n@@ -547,2 +526,1 @@\n-            bufferSession = bufferSegment.sessionImpl();\n-            modes = bufferSegment.mask;\n+            bufferSession = bufferSegment.session;\n@@ -551,4 +529,0 @@\n-            modes = DEFAULT_MODES;\n-        }\n-        if (bb.isReadOnly()) {\n-            modes |= READ_ONLY;\n@@ -556,0 +530,1 @@\n+        boolean readOnly = bb.isReadOnly();\n@@ -559,1 +534,1 @@\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -561,1 +536,1 @@\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -563,1 +538,1 @@\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -565,1 +540,1 @@\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -567,1 +542,1 @@\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -569,1 +544,1 @@\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -571,1 +546,1 @@\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -576,1 +551,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, modes, bufferSession);\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferSession);\n@@ -579,1 +554,1 @@\n-            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferSession);\n+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferSession);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":35,"deletions":60,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -58,5 +58,0 @@\n-    @Override\n-    public boolean isAlive() {\n-        return state != CLOSED;\n-    }\n-\n@@ -66,1 +61,1 @@\n-        checkValidStateSlow();\n+        checkValidState();\n@@ -68,1 +63,1 @@\n-            throw new IllegalStateException(\"Session keep alive limit exceeded\");\n+            throw tooManyAcquires();\n@@ -88,1 +83,1 @@\n-        checkValidStateSlow();\n+        checkValidState();\n@@ -92,1 +87,1 @@\n-            throw new IllegalStateException(\"Session is acquired by \" + state + \" clients\");\n+            throw alreadyAcquired(state);\n@@ -106,1 +101,1 @@\n-                throw new IllegalStateException(\"Already closed!\");\n+                throw alreadyClosed();\n@@ -117,1 +112,1 @@\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+                throw alreadyClosed();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * {@link HeapMemorySegmentImpl#base()} method so that it returns an array of the correct (sharp) type. Note that\n+ * {@link HeapMemorySegmentImpl#unsafeGetBase()} method so that it returns an array of the correct (sharp) type. Note that\n@@ -63,2 +63,2 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, int mask) {\n-        super(length, mask, MemorySessionImpl.GLOBAL);\n+    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly) {\n+        super(length, readOnly, MemorySessionImpl.GLOBAL);\n@@ -70,4 +70,1 @@\n-    abstract Object base();\n-\n-    @Override\n-    long min() {\n+    public long unsafeGetOffset() {\n@@ -78,1 +75,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n@@ -82,1 +79,1 @@\n-        if (!(base() instanceof byte[])) {\n+        if (!(base instanceof byte[])) {\n@@ -86,1 +83,1 @@\n-        return nioAccess.newHeapByteBuffer((byte[]) base(), (int)min() - BYTE_ARR_BASE, (int) byteSize(), null);\n+        return nioAccess.newHeapByteBuffer((byte[])base, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n@@ -93,2 +90,2 @@\n-        OfByte(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfByte(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -98,2 +95,2 @@\n-        OfByte dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfByte(this.offset + offset, base, size, mask);\n+        OfByte dup(long offset, long size, boolean readOnly, MemorySession session) {\n+            return new OfByte(this.offset + offset, base, size, readOnly);\n@@ -103,1 +100,1 @@\n-        byte[] base() {\n+        public byte[] unsafeGetBase() {\n@@ -110,1 +107,1 @@\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false);\n@@ -121,2 +118,2 @@\n-        OfChar(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfChar(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -126,2 +123,2 @@\n-        OfChar dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfChar(this.offset + offset, base, size, mask);\n+        OfChar dup(long offset, long size, boolean readOnly, MemorySession session) {\n+            return new OfChar(this.offset + offset, base, size, readOnly);\n@@ -131,1 +128,1 @@\n-        char[] base() {\n+        public char[] unsafeGetBase() {\n@@ -138,1 +135,1 @@\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false);\n@@ -149,2 +146,2 @@\n-        OfShort(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfShort(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -154,2 +151,2 @@\n-        OfShort dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfShort(this.offset + offset, base, size, mask);\n+        OfShort dup(long offset, long size, boolean readOnly, MemorySession session) {\n+            return new OfShort(this.offset + offset, base, size, readOnly);\n@@ -159,1 +156,1 @@\n-        short[] base() {\n+        public short[] unsafeGetBase() {\n@@ -166,1 +163,1 @@\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false);\n@@ -177,2 +174,2 @@\n-        OfInt(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfInt(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -182,2 +179,2 @@\n-        OfInt dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfInt(this.offset + offset, base, size, mask);\n+        OfInt dup(long offset, long size, boolean readOnly, MemorySession session) {\n+            return new OfInt(this.offset + offset, base, size, readOnly);\n@@ -187,1 +184,1 @@\n-        int[] base() {\n+        public int[] unsafeGetBase() {\n@@ -194,1 +191,1 @@\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false);\n@@ -205,2 +202,2 @@\n-        OfLong(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfLong(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -210,2 +207,2 @@\n-        OfLong dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfLong(this.offset + offset, base, size, mask);\n+        OfLong dup(long offset, long size, boolean readOnly, MemorySession session) {\n+            return new OfLong(this.offset + offset, base, size, readOnly);\n@@ -215,1 +212,1 @@\n-        long[] base() {\n+        public long[] unsafeGetBase() {\n@@ -222,1 +219,1 @@\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false);\n@@ -233,2 +230,2 @@\n-        OfFloat(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfFloat(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -238,2 +235,2 @@\n-        OfFloat dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfFloat(this.offset + offset, base, size, mask);\n+        OfFloat dup(long offset, long size, boolean readOnly, MemorySession session) {\n+            return new OfFloat(this.offset + offset, base, size, readOnly);\n@@ -243,1 +240,1 @@\n-        float[] base() {\n+        public float[] unsafeGetBase() {\n@@ -250,1 +247,1 @@\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false);\n@@ -261,2 +258,2 @@\n-        OfDouble(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfDouble(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -266,2 +263,2 @@\n-        OfDouble dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfDouble(this.offset + offset, base, size, mask);\n+        OfDouble dup(long offset, long size, boolean readOnly, MemorySession session) {\n+            return new OfDouble(this.offset + offset, base, size, readOnly);\n@@ -271,1 +268,1 @@\n-        double[] base() {\n+        public double[] unsafeGetBase() {\n@@ -278,1 +275,1 @@\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":49,"deletions":52,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemorySession session) {\n-        super(min, length, mask, session);\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySession session) {\n+        super(min, length, readOnly, session);\n@@ -58,2 +58,2 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session) {\n-        return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, session);\n+    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, session);\n@@ -98,2 +98,2 @@\n-        public EmptyMappedMemorySegmentImpl(int modes, MemorySession session) {\n-            super(0, null, 0, modes, session);\n+        public EmptyMappedMemorySegmentImpl(boolean readOnly, MemorySessionImpl session) {\n+            super(0, null, 0, readOnly, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    public MemorySessionImpl sessionImpl() {\n+    public MemorySessionImpl session() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * to memory access (see {@link #checkValidState()}).\n+ * to memory access (see {@link #checkValidStateRaw()}).\n@@ -49,1 +49,1 @@\n- * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n+ * associated owner thread such as {@link #close()} or {@link #checkValidStateRaw()}.\n@@ -55,1 +55,1 @@\n-public abstract non-sealed class MemorySessionImpl implements Scoped, MemorySession, SegmentAllocator {\n+public abstract non-sealed class MemorySessionImpl implements MemorySession, SegmentAllocator {\n@@ -81,2 +81,1 @@\n-        addInternal(runnable instanceof ResourceList.ResourceCleanup cleanup ?\n-                cleanup : ResourceList.ResourceCleanup.ofRunnable(runnable));\n+        addInternal(ResourceList.ResourceCleanup.ofRunnable(runnable));\n@@ -105,1 +104,1 @@\n-        checkValidStateSlow();\n+        checkValidState();\n@@ -144,1 +143,1 @@\n-    public boolean equals(Object o) {\n+    public final boolean equals(Object o) {\n@@ -150,1 +149,1 @@\n-    public int hashCode() {\n+    public final int hashCode() {\n@@ -177,1 +176,3 @@\n-    public abstract boolean isAlive();\n+    public boolean isAlive() {\n+        return state >= OPEN;\n+    }\n@@ -185,0 +186,1 @@\n+    @ForceInline\n@@ -186,6 +188,2 @@\n-        return ((Scoped)session).sessionImpl();\n-    }\n-\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return this;\n+        return session instanceof MemorySessionImpl sessionImpl ?\n+                sessionImpl : ((NonCloseableView)session).session;\n@@ -195,1 +193,1 @@\n-     * This is a faster version of {@link #checkValidStateSlow()}, which is called upon memory access, and which\n+     * This is a faster version of {@link #checkValidState()}, which is called upon memory access, and which\n@@ -200,1 +198,1 @@\n-     * please use {@link #checkValidStateSlow()}.\n+     * please use {@link #checkValidState()}.\n@@ -203,1 +201,1 @@\n-    public final void checkValidState() {\n+    public void checkValidStateRaw() {\n@@ -205,1 +203,1 @@\n-            throw new WrongThreadException(\"Attempted access outside owning thread\");\n+            throw WRONG_THREAD;\n@@ -208,1 +206,1 @@\n-            throw ScopedMemoryAccess.ScopedAccessError.INSTANCE;\n+            throw ALREADY_CLOSED;\n@@ -217,5 +215,5 @@\n-    public final void checkValidStateSlow() {\n-        if (owner != null && Thread.currentThread() != owner) {\n-            throw new WrongThreadException(\"Attempted access outside owning thread\");\n-        } else if (!isAlive()) {\n-            throw new IllegalStateException(\"Already closed\");\n+    public void checkValidState() {\n+        try {\n+            checkValidStateRaw();\n+        } catch (ScopedMemoryAccess.ScopedAccessError error) {\n+            throw error.newRuntimeException();\n@@ -292,5 +290,0 @@\n-        @Override\n-        public boolean isAlive() {\n-            return true;\n-        }\n-\n@@ -299,1 +292,1 @@\n-            throw new UnsupportedOperationException();\n+            throw nonCloseable();\n@@ -338,10 +331,0 @@\n-        @Override\n-        public boolean isAlive() {\n-            return true;\n-        }\n-\n-        @Override\n-        public MemorySession asNonCloseable() {\n-            return this;\n-        }\n-\n@@ -350,1 +333,1 @@\n-            throw new UnsupportedOperationException();\n+            throw nonCloseable();\n@@ -361,1 +344,1 @@\n-    public final static class NonCloseableView implements MemorySession, Scoped {\n+    public final static class NonCloseableView implements MemorySession {\n@@ -368,4 +351,0 @@\n-        public MemorySessionImpl sessionImpl() {\n-            return session;\n-        }\n-\n@@ -464,0 +443,7 @@\n+    }\n+\n+    \/\/ helper functions to centralize error handling\n+\n+    static IllegalStateException tooManyAcquires() {\n+        return new IllegalStateException(\"Session acquire limit exceeded\");\n+    }\n@@ -465,0 +451,2 @@\n+    static IllegalStateException alreadyAcquired(int acquires) {\n+        return new IllegalStateException(String.format(\"Session is acquired by %d clients\", acquires));\n@@ -466,0 +454,16 @@\n+\n+    static IllegalStateException alreadyClosed() {\n+        return new IllegalStateException(\"Already closed\");\n+    }\n+\n+    static WrongThreadException wrongThread() {\n+        return new WrongThreadException(\"Attempted access outside owning thread\");\n+    }\n+\n+    static UnsupportedOperationException nonCloseable() {\n+        return new UnsupportedOperationException(\"Attempted to close a non-closeable session\");\n+    }\n+\n+    static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n+\n+    static final ScopedMemoryAccess.ScopedAccessError WRONG_THREAD = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::wrongThread);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":51,"deletions":47,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, 0, MemorySessionImpl.GLOBAL) {\n+    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, false, MemorySessionImpl.GLOBAL) {\n@@ -51,1 +51,1 @@\n-        NativeMemorySegmentImpl dup(long offset, long size, int mask, MemorySession scope) {\n+        NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n@@ -67,2 +67,2 @@\n-    NativeMemorySegmentImpl(long min, long length, int mask, MemorySession session) {\n-        super(length, mask, session);\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySession session) {\n+        super(length, readOnly, session);\n@@ -80,2 +80,2 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session) {\n-        return new NativeMemorySegmentImpl(min + offset, size, mask, session);\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        return new NativeMemorySegmentImpl(min + offset, size, readOnly, session);\n@@ -86,1 +86,1 @@\n-        return nioAccess.newDirectByteBuffer(min(), (int) this.length, null,\n+        return nioAccess.newDirectByteBuffer(min, (int) this.length, null,\n@@ -96,1 +96,1 @@\n-    long min() {\n+    public long unsafeGetOffset() {\n@@ -101,1 +101,1 @@\n-    Object base() {\n+    public Object unsafeGetBase() {\n@@ -114,1 +114,1 @@\n-        sessionImpl.checkValidStateSlow();\n+        sessionImpl.checkValidState();\n@@ -130,1 +130,1 @@\n-                DEFAULT_MODES, session);\n+                false, session);\n@@ -146,3 +146,2 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n-        sessionImpl.checkValidStateSlow();\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, DEFAULT_MODES, session);\n+        MemorySessionImpl.toSessionImpl(session).checkValidState();\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, false, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.MemorySession;\n+\n@@ -29,1 +33,5 @@\n-    MemorySessionImpl sessionImpl();\n+    @ForceInline\n+    default MemorySessionImpl sessionImpl() {\n+        return MemorySessionImpl.toSessionImpl(session());\n+    }\n+    MemorySession session();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                throw new IllegalStateException(\"Already closed\");\n+                throw alreadyClosed();\n@@ -62,1 +62,1 @@\n-                throw new IllegalStateException(\"Session acquire limit exceeded\");\n+                throw tooManyAcquires();\n@@ -75,1 +75,1 @@\n-                throw new IllegalStateException(\"Already closed\");\n+                throw alreadyClosed();\n@@ -83,1 +83,1 @@\n-            throw new IllegalStateException(\"Already closed\");\n+            throw alreadyClosed();\n@@ -85,1 +85,1 @@\n-            throw new IllegalStateException(\"Session is acquired by \" + prevState + \" clients\");\n+            throw alreadyAcquired(prevState);\n@@ -90,1 +90,1 @@\n-            throw new IllegalStateException(\"Session is acquired by 1 client\");\n+            throw alreadyAcquired(1);\n@@ -94,5 +94,0 @@\n-    @Override\n-    public boolean isAlive() {\n-        return (int) STATE.getVolatile(this) != CLOSED;\n-    }\n-\n@@ -120,1 +115,1 @@\n-                    throw new IllegalStateException(\"Already closed\");\n+                    throw alreadyClosed();\n@@ -147,1 +142,1 @@\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+                throw alreadyClosed();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -448,5 +448,0 @@\n-        @Override\n-        public MemorySessionImpl sessionImpl() {\n-            return MemorySessionImpl.GLOBAL;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        sessionImpl().checkValidState();\n@@ -353,5 +353,0 @@\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        sessionImpl().checkValidState();\n@@ -155,5 +155,0 @@\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n-    }\n-\n@@ -162,1 +157,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        sessionImpl().checkValidState();\n@@ -177,1 +172,1 @@\n-            MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n+            MemorySessionImpl.toSessionImpl(session).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        sessionImpl().checkValidState();\n@@ -307,5 +307,0 @@\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        sessionImpl().checkValidState();\n@@ -155,5 +155,0 @@\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n-    }\n-\n@@ -162,1 +157,1 @@\n-        MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n+        sessionImpl().checkValidState();\n@@ -177,1 +172,1 @@\n-            MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n+            MemorySessionImpl.toSessionImpl(session).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -14,1 +14,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -27,1 +27,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -35,1 +35,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -49,1 +49,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -57,1 +57,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -70,1 +70,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -78,1 +78,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -92,1 +92,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -100,1 +100,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -113,1 +113,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -121,1 +121,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -134,1 +134,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -142,1 +142,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -155,1 +155,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -163,1 +163,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -176,1 +176,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -184,1 +184,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -196,1 +196,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -204,1 +204,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -217,1 +217,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -225,1 +225,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -238,1 +238,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -246,1 +246,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -259,1 +259,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -267,1 +267,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -280,1 +280,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -288,1 +288,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -301,1 +301,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -309,1 +309,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -322,1 +322,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -330,1 +330,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -343,1 +343,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -351,1 +351,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -364,1 +364,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -372,1 +372,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -385,1 +385,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -393,1 +393,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -406,1 +406,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -414,1 +414,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -427,1 +427,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -435,1 +435,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -450,1 +450,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -458,1 +458,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -471,1 +471,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -479,1 +479,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -492,1 +492,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -500,1 +500,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -515,1 +515,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -523,1 +523,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -536,1 +536,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -544,1 +544,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -557,1 +557,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -565,1 +565,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -578,1 +578,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -586,1 +586,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -599,1 +599,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -607,1 +607,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -620,1 +620,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -628,1 +628,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -641,1 +641,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -649,1 +649,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -662,1 +662,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -670,1 +670,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -683,1 +683,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -691,1 +691,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Supplier;\n@@ -58,2 +59,2 @@\n- * region concurrently. More specifically, when a thread wants to release a memory region, it should call the\n- * {@link MemorySessionImpl#close()} method. This method initiates thread-local handshakes with all the other VM threads,\n+ * session concurrently. More specifically, when a thread wants to release a memory session, it should call the\n+ * {@link ScopedMemoryAccess#closeScope(MemorySessionImpl)} method. This method initiates thread-local handshakes with all the other VM threads,\n@@ -61,1 +62,1 @@\n- * being closed, the handshake fails, and the session cannot be closed.\n+ * being closed, the handshake fails, and the session will not be closed.\n@@ -100,2 +101,7 @@\n-        private ScopedAccessError() {\n-            super(\"Attempt to access an already released memory resource\", null, false, false);\n+\n+        @SuppressWarnings(\"serial\")\n+        private final Supplier<RuntimeException> runtimeExceptionSupplier;\n+\n+        public ScopedAccessError(Supplier<RuntimeException> runtimeExceptionSupplier) {\n+            super(\"Invalid memory access\", null, false, false);\n+            this.runtimeExceptionSupplier = runtimeExceptionSupplier;\n@@ -103,0 +109,1 @@\n+\n@@ -105,1 +112,3 @@\n-        public static final ScopedAccessError INSTANCE = new ScopedAccessError();\n+        public final RuntimeException newRuntimeException() {\n+            return runtimeExceptionSupplier.get();\n+        }\n@@ -115,1 +124,1 @@\n-    public void copyMemory(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    public void copyMemory(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n@@ -120,1 +129,1 @@\n-              copyMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes);\n+              copyMemoryInternal(srcSession, dstSession, srcBase, srcOffset, destBase, destOffset, bytes);\n@@ -122,1 +131,1 @@\n-              throw new IllegalStateException(\"This segment is already closed\");\n+              throw ex.newRuntimeException();\n@@ -127,1 +136,1 @@\n-    private void copyMemoryInternal(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    private void copyMemoryInternal(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n@@ -132,2 +141,2 @@\n-            if (srcScope != null) {\n-                srcScope.checkValidState();\n+            if (srcSession != null) {\n+                srcSession.checkValidStateRaw();\n@@ -135,2 +144,2 @@\n-            if (dstScope != null) {\n-                dstScope.checkValidState();\n+            if (dstSession != null) {\n+                dstSession.checkValidStateRaw();\n@@ -140,2 +149,2 @@\n-            Reference.reachabilityFence(srcScope);\n-            Reference.reachabilityFence(dstScope);\n+            Reference.reachabilityFence(srcSession);\n+            Reference.reachabilityFence(dstSession);\n@@ -146,1 +155,1 @@\n-    public void copySwapMemory(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    public void copySwapMemory(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n@@ -151,1 +160,1 @@\n-              copySwapMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n+              copySwapMemoryInternal(srcSession, dstSession, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n@@ -153,1 +162,1 @@\n-              throw new IllegalStateException(\"This segment is already closed\");\n+              throw ex.newRuntimeException();\n@@ -158,1 +167,1 @@\n-    private void copySwapMemoryInternal(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    private void copySwapMemoryInternal(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n@@ -163,2 +172,2 @@\n-            if (srcScope != null) {\n-                srcScope.checkValidState();\n+            if (srcSession != null) {\n+                srcSession.checkValidStateRaw();\n@@ -166,2 +175,2 @@\n-            if (dstScope != null) {\n-                dstScope.checkValidState();\n+            if (dstSession != null) {\n+                dstSession.checkValidStateRaw();\n@@ -171,2 +180,2 @@\n-            Reference.reachabilityFence(srcScope);\n-            Reference.reachabilityFence(dstScope);\n+            Reference.reachabilityFence(srcSession);\n+            Reference.reachabilityFence(dstSession);\n@@ -181,1 +190,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -189,1 +198,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -198,1 +207,1 @@\n-    public int vectorizedMismatch(MemorySessionImpl aScope, MemorySessionImpl bScope,\n+    public int vectorizedMismatch(MemorySessionImpl aSession, MemorySessionImpl bSession,\n@@ -204,1 +213,1 @@\n-            return vectorizedMismatchInternal(aScope, bScope, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n+            return vectorizedMismatchInternal(aSession, bSession, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n@@ -206,1 +215,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -211,1 +220,1 @@\n-    private int vectorizedMismatchInternal(MemorySessionImpl aScope, MemorySessionImpl bScope,\n+    private int vectorizedMismatchInternal(MemorySessionImpl aSession, MemorySessionImpl bSession,\n@@ -217,2 +226,2 @@\n-            if (aScope != null) {\n-                aScope.checkValidState();\n+            if (aSession != null) {\n+                aSession.checkValidStateRaw();\n@@ -220,2 +229,2 @@\n-            if (bScope != null) {\n-                bScope.checkValidState();\n+            if (bSession != null) {\n+                bSession.checkValidStateRaw();\n@@ -225,2 +234,2 @@\n-            Reference.reachabilityFence(aScope);\n-            Reference.reachabilityFence(bScope);\n+            Reference.reachabilityFence(aSession);\n+            Reference.reachabilityFence(bSession);\n@@ -235,1 +244,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -243,1 +252,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -256,1 +265,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -264,1 +273,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -277,1 +286,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -285,1 +294,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -298,1 +307,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -306,1 +315,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -336,1 +345,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -350,1 +359,1 @@\n-            session.checkValidState();\n+            session.checkValidStateRaw();\n@@ -381,1 +390,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -396,1 +405,1 @@\n-            session.checkValidState();\n+            session.checkValidStateRaw();\n@@ -427,1 +436,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -441,1 +450,1 @@\n-            session.checkValidState();\n+            session.checkValidStateRaw();\n@@ -473,1 +482,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -487,1 +496,1 @@\n-            session.checkValidState();\n+            session.checkValidStateRaw();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":63,"deletions":54,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -1202,3 +1202,0 @@\n-    private static final int MAP_MEM_SEG_DEFAULT_MODES = 0;\n-    private static final int MAP_MEM_SEG_READ_ONLY = 1;\n-\n@@ -1213,1 +1210,1 @@\n-        sessionImpl.checkValidStateSlow();\n+        sessionImpl.checkValidState();\n@@ -1222,1 +1219,1 @@\n-        int modes = MAP_MEM_SEG_DEFAULT_MODES;\n+        boolean readOnly = false;\n@@ -1224,1 +1221,1 @@\n-            modes |= MAP_MEM_SEG_READ_ONLY;\n+            readOnly = true;\n@@ -1229,1 +1226,1 @@\n-                                            modes, session);\n+                                            readOnly, session);\n@@ -1240,1 +1237,1 @@\n-            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(modes, session);\n+            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                assertTrue(ex.getCause().getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getCause().getMessage().contains(\"Already closed\"));\n@@ -413,1 +413,1 @@\n-                assertTrue(ex.getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getMessage().contains(\"Already closed\"));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -373,3 +373,3 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(parent);\n-        sessionImpl.acquire0();\n-        child.addCloseAction(sessionImpl::release0);\n+        MemorySessionImpl parentImpl = MemorySessionImpl.toSessionImpl(parent);\n+        parentImpl.acquire0();\n+        child.addCloseAction(parentImpl::release0);\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}