{"files":[{"patch":"@@ -1079,1 +1079,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.session().baseSession(), dstImpl.session().baseSession(),\n@@ -1083,1 +1083,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.session().baseSession(), dstImpl.session().baseSession(),\n@@ -1892,1 +1892,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.session().baseSession(), null,\n@@ -1896,1 +1896,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.session().baseSession(), null,\n@@ -1944,1 +1944,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.session().baseSession(),\n@@ -1948,1 +1948,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.session().baseSession(),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-public sealed interface MemorySession extends AutoCloseable, SegmentAllocator permits MemorySessionImpl, MemorySessionImpl.NonCloseableView {\n+public sealed interface MemorySession extends AutoCloseable, SegmentAllocator permits MemorySessionImpl {\n@@ -275,1 +275,1 @@\n-        return MemorySessionImpl.createImplicit();\n+        return MemorySessionImpl.createImplicit(null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-                MemorySessionImpl.heapSession(loader);\n+                MemorySessionImpl.createImplicit(loader);\n@@ -238,1 +238,1 @@\n-        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        ((MemorySessionImpl)session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -620,1 +620,1 @@\n-                    ((AbstractMemorySegmentImpl)segment).sessionImpl() : null;\n+                    ((AbstractMemorySegmentImpl)segment).session() : null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.sessionImpl(),\n+        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.session(),\n@@ -138,1 +138,1 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.get$Type$(bb.session(),\n@@ -142,1 +142,1 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.session(),\n@@ -155,1 +155,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.session(),\n@@ -162,1 +162,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$Type$(bb.session(),\n@@ -167,1 +167,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.session(),\n@@ -181,1 +181,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session(),\n@@ -190,1 +190,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.session(),\n@@ -201,1 +201,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.session(),\n@@ -210,1 +210,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.session(),\n@@ -221,1 +221,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.session(),\n@@ -230,1 +230,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.session(),\n@@ -241,1 +241,1 @@\n-        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.session(),\n@@ -252,1 +252,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.session(),\n@@ -263,1 +263,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.session(),\n@@ -274,1 +274,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.session(),\n@@ -284,1 +284,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.session(),\n@@ -294,1 +294,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session(),\n@@ -304,1 +304,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.session(),\n@@ -314,1 +314,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.session(),\n@@ -325,1 +325,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.session(),\n@@ -336,1 +336,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.session(),\n@@ -347,1 +347,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.session(),\n@@ -360,1 +360,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.session(),\n@@ -374,1 +374,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.session(),\n@@ -388,1 +388,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.session(),\n@@ -402,1 +402,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session(),base, offset);\n@@ -404,1 +404,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session(),base, offset,\n@@ -416,1 +416,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.session(),\n@@ -430,1 +430,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.session(),\n@@ -444,1 +444,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.session(),\n@@ -458,1 +458,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session(),base, offset);\n@@ -460,1 +460,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session(),base, offset,\n@@ -470,1 +470,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.session(),\n@@ -484,1 +484,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.session(),\n@@ -498,1 +498,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.session(),\n@@ -512,1 +512,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session(),base, offset);\n@@ -514,1 +514,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session(),base, offset,\n@@ -525,1 +525,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.session(),\n@@ -539,1 +539,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.session(),\n@@ -553,1 +553,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.session(),\n@@ -567,1 +567,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session(),base, offset);\n@@ -569,1 +569,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session(),base, offset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -40,1 +39,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -765,1 +763,1 @@\n-            return ((AbstractMemorySegmentImpl)segment).sessionImpl();\n+            return (MemorySessionImpl)segment.session();\n@@ -774,5 +772,1 @@\n-            try {\n-                session.checkValidState();\n-            } catch (ScopedMemoryAccess.ScopedAccessError e) {\n-                throw new IllegalStateException(\"This segment is already closed\");\n-            }\n+            session.checkValidState();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-            if (session.ownerThread() == null && session.isCloseable()) {\n+            if (session.ownerThread() == null && session.baseSession().isCloseable()) {\n@@ -316,5 +316,1 @@\n-            try {\n-                session.checkValidState();\n-            } catch (ScopedAccessError e) {\n-                throw new IllegalStateException(\"This segment is already closed\");\n-            }\n+            session.checkValidState();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -73,1 +72,0 @@\n-    static final int READ_ONLY = 1;\n@@ -76,2 +74,0 @@\n-    static final int DEFAULT_MODES = 0;\n-\n@@ -81,2 +77,2 @@\n-    final int mask;\n-    final MemorySession session;\n+    final boolean readOnly;\n+    final MemorySessionImpl session;\n@@ -85,1 +81,1 @@\n-    AbstractMemorySegmentImpl(long length, int mask, MemorySession session) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySessionImpl session) {\n@@ -87,1 +83,1 @@\n-        this.mask = mask;\n+        this.readOnly = readOnly;\n@@ -91,5 +87,1 @@\n-    abstract long min();\n-\n-    abstract Object base();\n-\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl session);\n@@ -101,1 +93,1 @@\n-        return dup(0, length, mask | READ_ONLY, session);\n+        return dup(0, length, true, session);\n@@ -106,1 +98,1 @@\n-        return isSet(READ_ONLY);\n+        return readOnly;\n@@ -122,1 +114,1 @@\n-        return dup(offset, newSize, mask, session);\n+        return dup(offset, newSize, readOnly, session);\n@@ -150,1 +142,1 @@\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), base(), min(), length, value);\n+        SCOPED_MEMORY_ACCESS.setMemory(session.baseSession(), unsafeGetBase(), unsafeGetOffset(), length, value);\n@@ -181,3 +173,3 @@\n-            i = vectorizedMismatchLargeForBytes(sessionImpl(), that.sessionImpl(),\n-                    this.base(), this.min(),\n-                    that.base(), that.min(),\n+            i = vectorizedMismatchLargeForBytes(session, that.session,\n+                    this.unsafeGetBase(), this.unsafeGetOffset(),\n+                    that.unsafeGetBase(), that.unsafeGetOffset(),\n@@ -218,1 +210,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession.baseSession(), bSession.baseSession(),\n@@ -241,1 +233,1 @@\n-        if (isSet(READ_ONLY)) {\n+        if (readOnly) {\n@@ -266,3 +258,3 @@\n-        if (base() == that.base()) {  \/\/ both either native or heap\n-            final long thisStart = this.min();\n-            final long thatStart = that.min();\n+        if (unsafeGetBase() == that.unsafeGetBase()) {  \/\/ both either native or heap\n+            final long thisStart = this.unsafeGetOffset();\n+            final long thatStart = that.unsafeGetOffset();\n@@ -284,2 +276,2 @@\n-        if (base() == that.base()) {\n-            return that.min() - this.min();\n+        if (unsafeGetBase() == that.unsafeGetBase()) {\n+            return that.unsafeGetOffset() - this.unsafeGetOffset();\n@@ -353,0 +345,1 @@\n+    @ForceInline\n@@ -354,1 +347,1 @@\n-        if (!readOnly && isSet(READ_ONLY)) {\n+        if (!readOnly && this.readOnly) {\n@@ -361,1 +354,1 @@\n-        sessionImpl().checkValidStateSlow();\n+        session.checkValidState();\n@@ -364,3 +357,1 @@\n-    public long unsafeGetOffset() {\n-        return min();\n-    }\n+    public abstract long unsafeGetOffset();\n@@ -368,3 +359,1 @@\n-    public Object unsafeGetBase() {\n-        return base();\n-    }\n+    public abstract Object unsafeGetBase();\n@@ -374,4 +363,0 @@\n-    private boolean isSet(int mask) {\n-        return (this.mask & mask) != 0;\n-    }\n-\n@@ -414,7 +399,1 @@\n-    @ForceInline\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session);\n-    }\n-\n-    @Override\n-    public MemorySession session() {\n+    public MemorySessionImpl session() {\n@@ -425,1 +404,1 @@\n-        return new IndexOutOfBoundsException(String.format(\"Out of bound access on segment %s; offset = %d; length = %d\",\n+        return new IndexOutOfBoundsException(String.format(\"Out of bound access on segment %s; new offset = %d; new length = %d\",\n@@ -431,1 +410,1 @@\n-        return Math.abs(Objects.hash(base(), min(), NONCE));\n+        return Math.abs(Objects.hash(unsafeGetBase(), unsafeGetOffset(), NONCE));\n@@ -548,1 +527,0 @@\n-        int modes;\n@@ -550,2 +528,1 @@\n-            bufferSession = bufferSegment.sessionImpl();\n-            modes = bufferSegment.mask;\n+            bufferSession = bufferSegment.session;\n@@ -554,4 +531,0 @@\n-            modes = DEFAULT_MODES;\n-        }\n-        if (bb.isReadOnly()) {\n-            modes |= READ_ONLY;\n@@ -559,0 +532,1 @@\n+        boolean readOnly = bb.isReadOnly();\n@@ -562,1 +536,1 @@\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -564,1 +538,1 @@\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -566,1 +540,1 @@\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -568,1 +542,1 @@\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -570,1 +544,1 @@\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -572,1 +546,1 @@\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -574,1 +548,1 @@\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n@@ -579,1 +553,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, modes, bufferSession);\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferSession);\n@@ -582,1 +556,1 @@\n-            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferSession);\n+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferSession);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":38,"deletions":64,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -58,5 +58,0 @@\n-    @Override\n-    public boolean isAlive() {\n-        return state != CLOSED;\n-    }\n-\n@@ -66,1 +61,1 @@\n-        checkValidStateSlow();\n+        checkValidState();\n@@ -68,1 +63,1 @@\n-            throw new IllegalStateException(\"Session keep alive limit exceeded\");\n+            throw tooManyAcquires();\n@@ -88,1 +83,1 @@\n-        checkValidStateSlow();\n+        checkValidState();\n@@ -92,1 +87,1 @@\n-            throw new IllegalStateException(\"Session is acquired by \" + state + \" clients\");\n+            throw alreadyAcquired(state);\n@@ -106,1 +101,1 @@\n-                throw new IllegalStateException(\"Already closed!\");\n+                throw alreadyClosed();\n@@ -117,1 +112,1 @@\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+                throw alreadyClosed();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -43,1 +42,1 @@\n- * {@link HeapMemorySegmentImpl#base()} method so that it returns an array of the correct (sharp) type. Note that\n+ * {@link HeapMemorySegmentImpl#unsafeGetBase()} method so that it returns an array of the correct (sharp) type. Note that\n@@ -47,1 +46,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, int, MemorySession)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, int, MemorySessionImpl)}.\n@@ -63,2 +62,2 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, int mask) {\n-        super(length, mask, MemorySessionImpl.GLOBAL);\n+    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly) {\n+        super(length, readOnly, MemorySessionImpl.GLOBAL);\n@@ -70,4 +69,1 @@\n-    abstract Object base();\n-\n-    @Override\n-    long min() {\n+    public long unsafeGetOffset() {\n@@ -78,1 +74,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl session);\n@@ -82,1 +78,1 @@\n-        if (!(base() instanceof byte[])) {\n+        if (!(base instanceof byte[])) {\n@@ -86,1 +82,1 @@\n-        return nioAccess.newHeapByteBuffer((byte[]) base(), (int)min() - BYTE_ARR_BASE, (int) byteSize(), null);\n+        return nioAccess.newHeapByteBuffer((byte[])base, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n@@ -93,2 +89,2 @@\n-        OfByte(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfByte(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -98,2 +94,2 @@\n-        OfByte dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfByte(this.offset + offset, base, size, mask);\n+        OfByte dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+            return new OfByte(this.offset + offset, base, size, readOnly);\n@@ -103,1 +99,1 @@\n-        byte[] base() {\n+        public byte[] unsafeGetBase() {\n@@ -110,1 +106,1 @@\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false);\n@@ -121,2 +117,2 @@\n-        OfChar(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfChar(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -126,2 +122,2 @@\n-        OfChar dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfChar(this.offset + offset, base, size, mask);\n+        OfChar dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+            return new OfChar(this.offset + offset, base, size, readOnly);\n@@ -131,1 +127,1 @@\n-        char[] base() {\n+        public char[] unsafeGetBase() {\n@@ -138,1 +134,1 @@\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false);\n@@ -149,2 +145,2 @@\n-        OfShort(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfShort(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -154,2 +150,2 @@\n-        OfShort dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfShort(this.offset + offset, base, size, mask);\n+        OfShort dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+            return new OfShort(this.offset + offset, base, size, readOnly);\n@@ -159,1 +155,1 @@\n-        short[] base() {\n+        public short[] unsafeGetBase() {\n@@ -166,1 +162,1 @@\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false);\n@@ -177,2 +173,2 @@\n-        OfInt(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfInt(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -182,2 +178,2 @@\n-        OfInt dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfInt(this.offset + offset, base, size, mask);\n+        OfInt dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+            return new OfInt(this.offset + offset, base, size, readOnly);\n@@ -187,1 +183,1 @@\n-        int[] base() {\n+        public int[] unsafeGetBase() {\n@@ -194,1 +190,1 @@\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false);\n@@ -205,2 +201,2 @@\n-        OfLong(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfLong(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -210,2 +206,2 @@\n-        OfLong dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfLong(this.offset + offset, base, size, mask);\n+        OfLong dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+            return new OfLong(this.offset + offset, base, size, readOnly);\n@@ -215,1 +211,1 @@\n-        long[] base() {\n+        public long[] unsafeGetBase() {\n@@ -222,1 +218,1 @@\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false);\n@@ -233,2 +229,2 @@\n-        OfFloat(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfFloat(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -238,2 +234,2 @@\n-        OfFloat dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfFloat(this.offset + offset, base, size, mask);\n+        OfFloat dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+            return new OfFloat(this.offset + offset, base, size, readOnly);\n@@ -243,1 +239,1 @@\n-        float[] base() {\n+        public float[] unsafeGetBase() {\n@@ -250,1 +246,1 @@\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false);\n@@ -261,2 +257,2 @@\n-        OfDouble(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfDouble(long offset, Object base, long length, boolean readOnly) {\n+            super(offset, base, length, readOnly);\n@@ -266,2 +262,2 @@\n-        OfDouble dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfDouble(this.offset + offset, base, size, mask);\n+        OfDouble dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+            return new OfDouble(this.offset + offset, base, size, readOnly);\n@@ -271,1 +267,1 @@\n-        double[] base() {\n+        public double[] unsafeGetBase() {\n@@ -278,1 +274,1 @@\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":50,"deletions":54,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -46,2 +45,2 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemorySession session) {\n-        super(min, length, mask, session);\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySessionImpl session) {\n+        super(min, length, readOnly, session);\n@@ -58,2 +57,2 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session) {\n-        return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, session);\n+    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, session);\n@@ -81,1 +80,1 @@\n-        SCOPED_MEMORY_ACCESS.load(sessionImpl(), min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.load(session.baseSession(), min, unmapper.isSync(), length);\n@@ -85,1 +84,1 @@\n-        SCOPED_MEMORY_ACCESS.unload(sessionImpl(), min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.unload(session.baseSession(), min, unmapper.isSync(), length);\n@@ -89,1 +88,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(sessionImpl(), min, unmapper.isSync(), length);\n+        return SCOPED_MEMORY_ACCESS.isLoaded(session.baseSession(), min, unmapper.isSync(), length);\n@@ -93,1 +92,1 @@\n-        SCOPED_MEMORY_ACCESS.force(sessionImpl(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+        SCOPED_MEMORY_ACCESS.force(session.baseSession(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n@@ -98,2 +97,2 @@\n-        public EmptyMappedMemorySegmentImpl(int modes, MemorySession session) {\n-            super(0, null, 0, modes, session);\n+        public EmptyMappedMemorySegmentImpl(boolean readOnly, MemorySessionImpl session) {\n+            super(0, null, 0, readOnly, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    public MemorySessionImpl sessionImpl() {\n+    public MemorySessionImpl session() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * to memory access (see {@link #checkValidState()}).\n+ * to memory access (see {@link #checkValidStateRaw()}).\n@@ -49,1 +49,1 @@\n- * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n+ * associated owner thread such as {@link #close()} or {@link #checkValidStateRaw()}.\n@@ -55,1 +55,1 @@\n-public abstract non-sealed class MemorySessionImpl implements Scoped, MemorySession, SegmentAllocator {\n+public abstract non-sealed class MemorySessionImpl implements MemorySession, SegmentAllocator {\n@@ -81,2 +81,1 @@\n-        addInternal(runnable instanceof ResourceList.ResourceCleanup cleanup ?\n-                cleanup : ResourceList.ResourceCleanup.ofRunnable(runnable));\n+        addInternal(ResourceList.ResourceCleanup.ofRunnable(runnable));\n@@ -105,1 +104,1 @@\n-        checkValidStateSlow();\n+        checkValidState();\n@@ -130,2 +129,2 @@\n-    public static MemorySessionImpl createImplicit() {\n-        return new ImplicitSession();\n+    public static MemorySessionImpl createImplicit(Object ref) {\n+        return new ImplicitSession(ref);\n@@ -139,0 +138,4 @@\n+    public MemorySessionImpl baseSession() {\n+        return this;\n+    }\n+\n@@ -144,3 +147,3 @@\n-    public boolean equals(Object o) {\n-        return (o instanceof MemorySession other) &&\n-            toSessionImpl(other) == this;\n+    public final boolean equals(Object o) {\n+        return (o instanceof MemorySessionImpl other) &&\n+                baseSession() == other.baseSession();\n@@ -150,2 +153,4 @@\n-    public int hashCode() {\n-        return super.hashCode();\n+    public final int hashCode() {\n+        MemorySessionImpl base = baseSession();\n+        return (base != this) ?\n+                base.hashCode() : super.hashCode();\n@@ -177,1 +182,3 @@\n-    public abstract boolean isAlive();\n+    public boolean isAlive() {\n+        return state >= OPEN;\n+    }\n@@ -185,9 +192,0 @@\n-    public static MemorySessionImpl toSessionImpl(MemorySession session) {\n-        return ((Scoped)session).sessionImpl();\n-    }\n-\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return this;\n-    }\n-\n@@ -195,1 +193,1 @@\n-     * This is a faster version of {@link #checkValidStateSlow()}, which is called upon memory access, and which\n+     * This is a faster version of {@link #checkValidState()}, which is called upon memory access, and which\n@@ -200,1 +198,1 @@\n-     * please use {@link #checkValidStateSlow()}.\n+     * please use {@link #checkValidState()}.\n@@ -203,1 +201,1 @@\n-    public final void checkValidState() {\n+    public void checkValidStateRaw() {\n@@ -205,1 +203,1 @@\n-            throw new WrongThreadException(\"Attempted access outside owning thread\");\n+            throw WRONG_THREAD;\n@@ -208,1 +206,1 @@\n-            throw ScopedMemoryAccess.ScopedAccessError.INSTANCE;\n+            throw ALREADY_CLOSED;\n@@ -217,5 +215,5 @@\n-    public final void checkValidStateSlow() {\n-        if (owner != null && Thread.currentThread() != owner) {\n-            throw new WrongThreadException(\"Attempted access outside owning thread\");\n-        } else if (!isAlive()) {\n-            throw new IllegalStateException(\"Already closed\");\n+    public void checkValidState() {\n+        try {\n+            checkValidStateRaw();\n+        } catch (ScopedMemoryAccess.ScopedAccessError error) {\n+            throw error.newRuntimeException();\n@@ -292,5 +290,0 @@\n-        @Override\n-        public boolean isAlive() {\n-            return true;\n-        }\n-\n@@ -299,1 +292,1 @@\n-            throw new UnsupportedOperationException();\n+            throw nonCloseable();\n@@ -305,4 +298,0 @@\n-    public static MemorySessionImpl heapSession(Object ref) {\n-        return new GlobalSessionImpl(ref);\n-    }\n-\n@@ -319,1 +308,3 @@\n-        public ImplicitSession() {\n+        final Object ref;\n+\n+        ImplicitSession(Object ref) {\n@@ -321,0 +312,1 @@\n+            this.ref = ref;\n@@ -338,10 +330,0 @@\n-        @Override\n-        public boolean isAlive() {\n-            return true;\n-        }\n-\n-        @Override\n-        public MemorySession asNonCloseable() {\n-            return this;\n-        }\n-\n@@ -350,1 +332,1 @@\n-            throw new UnsupportedOperationException();\n+            throw nonCloseable();\n@@ -361,1 +343,1 @@\n-    public final static class NonCloseableView implements MemorySession, Scoped {\n+    public final static class NonCloseableView extends MemorySessionImpl {\n@@ -365,0 +347,1 @@\n+            super(session.owner, null, null);\n@@ -368,4 +351,0 @@\n-        public MemorySessionImpl sessionImpl() {\n-            return session;\n-        }\n-\n@@ -373,2 +352,2 @@\n-        public boolean isAlive() {\n-            return session.isAlive();\n+        public MemorySessionImpl baseSession() {\n+            return session;\n@@ -378,2 +357,2 @@\n-        public boolean isCloseable() {\n-            return false;\n+        void addInternal(ResourceList.ResourceCleanup resource) {\n+            session.addInternal(resource);\n@@ -383,2 +362,2 @@\n-        public Thread ownerThread() {\n-            return session.ownerThread();\n+        public void release0() {\n+            session.release0();\n@@ -388,2 +367,2 @@\n-        public boolean equals(Object o) {\n-            return session.equals(o);\n+        public void acquire0() {\n+            session.acquire0();\n@@ -393,2 +372,2 @@\n-        public int hashCode() {\n-            return session.hashCode();\n+        public boolean isCloseable() {\n+            return false;\n@@ -398,2 +377,2 @@\n-        public void whileAlive(Runnable action) {\n-            session.whileAlive(action);\n+        public void justClose() {\n+            throw nonCloseable();\n@@ -403,2 +382,2 @@\n-        public MemorySession asNonCloseable() {\n-            return this;\n+        public boolean isAlive() {\n+            return session.isAlive();\n@@ -408,2 +387,5 @@\n-        public void addCloseAction(Runnable runnable) {\n-            session.addCloseAction(runnable);\n+        public void checkValidStateRaw() {\n+            \/\/ We should never call checkValidStateRaw on a non-closeable view; that method should always be\n+            \/\/ called on the \"base\" session associated with the non-closeable view. Failure to do that\n+            \/\/ will result in use-after-free issues with ScopedMemoryAccess.\n+            throw new IllegalStateException(\"We should not get here!\");\n@@ -413,2 +395,2 @@\n-        public void close() {\n-            throw new UnsupportedOperationException();\n+        public void checkValidState() {\n+            session.checkValidState();\n@@ -464,0 +446,11 @@\n+    }\n+\n+    \/\/ helper functions to centralize error handling\n+\n+    static IllegalStateException tooManyAcquires() {\n+        return new IllegalStateException(\"Session acquire limit exceeded\");\n+    }\n+\n+    static IllegalStateException alreadyAcquired(int acquires) {\n+        return new IllegalStateException(String.format(\"Session is acquired by %d clients\", acquires));\n+    }\n@@ -465,0 +458,2 @@\n+    static IllegalStateException alreadyClosed() {\n+        return new IllegalStateException(\"Already closed\");\n@@ -466,0 +461,12 @@\n+\n+    static WrongThreadException wrongThread() {\n+        return new WrongThreadException(\"Attempted access outside owning thread\");\n+    }\n+\n+    static UnsupportedOperationException nonCloseable() {\n+        return new UnsupportedOperationException(\"Attempted to close a non-closeable session\");\n+    }\n+\n+    static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n+\n+    static final ScopedMemoryAccess.ScopedAccessError WRONG_THREAD = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::wrongThread);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":85,"deletions":78,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, 0, MemorySessionImpl.GLOBAL) {\n+    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, false, MemorySessionImpl.GLOBAL) {\n@@ -51,1 +51,1 @@\n-        NativeMemorySegmentImpl dup(long offset, long size, int mask, MemorySession scope) {\n+        NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n@@ -67,2 +67,2 @@\n-    NativeMemorySegmentImpl(long min, long length, int mask, MemorySession session) {\n-        super(length, mask, session);\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySessionImpl session) {\n+        super(length, readOnly, session);\n@@ -80,2 +80,2 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session) {\n-        return new NativeMemorySegmentImpl(min + offset, size, mask, session);\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl session) {\n+        return new NativeMemorySegmentImpl(min + offset, size, readOnly, session);\n@@ -86,1 +86,1 @@\n-        return nioAccess.newDirectByteBuffer(min(), (int) this.length, null,\n+        return nioAccess.newDirectByteBuffer(min, (int) this.length, null,\n@@ -96,1 +96,1 @@\n-    long min() {\n+    public long unsafeGetOffset() {\n@@ -101,1 +101,1 @@\n-    Object base() {\n+    public Object unsafeGetBase() {\n@@ -113,2 +113,2 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n-        sessionImpl.checkValidStateSlow();\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl)session;\n+        sessionImpl.checkValidState();\n@@ -130,1 +130,1 @@\n-                DEFAULT_MODES, session);\n+                false, sessionImpl);\n@@ -146,3 +146,3 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n-        sessionImpl.checkValidStateSlow();\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, DEFAULT_MODES, session);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl)session;\n+        sessionImpl.checkValidState();\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, false, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    MemorySessionImpl sessionImpl();\n+    MemorySessionImpl session();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                throw new IllegalStateException(\"Already closed\");\n+                throw alreadyClosed();\n@@ -62,1 +62,1 @@\n-                throw new IllegalStateException(\"Session acquire limit exceeded\");\n+                throw tooManyAcquires();\n@@ -75,1 +75,1 @@\n-                throw new IllegalStateException(\"Already closed\");\n+                throw alreadyClosed();\n@@ -83,1 +83,1 @@\n-            throw new IllegalStateException(\"Already closed\");\n+            throw alreadyClosed();\n@@ -85,1 +85,1 @@\n-            throw new IllegalStateException(\"Session is acquired by \" + prevState + \" clients\");\n+            throw alreadyAcquired(prevState);\n@@ -90,1 +90,1 @@\n-            throw new IllegalStateException(\"Session is acquired by 1 client\");\n+            throw alreadyAcquired(1);\n@@ -94,5 +94,0 @@\n-    @Override\n-    public boolean isAlive() {\n-        return (int) STATE.getVolatile(this) != CLOSED;\n-    }\n-\n@@ -120,1 +115,1 @@\n-                    throw new IllegalStateException(\"Already closed\");\n+                    throw alreadyClosed();\n@@ -147,1 +142,1 @@\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+                throw alreadyClosed();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-        emitInvokeInterface(Scoped.class, \"sessionImpl\", SESSION_IMPL_DESC);\n+        emitInvokeInterface(Scoped.class, \"session\", SESSION_IMPL_DESC);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -444,6 +444,1 @@\n-        public MemorySession session() {\n-            return MemorySessionImpl.GLOBAL;\n-        }\n-\n-        @Override\n-        public MemorySessionImpl sessionImpl() {\n+        public MemorySessionImpl session() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        ((MemorySessionImpl)session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        session().checkValidState();\n@@ -349,7 +349,2 @@\n-    public MemorySession session() {\n-        return segment.session();\n-    }\n-\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n+    public MemorySessionImpl session() {\n+        return (MemorySessionImpl)segment.session();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private final MemorySession session;\n+    private final MemorySessionImpl session;\n@@ -58,1 +58,1 @@\n-    private MacOsAArch64VaList(MemorySegment segment, MemorySession session) {\n+    private MacOsAArch64VaList(MemorySegment segment, MemorySessionImpl session) {\n@@ -130,1 +130,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        session.checkValidState();\n@@ -143,1 +143,1 @@\n-        return new MacOsAArch64VaList(segment, session);\n+        return new MacOsAArch64VaList(segment, (MemorySessionImpl)session);\n@@ -151,1 +151,1 @@\n-    public MemorySession session() {\n+    public MemorySessionImpl session() {\n@@ -155,5 +155,0 @@\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n-    }\n-\n@@ -162,1 +157,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        session.checkValidState();\n@@ -173,1 +168,1 @@\n-        private final MemorySession session;\n+        private final MemorySessionImpl session;\n@@ -177,2 +172,2 @@\n-            MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n-            this.session = session;\n+            ((MemorySessionImpl)session).checkValidState();\n+            this.session = (MemorySessionImpl)session;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        session().checkValidState();\n@@ -303,7 +303,2 @@\n-    public MemorySession session() {\n-        return segment.session();\n-    }\n-\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n+    public MemorySessionImpl session() {\n+        return (MemorySessionImpl)segment.session();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    private final MemorySession session;\n+    private final MemorySessionImpl session;\n@@ -69,1 +69,1 @@\n-    private WinVaList(MemorySegment segment, MemorySession session) {\n+    private WinVaList(MemorySegment segment, MemorySessionImpl session) {\n@@ -136,1 +136,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        session.checkValidState();\n@@ -143,1 +143,1 @@\n-        return new WinVaList(segment, session);\n+        return new WinVaList(segment, (MemorySessionImpl)session);\n@@ -151,1 +151,1 @@\n-    public MemorySession session() {\n+    public MemorySessionImpl session() {\n@@ -155,5 +155,0 @@\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n-    }\n-\n@@ -162,1 +157,1 @@\n-        MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n+        session.checkValidState();\n@@ -173,1 +168,1 @@\n-        private final MemorySession session;\n+        private final MemorySessionImpl session;\n@@ -177,2 +172,2 @@\n-            MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n-            this.session = session;\n+            ((MemorySessionImpl)session).checkValidState();\n+            this.session = (MemorySessionImpl)session;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -14,1 +14,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -27,1 +27,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -35,1 +35,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -49,1 +49,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -57,1 +57,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -70,1 +70,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -78,1 +78,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -92,1 +92,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -100,1 +100,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -113,1 +113,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -121,1 +121,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -134,1 +134,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -142,1 +142,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -155,1 +155,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -163,1 +163,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -176,1 +176,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -184,1 +184,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -196,1 +196,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -204,1 +204,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -217,1 +217,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -225,1 +225,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -238,1 +238,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -246,1 +246,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -259,1 +259,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -267,1 +267,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -280,1 +280,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -288,1 +288,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -301,1 +301,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -309,1 +309,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -322,1 +322,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -330,1 +330,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -343,1 +343,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -351,1 +351,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -364,1 +364,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -372,1 +372,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -385,1 +385,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -393,1 +393,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -406,1 +406,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -414,1 +414,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -427,1 +427,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -435,1 +435,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -450,1 +450,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -458,1 +458,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -471,1 +471,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -479,1 +479,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -492,1 +492,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -500,1 +500,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -515,1 +515,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -523,1 +523,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -536,1 +536,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -544,1 +544,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -557,1 +557,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -565,1 +565,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -578,1 +578,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -586,1 +586,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -599,1 +599,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -607,1 +607,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -620,1 +620,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -628,1 +628,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -641,1 +641,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -649,1 +649,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -662,1 +662,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -670,1 +670,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -683,1 +683,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -691,1 +691,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Supplier;\n@@ -58,2 +59,2 @@\n- * region concurrently. More specifically, when a thread wants to release a memory region, it should call the\n- * {@link MemorySessionImpl#close()} method. This method initiates thread-local handshakes with all the other VM threads,\n+ * session concurrently. More specifically, when a thread wants to release a memory session, it should call the\n+ * {@link ScopedMemoryAccess#closeScope(MemorySessionImpl)} method. This method initiates thread-local handshakes with all the other VM threads,\n@@ -61,1 +62,1 @@\n- * being closed, the handshake fails, and the session cannot be closed.\n+ * being closed, the handshake fails, and the session will not be closed.\n@@ -100,2 +101,7 @@\n-        private ScopedAccessError() {\n-            super(\"Attempt to access an already released memory resource\", null, false, false);\n+\n+        @SuppressWarnings(\"serial\")\n+        private final Supplier<RuntimeException> runtimeExceptionSupplier;\n+\n+        public ScopedAccessError(Supplier<RuntimeException> runtimeExceptionSupplier) {\n+            super(\"Invalid memory access\", null, false, false);\n+            this.runtimeExceptionSupplier = runtimeExceptionSupplier;\n@@ -103,0 +109,1 @@\n+\n@@ -105,1 +112,3 @@\n-        public static final ScopedAccessError INSTANCE = new ScopedAccessError();\n+        public final RuntimeException newRuntimeException() {\n+            return runtimeExceptionSupplier.get();\n+        }\n@@ -115,1 +124,1 @@\n-    public void copyMemory(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    public void copyMemory(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n@@ -120,1 +129,1 @@\n-              copyMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes);\n+              copyMemoryInternal(srcSession, dstSession, srcBase, srcOffset, destBase, destOffset, bytes);\n@@ -122,1 +131,1 @@\n-              throw new IllegalStateException(\"This segment is already closed\");\n+              throw ex.newRuntimeException();\n@@ -127,1 +136,1 @@\n-    private void copyMemoryInternal(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    private void copyMemoryInternal(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n@@ -132,2 +141,2 @@\n-            if (srcScope != null) {\n-                srcScope.checkValidState();\n+            if (srcSession != null) {\n+                srcSession.checkValidStateRaw();\n@@ -135,2 +144,2 @@\n-            if (dstScope != null) {\n-                dstScope.checkValidState();\n+            if (dstSession != null) {\n+                dstSession.checkValidStateRaw();\n@@ -140,2 +149,2 @@\n-            Reference.reachabilityFence(srcScope);\n-            Reference.reachabilityFence(dstScope);\n+            Reference.reachabilityFence(srcSession);\n+            Reference.reachabilityFence(dstSession);\n@@ -146,1 +155,1 @@\n-    public void copySwapMemory(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    public void copySwapMemory(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n@@ -151,1 +160,1 @@\n-              copySwapMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n+              copySwapMemoryInternal(srcSession, dstSession, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n@@ -153,1 +162,1 @@\n-              throw new IllegalStateException(\"This segment is already closed\");\n+              throw ex.newRuntimeException();\n@@ -158,1 +167,1 @@\n-    private void copySwapMemoryInternal(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    private void copySwapMemoryInternal(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n@@ -163,2 +172,2 @@\n-            if (srcScope != null) {\n-                srcScope.checkValidState();\n+            if (srcSession != null) {\n+                srcSession.checkValidStateRaw();\n@@ -166,2 +175,2 @@\n-            if (dstScope != null) {\n-                dstScope.checkValidState();\n+            if (dstSession != null) {\n+                dstSession.checkValidStateRaw();\n@@ -171,2 +180,2 @@\n-            Reference.reachabilityFence(srcScope);\n-            Reference.reachabilityFence(dstScope);\n+            Reference.reachabilityFence(srcSession);\n+            Reference.reachabilityFence(dstSession);\n@@ -181,1 +190,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -189,1 +198,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -198,1 +207,1 @@\n-    public int vectorizedMismatch(MemorySessionImpl aScope, MemorySessionImpl bScope,\n+    public int vectorizedMismatch(MemorySessionImpl aSession, MemorySessionImpl bSession,\n@@ -204,1 +213,1 @@\n-            return vectorizedMismatchInternal(aScope, bScope, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n+            return vectorizedMismatchInternal(aSession, bSession, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n@@ -206,1 +215,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -211,1 +220,1 @@\n-    private int vectorizedMismatchInternal(MemorySessionImpl aScope, MemorySessionImpl bScope,\n+    private int vectorizedMismatchInternal(MemorySessionImpl aSession, MemorySessionImpl bSession,\n@@ -217,2 +226,2 @@\n-            if (aScope != null) {\n-                aScope.checkValidState();\n+            if (aSession != null) {\n+                aSession.checkValidStateRaw();\n@@ -220,2 +229,2 @@\n-            if (bScope != null) {\n-                bScope.checkValidState();\n+            if (bSession != null) {\n+                bSession.checkValidStateRaw();\n@@ -225,2 +234,2 @@\n-            Reference.reachabilityFence(aScope);\n-            Reference.reachabilityFence(bScope);\n+            Reference.reachabilityFence(aSession);\n+            Reference.reachabilityFence(bSession);\n@@ -235,1 +244,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -243,1 +252,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -256,1 +265,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -264,1 +273,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -277,1 +286,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -285,1 +294,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -298,1 +307,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -306,1 +315,1 @@\n-                session.checkValidState();\n+                session.checkValidStateRaw();\n@@ -330,1 +339,1 @@\n-                    msp.sessionImpl(),\n+                    msp.session(),\n@@ -336,1 +345,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -350,1 +359,1 @@\n-            session.checkValidState();\n+            session.checkValidStateRaw();\n@@ -375,1 +384,1 @@\n-                    msp.sessionImpl(),\n+                    msp.session(),\n@@ -381,1 +390,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -396,1 +405,1 @@\n-            session.checkValidState();\n+            session.checkValidStateRaw();\n@@ -421,1 +430,1 @@\n-                    msp.sessionImpl(),\n+                    msp.session(),\n@@ -427,1 +436,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -441,1 +450,1 @@\n-            session.checkValidState();\n+            session.checkValidStateRaw();\n@@ -467,1 +476,1 @@\n-                    msp.sessionImpl(),\n+                    msp.session(),\n@@ -473,1 +482,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -487,1 +496,1 @@\n-            session.checkValidState();\n+            session.checkValidStateRaw();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":67,"deletions":58,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -1202,3 +1202,0 @@\n-    private static final int MAP_MEM_SEG_DEFAULT_MODES = 0;\n-    private static final int MAP_MEM_SEG_READ_ONLY = 1;\n-\n@@ -1212,2 +1209,2 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n-        sessionImpl.checkValidStateSlow();\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl)session;\n+        sessionImpl.checkValidState();\n@@ -1222,1 +1219,1 @@\n-        int modes = MAP_MEM_SEG_DEFAULT_MODES;\n+        boolean readOnly = false;\n@@ -1224,1 +1221,1 @@\n-            modes |= MAP_MEM_SEG_READ_ONLY;\n+            readOnly = true;\n@@ -1229,1 +1226,1 @@\n-                                            modes, session);\n+                                            readOnly, sessionImpl);\n@@ -1240,1 +1237,1 @@\n-            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(modes, session);\n+            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                assertTrue(ex.getCause().getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getCause().getMessage().contains(\"Already closed\"));\n@@ -413,1 +413,1 @@\n-                assertTrue(ex.getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getMessage().contains(\"Already closed\"));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(parent);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl)parent;\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}