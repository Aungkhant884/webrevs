{"files":[{"patch":"@@ -3601,0 +3601,6 @@\n+    if (p->is_exiting()) {\n+      \/\/ If we got here via JavaThread::exit(), then we remember that the\n+      \/\/ thread's GC barrier has been detached. We don't do this when we get\n+      \/\/ here from another path, e.g., cleanup_failed_attach_current_thread().\n+      p->set_terminated(JavaThread::_thread_gc_barrier_detached);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -907,1 +907,1 @@\n-    _not_terminated = 0xDEAD - 2,\n+    _not_terminated = 0xDEAD - 3,\n@@ -909,0 +909,1 @@\n+    _thread_gc_barrier_detached,                 \/\/ thread's GC barrier has been detached\n@@ -917,1 +918,1 @@\n-  \/\/   _not_terminated => _thread_exiting => _thread_terminated\n+  \/\/   _not_terminated => _thread_exiting => _thread_gc_barrier_detached => _thread_terminated\n@@ -921,0 +922,4 @@\n+  \/\/\n+  \/\/ A JavaThread that fails to JNI attach has these _terminated field transitions:\n+  \/\/   _not_terminated => _thread_terminated\n+  \/\/\n@@ -1175,1 +1180,2 @@\n-  \/\/ thread has called JavaThread::exit() or is terminated\n+  \/\/ thread has called JavaThread::exit(), thread's GC barrier is detached\n+  \/\/ or thread is terminated\n@@ -1177,0 +1183,2 @@\n+  \/\/ thread's GC barrier is NOT detached and thread is NOT terminated\n+  bool is_oop_safe() const;\n@@ -1178,1 +1186,1 @@\n-  \/\/ against the two non-terminated values so that a freed JavaThread\n+  \/\/ against the three non-terminated values so that a freed JavaThread\n@@ -1181,1 +1189,2 @@\n-    return l_terminated != _not_terminated && l_terminated != _thread_exiting;\n+    return l_terminated != _not_terminated && l_terminated != _thread_exiting &&\n+           l_terminated != _thread_gc_barrier_detached;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-  \/\/ Use load-acquire so that setting of _terminated by\n-  \/\/ JavaThread::exit() is seen more quickly.\n@@ -266,1 +264,9 @@\n-  return l_terminated == _thread_exiting || check_is_terminated(l_terminated);\n+  return l_terminated == _thread_exiting ||\n+         l_terminated == _thread_gc_barrier_detached ||\n+         check_is_terminated(l_terminated);\n+}\n+\n+inline bool JavaThread::is_oop_safe() const {\n+  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n+  return l_terminated != _thread_gc_barrier_detached &&\n+         !check_is_terminated(l_terminated);\n@@ -270,2 +276,0 @@\n-  \/\/ Use load-acquire so that setting of _terminated by\n-  \/\/ JavaThread::exit() is seen more quickly.\n@@ -277,1 +281,0 @@\n-  \/\/ use release-store so the setting of _terminated is seen more quickly\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -166,1 +166,2 @@\n-    \/\/ JavaThread::exit() skipped calling current_thread_exiting()\n+    \/\/ We did not get here via JavaThread::exit() so current_thread_exiting()\n+    \/\/ was not called, e.g., JavaThread::cleanup_failed_attach_current_thread().\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}