{"files":[{"patch":"@@ -58,1 +58,3 @@\n-  BUILD_JDK_JTREG_EXCLUDE += libDirectIO.c libInheritedChannel.c exelauncher.c\n+  BUILD_JDK_JTREG_EXCLUDE += libDirectIO.c libInheritedChannel.c \\\n+      libExplicitAttach.c libImplicitAttach.c \\\n+      exelauncher.c\n@@ -87,0 +89,3 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libExplicitAttach := -ljvm\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libExplicitAttach := -pthread\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libImplicitAttach := -pthread\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -655,3 +655,0 @@\n-        if (name == null) {\n-            throw new InternalError(\"name cannot be null\");\n-        }\n@@ -661,3 +658,0 @@\n-        if (attached && g == null) {\n-            throw new InternalError(\"group cannot be null when attaching\");\n-        }\n@@ -665,5 +659,3 @@\n-        SecurityManager security = System.getSecurityManager();\n-        if (g == null) {\n-            \/\/ the security manager can choose the thread group\n-            if (security != null) {\n-                g = security.getThreadGroup();\n+        if (attached) {\n+            if (g == null) {\n+                throw new InternalError(\"group cannot be null when attaching\");\n@@ -671,2 +663,3 @@\n-\n-            \/\/ default to current thread's group\n+            this.holder = new FieldHolder(g, task, stackSize, NORM_PRIORITY, false);\n+        } else {\n+            SecurityManager sm = System.getSecurityManager();\n@@ -674,1 +667,9 @@\n-                g = parent.getThreadGroup();\n+                \/\/ the security manager can choose the thread group\n+                if (sm != null) {\n+                    g = sm.getThreadGroup();\n+                }\n+\n+                \/\/ default to current thread's group\n+                if (g == null) {\n+                    g = parent.getThreadGroup();\n+                }\n@@ -676,1 +677,0 @@\n-        }\n@@ -678,5 +678,6 @@\n-        \/\/ permission checks when creating a child Thread\n-        if (!attached && security != null) {\n-            security.checkAccess(g);\n-            if (isCCLOverridden(getClass())) {\n-                security.checkPermission(SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);\n+            \/\/ permission checks when creating a child Thread\n+            if (sm != null) {\n+                sm.checkAccess(g);\n+                if (isCCLOverridden(getClass())) {\n+                    sm.checkPermission(SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);\n+                }\n@@ -684,0 +685,3 @@\n+\n+            int priority = Math.min(parent.getPriority(), g.getMaxPriority());\n+            this.holder = new FieldHolder(g, task, stackSize, priority, parent.isDaemon());\n@@ -691,1 +695,2 @@\n-        this.name = name;\n+        this.name = (name != null) ? name : genThreadName();\n+\n@@ -723,12 +728,0 @@\n-\n-        int priority;\n-        boolean daemon;\n-        if (attached) {\n-            \/\/ primordial or attached thread\n-            priority = NORM_PRIORITY;\n-            daemon = false;\n-        } else {\n-            priority = Math.min(parent.getPriority(), g.getMaxPriority());\n-            daemon = parent.isDaemon();\n-        }\n-        this.holder = new FieldHolder(g, task, stackSize, priority, daemon);\n@@ -1156,1 +1149,1 @@\n-        this(null, genThreadName(), 0, null, 0, null);\n+        this(null, null, 0, null, 0, null);\n@@ -1177,1 +1170,1 @@\n-        this(null, genThreadName(), 0, task, 0, null);\n+        this(null, null, 0, task, 0, null);\n@@ -1186,1 +1179,1 @@\n-        this(null, genThreadName(), 0, task, 0, acc);\n+        this(null, null, 0, task, 0, acc);\n@@ -1219,1 +1212,1 @@\n-        this(group, genThreadName(), 0, task, 0, null);\n+        this(group, null, 0, task, 0, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":30,"deletions":37,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8287982\n+ * @summary Test native threads attaching to the VM with JNI AttachCurrentThread\n+ * @requires (os.family == \"linux\" | os.family == \"mac\")\n+ * @library \/test\/lib\n+ * @compile ExplicitAttach.java\n+ * @run main AttachTest ExplicitAttach 1\n+ * @run main AttachTest ExplicitAttach 2\n+ * @run main AttachTest ExplicitAttach 4\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test native threads attaching implicitly to the VM by means of an upcall\n+ * @requires (os.family == \"linux\" | os.family == \"mac\") & (sun.arch.data.model == \"64\")\n+ * @library \/test\/lib\n+ * @compile --enable-preview -source ${jdk.version} ImplicitAttach.java\n+ * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n+ * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n+ * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n+ *\/\n+\n+import java.util.stream.Stream;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AttachTest {\n+    static final String TEST_CLASSES = System.getProperty(\"test.classes\");\n+    static final String JAVA_LIBRARY_PATH = System.getProperty(\"java.library.path\");\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ prepend -cp ${test.classes} -Djava.library.path=${java.library.path}\n+        String[] opts = Stream.concat(Stream.of(\n+                        \"-cp\", TEST_CLASSES,\n+                        \"-Djava.library.path=\" + JAVA_LIBRARY_PATH),\n+                        Stream.of(args))\n+                .toArray(String[]::new);\n+        OutputAnalyzer outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        int exitValue = outputAnalyzer.getExitValue();\n+        if (exitValue != 0)\n+            throw new RuntimeException(\"Test failed\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/AttachTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * Test native threads attaching to the VM with JNI AttachCurrentThread.\n+ *\/\n+public class ExplicitAttach {\n+    private static volatile CountDownLatch latch;\n+\n+    public static void main(String[] args) throws Exception {\n+        int threadCount;\n+        if (args.length > 0) {\n+            threadCount = Integer.parseInt(args[0]);\n+        } else {\n+            threadCount = 2;\n+        }\n+        latch = new CountDownLatch(threadCount);\n+\n+        \/\/ start the threads and wait for the threads to call home\n+        startThreads(threadCount);\n+        latch.await();\n+    }\n+\n+    \/**\n+     * Invoked by attached threads.\n+     *\/\n+    private static void callback() {\n+        System.out.println(Thread.currentThread());\n+        latch.countDown();\n+    }\n+\n+    \/**\n+     * Start n native threads that attach to the VM and invoke callback.\n+     *\/\n+    private static native void startThreads(int n);\n+\n+    static {\n+        System.loadLibrary(\"ExplicitAttach\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ExplicitAttach.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * Test native threads attaching implicitly to the VM by means of an upcall.\n+ *\/\n+public class ImplicitAttach {\n+    private static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n+    private static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+\n+    private static volatile CountDownLatch latch;\n+\n+    public static void main(String[] args) throws Throwable {\n+        int threadCount;\n+        if (args.length > 0) {\n+            threadCount = Integer.parseInt(args[0]);\n+        } else {\n+            threadCount = 2;\n+        }\n+        latch = new CountDownLatch(threadCount);\n+\n+        Linker abi = Linker.nativeLinker();\n+\n+        \/\/ stub to invoke callback\n+        MethodHandle callback = MethodHandles.lookup()\n+                .findStatic(ImplicitAttach.class, \"callback\", MethodType.methodType(void.class));\n+        MemorySegment upcallStub = abi.upcallStub(callback,\n+                FunctionDescriptor.ofVoid(),\n+                MemorySession.openImplicit());\n+\n+        \/\/ void start_threads(int count, void *(*f)(void *))\n+        SymbolLookup symbolLookup = SymbolLookup.loaderLookup();\n+        MemorySegment symbol = symbolLookup.lookup(\"start_threads\").orElseThrow();\n+        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_INT, C_POINTER);\n+        MethodHandle start_threads = abi.downcallHandle(symbol, desc);\n+\n+        \/\/ start the threads and wait for the threads to call home\n+        start_threads.invoke(threadCount, upcallStub);\n+        latch.await();\n+    }\n+\n+    \/**\n+     * Invoked from native thread.\n+     *\/\n+    private static void callback() {\n+        System.out.println(Thread.currentThread());\n+        latch.countDown();\n+    }\n+\n+    static {\n+        System.loadLibrary(\"ImplicitAttach\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdio.h>\n+#include <pthread.h>\n+#include \"jni.h\"\n+\n+#define STACK_SIZE 0x100000\n+\n+\/**\n+ * Attach the current thread with JNI AttachCurrentThread, call a method, and detach.\n+ *\/\n+void* thread_main(void* arg) {\n+    JavaVM *vm;\n+    JNIEnv *env;\n+    JavaVMInitArgs vm_args;\n+    jsize count;\n+    jint res;\n+\n+    res = JNI_GetCreatedJavaVMs(&vm, 1, &count);\n+    if (res != JNI_OK) {\n+        fprintf(stderr, \"JNI_GetCreatedJavaVMs failed: %d\\n\", res);\n+        return NULL;\n+    }\n+\n+    res = (*vm)->AttachCurrentThread(vm, (void **) &env, NULL);\n+    if (res != JNI_OK) {\n+        fprintf(stderr, \"AttachCurrentThreadAsDaemon failed: %d\\n\", res);\n+        return NULL;\n+    }\n+\n+    \/\/ call ExplicitAttach.callback()\n+    jclass clazz = (*env)->FindClass(env, \"ExplicitAttach\");\n+    if (clazz == NULL) {\n+        fprintf(stderr, \"FindClass failed\\n\");\n+        goto detach;\n+    }\n+    jmethodID mid = (*env)->GetStaticMethodID(env, clazz, \"callback\", \"()V\");\n+    if (mid == NULL) {\n+        fprintf(stderr, \"GetStaticMethodID failed\\n\");\n+        goto detach;\n+    }\n+    (*env)->CallStaticVoidMethod(env, clazz, mid);\n+    if ((*env)->ExceptionOccurred(env)) {\n+        fprintf(stderr, \"CallStaticVoidMethod failed\\n\");\n+        goto detach;\n+    }\n+\n+  detach:\n+    res = (*vm)->DetachCurrentThread(vm);\n+    if (res != JNI_OK) {\n+        fprintf(stderr, \"DetachCurrentThread failed: %d\\n\", res);\n+    }\n+\n+    return NULL;\n+}\n+\n+JNIEXPORT void JNICALL Java_ExplicitAttach_startThreads(JNIEnv *env, jclass clazz, int n) {\n+    pthread_t tid;\n+    pthread_attr_t attr;\n+    int i;\n+\n+    pthread_attr_init(&attr);\n+    pthread_attr_setstacksize(&attr, STACK_SIZE);\n+    for (i = 0; i < n ; i++) {\n+        int res = pthread_create(&tid, &attr, thread_main, NULL);\n+        if (res != 0) {\n+            fprintf(stderr, \"pthread_create failed: %d\\n\", res);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/libExplicitAttach.c","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdio.h>\n+#include <pthread.h>\n+\n+#define STACK_SIZE 0x100000\n+\n+\/**\n+ * Creates n threads to execute the given function.\n+ *\/\n+void start_threads(int n, void *(*f)(void *)) {\n+    pthread_t tid;\n+    pthread_attr_t attr;\n+    int i;\n+\n+    pthread_attr_init(&attr);\n+    pthread_attr_setstacksize(&attr, STACK_SIZE);\n+    for (i = 0; i < n ; i++) {\n+        int res = pthread_create(&tid, &attr, f, NULL);\n+        if (res != 0) {\n+            fprintf(stderr, \"pthread_create failed: %d\\n\", res);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/libImplicitAttach.c","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}