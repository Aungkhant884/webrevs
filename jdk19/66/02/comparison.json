{"files":[{"patch":"@@ -711,1 +711,1 @@\n-  \/\/ Jump to the entry point of the i2c stub.\n+  \/\/ Jump to the entry point of the c2i stub.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1018,1 +1018,3 @@\n-                                 int& stack_slots) {\n+                                 int& stack_slots,\n+                                 int& interpreted_entry_offset,\n+                                 int& compiled_entry_offset) {\n@@ -1020,2 +1022,1 @@\n-  Address resolve(SharedRuntime::get_resolve_static_call_stub(),\n-                  relocInfo::static_call_type);\n+  Address resolve(SharedRuntime::get_resolve_static_call_stub(), relocInfo::static_call_type);\n@@ -1023,1 +1024,0 @@\n-  stack_slots = 2; \/\/ will be overwritten\n@@ -1028,1 +1028,3 @@\n-  __ enter();\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n@@ -1030,1 +1032,24 @@\n-  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ ldrw(rscratch1, Address(rthread, JavaThread::interp_only_mode_offset()));\n+    __ cbnzw(rscratch1, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ ldr(c_rarg1, Address(esp, Interpreter::stackElementSize*2));\n+    __ ldr(c_rarg2, Address(esp, Interpreter::stackElementSize*1));\n+    __ ldr(c_rarg3, Address(esp, Interpreter::stackElementSize*0));\n+    __ push_cont_fastpath(rthread);\n+\n+    __ enter();\n+    stack_slots = 2; \/\/ will be adjusted in setup\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+    \/\/ The frame is complete here, but we only record it for the compiled entry, so the frame would appear unsafe,\n+    \/\/ but that's okay because at the very worst we'll miss an async sample, but we're in interp_only_mode anyeay.\n+\n+    fill_continuation_entry(masm);\n+\n+    __ cmp(c_rarg2, (u1)0);\n+    __ br(Assembler::NE, call_thaw);\n@@ -1032,2 +1057,20 @@\n-  \/\/ Frame is now completed as far as size and linkage.\n-  frame_complete =__ pc() - start;\n+    address mark = __ pc();\n+    __ trampoline_call1(resolve, NULL, false);\n+\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ b(exit);\n+\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n+\n+  __ enter();\n+  stack_slots = 2; \/\/ will be adjusted in setup\n+  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+  frame_complete = __ pc() - start;\n@@ -1041,1 +1084,0 @@\n-\n@@ -1084,1 +1126,1 @@\n-  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n+  CompiledStaticCall::emit_to_interp_stub(*cbuf, mark);\n@@ -1174,1 +1216,1 @@\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n+    int vep_offset = 0;\n@@ -1179,0 +1221,2 @@\n+    int interpreted_entry_offset = -1;\n+    int compiled_entry_offset = -1;\n@@ -1186,1 +1230,3 @@\n-                         stack_slots);\n+                         stack_slots,\n+                         interpreted_entry_offset,\n+                         vep_offset);\n@@ -1198,1 +1244,1 @@\n-    ContinuationEntry::set_enter_code(nm);\n+    ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":59,"deletions":13,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1279,1 +1279,3 @@\n-                                 int& stack_slots) {\n+                                 int& stack_slots,\n+                                 int& interpreted_entry_offset,\n+                                 int& compiled_entry_offset) {\n@@ -1301,0 +1303,3 @@\n+  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n+                         relocInfo::static_call_type);\n+\n@@ -1303,0 +1308,55 @@\n+  Label L_thaw, L_exit;\n+\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ cmpb(Address(r15_thread, JavaThread::interp_only_mode_offset()), 0);\n+    __ jcc(Assembler::notEqual, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    __ pop(rax); \/\/ return address\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ movptr(c_rarg1, Address(rsp, Interpreter::stackElementSize*2));\n+    __ movl(c_rarg2,   Address(rsp, Interpreter::stackElementSize*1));\n+    __ movl(c_rarg3,   Address(rsp, Interpreter::stackElementSize*0));\n+    __ andptr(rsp, -16); \/\/ Ensure compiled code always sees stack at proper alignment\n+    __ push(rax); \/\/ return address\n+    __ push_cont_fastpath();\n+\n+    __ enter();\n+\n+    stack_slots = 2; \/\/ will be adjusted in setup\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+\n+    __ verify_oop(reg_cont_obj);\n+\n+    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+    \/\/ If continuation, call to thaw. Otherwise, resolve the call and exit.\n+    __ testptr(reg_is_cont, reg_is_cont);\n+    __ jcc(Assembler::notZero, L_thaw);\n+\n+    \/\/ --- Resolve path\n+\n+    \/\/ Make sure the call is patchable\n+    __ align(BytesPerWord, __ offset() + NativeCall::displacement_offset);\n+    \/\/ Emit stub for static call\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, __ pc());\n+    if (stub == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n+    __ call(resolve);\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ jmp(L_exit);\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n@@ -1315,2 +1375,0 @@\n-  Label L_thaw, L_exit;\n-\n@@ -1333,3 +1391,0 @@\n-  \/\/ Call the resolve stub\n-  AddressLiteral resolve(SharedRuntime::get_resolve_static_call_stub(),\n-                         relocInfo::static_call_type);\n@@ -1474,1 +1529,1 @@\n-    int vep_offset = ((intptr_t)__ pc()) - start;\n+    int vep_offset = 0;\n@@ -1479,0 +1534,2 @@\n+    int interpreted_entry_offset = -1;\n+    int compiled_entry_offset = -1;\n@@ -1484,1 +1541,3 @@\n-                         stack_slots);\n+                         stack_slots,\n+                         interpreted_entry_offset,\n+                         vep_offset);\n@@ -1496,1 +1555,1 @@\n-    ContinuationEntry::set_enter_code(nm);\n+    ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":68,"deletions":9,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -656,0 +657,7 @@\n+void CompiledStaticCall::compute_entry_for_continuation_entry(const methodHandle& m, StaticCallInfo& info) {\n+  if (ContinuationEntry::is_interpreted_call(instruction_address())) {\n+    info._to_interpreter = true;\n+    info._entry = m()->get_c2i_entry();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -348,0 +348,1 @@\n+  void compute_entry_for_continuation_entry(const methodHandle& m, StaticCallInfo& info);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -1331,1 +1332,1 @@\n-    mh->_i2i_entry = mh->get_i2c_entry();\n+    mh->_i2i_entry = ContinuationEntry::interpreted_entry();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -37,0 +38,2 @@\n+CompiledMethod* ContinuationEntry::_enter_special = nullptr;\n+int ContinuationEntry::_interpreted_entry_offset = 0;\n@@ -38,1 +41,1 @@\n-void ContinuationEntry::set_enter_code(CompiledMethod* cm) {\n+void ContinuationEntry::set_enter_code(CompiledMethod* cm, int interpreted_entry_offset) {\n@@ -41,0 +44,20 @@\n+\n+  _enter_special = cm;\n+  _interpreted_entry_offset = interpreted_entry_offset;\n+  assert(_enter_special->code_contains(compiled_entry()),    \"entry not in enterSpecial\");\n+  assert(_enter_special->code_contains(interpreted_entry()), \"entry not in enterSpecial\");\n+  assert(interpreted_entry() < compiled_entry(), \"unexpected code layout\");\n+}\n+\n+address ContinuationEntry::compiled_entry() {\n+  return _enter_special->verified_entry_point();\n+}\n+\n+address ContinuationEntry::interpreted_entry() {\n+  return _enter_special->code_begin() + _interpreted_entry_offset;\n+}\n+\n+bool ContinuationEntry::is_interpreted_call(address call_address) {\n+  assert(_enter_special->code_contains(call_address), \"call not in enterSpecial\");\n+  assert(call_address >= interpreted_entry(), \"unexpected location\");\n+  return call_address < compiled_entry();\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-  static void set_enter_code(CompiledMethod* nm); \/\/ friend SharedRuntime::generate_native_wrapper\n+  static void set_enter_code(CompiledMethod* cm, int interpreted_entry_offset);\n+  static bool is_interpreted_call(address call_address);\n@@ -59,0 +60,2 @@\n+  static CompiledMethod* _enter_special;\n+  static int _interpreted_entry_offset;\n@@ -92,0 +95,5 @@\n+  static address compiled_entry();\n+  static address interpreted_entry();\n+\n+  static CompiledMethod* enter_special() { return _enter_special; }\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1349,0 +1349,3 @@\n+        if (is_nmethod && caller_nm->method()->is_continuation_enter_intrinsic()) {\n+          ssc->compute_entry_for_continuation_entry(callee_method, static_call_info);\n+        }\n@@ -1563,0 +1566,1 @@\n+  bool enter_special = false;\n@@ -1566,0 +1570,9 @@\n+\n+    if (current->is_interp_only_mode()) {\n+      RegisterMap reg_map(current, false);\n+      frame stub_frame = current->last_frame();\n+      assert(stub_frame.is_runtime_frame(), \"must be a runtimeStub\");\n+      frame caller = stub_frame.sender(&reg_map);\n+      enter_special = caller.cb() != NULL && caller.cb()->is_compiled()\n+        && caller.cb()->as_compiled_method()->method()->is_continuation_enter_intrinsic();\n+    }\n@@ -1567,0 +1580,12 @@\n+\n+  if (current->is_interp_only_mode() && enter_special) {\n+    \/\/ enterSpecial is compiled and calls this method to resolve the call to Continuation::enter\n+    \/\/ but in interp_only_mode we need to go to the interpreted entry\n+    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n+    \/\/\n+    \/\/ This should probably be done in all cases, not just enterSpecial (see JDK-8218403),\n+    \/\/ but that's part of a larger fix, and the situation is worse for enterSpecial, as it has no\n+    \/\/ interpreted version.\n+    return callee_method->get_c2i_entry();\n+  }\n+\n@@ -1997,0 +2022,3 @@\n+  assert(!JavaThread::current()->is_interp_only_mode() || !nm->method()->is_continuation_enter_intrinsic()\n+    || ContinuationEntry::is_interpreted_call(return_pc), \"interp_only_mode but not in enterSpecial interpreted entry\");\n+\n@@ -2033,0 +2061,7 @@\n+      if (nm->method()->is_continuation_enter_intrinsic()) {\n+        assert(ContinuationEntry::is_interpreted_call(call->instruction_address()) == JavaThread::current()->is_interp_only_mode(),\n+          \"mode: %d\", JavaThread::current()->is_interp_only_mode());\n+        if (ContinuationEntry::is_interpreted_call(call->instruction_address())) {\n+          return;\n+        }\n+      }\n@@ -3062,1 +3097,1 @@\n-        buffer.initialize_stubs_size(64);\n+        buffer.initialize_stubs_size(128);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-\n-serviceability\/jvmti\/vthread\/ContStackDepthTest\/ContStackDepthTest.java 8288949 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}