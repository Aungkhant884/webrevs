{"files":[{"patch":"@@ -454,0 +454,13 @@\n+}\n+\n+void CompiledMethod::clear_continuation_enter_special_inline_caches() {\n+  assert (method()->is_continuation_enter_intrinsic(), \"not Continuation.enterSpecial\");\n+\n+  ResourceMark rm;\n+  CompiledICLocker ml(this);\n+  RelocIterator iter(this);\n+  while(iter.next()) {\n+    if (iter.type() == relocInfo::static_call_type) {\n+      iter.reloc()->clear_inline_cache();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -377,0 +377,1 @@\n+  void clear_continuation_enter_special_inline_caches();\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -314,0 +314,3 @@\n+  if (thread->is_interp_only_mode() && ContinuationEntry::enter_special() != nullptr) {\n+    ContinuationEntry::enter_special()->clear_continuation_enter_special_inline_caches();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+CompiledMethod* ContinuationEntry::_enter_special = nullptr;\n@@ -41,0 +42,1 @@\n+  _enter_special = cm;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-  static void set_enter_code(CompiledMethod* nm); \/\/ friend SharedRuntime::generate_native_wrapper\n+  static CompiledMethod* _enter_special;\n+  static void set_enter_code(CompiledMethod* cm); \/\/ friend SharedRuntime::generate_native_wrapper\n@@ -92,0 +93,2 @@\n+  static CompiledMethod* enter_special() { return _enter_special; }\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-  def(CompiledIC_lock              , PaddedMutex  , nosafepoint);  \/\/ locks VtableStubs_lock, InlineCacheBuffer_lock\n+  def(CompiledIC_lock              , PaddedMutex  , nosafepoint-1);  \/\/ locks VtableStubs_lock, InlineCacheBuffer_lock\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1563,0 +1563,1 @@\n+  bool enter_special = false;\n@@ -1566,0 +1567,9 @@\n+\n+    if (current->is_interp_only_mode()) {\n+      RegisterMap reg_map(current, false);\n+      frame stub_frame = current->last_frame();\n+      assert(stub_frame.is_runtime_frame(), \"must be a runtimeStub\");\n+      frame caller = stub_frame.sender(&reg_map);\n+      enter_special = caller.cb() != NULL && caller.cb()->is_compiled()\n+        && caller.cb()->as_compiled_method()->method()->is_continuation_enter_intrinsic();\n+    }\n@@ -1567,0 +1577,8 @@\n+\n+  if (current->is_interp_only_mode() && enter_special) {\n+    \/\/ enterSpecial is compiled and calls this method to resolve the call to Continuation::enter\n+    \/\/ but in interp_only_mode we need to go to the interpreted entry\n+    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n+    return callee_method->get_c2i_entry();\n+  }\n+\n@@ -1994,0 +2012,8 @@\n+  \/\/ Don't patch Continuation.enterSpecial if in interp_only mode.\n+  \/\/ It's possible that another thread that isn't interp_only will patch enterSpecial,\n+  \/\/ but we'll worry about that another time.\n+  if (nm->method()->is_continuation_enter_intrinsic()) {\n+    if (JavaThread::current()->is_interp_only_mode())\n+      return;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-\n-serviceability\/jvmti\/vthread\/ContStackDepthTest\/ContStackDepthTest.java 8288949 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}