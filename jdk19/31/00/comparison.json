{"files":[{"patch":"@@ -64,0 +64,4 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#endif\n+\n@@ -384,0 +388,8 @@\n+\n+JVM_ENTRY_NO_ENV(jboolean, jfr_is_containerized(JNIEnv* env, jobject jvm))\n+#ifdef LINUX\n+  return OSContainer::is_containerized();\n+#else\n+  return false;\n+#endif\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -161,0 +161,2 @@\n+jboolean JNICALL jfr_is_containerized(JNIEnv* env, jobject jvm);\n+\n@@ -166,1 +168,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,1 +96,2 @@\n-      (char*)\"isInstrumented\", (char*)\"(Ljava\/lang\/Class;)Z\", (void*) jfr_is_class_instrumented\n+      (char*)\"isInstrumented\", (char*)\"(Ljava\/lang\/Class;)Z\", (void*) jfr_is_class_instrumented,\n+      (char*)\"isContainerized\", (char*)\"()Z\", (void*) jfr_is_containerized\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -623,0 +623,9 @@\n+\n+    \/**\n+     * Returns {@code true}, if the JVM is running in a container, {@code false} otherwise.\n+     * <p>\n+     * If -XX:-UseContainerSupport has been specified, this method returns {@code false},\n+     * which is questionable, but Container.metrics() returns {@code null}, so events\n+     * can't be emitted anyway.\n+     *\/\n+    public native boolean isContainerized();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,0 +62,4 @@\n+                if (!Utils.shouldInstrument(clazz.getClassLoader() == null, clazz.getName())) {\n+                    Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, \"Skipping instrumentation for \" + clazz.getName() + \" since container support is missing\");\n+                    return oldBytes;\n+                }\n@@ -106,0 +110,4 @@\n+            if (!Utils.shouldInstrument(bootClassLoader,  ei.getEventName())) {\n+                Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, \"Skipping instrumentation for \" + eventName + \" since container support is missing\");\n+                return oldBytes;\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-        if (jvm.isInstrumented(eventClass)) {\n+        if (jvm.isInstrumented(eventClass) || !Utils.shouldInstrument(pe.isJDK(), pe.getName())) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-    private static Metrics[] metrics;\n@@ -701,3 +700,3 @@\n-    public static boolean shouldSkipBytecode(String eventName, Class<?> superClass) {\n-        if (superClass.getClassLoader() != null || !superClass.getName().equals(\"jdk.jfr.events.AbstractJDKEvent\")) {\n-            return false;\n+    public static boolean shouldInstrument(boolean isJDK, String name) {\n+        if (!isJDK) {\n+            return true;\n@@ -705,6 +704,3 @@\n-        return eventName.startsWith(\"jdk.Container\") && getMetrics() == null;\n-    }\n-\n-    private static Metrics getMetrics() {\n-        if (metrics == null) {\n-            metrics = new Metrics[]{Metrics.systemMetrics()};\n+        if (!name.contains(\".Container\")) {\n+            \/\/ Matched @Name(\"jdk.jfr.Container*\") or class name jdk.jfr.events.Container*\n+            return true;\n@@ -712,1 +708,1 @@\n-        return metrics[0];\n+        return JVM.getJVM().isContainerized();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -177,1 +177,9 @@\n-        containerMetrics = Container.metrics();\n+        if (JVM.getJVM().isContainerized() ) {\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"JVM is containerized\");\n+            containerMetrics = Container.metrics();\n+            if (containerMetrics != null) {\n+                Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Container metrics are available\");\n+            }\n+        }\n+        \/\/ The registration of events and hooks are needed to provide metadata,\n+        \/\/ even when not running in a container\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}