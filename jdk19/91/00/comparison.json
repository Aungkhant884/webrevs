{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.util.NoSuchElementException;\n@@ -53,1 +54,8 @@\n- *\n+ * <h2 id=\"safety\">Safety<\/h2>\n+ * The {@code nextVarg} methods used to retrieve elements from a variable argument list\n+ * will try to detect out-of-bounds reads on a best-effort basis.\n+ * <p>\n+ * In practice, whether this detection succeeds depends on the method used to create the variable argument list.\n+ * Particularly, variable argument lists created using {@link #make(Consumer, MemorySession)} are able to detect out-of-bounds reads,\n+ * while variable argument lists crearted using {@link #ofAddress(MemoryAddress, MemorySession)} are not.\n+ * <p>\n@@ -77,0 +85,1 @@\n+     * @throws NoSuchElementException if an out-of-bounds read is detected.\n@@ -90,0 +99,1 @@\n+     * @throws NoSuchElementException if an out-of-bounds read is detected.\n@@ -103,0 +113,1 @@\n+     * @throws NoSuchElementException if an out-of-bounds read is detected.\n@@ -116,0 +127,1 @@\n+     * @throws NoSuchElementException if an out-of-bounds read is detected.\n@@ -138,0 +150,1 @@\n+     * @throws NoSuchElementException if an out-of-bounds read is detected.\n@@ -149,0 +162,1 @@\n+     * @throws NoSuchElementException if an out-of-bounds read is detected.\n@@ -188,0 +202,2 @@\n+     * @implNote variable argument lists created using this method can not detect out-of-bound reads.\n+     *\n@@ -217,0 +233,2 @@\n+     * @implNote variable argument lists created using this method can detect out-of-bound reads.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import java.util.NoSuchElementException;\n@@ -385,0 +386,4 @@\n+    public static NoSuchElementException newVaListNSEE(MemoryLayout layout) {\n+        return new NoSuchElementException(\"No such element: \" + layout);\n+    }\n+\n@@ -386,1 +391,0 @@\n-        public final Class<?> carrier;\n@@ -390,2 +394,1 @@\n-        public SimpleVaArg(Class<?> carrier, MemoryLayout layout, Object value) {\n-            this.carrier = carrier;\n+        public SimpleVaArg(MemoryLayout layout, Object value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-    static final Class<?> CARRIER = MemoryAddress.class;\n-\n@@ -76,0 +74,2 @@\n+    private static final long STACK_SLOT_SIZE = 8;\n+\n@@ -104,0 +104,1 @@\n+    private MemorySegment stack;\n@@ -105,0 +106,1 @@\n+    private final long gpLimit;\n@@ -106,0 +108,1 @@\n+    private final long fpLimit;\n@@ -107,1 +110,2 @@\n-    private LinuxAArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea) {\n+    private LinuxAArch64VaList(MemorySegment segment, MemorySegment stack,\n+                               MemorySegment gpRegsArea, long gpLimit, MemorySegment fpRegsArea, long fpLimit) {\n@@ -109,0 +113,1 @@\n+        this.stack = stack;\n@@ -110,0 +115,1 @@\n+        this.gpLimit = gpLimit;\n@@ -111,0 +117,1 @@\n+        this.fpLimit = fpLimit;\n@@ -114,0 +121,3 @@\n+        MemorySegment stack = MemorySegment.ofAddress(stackPtr(segment),\n+                Long.MAX_VALUE, segment.session()); \/\/ size unknown\n+\n@@ -119,1 +129,1 @@\n-        return new LinuxAArch64VaList(segment, gpRegsArea, fpRegsArea);\n+        return new LinuxAArch64VaList(segment, stack, gpRegsArea, MAX_GP_OFFSET, fpRegsArea, MAX_FP_OFFSET);\n@@ -168,1 +178,1 @@\n-    private MemoryAddress stackPtr() {\n+    private static MemoryAddress stackPtr(MemorySegment segment) {\n@@ -172,2 +182,7 @@\n-    private void stackPtr(MemoryAddress ptr) {\n-        VH_stack.set(segment, ptr);\n+    private MemoryAddress stackPtr() {\n+        return stackPtr(segment);\n+    }\n+\n+    private void setStack(MemorySegment newStack) {\n+        stack = newStack;\n+        VH_stack.set(segment, stack.address());\n@@ -202,3 +217,5 @@\n-    private void preAlignStack(MemoryLayout layout) {\n-        if (layout.byteAlignment() > 8) {\n-            stackPtr(Utils.alignUp(stackPtr(), 16));\n+    private long preAlignOffset(MemoryLayout layout) {\n+        long alignmentOffset = 0;\n+        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n+            long addr = stack.address().toRawLongValue();\n+            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n@@ -206,0 +223,5 @@\n+        return alignmentOffset;\n+    }\n+\n+    private void preAlignStack(MemoryLayout layout) {\n+        setStack(stack.asSlice(preAlignOffset(layout)));\n@@ -209,1 +231,1 @@\n-        stackPtr(Utils.alignUp(stackPtr().addOffset(layout.byteSize()), 8));\n+        setStack(stack.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n@@ -214,1 +236,1 @@\n-        return (int) read(int.class, layout);\n+        return (int) read(layout);\n@@ -219,1 +241,1 @@\n-        return (long) read(long.class, layout);\n+        return (long) read(layout);\n@@ -224,1 +246,1 @@\n-        return (double) read(double.class, layout);\n+        return (double) read(layout);\n@@ -229,1 +251,1 @@\n-        return (MemoryAddress) read(MemoryAddress.class, layout);\n+        return (MemoryAddress) read(layout);\n@@ -235,1 +257,1 @@\n-        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n+        return (MemorySegment) read( layout, allocator);\n@@ -238,2 +260,2 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout) {\n-        return read(carrier, layout, THROWING_ALLOCATOR);\n+    private Object read(MemoryLayout layout) {\n+        return read(layout, THROWING_ALLOCATOR);\n@@ -242,1 +264,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n+    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n@@ -246,0 +268,1 @@\n+            checkStackElement(layout);\n@@ -249,1 +272,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), session());\n+                    MemorySegment slice = stack.asSlice(0, layout.byteSize());\n@@ -257,1 +280,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), session());\n+                    MemorySegment slice = stack.asSlice(0, layout.byteSize());\n@@ -266,0 +289,1 @@\n+                    checkGPElement(layout, numSlots(layout));\n@@ -278,0 +302,1 @@\n+                    checkFPElement(layout, numSlots(layout));\n@@ -293,0 +318,1 @@\n+                    checkGPElement(layout, 1);\n@@ -305,0 +331,1 @@\n+                    checkGPElement(layout, 1);\n@@ -311,0 +338,1 @@\n+                    checkFPElement(layout, 1);\n@@ -320,0 +348,18 @@\n+    private void checkGPElement(MemoryLayout layout, long slots) {\n+        if ((grOffs() + MAX_GP_OFFSET) + (slots * GP_SLOT_SIZE) > gpLimit) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n+    }\n+\n+    private void checkFPElement(MemoryLayout layout, long slots) {\n+        if ((vrOffs() + MAX_FP_OFFSET) + (slots * FP_SLOT_SIZE) > fpLimit) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n+    }\n+\n+    private void checkStackElement(MemoryLayout layout) {\n+        if (preAlignOffset(layout) + layout.byteSize() > stack.byteSize()) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n+    }\n+\n@@ -328,0 +374,1 @@\n+                checkStackElement(layout);\n@@ -331,1 +378,3 @@\n-                consumeFPSlots(numSlots(layout));\n+                long slots = numSlots(layout);\n+                checkFPElement(layout, slots);\n+                consumeFPSlots((int) slots);\n@@ -333,0 +382,1 @@\n+                checkGPElement(layout, 1);\n@@ -335,1 +385,3 @@\n-                consumeGPSlots(numSlots(layout));\n+                long slots = numSlots(layout);\n+                checkGPElement(layout, slots);\n+                consumeGPSlots((int) slots);\n@@ -362,1 +414,1 @@\n-        return new LinuxAArch64VaList(copy, gpRegsArea, fpRegsArea);\n+        return new LinuxAArch64VaList(copy, stack, gpRegsArea, gpLimit, fpRegsArea, fpLimit);\n@@ -370,2 +422,2 @@\n-    private static int numSlots(MemoryLayout layout) {\n-        return (int) Utils.alignUp(layout.byteSize(), 8) \/ 8;\n+    private static long numSlots(MemoryLayout layout) {\n+        return Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE) \/ STACK_SLOT_SIZE;\n@@ -413,1 +465,1 @@\n-            return arg(int.class, layout, value);\n+            return arg(layout, value);\n@@ -418,1 +470,1 @@\n-            return arg(long.class, layout, value);\n+            return arg(layout, value);\n@@ -423,1 +475,1 @@\n-            return arg(double.class, layout, value);\n+            return arg(layout, value);\n@@ -428,1 +480,1 @@\n-            return arg(MemoryAddress.class, layout, value.address());\n+            return arg(layout, value.address());\n@@ -433,1 +485,1 @@\n-            return arg(MemorySegment.class, layout, value);\n+            return arg(layout, value);\n@@ -436,1 +488,1 @@\n-        private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {\n+        private Builder arg(MemoryLayout layout, Object value) {\n@@ -441,1 +493,1 @@\n-                stackArgs.add(new SimpleVaArg(carrier, layout, value));\n+                stackArgs.add(new SimpleVaArg(layout, value));\n@@ -503,1 +555,1 @@\n-            MemoryAddress stackArgsPtr = MemoryAddress.NULL;\n+            MemorySegment stackArgsSegment;\n@@ -506,3 +558,3 @@\n-                    .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);\n-                MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);\n-                stackArgsPtr = stackArgsSegment.address();\n+                    .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), STACK_SLOT_SIZE), Long::sum);\n+                stackArgsSegment = allocator.allocate(stackArgsSize, 16);\n+                MemorySegment writeCursor = stackArgsSegment;\n@@ -510,2 +562,2 @@\n-                    final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);\n-                    stackArgsSegment = Utils.alignUp(stackArgsSegment, alignedSize);\n+                    final long alignedSize = Utils.alignUp(arg.layout.byteSize(), STACK_SLOT_SIZE);\n+                    writeCursor = Utils.alignUp(writeCursor, alignedSize);\n@@ -513,2 +565,2 @@\n-                    writer.set(stackArgsSegment, arg.value);\n-                    stackArgsSegment = stackArgsSegment.asSlice(alignedSize);\n+                    writer.set(writeCursor, arg.value);\n+                    writeCursor = writeCursor.asSlice(alignedSize);\n@@ -516,0 +568,2 @@\n+            } else {\n+                stackArgsSegment = MemorySegment.ofAddress(MemoryAddress.NULL, 0, session);\n@@ -520,1 +574,1 @@\n-            VH_stack.set(vaListSegment, stackArgsPtr);\n+            VH_stack.set(vaListSegment, stackArgsSegment.address());\n@@ -526,1 +580,1 @@\n-            return new LinuxAArch64VaList(vaListSegment, gpRegs, fpRegs);\n+            return new LinuxAArch64VaList(vaListSegment, stackArgsSegment, gpRegs, currentGPOffset, fpRegs, currentFPOffset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":97,"deletions":43,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-    public static final Class<?> CARRIER = MemoryAddress.class;\n@@ -69,1 +68,1 @@\n-        return (int) read(int.class, layout);\n+        return (int) read(layout);\n@@ -74,1 +73,1 @@\n-        return (long) read(long.class, layout);\n+        return (long) read(layout);\n@@ -79,1 +78,1 @@\n-        return (double) read(double.class, layout);\n+        return (double) read(layout);\n@@ -84,1 +83,1 @@\n-        return (MemoryAddress) read(MemoryAddress.class, layout);\n+        return (MemoryAddress) read(layout);\n@@ -90,1 +89,1 @@\n-        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n+        return (MemorySegment) read(layout, allocator);\n@@ -93,2 +92,2 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout) {\n-        return read(carrier, layout, SharedUtils.THROWING_ALLOCATOR);\n+    private Object read(MemoryLayout layout) {\n+        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n@@ -97,1 +96,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n+    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n@@ -100,1 +99,1 @@\n-        if (carrier == MemorySegment.class) {\n+        if (layout instanceof GroupLayout) {\n@@ -104,0 +103,1 @@\n+                    checkElement(layout, VA_SLOT_SIZE_BYTES);\n@@ -112,0 +112,2 @@\n+                    long size = alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+                    checkElement(layout, size);\n@@ -114,1 +116,1 @@\n-                    segment = segment.asSlice(alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES));\n+                    segment = segment.asSlice(size);\n@@ -120,0 +122,1 @@\n+            checkElement(layout, VA_SLOT_SIZE_BYTES);\n@@ -127,0 +130,7 @@\n+    private static long sizeOf(MemoryLayout layout) {\n+        return switch (TypeClass.classifyLayout(layout)) {\n+            case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+            default -> VA_SLOT_SIZE_BYTES;\n+        };\n+    }\n+\n@@ -134,4 +144,9 @@\n-            segment = segment.asSlice(switch (TypeClass.classifyLayout(layout)) {\n-                case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n-                default -> VA_SLOT_SIZE_BYTES;\n-            });\n+            long size = sizeOf(layout);\n+            checkElement(layout, size);\n+            segment = segment.asSlice(size);\n+        }\n+    }\n+\n+    private void checkElement(MemoryLayout layout, long size) {\n+        if (segment.byteSize() < size) {\n+            throw SharedUtils.newVaListNSEE(layout);\n@@ -181,1 +196,1 @@\n-        private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {\n+        private Builder arg(MemoryLayout layout, Object value) {\n@@ -184,1 +199,1 @@\n-            args.add(new SimpleVaArg(carrier, layout, value));\n+            args.add(new SimpleVaArg(layout, value));\n@@ -190,1 +205,1 @@\n-            return arg(int.class, layout, value);\n+            return arg(layout, value);\n@@ -195,1 +210,1 @@\n-            return arg(long.class, layout, value);\n+            return arg(layout, value);\n@@ -200,1 +215,1 @@\n-            return arg(double.class, layout, value);\n+            return arg(layout, value);\n@@ -205,1 +220,1 @@\n-            return arg(MemoryAddress.class, layout, value.address());\n+            return arg(layout, value.address());\n@@ -210,1 +225,1 @@\n-            return arg(MemorySegment.class, layout, value);\n+            return arg(layout, value);\n@@ -220,5 +235,2 @@\n-            \/\/ Each argument may occupy up to four slots\n-            MemorySegment segment = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size() * 4);\n-\n-            List<MemorySegment> attachedSegments = new ArrayList<>();\n-            attachedSegments.add(segment);\n+            long allocationSize = args.stream().reduce(0L, (acc, e) -> acc + sizeOf(e.layout), Long::sum);\n+            MemorySegment segment = allocator.allocate(allocationSize);\n@@ -228,1 +240,1 @@\n-                if (arg.carrier == MemorySegment.class) {\n+                if (arg.layout instanceof GroupLayout) {\n@@ -235,1 +247,0 @@\n-                            attachedSegments.add(copy);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":40,"deletions":29,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-    static final Class<?> CARRIER = MemoryAddress.class;\n-\n@@ -69,0 +67,2 @@\n+    private static final long STACK_SLOT_SIZE = 8;\n+\n@@ -115,0 +115,1 @@\n+    private MemorySegment overflowArgArea;\n@@ -116,0 +117,2 @@\n+    private final long gpLimit;\n+    private final long fpLimit;\n@@ -117,1 +120,3 @@\n-    private SysVVaList(MemorySegment segment, MemorySegment regSaveArea) {\n+    private SysVVaList(MemorySegment segment,\n+                       MemorySegment overflowArgArea,\n+                       MemorySegment regSaveArea, long gpLimit, long fpLimit) {\n@@ -119,0 +124,1 @@\n+        this.overflowArgArea = overflowArgArea;\n@@ -120,0 +126,2 @@\n+        this.gpLimit = gpLimit;\n+        this.fpLimit = fpLimit;\n@@ -124,1 +132,2 @@\n-        return new SysVVaList(segment, regSaveArea);\n+        MemorySegment overflowArgArea = getArgOverflowArea(segment);\n+        return new SysVVaList(segment, overflowArgArea, regSaveArea, MAX_GP_OFFSET, MAX_FP_OFFSET);\n@@ -160,2 +169,3 @@\n-    private MemoryAddress stackPtr() {\n-        return (MemoryAddress) VH_overflow_arg_area.get(segment);\n+    private static MemorySegment getRegSaveArea(MemorySegment segment) {\n+        return MemorySegment.ofAddress(((MemoryAddress)VH_reg_save_area.get(segment)),\n+                LAYOUT_REG_SAVE_AREA.byteSize(), segment.session());\n@@ -164,2 +174,3 @@\n-    private void stackPtr(MemoryAddress ptr) {\n-        VH_overflow_arg_area.set(segment, ptr);\n+    private static MemorySegment getArgOverflowArea(MemorySegment segment) {\n+        return MemorySegment.ofAddress(((MemoryAddress)VH_overflow_arg_area.get(segment)),\n+                Long.MAX_VALUE, segment.session()); \/\/ size unknown\n@@ -168,2 +179,7 @@\n-    private MemorySegment regSaveArea() {\n-        return getRegSaveArea(segment);\n+    private long preAlignOffset(MemoryLayout layout) {\n+        long alignmentOffset = 0;\n+        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n+            long addr = overflowArgArea.address().toRawLongValue();\n+            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n+        }\n+        return alignmentOffset;\n@@ -172,3 +188,3 @@\n-    private static MemorySegment getRegSaveArea(MemorySegment segment) {\n-        return MemorySegment.ofAddress(((MemoryAddress)VH_reg_save_area.get(segment)),\n-                LAYOUT_REG_SAVE_AREA.byteSize(), segment.session());\n+    private void setOverflowArgArea(MemorySegment newSegment) {\n+        overflowArgArea = newSegment;\n+        VH_overflow_arg_area.set(segment, overflowArgArea.address());\n@@ -178,3 +194,1 @@\n-        if (layout.byteAlignment() > 8) {\n-            stackPtr(Utils.alignUp(stackPtr(), 16));\n-        }\n+        setOverflowArgArea(overflowArgArea.asSlice(preAlignOffset(layout)));\n@@ -184,1 +198,1 @@\n-        stackPtr(Utils.alignUp(stackPtr().addOffset(layout.byteSize()), 8));\n+        setOverflowArgArea(overflowArgArea.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n@@ -189,1 +203,1 @@\n-        return (int) read(int.class, layout);\n+        return (int) read(layout);\n@@ -194,1 +208,1 @@\n-        return (long) read(long.class, layout);\n+        return (long) read(layout);\n@@ -199,1 +213,1 @@\n-        return (double) read(double.class, layout);\n+        return (double) read(layout);\n@@ -204,1 +218,1 @@\n-        return (MemoryAddress) read(MemoryAddress.class, layout);\n+        return (MemoryAddress) read(layout);\n@@ -210,1 +224,1 @@\n-        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n+        return (MemorySegment) read(layout, allocator);\n@@ -213,2 +227,2 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout) {\n-        return read(carrier, layout, THROWING_ALLOCATOR);\n+    private Object read(MemoryLayout layout) {\n+        return read(layout, THROWING_ALLOCATOR);\n@@ -217,1 +231,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n+    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n@@ -222,0 +236,1 @@\n+            checkStackElement(layout);\n@@ -225,1 +240,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), session());\n+                    MemorySegment slice = overflowArgArea.asSlice(0, layout.byteSize());\n@@ -233,6 +248,4 @@\n-                    try (MemorySession localSession = MemorySession.openConfined()) {\n-                        MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), localSession);\n-                        Object res = reader.get(slice);\n-                        postAlignStack(layout);\n-                        yield res;\n-                    }\n+                    MemorySegment slice = overflowArgArea.asSlice(0, layout.byteSize());\n+                    Object res = reader.get(slice);\n+                    postAlignStack(layout);\n+                    yield res;\n@@ -242,0 +255,1 @@\n+            checkRegAreaElement(layout, typeClass);\n@@ -277,0 +291,16 @@\n+    private void checkRegAreaElement(MemoryLayout layout, TypeClass typeClass) {\n+        long gpSize = typeClass.nIntegerRegs() * GP_SLOT_SIZE;\n+        long fpSize = typeClass.nVectorRegs() * FP_SLOT_SIZE;\n+        if (currentGPOffset() + gpSize > gpLimit\n+            || currentFPOffset() + fpSize > fpLimit) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n+    }\n+\n+    private void checkStackElement(MemoryLayout layout) {\n+        long offset = preAlignOffset(layout);\n+        if (offset + layout.byteSize() > overflowArgArea.byteSize()) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n+    }\n+\n@@ -285,0 +315,1 @@\n+                checkStackElement(layout);\n@@ -288,0 +319,1 @@\n+                checkRegAreaElement(layout, typeClass);\n@@ -316,1 +348,1 @@\n-        return new SysVVaList(copy, regSaveArea);\n+        return new SysVVaList(copy, overflowArgArea, regSaveArea, gpLimit, fpLimit);\n@@ -334,2 +366,2 @@\n-               + \", overflow_arg_area=\" + stackPtr()\n-               + \", reg_save_area=\" + regSaveArea()\n+               + \", overflow_arg_area=\" + overflowArgArea\n+               + \", reg_save_area=\" + regSaveArea\n@@ -353,1 +385,1 @@\n-            return arg(int.class, layout, value);\n+            return arg(layout, value);\n@@ -358,1 +390,1 @@\n-            return arg(long.class, layout, value);\n+            return arg(layout, value);\n@@ -363,1 +395,1 @@\n-            return arg(double.class, layout, value);\n+            return arg(layout, value);\n@@ -368,1 +400,1 @@\n-            return arg(MemoryAddress.class, layout, value.address());\n+            return arg(layout, value.address());\n@@ -373,1 +405,1 @@\n-            return arg(MemorySegment.class, layout, value);\n+            return arg(layout, value);\n@@ -376,1 +408,1 @@\n-        private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {\n+        private Builder arg(MemoryLayout layout, Object value) {\n@@ -383,1 +415,1 @@\n-                stackArgs.add(new SimpleVaArg(carrier, layout, value));\n+                stackArgs.add(new SimpleVaArg(layout, value));\n@@ -429,1 +461,1 @@\n-            MemoryAddress stackArgsPtr = MemoryAddress.NULL;\n+            MemorySegment stackArgsSegment;\n@@ -431,3 +463,4 @@\n-                long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -> acc + e.layout.byteSize(), Long::sum);\n-                MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);\n-                MemorySegment maOverflowArgArea = stackArgsSegment;\n+                long stackArgsSize = stackArgs.stream().reduce(0L,\n+                        (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), STACK_SLOT_SIZE), Long::sum);\n+                stackArgsSegment = allocator.allocate(stackArgsSize, 16);\n+                MemorySegment writeCursor = stackArgsSegment;\n@@ -436,1 +469,1 @@\n-                        maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));\n+                        writeCursor = Utils.alignUp(writeCursor, Math.min(16, arg.layout.byteSize()));\n@@ -439,1 +472,1 @@\n-                        maOverflowArgArea.copyFrom((MemorySegment) arg.value);\n+                        writeCursor.copyFrom((MemorySegment) arg.value);\n@@ -442,1 +475,1 @@\n-                        writer.set(maOverflowArgArea, arg.value);\n+                        writer.set(writeCursor, arg.value);\n@@ -444,1 +477,1 @@\n-                    maOverflowArgArea = maOverflowArgArea.asSlice(arg.layout.byteSize());\n+                    writeCursor = writeCursor.asSlice(Utils.alignUp(arg.layout.byteSize(), STACK_SLOT_SIZE));\n@@ -446,1 +479,2 @@\n-                stackArgsPtr = stackArgsSegment.address();\n+            } else {\n+                stackArgsSegment = MemorySegment.ofAddress(MemoryAddress.NULL, 0, session);\n@@ -450,1 +484,1 @@\n-            VH_overflow_arg_area.set(vaListSegment, stackArgsPtr);\n+            VH_overflow_arg_area.set(vaListSegment, stackArgsSegment.address());\n@@ -453,1 +487,1 @@\n-            return new SysVVaList(vaListSegment, reg_save_area);\n+            return new SysVVaList(vaListSegment, stackArgsSegment, reg_save_area, currentGPOffset, currentFPOffset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":87,"deletions":53,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    public static final Class<?> CARRIER = MemoryAddress.class;\n@@ -80,1 +79,1 @@\n-        return (int) read(int.class, layout);\n+        return (int) read(layout);\n@@ -85,1 +84,1 @@\n-        return (long) read(long.class, layout);\n+        return (long) read(layout);\n@@ -90,1 +89,1 @@\n-        return (double) read(double.class, layout);\n+        return (double) read(layout);\n@@ -95,1 +94,1 @@\n-        return (MemoryAddress) read(MemoryAddress.class, layout);\n+        return (MemoryAddress) read(layout);\n@@ -101,1 +100,1 @@\n-        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n+        return (MemorySegment) read(layout, allocator);\n@@ -104,2 +103,2 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout) {\n-        return read(carrier, layout, SharedUtils.THROWING_ALLOCATOR);\n+    private Object read(MemoryLayout layout) {\n+        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n@@ -108,1 +107,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n+    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n@@ -111,1 +110,2 @@\n-        if (carrier == MemorySegment.class) {\n+        checkElement(layout);\n+        if (layout instanceof GroupLayout) {\n@@ -133,0 +133,6 @@\n+    private void checkElement(MemoryLayout layout) {\n+        if (segment.byteSize() < VA_SLOT_SIZE_BYTES) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n+    }\n+\n@@ -137,2 +143,5 @@\n-        Stream.of(layouts).forEach(Objects::requireNonNull);\n-        segment = segment.asSlice(layouts.length * VA_SLOT_SIZE_BYTES);\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            checkElement(layout);\n+            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+        }\n@@ -181,1 +190,1 @@\n-        private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {\n+        private Builder arg(MemoryLayout layout, Object value) {\n@@ -184,1 +193,1 @@\n-            args.add(new SimpleVaArg(carrier, layout, value));\n+            args.add(new SimpleVaArg(layout, value));\n@@ -190,1 +199,1 @@\n-            return arg(int.class, layout, value);\n+            return arg(layout, value);\n@@ -195,1 +204,1 @@\n-            return arg(long.class, layout, value);\n+            return arg(layout, value);\n@@ -200,1 +209,1 @@\n-            return arg(double.class, layout, value);\n+            return arg(layout, value);\n@@ -205,1 +214,1 @@\n-            return arg(MemoryAddress.class, layout, value.address());\n+            return arg(layout, value.address());\n@@ -210,1 +219,1 @@\n-            return arg(MemorySegment.class, layout, value);\n+            return arg(layout, value);\n@@ -219,2 +228,0 @@\n-            List<MemorySegment> attachedSegments = new ArrayList<>();\n-            attachedSegments.add(segment);\n@@ -224,1 +231,1 @@\n-                if (arg.carrier == MemorySegment.class) {\n+                if (arg.layout instanceof GroupLayout) {\n@@ -231,1 +238,0 @@\n-                            attachedSegments.add(copy);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":29,"deletions":23,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import java.util.List;\n+import java.util.NoSuchElementException;\n@@ -63,0 +65,3 @@\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n@@ -64,0 +69,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n@@ -66,0 +72,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -135,1 +142,1 @@\n-            = (builder, session) -> Windowsx64Linker.newVaList(builder, session);\n+            = Windowsx64Linker::newVaList;\n@@ -137,1 +144,1 @@\n-            = (builder, session) -> SysVx64Linker.newVaList(builder, session);\n+            = SysVx64Linker::newVaList;\n@@ -139,1 +146,1 @@\n-            = (builder, session) -> LinuxAArch64Linker.newVaList(builder, session);\n+            = LinuxAArch64Linker::newVaList;\n@@ -141,1 +148,1 @@\n-            = (builder, session) -> MacOsAArch64Linker.newVaList(builder, session);\n+            = MacOsAArch64Linker::newVaList;\n@@ -143,1 +150,1 @@\n-            = (builder, session) -> VaList.make(builder, session);\n+            = VaList::make;\n@@ -818,0 +825,83 @@\n+\n+    @DataProvider\n+    public static Object[][] overflow() {\n+        List<Function<Consumer<VaList.Builder>, VaList>> factories = List.of(\n+            winVaListFactory,\n+            sysvVaListFactory,\n+            linuxAArch64VaListFactory,\n+            macAArch64VaListFactory\n+        );\n+        List<List<MemoryLayout>> contentsCases = List.of(\n+            List.of(JAVA_INT),\n+            List.of(JAVA_LONG),\n+            List.of(JAVA_DOUBLE),\n+            List.of(ADDRESS),\n+            List.of(JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG,\n+                    JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG,\n+                    JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE,\n+                    JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE,\n+                    JAVA_INT, JAVA_LONG, JAVA_DOUBLE, ADDRESS)\n+        );\n+        List<MemoryLayout> overflowCases = List.of(\n+            JAVA_INT,\n+            JAVA_LONG,\n+            JAVA_DOUBLE,\n+            ADDRESS\n+        );\n+        return factories.stream()\n+                .<Object[]>mapMulti((factory, sink) -> {\n+                    for (List<MemoryLayout> content : contentsCases) {\n+                        for (MemoryLayout overflow : overflowCases) {\n+                            sink.accept(new Object[]{ factory, content, overflow });\n+                        }\n+                    }\n+                })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    private static void buildVaList(VaList.Builder builder, List<MemoryLayout> contents) {\n+        for (MemoryLayout layout : contents) {\n+            if (layout instanceof ValueLayout.OfInt ofInt) {\n+                 builder.addVarg(ofInt, 1);\n+            } else if (layout instanceof ValueLayout.OfLong ofLong) {\n+                 builder.addVarg(ofLong, 1L);\n+            } else if (layout instanceof ValueLayout.OfDouble ofDouble) {\n+                 builder.addVarg(ofDouble, 1D);\n+            } else if (layout instanceof ValueLayout.OfAddress ofAddress) {\n+                 builder.addVarg(ofAddress, MemoryAddress.ofLong(1));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"overflow\")\n+    public void testSkipOverflow(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n+                                 List<MemoryLayout> contents,\n+                                 MemoryLayout skipped) {\n+        VaList vaList = vaListFactory.apply(b -> buildVaList(b, contents));\n+        vaList.skip(contents.toArray(MemoryLayout[]::new));\n+        assertThrows(NoSuchElementException.class, () -> vaList.skip(skipped));\n+    }\n+\n+    private static void nextVarg(VaList vaList, MemoryLayout layout) {\n+        if (layout instanceof ValueLayout.OfInt ofInt) {\n+            assertEquals(vaList.nextVarg(ofInt), 1);\n+        } else if (layout instanceof ValueLayout.OfLong ofLong) {\n+            assertEquals(vaList.nextVarg(ofLong), 1L);\n+        } else if (layout instanceof ValueLayout.OfDouble ofDouble) {\n+            assertEquals(vaList.nextVarg(ofDouble), 1D);\n+        } else if (layout instanceof ValueLayout.OfAddress ofAddress) {\n+            assertEquals(vaList.nextVarg(ofAddress), MemoryAddress.ofLong(1));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"overflow\")\n+    public void testVargOverflow(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n+                                 List<MemoryLayout> contents,\n+                                 MemoryLayout next) {\n+        VaList vaList = vaListFactory.apply(b -> buildVaList(b, contents));\n+        for (MemoryLayout layout : contents) {\n+            nextVarg(vaList, layout);\n+        }\n+        assertThrows(NoSuchElementException.class, () -> nextVarg(vaList, next));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":95,"deletions":5,"binary":false,"changes":100,"status":"modified"}]}