{"files":[{"patch":"@@ -38,1 +38,1 @@\n-the same object.\"  Accordingly, object _references_ (like other values) can be\n+the same object?\"  Accordingly, object _references_ (like other values) can be\n@@ -52,1 +52,1 @@\n-| Default value is zero                      | Default value is null              |\n+| Default value is zero                      | Default value is `null`            |\n@@ -62,1 +62,1 @@\n-races; primitives allow tearing under race for larger-than-32-bit values.  \n+races; primitives allow tearing under race for larger-than-32-bit values.\n@@ -146,1 +146,1 @@\n-value is null, and loads and stores of references are atomic even in the\n+value is `null`, and loads and stores of references are atomic even in the\n@@ -259,2 +259,2 @@\n-    operation on `Object`, weak references become almost useless, as every class\n-    that wants to maintain some sort of weak data structure would have to\n+    operation on `Object`, weak references would become almost useless, as every\n+    class that wants to maintain some sort of weak data structure would have to\n@@ -272,1 +272,1 @@\n-    serialization, are consistent with those after deserialization.\n+    serialization are consistent with those after deserialization.\n@@ -278,1 +278,1 @@\n-we introduce two restricted interfaces `IdentityObject` and `ValueObject`.\n+we introduce two restricted interfaces, `IdentityObject` and `ValueObject`.\n@@ -290,1 +290,1 @@\n-as well as statically reflecting the requirement for identity in variable types\n+It also statically reflects the requirement for identity in variable types\n@@ -308,1 +308,1 @@\n-extend it directly or indirectly, but itself is (currently) an identity class,\n+extend it directly or indirectly, but it itself is (currently) an identity class,\n@@ -338,1 +338,1 @@\n-same runtime behavior as the basic primitives (`int`, `double`, etc.)\n+same runtime behavior as the basic primitives (`int`, `double`, etc.).\n@@ -361,2 +361,2 @@\n-A primitive class declaration is subject to the same constraints as for value\n-classes (e.g., the instance fields are implicitly `final`). Additionally,\n+A primitive class declaration is subject to the same constraints as value\n+class declarations (e.g., the instance fields are implicitly `final`). Additionally,\n@@ -504,1 +504,1 @@\n-primitive types (such as complex numbers, 2D points, half-floats, etc.)\n+primitive types (such as complex numbers, 2D points, half-floats, etc.).\n@@ -587,1 +587,1 @@\n-   value.  We can capture the \"`V` or null\" requirement by changing the\n+   value.  We can capture the \"`V` or `null`\" requirement by changing the\n@@ -662,1 +662,1 @@\n-| Not nullable; default value is zero | Nullable; default value is null    |\n+| Not nullable; default value is zero | Nullable; default value is `null`  |\n@@ -687,1 +687,1 @@\n- - Use identity classes when we need mutability, layout extension, or locking;\n+ - Use identity classes when we need mutability, layout extension, or locking.\n@@ -690,1 +690,1 @@\n-   cross-field invariants; \n+   cross-field invariants.\n@@ -695,2 +695,3 @@\n- - The `P.ref` reference type for a primitive recovers the benefits of\n-   a value class.\n+\n+ - Remember that the `P.ref` reference type for a primitive recovers the\n+   benefits of a value class.\n@@ -702,0 +703,1 @@\n+\n@@ -704,0 +706,1 @@\n+\n","filename":"site\/design-notes\/state-of-valhalla\/02-object-model.md","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"}]}