{"files":[{"patch":"@@ -61,1 +61,1 @@\n-    private boolean sendHeader = true;\n+    private boolean sendHeader = false;\n@@ -230,1 +230,1 @@\n-            if (isFragmentedMP4()) {\n+            if (currentPlaylist.isFragmentedMP4()) {\n@@ -271,1 +271,1 @@\n-            if (isFragmentedMP4()) {\n+            if (currentPlaylist.isFragmentedMP4()) {\n@@ -277,4 +277,0 @@\n-    private boolean isFragmentedMP4() {\n-        return (currentPlaylist.getMimeType() == HLS_VALUE_MIMETYPE_FMP4);\n-    }\n-\n@@ -403,1 +399,4 @@\n-                if (isFragmentedMP4()) {\n+                \/\/ If we have playlist with fMP4, set flag to add header\n+                \/\/ to first data segment and adjust index to 0\n+                if (currentPlaylist.isFragmentedMP4()) {\n+                    sendHeader = true;\n@@ -757,0 +756,1 @@\n+        private double startTime = 0.0;\n@@ -811,0 +811,4 @@\n+        private boolean isFragmentedMP4() {\n+            return (getMimeType() == HLS_VALUE_MIMETYPE_FMP4);\n+        }\n+\n@@ -857,2 +861,12 @@\n-                    mediaFilesStartTimes.add(this.duration);\n-                    this.duration += duration;\n+                    mediaFilesStartTimes.add(this.startTime);\n+                    this.startTime += duration;\n+\n+                    \/\/ For fragmented MP4 we should not add duration of first\n+                    \/\/ segment, since it is header without actuall data.\n+                    if (mediaFiles.size() == 1) {\n+                        if (!isFragmentedMP4()) {\n+                            this.duration += duration;\n+                        }\n+                    } else {\n+                        this.duration += duration;\n+                    }\n@@ -888,1 +902,1 @@\n-                if ((mediaFileIndex) < mediaFiles.size()) {\n+                if (mediaFileIndex < mediaFiles.size()) {\n@@ -915,1 +929,5 @@\n-            return mediaFilesStartTimes.get(mediaFileIndex);\n+            if (mediaFileIndex < mediaFiles.size()) {\n+                return mediaFilesStartTimes.get(mediaFileIndex);\n+            }\n+\n+            return 0.0;\n","filename":"modules\/javafx.media\/src\/main\/java\/com\/sun\/media\/jfxmedia\/locator\/HLSConnectionHolder.java","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n+        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_HOOKS,\n@@ -237,1 +237,1 @@\n-        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n+        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_HOOKS,\n@@ -247,1 +247,1 @@\n-        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n+        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_HOOKS,\n@@ -258,1 +258,1 @@\n-        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n+        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_HOOKS,\n@@ -269,1 +269,1 @@\n-        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n+        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_HOOKS,\n@@ -279,1 +279,1 @@\n-        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n+        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_HOOKS,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/javasource\/javasource.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,7 +42,0 @@\n-enum\n-{\n-    HLS_FORMAT_UNKNOWN = 0x0,\n-    HLS_FORMAT_MP2T,\n-    HLS_FORMAT_FMP4\n-};\n-\n@@ -53,2 +46,0 @@\n-    gint          hls_format;\n-\n@@ -174,2 +165,0 @@\n-    element->hls_format = HLS_FORMAT_FMP4;\n-\n@@ -531,0 +520,1 @@\n+                element->send_new_segment = FALSE;\n@@ -533,2 +523,0 @@\n-                if (segment.start != 0)\n-                  element->send_new_segment = FALSE;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/progressbuffer\/hlsprogressbuffer.c","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+    m_FirstPTS = GST_CLOCK_TIME_NONE;\n@@ -323,0 +324,12 @@\n+    \/\/ Update PTS in pBuffer, so first buffer starts with 0. Our rendering\n+    \/\/ code expects PTS between 0 and duration and will not render anything\n+    \/\/ beyond duration. For fragmented MP4 PTS starts with N value (usually 10\n+    \/\/ seconds) and last PTS will be duration + N.\n+    if (pPipeline->m_FirstPTS != GST_CLOCK_TIME_NONE &&\n+            GST_BUFFER_TIMESTAMP_IS_VALID (pBuffer) &&\n+            GST_BUFFER_TIMESTAMP(pBuffer) >= pPipeline->m_FirstPTS)\n+    {\n+        GST_BUFFER_TIMESTAMP(pBuffer) =\n+            GST_BUFFER_TIMESTAMP(pBuffer) - pPipeline->m_FirstPTS;\n+    }\n+\n@@ -382,0 +395,6 @@\n+    if (pPipeline->m_FirstPTS == GST_CLOCK_TIME_NONE &&\n+            GST_BUFFER_TIMESTAMP_IS_VALID(pBuffer))\n+    {\n+        pPipeline->m_FirstPTS = GST_BUFFER_TIMESTAMP(pBuffer);\n+    }\n+\n@@ -388,0 +407,8 @@\n+        if (pPipeline->m_FirstPTS != GST_CLOCK_TIME_NONE &&\n+                GST_BUFFER_TIMESTAMP_IS_VALID (pBuffer) &&\n+                GST_BUFFER_TIMESTAMP(pBuffer) >= pPipeline->m_FirstPTS)\n+        {\n+            GST_BUFFER_TIMESTAMP(pBuffer) =\n+                GST_BUFFER_TIMESTAMP(pBuffer) - pPipeline->m_FirstPTS;\n+        }\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAVPlaybackPipeline.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,1 @@\n+    GstClockTime            m_FirstPTS;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAVPlaybackPipeline.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}