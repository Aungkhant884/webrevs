{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,11 +160,0 @@\n-    \/**\n-     * Get stream size.\n-     * Behavior can vary based on subclass implementation.\n-     * For example HLS will load next segment and return segment size.\n-     *\n-     * @return - Stream size.\n-     *\/\n-    int getStreamSize() {\n-        return -1;\n-    }\n-\n","filename":"modules\/javafx.media\/src\/main\/java\/com\/sun\/media\/jfxmedia\/locator\/ConnectionHolder.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,5 @@\n-import java.net.*;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLConnection;\n@@ -46,0 +50,2 @@\n+    private URLConnection headerConnection = null;\n+    private ReadableByteChannel headerChannel = null;\n@@ -55,0 +61,1 @@\n+    private boolean sendHeader = true;\n@@ -59,0 +66,3 @@\n+    private static final int HLS_PROP_LOAD_SEGMENT = 4;\n+    private static final int HLS_PROP_SEGMENT_START_TIME = 5;\n+    private static final int HLS_VALUE_MIMETYPE_UNKNOWN = -1;\n@@ -61,0 +71,2 @@\n+    private static final int HLS_VALUE_MIMETYPE_FMP4 = 3;\n+    private static final int HLS_VALUE_MIMETYPE_AAC = 4;\n@@ -80,0 +92,13 @@\n+        if (headerChannel != null) {\n+            buffer.rewind();\n+            if (buffer.limit() < buffer.capacity()) {\n+                buffer.limit(buffer.capacity());\n+            }\n+            int read = headerChannel.read(buffer);\n+            if (read == -1) {\n+                resetHeaderConnection();\n+            } else {\n+                return read;\n+            }\n+        }\n+\n@@ -90,0 +115,1 @@\n+    @Override\n@@ -94,0 +120,1 @@\n+    @Override\n@@ -98,0 +125,1 @@\n+    @Override\n@@ -102,0 +130,1 @@\n+    @Override\n@@ -106,0 +135,1 @@\n+    @Override\n@@ -109,1 +139,1 @@\n-        } catch (Exception e) {\n+        } catch (InterruptedException e) {\n@@ -128,1 +158,1 @@\n-        } catch (Exception e) {\n+        } catch (InterruptedException e) {\n@@ -132,17 +162,13 @@\n-        if (prop == HLS_PROP_GET_DURATION) {\n-            return (int) (currentPlaylist.getDuration() * HLS_VALUE_FLOAT_MULTIPLIER);\n-        } else if (prop == HLS_PROP_GET_HLS_MODE) {\n-            return 1;\n-        } else if (prop == HLS_PROP_GET_MIMETYPE) {\n-            return currentPlaylist.getMimeType();\n-        }\n-\n-        return -1;\n-    }\n-\n-    @Override\n-    int getStreamSize() {\n-        try {\n-            readySignal.await();\n-        } catch (Exception e) {\n-            return -1;\n+        switch (prop) {\n+            case HLS_PROP_GET_DURATION:\n+                return (int)(currentPlaylist.getDuration() * HLS_VALUE_FLOAT_MULTIPLIER);\n+            case HLS_PROP_GET_HLS_MODE:\n+                return 1;\n+            case HLS_PROP_GET_MIMETYPE:\n+                return currentPlaylist.getMimeType();\n+            case HLS_PROP_LOAD_SEGMENT:\n+                return loadNextSegment();\n+            case HLS_PROP_SEGMENT_START_TIME:\n+                return (int)(currentPlaylist.getMediaFileStartTime() * HLS_VALUE_FLOAT_MULTIPLIER);\n+            default:\n+                return -1;\n@@ -150,2 +176,0 @@\n-\n-        return loadNextSegment();\n@@ -157,0 +181,2 @@\n+        resetHeaderConnection();\n+\n@@ -161,0 +187,15 @@\n+    private void resetHeaderConnection() {\n+        try {\n+            if (headerChannel != null) {\n+                headerChannel.close();\n+            }\n+        } catch (IOException ioex) {}\n+        finally {\n+            headerChannel = null;\n+        }\n+\n+        Locator.closeConnection(headerConnection);\n+        headerConnection = null;\n+    }\n+\n+\n@@ -162,1 +203,1 @@\n-    \/\/ Returns positive size of segment if no isssues.\n+    \/\/ Returns positive size of segment if no issues.\n@@ -167,1 +208,21 @@\n-        String mediaFile = currentPlaylist.getNextMediaFile();\n+        String mediaFile;\n+        int headerLength = 0;\n+\n+        if (sendHeader) {\n+            mediaFile = currentPlaylist.getHeaderFile();\n+            if (mediaFile == null) {\n+                return -1;\n+            }\n+\n+            try {\n+                URI uri = new URI(mediaFile);\n+                headerConnection = uri.toURL().openConnection();\n+                headerChannel = openHeaderChannel();\n+                headerLength = headerConnection.getContentLength();\n+            } catch (IOException | URISyntaxException e) {\n+                return -1;\n+            }\n+            sendHeader = false;\n+        }\n+\n+        mediaFile = currentPlaylist.getNextMediaFile();\n@@ -169,0 +230,3 @@\n+            if (isFragmentedMP4()) {\n+                sendHeader = true;\n+            }\n@@ -176,1 +240,1 @@\n-        } catch (Exception e) {\n+        } catch (IOException | URISyntaxException e) {\n@@ -181,1 +245,1 @@\n-            return (-1 * urlConnection.getContentLength());\n+            return (-1 * (urlConnection.getContentLength() + headerLength));\n@@ -183,1 +247,1 @@\n-            return urlConnection.getContentLength();\n+            return (urlConnection.getContentLength() + headerLength);\n@@ -191,0 +255,4 @@\n+    private ReadableByteChannel openHeaderChannel() throws IOException {\n+        return Channels.newChannel(headerConnection.getInputStream());\n+    }\n+\n@@ -203,0 +271,3 @@\n+            if (isFragmentedMP4()) {\n+                sendHeader = true;\n+            }\n@@ -206,0 +277,4 @@\n+    private boolean isFragmentedMP4() {\n+        return (currentPlaylist.getMimeType() == HLS_VALUE_MIMETYPE_FMP4);\n+    }\n+\n@@ -219,1 +294,1 @@\n-        private BlockingQueue<Integer> stateQueue = new LinkedBlockingQueue<Integer>();\n+        private final BlockingQueue<Integer> stateQueue = new LinkedBlockingQueue<>();\n@@ -258,1 +333,1 @@\n-                } catch (Exception e) {\n+                } catch (InterruptedException e) {\n@@ -277,2 +352,3 @@\n-            PlaylistParser parser = new PlaylistParser();\n-            parser.load(playlistURI);\n+            try {\n+                PlaylistParser parser = new PlaylistParser();\n+                parser.load(playlistURI);\n@@ -280,2 +356,2 @@\n-            if (parser.isVariantPlaylist()) {\n-                variantPlaylist = new VariantPlaylist(playlistURI);\n+                if (parser.isVariantPlaylist()) {\n+                    variantPlaylist = new VariantPlaylist(playlistURI);\n@@ -283,10 +359,0 @@\n-                while (parser.hasNext()) {\n-                    variantPlaylist.addPlaylistInfo(parser.getString(), parser.getInteger());\n-                }\n-            } else {\n-                if (currentPlaylist == null) {\n-                    currentPlaylist = new Playlist(parser.isLivePlaylist(), parser.getTargetDuration());\n-                    currentPlaylist.setPlaylistURI(playlistURI);\n-                }\n-\n-                if (currentPlaylist.setSequenceNumber(parser.getSequenceNumber())) {\n@@ -294,1 +360,16 @@\n-                        currentPlaylist.addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());\n+                        variantPlaylist.addPlaylistInfo(parser.getString(), parser.getInteger());\n+                    }\n+                } else {\n+                    if (currentPlaylist == null) {\n+                        currentPlaylist = new Playlist(parser.isLivePlaylist(), parser.getTargetDuration());\n+                        currentPlaylist.setPlaylistURI(playlistURI);\n+                    }\n+\n+                    if (currentPlaylist.setSequenceNumber(parser.getSequenceNumber())) {\n+                        while (parser.hasNext()) {\n+                            currentPlaylist.addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());\n+                        }\n+                    }\n+\n+                    if (variantPlaylist != null) {\n+                        variantPlaylist.addPlaylist(currentPlaylist);\n@@ -298,0 +379,1 @@\n+                \/\/ Update variant playlists\n@@ -299,1 +381,8 @@\n-                    variantPlaylist.addPlaylist(currentPlaylist);\n+                    while (variantPlaylist.hasNext()) {\n+                        try {\n+                            currentPlaylist = new Playlist(variantPlaylist.getPlaylistURI());\n+                            currentPlaylist.update(null);\n+                            variantPlaylist.addPlaylist(currentPlaylist);\n+                        } catch (URISyntaxException | MalformedURLException e) {\n+                        }\n+                    }\n@@ -301,1 +390,0 @@\n-            }\n@@ -303,10 +391,4 @@\n-            \/\/ Update variant playlists\n-            if (variantPlaylist != null) {\n-                while (variantPlaylist.hasNext()) {\n-                    try {\n-                        currentPlaylist = new Playlist(variantPlaylist.getPlaylistURI());\n-                        currentPlaylist.update(null);\n-                        variantPlaylist.addPlaylist(currentPlaylist);\n-                    } catch (URISyntaxException e) {\n-                    } catch (MalformedURLException e) {\n-                    }\n+                \/\/ Always start with first data playlist\n+                if (variantPlaylist != null) {\n+                    currentPlaylist = variantPlaylist.getPlaylist(0);\n+                    isBitrateAdjustable = true;\n@@ -314,1 +396,0 @@\n-            }\n@@ -316,5 +397,5 @@\n-            \/\/ Always start with first data playlist\n-            if (variantPlaylist != null) {\n-                currentPlaylist = variantPlaylist.getPlaylist(0);\n-                isBitrateAdjustable = true;\n-            }\n+                \/\/ Start reloading live playlist\n+                if (currentPlaylist.isLive()) {\n+                    setReloadPlaylist(currentPlaylist);\n+                    putState(STATE_RELOAD_PLAYLIST);\n+                }\n@@ -322,4 +403,6 @@\n-            \/\/ Start reloading live playlist\n-            if (currentPlaylist.isLive()) {\n-                setReloadPlaylist(currentPlaylist);\n-                putState(STATE_RELOAD_PLAYLIST);\n+                if (isFragmentedMP4()) {\n+                    mediaFileIndex = 0;\n+                }\n+            } catch (Exception e) {\n+            } finally {\n+                readySignal.countDown();\n@@ -327,2 +410,0 @@\n-\n-            readySignal.countDown();\n@@ -361,4 +442,4 @@\n-        private List<String> dataListString = new ArrayList<String>();\n-        private List<Integer> dataListInteger = new ArrayList<Integer>();\n-        private List<Double> dataListDouble = new ArrayList<Double>();\n-        private List<Boolean> dataListBoolean = new ArrayList<Boolean>();\n+        private List<String> dataListString = new ArrayList<>();\n+        private List<Integer> dataListInteger = new ArrayList<>();\n+        private List<Double> dataListDouble = new ArrayList<>();\n+        private List<Boolean> dataListBoolean = new ArrayList<>();\n@@ -419,5 +500,4 @@\n-            if (dataListString.size() > dataListIndex || dataListInteger.size() > dataListIndex || dataListDouble.size() > dataListIndex || dataListBoolean.size() > dataListIndex) {\n-                return true;\n-            } else {\n-                return false;\n-            }\n+            return dataListString.size() > dataListIndex ||\n+                    dataListInteger.size() > dataListIndex ||\n+                    dataListDouble.size() > dataListIndex ||\n+                    dataListBoolean.size() > dataListIndex;\n@@ -517,0 +597,22 @@\n+            } else if (line.startsWith(\"#EXT-X-MAP\")) {\n+                String[] s1 = line.split(\":\");\n+                if (s1.length == 2 && s1[1].length() > 0) {\n+                    String[] s2 = s1[1].split(\",\");\n+                    if (s2.length > 0) {\n+                        for (int i = 0; i < s2.length; i++) {\n+                            s2[i] = s2[i].trim();\n+                            if (s2[i].startsWith(\"URI\")) {\n+                                String[] s3 = s2[i].split(\"=\");\n+                                if (s3.length == 2 && s3[1].length() > 0) {\n+                                    String dataFile =\n+                                            s3[1].replaceAll(\"^\\\"+|\\\"+$\", \"\");\n+                                    dataListString.add(dataFile);\n+                                    \/\/ GStreamer expects start of stream to be\n+                                    \/\/ discontinuity.\n+                                    dataListBoolean.add(true);\n+                                    dataListDouble.add(Double.valueOf(targetDuration));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n@@ -521,4 +623,8 @@\n-                isLineMediaFileURI = false;\n-                dataListString.add(line);\n-                dataListBoolean.add(isDiscontinuity);\n-                isDiscontinuity = false;\n+                \/\/ We can have additional tags after #EXTINF such as\n+                \/\/ #EXT-X-BITRATE for fMP4 playlist, so ignore them.\n+                if (!line.startsWith(\"#\")) {\n+                    isLineMediaFileURI = false;\n+                    dataListString.add(line);\n+                    dataListBoolean.add(isDiscontinuity);\n+                    isDiscontinuity = false;\n+                }\n@@ -549,3 +655,3 @@\n-        private List<String> playlistsLocations = new ArrayList<String>();\n-        private List<Integer> playlistsBitrates = new ArrayList<Integer>();\n-        private List<Playlist> playlists = new ArrayList<Playlist>();\n+        private List<String> playlistsLocations = new ArrayList<>();\n+        private List<Integer> playlistsBitrates = new ArrayList<>();\n+        private List<Playlist> playlists = new ArrayList<>();\n@@ -587,5 +693,2 @@\n-            if (playlistsLocations.size() > infoIndex && playlistsBitrates.size() > infoIndex) {\n-                return true;\n-            } else {\n-                return false;\n-            }\n+            return playlistsLocations.size() > infoIndex &&\n+                    playlistsBitrates.size() > infoIndex;\n@@ -650,3 +753,3 @@\n-        private List<String> mediaFiles = new ArrayList<String>();\n-        private List<Double> mediaFilesStartTimes = new ArrayList<Double>();\n-        private List<Boolean> mediaFilesDiscontinuities = new ArrayList<Boolean>();\n+        private final List<String> mediaFiles = new ArrayList<>();\n+        private final List<Double> mediaFilesStartTimes = new ArrayList<>();\n+        private final List<Boolean> mediaFilesDiscontinuities = new ArrayList<>();\n@@ -660,0 +763,1 @@\n+        private int mimeType = HLS_VALUE_MIMETYPE_UNKNOWN;\n@@ -797,0 +901,18 @@\n+        private String getHeaderFile() {\n+            synchronized (lock) {\n+                if (mediaFiles.size() > 0) {\n+                    if (baseURI != null) {\n+                        return baseURI + mediaFiles.get(0);\n+                    } else {\n+                        return mediaFiles.get(0);\n+                    }\n+                } else {\n+                    return null;\n+                }\n+            }\n+        }\n+\n+        private double getMediaFileStartTime() {\n+            return mediaFilesStartTimes.get(mediaFileIndex);\n+        }\n+\n@@ -818,1 +940,6 @@\n-                        mediaFileIndex = -1;\n+                        if (isFragmentedMP4()) {\n+                            mediaFileIndex = 0; \/\/ Skip header at 0 index\n+                            \/\/ we will send it with first segment if needed.\n+                        } else {\n+                            mediaFileIndex = -1;\n+                        }\n@@ -834,1 +961,5 @@\n-                                    mediaFileIndex = index - 1; \/\/ Seek will load segment and increment mediaFileIndex\n+                                    if (isFragmentedMP4()) {\n+                                        mediaFileIndex = index;\n+                                    } else {\n+                                        mediaFileIndex = index - 1; \/\/ Seek will load segment and increment mediaFileIndex\n+                                    }\n@@ -839,1 +970,5 @@\n-                                    mediaFileIndex = index - 1; \/\/ Seek will load segment and increment mediaFileIndex\n+                                    if (isFragmentedMP4()) {\n+                                        mediaFileIndex = index;\n+                                    } else {\n+                                        mediaFileIndex = index - 1; \/\/ Seek will load segment and increment mediaFileIndex\n+                                    }\n@@ -855,5 +990,12 @@\n-                if (mediaFiles.size() > 0) {\n-                    if (stripParameters(mediaFiles.get(0)).endsWith(\".ts\")) {\n-                        return HLS_VALUE_MIMETYPE_MP2T;\n-                    } else if (stripParameters(mediaFiles.get(0)).endsWith(\".mp3\")) {\n-                        return HLS_VALUE_MIMETYPE_MP3;\n+                if (mimeType == HLS_VALUE_MIMETYPE_UNKNOWN) {\n+                    if (mediaFiles.size() > 0) {\n+                        if (stripParameters(mediaFiles.get(0)).endsWith(\".ts\")) {\n+                            mimeType = HLS_VALUE_MIMETYPE_MP2T;\n+                        } else if (stripParameters(mediaFiles.get(0)).endsWith(\".mp3\")) {\n+                            mimeType = HLS_VALUE_MIMETYPE_MP3;\n+                        } else if (stripParameters(mediaFiles.get(0)).endsWith(\".mp4\")\n+                                || stripParameters(mediaFiles.get(0)).endsWith(\".m4s\")) {\n+                            mimeType = HLS_VALUE_MIMETYPE_FMP4;\n+                        } else if (stripParameters(mediaFiles.get(0)).endsWith(\".aac\")) {\n+                            mimeType = HLS_VALUE_MIMETYPE_AAC;\n+                        }\n@@ -864,1 +1006,1 @@\n-            return -1;\n+            return mimeType;\n","filename":"modules\/javafx.media\/src\/main\/java\/com\/sun\/media\/jfxmedia\/locator\/HLSConnectionHolder.java","additions":244,"deletions":102,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,8 @@\n+<tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audiovisual)<\/td><td>H.264\/AVC<\/td>\n+    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+<tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audiovisual)<\/td><td>H.265\/HEVC<\/td>\n+    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+<tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audio-only)<\/td><td>N\/A<\/td>\n+    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+<tr><th scope=\"row\">HLS (*)<\/th><td>AAC HTTP Live Streaming (audio-only)<\/td><td>N\/A<\/td>\n+    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n","filename":"modules\/javafx.media\/src\/main\/java\/javafx\/scene\/media\/package.html","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,1674 @@\n+\/* GStreamer AAC parser plugin\n+ * Copyright (C) 2008 Nokia Corporation. All rights reserved.\n+ *\n+ * Contact: Stefan Kost <stefan.kost@nokia.com>\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+\/**\n+ * SECTION:element-aacparse\n+ * @title: aacparse\n+ * @short_description: AAC parser\n+ * @see_also: #GstAmrParse\n+ *\n+ * This is an AAC parser which handles both ADIF and ADTS stream formats.\n+ *\n+ * As ADIF format is not framed, it is not seekable and stream duration cannot\n+ * be determined either. However, ADTS format AAC clips can be seeked, and parser\n+ * can also estimate playback position and clip duration.\n+ *\n+ * ## Example launch line\n+ * |[\n+ * gst-launch-1.0 filesrc location=abc.aac ! aacparse ! faad ! audioresample ! audioconvert ! alsasink\n+ * ]|\n+ *\n+ *\/\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#include <string.h>\n+\n+#include <gst\/base\/gstbitreader.h>\n+#include <gst\/pbutils\/pbutils.h>\n+#include \"gstaacparse.h\"\n+\n+\n+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE (\"src\",\n+    GST_PAD_SRC,\n+    GST_PAD_ALWAYS,\n+    GST_STATIC_CAPS (\"audio\/mpeg, \"\n+        \"framed = (boolean) true, \" \"mpegversion = (int) { 2, 4 }, \"\n+        \"stream-format = (string) { raw, adts, adif, loas };\"));\n+\n+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE (\"sink\",\n+    GST_PAD_SINK,\n+    GST_PAD_ALWAYS,\n+    GST_STATIC_CAPS (\"audio\/mpeg, mpegversion = (int) { 2, 4 };\"));\n+\n+GST_DEBUG_CATEGORY_STATIC (aacparse_debug);\n+#define GST_CAT_DEFAULT aacparse_debug\n+\n+\n+#define ADIF_MAX_SIZE 40        \/* Should be enough *\/\n+#define ADTS_MAX_SIZE 10        \/* Should be enough *\/\n+#define LOAS_MAX_SIZE 3         \/* Should be enough *\/\n+#define RAW_MAX_SIZE  1         \/* Correct framing is required *\/\n+\n+#define ADTS_HEADERS_LENGTH 7UL \/* Total byte-length of fixed and variable\n+                                   headers prepended during raw to ADTS\n+                                   conversion *\/\n+\n+#define AAC_FRAME_DURATION(parse) (GST_SECOND\/parse->frames_per_sec)\n+\n+static const gint loas_sample_rate_table[16] = {\n+  96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,\n+  16000, 12000, 11025, 8000, 7350, 0, 0, 0\n+};\n+\n+static const gint loas_channels_table[16] = {\n+  0, 1, 2, 3, 4, 5, 6, 8,\n+  0, 0, 0, 7, 8, 0, 8, 0\n+};\n+\n+static gboolean gst_aac_parse_start (GstBaseParse * parse);\n+static gboolean gst_aac_parse_stop (GstBaseParse * parse);\n+\n+static gboolean gst_aac_parse_sink_setcaps (GstBaseParse * parse,\n+    GstCaps * caps);\n+static GstCaps *gst_aac_parse_sink_getcaps (GstBaseParse * parse,\n+    GstCaps * filter);\n+\n+static GstFlowReturn gst_aac_parse_handle_frame (GstBaseParse * parse,\n+    GstBaseParseFrame * frame, gint * skipsize);\n+static GstFlowReturn gst_aac_parse_pre_push_frame (GstBaseParse * parse,\n+    GstBaseParseFrame * frame);\n+static gboolean gst_aac_parse_src_event (GstBaseParse * parse,\n+    GstEvent * event);\n+\n+static gboolean gst_aac_parse_read_audio_specific_config (GstAacParse *\n+    aacparse, GstBitReader * br, gint * object_type, gint * sample_rate,\n+    gint * channels, gint * frame_samples);\n+\n+\n+#define gst_aac_parse_parent_class parent_class\n+G_DEFINE_TYPE (GstAacParse, gst_aac_parse, GST_TYPE_BASE_PARSE);\n+\n+\/**\n+ * gst_aac_parse_class_init:\n+ * @klass: #GstAacParseClass.\n+ *\n+ *\/\n+static void\n+gst_aac_parse_class_init (GstAacParseClass * klass)\n+{\n+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);\n+  GstBaseParseClass *parse_class = GST_BASE_PARSE_CLASS (klass);\n+\n+  GST_DEBUG_CATEGORY_INIT (aacparse_debug, \"aacparse\", 0,\n+      \"AAC audio stream parser\");\n+\n+  gst_element_class_add_static_pad_template (element_class, &sink_template);\n+  gst_element_class_add_static_pad_template (element_class, &src_template);\n+\n+  gst_element_class_set_static_metadata (element_class,\n+      \"AAC audio stream parser\", \"Codec\/Parser\/Audio\",\n+      \"Advanced Audio Coding parser\", \"Stefan Kost <stefan.kost@nokia.com>\");\n+\n+  parse_class->start = GST_DEBUG_FUNCPTR (gst_aac_parse_start);\n+  parse_class->stop = GST_DEBUG_FUNCPTR (gst_aac_parse_stop);\n+  parse_class->set_sink_caps = GST_DEBUG_FUNCPTR (gst_aac_parse_sink_setcaps);\n+  parse_class->get_sink_caps = GST_DEBUG_FUNCPTR (gst_aac_parse_sink_getcaps);\n+  parse_class->handle_frame = GST_DEBUG_FUNCPTR (gst_aac_parse_handle_frame);\n+  parse_class->pre_push_frame =\n+      GST_DEBUG_FUNCPTR (gst_aac_parse_pre_push_frame);\n+  parse_class->src_event = GST_DEBUG_FUNCPTR (gst_aac_parse_src_event);\n+}\n+\n+\n+\/**\n+ * gst_aac_parse_init:\n+ * @aacparse: #GstAacParse.\n+ * @klass: #GstAacParseClass.\n+ *\n+ *\/\n+static void\n+gst_aac_parse_init (GstAacParse * aacparse)\n+{\n+  GST_DEBUG (\"initialized\");\n+  GST_PAD_SET_ACCEPT_INTERSECT (GST_BASE_PARSE_SINK_PAD (aacparse));\n+  GST_PAD_SET_ACCEPT_TEMPLATE (GST_BASE_PARSE_SINK_PAD (aacparse));\n+\n+  aacparse->last_parsed_sample_rate = 0;\n+  aacparse->last_parsed_channels = 0;\n+}\n+\n+\n+\/**\n+ * gst_aac_parse_set_src_caps:\n+ * @aacparse: #GstAacParse.\n+ * @sink_caps: (proposed) caps of sink pad\n+ *\n+ * Set source pad caps according to current knowledge about the\n+ * audio stream.\n+ *\n+ * Returns: TRUE if caps were successfully set.\n+ *\/\n+static gboolean\n+gst_aac_parse_set_src_caps (GstAacParse * aacparse, GstCaps * sink_caps)\n+{\n+  GstStructure *s;\n+  GstCaps *src_caps = NULL, *peercaps;\n+  gboolean res = FALSE;\n+  const gchar *stream_format;\n+  guint8 codec_data[2];\n+  guint16 codec_data_data;\n+  gint sample_rate_idx;\n+\n+  GST_DEBUG_OBJECT (aacparse, \"sink caps: %\" GST_PTR_FORMAT, sink_caps);\n+  if (sink_caps)\n+    src_caps = gst_caps_copy (sink_caps);\n+  else\n+    src_caps = gst_caps_new_empty_simple (\"audio\/mpeg\");\n+\n+  gst_caps_set_simple (src_caps, \"framed\", G_TYPE_BOOLEAN, TRUE,\n+      \"mpegversion\", G_TYPE_INT, aacparse->mpegversion, NULL);\n+\n+  aacparse->output_header_type = aacparse->header_type;\n+  switch (aacparse->header_type) {\n+    case DSPAAC_HEADER_NONE:\n+      stream_format = \"raw\";\n+      break;\n+    case DSPAAC_HEADER_ADTS:\n+      stream_format = \"adts\";\n+      break;\n+    case DSPAAC_HEADER_ADIF:\n+      stream_format = \"adif\";\n+      break;\n+    case DSPAAC_HEADER_LOAS:\n+      stream_format = \"loas\";\n+      break;\n+    default:\n+      stream_format = NULL;\n+  }\n+\n+  \/* Generate codec data to be able to set profile\/level on the caps *\/\n+  sample_rate_idx =\n+      gst_codec_utils_aac_get_index_from_sample_rate (aacparse->sample_rate);\n+  if (sample_rate_idx < 0)\n+    goto not_a_known_rate;\n+  codec_data_data =\n+      (aacparse->object_type << 11) |\n+      (sample_rate_idx << 7) | (aacparse->channels << 3);\n+  GST_WRITE_UINT16_BE (codec_data, codec_data_data);\n+  gst_codec_utils_aac_caps_set_level_and_profile (src_caps, codec_data, 2);\n+\n+  s = gst_caps_get_structure (src_caps, 0);\n+  if (aacparse->sample_rate > 0)\n+    gst_structure_set (s, \"rate\", G_TYPE_INT, aacparse->sample_rate, NULL);\n+  if (aacparse->channels > 0)\n+    gst_structure_set (s, \"channels\", G_TYPE_INT, aacparse->channels, NULL);\n+  if (stream_format)\n+    gst_structure_set (s, \"stream-format\", G_TYPE_STRING, stream_format, NULL);\n+\n+  peercaps = gst_pad_peer_query_caps (GST_BASE_PARSE_SRC_PAD (aacparse), NULL);\n+  if (peercaps && !gst_caps_can_intersect (src_caps, peercaps)) {\n+    GST_DEBUG_OBJECT (GST_BASE_PARSE (aacparse)->srcpad,\n+        \"Caps can not intersect\");\n+    if (aacparse->header_type == DSPAAC_HEADER_ADTS) {\n+      GST_DEBUG_OBJECT (GST_BASE_PARSE (aacparse)->srcpad,\n+          \"Input is ADTS, trying raw\");\n+      gst_caps_set_simple (src_caps, \"stream-format\", G_TYPE_STRING, \"raw\",\n+          NULL);\n+      if (gst_caps_can_intersect (src_caps, peercaps)) {\n+        GstBuffer *codec_data_buffer;\n+\n+        GST_DEBUG_OBJECT (GST_BASE_PARSE (aacparse)->srcpad,\n+            \"Caps can intersect, we will drop the ADTS layer\");\n+        aacparse->output_header_type = DSPAAC_HEADER_NONE;\n+\n+        \/* The codec_data data is according to AudioSpecificConfig,\n+           ISO\/IEC 14496-3, 1.6.2.1 *\/\n+        codec_data_buffer = gst_buffer_new_and_alloc (2);\n+        gst_buffer_fill (codec_data_buffer, 0, codec_data, 2);\n+        gst_caps_set_simple (src_caps, \"codec_data\", GST_TYPE_BUFFER,\n+            codec_data_buffer, NULL);\n+        gst_buffer_unref (codec_data_buffer);\n+      }\n+    } else if (aacparse->header_type == DSPAAC_HEADER_NONE) {\n+      GST_DEBUG_OBJECT (GST_BASE_PARSE (aacparse)->srcpad,\n+          \"Input is raw, trying ADTS\");\n+      gst_caps_set_simple (src_caps, \"stream-format\", G_TYPE_STRING, \"adts\",\n+          NULL);\n+      if (gst_caps_can_intersect (src_caps, peercaps)) {\n+        GST_DEBUG_OBJECT (GST_BASE_PARSE (aacparse)->srcpad,\n+            \"Caps can intersect, we will prepend ADTS headers\");\n+        aacparse->output_header_type = DSPAAC_HEADER_ADTS;\n+      }\n+    }\n+  }\n+  if (peercaps)\n+    gst_caps_unref (peercaps);\n+\n+  aacparse->last_parsed_channels = 0;\n+  aacparse->last_parsed_sample_rate = 0;\n+\n+  GST_DEBUG_OBJECT (aacparse, \"setting src caps: %\" GST_PTR_FORMAT, src_caps);\n+\n+  res = gst_pad_set_caps (GST_BASE_PARSE (aacparse)->srcpad, src_caps);\n+  gst_caps_unref (src_caps);\n+  return res;\n+\n+not_a_known_rate:\n+  GST_ERROR_OBJECT (aacparse, \"Not a known sample rate: %d\",\n+      aacparse->sample_rate);\n+  gst_caps_unref (src_caps);\n+  return FALSE;\n+}\n+\n+\n+\/**\n+ * gst_aac_parse_sink_setcaps:\n+ * @sinkpad: GstPad\n+ * @caps: GstCaps\n+ *\n+ * Implementation of \"set_sink_caps\" vmethod in #GstBaseParse class.\n+ *\n+ * Returns: TRUE on success.\n+ *\/\n+static gboolean\n+gst_aac_parse_sink_setcaps (GstBaseParse * parse, GstCaps * caps)\n+{\n+  GstAacParse *aacparse;\n+  GstStructure *structure;\n+  gchar *caps_str;\n+  const GValue *value;\n+\n+  aacparse = GST_AAC_PARSE (parse);\n+  structure = gst_caps_get_structure (caps, 0);\n+  caps_str = gst_caps_to_string (caps);\n+\n+  GST_DEBUG_OBJECT (aacparse, \"setcaps: %s\", caps_str);\n+  g_free (caps_str);\n+\n+  \/* This is needed at least in case of RTP\n+   * Parses the codec_data information to get ObjectType,\n+   * number of channels and samplerate *\/\n+  value = gst_structure_get_value (structure, \"codec_data\");\n+  if (value) {\n+    GstBuffer *buf = gst_value_get_buffer (value);\n+\n+    if (buf && gst_buffer_get_size (buf) >= 2) {\n+      GstMapInfo map;\n+      GstBitReader br;\n+\n+      if (!gst_buffer_map (buf, &map, GST_MAP_READ))\n+        return FALSE;\n+      gst_bit_reader_init (&br, map.data, map.size);\n+      gst_aac_parse_read_audio_specific_config (aacparse, &br,\n+          &aacparse->object_type, &aacparse->sample_rate, &aacparse->channels,\n+          &aacparse->frame_samples);\n+\n+      aacparse->header_type = DSPAAC_HEADER_NONE;\n+      aacparse->mpegversion = 4;\n+      gst_buffer_unmap (buf, &map);\n+\n+      GST_DEBUG (\"codec_data: object_type=%d, sample_rate=%d, channels=%d, \"\n+          \"samples=%d\", aacparse->object_type, aacparse->sample_rate,\n+          aacparse->channels, aacparse->frame_samples);\n+\n+      \/* arrange for metadata and get out of the way *\/\n+      gst_aac_parse_set_src_caps (aacparse, caps);\n+      if (aacparse->header_type == aacparse->output_header_type)\n+        gst_base_parse_set_passthrough (parse, TRUE);\n+\n+      \/* input is already correctly framed *\/\n+      gst_base_parse_set_min_frame_size (parse, RAW_MAX_SIZE);\n+    } else {\n+      return FALSE;\n+    }\n+\n+    \/* caps info overrides *\/\n+    gst_structure_get_int (structure, \"rate\", &aacparse->sample_rate);\n+    gst_structure_get_int (structure, \"channels\", &aacparse->channels);\n+  } else {\n+    const gchar *stream_format =\n+        gst_structure_get_string (structure, \"stream-format\");\n+\n+    if (g_strcmp0 (stream_format, \"raw\") == 0) {\n+      GST_ERROR_OBJECT (parse, \"Need codec_data for raw AAC\");\n+      return FALSE;\n+    } else {\n+      aacparse->sample_rate = 0;\n+      aacparse->channels = 0;\n+      aacparse->header_type = DSPAAC_HEADER_NOT_PARSED;\n+      gst_base_parse_set_passthrough (parse, FALSE);\n+    }\n+  }\n+  return TRUE;\n+}\n+\n+\n+\/**\n+ * gst_aac_parse_adts_get_frame_len:\n+ * @data: block of data containing an ADTS header.\n+ *\n+ * This function calculates ADTS frame length from the given header.\n+ *\n+ * Returns: size of the ADTS frame.\n+ *\/\n+static inline guint\n+gst_aac_parse_adts_get_frame_len (const guint8 * data)\n+{\n+  return ((data[3] & 0x03) << 11) | (data[4] << 3) | ((data[5] & 0xe0) >> 5);\n+}\n+\n+\n+\/**\n+ * gst_aac_parse_check_adts_frame:\n+ * @aacparse: #GstAacParse.\n+ * @data: Data to be checked.\n+ * @avail: Amount of data passed.\n+ * @framesize: If valid ADTS frame was found, this will be set to tell the\n+ *             found frame size in bytes.\n+ * @needed_data: If frame was not found, this may be set to tell how much\n+ *               more data is needed in the next round to detect the frame\n+ *               reliably. This may happen when a frame header candidate\n+ *               is found but it cannot be guaranteed to be the header without\n+ *               peeking the following data.\n+ *\n+ * Check if the given data contains contains ADTS frame. The algorithm\n+ * will examine ADTS frame header and calculate the frame size. Also, another\n+ * consecutive ADTS frame header need to be present after the found frame.\n+ * Otherwise the data is not considered as a valid ADTS frame. However, this\n+ * \"extra check\" is omitted when EOS has been received. In this case it is\n+ * enough when data[0] contains a valid ADTS header.\n+ *\n+ * This function may set the #needed_data to indicate that a possible frame\n+ * candidate has been found, but more data (#needed_data bytes) is needed to\n+ * be absolutely sure. When this situation occurs, FALSE will be returned.\n+ *\n+ * When a valid frame is detected, this function will use\n+ * gst_base_parse_set_min_frame_size() function from #GstBaseParse class\n+ * to set the needed bytes for next frame.This way next data chunk is already\n+ * of correct size.\n+ *\n+ * Returns: TRUE if the given data contains a valid ADTS header.\n+ *\/\n+static gboolean\n+gst_aac_parse_check_adts_frame (GstAacParse * aacparse,\n+    const guint8 * data, const guint avail, gboolean drain,\n+    guint * framesize, guint * needed_data)\n+{\n+  guint crc_size;\n+\n+  *needed_data = 0;\n+\n+  \/* Absolute minimum to perform the ADTS syncword,\n+     layer and sampling frequency tests *\/\n+  if (G_UNLIKELY (avail < 3)) {\n+    *needed_data = 3;\n+    return FALSE;\n+  }\n+\n+  \/* Syncword and layer tests *\/\n+  if ((data[0] == 0xff) && ((data[1] & 0xf6) == 0xf0)) {\n+\n+    \/* Sampling frequency test *\/\n+    if (G_UNLIKELY ((data[2] & 0x3C) >> 2 == 15))\n+      return FALSE;\n+\n+    \/* This looks like an ADTS frame header but\n+       we need at least 6 bytes to proceed *\/\n+    if (G_UNLIKELY (avail < 6)) {\n+      *needed_data = 6;\n+      return FALSE;\n+    }\n+\n+    *framesize = gst_aac_parse_adts_get_frame_len (data);\n+\n+    \/* If frame has CRC, it needs 2 bytes\n+       for it at the end of the header *\/\n+    crc_size = (data[1] & 0x01) ? 0 : 2;\n+\n+    \/* CRC size test *\/\n+    if (*framesize < 7 + crc_size) {\n+      *needed_data = 7 + crc_size;\n+      return FALSE;\n+    }\n+\n+    \/* In EOS mode this is enough. No need to examine the data further.\n+       We also relax the check when we have sync, on the assumption that\n+       if we're not looking at random data, we have a much higher chance\n+       to get the correct sync, and this avoids losing two frames when\n+       a single bit corruption happens. *\/\n+    if (drain || !GST_BASE_PARSE_LOST_SYNC (aacparse)) {\n+      return TRUE;\n+    }\n+\n+    if (*framesize + ADTS_MAX_SIZE > avail) {\n+      \/* We have found a possible frame header candidate, but can't be\n+         sure since we don't have enough data to check the next frame *\/\n+      GST_DEBUG (\"NEED MORE DATA: we need %d, available %d\",\n+          *framesize + ADTS_MAX_SIZE, avail);\n+      *needed_data = *framesize + ADTS_MAX_SIZE;\n+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),\n+          *framesize + ADTS_MAX_SIZE);\n+      return FALSE;\n+    }\n+\n+    if ((data[*framesize] == 0xff) && ((data[*framesize + 1] & 0xf6) == 0xf0)) {\n+      guint nextlen = gst_aac_parse_adts_get_frame_len (data + (*framesize));\n+\n+      GST_LOG (\"ADTS frame found, len: %d bytes\", *framesize);\n+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),\n+          nextlen + ADTS_MAX_SIZE);\n+      return TRUE;\n+    }\n+  }\n+  return FALSE;\n+}\n+\n+static gboolean\n+gst_aac_parse_latm_get_value (GstAacParse * aacparse, GstBitReader * br,\n+    guint32 * value)\n+{\n+  guint8 bytes, i, byte;\n+\n+  *value = 0;\n+  if (!gst_bit_reader_get_bits_uint8 (br, &bytes, 2))\n+    return FALSE;\n+  for (i = 0; i <= bytes; ++i) {\n+    *value <<= 8;\n+    if (!gst_bit_reader_get_bits_uint8 (br, &byte, 8))\n+      return FALSE;\n+    *value += byte;\n+  }\n+  return TRUE;\n+}\n+\n+static gboolean\n+gst_aac_parse_get_audio_object_type (GstAacParse * aacparse, GstBitReader * br,\n+    guint8 * audio_object_type)\n+{\n+  if (!gst_bit_reader_get_bits_uint8 (br, audio_object_type, 5))\n+    return FALSE;\n+  if (*audio_object_type == 31) {\n+    if (!gst_bit_reader_get_bits_uint8 (br, audio_object_type, 6))\n+      return FALSE;\n+    *audio_object_type += 32;\n+  }\n+  GST_LOG_OBJECT (aacparse, \"audio object type %u\", *audio_object_type);\n+  return TRUE;\n+}\n+\n+static gboolean\n+gst_aac_parse_get_audio_sample_rate (GstAacParse * aacparse, GstBitReader * br,\n+    gint * sample_rate)\n+{\n+  guint8 sampling_frequency_index;\n+  if (!gst_bit_reader_get_bits_uint8 (br, &sampling_frequency_index, 4))\n+    return FALSE;\n+  GST_LOG_OBJECT (aacparse, \"sampling_frequency_index: %u\",\n+      sampling_frequency_index);\n+  if (sampling_frequency_index == 0xf) {\n+    guint32 sampling_rate;\n+    if (!gst_bit_reader_get_bits_uint32 (br, &sampling_rate, 24))\n+      return FALSE;\n+    *sample_rate = sampling_rate;\n+  } else {\n+    *sample_rate = loas_sample_rate_table[sampling_frequency_index];\n+    if (!*sample_rate)\n+      return FALSE;\n+  }\n+  aacparse->last_parsed_sample_rate = *sample_rate;\n+  return TRUE;\n+}\n+\n+\/* See table 1.13 in ISO\/IEC 14496-3 *\/\n+static gboolean\n+gst_aac_parse_read_audio_specific_config (GstAacParse * aacparse,\n+    GstBitReader * br, gint * object_type, gint * sample_rate, gint * channels,\n+    gint * frame_samples)\n+{\n+  guint8 audio_object_type;\n+  guint8 G_GNUC_UNUSED extension_audio_object_type;\n+  guint8 channel_configuration, extension_channel_configuration;\n+  gboolean G_GNUC_UNUSED sbr = FALSE, ps = FALSE;\n+\n+  if (!gst_aac_parse_get_audio_object_type (aacparse, br, &audio_object_type))\n+    return FALSE;\n+  if (object_type)\n+    *object_type = audio_object_type;\n+\n+  if (!gst_aac_parse_get_audio_sample_rate (aacparse, br, sample_rate))\n+    return FALSE;\n+\n+  if (!gst_bit_reader_get_bits_uint8 (br, &channel_configuration, 4))\n+    return FALSE;\n+  *channels = loas_channels_table[channel_configuration];\n+  GST_LOG_OBJECT (aacparse, \"channel_configuration: %d\", channel_configuration);\n+  if (!*channels)\n+    return FALSE;\n+\n+  if (audio_object_type == 5 || audio_object_type == 29) {\n+    extension_audio_object_type = 5;\n+    sbr = TRUE;\n+    if (audio_object_type == 29) {\n+      ps = TRUE;\n+      \/* Parametric stereo. If we have a one-channel configuration, we can\n+       * override it to stereo *\/\n+      if (*channels == 1)\n+        *channels = 2;\n+    }\n+\n+    GST_LOG_OBJECT (aacparse,\n+        \"Audio object type 5 or 29, so rereading sampling rate (was %d)...\",\n+        *sample_rate);\n+    if (!gst_aac_parse_get_audio_sample_rate (aacparse, br, sample_rate))\n+      return FALSE;\n+\n+    if (!gst_aac_parse_get_audio_object_type (aacparse, br, &audio_object_type))\n+      return FALSE;\n+\n+    if (audio_object_type == 22) {\n+      \/* extension channel configuration *\/\n+      if (!gst_bit_reader_get_bits_uint8 (br, &extension_channel_configuration,\n+              4))\n+        return FALSE;\n+      GST_LOG_OBJECT (aacparse, \"extension channel_configuration: %d\",\n+          extension_channel_configuration);\n+      *channels = loas_channels_table[extension_channel_configuration];\n+      if (!*channels)\n+        return FALSE;\n+    }\n+  } else {\n+    extension_audio_object_type = 0;\n+  }\n+\n+  GST_INFO_OBJECT (aacparse, \"Parsed AudioSpecificConfig: %d Hz, %d channels\",\n+      *sample_rate, *channels);\n+\n+  if (frame_samples && audio_object_type == 23) {\n+    guint8 frame_flag;\n+    \/* Read the Decoder Configuration (GASpecificConfig) if present *\/\n+    \/* We only care about the first bit to know what the number of samples\n+     * in a frame is *\/\n+    if (!gst_bit_reader_get_bits_uint8 (br, &frame_flag, 1))\n+      return FALSE;\n+    *frame_samples = frame_flag ? 960 : 1024;\n+  }\n+\n+  \/* There's LOTS of stuff next, but we ignore it for now as we have\n+     what we want (sample rate and number of channels *\/\n+  GST_DEBUG_OBJECT (aacparse,\n+      \"Need more code to parse humongous LOAS data, currently ignored\");\n+  aacparse->last_parsed_channels = *channels;\n+  return TRUE;\n+}\n+\n+\n+static gboolean\n+gst_aac_parse_read_loas_config (GstAacParse * aacparse, const guint8 * data,\n+    guint avail, gint * sample_rate, gint * channels, gint * version)\n+{\n+  GstBitReader br;\n+  guint8 u8, v, vA;\n+\n+  \/* No version in the bitstream, but the spec has LOAS in the MPEG-4 section *\/\n+  if (version)\n+    *version = 4;\n+\n+  gst_bit_reader_init (&br, data, avail);\n+\n+  \/* skip sync word (11 bits) and size (13 bits) *\/\n+  if (!gst_bit_reader_skip (&br, 11 + 13))\n+    return FALSE;\n+\n+  \/* First bit is \"use last config\" *\/\n+  if (!gst_bit_reader_get_bits_uint8 (&br, &u8, 1))\n+    return FALSE;\n+  if (u8) {\n+    GST_LOG_OBJECT (aacparse, \"Frame uses previous config\");\n+    if (!aacparse->last_parsed_sample_rate || !aacparse->last_parsed_channels) {\n+      GST_DEBUG_OBJECT (aacparse,\n+          \"No previous config to use. We'll look for more data.\");\n+      return FALSE;\n+    }\n+    *sample_rate = aacparse->last_parsed_sample_rate;\n+    *channels = aacparse->last_parsed_channels;\n+    return TRUE;\n+  }\n+\n+  GST_DEBUG_OBJECT (aacparse, \"Frame contains new config\");\n+\n+  \/* audioMuxVersion *\/\n+  if (!gst_bit_reader_get_bits_uint8 (&br, &v, 1))\n+    return FALSE;\n+  if (v) {\n+    \/* audioMuxVersionA *\/\n+    if (!gst_bit_reader_get_bits_uint8 (&br, &vA, 1))\n+      return FALSE;\n+  } else\n+    vA = 0;\n+\n+  GST_LOG_OBJECT (aacparse, \"v %d, vA %d\", v, vA);\n+  if (vA == 0) {\n+    guint8 same_time, subframes, num_program, prog;\n+    if (v == 1) {\n+      guint32 value;\n+      \/* taraBufferFullness *\/\n+      if (!gst_aac_parse_latm_get_value (aacparse, &br, &value))\n+        return FALSE;\n+    }\n+    if (!gst_bit_reader_get_bits_uint8 (&br, &same_time, 1))\n+      return FALSE;\n+    if (!gst_bit_reader_get_bits_uint8 (&br, &subframes, 6))\n+      return FALSE;\n+    if (!gst_bit_reader_get_bits_uint8 (&br, &num_program, 4))\n+      return FALSE;\n+    GST_LOG_OBJECT (aacparse, \"same_time %d, subframes %d, num_program %d\",\n+        same_time, subframes, num_program);\n+\n+    for (prog = 0; prog <= num_program; ++prog) {\n+      guint8 num_layer, layer;\n+      if (!gst_bit_reader_get_bits_uint8 (&br, &num_layer, 3))\n+        return FALSE;\n+      GST_LOG_OBJECT (aacparse, \"Program %d: %d layers\", prog, num_layer);\n+\n+      for (layer = 0; layer <= num_layer; ++layer) {\n+        guint8 use_same_config;\n+        if (prog == 0 && layer == 0) {\n+          use_same_config = 0;\n+        } else {\n+          if (!gst_bit_reader_get_bits_uint8 (&br, &use_same_config, 1))\n+            return FALSE;\n+        }\n+        if (!use_same_config) {\n+          if (v == 0) {\n+            if (!gst_aac_parse_read_audio_specific_config (aacparse, &br, NULL,\n+                    sample_rate, channels, NULL))\n+              return FALSE;\n+          } else {\n+            guint32 asc_len;\n+            if (!gst_aac_parse_latm_get_value (aacparse, &br, &asc_len))\n+              return FALSE;\n+            if (!gst_aac_parse_read_audio_specific_config (aacparse, &br, NULL,\n+                    sample_rate, channels, NULL))\n+              return FALSE;\n+            if (!gst_bit_reader_skip (&br, asc_len))\n+              return FALSE;\n+          }\n+        }\n+      }\n+    }\n+    GST_LOG_OBJECT (aacparse, \"More data ignored\");\n+  } else {\n+    GST_WARNING_OBJECT (aacparse, \"Spec says \\\"TBD\\\"...\");\n+    return FALSE;\n+  }\n+  return TRUE;\n+}\n+\n+\/**\n+ * gst_aac_parse_loas_get_frame_len:\n+ * @data: block of data containing a LOAS header.\n+ *\n+ * This function calculates LOAS frame length from the given header.\n+ *\n+ * Returns: size of the LOAS frame.\n+ *\/\n+static inline guint\n+gst_aac_parse_loas_get_frame_len (const guint8 * data)\n+{\n+  return (((data[1] & 0x1f) << 8) | data[2]) + 3;\n+}\n+\n+\n+\/**\n+ * gst_aac_parse_check_loas_frame:\n+ * @aacparse: #GstAacParse.\n+ * @data: Data to be checked.\n+ * @avail: Amount of data passed.\n+ * @framesize: If valid LOAS frame was found, this will be set to tell the\n+ *             found frame size in bytes.\n+ * @needed_data: If frame was not found, this may be set to tell how much\n+ *               more data is needed in the next round to detect the frame\n+ *               reliably. This may happen when a frame header candidate\n+ *               is found but it cannot be guaranteed to be the header without\n+ *               peeking the following data.\n+ *\n+ * Check if the given data contains contains LOAS frame. The algorithm\n+ * will examine LOAS frame header and calculate the frame size. Also, another\n+ * consecutive LOAS frame header need to be present after the found frame.\n+ * Otherwise the data is not considered as a valid LOAS frame. However, this\n+ * \"extra check\" is omitted when EOS has been received. In this case it is\n+ * enough when data[0] contains a valid LOAS header.\n+ *\n+ * This function may set the #needed_data to indicate that a possible frame\n+ * candidate has been found, but more data (#needed_data bytes) is needed to\n+ * be absolutely sure. When this situation occurs, FALSE will be returned.\n+ *\n+ * When a valid frame is detected, this function will use\n+ * gst_base_parse_set_min_frame_size() function from #GstBaseParse class\n+ * to set the needed bytes for next frame.This way next data chunk is already\n+ * of correct size.\n+ *\n+ * LOAS can have three different formats, if I read the spec correctly. Only\n+ * one of them is supported here, as the two samples I have use this one.\n+ *\n+ * Returns: TRUE if the given data contains a valid LOAS header.\n+ *\/\n+static gboolean\n+gst_aac_parse_check_loas_frame (GstAacParse * aacparse,\n+    const guint8 * data, const guint avail, gboolean drain,\n+    guint * framesize, guint * needed_data)\n+{\n+  *needed_data = 0;\n+\n+  \/* 3 byte header *\/\n+  if (G_UNLIKELY (avail < 3)) {\n+    *needed_data = 3;\n+    return FALSE;\n+  }\n+\n+  if ((data[0] == 0x56) && ((data[1] & 0xe0) == 0xe0)) {\n+    *framesize = gst_aac_parse_loas_get_frame_len (data);\n+    GST_DEBUG_OBJECT (aacparse, \"Found possible %u byte LOAS frame\",\n+        *framesize);\n+\n+    \/* In EOS mode this is enough. No need to examine the data further.\n+       We also relax the check when we have sync, on the assumption that\n+       if we're not looking at random data, we have a much higher chance\n+       to get the correct sync, and this avoids losing two frames when\n+       a single bit corruption happens. *\/\n+    if (drain || !GST_BASE_PARSE_LOST_SYNC (aacparse)) {\n+      return TRUE;\n+    }\n+\n+    if (*framesize + LOAS_MAX_SIZE > avail) {\n+      \/* We have found a possible frame header candidate, but can't be\n+         sure since we don't have enough data to check the next frame *\/\n+      GST_DEBUG (\"NEED MORE DATA: we need %d, available %d\",\n+          *framesize + LOAS_MAX_SIZE, avail);\n+      *needed_data = *framesize + LOAS_MAX_SIZE;\n+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),\n+          *framesize + LOAS_MAX_SIZE);\n+      return FALSE;\n+    }\n+\n+    if ((data[*framesize] == 0x56) && ((data[*framesize + 1] & 0xe0) == 0xe0)) {\n+      guint nextlen = gst_aac_parse_loas_get_frame_len (data + (*framesize));\n+\n+      GST_LOG (\"LOAS frame found, len: %d bytes\", *framesize);\n+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),\n+          nextlen + LOAS_MAX_SIZE);\n+      return TRUE;\n+    } else {\n+      GST_DEBUG_OBJECT (aacparse, \"That was a false positive\");\n+    }\n+  }\n+  return FALSE;\n+}\n+\n+\/* caller ensure sufficient data *\/\n+static inline void\n+gst_aac_parse_parse_adts_header (GstAacParse * aacparse, const guint8 * data,\n+    gint * rate, gint * channels, gint * object, gint * version)\n+{\n+\n+  if (rate) {\n+    gint sr_idx = (data[2] & 0x3c) >> 2;\n+\n+    *rate = gst_codec_utils_aac_get_sample_rate_from_index (sr_idx);\n+  }\n+  if (channels) {\n+    *channels = ((data[2] & 0x01) << 2) | ((data[3] & 0xc0) >> 6);\n+    if (*channels == 7)\n+      *channels = 8;\n+  }\n+\n+  if (version)\n+    *version = (data[1] & 0x08) ? 2 : 4;\n+  if (object)\n+    *object = ((data[2] & 0xc0) >> 6) + 1;\n+}\n+\n+\/**\n+ * gst_aac_parse_detect_stream:\n+ * @aacparse: #GstAacParse.\n+ * @data: A block of data that needs to be examined for stream characteristics.\n+ * @avail: Size of the given datablock.\n+ * @framesize: If valid stream was found, this will be set to tell the\n+ *             first frame size in bytes.\n+ * @skipsize: If valid stream was found, this will be set to tell the first\n+ *            audio frame position within the given data.\n+ *\n+ * Examines the given piece of data and try to detect the format of it. It\n+ * checks for \"ADIF\" header (in the beginning of the clip) and ADTS frame\n+ * header. If the stream is detected, TRUE will be returned and #framesize\n+ * is set to indicate the found frame size. Additionally, #skipsize might\n+ * be set to indicate the number of bytes that need to be skipped, a.k.a. the\n+ * position of the frame inside given data chunk.\n+ *\n+ * Returns: TRUE on success.\n+ *\/\n+static gboolean\n+gst_aac_parse_detect_stream (GstAacParse * aacparse,\n+    const guint8 * data, const guint avail, gboolean drain,\n+    guint * framesize, gint * skipsize)\n+{\n+  gboolean found = FALSE;\n+  guint need_data_adts = 0, need_data_loas;\n+  guint i = 0;\n+\n+  GST_DEBUG_OBJECT (aacparse, \"Parsing header data\");\n+\n+  \/* FIXME: No need to check for ADIF if we are not in the beginning of the\n+     stream *\/\n+\n+  \/* Can we even parse the header? *\/\n+  if (avail < MAX (ADTS_MAX_SIZE, LOAS_MAX_SIZE)) {\n+    GST_DEBUG_OBJECT (aacparse, \"Not enough data to check\");\n+    return FALSE;\n+  }\n+\n+  for (i = 0; i < avail - 4; i++) {\n+    if (((data[i] == 0xff) && ((data[i + 1] & 0xf6) == 0xf0)) ||\n+        ((data[i] == 0x56) && ((data[i + 1] & 0xe0) == 0xe0)) ||\n+        strncmp ((char *) data + i, \"ADIF\", 4) == 0) {\n+      GST_DEBUG_OBJECT (aacparse, \"Found signature at offset %u\", i);\n+      found = TRUE;\n+\n+      if (i) {\n+        \/* Trick: tell the parent class that we didn't find the frame yet,\n+           but make it skip 'i' amount of bytes. Next time we arrive\n+           here we have full frame in the beginning of the data. *\/\n+        *skipsize = i;\n+        return FALSE;\n+      }\n+      break;\n+    }\n+  }\n+  if (!found) {\n+    if (i)\n+      *skipsize = i;\n+    return FALSE;\n+  }\n+\n+  if (gst_aac_parse_check_adts_frame (aacparse, data, avail, drain,\n+          framesize, &need_data_adts)) {\n+    gint rate, channels;\n+\n+    GST_INFO (\"ADTS ID: %d, framesize: %d\", (data[1] & 0x08) >> 3, *framesize);\n+\n+    gst_aac_parse_parse_adts_header (aacparse, data, &rate, &channels,\n+        &aacparse->object_type, &aacparse->mpegversion);\n+\n+    if (!channels || !framesize) {\n+      GST_DEBUG_OBJECT (aacparse, \"impossible ADTS configuration\");\n+      return FALSE;\n+    }\n+\n+    aacparse->header_type = DSPAAC_HEADER_ADTS;\n+    gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse), rate,\n+        aacparse->frame_samples, 2, 2);\n+\n+    GST_DEBUG (\"ADTS: samplerate %d, channels %d, objtype %d, version %d\",\n+        rate, channels, aacparse->object_type, aacparse->mpegversion);\n+\n+    gst_base_parse_set_syncable (GST_BASE_PARSE (aacparse), TRUE);\n+\n+    return TRUE;\n+  }\n+\n+  if (gst_aac_parse_check_loas_frame (aacparse, data, avail, drain,\n+          framesize, &need_data_loas)) {\n+    gint rate = 0, channels = 0;\n+\n+    GST_INFO (\"LOAS, framesize: %d\", *framesize);\n+\n+    aacparse->header_type = DSPAAC_HEADER_LOAS;\n+\n+    if (!gst_aac_parse_read_loas_config (aacparse, data, avail, &rate,\n+            &channels, &aacparse->mpegversion)) {\n+      \/* This is pretty normal when skipping data at the start of\n+       * random stream (MPEG-TS capture for example) *\/\n+      GST_LOG_OBJECT (aacparse, \"Error reading LOAS config\");\n+      return FALSE;\n+    }\n+\n+    if (rate && channels) {\n+      gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse), rate,\n+          aacparse->frame_samples, 2, 2);\n+\n+      \/* Don't store the sample rate and channels yet -\n+       * this is just format detection. *\/\n+      GST_DEBUG (\"LOAS: samplerate %d, channels %d, objtype %d, version %d\",\n+          rate, channels, aacparse->object_type, aacparse->mpegversion);\n+    }\n+\n+    gst_base_parse_set_syncable (GST_BASE_PARSE (aacparse), TRUE);\n+\n+    return TRUE;\n+  }\n+\n+  if (need_data_adts || need_data_loas) {\n+    \/* This tells the parent class not to skip any data *\/\n+    *skipsize = 0;\n+    return FALSE;\n+  }\n+\n+  if (avail < ADIF_MAX_SIZE)\n+    return FALSE;\n+\n+  if (memcmp (data + i, \"ADIF\", 4) == 0) {\n+    const guint8 *adif;\n+    int skip_size = 0;\n+    int bitstream_type;\n+    int sr_idx;\n+    GstCaps *sinkcaps;\n+\n+    aacparse->header_type = DSPAAC_HEADER_ADIF;\n+    aacparse->mpegversion = 4;\n+\n+    \/* Skip the \"ADIF\" bytes *\/\n+    adif = data + i + 4;\n+\n+    \/* copyright string *\/\n+    if (adif[0] & 0x80)\n+      skip_size += 9;           \/* skip 9 bytes *\/\n+\n+    bitstream_type = adif[0 + skip_size] & 0x10;\n+    aacparse->bitrate =\n+        ((unsigned int) (adif[0 + skip_size] & 0x0f) << 19) |\n+        ((unsigned int) adif[1 + skip_size] << 11) |\n+        ((unsigned int) adif[2 + skip_size] << 3) |\n+        ((unsigned int) adif[3 + skip_size] & 0xe0);\n+\n+    \/* CBR *\/\n+    if (bitstream_type == 0) {\n+#if 0\n+      \/* Buffer fullness parsing. Currently not needed... *\/\n+      guint num_elems = 0;\n+      guint fullness = 0;\n+\n+      num_elems = (adif[3 + skip_size] & 0x1e);\n+      GST_INFO (\"ADIF num_config_elems: %d\", num_elems);\n+\n+      fullness = ((unsigned int) (adif[3 + skip_size] & 0x01) << 19) |\n+          ((unsigned int) adif[4 + skip_size] << 11) |\n+          ((unsigned int) adif[5 + skip_size] << 3) |\n+          ((unsigned int) (adif[6 + skip_size] & 0xe0) >> 5);\n+\n+      GST_INFO (\"ADIF buffer fullness: %d\", fullness);\n+#endif\n+      aacparse->object_type = ((adif[6 + skip_size] & 0x01) << 1) |\n+          ((adif[7 + skip_size] & 0x80) >> 7);\n+      sr_idx = (adif[7 + skip_size] & 0x78) >> 3;\n+    }\n+    \/* VBR *\/\n+    else {\n+      aacparse->object_type = (adif[4 + skip_size] & 0x18) >> 3;\n+      sr_idx = ((adif[4 + skip_size] & 0x07) << 1) |\n+          ((adif[5 + skip_size] & 0x80) >> 7);\n+    }\n+\n+    \/* FIXME: This gives totally wrong results. Duration calculation cannot\n+       be based on this *\/\n+    aacparse->sample_rate =\n+        gst_codec_utils_aac_get_sample_rate_from_index (sr_idx);\n+\n+    \/* baseparse is not given any fps,\n+     * so it will give up on timestamps, seeking, etc *\/\n+\n+    \/* FIXME: Can we assume this? *\/\n+    aacparse->channels = 2;\n+\n+    GST_INFO (\"ADIF: br=%d, samplerate=%d, objtype=%d\",\n+        aacparse->bitrate, aacparse->sample_rate, aacparse->object_type);\n+\n+    gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse), 512);\n+\n+    \/* arrange for metadata and get out of the way *\/\n+    sinkcaps = gst_pad_get_current_caps (GST_BASE_PARSE_SINK_PAD (aacparse));\n+    gst_aac_parse_set_src_caps (aacparse, sinkcaps);\n+    if (sinkcaps)\n+      gst_caps_unref (sinkcaps);\n+\n+    \/* not syncable, not easily seekable (unless we push data from start *\/\n+    gst_base_parse_set_syncable (GST_BASE_PARSE_CAST (aacparse), FALSE);\n+    gst_base_parse_set_passthrough (GST_BASE_PARSE_CAST (aacparse), TRUE);\n+    gst_base_parse_set_average_bitrate (GST_BASE_PARSE_CAST (aacparse), 0);\n+\n+    *framesize = avail;\n+    return TRUE;\n+  }\n+\n+  \/* This should never happen *\/\n+  return FALSE;\n+}\n+\n+\/**\n+ * gst_aac_parse_get_audio_profile_object_type\n+ * @aacparse: #GstAacParse.\n+ *\n+ * Gets the MPEG-2 profile or the MPEG-4 object type value corresponding to the\n+ * mpegversion and profile of @aacparse's src pad caps, according to the\n+ * values defined by table 1.A.11 in ISO\/IEC 14496-3.\n+ *\n+ * Returns: the profile or object type value corresponding to @aacparse's src\n+ * pad caps, if such a value exists; otherwise G_MAXUINT8.\n+ *\/\n+static guint8\n+gst_aac_parse_get_audio_profile_object_type (GstAacParse * aacparse)\n+{\n+  GstCaps *srccaps;\n+  GstStructure *srcstruct;\n+  const gchar *profile;\n+  guint8 ret;\n+\n+  srccaps = gst_pad_get_current_caps (GST_BASE_PARSE_SRC_PAD (aacparse));\n+  if (G_UNLIKELY (srccaps == NULL)) {\n+    return G_MAXUINT8;\n+  }\n+\n+  srcstruct = gst_caps_get_structure (srccaps, 0);\n+  profile = gst_structure_get_string (srcstruct, \"profile\");\n+  if (G_UNLIKELY (profile == NULL)) {\n+    gst_caps_unref (srccaps);\n+    return G_MAXUINT8;\n+  }\n+\n+  if (g_strcmp0 (profile, \"main\") == 0) {\n+    ret = (guint8) 0U;\n+  } else if (g_strcmp0 (profile, \"lc\") == 0) {\n+    ret = (guint8) 1U;\n+  } else if (g_strcmp0 (profile, \"ssr\") == 0) {\n+    ret = (guint8) 2U;\n+  } else if (g_strcmp0 (profile, \"ltp\") == 0) {\n+    if (G_LIKELY (aacparse->mpegversion == 4))\n+      ret = (guint8) 3U;\n+    else\n+      ret = G_MAXUINT8;         \/* LTP Object Type allowed only for MPEG-4 *\/\n+  } else {\n+    ret = G_MAXUINT8;\n+  }\n+\n+  gst_caps_unref (srccaps);\n+  return ret;\n+}\n+\n+\/**\n+ * gst_aac_parse_get_audio_channel_configuration\n+ * @num_channels: number of audio channels.\n+ *\n+ * Gets the Channel Configuration value, as defined by table 1.19 in ISO\/IEC\n+ * 14496-3, for a given number of audio channels.\n+ *\n+ * Returns: the Channel Configuration value corresponding to @num_channels, if\n+ * such a value exists; otherwise G_MAXUINT8.\n+ *\/\n+static guint8\n+gst_aac_parse_get_audio_channel_configuration (gint num_channels)\n+{\n+  if (num_channels >= 1 && num_channels <= 6)   \/* Mono up to & including 5.1 *\/\n+    return (guint8) num_channels;\n+  else if (num_channels == 8)   \/* 7.1 *\/\n+    return (guint8) 7U;\n+  else\n+    return G_MAXUINT8;\n+\n+  \/* FIXME: Add support for configurations 11, 12 and 14 from\n+   * ISO\/IEC 14496-3:2009\/PDAM 4 based on the actual channel layout\n+   *\/\n+}\n+\n+\/**\n+ * gst_aac_parse_get_audio_sampling_frequency_index:\n+ * @sample_rate: audio sampling rate.\n+ *\n+ * Gets the Sampling Frequency Index value, as defined by table 1.18 in ISO\/IEC\n+ * 14496-3, for a given sampling rate.\n+ *\n+ * Returns: the Sampling Frequency Index value corresponding to @sample_rate,\n+ * if such a value exists; otherwise G_MAXUINT8.\n+ *\/\n+static guint8\n+gst_aac_parse_get_audio_sampling_frequency_index (gint sample_rate)\n+{\n+  switch (sample_rate) {\n+    case 96000:\n+      return 0x0U;\n+    case 88200:\n+      return 0x1U;\n+    case 64000:\n+      return 0x2U;\n+    case 48000:\n+      return 0x3U;\n+    case 44100:\n+      return 0x4U;\n+    case 32000:\n+      return 0x5U;\n+    case 24000:\n+      return 0x6U;\n+    case 22050:\n+      return 0x7U;\n+    case 16000:\n+      return 0x8U;\n+    case 12000:\n+      return 0x9U;\n+    case 11025:\n+      return 0xAU;\n+    case 8000:\n+      return 0xBU;\n+    case 7350:\n+      return 0xCU;\n+    default:\n+      return G_MAXUINT8;\n+  }\n+}\n+\n+\/**\n+ * gst_aac_parse_prepend_adts_headers:\n+ * @aacparse: #GstAacParse.\n+ * @frame: raw AAC frame to which ADTS headers shall be prepended.\n+ *\n+ * Prepends ADTS headers to a raw AAC audio frame.\n+ *\n+ * Returns: TRUE if ADTS headers were successfully prepended; FALSE otherwise.\n+ *\/\n+static gboolean\n+gst_aac_parse_prepend_adts_headers (GstAacParse * aacparse,\n+    GstBaseParseFrame * frame)\n+{\n+  GstMemory *mem;\n+  guint8 *adts_headers;\n+  gsize buf_size;\n+  gsize frame_size;\n+  guint8 id, profile, channel_configuration, sampling_frequency_index;\n+\n+  id = (aacparse->mpegversion == 4) ? 0x0U : 0x1U;\n+  profile = gst_aac_parse_get_audio_profile_object_type (aacparse);\n+  if (profile == G_MAXUINT8) {\n+    GST_ERROR_OBJECT (aacparse, \"Unsupported audio profile or object type\");\n+    return FALSE;\n+  }\n+  channel_configuration =\n+      gst_aac_parse_get_audio_channel_configuration (aacparse->channels);\n+  if (channel_configuration == G_MAXUINT8) {\n+    GST_ERROR_OBJECT (aacparse, \"Unsupported number of channels\");\n+    return FALSE;\n+  }\n+  sampling_frequency_index =\n+      gst_aac_parse_get_audio_sampling_frequency_index (aacparse->sample_rate);\n+  if (sampling_frequency_index == G_MAXUINT8) {\n+    GST_ERROR_OBJECT (aacparse, \"Unsupported sampling frequency\");\n+    return FALSE;\n+  }\n+\n+  frame->out_buffer = gst_buffer_copy (frame->buffer);\n+  buf_size = gst_buffer_get_size (frame->out_buffer);\n+  frame_size = buf_size + ADTS_HEADERS_LENGTH;\n+\n+  if (G_UNLIKELY (frame_size >= 0x4000)) {\n+    GST_ERROR_OBJECT (aacparse, \"Frame size is too big for ADTS\");\n+    return FALSE;\n+  }\n+\n+  adts_headers = (guint8 *) g_malloc0 (ADTS_HEADERS_LENGTH);\n+\n+  \/* Note: no error correction bits are added to the resulting ADTS frames *\/\n+  adts_headers[0] = 0xFFU;\n+  adts_headers[1] = 0xF0U | (id << 3) | 0x1U;\n+  adts_headers[2] = (profile << 6) | (sampling_frequency_index << 2) | 0x2U |\n+      ((channel_configuration & 0x4U) >> 2);\n+  adts_headers[3] = ((channel_configuration & 0x3U) << 6) | 0x30U |\n+      (guint8) (frame_size >> 11);\n+  adts_headers[4] = (guint8) ((frame_size >> 3) & 0x00FF);\n+  adts_headers[5] = (guint8) (((frame_size & 0x0007) << 5) + 0x1FU);\n+  adts_headers[6] = 0xFCU;\n+\n+  mem = gst_memory_new_wrapped (0, adts_headers, ADTS_HEADERS_LENGTH, 0,\n+      ADTS_HEADERS_LENGTH, adts_headers, g_free);\n+  gst_buffer_prepend_memory (frame->out_buffer, mem);\n+\n+  return TRUE;\n+}\n+\n+\/**\n+ * gst_aac_parse_check_valid_frame:\n+ * @parse: #GstBaseParse.\n+ * @frame: #GstBaseParseFrame.\n+ * @skipsize: How much data parent class should skip in order to find the\n+ *            frame header.\n+ *\n+ * Implementation of \"handle_frame\" vmethod in #GstBaseParse class.\n+ *\n+ * Also determines frame overhead.\n+ * ADTS streams have a 7 byte header in each frame. MP4 and ADIF streams don't have\n+ * a per-frame header. LOAS has 3 bytes.\n+ *\n+ * We're making a couple of simplifying assumptions:\n+ *\n+ * 1. We count Program Configuration Elements rather than searching for them\n+ *    in the streams to discount them - the overhead is negligible.\n+ *\n+ * 2. We ignore CRC. This has a worst-case impact of (num_raw_blocks + 1)*16\n+ *    bits, which should still not be significant enough to warrant the\n+ *    additional parsing through the headers\n+ *\n+ * Returns: a #GstFlowReturn.\n+ *\/\n+static GstFlowReturn\n+gst_aac_parse_handle_frame (GstBaseParse * parse,\n+    GstBaseParseFrame * frame, gint * skipsize)\n+{\n+  GstMapInfo map;\n+  GstAacParse *aacparse;\n+  gboolean ret = FALSE;\n+  gboolean lost_sync;\n+  GstBuffer *buffer;\n+  guint framesize;\n+  gint rate = 0, channels = 0;\n+\n+  aacparse = GST_AAC_PARSE (parse);\n+  buffer = frame->buffer;\n+\n+  gst_buffer_map (buffer, &map, GST_MAP_READ);\n+\n+  *skipsize = -1;\n+  lost_sync = GST_BASE_PARSE_LOST_SYNC (parse);\n+\n+  if (aacparse->header_type == DSPAAC_HEADER_ADIF ||\n+      aacparse->header_type == DSPAAC_HEADER_NONE) {\n+    \/* There is nothing to parse *\/\n+    framesize = map.size;\n+    ret = TRUE;\n+\n+  } else if (aacparse->header_type == DSPAAC_HEADER_NOT_PARSED || lost_sync) {\n+\n+    ret = gst_aac_parse_detect_stream (aacparse, map.data, map.size,\n+        GST_BASE_PARSE_DRAINING (parse), &framesize, skipsize);\n+\n+  } else if (aacparse->header_type == DSPAAC_HEADER_ADTS) {\n+    guint needed_data = 1024;\n+\n+    ret = gst_aac_parse_check_adts_frame (aacparse, map.data, map.size,\n+        GST_BASE_PARSE_DRAINING (parse), &framesize, &needed_data);\n+\n+    if (!ret && needed_data) {\n+      GST_DEBUG (\"buffer didn't contain valid frame\");\n+      *skipsize = 0;\n+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),\n+          needed_data);\n+    }\n+\n+  } else if (aacparse->header_type == DSPAAC_HEADER_LOAS) {\n+    guint needed_data = 1024;\n+\n+    ret = gst_aac_parse_check_loas_frame (aacparse, map.data,\n+        map.size, GST_BASE_PARSE_DRAINING (parse), &framesize, &needed_data);\n+\n+    if (!ret && needed_data) {\n+      GST_DEBUG (\"buffer didn't contain valid frame\");\n+      *skipsize = 0;\n+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),\n+          needed_data);\n+    }\n+\n+  } else {\n+    GST_DEBUG (\"buffer didn't contain valid frame\");\n+    gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),\n+        ADTS_MAX_SIZE);\n+  }\n+\n+  if (G_UNLIKELY (!ret))\n+    goto exit;\n+\n+  if (aacparse->header_type == DSPAAC_HEADER_ADTS) {\n+    \/* see above *\/\n+    frame->overhead = 7;\n+\n+    gst_aac_parse_parse_adts_header (aacparse, map.data,\n+        &rate, &channels, NULL, NULL);\n+\n+    GST_LOG_OBJECT (aacparse, \"rate: %d, chans: %d\", rate, channels);\n+\n+    if (G_UNLIKELY (rate != aacparse->sample_rate\n+            || channels != aacparse->channels)) {\n+      aacparse->sample_rate = rate;\n+      aacparse->channels = channels;\n+\n+      if (!gst_aac_parse_set_src_caps (aacparse, NULL)) {\n+        \/* If linking fails, we need to return appropriate error *\/\n+        ret = GST_FLOW_NOT_LINKED;\n+      }\n+\n+      gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse),\n+          aacparse->sample_rate, aacparse->frame_samples, 2, 2);\n+    }\n+  } else if (aacparse->header_type == DSPAAC_HEADER_LOAS) {\n+    gboolean setcaps = FALSE;\n+\n+    \/* see above *\/\n+    frame->overhead = 3;\n+\n+    if (!gst_aac_parse_read_loas_config (aacparse, map.data, map.size, &rate,\n+            &channels, NULL) || !rate || !channels) {\n+      \/* This is pretty normal when skipping data at the start of\n+       * random stream (MPEG-TS capture for example) *\/\n+      GST_DEBUG_OBJECT (aacparse, \"Error reading LOAS config. Skipping.\");\n+      \/* Since we don't fully parse the LOAS config, we don't know for sure\n+       * how much to skip. Just skip 1 to end up to the next marker and\n+       * resume parsing from there *\/\n+      *skipsize = 1;\n+      goto exit;\n+    }\n+\n+    if (G_UNLIKELY (rate != aacparse->sample_rate\n+            || channels != aacparse->channels)) {\n+      aacparse->sample_rate = rate;\n+      aacparse->channels = channels;\n+      setcaps = TRUE;\n+      GST_INFO_OBJECT (aacparse, \"New LOAS config: %d Hz, %d channels\", rate,\n+          channels);\n+    }\n+\n+    \/* We want to set caps both at start, and when rate\/channels change.\n+       Since only some LOAS frames have that info, we may receive frames\n+       before knowing about rate\/channels. *\/\n+    if (setcaps\n+        || !gst_pad_has_current_caps (GST_BASE_PARSE_SRC_PAD (aacparse))) {\n+      if (!gst_aac_parse_set_src_caps (aacparse, NULL)) {\n+        \/* If linking fails, we need to return appropriate error *\/\n+        ret = GST_FLOW_NOT_LINKED;\n+      }\n+\n+      gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse),\n+          aacparse->sample_rate, aacparse->frame_samples, 2, 2);\n+    }\n+  }\n+\n+  if (aacparse->header_type == DSPAAC_HEADER_NONE\n+      && aacparse->output_header_type == DSPAAC_HEADER_ADTS) {\n+    if (!gst_aac_parse_prepend_adts_headers (aacparse, frame)) {\n+      GST_ERROR_OBJECT (aacparse, \"Failed to prepend ADTS headers to frame\");\n+      ret = GST_FLOW_ERROR;\n+    }\n+  }\n+\n+exit:\n+  gst_buffer_unmap (buffer, &map);\n+\n+  if (ret) {\n+    \/* found, skip if needed *\/\n+    if (*skipsize > 0)\n+      return GST_FLOW_OK;\n+    *skipsize = 0;\n+  } else {\n+    if (*skipsize < 0)\n+      *skipsize = 1;\n+  }\n+\n+  if (ret && framesize <= map.size) {\n+    return gst_base_parse_finish_frame (parse, frame, framesize);\n+  }\n+\n+  return GST_FLOW_OK;\n+}\n+\n+static GstFlowReturn\n+gst_aac_parse_pre_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)\n+{\n+  GstAacParse *aacparse = GST_AAC_PARSE (parse);\n+\n+  if (!aacparse->sent_codec_tag) {\n+    GstTagList *taglist;\n+    GstCaps *caps;\n+\n+    \/* codec tag *\/\n+    caps = gst_pad_get_current_caps (GST_BASE_PARSE_SRC_PAD (parse));\n+    if (caps == NULL) {\n+      if (GST_PAD_IS_FLUSHING (GST_BASE_PARSE_SRC_PAD (parse))) {\n+        GST_INFO_OBJECT (parse, \"Src pad is flushing\");\n+        return GST_FLOW_FLUSHING;\n+      } else {\n+        GST_INFO_OBJECT (parse, \"Src pad is not negotiated!\");\n+        return GST_FLOW_NOT_NEGOTIATED;\n+      }\n+    }\n+\n+    taglist = gst_tag_list_new_empty ();\n+    gst_pb_utils_add_codec_description_to_tag_list (taglist,\n+        GST_TAG_AUDIO_CODEC, caps);\n+    gst_caps_unref (caps);\n+\n+    gst_base_parse_merge_tags (parse, taglist, GST_TAG_MERGE_REPLACE);\n+    gst_tag_list_unref (taglist);\n+\n+    \/* also signals the end of first-frame processing *\/\n+    aacparse->sent_codec_tag = TRUE;\n+  }\n+\n+  \/* As a special case, we can remove the ADTS framing and output raw AAC. *\/\n+  if (aacparse->header_type == DSPAAC_HEADER_ADTS\n+      && aacparse->output_header_type == DSPAAC_HEADER_NONE) {\n+    guint header_size;\n+    GstMapInfo map;\n+    frame->out_buffer = gst_buffer_make_writable (frame->buffer);\n+    frame->buffer = NULL;\n+    gst_buffer_map (frame->out_buffer, &map, GST_MAP_READ);\n+    header_size = (map.data[1] & 1) ? 7 : 9;    \/* optional CRC *\/\n+    gst_buffer_unmap (frame->out_buffer, &map);\n+    gst_buffer_resize (frame->out_buffer, header_size,\n+        gst_buffer_get_size (frame->out_buffer) - header_size);\n+  }\n+\n+  frame->flags |= GST_BASE_PARSE_FRAME_FLAG_CLIP;\n+\n+  return GST_FLOW_OK;\n+}\n+\n+\n+\/**\n+ * gst_aac_parse_start:\n+ * @parse: #GstBaseParse.\n+ *\n+ * Implementation of \"start\" vmethod in #GstBaseParse class.\n+ *\n+ * Returns: TRUE if startup succeeded.\n+ *\/\n+static gboolean\n+gst_aac_parse_start (GstBaseParse * parse)\n+{\n+  GstAacParse *aacparse;\n+\n+  aacparse = GST_AAC_PARSE (parse);\n+  GST_DEBUG (\"start\");\n+  aacparse->frame_samples = 1024;\n+  gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse), ADTS_MAX_SIZE);\n+  aacparse->sent_codec_tag = FALSE;\n+  aacparse->last_parsed_channels = 0;\n+  aacparse->last_parsed_sample_rate = 0;\n+  aacparse->object_type = 0;\n+  aacparse->bitrate = 0;\n+  aacparse->header_type = DSPAAC_HEADER_NOT_PARSED;\n+  aacparse->output_header_type = DSPAAC_HEADER_NOT_PARSED;\n+  aacparse->channels = 0;\n+  aacparse->sample_rate = 0;\n+  return TRUE;\n+}\n+\n+\n+\/**\n+ * gst_aac_parse_stop:\n+ * @parse: #GstBaseParse.\n+ *\n+ * Implementation of \"stop\" vmethod in #GstBaseParse class.\n+ *\n+ * Returns: TRUE is stopping succeeded.\n+ *\/\n+static gboolean\n+gst_aac_parse_stop (GstBaseParse * parse)\n+{\n+  GST_DEBUG (\"stop\");\n+  return TRUE;\n+}\n+\n+static void\n+remove_fields (GstCaps * caps)\n+{\n+  guint i, n;\n+\n+  n = gst_caps_get_size (caps);\n+  for (i = 0; i < n; i++) {\n+    GstStructure *s = gst_caps_get_structure (caps, i);\n+\n+    gst_structure_remove_field (s, \"framed\");\n+  }\n+}\n+\n+static void\n+add_conversion_fields (GstCaps * caps)\n+{\n+  guint i, n;\n+\n+  n = gst_caps_get_size (caps);\n+  for (i = 0; i < n; i++) {\n+    GstStructure *s = gst_caps_get_structure (caps, i);\n+\n+    if (gst_structure_has_field (s, \"stream-format\")) {\n+      const GValue *v = gst_structure_get_value (s, \"stream-format\");\n+\n+      if (G_VALUE_HOLDS_STRING (v)) {\n+        const gchar *str = g_value_get_string (v);\n+\n+        if (strcmp (str, \"adts\") == 0 || strcmp (str, \"raw\") == 0) {\n+          GValue va = G_VALUE_INIT;\n+          GValue vs = G_VALUE_INIT;\n+\n+          g_value_init (&va, GST_TYPE_LIST);\n+          g_value_init (&vs, G_TYPE_STRING);\n+          g_value_set_string (&vs, \"adts\");\n+          gst_value_list_append_value (&va, &vs);\n+          g_value_set_string (&vs, \"raw\");\n+          gst_value_list_append_value (&va, &vs);\n+          gst_structure_set_value (s, \"stream-format\", &va);\n+          g_value_unset (&va);\n+          g_value_unset (&vs);\n+        }\n+      } else if (GST_VALUE_HOLDS_LIST (v)) {\n+        gboolean contains_raw = FALSE;\n+        gboolean contains_adts = FALSE;\n+        guint m = gst_value_list_get_size (v), j;\n+\n+        for (j = 0; j < m; j++) {\n+          const GValue *ve = gst_value_list_get_value (v, j);\n+          const gchar *str;\n+\n+          if (G_VALUE_HOLDS_STRING (ve) && (str = g_value_get_string (ve))) {\n+            if (strcmp (str, \"adts\") == 0)\n+              contains_adts = TRUE;\n+            else if (strcmp (str, \"raw\") == 0)\n+              contains_raw = TRUE;\n+          }\n+        }\n+\n+        if (contains_adts || contains_raw) {\n+          GValue va = G_VALUE_INIT;\n+          GValue vs = G_VALUE_INIT;\n+\n+          g_value_init (&va, GST_TYPE_LIST);\n+          g_value_init (&vs, G_TYPE_STRING);\n+          g_value_copy (v, &va);\n+\n+          if (!contains_raw) {\n+            g_value_set_string (&vs, \"raw\");\n+            gst_value_list_append_value (&va, &vs);\n+          }\n+          if (!contains_adts) {\n+            g_value_set_string (&vs, \"adts\");\n+            gst_value_list_append_value (&va, &vs);\n+          }\n+\n+          gst_structure_set_value (s, \"stream-format\", &va);\n+\n+          g_value_unset (&vs);\n+          g_value_unset (&va);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+static GstCaps *\n+gst_aac_parse_sink_getcaps (GstBaseParse * parse, GstCaps * filter)\n+{\n+  GstCaps *peercaps, *templ;\n+  GstCaps *res;\n+\n+  templ = gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse));\n+\n+  if (filter) {\n+    GstCaps *fcopy = gst_caps_copy (filter);\n+    \/* Remove the fields we convert *\/\n+    remove_fields (fcopy);\n+    add_conversion_fields (fcopy);\n+    peercaps = gst_pad_peer_query_caps (GST_BASE_PARSE_SRC_PAD (parse), fcopy);\n+    gst_caps_unref (fcopy);\n+  } else\n+    peercaps = gst_pad_peer_query_caps (GST_BASE_PARSE_SRC_PAD (parse), NULL);\n+\n+  if (peercaps) {\n+    peercaps = gst_caps_make_writable (peercaps);\n+    \/* Remove the fields we convert *\/\n+    remove_fields (peercaps);\n+    add_conversion_fields (peercaps);\n+\n+    res = gst_caps_intersect_full (peercaps, templ, GST_CAPS_INTERSECT_FIRST);\n+    gst_caps_unref (peercaps);\n+    gst_caps_unref (templ);\n+  } else {\n+    res = templ;\n+  }\n+\n+  if (filter) {\n+    GstCaps *intersection;\n+\n+    intersection =\n+        gst_caps_intersect_full (filter, res, GST_CAPS_INTERSECT_FIRST);\n+    gst_caps_unref (res);\n+    res = intersection;\n+  }\n+\n+  return res;\n+}\n+\n+static gboolean\n+gst_aac_parse_src_event (GstBaseParse * parse, GstEvent * event)\n+{\n+  GstAacParse *aacparse = GST_AAC_PARSE (parse);\n+\n+  if (GST_EVENT_TYPE (event) == GST_EVENT_FLUSH_STOP) {\n+    aacparse->last_parsed_channels = 0;\n+    aacparse->last_parsed_sample_rate = 0;\n+  }\n+\n+  return GST_BASE_PARSE_CLASS (parent_class)->src_event (parse, event);\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/audioparsers\/gstaacparse.c","additions":1674,"deletions":0,"binary":false,"changes":1674,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/* GStreamer AAC parser\n+ * Copyright (C) 2008 Nokia Corporation. All rights reserved.\n+ *\n+ * Contact: Stefan Kost <stefan.kost@nokia.com>\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+#ifndef __GST_AAC_PARSE_H__\n+#define __GST_AAC_PARSE_H__\n+\n+#include <gst\/gst.h>\n+#include <gst\/base\/gstbaseparse.h>\n+\n+G_BEGIN_DECLS\n+\n+#define GST_TYPE_AAC_PARSE \\\n+  (gst_aac_parse_get_type())\n+#define GST_AAC_PARSE(obj) \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AAC_PARSE, GstAacParse))\n+#define GST_AAC_PARSE_CLASS(klass) \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AAC_PARSE, GstAacParseClass))\n+#define GST_IS_AAC_PARSE(obj) \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AAC_PARSE))\n+#define GST_IS_AAC_PARSE_CLASS(klass) \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AAC_PARSE))\n+\n+\n+\/**\n+ * GstAacHeaderType:\n+ * @DSPAAC_HEADER_NOT_PARSED: Header not parsed yet.\n+ * @DSPAAC_HEADER_UNKNOWN: Unknown (not recognized) header.\n+ * @DSPAAC_HEADER_ADIF: ADIF header found.\n+ * @DSPAAC_HEADER_ADTS: ADTS header found.\n+ * @DSPAAC_HEADER_LOAS: LOAS header found.\n+ * @DSPAAC_HEADER_NONE: Raw stream, no header.\n+ *\n+ * Type header enumeration set in #header_type.\n+ *\/\n+typedef enum {\n+  DSPAAC_HEADER_NOT_PARSED,\n+  DSPAAC_HEADER_UNKNOWN,\n+  DSPAAC_HEADER_ADIF,\n+  DSPAAC_HEADER_ADTS,\n+  DSPAAC_HEADER_LOAS,\n+  DSPAAC_HEADER_NONE\n+} GstAacHeaderType;\n+\n+\n+typedef struct _GstAacParse GstAacParse;\n+typedef struct _GstAacParseClass GstAacParseClass;\n+\n+\/**\n+ * GstAacParse:\n+ *\n+ * The opaque GstAacParse data structure.\n+ *\/\n+struct _GstAacParse {\n+  GstBaseParse element;\n+\n+  \/* Stream type -related info *\/\n+  gint           object_type;\n+  gint           bitrate;\n+  gint           sample_rate;\n+  gint           channels;\n+  gint           mpegversion;\n+  gint           frame_samples;\n+\n+  GstAacHeaderType header_type;\n+  GstAacHeaderType output_header_type;\n+\n+  gboolean sent_codec_tag;\n+\n+  gint last_parsed_sample_rate;\n+  gint last_parsed_channels;\n+};\n+\n+\/**\n+ * GstAacParseClass:\n+ * @parent_class: Element parent class.\n+ *\n+ * The opaque GstAacParseClass data structure.\n+ *\/\n+struct _GstAacParseClass {\n+  GstBaseParseClass parent_class;\n+};\n+\n+GType gst_aac_parse_get_type (void);\n+\n+G_END_DECLS\n+\n+#endif \/* __GST_AAC_PARSE_H__ *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/audioparsers\/gstaacparse.h","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -36,0 +36,3 @@\n+#ifdef LINUX\n+#include \"gstaacparse.h\"\n+#endif \/\/ LINUX\n@@ -72,0 +75,6 @@\n+#ifdef LINUX\n+  return gst_element_register (plugin, \"aacparse\",\n+      GST_RANK_PRIMARY + 1, GST_TYPE_AAC_PARSE) &\n+         gst_element_register (plugin, \"mpegaudioparse\",\n+      GST_RANK_PRIMARY + 2, GST_TYPE_MPEG_AUDIO_PARSE);\n+#else \/\/ LINUX\n@@ -74,0 +83,1 @@\n+#endif \/\/ LINUX\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/audioparsers\/parsersplugin.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7079,0 +7079,7 @@\n+#ifdef GSTREAMER_LITE\n+if (demux->got_moov && QTDEMUX_N_STREAMS (demux) > 0 &&\n+              !demux->fragmented) { \/\/ Do not skip moov for fMP4, otherwise\n+              \/\/ downstream will not receive header during stream switch.\n+              \/\/ Might need better solution, but fine for our current use\n+              \/\/ case.\n+#else \/\/ GSTREAMER_LITE\n@@ -7082,0 +7089,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -14323,0 +14331,3 @@\n+#ifdef GSTREAMER_LITE\n+          \"fragmented\", G_TYPE_BOOLEAN, qtdemux->fragmented,\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux.c","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,2 +477,0 @@\n-                else\n-                    post_message(demuxer, \"Demuxer thread is not null\", GST_MESSAGE_ERROR, GST_CORE_ERROR, GST_CORE_ERROR_THREAD);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/mpegtsdemuxer.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-static void videodecoder_dispose(GObject* object)\n+void videodecoder_close_decoder(VideoDecoder *decoder)\n@@ -177,2 +177,0 @@\n-    VideoDecoder *decoder = VIDEODECODER(object);\n-\n@@ -198,0 +196,7 @@\n+}\n+\n+static void videodecoder_dispose(GObject* object)\n+{\n+    VideoDecoder *decoder = VIDEODECODER(object);\n+\n+    basedecoder_close_decoder(decoder);\n@@ -382,3 +387,2 @@\n-\n-    if (base->is_initialized)\n-        return TRUE;\n+    gint width = 0;\n+    gint height = 0;\n@@ -391,0 +395,16 @@\n+    \/\/ Reload decoder if input resolution changed.\n+    if (gst_structure_get_int(s, \"width\", &width) && gst_structure_get_int(s, \"height\", &height))\n+    {\n+        if (decoder->width != 0 && decoder->height != 0 &&\n+                (decoder->width != width || decoder->height != height))\n+        {\n+            videodecoder_state_reset(decoder);\n+            basedecoder_close_decoder(BASEDECODER(decoder));\n+            videodecoder_close_decoder(decoder);\n+            videodecoder_init_state(decoder);\n+        }\n+    }\n+\n+    if (base->is_initialized)\n+        return TRUE;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/videodecoder.c","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,3 @@\n+#define MP2T_PTS_INPUT_DEBUG 0\n+#define H264_PTS_INPUT_DEBUG 0\n+#define AAC_PTS_INPUT_DEBUG 0\n@@ -359,0 +362,5 @@\n+\n+    decoder->fragmented = FALSE;\n+    decoder->width = 0;\n+    decoder->height = 0;\n+    decoder->lengthSizeMinusOne = 0;\n@@ -751,1 +759,1 @@\n-                    g_print(\"JFXMEDIA MP2T H264 %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]), GST_BUFFER_DURATION(decoder->out_buffer[pUserData->output_index]));\n+                    g_print(\"JFXMEDIA OUTPUT MP2T H264 %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]), GST_BUFFER_DURATION(decoder->out_buffer[pUserData->output_index]));\n@@ -753,1 +761,1 @@\n-                    g_print(\"DEBUG MP2T H264 %I64u -1\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]));\n+                    g_print(\"JFXMEDIA OUTPUT MP2T H264 %I64u -1\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]));\n@@ -755,1 +763,1 @@\n-                    g_print(\"JFXMEDIA MP2T H264 -1\\n\");\n+                    g_print(\"JFXMEDIA OUTPUT MP2T H264 -1\\n\");\n@@ -760,1 +768,1 @@\n-                    g_print(\"JFXMEDIA MP2T AAC  %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]), GST_BUFFER_DURATION(decoder->out_buffer[pUserData->output_index]));\n+                    g_print(\"JFXMEDIA OUTPUT MP2T AAC  %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]), GST_BUFFER_DURATION(decoder->out_buffer[pUserData->output_index]));\n@@ -762,1 +770,1 @@\n-                    g_print(\"JFXMEDIA MP2T AAC  %I64u -1\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]));\n+                    g_print(\"JFXMEDIA OUTPUT MP2T AAC  %I64u -1\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]));\n@@ -764,1 +772,1 @@\n-                    g_print(\"JFXMEDIA MP2T AAC  -1\\n\");\n+                    g_print(\"JFXMEDIA OUTPUT MP2T AAC  -1\\n\");\n@@ -772,1 +780,1 @@\n-                g_print(\"JFXMEDIA H264 %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]), GST_BUFFER_DURATION(decoder->out_buffer[pUserData->output_index]));\n+                g_print(\"JFXMEDIA OUTPUT H264 %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]), GST_BUFFER_DURATION(decoder->out_buffer[pUserData->output_index]));\n@@ -774,1 +782,1 @@\n-                g_print(\"JFXMEDIA H264 %I64u -1\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]));\n+                g_print(\"JFXMEDIA OUTPUT H264 %I64u -1\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]));\n@@ -776,1 +784,1 @@\n-                g_print(\"JFXMEDIA H264 -1\\n\");\n+                g_print(\"JFXMEDIA OUTPUT H264 -1\\n\");\n@@ -783,1 +791,1 @@\n-                g_print(\"JFXMEDIA AAC  %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]), GST_BUFFER_DURATION(decoder->out_buffer[pUserData->output_index]));\n+                g_print(\"JFXMEDIA OUTPUT AAC  %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]), GST_BUFFER_DURATION(decoder->out_buffer[pUserData->output_index]));\n@@ -785,1 +793,1 @@\n-                g_print(\"JFXMEDIA AAC  %I64u -1\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]));\n+                g_print(\"JFXMEDIA OUTPUT AAC  %I64u -1\\n\", GST_BUFFER_TIMESTAMP(decoder->out_buffer[pUserData->output_index]));\n@@ -787,1 +795,1 @@\n-                g_print(\"JFXMEDIA AAC  -1\\n\");\n+                g_print(\"JFXMEDIA OUTPUT AAC  -1\\n\");\n@@ -1192,1 +1200,1 @@\n-gsize dshowwrapper_get_avc_config(void *in, gsize in_size, BYTE *out, gsize out_size, guint *avcProfile, guint *avcLevel, guint *lengthSizeMinusOne)\n+gsize dshowwrapper_get_avc_config(void *in, gsize in_size, BYTE *out, gsize out_size, guint *lengthSizeMinusOne)\n@@ -1197,1 +1205,1 @@\n-    guint16 structSize = 0;\n+    guint16 nalUnitLength = 0;\n@@ -1199,1 +1207,0 @@\n-    gsize size = 0;\n@@ -1211,2 +1218,0 @@\n-    *avcProfile = header->avcProfile;\n-    *avcLevel = header->avcLevel;\n@@ -1218,2 +1223,2 @@\n-    for (ii = 0; ii < header->spsCount; ii++) {\n-\n+    for (ii = 0; ii < header->spsCount; ii++)\n+    {\n@@ -1223,4 +1228,3 @@\n-        structSize = ((guint16)*(guint8*)bdata) << 8;\n-        bdata++;\n-        structSize |= (guint16)*(guint8*)bdata;\n-        bdata++;\n+        nalUnitLength = ((guint16)*(guint8*)bdata) << 8;\n+        nalUnitLength |= (guint16)*(guint8*)(bdata + 1);\n+        nalUnitLength += 2; \/\/ Copy nalUnitLength\n@@ -1228,2 +1232,1 @@\n-        out_bytes_count += (structSize + 2);\n-        if (out_bytes_count > out_size)\n+        if ((out_bytes_count + nalUnitLength) > out_size)\n@@ -1232,2 +1235,1 @@\n-        in_bytes_count += structSize;\n-        if (in_bytes_count > in_size)\n+        if ((in_bytes_count + nalUnitLength) > in_size)\n@@ -1236,4 +1238,4 @@\n-        memcpy(out, ((guint8*)bdata - 2), structSize + 2);\n-        size += structSize + 2;\n-        out += size;\n-        bdata += structSize;\n+        \/\/ Copy nal unit\n+        memcpy(out, (guint8*)bdata, nalUnitLength);\n+        bdata += nalUnitLength; in_bytes_count += nalUnitLength;\n+        out += nalUnitLength; out_bytes_count += nalUnitLength;\n@@ -1243,1 +1245,1 @@\n-            return 0;\n+        return 0;\n@@ -1250,2 +1252,2 @@\n-    for (ii = 0; ii < ppsCount; ii++) {\n-\n+    for (ii = 0; ii < ppsCount; ii++)\n+    {\n@@ -1255,4 +1257,3 @@\n-        structSize = ((guint16)*(guint8*)bdata) << 8;\n-        bdata++;\n-        structSize |= (guint16)*(guint8*)bdata;\n-        bdata++;\n+        nalUnitLength = ((guint16)*(guint8*)bdata) << 8;\n+        nalUnitLength |= (guint16)*(guint8*)(bdata + 1);\n+        nalUnitLength += 2; \/\/ Copy nalUnitLength\n@@ -1260,2 +1261,1 @@\n-        out_bytes_count += (structSize + 2);\n-        if (out_bytes_count > out_size)\n+       if ((out_bytes_count + nalUnitLength) > out_size)\n@@ -1264,2 +1264,1 @@\n-        in_bytes_count += structSize;\n-        if (in_bytes_count > in_size)\n+        if ((in_bytes_count + nalUnitLength) > in_size)\n@@ -1268,4 +1267,4 @@\n-        memcpy(out, ((guint8*)bdata - 2), structSize + 2);\n-        size += structSize + 2;\n-        out += size;\n-        bdata += structSize;\n+        \/\/ Copy nal unit\n+        memcpy(out, (guint8*)bdata, nalUnitLength);\n+        bdata += nalUnitLength; in_bytes_count += nalUnitLength;\n+        out += nalUnitLength; out_bytes_count += nalUnitLength;\n@@ -1274,1 +1273,1 @@\n-    return size;\n+    return out_bytes_count;\n@@ -1311,1 +1310,1 @@\n-        count = sizeof(szAACDecoders)\/sizeof(WCHAR*);\n+        count = sizeof(szAVCDecoders)\/sizeof(WCHAR*);\n@@ -1467,0 +1466,3 @@\n+    if (decoder->pDecoder != NULL)\n+        return TRUE;\n+\n@@ -1649,0 +1651,3 @@\n+    if (decoder->pDecoder != NULL)\n+        return TRUE;\n+\n@@ -1839,0 +1844,3 @@\n+    if (decoder->pDecoder != NULL)\n+        return;\n+\n@@ -1934,0 +1942,54 @@\n+static gboolean dshowwrapper_reload_decoder_h264_fragmented(GstDShowWrapper *decoder, sInputFormat *pInputFormat, sOutputFormat *pOutputFormat)\n+{\n+    HRESULT hr = S_OK;\n+    OAFilterState fs = 0;\n+    IPin *pOutput = NULL;\n+\n+    if (decoder->pMediaControl)\n+    {\n+        decoder->pMediaControl->Stop();\n+        decoder->pMediaControl->GetState(5000, &fs);\n+    }\n+\n+    if (decoder->pDecoder != NULL && decoder->pGraph != NULL)\n+    {\n+        decoder->pGraph->RemoveFilter(decoder->pDecoder);\n+        decoder->pDecoder->Release();\n+        decoder->pDecoder = NULL;\n+    }\n+\n+    hr = decoder->pSrc->InitMediaType(pInputFormat);\n+    if (FAILED(hr))\n+        return FALSE;\n+\n+    hr = decoder->pSink[0]->InitMediaType(pOutputFormat);\n+    if (FAILED(hr))\n+        return FALSE;\n+\n+    dshowwrapper_load_decoder_h264(decoder, JFX_CODEC_ID_AVC1);\n+    if (decoder->pDecoder == NULL)\n+        return FALSE;\n+\n+    \/\/ Add decoder\n+    hr = decoder->pGraph->AddFilter(decoder->pDecoder, L\"Decoder\");\n+    if (FAILED(hr))\n+    {\n+        return FALSE;\n+    }\n+\n+    if (!dshowwrapper_connect_filters(decoder, decoder->pISrc, decoder->pDecoder))\n+    {\n+        return FALSE;\n+    }\n+\n+    if (!dshowwrapper_connect_filters(decoder, decoder->pDecoder, decoder->pISink[0]))\n+    {\n+        return FALSE;\n+    }\n+\n+    if (decoder->pMediaControl)\n+        decoder->pMediaControl->Run();\n+\n+    return TRUE;\n+}\n+\n@@ -1937,0 +1999,3 @@\n+    HRESULT hr = S_OK;\n+\n+    gboolean reloadDecoder = FALSE;\n@@ -1950,0 +2015,6 @@\n+    GstMapInfo codec_data_info;\n+    BYTE header[MAX_HEADER_SIZE];\n+    gint header_size = 0;\n+\n+    if (!gst_structure_get_boolean(s, \"fragmented\", &decoder->fragmented))\n+        decoder->fragmented = FALSE;\n@@ -1953,5 +2024,0 @@\n-        \/\/ Load AVC1 decoder\n-        dshowwrapper_load_decoder_h264(decoder, JFX_CODEC_ID_AVC1);\n-        if (decoder->pDecoder == NULL)\n-            return FALSE;\n-\n@@ -1965,0 +2031,18 @@\n+    }\n+\n+    if (decoder->pDecoder != NULL)\n+    {\n+        if (decoder->fragmented &&\n+              (decoder->width != width || decoder->height != height) &&\n+               decoder->width != 0 && decoder->height != 0)\n+            reloadDecoder = TRUE;\n+        else\n+            return TRUE;\n+    }\n+\n+    if (width != 0 && height != 0)\n+    {\n+        \/\/ Load AVC1 decoder\n+        dshowwrapper_load_decoder_h264(decoder, JFX_CODEC_ID_AVC1);\n+        if (decoder->pDecoder == NULL)\n+            return FALSE;\n@@ -1967,6 +2051,0 @@\n-        BYTE header[MAX_HEADER_SIZE];\n-        gint header_size = 0;\n-        guint avcProfile = 0;\n-        guint avcLevel = 0;\n-        guint lengthSizeMinusOne = 0;\n-        GstMapInfo info;\n@@ -1975,1 +2053,1 @@\n-            if (gst_buffer_map(codec_data, &info, GST_MAP_READ))\n+            if (gst_buffer_map(codec_data, &codec_data_info, GST_MAP_READ))\n@@ -1977,3 +2055,3 @@\n-                if (info.size <= MAX_HEADER_SIZE)\n-                    header_size = dshowwrapper_get_avc_config(info.data, info.size, header, 256, &avcProfile, &avcLevel, &lengthSizeMinusOne);\n-                gst_buffer_unmap(codec_data, &info);\n+                if (codec_data_info.size <= MAX_HEADER_SIZE)\n+                    header_size = dshowwrapper_get_avc_config(codec_data_info.data, codec_data_info.size, header, MAX_HEADER_SIZE, &decoder->lengthSizeMinusOne);\n+                gst_buffer_unmap(codec_data, &codec_data_info);\n@@ -2021,1 +2099,1 @@\n-        pbFormat->dwFlags = lengthSizeMinusOne + 1;\n+        pbFormat->dwFlags = decoder->lengthSizeMinusOne + 1;\n@@ -2033,0 +2111,3 @@\n+\n+        decoder->width = width;\n+        decoder->height = height;\n@@ -2068,1 +2149,1 @@\n-    if (!dshowwrapper_create_ds_source(decoder, &inputFormat))\n+    if (!reloadDecoder && !dshowwrapper_create_ds_source(decoder, &inputFormat))\n@@ -2179,1 +2260,1 @@\n-    if (!dshowwrapper_create_ds_sink(decoder, &outputFormat, 0, true))\n+    if (!reloadDecoder && !dshowwrapper_create_ds_sink(decoder, &outputFormat, 0, true))\n@@ -2182,0 +2263,7 @@\n+\n+    if (reloadDecoder)\n+    {\n+        if (!dshowwrapper_reload_decoder_h264_fragmented(decoder, &inputFormat, &outputFormat))\n+            goto exit;\n+    }\n+\n@@ -2804,0 +2892,34 @@\n+#if MP2T_PTS_INPUT_DEBUG\n+    if (decoder->eInputFormat == MEDIA_FORMAT_STREAM_MP2T)\n+    {\n+        if (GST_BUFFER_TIMESTAMP_IS_VALID(buf) && GST_BUFFER_DURATION_IS_VALID(buf))\n+             g_print(\"JFXMEDIA INPUT MP2T %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(buf), GST_BUFFER_DURATION(buf));\n+        else if (GST_BUFFER_TIMESTAMP_IS_VALID(buf) && !GST_BUFFER_DURATION_IS_VALID(buf))\n+            g_print(\"JFXMEDIA INPUT MP2T %I64u -1\\n\", GST_BUFFER_TIMESTAMP(buf));\n+        else\n+            g_print(\"JFXMEDIA INPUT MP2T -1\\n\");\n+    }\n+#endif\n+#if H264_PTS_INPUT_DEBUG\n+    if (decoder->eInputFormat == MEDIA_FORMAT_VIDEO_H264 || decoder->eInputFormat == MEDIA_FORMAT_VIDEO_AVC1)\n+    {\n+        if (GST_BUFFER_TIMESTAMP_IS_VALID(buf) && GST_BUFFER_DURATION_IS_VALID(buf))\n+            g_print(\"JFXMEDIA INPUT H264 %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(buf), GST_BUFFER_DURATION(buf));\n+        else if (GST_BUFFER_TIMESTAMP_IS_VALID(buf) && !GST_BUFFER_DURATION_IS_VALID(buf))\n+            g_print(\"JFXMEDIA INPUT H264 %I64u -1\\n\", GST_BUFFER_TIMESTAMP(buf));\n+        else\n+            g_print(\"JFXMEDIA INPUT H264 -1\\n\");\n+    }\n+#endif\n+#if AAC_PTS_INPUT_DEBUG\n+    if (decoder->eInputFormat == MEDIA_FORMAT_AUDIO_AAC)\n+    {\n+        if (GST_BUFFER_TIMESTAMP_IS_VALID(buf) && GST_BUFFER_DURATION_IS_VALID(buf))\n+            g_print(\"JFXMEDIA INPUT AAC  %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(buf), GST_BUFFER_DURATION(buf));\n+        else if (GST_BUFFER_TIMESTAMP_IS_VALID(buf) && !GST_BUFFER_DURATION_IS_VALID(buf))\n+            g_print(\"JFXMEDIA INPUT AAC  %I64u -1\\n\", GST_BUFFER_TIMESTAMP(buf));\n+        else\n+            g_print(\"JFXMEDIA INPUT AAC  -1\\n\");\n+    }\n+#endif\n+\n@@ -2878,0 +3000,1 @@\n+        gst_event_copy_segment(event, &segment);\n@@ -2880,1 +3003,0 @@\n-            gst_event_copy_segment(event, &segment);\n@@ -2888,1 +3010,0 @@\n-            gst_event_copy_segment(event, &segment);\n@@ -2917,0 +3038,1 @@\n+\n@@ -2921,1 +3043,0 @@\n-            HRESULT hr = S_OK;\n@@ -2941,1 +3062,0 @@\n-            HRESULT hr = S_OK;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/dshowwrapper\/dshowwrapper.cpp","additions":191,"deletions":71,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,0 +155,5 @@\n+\n+    gboolean fragmented;\n+    gint width;\n+    gint height;\n+    guint lengthSizeMinusOne;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/dshowwrapper\/dshowwrapper.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+#define HLS_PROP_LOAD_SEGMENT                4\n+#define HLS_PROP_SEGMENT_START_TIME          5\n@@ -55,1 +57,0 @@\n-    SIGNAL_GET_STREAM_SIZE,\n@@ -286,10 +287,0 @@\n-\n-    klass->signals[SIGNAL_GET_STREAM_SIZE] = g_signal_new (\"get-stream-size\",\n-        G_TYPE_FROM_CLASS (klass),\n-        G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n-        0,\n-        NULL, \/* accumulator *\/\n-        NULL, \/* accu_data *\/\n-        source_marshal_INT__VOID,\n-        G_TYPE_INT, \/* return_type *\/\n-        0    \/* n_params *\/ );\n@@ -577,0 +568,1 @@\n+                    gint start_time = 0;\n@@ -578,1 +570,6 @@\n-                    g_signal_emit(element, JAVA_SOURCE_GET_CLASS(element)->signals[SIGNAL_GET_STREAM_SIZE], 0, &result);\n+                    g_signal_emit(element,\n+                        JAVA_SOURCE_GET_CLASS(element)->signals[SIGNAL_PROPERTY],\n+                        0, HLS_PROP_LOAD_SEGMENT, 0, &result);\n+                    g_signal_emit(element,\n+                        JAVA_SOURCE_GET_CLASS(element)->signals[SIGNAL_PROPERTY],\n+                        0, HLS_PROP_SEGMENT_START_TIME, 0, &start_time);\n@@ -602,1 +599,1 @@\n-                    segment.start = 0;\n+                    segment.start = ((gint64)start_time*GST_SECOND) \/ HLS_VALUE_FLOAT_MULTIPLIER;\n@@ -664,1 +661,9 @@\n-                            caps = gst_caps_new_simple (element->mimetype, NULL, NULL);\n+                            \/\/ Special case for HLS AAC elementary stream.\n+                            \/\/ It has \"audio\/aac\" mimetype which is same as\n+                            \/\/ \"audio\/mpeg\" mpegversion=4. We changing it here\n+                            \/\/ so downstream will undestand it.\n+                            if (strstr(element->mimetype, \"audio\/aac\") != NULL)\n+                                caps = gst_caps_new_simple(\"audio\/mpeg\", \"mpegversion\", G_TYPE_INT, 4, NULL);\n+                            else\n+                                caps = gst_caps_new_simple(element->mimetype, NULL, NULL);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/javasource\/javasource.c","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,1 @@\n+    decoder->is_decoder_initialized = FALSE;\n@@ -192,0 +193,1 @@\n+    decoder->force_output_discontinuity = FALSE;\n@@ -329,0 +331,1 @@\n+    {\n@@ -330,0 +333,2 @@\n+        decoder->force_output_discontinuity = TRUE;\n+    }\n@@ -720,0 +725,7 @@\n+        if (SUCCEEDED(hr) && decoder->force_output_discontinuity)\n+        {\n+            pGstBuffer = gst_buffer_make_writable(pGstBuffer);\n+            GST_BUFFER_FLAG_SET(pGstBuffer, GST_BUFFER_FLAG_DISCONT);\n+            decoder->force_output_discontinuity = FALSE;\n+        }\n+\n@@ -1188,0 +1200,1 @@\n+    HRESULT hr = S_OK;\n@@ -1193,0 +1206,2 @@\n+    IMFAttributes *pAttributes = NULL;\n+    UINT32 unFormatChange = FALSE;\n@@ -1194,4 +1209,4 @@\n-    HRESULT hr = mfwrapper_load_decoder(decoder, caps);\n-\n-    if (SUCCEEDED(hr))\n-        hr = mfwrapper_set_input_media_type(decoder, caps);\n+    if (!decoder->is_decoder_initialized)\n+    {\n+        if (SUCCEEDED(hr))\n+            hr = mfwrapper_set_input_media_type(decoder, caps);\n@@ -1199,2 +1214,2 @@\n-    if (SUCCEEDED(hr))\n-        hr = mfwrapper_set_output_media_type(decoder, caps);\n+        if (SUCCEEDED(hr))\n+            hr = mfwrapper_set_output_media_type(decoder, caps);\n@@ -1202,2 +1217,2 @@\n-    if (SUCCEEDED(hr))\n-        hr = decoder->pDecoder->GetInputStatus(0, &dwStatus);\n+        if (SUCCEEDED(hr))\n+            hr = decoder->pDecoder->GetInputStatus(0, &dwStatus);\n@@ -1205,2 +1220,3 @@\n-    if (FAILED(hr) || dwStatus != MFT_INPUT_STATUS_ACCEPT_DATA) {\n-        return FALSE;\n+        if (FAILED(hr) || dwStatus != MFT_INPUT_STATUS_ACCEPT_DATA) {\n+            return FALSE;\n+        }\n@@ -1228,0 +1244,4 @@\n+            \/\/ Free old one if exist\n+            if (decoder->header)\n+                delete[] decoder->header;\n+\n@@ -1247,2 +1267,4 @@\n-    if (SUCCEEDED(hr))\n-        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL);\n+    if (!decoder->is_decoder_initialized)\n+    {\n+        if (SUCCEEDED(hr))\n+            hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL);\n@@ -1250,2 +1272,2 @@\n-    if (SUCCEEDED(hr))\n-        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL);\n+        if (SUCCEEDED(hr))\n+            hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL);\n@@ -1253,2 +1275,6 @@\n-    if (SUCCEEDED(hr))\n-        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL);\n+        if (SUCCEEDED(hr))\n+            hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL);\n+\n+        if (SUCCEEDED(hr))\n+            decoder->is_decoder_initialized = TRUE;\n+    }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.cpp","additions":43,"deletions":17,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    gboolean is_decoder_initialized;\n@@ -65,0 +66,1 @@\n+    gboolean force_output_discontinuity;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,7 @@\n+enum\n+{\n+    HLS_FORMAT_UNKNOWN = 0x0,\n+    HLS_FORMAT_MP2T,\n+    HLS_FORMAT_FMP4\n+};\n+\n@@ -46,0 +53,2 @@\n+    gint          hls_format;\n+\n@@ -49,3 +58,3 @@\n-    GMutex       lock;\n-    GCond        add_cond;\n-    GCond        del_cond;\n+    GMutex        lock;\n+    GCond         add_cond;\n+    GCond         del_cond;\n@@ -56,0 +65,1 @@\n+    gboolean      cache_discont[NUM_OF_CACHED_SEGMENTS];\n@@ -67,1 +77,1 @@\n-    GstClockTime buffer_pts;\n+    GstClockTime  buffer_pts;\n@@ -164,1 +174,1 @@\n-    int i = 0;\n+    element->hls_format = HLS_FORMAT_FMP4;\n@@ -179,1 +189,1 @@\n-    for (i = 0; i < NUM_OF_CACHED_SEGMENTS; i++)\n+    for (int i = 0; i < NUM_OF_CACHED_SEGMENTS; i++)\n@@ -184,0 +194,1 @@\n+        element->cache_discont[i] = FALSE;\n@@ -325,0 +336,5 @@\n+        if (GST_BUFFER_FLAG_IS_SET(data, GST_BUFFER_FLAG_DISCONT))\n+        {\n+            element->cache_discont[element->cache_write_index] = TRUE;\n+        }\n+\n@@ -418,0 +434,7 @@\n+        if (element->cache_discont[element->cache_read_index])\n+        {\n+            buffer = gst_buffer_make_writable(buffer);\n+            GST_BUFFER_FLAG_SET(buffer, GST_BUFFER_FLAG_DISCONT);\n+            element->cache_discont[element->cache_read_index] = FALSE;\n+        }\n+\n@@ -496,6 +519,0 @@\n-            if (segment.stop - segment.start <= 0)\n-            {\n-                gst_element_message_full(GST_ELEMENT(element), GST_MESSAGE_ERROR, GST_STREAM_ERROR, GST_STREAM_ERROR_WRONG_TYPE, g_strdup(\"Only limited content is supported by hlsprogressbuffer.\"), NULL, (\"hlsprogressbuffer.c\"), (\"hls_progress_buffer_sink_event\"), 0);\n-                return TRUE;\n-            }\n-\n@@ -505,1 +522,1 @@\n-                gst_segment_init (&new_segment, GST_FORMAT_TIME);\n+                gst_segment_init(&new_segment, GST_FORMAT_TIME);\n@@ -508,1 +525,1 @@\n-                new_segment.start = segment.position;\n+                new_segment.start = segment.start;\n@@ -511,1 +528,1 @@\n-                new_segment.time = segment.position;\n+                new_segment.time = segment.time;\n@@ -515,2 +532,3 @@\n-                event = gst_event_new_segment (&new_segment);\n-                element->send_new_segment = FALSE;\n+                event = gst_event_new_segment(&new_segment);\n+                if (segment.start != 0)\n+                  element->send_new_segment = FALSE;\n@@ -518,1 +536,1 @@\n-            }\n+             }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/progressbuffer\/hlsprogressbuffer.c","additions":37,"deletions":19,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -238,0 +238,1 @@\n+          gst-plugins-good\/gst\/audioparsers\/gstaacparse.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/linux\/gstreamer-lite\/Makefile","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,3 +75,0 @@\n-    \/* Get stream size. *\/\n-    virtual int GetStreamSize() = 0;\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/Locator\/LocatorStream.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+#define CONTENT_TYPE_FMP4   \"video\/quicktime\"\n+#define CONTENT_TYPE_AAC    \"audio\/aac\"\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/MediaManagement\/MediaTypes.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-jmethodID CJavaInputStreamCallbacks::m_GetStreamSizeMID = 0;\n@@ -145,6 +144,0 @@\n-        if (!hasException)\n-        {\n-            m_GetStreamSizeMID = env->GetMethodID(klass, \"getStreamSize\", \"()I\");\n-            hasException = javaEnv.reportException();\n-        }\n-\n@@ -332,19 +325,0 @@\n-\n-int CJavaInputStreamCallbacks::GetStreamSize()\n-{\n-    CJavaEnvironment javaEnv(m_jvm);\n-    JNIEnv *pEnv = javaEnv.getEnvironment();\n-    int result = 0;\n-\n-    if (pEnv) {\n-        jobject connection = pEnv->NewLocalRef(m_ConnectionHolder);\n-        if (connection) {\n-            result = pEnv->CallIntMethod(connection, m_GetStreamSizeMID);\n-            pEnv->DeleteLocalRef(connection);\n-        }\n-\n-        javaEnv.reportException();\n-    }\n-\n-    return result;\n-}\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/jni\/JavaInputStreamCallbacks.cpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-    int  GetStreamSize();\n@@ -64,1 +63,0 @@\n-    static jmethodID m_GetStreamSizeMID;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/jni\/JavaInputStreamCallbacks.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -989,0 +989,15 @@\n+                else if (strstr(mimetype, CONTENT_TYPE_AAC) != NULL)\n+                {\n+                    gboolean is_supported = FALSE;\n+                    g_object_set(m_Elements[AUDIO_DECODER], \"codec-id\", (gint)JFX_CODEC_ID_AAC, NULL);\n+                    g_object_get(m_Elements[AUDIO_DECODER], \"is-supported\", &is_supported, NULL);\n+                    if (is_supported)\n+                    {\n+                        return TRUE;\n+                    }\n+                    else\n+                    {\n+                        m_audioCodecErrorCode = ERROR_MEDIA_AAC_FORMAT_UNSUPPORTED;\n+                        return FALSE;\n+                    }\n+                }\n@@ -1823,0 +1838,4 @@\n+        else if (m_AudioTrackInfo.mimeType.find(CONTENT_TYPE_AAC))\n+        {\n+            encoding = CTrack::AAC;\n+        }\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAudioPlaybackPipeline.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,2 @@\n+#define HLS_VALUE_MIMETYPE_FMP4 3\n+#define HLS_VALUE_MIMETYPE_AAC  4\n@@ -211,1 +213,0 @@\n-            g_signal_connect (javaSource, \"get-stream-size\", G_CALLBACK (SourceGetStreamSize), callbacks);\n@@ -223,0 +224,4 @@\n+            else if (streamMimeType == HLS_VALUE_MIMETYPE_FMP4)\n+                g_object_set (javaSource, \"mimetype\", CONTENT_TYPE_FMP4, NULL);\n+            else if (streamMimeType == HLS_VALUE_MIMETYPE_AAC)\n+                g_object_set (javaSource, \"mimetype\", CONTENT_TYPE_AAC, NULL);\n@@ -310,5 +315,0 @@\n-int CGstPipelineFactory::SourceGetStreamSize(GstElement *src, gpointer data)\n-{\n-    return ((CStreamCallbacks*)data)->GetStreamSize();\n-}\n-\n@@ -325,1 +325,0 @@\n-    g_signal_handlers_disconnect_by_func (src, (void*)G_CALLBACK (SourceGetStreamSize), callbacks);\n@@ -546,0 +545,5 @@\n+    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_AAC)\n+        return CreateAudioPipeline(source, NULL, \"dshowwrapper\", false, pOptions, ppPipeline);\n+    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n+        \/\/ Video decoder is loaded dynamically\n+        return CreateAVPipeline(source, \"qtdemux\", \"dshowwrapper\", true, NULL, pVideoSink, pOptions, ppPipeline);\n@@ -557,0 +561,4 @@\n+    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_AAC)\n+        return CreateAudioPipeline(source, \"aacparse\", \"avaudiodecoder\", false, pOptions, ppPipeline);\n+    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n+        return CreateAVPipeline(source, \"qtdemux\", \"avaudiodecoder\", true, \"avvideodecoder\", pVideoSink, pOptions, ppPipeline);\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstPipelineFactory.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,0 @@\n-    static int      SourceGetStreamSize(GstElement *src, gpointer data);\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstPipelineFactory.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -208,0 +208,1 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\gstisoff.c\" \/>\r\n@@ -211,0 +212,1 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\properties.c\" \/>\r\n@@ -220,0 +222,2 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_tags.c\" \/>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_tree.c\" \/>\r\n@@ -522,0 +526,14 @@\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\audioparsers\\gstmpegaudioparse.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\descriptors.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\fourcc.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\gstisoff.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\properties.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtatomparser.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_debug.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_dump.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_lang.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_tags.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_tree.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_types.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtpalette.h\" \/>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/gstreamer\/gstreamer.vcxproj","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n@@ -672,0 +672,12 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\gstisoff.c\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClCompile>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\properties.c\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClCompile>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_tags.c\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClCompile>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_tree.c\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClCompile>\r\n@@ -818,0 +830,42 @@\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\descriptors.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\fourcc.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\gstisoff.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\properties.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtatomparser.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_debug.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_dump.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_lang.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_tags.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_tree.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtdemux_types.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\isomp4\\qtpalette.h\">\r\n+      <Filter>gst-plugins-good\\gst\\isomp4<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-good\\gst\\audioparsers\\gstmpegaudioparse.h\">\r\n+      <Filter>gst-plugins-good\\gst\\audioparsers<\/Filter>\r\n+    <\/ClInclude>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/gstreamer\/gstreamer.vcxproj.filters","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\progressbuffer\\cache.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\progressbuffer\\hlsprogressbuffer.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\progressbuffer\\progressbuffer.h\" \/>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/plugins\/plugins.vcxproj","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,11 @@\n+  <ItemGroup>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\progressbuffer\\cache.h\">\r\n+      <Filter>progressbuffer<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\progressbuffer\\hlsprogressbuffer.h\">\r\n+      <Filter>progressbuffer<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\progressbuffer\\progressbuffer.h\">\r\n+      <Filter>progressbuffer<\/Filter>\r\n+    <\/ClInclude>\r\n+  <\/ItemGroup>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/plugins\/plugins.vcxproj.filters","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}