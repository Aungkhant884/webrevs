{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-                    List<E> removed = getRemovedElements(c, 0);\n+                    List<E> removed = getRemovedElements(c, totalRemovedSize);\n@@ -63,1 +63,0 @@\n-                    int adjustedFrom = totalRemovedSize + c.getFrom();\n@@ -65,1 +64,1 @@\n-                        nextRemove(c.getFrom(), getRemovedModelItem(adjustedFrom));\n+                        nextRemove(c.getFrom(), getRemovedModelItem(totalRemovedSize + c.getFrom()));\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/SelectedItemsReadOnlyObservableList.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.com.sun.javafx.scene.control;\n+\n+import com.sun.javafx.collections.ObservableListWrapper;\n+import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+import org.junit.Before;\n+import org.junit.Test;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SelectedItemsReadOnlyObservableListTest {\n+\n+    ObservableList<String> items;\n+    ObservableList<String> selectedItems;\n+    TestObservableList<Integer> selectedIndices;\n+    List<String> changes;\n+\n+    @Before\n+    public void setup() {\n+        changes = new ArrayList<>();\n+        items = FXCollections.observableArrayList(\"foo\", \"bar\", \"baz\", \"qux\", \"quz\");\n+        selectedIndices = new TestObservableList<>();\n+        selectedItems = new SelectedItemsReadOnlyObservableList<>(selectedIndices, () -> 0) {\n+            @Override protected String getModelItem(int index) { return items.get(index); }\n+        };\n+        selectedItems.addListener((ListChangeListener<? super String>) c -> changes.add(c.toString()));\n+    }\n+\n+    \/**\n+     * { [foo, bar, baz, qux, quz] added at 0 }\n+     * { [foo, bar, baz, qux, quz] removed at 0 }\n+     *\/\n+    @Test\n+    public void testAddAndRemoveEntireRange() {\n+        selectedIndices.addAll(0, 1, 2, 3, 4);\n+        assertEquals(1, changes.size());\n+        assertEquals(change(added(0, \"foo\", \"bar\", \"baz\", \"qux\", \"quz\")), changes.get(0));\n+        changes.clear();\n+        selectedIndices.removeAll(0, 1, 2, 3, 4);\n+        assertEquals(1, changes.size());\n+        assertEquals(change(removed(0, \"foo\", \"bar\", \"baz\", \"qux\", \"quz\")), changes.get(0));\n+    }\n+\n+    \/**\n+     * { [foo, bar, baz, qux, quz] added at 0 }\n+     * { [bar, baz, qux] removed at 1 }\n+     *\/\n+    @Test\n+    public void testRemoveInteriorRange() {\n+        selectedIndices.addAll(0, 1, 2, 3, 4);\n+        changes.clear();\n+        selectedIndices.removeAll(1, 2, 3);\n+        assertEquals(1, changes.size());\n+        assertEquals(change(removed(1, \"bar\", \"baz\", \"qux\")), changes.get(0));\n+    }\n+\n+    \/**\n+     * { [foo, bar, baz, qux, quz] added at 0 }\n+     * { [foo, bar] removed at 0, [qux, quz] removed at 1 }\n+     *\/\n+    @Test\n+    public void testRemoveDisjointRanges() {\n+        selectedIndices.addAll(0, 1, 2, 3, 4);\n+        changes.clear();\n+        selectedIndices.removeAll(0, 1, 3, 4);\n+        assertEquals(1, changes.size());\n+        assertEquals(change(\n+            removed(0, \"foo\", \"bar\"),\n+            removed(1, \"qux\", \"quz\")), changes.get(0));\n+    }\n+\n+    \/**\n+     * Note that using non-atomic swap operations on 'selectedIndices' doesn't work for\n+     * SelectedItemsReadOnlyObservableList, since it results in intermediate states where\n+     * 'selectedIndices' contains duplicates. This results in incorrect change notifications,\n+     * which can be seen in this test:\n+     *\n+     * { [foo, bar] added at 0 }\n+     * { [foo] replaced by [bar] at 0 }, but should be: [foo, bar] replaced by [bar, foo]\n+     *\n+     * This test is a documentation of that fact, and it will start to fail if replaceAll\n+     * is implemented as an atomic operation.\n+     *\/\n+    @Test\n+    public void testReplaceTwoItems() {\n+        selectedIndices.addAll(0, 1);\n+        changes.clear();\n+        selectedIndices.replaceAll(i -> i == 0 ? 1 : 0);\n+        assertEquals(1, changes.size());\n+        assertEquals(change(replaced(0, range(\"foo\"), range(\"bar\"))), changes.get(0));\n+    }\n+\n+    \/**\n+     * Note that using non-atomic swap operations on 'selectedIndices' doesn't work for\n+     * SelectedItemsReadOnlyObservableList, since it results in intermediate states where\n+     * 'selectedIndices' contains duplicates. This results in incorrect change notifications,\n+     * which can be seen in this test:\n+     *\n+     * { [foo, bar, baz, qux, quz] added at 0 }\n+     * { [foo] replaced by [bar] at 0 }, but should be [foo, bar] replaced by [bar, foo]\n+     * { [qux] replaced by [quz] at 3 }, but should be [qux, quz] replaced by [quz, qux]\n+     *\n+     * This test is a documentation of that fact, and it will start to fail if replaceAll\n+     * is implemented as an atomic operation.\n+     *\/\n+    @Test\n+    public void testReplaceDisjointRanges() {\n+        selectedIndices.addAll(0, 1, 2, 3, 4);\n+        changes.clear();\n+        selectedIndices.replaceAll(i -> {\n+            switch (i) {\n+                case 0: return 1;\n+                case 1: return 0;\n+                case 3: return 4;\n+                case 4: return 3;\n+                default: return i;\n+            }\n+        });\n+\n+        assertEquals(2, changes.size());\n+        assertEquals(change(replaced(0, range(\"foo\"), range(\"bar\"))), changes.get(0));\n+        assertEquals(change(replaced(3, range(\"qux\"), range(\"quz\"))), changes.get(1));\n+    }\n+\n+    \/**\n+     * { [foo, bar, baz, qux, quz] added at 0 }\n+     * { [foo, bar] replaced by [bar, foo] at 0, [qux, quz] removed at 3 }\n+     *\/\n+    @Test\n+    public void testReplaceAndRemoveRanges() {\n+        selectedIndices.addAll(0, 1, 2, 3, 4);\n+        changes.clear();\n+        selectedIndices._beginChange();\n+        selectedIndices.set(0, 1);\n+        selectedIndices.set(1, 0);\n+        selectedIndices.remove(3, 5);\n+        selectedIndices._endChange();\n+\n+        assertEquals(1, changes.size());\n+        assertEquals(change(\n+            replaced(0, range(\"foo\", \"bar\"), range(\"bar\", \"foo\")),\n+            removed(3, \"qux\", \"quz\")\n+        ), changes.get(0));\n+    }\n+\n+    \/**\n+     * { [foo, bar, baz, qux, quz] added at 0 }\n+     * { [foo, bar] removed at 0, [qux, quz] replaced by [quz, qux] at 1 }\n+     *\/\n+    @Test\n+    public void testRemoveAndReplaceRanges() {\n+        selectedIndices.addAll(0, 1, 2, 3, 4);\n+        changes.clear();\n+        selectedIndices._beginChange();\n+        selectedIndices.remove(0, 2);\n+        selectedIndices.set(1, 4);\n+        selectedIndices.set(2, 3);\n+        selectedIndices._endChange();\n+\n+        assertEquals(1, changes.size());\n+        assertEquals(change(\n+                removed(0, \"foo\", \"bar\"),\n+                replaced(1, range(\"qux\", \"quz\"), range(\"quz\", \"qux\"))\n+        ), changes.get(0));\n+    }\n+\n+    private String change(String... subChanges) {\n+        return \"{ \" + String.join(\", \", subChanges) + \" }\";\n+    }\n+\n+    private String added(int index, String... items) {\n+        return range(items) + \" added at \" + index;\n+    }\n+\n+    private String removed(int index, String... items) {\n+        return range(items) + \" removed at \" + index;\n+    }\n+\n+    private String replaced(int index, String items, String replacedBy) {\n+        return items + \" replaced by \" + replacedBy + \" at \" + index;\n+    }\n+\n+    private String range(String... items) {\n+        return \"[\" + String.join(\", \", items) + \"]\";\n+    }\n+\n+    private static class TestObservableList<T> extends ObservableListWrapper<T> {\n+        public TestObservableList() { super(new ArrayList<>()); }\n+        public void _beginChange() { beginChange(); }\n+        public void _endChange() { endChange(); }\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/SelectedItemsReadOnlyObservableListTest.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"}]}