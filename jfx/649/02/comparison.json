{"files":[{"patch":"@@ -2934,1 +2934,1 @@\n-                def codecsCfgArgs = [\"--enable-decoder=aac,mp3,mp3float,h264\", \"--enable-parser=aac,h264\", \"--enable-demuxer=aac,h264,mpegts,mpegtsraw\"]\n+                def codecsCfgArgs = [\"--enable-decoder=aac,mp3,mp3float,h264,hevc\", \"--enable-parser=aac,h264,hevc\", \"--enable-demuxer=aac,h264,hevc,mpegts,mpegtsraw\"]\n","filename":"build.gradle","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,3 @@\n-    ERROR_MEDIA_HLS_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000D),\n-    ERROR_MEDIA_CORRUPTED(ERROR_BASE_MEDIA.code()+0x000E),\n+    ERROR_MEDIA_H265_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000D),\n+    ERROR_MEDIA_HLS_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000E),\n+    ERROR_MEDIA_CORRUPTED(ERROR_BASE_MEDIA.code()+0x000F),\n@@ -132,0 +133,2 @@\n+    ERROR_MISSING_LIBSWSCALE(ERROR_BASE_SYSTEM.code()+0x0005),\n+    ERROR_INVALID_LIBSWSCALE(ERROR_BASE_SYSTEM.code()+0x0006),\n","filename":"modules\/javafx.media\/src\/main\/java\/com\/sun\/media\/jfxmedia\/MediaError.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+        H265,\n","filename":"modules\/javafx.media\/src\/main\/java\/com\/sun\/media\/jfxmedia\/track\/Track.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,0 +114,1 @@\n+                errorCode == MediaError.ERROR_MEDIA_H265_FORMAT_UNSUPPORTED.code() ||\n","filename":"modules\/javafx.media\/src\/main\/java\/javafx\/scene\/media\/MediaException.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+<tr><th scope=\"row\">H.265\/HEVC<\/th><td>Video<\/td><td>H.265\/MPEG-H Part 2 \/ HEVC (High Efficiency Video Coding)\n+video compression<\/td><\/tr>\n@@ -104,0 +106,2 @@\n+<tr><th scope=\"row\">MP4<\/th><td>MPEG-4 Part 14<\/td><td>H.265\/HEVC<\/td>\n+    <td>AAC<\/td><td>video\/mp4, audio\/x-m4a, video\/x-m4v<\/td><td>.mp4, .m4a, .m4v<\/td><\/tr>\n","filename":"modules\/javafx.media\/src\/main\/java\/javafx\/scene\/media\/package.html","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -332,1 +332,1 @@\n-        case GST_EVENT_NEWSEGMENT:\n+        case GST_EVENT_SEGMENT:\n@@ -334,8 +334,5 @@\n-            GstFormat format;\n-            gboolean update;\n-            gdouble rate, applied_rate;\n-            gint64 start, stop, time;\n-\n-            gst_event_parse_new_segment_full (event, &update, &rate, &applied_rate, &format, &start, &stop, &time);\n-            g_print(\"audiodecoder_sink_event: NEW_SEGMENT update=%s, rate=%f, format=%d, start=%ld, stop=%ld, time=%ld\\n\",\n-                    update ? \"TRUE\" : \"FALSE\", rate, format, start, stop, time);\n+            GstSegment segment;\n+            gst_event_copy_segment(event, &segment);\n+\n+            g_print(\"audiodecoder_sink_event: NEW_SEGMENT rate=%.1f, format=%d, start=%.3f, stop=%.3f, time=%.3f\\n\",\n+                    segment.rate, segment.format, (double)segment.start\/GST_SECOND, (double)segment.stop\/GST_SECOND, (double)segment.time\/GST_SECOND);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/audiodecoder.c","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,3 @@\n+\/\/ HEVC\/H.265 support should be available in 56 and up\n+#define HEVC_SUPPORT           (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(56,0,0))\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/avdefines.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"fxplugins_common.h\"\n@@ -37,0 +38,1 @@\n+#include <libavutil\/pixfmt.h>\n@@ -41,0 +43,7 @@\n+enum\n+{\n+    PROP_0,\n+    PROP_CODEC_ID,\n+    PROP_IS_SUPPORTED,\n+};\n+\n@@ -44,2 +53,3 @@\n-#define SINK_CAPS                     \\\n-    \"video\/x-h264\"\n+#define SINK_CAPS    \\\n+    \"video\/x-h264; \" \\\n+    \"video\/x-h265\"\n@@ -114,0 +124,4 @@\n+static void videodecoder_dispose(GObject* object);\n+static void videodecoder_set_property(GObject *object, guint property_id, const GValue *value, GParamSpec *pspec);\n+static void videodecoder_get_property(GObject *object, guint property_id, GValue *value, GParamSpec *pspec);\n+\n@@ -117,0 +131,1 @@\n+    GObjectClass *gobject_class = (GObjectClass*)klass;\n@@ -130,0 +145,12 @@\n+\n+    gobject_class->dispose = videodecoder_dispose;\n+    gobject_class->set_property = videodecoder_set_property;\n+    gobject_class->get_property = videodecoder_get_property;\n+\n+    g_object_class_install_property (gobject_class, PROP_CODEC_ID,\n+        g_param_spec_int (\"codec-id\", \"Codec ID\", \"Codec ID\", -1, G_MAXINT, 0,\n+        (GParamFlags)(G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS)));\n+\n+    g_object_class_install_property (gobject_class, PROP_IS_SUPPORTED,\n+        g_param_spec_boolean (\"is-supported\", \"Is supported\", \"Is codec ID supported\", FALSE,\n+        (GParamFlags)(G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS)));\n@@ -148,0 +175,76 @@\n+static void videodecoder_dispose(GObject* object)\n+{\n+    VideoDecoder *decoder = VIDEODECODER(object);\n+\n+#if HEVC_SUPPORT\n+    if (decoder->dest_frame)\n+    {\n+        av_frame_free(&decoder->dest_frame);\n+        decoder->dest_frame = NULL;\n+    }\n+\n+    if (decoder->sws_context)\n+    {\n+        decoder->sws_freeContext_func(decoder->sws_context);\n+        decoder->sws_context = NULL;\n+    }\n+\n+    if (decoder->swscale_module)\n+    {\n+        dlclose(decoder->swscale_module);\n+        decoder->swscale_module = NULL;\n+    }\n+#endif \/\/ HEVC_SUPPORT\n+\n+    G_OBJECT_CLASS(parent_class)->dispose(object);\n+}\n+\n+static gboolean videodecoder_is_decoder_by_codec_id_supported(gint codec_id)\n+{\n+    switch(codec_id)\n+    {\n+    case JFX_CODEC_ID_H265:\n+#if HEVC_SUPPORT\n+        return TRUE;\n+#else \/\/ HEVC_SUPPORT\n+        return FALSE;\n+#endif \/\/ HEVC_SUPPORT\n+        break;\n+    case JFX_CODEC_ID_AVC1:\n+        return TRUE;\n+        break;\n+    case JFX_CODEC_ID_H264:\n+        return TRUE;\n+        break;\n+    }\n+\n+    return FALSE;\n+}\n+\n+static void videodecoder_set_property(GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)\n+{\n+    VideoDecoder *decoder = VIDEODECODER(object);\n+    switch (property_id)\n+    {\n+    case PROP_CODEC_ID:\n+        decoder->codec_id = g_value_get_int(value);\n+        break;\n+    default:\n+        break;\n+    }\n+}\n+\n+static void videodecoder_get_property(GObject *object, guint property_id, GValue *value, GParamSpec *pspec)\n+{\n+    VideoDecoder *decoder = VIDEODECODER(object);\n+    gboolean is_supported = FALSE;\n+    switch (property_id)\n+    {\n+    case PROP_IS_SUPPORTED:\n+        is_supported = videodecoder_is_decoder_by_codec_id_supported(decoder->codec_id);\n+        g_value_set_boolean(value, is_supported);\n+        break;\n+    default:\n+        break;\n+    }\n+}\n@@ -229,1 +332,1 @@\n-        case GST_EVENT_NEWSEGMENT:\n+        case GST_EVENT_SEGMENT:\n@@ -231,4 +334,2 @@\n-            GstFormat format;\n-            gboolean update;\n-            gdouble rate, applied_rate;\n-            gint64 start, stop, time;\n+            GstSegment segment;\n+            gst_event_copy_segment(event, &segment);\n@@ -236,3 +337,2 @@\n-            gst_event_parse_new_segment_full (event, &update, &rate, &applied_rate, &format, &start, &stop, &time);\n-            g_print(\"videodecoder_sink_event: NEW_SEGMENT update=%s, rate=%.1f, format=%d, start=%.3f, stop=%.3f, time=%.3f\\n\",\n-                    update ? \"TRUE\" : \"FALSE\", rate, format, (double)start\/GST_SECOND, (double)stop\/GST_SECOND, (double)time\/GST_SECOND);\n+            g_print(\"videodecoder_sink_event: NEW_SEGMENT rate=%.1f, format=%d, start=%.3f, stop=%.3f, time=%.3f\\n\",\n+                    segment.rate, segment.format, (double)segment.start\/GST_SECOND, (double)segment.stop\/GST_SECOND, (double)segment.time\/GST_SECOND);\n@@ -265,0 +365,9 @@\n+    decoder->codec_id = JFX_CODEC_ID_UNKNOWN;\n+#if HEVC_SUPPORT\n+    decoder->sws_context = NULL;\n+    decoder->dest_frame = NULL;\n+    decoder->swscale_module = NULL;\n+    decoder->sws_getContext_func = NULL;\n+    decoder->sws_freeContext_func = NULL;\n+    decoder->sws_scale_func = NULL;\n+#endif \/\/ HEVC_SUPPORT\n@@ -272,0 +381,1 @@\n+    const gchar *mimetype = NULL;\n@@ -284,0 +394,7 @@\n+    if (s != NULL)\n+    {\n+        mimetype = gst_structure_get_name(s);\n+        if (mimetype != NULL)\n+        {\n+            if (strstr(mimetype, \"video\/x-h264\") != NULL)\n+            {\n@@ -285,1 +402,9 @@\n-    base->is_initialized = basedecoder_open_decoder(BASEDECODER(decoder), AV_CODEC_ID_H264);\n+                base->is_initialized = basedecoder_open_decoder(BASEDECODER(decoder), AV_CODEC_ID_H264);\n+#else\n+                base->is_initialized = basedecoder_open_decoder(BASEDECODER(decoder), CODEC_ID_H264);\n+#endif\n+            }\n+            else if (strstr(mimetype, \"video\/x-h265\") != NULL)\n+            {\n+#if HEVC_SUPPORT\n+                base->is_initialized = basedecoder_open_decoder(BASEDECODER(decoder), AV_CODEC_ID_HEVC);\n@@ -287,1 +412,1 @@\n-    base->is_initialized = basedecoder_open_decoder(BASEDECODER(decoder), CODEC_ID_H264);\n+                return FALSE;\n@@ -289,0 +414,4 @@\n+            }\n+        }\n+    }\n+\n@@ -298,0 +427,116 @@\n+#if HEVC_SUPPORT\n+static gboolean videodecoder_init_converter(VideoDecoder *decoder)\n+{\n+    BaseDecoder *base = BASEDECODER(decoder);\n+\n+    \/\/ Load libswscale\n+    if (decoder->swscale_module == NULL)\n+    {\n+        decoder->swscale_module = dlopen(\"libswscale.so\", RTLD_LAZY);\n+        if (decoder->swscale_module == NULL)\n+        {\n+            \/\/ Halt playback, since we cannot continue and post user\n+            \/\/ friendly error message that libswscale is required\n+            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                    JFX_GST_ERROR, JFX_GST_MISSING_LIBSWSCALE,\n+                    g_strdup(\"Error: libswscale is required for H.265\/HEVC 10\/12-bit decoding\"), NULL,\n+                    (\"videodecoder.c\"), (\"videodecoder_init_converter\"), 0);\n+            return FALSE;\n+        }\n+\n+        decoder->sws_getContext_func = dlsym(decoder->swscale_module, \"sws_getContext\");\n+        if (!decoder->sws_getContext_func)\n+        {\n+            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                    JFX_GST_ERROR, JFX_GST_INVALID_LIBSWSCALE,\n+                    g_strdup(\"Error: Failed to find \\\"sws_getContext()\\\" in libswscale\"), NULL,\n+                    (\"videodecoder.c\"), (\"videodecoder_init_converter\"), 0);\n+            return FALSE;\n+        }\n+\n+        decoder->sws_freeContext_func = dlsym(decoder->swscale_module, \"sws_freeContext\");\n+        if (!decoder->sws_freeContext_func)\n+        {\n+            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                    JFX_GST_ERROR, JFX_GST_INVALID_LIBSWSCALE,\n+                    g_strdup(\"Error: Failed to find \\\"sws_freeContext()\\\" in libswscale\"), NULL,\n+                    (\"videodecoder.c\"), (\"videodecoder_init_converter\"), 0);\n+            return FALSE;\n+        }\n+\n+        decoder->sws_scale_func = dlsym(decoder->swscale_module, \"sws_scale\");\n+        if (!decoder->sws_scale_func)\n+        {\n+            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                    JFX_GST_ERROR, JFX_GST_INVALID_LIBSWSCALE,\n+                    g_strdup(\"Error: Failed to find \\\"sws_scale()\\\" in libswscale\"), NULL,\n+                    (\"videodecoder.c\"), (\"videodecoder_init_converter\"), 0);\n+            return FALSE;\n+        }\n+    }\n+\n+    if (decoder->dest_frame)\n+    {\n+        av_frame_free(&decoder->dest_frame);\n+        decoder->dest_frame = NULL;\n+    }\n+\n+    if (decoder->sws_context)\n+    {\n+        decoder->sws_freeContext_func(decoder->sws_context);\n+        decoder->sws_context = NULL;\n+    }\n+\n+    decoder->sws_context =\n+            decoder->sws_getContext_func(decoder->width, decoder->height,\n+                                         base->frame->format, decoder->width,\n+                                         decoder->height, AV_PIX_FMT_YUV420P,\n+                                         SWS_BILINEAR, NULL, NULL, NULL);\n+\n+    if (decoder->sws_context == NULL)\n+        return FALSE;\n+\n+    decoder->dest_frame = av_frame_alloc();\n+    if (decoder->dest_frame == NULL)\n+        return FALSE;\n+\n+    decoder->dest_frame->format = AV_PIX_FMT_YUV420P;\n+    decoder->dest_frame->width  = decoder->width;\n+    decoder->dest_frame->height = decoder->height;\n+    int ret = av_frame_get_buffer(decoder->dest_frame, 32);\n+    if (ret < 0)\n+    {\n+        av_frame_free(&decoder->dest_frame);\n+        decoder->dest_frame = NULL;\n+        decoder->sws_freeContext_func(decoder->sws_context);\n+        decoder->sws_context = NULL;\n+        return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+static gboolean videodecoder_convert_frame(VideoDecoder *decoder)\n+{\n+    BaseDecoder *base = BASEDECODER(decoder);\n+\n+    if (decoder->sws_context == NULL || decoder->dest_frame == NULL ||\n+            decoder->sws_scale_func == NULL)\n+        return TRUE;\n+\n+    int ret = decoder->sws_scale_func(decoder->sws_context,\n+                                      base->frame->data,\n+                                      base->frame->linesize,\n+                                      0,\n+                                      base->frame->height,\n+                                      decoder->dest_frame->data,\n+                                      decoder->dest_frame->linesize);\n+    if (ret < 0)\n+        return FALSE;\n+\n+    decoder->dest_frame->reordered_opaque = base->frame->reordered_opaque;\n+\n+    return TRUE;\n+}\n+#endif \/\/ HEVC_SUPPORT\n+\n@@ -301,0 +546,4 @@\n+    gboolean set_linesize = TRUE;\n+    int linesize0 = 0;\n+    int linesize1 = 0;\n+    int linesize2 = 0;\n@@ -318,0 +567,33 @@\n+#if HEVC_SUPPORT\n+    \/\/ Setup scaler and color converter if pixel format is not AV_PIX_FMT_YUV420P.\n+    \/\/ We will get different pixel format for H.265 10-bit such as\n+    \/\/ AV_PIX_FMT_YUV422P10LE. Scaling should not happen if resolution is same.\n+    if (base->frame->format != AV_PIX_FMT_YUV420P)\n+    {\n+        if (!videodecoder_init_converter(decoder))\n+        {\n+            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                                             GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE,\n+                                             g_strdup(\"videodecoder_init_convert() failed\"), NULL,\n+                                             (\"videodecoder.c\"), (\"videodecoder_configure_sourcepad\"), 0);\n+            return FALSE;\n+        }\n+\n+        if (!videodecoder_convert_frame(decoder))\n+        {\n+            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                                             GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE,\n+                                             g_strdup(\"videodecoder_convert_frame() failed\"), NULL,\n+                                             (\"videodecoder.c\"), (\"videodecoder_configure_sourcepad\"), 0);\n+\n+            return FALSE;\n+        }\n+\n+        linesize0 = decoder->dest_frame->linesize[0];\n+        linesize1 = decoder->dest_frame->linesize[1];\n+        linesize2 = decoder->dest_frame->linesize[2];\n+\n+        set_linesize = FALSE;\n+    }\n+#endif \/\/ HEVC_SUPPORT\n+\n@@ -320,2 +602,9 @@\n-        decoder->u_offset = base->frame->linesize[0] * decoder->height;\n-        decoder->uv_blocksize = base->frame->linesize[1] * decoder->height \/ 2;\n+        if (set_linesize)\n+        {\n+            linesize0 = base->frame->linesize[0];\n+            linesize1 = base->frame->linesize[1];\n+            linesize2 = base->frame->linesize[2];\n+        }\n+\n+        decoder->u_offset = linesize0 * decoder->height;\n+        decoder->uv_blocksize = linesize1 * decoder->height \/ 2;\n@@ -324,1 +613,1 @@\n-        decoder->frame_size = (base->frame->linesize[0] + base->frame->linesize[1]) * decoder->height;\n+        decoder->frame_size = (linesize0 + linesize1) * decoder->height;\n@@ -330,3 +619,3 @@\n-                                                \"stride-y\", G_TYPE_INT, base->frame->linesize[0],\n-                                                \"stride-u\", G_TYPE_INT, base->frame->linesize[1],\n-                                                \"stride-v\", G_TYPE_INT, base->frame->linesize[2],\n+                                                \"stride-y\", G_TYPE_INT, linesize0,\n+                                                \"stride-u\", G_TYPE_INT, linesize1,\n+                                                \"stride-v\", G_TYPE_INT, linesize2,\n@@ -372,0 +661,5 @@\n+    gboolean       set_frame_values = TRUE;\n+    int64_t        reordered_opaque = AV_NOPTS_VALUE;\n+    uint8_t*       data0 = NULL;\n+    uint8_t*       data1 = NULL;\n+    uint8_t*       data2 = NULL;\n@@ -439,0 +733,30 @@\n+#if HEVC_SUPPORT\n+            if (!videodecoder_convert_frame(decoder))\n+            {\n+                gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                                         GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE,\n+                                         g_strdup(\"Video frame conversion failed\"), NULL,\n+                                         (\"videodecoder.c\"), (\"videodecoder_chain\"), 0);\n+\n+                result = GST_FLOW_ERROR;\n+                goto _exit;\n+            }\n+\n+            if (decoder->dest_frame)\n+            {\n+                reordered_opaque = decoder->dest_frame->reordered_opaque;\n+                data0 = decoder->dest_frame->data[0];\n+                data1 = decoder->dest_frame->data[1];\n+                data2 = decoder->dest_frame->data[2];\n+                set_frame_values = FALSE;\n+            }\n+#endif \/\/ HEVC_SUPPORTf\n+\n+            if (set_frame_values)\n+            {\n+                reordered_opaque = base->frame->reordered_opaque;\n+                data0 = base->frame->data[0];\n+                data1 = base->frame->data[1];\n+                data2 = base->frame->data[2];\n+            }\n+\n@@ -446,1 +770,1 @@\n-                                             (\"Decoded video buffer allocation failed\"), NULL,\n+                                             g_strdup(\"Decoded video buffer allocation failed\"), NULL,\n@@ -453,1 +777,1 @@\n-                if (base->frame->reordered_opaque != AV_NOPTS_VALUE)\n+                if (reordered_opaque != AV_NOPTS_VALUE)\n@@ -455,1 +779,1 @@\n-                    GST_BUFFER_TIMESTAMP(outbuf) = base->frame->reordered_opaque;\n+                    GST_BUFFER_TIMESTAMP(outbuf) = reordered_opaque;\n@@ -469,3 +793,3 @@\n-                memcpy(info2.data,                     base->frame->data[0], decoder->u_offset);\n-                memcpy(info2.data + decoder->u_offset, base->frame->data[1], decoder->uv_blocksize);\n-                memcpy(info2.data + decoder->v_offset, base->frame->data[2], decoder->uv_blocksize);\n+                memcpy(info2.data,                     data0, decoder->u_offset);\n+                memcpy(info2.data + decoder->u_offset, data1, decoder->uv_blocksize);\n+                memcpy(info2.data + decoder->v_offset, data2, decoder->uv_blocksize);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/videodecoder.c","additions":349,"deletions":25,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+#include <dlfcn.h>\n+#include <libswscale\/swscale.h>\n+\n@@ -46,0 +49,15 @@\n+#if HEVC_SUPPORT\n+\/\/ libswscale APIs\n+typedef struct SwsContext *(*sws_getContext_ptr)(int srcW, int srcH,\n+                                                 enum AVPixelFormat srcFormat,\n+                                                 int dstW, int dstH,\n+                                                 enum AVPixelFormat dstFormat,\n+                                                 int flags, SwsFilter *srcFilter,\n+                                                 SwsFilter *dstFilter,\n+                                                 const double *param);\n+typedef void (*sws_freeContext_ptr)(struct SwsContext *swsContext);\n+typedef int (*sws_scale_ptr)(struct SwsContext *c, const uint8_t *const srcSlice[],\n+                      const int srcStride[], int srcSliceY, int srcSliceH,\n+                      uint8_t *const dst[], const int dstStride[]);\n+#endif \/\/ HEVC_SUPPORT\n+\n@@ -62,1 +80,14 @@\n-    AVPacket       packet;\n+    AVPacket    packet;\n+\n+    gint        codec_id;\n+\n+#if HEVC_SUPPORT\n+    struct SwsContext *sws_context;\n+    AVFrame           *dest_frame;\n+\n+    \/\/ Load and use libswscale dynamically\n+    void                *swscale_module;\n+    sws_getContext_ptr  sws_getContext_func;\n+    sws_freeContext_ptr sws_freeContext_func;\n+    sws_scale_ptr       sws_scale_func;\n+#endif \/\/ HEVC_SUPPORT\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/videodecoder.h","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,3 @@\n-                         GST_STATIC_CAPS (\"video\/x-h264\")\n+                         GST_STATIC_CAPS (\n+                         \"video\/x-h264; \"\n+                         \"video\/x-h265\") \/\/ Fake caps, so we can connect and post error\n@@ -539,0 +541,23 @@\n+    GstStructure *s = NULL;\n+    const gchar *mimetype = NULL;\n+\n+    \/\/ Post error to halt playback if we asked to decode HEVC, so we can\n+    \/\/ fallback to OSXPlatform. With soft error we will play audio only for MP4\n+    \/\/ with HEVC and AAC.\n+    s = gst_caps_get_structure(videoSpecificCaps, 0);\n+    if (s != NULL)\n+    {\n+        mimetype = gst_structure_get_name(s);\n+        if (mimetype != NULL)\n+        {\n+            if (strstr(mimetype, \"video\/x-h265\") != NULL)\n+            {\n+                gst_element_message_full(GST_ELEMENT(decode), GST_MESSAGE_ERROR,\n+                        GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE,\n+                        g_strdup(\"GSTPlatform does not support HEVC on macOS, use OSXPlatform instead.\"),\n+                        NULL, (\"avcdecoder.c\"), (\"avcdecoder_init_decoder\"), 0);\n+\n+                return GST_FLOW_ERROR;\n+            }\n+        }\n+    }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/avcdecoder\/avcdecoder.c","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+#include \"fxplugins_common.h\"\n+\n@@ -57,8 +59,0 @@\n-enum CODEC_ID\n-{\n-    CODEC_ID_UNKNOWN = 0,\n-    CODEC_ID_AAC,\n-    CODEC_ID_H264, \/\/ HLS\n-    CODEC_ID_AVC1, \/\/ MP4\n-};\n-\n@@ -340,1 +334,1 @@\n-    decoder->codec_id = CODEC_ID_UNKNOWN;\n+    decoder->codec_id = JFX_CODEC_ID_UNKNOWN;\n@@ -1297,1 +1291,1 @@\n-    case CODEC_ID_AAC:\n+    case JFX_CODEC_ID_AAC:\n@@ -1316,1 +1310,1 @@\n-    case CODEC_ID_AVC1:\n+    case JFX_CODEC_ID_AVC1:\n@@ -1335,1 +1329,1 @@\n-    case CODEC_ID_H264:\n+    case JFX_CODEC_ID_H264:\n@@ -1840,1 +1834,1 @@\n-static void dshowwrapper_load_decoder_h264(GstDShowWrapper *decoder, CODEC_ID codecID)\n+static void dshowwrapper_load_decoder_h264(GstDShowWrapper *decoder, JFX_CODEC_ID codecID)\n@@ -1845,1 +1839,1 @@\n-    if (codecID == CODEC_ID_H264)\n+    if (codecID == JFX_CODEC_ID_H264)\n@@ -1858,1 +1852,1 @@\n-    else if (codecID == CODEC_ID_AVC1)\n+    else if (codecID == JFX_CODEC_ID_AVC1)\n@@ -1960,1 +1954,1 @@\n-        dshowwrapper_load_decoder_h264(decoder, CODEC_ID_AVC1);\n+        dshowwrapper_load_decoder_h264(decoder, JFX_CODEC_ID_AVC1);\n@@ -2043,1 +2037,1 @@\n-        dshowwrapper_load_decoder_h264(decoder, CODEC_ID_H264);\n+        dshowwrapper_load_decoder_h264(decoder, JFX_CODEC_ID_H264);\n@@ -2461,1 +2455,1 @@\n-    if (!dshowwrapper_is_decoder_by_codec_id_supported(CODEC_ID_H264))\n+    if (!dshowwrapper_is_decoder_by_codec_id_supported(JFX_CODEC_ID_H264))\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/dshowwrapper\/dshowwrapper.cpp","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,2 @@\n-gboolean dshowwrapper_init(GstPlugin* aacdecoder);\n+gboolean dshowwrapper_init(GstPlugin* dshowwrapper);\n+gboolean mfwrapper_init(GstPlugin* mfwrapper);\n@@ -53,0 +54,1 @@\n+           mfwrapper_init(plugin) &&\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/fxplugins.c","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,21 @@\n+\/\/ Do not use CODEC_ID_*, since it will conflict with libavcodec\n+enum JFX_CODEC_ID\n+{\n+    JFX_CODEC_ID_UNKNOWN = 0,\n+    JFX_CODEC_ID_AAC,\n+    JFX_CODEC_ID_H264, \/\/ HLS\n+    JFX_CODEC_ID_AVC1, \/\/ MP4\n+    JFX_CODEC_ID_H265, \/\/ MP4\n+};\n+\n+\/\/ Custom error codes used by our plugins\n+\n+\/\/ GStreamer enums with error codes does not contains more then 25 error codes,\n+\/\/ so we will start with 0xFF, so we do not conflict with GStreamer\n+enum JFX_GST_ERROR_CODES\n+{\n+    JFX_GST_ERROR = 0xFF,\n+    JFX_GST_MISSING_LIBSWSCALE,\n+    JFX_GST_INVALID_LIBSWSCALE,\n+};\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/fxplugins_common.h","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,1303 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HAVE_CONFIG_H\n+#  include <config.h>\n+#endif\n+\n+#include <gst\/gst.h>\n+\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <mfwrapper.h>\n+#include <mfidl.h>\n+#include <Wmcodecdsp.h>\n+\n+#include \"fxplugins_common.h\"\n+\n+#define PTS_DEBUG 0\n+\n+enum\n+{\n+    PROP_0,\n+    PROP_CODEC_ID,\n+    PROP_IS_SUPPORTED,\n+};\n+\n+enum\n+{\n+    PO_DELIVERED,\n+    PO_NEED_MORE_DATA,\n+    PO_FLUSHING,\n+    PO_FAILED,\n+};\n+\n+GST_DEBUG_CATEGORY_STATIC(gst_mfwrapper_debug);\n+#define GST_CAT_DEFAULT gst_mfwrapper_debug\n+\n+\/\/ The input capabilities\n+static GstStaticPadTemplate sink_factory =\n+GST_STATIC_PAD_TEMPLATE(\"sink\",\n+    GST_PAD_SINK,\n+    GST_PAD_ALWAYS,\n+    GST_STATIC_CAPS(\n+        \/\/ H.265\n+        \"video\/x-h265\"\n+    ));\n+\n+\/\/ The output capabilities\n+static GstStaticPadTemplate src_factory =\n+GST_STATIC_PAD_TEMPLATE(\"src\",\n+    GST_PAD_SRC,\n+    GST_PAD_ALWAYS,\n+    GST_STATIC_CAPS(\n+        \/\/ YV12\n+        \"video\/x-raw-yuv, \"\n+        \"format=(string)YV12\"\n+    ));\n+\n+\/\/ Forward declarations\n+static void gst_mfwrapper_dispose(GObject* object);\n+static void gst_mfwrapper_set_property(GObject *object, guint property_id, const GValue *value, GParamSpec *pspec);\n+static void gst_mfwrapper_get_property(GObject *object, guint property_id, GValue *value, GParamSpec *pspec);\n+\n+static GstFlowReturn mfwrapper_chain(GstPad* pad, GstObject *parent, GstBuffer* buf);\n+\n+static gboolean mfwrapper_sink_event(GstPad* pad, GstObject *parent, GstEvent* event);\n+static gboolean mfwrapper_sink_set_caps(GstPad * pad, GstObject *parent, GstCaps * caps);\n+static gboolean mfwrapper_activate(GstPad* pad, GstObject *parent);\n+static gboolean mfwrapper_activatemode(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean active);\n+\n+static HRESULT mfwrapper_load_decoder(GstMFWrapper *decoder, GstCaps *caps);\n+\n+static gboolean mfwrapper_is_decoder_by_codec_id_supported(GstMFWrapper *decoder, gint codec_id);\n+\n+template <class T> void SafeRelease(T **ppT)\n+{\n+    if (*ppT)\n+    {\n+        (*ppT)->Release();\n+        *ppT = NULL;\n+    }\n+}\n+\n+\/***********************************************************************************\n+* Substitution for\n+* G_DEFINE_TYPE (GstMFWrapper, gst_mfwrapper, GstElement, GST_TYPE_ELEMENT);\n+***********************************************************************************\/\n+#define gst_mfwrapper_parent_class parent_class\n+static void gst_mfwrapper_init(GstMFWrapper      *self);\n+static void gst_mfwrapper_class_init(GstMFWrapperClass *klass);\n+static gpointer gst_mfwrapper_parent_class = NULL;\n+static void     gst_mfwrapper_class_intern_init(gpointer klass)\n+{\n+    gst_mfwrapper_parent_class = g_type_class_peek_parent(klass);\n+    gst_mfwrapper_class_init((GstMFWrapperClass*)klass);\n+}\n+\n+GType gst_mfwrapper_get_type(void)\n+{\n+    static volatile gsize gonce_data = 0;\n+    \/\/ INLINE - g_once_init_enter()\n+    if (g_once_init_enter(&gonce_data))\n+    {\n+        GType _type;\n+        _type = g_type_register_static_simple(GST_TYPE_ELEMENT,\n+            g_intern_static_string(\"GstMFWrapper\"),\n+            sizeof(GstMFWrapperClass),\n+            (GClassInitFunc)gst_mfwrapper_class_intern_init,\n+            sizeof(GstMFWrapper),\n+            (GInstanceInitFunc)gst_mfwrapper_init,\n+            (GTypeFlags)0);\n+        g_once_init_leave(&gonce_data, (gsize)_type);\n+    }\n+    return (GType)gonce_data;\n+}\n+\n+\/\/ Initialize mfwrapper's class.\n+static void gst_mfwrapper_class_init(GstMFWrapperClass *klass)\n+{\n+    GstElementClass *element_class = (GstElementClass*)klass;\n+    GObjectClass *gobject_class = (GObjectClass*)klass;\n+\n+    gst_element_class_set_metadata(element_class,\n+        \"MFWrapper\",\n+        \"Codec\/Decoder\/Audio\/Video\",\n+        \"Media Foundation Wrapper\",\n+        \"Oracle Corporation\");\n+\n+    gst_element_class_add_pad_template(element_class,\n+        gst_static_pad_template_get(&src_factory));\n+    gst_element_class_add_pad_template(element_class,\n+        gst_static_pad_template_get(&sink_factory));\n+\n+    gobject_class->dispose = gst_mfwrapper_dispose;\n+    gobject_class->set_property = gst_mfwrapper_set_property;\n+    gobject_class->get_property = gst_mfwrapper_get_property;\n+\n+    g_object_class_install_property(gobject_class, PROP_CODEC_ID,\n+        g_param_spec_int(\"codec-id\", \"Codec ID\", \"Codec ID\", -1, G_MAXINT, 0,\n+        (GParamFlags)(G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS)));\n+\n+    g_object_class_install_property(gobject_class, PROP_IS_SUPPORTED,\n+        g_param_spec_boolean(\"is-supported\", \"Is supported\", \"Is codec ID supported\", FALSE,\n+        (GParamFlags)(G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS)));\n+}\n+\n+\/\/ Initialize the new element\n+\/\/ Instantiate pads and add them to element\n+\/\/ Set pad calback functions\n+\/\/ Initialize instance structure\n+static void gst_mfwrapper_init(GstMFWrapper *decoder)\n+{\n+    \/\/ Input\n+    decoder->sinkpad = gst_pad_new_from_static_template(&sink_factory, \"sink\");\n+    gst_element_add_pad(GST_ELEMENT(decoder), decoder->sinkpad);\n+    gst_pad_set_chain_function(decoder->sinkpad, mfwrapper_chain);\n+    gst_pad_set_event_function(decoder->sinkpad, mfwrapper_sink_event);\n+    gst_pad_set_activate_function(decoder->sinkpad, mfwrapper_activate);\n+    gst_pad_set_activatemode_function(decoder->sinkpad, mfwrapper_activatemode);\n+\n+    \/\/ Output\n+    decoder->srcpad = gst_pad_new_from_static_template(&src_factory, \"src\");\n+    gst_element_add_pad(GST_ELEMENT(decoder), decoder->srcpad);\n+\n+    decoder->is_flushing = FALSE;\n+    decoder->is_eos_received = FALSE;\n+    decoder->is_eos = FALSE;\n+    decoder->force_discontinuity = FALSE;\n+\n+    \/\/ Initialize Media Foundation\n+    bool bCallCoUninitialize = true;\n+\n+    if (FAILED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)))\n+        bCallCoUninitialize = false;\n+\n+    decoder->hr_mfstartup = MFStartup(MF_VERSION, MFSTARTUP_LITE);\n+\n+    if (bCallCoUninitialize)\n+        CoUninitialize();\n+\n+    decoder->pDecoder = NULL;\n+    decoder->pDecoderOutput = NULL;\n+\n+    decoder->pColorConvert = NULL;\n+    decoder->pColorConvertOutput = NULL;\n+\n+    decoder->header = NULL;\n+    decoder->header_size = 0;\n+\n+    decoder->width = 1920;\n+    decoder->height = 1080;\n+    decoder->framerate_num = 2997;\n+    decoder->framerate_den = 100;\n+}\n+\n+static void gst_mfwrapper_dispose(GObject* object)\n+{\n+    GstMFWrapper *decoder = GST_MFWRAPPER(object);\n+\n+    SafeRelease(&decoder->pDecoderOutput);\n+    SafeRelease(&decoder->pDecoder);\n+\n+    SafeRelease(&decoder->pColorConvertOutput);\n+    SafeRelease(&decoder->pColorConvert);\n+\n+    if (decoder->hr_mfstartup == S_OK)\n+        MFShutdown();\n+\n+    G_OBJECT_CLASS(parent_class)->dispose(object);\n+}\n+\n+static void gst_mfwrapper_set_property(GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)\n+{\n+    GstMFWrapper *decoder = GST_MFWRAPPER(object);\n+    switch (property_id)\n+    {\n+    case PROP_CODEC_ID:\n+        decoder->codec_id = g_value_get_int(value);\n+        break;\n+    default:\n+        break;\n+    }\n+}\n+\n+static void gst_mfwrapper_get_property(GObject *object, guint property_id, GValue *value, GParamSpec *pspec)\n+{\n+    GstMFWrapper *decoder = GST_MFWRAPPER(object);\n+    gboolean is_supported = FALSE;\n+    switch (property_id)\n+    {\n+    case PROP_IS_SUPPORTED:\n+        is_supported = mfwrapper_is_decoder_by_codec_id_supported(decoder, decoder->codec_id);\n+        g_value_set_boolean(value, is_supported);\n+        break;\n+    default:\n+        break;\n+    }\n+}\n+\n+static gboolean mfwrapper_is_decoder_by_codec_id_supported(GstMFWrapper *decoder, gint codec_id)\n+{\n+    HRESULT hr = S_FALSE;\n+\n+    switch (codec_id)\n+    {\n+    case JFX_CODEC_ID_H265:\n+        \/\/ Dummy caps to load H.265 decoder\n+        GstCaps *caps = gst_caps_new_simple(\"video\/x-h265\",\n+            \"width\", G_TYPE_INT, 1920,\n+            \"height\", G_TYPE_INT, 1080,\n+            NULL);\n+        hr = mfwrapper_load_decoder(decoder, caps);\n+        gst_caps_unref(caps);\n+        break;\n+    }\n+\n+    if (hr == S_OK)\n+        return TRUE;\n+    else\n+        return FALSE;\n+}\n+\n+static void mfwrapper_set_src_caps(GstMFWrapper *decoder)\n+{\n+    GstCaps *srcCaps = NULL;\n+    HRESULT hr = S_OK;\n+    MFT_OUTPUT_STREAM_INFO outputStreamInfo;\n+\n+    GstCaps *padCaps = gst_pad_get_current_caps(decoder->srcpad);\n+    if (padCaps == NULL)\n+    {\n+        srcCaps = gst_caps_new_simple(\"video\/x-raw-yuv\",\n+            \"format\", G_TYPE_STRING, \"YV12\",\n+            \"framerate\", GST_TYPE_FRACTION, decoder->framerate_num, decoder->framerate_den,\n+            \"width\", G_TYPE_INT, decoder->width,\n+            \"height\", G_TYPE_INT, decoder->height,\n+            \"offset-y\", G_TYPE_INT, 0,\n+            \"offset-v\", G_TYPE_INT, (decoder->width * decoder->height + ((decoder->width * decoder->height) \/ 4)),\n+            \"offset-u\", G_TYPE_INT, decoder->width * decoder->height,\n+            \"stride-y\", G_TYPE_INT, decoder->width,\n+            \"stride-v\", G_TYPE_INT, decoder->width \/ 2,\n+            \"stride-u\", G_TYPE_INT, decoder->width \/ 2,\n+            NULL);\n+    }\n+    else\n+    {\n+        srcCaps = gst_caps_copy(padCaps);\n+        gst_caps_unref(padCaps);\n+        if (srcCaps == NULL)\n+            return;\n+\n+        gst_caps_set_simple(srcCaps,\n+            \"width\", G_TYPE_INT, decoder->width,\n+            \"height\", G_TYPE_INT, decoder->height,\n+            \"offset-y\", G_TYPE_INT, 0,\n+            \"offset-v\", G_TYPE_INT, (decoder->width * decoder->height + ((decoder->width * decoder->height) \/ 4)),\n+            \"offset-u\", G_TYPE_INT, decoder->width * decoder->height,\n+            \"stride-y\", G_TYPE_INT, decoder->width,\n+            \"stride-v\", G_TYPE_INT, decoder->width \/ 2,\n+            \"stride-u\", G_TYPE_INT, decoder->width \/ 2,\n+            NULL);\n+    }\n+\n+    GstEvent *caps_event = gst_event_new_caps(srcCaps);\n+    if (caps_event)\n+        gst_pad_push_event(decoder->srcpad, caps_event);\n+    gst_caps_unref(srcCaps);\n+\n+    \/\/ Allocate or update decoder output buffer\n+    SafeRelease(&decoder->pDecoderOutput);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->GetOutputStreamInfo(0, &outputStreamInfo);\n+\n+    if (SUCCEEDED(hr))\n+    {\n+        if (!((outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) || (outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)))\n+        {\n+            hr = MFCreateSample(&decoder->pDecoderOutput);\n+            if (SUCCEEDED(hr))\n+            {\n+                IMFMediaBuffer *pBuffer = NULL;\n+                hr = MFCreateMemoryBuffer(outputStreamInfo.cbSize, &pBuffer);\n+                if (SUCCEEDED(hr))\n+                    hr = decoder->pDecoderOutput->AddBuffer(pBuffer);\n+                SafeRelease(&pBuffer);\n+            }\n+        }\n+    }\n+}\n+\n+static void mfwrapper_nalu_to_start_code(BYTE *pbBuffer, guint size)\n+{\n+    gint leftSize = size;\n+\n+    if (pbBuffer == NULL || size < 4)\n+        return;\n+\n+    do\n+    {\n+        guint naluLen = ((guint)*(guint8*)pbBuffer) << 24;\n+        naluLen |= ((guint)*(guint8*)(pbBuffer + 1)) << 16;\n+        naluLen |= ((guint)*(guint8*)(pbBuffer + 2)) << 8;\n+        naluLen |= ((guint)*(guint8*)(pbBuffer + 3));\n+\n+        if (naluLen <= 1) \/\/ Start code or something wrong\n+            return;\n+\n+        pbBuffer[0] = 0x00;\n+        pbBuffer[1] = 0x00;\n+        pbBuffer[2] = 0x00;\n+        pbBuffer[3] = 0x01;\n+\n+        leftSize -= (naluLen + 4);\n+        pbBuffer += (naluLen + 4);\n+\n+    } while (leftSize > 0);\n+}\n+\n+static gboolean mfwrapper_process_input(GstMFWrapper *decoder, GstBuffer *buf)\n+{\n+    IMFSample *pSample = NULL;\n+    IMFMediaBuffer *pBuffer = NULL;\n+    BYTE *pbBuffer = NULL;\n+    GstMapInfo info;\n+    gsize size = 0;\n+    gboolean unmap_buf = FALSE;\n+    gboolean unlock_buf = FALSE;\n+\n+    if (!decoder->pDecoder)\n+        return FALSE;\n+\n+    HRESULT hr = MFCreateSample(&pSample);\n+\n+    if (SUCCEEDED(hr) && decoder->force_discontinuity)\n+    {\n+        hr = pSample->SetUINT32(MFSampleExtension_Discontinuity, TRUE);\n+        decoder->force_discontinuity = FALSE;\n+    }\n+\n+    if (SUCCEEDED(hr) && GST_BUFFER_PTS_IS_VALID(buf))\n+        hr = pSample->SetSampleTime(GST_BUFFER_PTS(buf) \/ 100);\n+\n+    if (SUCCEEDED(hr) && GST_BUFFER_DURATION_IS_VALID(buf))\n+        hr = pSample->SetSampleDuration(GST_BUFFER_DURATION(buf) \/ 100);\n+\n+    if (SUCCEEDED(hr) && gst_buffer_map(buf, &info, GST_MAP_READ))\n+        unmap_buf = TRUE;\n+    else\n+        hr = E_FAIL;\n+\n+    if (SUCCEEDED(hr) && decoder->header != NULL && decoder->header_size > 0)\n+        hr = MFCreateMemoryBuffer(decoder->header_size + info.size, &pBuffer);\n+    else if (SUCCEEDED(hr))\n+        hr = MFCreateMemoryBuffer(info.size, &pBuffer);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pBuffer->Lock(&pbBuffer, NULL, NULL);\n+\n+    if (SUCCEEDED(hr))\n+        unlock_buf = TRUE;\n+\n+    if (SUCCEEDED(hr) && decoder->header != NULL && decoder->header_size > 0)\n+    {\n+        memcpy_s(pbBuffer, decoder->header_size + info.size, decoder->header, decoder->header_size);\n+        pbBuffer += decoder->header_size;\n+        memcpy_s(pbBuffer, info.size, info.data, info.size);\n+        mfwrapper_nalu_to_start_code(pbBuffer, info.size);\n+\n+        delete[] decoder->header;\n+        decoder->header = NULL;\n+\n+        hr = pBuffer->SetCurrentLength(decoder->header_size + info.size);\n+        decoder->header_size = 0;\n+    }\n+    else if (SUCCEEDED(hr))\n+    {\n+        memcpy_s(pbBuffer, info.size, info.data, info.size);\n+        mfwrapper_nalu_to_start_code(pbBuffer, info.size);\n+        hr = pBuffer->SetCurrentLength(info.size);\n+    }\n+\n+    if (unlock_buf)\n+        hr = pBuffer->Unlock();\n+\n+    if (unmap_buf)\n+        gst_buffer_unmap(buf, &info);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pSample->AddBuffer(pBuffer);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->ProcessInput(0, pSample, 0);\n+\n+    gst_buffer_unref(buf);\n+\n+    SafeRelease(&pBuffer);\n+    SafeRelease(&pSample);\n+\n+    if (SUCCEEDED(hr))\n+        return TRUE;\n+    else\n+        return FALSE;\n+}\n+\n+static HRESULT mfwrapper_init_colorconvert(GstMFWrapper *decoder)\n+{\n+    DWORD dwStatus = 0;\n+\n+    IMFMediaType *pDecoderOutputType = NULL;\n+    IMFMediaType *pInputType = NULL;\n+    IMFMediaType *pConverterOutputType = NULL;\n+    IMFMediaType *pOutputType = NULL;\n+    GUID subType;\n+    UINT32 unDefaultStride = 0;\n+    UINT32 unNumerator = 0;\n+    UINT32 unDenominator = 0;\n+    MFT_OUTPUT_STREAM_INFO outputStreamInfo;\n+\n+    HRESULT hr = CoCreateInstance(CLSID_VideoProcessorMFT, NULL, CLSCTX_ALL, IID_PPV_ARGS(&decoder->pColorConvert));\n+\n+    \/\/ Set input type\n+    DWORD dwTypeIndex = 0;\n+    do\n+    {\n+        hr = decoder->pDecoder->GetOutputAvailableType(0, dwTypeIndex, &pDecoderOutputType);\n+        dwTypeIndex++;\n+\n+        if (SUCCEEDED(hr))\n+            hr = pDecoderOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+\n+        if (SUCCEEDED(hr) && !IsEqualGUID(subType, MFVideoFormat_NV12))\n+        {\n+            SafeRelease(&pDecoderOutputType);\n+            hr = E_FAIL;\n+            continue;\n+        }\n+\n+        if (SUCCEEDED(hr))\n+            hr = MFCreateMediaType(&pInputType);\n+\n+        if (SUCCEEDED(hr))\n+            hr = pInputType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);\n+\n+        if (SUCCEEDED(hr))\n+            hr = pInputType->SetGUID(MF_MT_SUBTYPE, subType);\n+\n+        if (SUCCEEDED(hr))\n+            hr = MFSetAttributeSize(pInputType, MF_MT_FRAME_SIZE, decoder->width, decoder->height);\n+\n+        if (SUCCEEDED(hr))\n+            hr = MFSetAttributeRatio(pInputType, MF_MT_FRAME_RATE, decoder->framerate_num, decoder->framerate_den);\n+\n+        if (SUCCEEDED(hr))\n+        {\n+            hr = pDecoderOutputType->GetUINT32(MF_MT_DEFAULT_STRIDE, &unDefaultStride);\n+            if (SUCCEEDED(hr))\n+                hr = pInputType->SetUINT32(MF_MT_DEFAULT_STRIDE, unDefaultStride);\n+        }\n+\n+        if (SUCCEEDED(hr))\n+        {\n+            hr = MFGetAttributeRatio(pDecoderOutputType, MF_MT_PIXEL_ASPECT_RATIO, &unNumerator, &unDenominator);\n+            if (SUCCEEDED(hr))\n+                hr = MFSetAttributeRatio(pInputType, MF_MT_PIXEL_ASPECT_RATIO, unNumerator, unDenominator);\n+        }\n+\n+        if (SUCCEEDED(hr))\n+            hr = decoder->pColorConvert->SetInputType(0, pInputType, 0);\n+\n+        SafeRelease(&pInputType);\n+\n+        if (SUCCEEDED(hr))\n+            hr = decoder->pDecoder->SetOutputType(0, pDecoderOutputType, 0);\n+\n+        SafeRelease(&pDecoderOutputType);\n+\n+    } while (hr != MF_E_NO_MORE_TYPES && FAILED(hr));\n+\n+    \/\/ Set output type\n+    dwTypeIndex = 0;\n+    do\n+    {\n+        hr = decoder->pColorConvert->GetOutputAvailableType(0, dwTypeIndex, &pConverterOutputType);\n+        dwTypeIndex++;\n+\n+        if (SUCCEEDED(hr))\n+            hr = pConverterOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+\n+        if (SUCCEEDED(hr) && !(IsEqualGUID(subType, MFVideoFormat_IYUV) || IsEqualGUID(subType, MFVideoFormat_I420)))\n+        {\n+            SafeRelease(&pConverterOutputType);\n+            hr = E_FAIL;\n+            continue;\n+        }\n+\n+        SafeRelease(&pConverterOutputType);\n+\n+        if (SUCCEEDED(hr))\n+            hr = MFCreateMediaType(&pOutputType);\n+\n+        if (SUCCEEDED(hr))\n+            hr = pOutputType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);\n+\n+        if (SUCCEEDED(hr))\n+            hr = pOutputType->SetGUID(MF_MT_SUBTYPE, subType);\n+\n+        if (SUCCEEDED(hr))\n+            hr = MFSetAttributeSize(pOutputType, MF_MT_FRAME_SIZE, decoder->width, decoder->height);\n+\n+        if (SUCCEEDED(hr))\n+            hr = MFSetAttributeRatio(pOutputType, MF_MT_FRAME_RATE, decoder->framerate_num, decoder->framerate_den);\n+\n+        if (SUCCEEDED(hr))\n+            hr = decoder->pColorConvert->SetOutputType(0, pOutputType, 0);\n+\n+        SafeRelease(&pOutputType);\n+\n+    } while (hr != MF_E_NO_MORE_TYPES && FAILED(hr));\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pColorConvert->GetOutputStreamInfo(0, &outputStreamInfo);\n+\n+    if (SUCCEEDED(hr))\n+    {\n+        if (!((outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) || (outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)))\n+        {\n+            hr = MFCreateSample(&decoder->pColorConvertOutput);\n+            if (SUCCEEDED(hr))\n+            {\n+                IMFMediaBuffer *pBuffer = NULL;\n+                hr = MFCreateMemoryBuffer(outputStreamInfo.cbSize, &pBuffer);\n+                if (SUCCEEDED(hr))\n+                    hr = decoder->pColorConvertOutput->AddBuffer(pBuffer);\n+                SafeRelease(&pBuffer);\n+            }\n+        }\n+    }\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pColorConvert->GetInputStatus(0, &dwStatus);\n+\n+    if (FAILED(hr) || dwStatus != MFT_INPUT_STATUS_ACCEPT_DATA) {\n+        return hr;\n+    }\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL);\n+\n+    return hr;\n+}\n+\n+static gboolean mfwrapper_convert_output(GstMFWrapper *decoder)\n+{\n+    DWORD dwFlags = 0;\n+    DWORD dwStatus = 0;\n+    MFT_OUTPUT_DATA_BUFFER outputDataBuffer;\n+    outputDataBuffer.dwStreamID = 0;\n+    outputDataBuffer.pSample = decoder->pColorConvertOutput;\n+    outputDataBuffer.dwStatus = 0;\n+    outputDataBuffer.pEvents = NULL;\n+    IMFMediaType *pOutputType = NULL;\n+\n+    if (decoder->pColorConvert == NULL || decoder->pColorConvertOutput == NULL)\n+        return FALSE;\n+\n+    \/\/ Extra call to unblock color converter, since it expects ProcessOutput to be called\n+    \/\/ until it returns MF_E_TRANSFORM_NEED_MORE_INPUT\n+    HRESULT hr = decoder->pColorConvert->ProcessOutput(0, 1, &outputDataBuffer, &dwStatus);\n+\n+    hr = decoder->pColorConvert->ProcessInput(0, decoder->pDecoderOutput, 0);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pColorConvert->GetOutputStatus(&dwFlags);\n+\n+    if (SUCCEEDED(hr) && dwFlags != MFT_OUTPUT_STATUS_SAMPLE_READY)\n+        return FALSE;\n+\n+    hr = decoder->pColorConvert->ProcessOutput(0, 1, &outputDataBuffer, &dwStatus);\n+    SafeRelease(&outputDataBuffer.pEvents);\n+    if (hr == MF_E_TRANSFORM_STREAM_CHANGE)\n+    {\n+        if (outputDataBuffer.dwStatus == MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE)\n+        {\n+            hr = decoder->pColorConvert->GetOutputAvailableType(0, 0, &pOutputType);\n+\n+            if (SUCCEEDED(hr))\n+                hr = pOutputType->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_IYUV);\n+\n+            if (SUCCEEDED(hr))\n+                hr = decoder->pColorConvert->SetOutputType(0, pOutputType, 0);\n+\n+            SafeRelease(&pOutputType);\n+        }\n+    }\n+    else if (SUCCEEDED(hr))\n+    {\n+        if (outputDataBuffer.dwStatus == 0)\n+        {\n+            return TRUE;\n+        }\n+    }\n+\n+    return FALSE;\n+}\n+\n+static GstFlowReturn mfwrapper_deliver_sample(GstMFWrapper *decoder, IMFSample *pSample)\n+{\n+    GstFlowReturn ret = GST_FLOW_OK;\n+    LONGLONG llTimestamp = 0;\n+    LONGLONG llDuration = 0;\n+    IMFMediaBuffer *pMediaBuffer = NULL;\n+    BYTE *pBuffer = NULL;\n+    DWORD cbMaxLength = 0;\n+    DWORD cbCurrentLength = 0;\n+    GstMapInfo info;\n+\n+    HRESULT hr = pSample->ConvertToContiguousBuffer(&pMediaBuffer);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pMediaBuffer->Lock(&pBuffer, &cbMaxLength, &cbCurrentLength);\n+\n+    if (SUCCEEDED(hr) && cbCurrentLength > 0)\n+    {\n+        GstBuffer *pGstBuffer = gst_buffer_new_allocate(NULL, cbCurrentLength, NULL);\n+        if (pGstBuffer == NULL || !gst_buffer_map(pGstBuffer, &info, GST_MAP_WRITE))\n+        {\n+            pMediaBuffer->Unlock();\n+            gst_buffer_unref(pGstBuffer); \/\/ INLINE - gst_buffer_unref()\n+            return GST_FLOW_ERROR;\n+        }\n+\n+        memcpy(info.data, pBuffer, cbCurrentLength);\n+        gst_buffer_unmap(pGstBuffer, &info);\n+        gst_buffer_set_size(pGstBuffer, cbCurrentLength);\n+\n+        hr = pMediaBuffer->Unlock();\n+        if (SUCCEEDED(hr))\n+        {\n+            hr = pSample->GetSampleTime(&llTimestamp);\n+            GST_BUFFER_TIMESTAMP(pGstBuffer) = llTimestamp * 100;\n+        }\n+\n+        if (SUCCEEDED(hr))\n+        {\n+            hr = pSample->GetSampleDuration(&llDuration);\n+            GST_BUFFER_DURATION(pGstBuffer) = llDuration * 100;\n+        }\n+\n+#if PTS_DEBUG\n+        if (GST_BUFFER_TIMESTAMP_IS_VALID(pGstBuffer) && GST_BUFFER_DURATION_IS_VALID(pGstBuffer))\n+            g_print(\"JFXMEDIA H265 %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(pGstBuffer), GST_BUFFER_DURATION(pGstBuffer));\n+        else if (GST_BUFFER_TIMESTAMP_IS_VALID(pGstBuffer) && !GST_BUFFER_DURATION_IS_VALID(pGstBuffer))\n+            g_print(\"JFXMEDIA H265 %I64u -1\\n\", GST_BUFFER_TIMESTAMP(pGstBuffer));\n+        else\n+            g_print(\"JFXMEDIA H265 -1\\n\");\n+#endif\n+\n+        ret = gst_pad_push(decoder->srcpad, pGstBuffer);\n+    }\n+    else if (SUCCEEDED(hr))\n+    {\n+        pMediaBuffer->Unlock();\n+    }\n+\n+    SafeRelease(&pMediaBuffer);\n+\n+    return ret;\n+}\n+\n+static gint mfwrapper_process_output(GstMFWrapper *decoder)\n+{\n+    IMFMediaType *pOutputType = NULL;\n+    MFT_OUTPUT_DATA_BUFFER outputDataBuffer;\n+    outputDataBuffer.dwStreamID = 0;\n+    outputDataBuffer.pSample = decoder->pDecoderOutput;\n+    outputDataBuffer.dwStatus = 0;\n+    outputDataBuffer.pEvents = NULL;\n+    DWORD dwFlags = 0;\n+    DWORD dwStatus = 0;\n+    GstFlowReturn ret = GST_FLOW_OK;\n+\n+    if (!decoder->pDecoder)\n+        return PO_FAILED;\n+\n+    if (decoder->is_eos || decoder->is_flushing)\n+        return PO_FLUSHING;\n+\n+    HRESULT hr = decoder->pDecoder->GetOutputStatus(&dwFlags);\n+    if (SUCCEEDED(hr) && dwFlags != MFT_OUTPUT_STATUS_SAMPLE_READY)\n+        return PO_NEED_MORE_DATA;\n+\n+    hr = decoder->pDecoder->ProcessOutput(0, 1, &outputDataBuffer, &dwStatus);\n+    SafeRelease(&outputDataBuffer.pEvents);\n+    if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT)\n+    {\n+        return PO_NEED_MORE_DATA;\n+    }\n+    else if (hr == MF_E_TRANSFORM_STREAM_CHANGE)\n+    {\n+        if (outputDataBuffer.dwStatus == MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE)\n+        {\n+            GUID subType;\n+            guint width = 0; guint height = 0;\n+            DWORD dwTypeIndex = 0;\n+\n+            do\n+            {\n+                hr = decoder->pDecoder->GetOutputAvailableType(0, dwTypeIndex, &pOutputType);\n+\n+                if (SUCCEEDED(hr))\n+                    hr = pOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+\n+                if (SUCCEEDED(hr))\n+                    hr = MFGetAttributeSize(pOutputType, MF_MT_FRAME_SIZE, &width, &height);\n+\n+                if (SUCCEEDED(hr) && (decoder->width != width || decoder->height != height))\n+                {\n+                    decoder->width = width;\n+                    decoder->height = height;\n+                }\n+\n+                \/\/ If decoder prefers MFVideoFormat_P010, then it means we dealing with 10 or 12-bit\n+                \/\/ HEVC, in this case setup color converter\n+                if (SUCCEEDED(hr) && dwTypeIndex == 0 && IsEqualGUID(subType, MFVideoFormat_P010))\n+                {\n+                    hr = mfwrapper_init_colorconvert(decoder);\n+                    break;\n+                }\n+\n+                dwTypeIndex++;\n+\n+                \/\/ I420 and IYUV are same\n+                if (SUCCEEDED(hr) && !IsEqualGUID(subType, MFVideoFormat_IYUV) && !IsEqualGUID(subType, MFVideoFormat_I420))\n+                {\n+                    SafeRelease(&pOutputType);\n+                    hr = E_FAIL;\n+                    continue;\n+                }\n+\n+                if (SUCCEEDED(hr))\n+                    hr = decoder->pDecoder->SetOutputType(0, pOutputType, 0);\n+            } while (hr != MF_E_NO_MORE_TYPES && FAILED(hr));\n+\n+            \/\/ Update caps on src pad in case if something changed\n+            if (SUCCEEDED(hr))\n+                mfwrapper_set_src_caps(decoder);\n+\n+            SafeRelease(&pOutputType);\n+        }\n+    }\n+    else if (SUCCEEDED(hr))\n+    {\n+        if (outputDataBuffer.dwStatus == 0)\n+        {\n+            \/\/ Check if we need to convert output\n+            if (decoder->pColorConvert && decoder->pColorConvertOutput)\n+            {\n+                if (mfwrapper_convert_output(decoder))\n+                {\n+                    ret = mfwrapper_deliver_sample(decoder, decoder->pColorConvertOutput);\n+                }\n+            }\n+            else\n+            {\n+                ret = mfwrapper_deliver_sample(decoder, decoder->pDecoderOutput);\n+            }\n+        }\n+    }\n+\n+    if (decoder->is_eos || decoder->is_flushing || ret != GST_FLOW_OK)\n+        return PO_FLUSHING;\n+    else if (SUCCEEDED(hr))\n+        return PO_DELIVERED;\n+    else\n+        return PO_FAILED;\n+}\n+\n+\/\/ Processes input buffers\n+static GstFlowReturn mfwrapper_chain(GstPad *pad, GstObject *parent, GstBuffer *buf)\n+{\n+    GstFlowReturn ret = GST_FLOW_OK;\n+    GstMFWrapper *decoder = GST_MFWRAPPER(parent);\n+\n+    if (decoder->is_flushing || decoder->is_eos_received)\n+    {\n+        \/\/ INLINE - gst_buffer_unref()\n+        gst_buffer_unref(buf);\n+        return GST_FLOW_FLUSHING;\n+    }\n+\n+    if (!mfwrapper_process_input(decoder, buf))\n+        return GST_FLOW_FLUSHING;\n+\n+    gint po_ret = mfwrapper_process_output(decoder);\n+    if (po_ret != PO_DELIVERED && po_ret != PO_NEED_MORE_DATA)\n+        return GST_FLOW_FLUSHING;\n+\n+    if (decoder->is_flushing)\n+        return GST_FLOW_FLUSHING;\n+\n+    return ret;\n+}\n+\n+static gboolean mfwrapper_push_sink_event(GstMFWrapper *decoder, GstEvent *event)\n+{\n+    gboolean ret = TRUE;\n+\n+    if (gst_pad_is_linked(decoder->srcpad))\n+        ret = gst_pad_push_event(decoder->srcpad, gst_event_ref(event));  \/\/ INLINE - gst_event_ref()\n+\n+    \/\/ INLINE - gst_event_unref()\n+    gst_event_unref(event);\n+\n+    return ret;\n+}\n+\n+static gboolean mfwrapper_sink_event(GstPad* pad, GstObject *parent, GstEvent *event)\n+{\n+    gboolean ret = FALSE;\n+    GstMFWrapper *decoder = GST_MFWRAPPER(parent);\n+    HRESULT hr = S_OK;\n+\n+    switch (GST_EVENT_TYPE(event))\n+    {\n+    case GST_EVENT_SEGMENT:\n+    {\n+        decoder->force_discontinuity = TRUE;\n+        ret = mfwrapper_push_sink_event(decoder, event);\n+        decoder->is_eos_received = FALSE;\n+        decoder->is_eos = FALSE;\n+    }\n+    break;\n+    case GST_EVENT_FLUSH_START:\n+    {\n+        decoder->is_flushing = TRUE;\n+\n+        ret = mfwrapper_push_sink_event(decoder, event);\n+    }\n+    break;\n+    case GST_EVENT_FLUSH_STOP:\n+    {\n+        decoder->pDecoder->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+        if (decoder->pColorConvert)\n+            decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+\n+        ret = mfwrapper_push_sink_event(decoder, event);\n+\n+        decoder->is_flushing = FALSE;\n+    }\n+    break;\n+    case GST_EVENT_EOS:\n+    {\n+        decoder->is_eos_received = TRUE;\n+\n+        \/\/ Let decoder know that we got end of stream\n+        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0);\n+\n+        \/\/ Ask decoder to produce all remaining data\n+        if (SUCCEEDED(hr))\n+            decoder->pDecoder->ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, 0);\n+\n+        \/\/ Deliver remaining data\n+        gint po_ret;\n+        do\n+        {\n+            po_ret = mfwrapper_process_output(decoder);\n+        } while (po_ret == PO_DELIVERED);\n+\n+        if (decoder->pColorConvert)\n+        {\n+            hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0);\n+            if (SUCCEEDED(hr))\n+                hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+        }\n+\n+        \/\/ We done pushing all frames. Deliver EOS.\n+        ret = mfwrapper_push_sink_event(decoder, event);\n+\n+        decoder->is_eos = TRUE;\n+    }\n+    break;\n+    case GST_EVENT_CAPS:\n+    {\n+        GstCaps *caps;\n+\n+        gst_event_parse_caps(event, &caps);\n+        if (!mfwrapper_sink_set_caps(pad, parent, caps))\n+        {\n+            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR, GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE, g_strdup(\"Failed to decode stream\"), NULL, (\"mfwrapper.c\"), (\"mfwrapper_sink_event\"), 0);\n+        }\n+\n+        \/\/ INLINE - gst_event_unref()\n+        gst_event_unref(event);\n+        ret = TRUE;\n+    }\n+    break;\n+    default:\n+        ret = mfwrapper_push_sink_event(decoder, event);\n+        break;\n+    }\n+\n+    return ret;\n+}\n+\n+static gboolean mfwrapper_get_mf_media_types(GstCaps *caps, GUID *pMajorType, GUID *pSubType)\n+{\n+    GstStructure *s = NULL;\n+    const gchar *mimetype = NULL;\n+\n+    if (caps == NULL || pMajorType == NULL || pSubType == NULL)\n+        return FALSE;\n+\n+    s = gst_caps_get_structure(caps, 0);\n+    if (s != NULL)\n+    {\n+        mimetype = gst_structure_get_name(s);\n+        if (mimetype != NULL)\n+        {\n+            if (strstr(mimetype, \"video\/x-h265\") != NULL)\n+            {\n+                *pMajorType = MFMediaType_Video;\n+                *pSubType = MFVideoFormat_HEVC;\n+\n+                return TRUE;\n+            }\n+        }\n+    }\n+\n+    return FALSE;\n+}\n+\n+static HRESULT mfwrapper_load_decoder(GstMFWrapper *decoder, GstCaps *caps)\n+{\n+    HRESULT hr = S_OK;\n+    UINT32 count = 0;\n+\n+    GUID majorType;\n+    GUID subType;\n+\n+    IMFActivate **ppActivate = NULL;\n+\n+    MFT_REGISTER_TYPE_INFO info = { 0 };\n+\n+    if (decoder->pDecoder)\n+        return S_OK;\n+\n+    if (!mfwrapper_get_mf_media_types(caps, &majorType, &subType))\n+        return E_FAIL;\n+\n+    info.guidMajorType = majorType;\n+    info.guidSubtype = subType;\n+\n+    hr = MFTEnumEx(MFT_CATEGORY_VIDEO_DECODER,\n+        MFT_ENUM_FLAG_SYNCMFT | MFT_ENUM_FLAG_LOCALMFT | MFT_ENUM_FLAG_SORTANDFILTER,\n+        &info,\n+        NULL,\n+        &ppActivate,\n+        &count);\n+    if (SUCCEEDED(hr) && count == 0)\n+    {\n+        hr = E_FAIL;\n+    }\n+\n+    if (SUCCEEDED(hr))\n+    {\n+        hr = ppActivate[0]->ActivateObject(IID_PPV_ARGS(&decoder->pDecoder));\n+    }\n+\n+    for (UINT32 i = 0; i < count; i++)\n+    {\n+        ppActivate[i]->Release();\n+    }\n+\n+    CoTaskMemFree(ppActivate);\n+\n+    return hr;\n+}\n+\n+gsize mfwrapper_get_hevc_config(void *in, gsize in_size, BYTE *out, gsize out_size)\n+{\n+    guintptr bdata = (guintptr)in;\n+    guint8 arrayCount = 0;\n+    guint16 nalUnitsCount = 0;\n+    guint16 nalUnitLength = 0;\n+    guint ii = 0;\n+    guint jj = 0;\n+    gsize in_bytes_count = 22;\n+    gsize out_bytes_count = 0;\n+    guint8 startCode[4] = { 0x00, 0x00, 0x00, 0x01 };\n+\n+    if (in_bytes_count > in_size)\n+        return 0;\n+\n+    \/\/ Skip first 22 bytes\n+    bdata += in_bytes_count;\n+\n+    \/\/ Get array count\n+    arrayCount = *(guint8*)bdata;\n+    bdata++; in_bytes_count++;\n+\n+    for (ii = 0; ii < arrayCount; ii++) {\n+        if ((in_bytes_count + 3) > in_size)\n+            return 0;\n+\n+        \/\/ Skip 1 byte, not needed\n+        bdata++; in_bytes_count++;\n+\n+        \/\/ 2 bytes number of nal units in array\n+        nalUnitsCount = ((guint16)*(guint8*)bdata) << 8;\n+        bdata++; in_bytes_count++;\n+        nalUnitsCount |= (guint16)*(guint8*)bdata;\n+        bdata++; in_bytes_count++;\n+\n+        for (jj = 0; jj < nalUnitsCount; jj++) {\n+            if ((in_bytes_count + 2) > in_size)\n+                return 0;\n+\n+            nalUnitLength = ((guint16)*(guint8*)bdata) << 8;\n+            bdata++; in_bytes_count++;\n+            nalUnitLength |= (guint16)*(guint8*)bdata;\n+            bdata++; in_bytes_count++;\n+\n+            if ((out_bytes_count + 4) > out_size)\n+                return 0;\n+\n+            \/\/ Set start code\n+            memcpy(out, &startCode[0], sizeof(startCode));\n+            out += sizeof(startCode); out_bytes_count += sizeof(startCode);\n+\n+            if ((out_bytes_count + nalUnitLength) > out_size)\n+                return 0;\n+\n+            if ((in_bytes_count + nalUnitLength) > in_size)\n+                return 0;\n+\n+            \/\/ Copy nal unit\n+            memcpy(out, (guint8*)bdata, nalUnitLength);\n+            bdata += nalUnitLength; in_bytes_count += nalUnitLength;\n+            out += nalUnitLength; out_bytes_count += nalUnitLength;\n+        }\n+    }\n+\n+    return out_bytes_count;\n+}\n+\n+static HRESULT mfwrapper_set_input_media_type(GstMFWrapper *decoder, GstCaps *caps)\n+{\n+    HRESULT hr = S_OK;\n+\n+    IMFMediaType *pInputType = NULL;\n+    GUID majorType;\n+    GUID subType;\n+    GstStructure *s = NULL;\n+\n+    s = gst_caps_get_structure(caps, 0);\n+    if (s == NULL)\n+        return E_FAIL;\n+\n+    hr = MFCreateMediaType(&pInputType);\n+\n+    if (!mfwrapper_get_mf_media_types(caps, &majorType, &subType))\n+        return E_FAIL;\n+\n+    if (SUCCEEDED(hr))\n+        hr = pInputType->SetGUID(MF_MT_MAJOR_TYPE, majorType);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pInputType->SetGUID(MF_MT_SUBTYPE, subType);\n+\n+    if (SUCCEEDED(hr) && gst_structure_get_int(s, \"width\", (gint*)&decoder->width) && gst_structure_get_int(s, \"height\", (gint*)&decoder->height))\n+        hr = MFSetAttributeSize(pInputType, MF_MT_FRAME_SIZE, decoder->width, decoder->height);\n+\n+    if (SUCCEEDED(hr) && gst_structure_get_fraction(s, \"framerate\", (gint*)&decoder->framerate_num, (gint*)&decoder->framerate_den))\n+        hr = MFSetAttributeRatio(pInputType, MF_MT_FRAME_RATE, decoder->framerate_num, decoder->framerate_den);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->SetInputType(0, pInputType, 0);\n+\n+    SafeRelease(&pInputType);\n+\n+    return hr;\n+}\n+\n+static HRESULT mfwrapper_set_output_media_type(GstMFWrapper *decoder, GstCaps *caps)\n+{\n+    HRESULT hr = S_OK;\n+\n+    IMFMediaType *pOutputType = NULL;\n+\n+    hr = MFCreateMediaType(&pOutputType);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pOutputType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pOutputType->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_IYUV);\n+\n+    if (SUCCEEDED(hr))\n+        hr = MFSetAttributeSize(pOutputType, MF_MT_FRAME_SIZE, decoder->width, decoder->height);\n+\n+    if (SUCCEEDED(hr))\n+        hr = MFSetAttributeRatio(pOutputType, MF_MT_FRAME_RATE, decoder->framerate_num, decoder->framerate_den);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->SetOutputType(0, pOutputType, 0);\n+\n+    \/\/ Set srcpad caps\n+    mfwrapper_set_src_caps(decoder);\n+\n+    SafeRelease(&pOutputType);\n+\n+    return hr;\n+}\n+\n+static gboolean mfwrapper_init_mf(GstMFWrapper *decoder, GstCaps *caps)\n+{\n+    DWORD dwStatus = 0;\n+    GstStructure *s = NULL;\n+    const GValue *codec_data_value = NULL;\n+    GstBuffer *codec_data = NULL;\n+    gint skipSize = 0;\n+\n+    HRESULT hr = mfwrapper_load_decoder(decoder, caps);\n+\n+    if (SUCCEEDED(hr))\n+        hr = mfwrapper_set_input_media_type(decoder, caps);\n+\n+    if (SUCCEEDED(hr))\n+        hr = mfwrapper_set_output_media_type(decoder, caps);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->GetInputStatus(0, &dwStatus);\n+\n+    if (FAILED(hr) || dwStatus != MFT_INPUT_STATUS_ACCEPT_DATA) {\n+        return FALSE;\n+    }\n+\n+    if (SUCCEEDED(hr))\n+        s = gst_caps_get_structure(caps, 0);\n+\n+    if (s == NULL)\n+        return FALSE;\n+\n+    \/\/ Get HEVC Config\n+    GstMapInfo info;\n+\n+    if (SUCCEEDED(hr))\n+        codec_data_value = gst_structure_get_value(s, \"codec_data\");\n+\n+    if (codec_data_value)\n+        codec_data = gst_value_get_buffer(codec_data_value);\n+\n+    if (codec_data != NULL)\n+    {\n+        if (gst_buffer_map(codec_data, &info, GST_MAP_READ) && info.size > 0)\n+        {\n+            decoder->header = new BYTE[info.size * 2]; \/\/ Should be enough, since we will only add several 4 bytes start codes to 3 nal units\n+            if (decoder->header == NULL)\n+            {\n+                gst_buffer_unmap(codec_data, &info);\n+                return FALSE;\n+            }\n+\n+            decoder->header_size = mfwrapper_get_hevc_config(info.data, info.size, decoder->header, info.size * 2);\n+            gst_buffer_unmap(codec_data, &info);\n+\n+            if (decoder->header_size <= 0)\n+            {\n+                delete[] decoder->header;\n+                decoder->header = NULL;\n+                return FALSE;\n+            }\n+        }\n+    }\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL);\n+\n+    if (SUCCEEDED(hr))\n+        return TRUE;\n+    else\n+        return FALSE;\n+}\n+\n+static gboolean mfwrapper_sink_set_caps(GstPad * pad, GstObject *parent, GstCaps * caps)\n+{\n+    gboolean ret = FALSE;\n+    GstMFWrapper *decoder = GST_MFWRAPPER(parent);\n+\n+    if (pad == decoder->sinkpad)\n+    {\n+        ret = mfwrapper_init_mf(decoder, caps);\n+    }\n+\n+    return ret;\n+}\n+\n+static gboolean mfwrapper_activate(GstPad *pad, GstObject *parent)\n+{\n+    return gst_pad_activate_mode(pad, GST_PAD_MODE_PUSH, TRUE);\n+}\n+\n+static gboolean mfwrapper_activatemode(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean active)\n+{\n+    gboolean res = FALSE;\n+    GstMFWrapper *decoder = GST_MFWRAPPER(parent);\n+\n+    switch (mode) {\n+    case GST_PAD_MODE_PUSH:\n+        res = TRUE;\n+        break;\n+    case GST_PAD_MODE_PULL:\n+        res = TRUE;\n+        break;\n+    default:\n+        \/* unknown scheduling mode *\/\n+        res = FALSE;\n+        break;\n+    }\n+\n+    return res;\n+}\n+\n+gboolean mfwrapper_init(GstPlugin* mfwrapper)\n+{\n+    return gst_element_register(mfwrapper, \"mfwrapper\", 512, GST_TYPE_MFWRAPPER);\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.cpp","additions":1303,"deletions":0,"binary":false,"changes":1303,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef __MF_WRAPPER_H__\n+#define __MF_WRAPPER_H__\n+\n+#include <gst\/gst.h>\n+\n+#include <mfapi.h>\n+#include <mferror.h>\n+#include <mftransform.h>\n+\n+G_BEGIN_DECLS\n+\n+#define GST_TYPE_MFWRAPPER \\\n+    (gst_mfwrapper_get_type())\n+#define GST_MFWRAPPER(obj) \\\n+    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MFWRAPPER,GstMFWrapper))\n+#define GST_MFWRAPPER_CLASS(klass) \\\n+    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MFWRAPPER,GstMFWrapperClass))\n+#define GST_IS_MFWRAPPER(obj) \\\n+    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MFWRAPPER))\n+#define GST_IS_MFWRAPPER_CLASS(klass) \\\n+    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MFWRAPPER))\n+\n+typedef struct _GstMFWrapper      GstMFWrapper;\n+typedef struct _GstMFWrapperClass GstMFWrapperClass;\n+\n+struct _GstMFWrapper\n+{\n+    GstElement element;\n+\n+    GstPad *sinkpad;         \/\/ input pad\n+    GstPad *srcpad;          \/\/ output pads\n+\n+    gint codec_id;\n+\n+    gboolean is_flushing;\n+    gboolean is_eos_received;\n+    gboolean is_eos;\n+\n+    gboolean force_discontinuity;\n+\n+    HRESULT hr_mfstartup;\n+\n+    IMFTransform *pDecoder;\n+\n+    IMFSample *pDecoderOutput;\n+\n+    IMFTransform *pColorConvert;\n+\n+    IMFSample *pColorConvertOutput;\n+\n+    BYTE *header;\n+    guint header_size;\n+\n+    guint width;\n+    guint height;\n+    guint framerate_num;\n+    guint framerate_den;\n+};\n+\n+struct _GstMFWrapperClass\n+{\n+    GstElementClass parent_class;\n+};\n+\n+GType gst_mfwrapper_get_type(void);\n+\n+gboolean mfwrapper_init(GstPlugin* mfwrapper);\n+\n+G_END_DECLS\n+\n+#endif \/\/ __MF_WRAPPER_H__\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.h","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include <fxplugins_common.h>\n+#include \"fxplugins_common.h\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/progressbuffer\/progressbuffer.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-INCLUDES += $(shell pkg-config --cflags libavcodec libavformat)\n+INCLUDES += $(shell pkg-config --cflags libavcodec libavformat libswscale)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/linux\/avplugin\/Makefile","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-              strmiids.lib\n+              strmiids.lib \\\n+              Mfplat.lib \\\n+              mfuuid.lib\n@@ -44,1 +46,2 @@\n-          progressbuffer\/win32\n+          progressbuffer\/win32 \\\n+          mfwrapper\n@@ -58,1 +61,2 @@\n-              dshowwrapper\/Src.cpp\n+              dshowwrapper\/Src.cpp \\\n+              mfwrapper\/mfwrapper.cpp\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/fxplugins\/Makefile","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+        H265,\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/PipelineManagement\/Track.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include <fxplugins_common.h>\n@@ -157,1 +158,0 @@\n-#if TARGET_OS_WIN32\n@@ -169,0 +169,1 @@\n+#if TARGET_OS_WIN32 | TARGET_OS_LINUX\n@@ -172,1 +173,1 @@\n-                    g_object_set(m_Elements[VIDEO_DECODER], \"codec-id\", (gint)CODEC_ID_AVC1, NULL); \/\/ Check for AVC1 (MP4). For HLS we should get error early\n+                    g_object_set(m_Elements[VIDEO_DECODER], \"codec-id\", (gint)JFX_CODEC_ID_AVC1, NULL); \/\/ Check for AVC1 (MP4). For HLS we should get error early\n@@ -184,17 +185,16 @@\n-            }\n-        }\n-    }\n-\n-    return CGstAudioPlaybackPipeline::IsCodecSupported(pCaps);\n-#else \/\/ TARGET_OS_WIN32\n-    GstStructure *s = NULL;\n-    const gchar *mimetype = NULL;\n-\n-    if (pCaps)\n-    {\n-        s = gst_caps_get_structure (pCaps, 0);\n-        if (s != NULL)\n-        {\n-            mimetype = gst_structure_get_name (s);\n-            if (mimetype != NULL)\n-            {\n+                else if (strstr(mimetype, \"video\/x-h265\") != NULL) \/\/ H.265\n+                {\n+                    gboolean is_supported = FALSE;\n+                    g_object_set(m_Elements[VIDEO_DECODER], \"codec-id\", (gint)JFX_CODEC_ID_H265, NULL); \/\/ Check for H265 (MP4)\n+                    g_object_get(m_Elements[VIDEO_DECODER], \"is-supported\", &is_supported, NULL);\n+                    if (is_supported)\n+                    {\n+                        return TRUE;\n+                    }\n+                    else\n+                    {\n+                        m_videoCodecErrorCode = ERROR_MEDIA_H265_FORMAT_UNSUPPORTED;\n+                        return FALSE;\n+                    }\n+                }\n+#else \/\/ TARGET_OS_WIN32 | TARGET_OS_LINUX\n@@ -206,0 +206,1 @@\n+#endif \/\/ TARGET_OS_WIN32 | TARGET_OS_LINUX\n@@ -211,1 +212,0 @@\n-#endif \/\/ TRAGET_OS_WIN32\n@@ -238,0 +238,48 @@\n+bool CGstAVPlaybackPipeline::LoadDecoder(GstCaps *pCaps)\n+{\n+#if TARGET_OS_WIN32\n+    GstStructure *s = NULL;\n+    const gchar *mimetype = NULL;\n+    char* strVideoDecoderName = NULL;\n+\n+    if (m_Elements[VIDEO_BIN] == NULL)\n+        return FALSE;\n+\n+    if (pCaps)\n+    {\n+        s = gst_caps_get_structure(pCaps, 0);\n+        if (s != NULL)\n+        {\n+            mimetype = gst_structure_get_name(s);\n+            if (mimetype != NULL)\n+            {\n+                if (strstr(mimetype, \"video\/x-h264\") != NULL) \/\/ H.264\n+                {\n+                    strVideoDecoderName = \"dshowwrapper\";\n+                }\n+                else if (strstr(mimetype, \"video\/x-h265\") != NULL) \/\/ H.265\n+                {\n+                    strVideoDecoderName = \"mfwrapper\";\n+                }\n+                else\n+                {\n+                    return FALSE;\n+                }\n+\n+                GstElement *videodec = gst_element_factory_make(strVideoDecoderName, NULL);\n+                if (videodec == NULL)\n+                    return FALSE;\n+\n+                gst_bin_add_many(GST_BIN(m_Elements[VIDEO_BIN]), videodec, NULL);\n+                if (!gst_element_link_many(m_Elements[VIDEO_QUEUE], videodec, m_Elements[VIDEO_SINK], NULL))\n+                    return FALSE;\n+\n+                m_Elements.add(VIDEO_DECODER, videodec);\n+            }\n+        }\n+    }\n+#endif \/\/ TARGET_OS_WIN32\n+\n+    return CGstAudioPlaybackPipeline::LoadDecoder(pCaps);\n+}\n+\n@@ -491,0 +539,7 @@\n+#if TARGET_OS_WIN32\n+        if (pPipeline->m_Elements[VIDEO_DECODER] == NULL)\n+        {\n+            if (!pPipeline->LoadDecoder(pCaps))\n+                goto Error;\n+        }\n+#endif \/\/ TARGET_OS_WIN32\n@@ -789,0 +844,2 @@\n+        } else if (strMimeType.find(\"video\/x-h265\") != string::npos) {\n+            encoding = CTrack::H265;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAVPlaybackPipeline.cpp","additions":78,"deletions":21,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    virtual bool LoadDecoder(GstCaps *pCaps);\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAVPlaybackPipeline.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include <fxplugins_common.h>\n@@ -974,1 +975,1 @@\n-                            g_object_set(m_Elements[AUDIO_DECODER], \"codec-id\", (gint)CODEC_ID_AAC, NULL);\n+                            g_object_set(m_Elements[AUDIO_DECODER], \"codec-id\", (gint)JFX_CODEC_ID_AAC, NULL);\n@@ -1036,0 +1037,5 @@\n+bool CGstAudioPlaybackPipeline::LoadDecoder(GstCaps *pCaps)\n+{\n+    return TRUE; \/\/ Nothing to do for audio yet\n+}\n+\n@@ -1191,0 +1197,17 @@\n+                else if (pPipeline != NULL && pPipeline->m_pEventDispatcher != NULL && error->domain == JFX_GST_ERROR)\n+                {\n+                    if (error->code == JFX_GST_MISSING_LIBSWSCALE)\n+                    {\n+                        if (!pPipeline->m_pEventDispatcher->SendPlayerMediaErrorEvent(ERROR_MISSING_LIBSWSCALE))\n+                        {\n+                            LOGGER_LOGMSG(LOGGER_ERROR, \"Cannot send media error event.\\n\");\n+                        }\n+                    }\n+                    else if (error->code == JFX_GST_INVALID_LIBSWSCALE)\n+                    {\n+                        if (!pPipeline->m_pEventDispatcher->SendPlayerMediaErrorEvent(ERROR_INVALID_LIBSWSCALE))\n+                        {\n+                            LOGGER_LOGMSG(LOGGER_ERROR, \"Cannot send media error event.\\n\");\n+                        }\n+                    }\n+                }\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAudioPlaybackPipeline.cpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,10 +47,0 @@\n-#if TARGET_OS_WIN32\n-enum CODEC_ID\n-{\n-    CODEC_ID_UNKNOWN = 0,\n-    CODEC_ID_AAC,\n-    CODEC_ID_H264, \/\/ HLS\n-    CODEC_ID_AVC1, \/\/ MP4\n-};\n-#endif \/\/ TARGET_OS_WIN32\n-\n@@ -121,0 +111,1 @@\n+    virtual bool LoadDecoder(GstCaps *pCaps);\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAudioPlaybackPipeline.h","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -484,1 +484,3 @@\n-    return CreateAVPipeline(source, \"qtdemux\", \"dshowwrapper\", true, \"dshowwrapper\", pVideoSink, pOptions, ppPipeline);\n+    \/\/ We need to load dshowwrapper (H.264) or mfwrapper (H.265), but we do not know which one based on .mp4\n+    \/\/ extension, so intead we will load video decoder dynamically when qtdemux will signal video pad added.\n+    return CreateAVPipeline(source, \"qtdemux\", \"dshowwrapper\", true, NULL, pVideoSink, pOptions, ppPipeline);\n@@ -814,1 +816,1 @@\n-    GstElement *videodec   = CreateElement (strDecoderName);\n+    GstElement *videodec   = strDecoderName != NULL ? CreateElement (strDecoderName) : NULL;\n@@ -816,1 +818,1 @@\n-    if (NULL == videodec || NULL == videoqueue)\n+    if ((NULL != strDecoderName && NULL == videodec) || NULL == videoqueue)\n@@ -842,1 +844,0 @@\n-\n@@ -847,3 +848,12 @@\n-    gst_bin_add_many (GST_BIN (*ppVideobin), videoqueue, videodec, pVideoSink, NULL);\n-    if(!gst_element_link_many (videoqueue, videodec, pVideoSink, NULL))\n-        return ERROR_GSTREAMER_ELEMENT_LINK_VIDEO_BIN;\n+    if (videodec)\n+    {\n+        gst_bin_add_many(GST_BIN(*ppVideobin), videoqueue, videodec, pVideoSink, NULL);\n+        if (!gst_element_link_many(videoqueue, videodec, pVideoSink, NULL))\n+            return ERROR_GSTREAMER_ELEMENT_LINK_VIDEO_BIN;\n+    }\n+    else\n+    {\n+        gst_bin_add_many(GST_BIN(*ppVideobin), videoqueue, pVideoSink, NULL);\n+        if (!gst_element_link_many(pVideoSink, NULL))\n+            return ERROR_GSTREAMER_ELEMENT_LINK_VIDEO_BIN;\n+    }\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstPipelineFactory.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -485,0 +485,3 @@\n+                case 'hvc1':\n+                    encoding = CTrack::H265;\n+                    break;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/osx\/avf\/AVFMediaPlayer.mm","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+\tPLUGINS_DIR = ..\/..\/..\/gstreamer\/plugins\n@@ -85,0 +86,1 @@\n+\t           -I$(PLUGINS_DIR) \\\n@@ -148,1 +150,1 @@\n-OBJECTS  = $(patsubst %.cpp,$(OBJBASE_DIR)\/%.o,$(CPP_SOURCES)) $(patsubst %.c,$(OBJBASE_DIR)\/%.o,$(C_SOURCES)) \n+OBJECTS  = $(patsubst %.cpp,$(OBJBASE_DIR)\/%.o,$(CPP_SOURCES)) $(patsubst %.c,$(OBJBASE_DIR)\/%.o,$(C_SOURCES))\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/projects\/linux\/Makefile","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+PLUGINS_DIR = $(BASE_DIR)\/gstreamer\/plugins\n@@ -101,1 +102,2 @@\n-           -I$(GSTREAMER_LITE_DIR)\/gstreamer\/libs\n+           -I$(GSTREAMER_LITE_DIR)\/gstreamer\/libs \\\n+           -I$(PLUGINS_DIR)\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/projects\/mac\/Makefile","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+PLUGINS_DIR = ..\/..\/..\/gstreamer\/plugins\n@@ -69,1 +70,2 @@\n-           -I$(GSTREAMER_LITE_DIR)\/gstreamer\/libs\n+           -I$(GSTREAMER_LITE_DIR)\/gstreamer\/libs \\\n+           -I$(PLUGINS_DIR)\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/projects\/win\/Makefile","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-<?xml version='1.0' encoding='UTF-8' ?>\r\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n@@ -35,0 +35,1 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\plugins\\mfwrapper\\mfwrapper.cpp\" \/>\r\n@@ -45,0 +46,8 @@\n+  <ItemGroup>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\dshowwrapper\\Allocator.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\dshowwrapper\\dshowwrapper.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\dshowwrapper\\Sink.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\dshowwrapper\\Src.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\fxplugins_common.h\" \/>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\mfwrapper\\mfwrapper.h\" \/>\r\n+  <\/ItemGroup>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/plugins\/plugins.vcxproj","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -13,0 +13,3 @@\n+    <Filter Include=\"mfwrapper\">\r\n+      <UniqueIdentifier>{a396eb3d-d2e5-418e-999c-38fcdc5473a5}<\/UniqueIdentifier>\r\n+    <\/Filter>\r\n@@ -43,0 +46,21 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\plugins\\mfwrapper\\mfwrapper.cpp\">\r\n+      <Filter>mfwrapper<\/Filter>\r\n+    <\/ClCompile>\r\n+  <\/ItemGroup>\r\n+  <ItemGroup>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\mfwrapper\\mfwrapper.h\">\r\n+      <Filter>mfwrapper<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\dshowwrapper\\Allocator.h\">\r\n+      <Filter>dshowwrapper<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\dshowwrapper\\dshowwrapper.h\">\r\n+      <Filter>dshowwrapper<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\dshowwrapper\\Sink.h\">\r\n+      <Filter>dshowwrapper<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\dshowwrapper\\Src.h\">\r\n+      <Filter>dshowwrapper<\/Filter>\r\n+    <\/ClInclude>\r\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\fxplugins_common.h\" \/>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/plugins\/plugins.vcxproj.filters","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}