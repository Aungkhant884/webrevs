{"files":[{"patch":"@@ -27,54 +27,54 @@\n-    <p>Provides classes that create and operate on a {@link Binding Binding}\n-        that calculates a value that depends on one or more sources.<\/p>\n-    <h2>Characteristics of Bindings<\/h2>\n-    <p>Bindings are assembled from one or more sources, usually called\n-        their dependencies. A binding observes its dependencies for changes\n-        and updates its own value according to changes in the dependencies.<\/p>\n-    <p>Almost all bindings defined in this library require\n-        implementations of {@link javafx.beans.Observable} for their\n-        dependencies. There are two types of implementations already provided,\n-        the properties in the package {@link javafx.beans.property} and the\n-        observable collections ({@link javafx.collections.ObservableList} and\n-        {@link javafx.collections.ObservableMap}). Bindings also implement\n-        {@code Observable} and can again serve as sources for other bindings\n-        allowing to construct very complex bindings from simple ones.<\/p>\n-    <p>Bindings in our implementation are always calculated lazily.\n-        That means, if a dependency changes, the result of a binding is not\n-        immediately recalculated, but it is marked as invalid. Next time the\n-        value of an invalid binding is requested, it is recalculated.<\/p>\n-    <h2>High Level API and Low Level API<\/h2>\n-    <p>The Binding API is roughly divided in two parts, the High Level\n-        Binding API and the Low Level Binding API. The High Level Binding API\n-        allows to construct simple bindings in an easy to use fashion.\n-        Defining a binding with the High Level API should be straightforward,\n-        especially when used in an IDE that provides code completion.\n-        Unfortunately it has its limitation and at that point the Low Level\n-        API comes into play. Experienced Java developers can use the Low Level\n-        API to define bindings, if the functionality of the High Level API is\n-        not sufficient or to improve the performance. The main goals of the\n-        Low Level API are fast execution and small memory footprint.<\/p>\n-    <p>Following is an example of how both APIs can be used. Assuming\n-        we have four instances of {@link\n-        javafx.beans.property.DoubleProperty} {@code a}, {@code b}, {@code\n-        c} , and {@code d}, we can define a binding that calculates {@code a*b\n-        + c*d} with the High Level API for example like this:<\/p>\n-    <p>{@code NumberBinding result = Bindings.add (a.multiply(b),\n-        c.multiply(d)); }<\/p>\n-    <p>Defining the same binding using the Low Level API could be done\n-        like this:<\/p>\n-    <pre>\n-<code>\n-DoubleBinding foo = new DoubleBinding() {\n-\n-    {\n-        super.bind(a, b, c, d);\n-    }\n-\n-    &#x40;Override\n-    protected double computeValue() {\n-        return a.getValue() * b.getValue() + c.getValue() * d.getValue();\n-    }\n-};\n-<\/code>\n-<\/pre>\n-*\/\n+ * <p>Provides classes that create and operate on a {@link Binding Binding}\n+ *     that calculates a value that depends on one or more sources.<\/p>\n+ * <h2>Characteristics of Bindings<\/h2>\n+ * <p>Bindings are assembled from one or more sources, usually called\n+ *     their dependencies. A binding observes its dependencies for changes\n+ *     and updates its own value according to changes in the dependencies.<\/p>\n+ * <p>Almost all bindings defined in this library require\n+ *     implementations of {@link javafx.beans.Observable} for their\n+ *     dependencies. There are two types of implementations already provided,\n+ *     the properties in the package {@link javafx.beans.property} and the\n+ *     observable collections ({@link javafx.collections.ObservableList} and\n+ *     {@link javafx.collections.ObservableMap}). Bindings also implement\n+ *     {@code Observable} and can again serve as sources for other bindings\n+ *     allowing to construct very complex bindings from simple ones.<\/p>\n+ * <p>Bindings in our implementation are always calculated lazily.\n+ *     That means, if a dependency changes, the result of a binding is not\n+ *     immediately recalculated, but it is marked as invalid. Next time the\n+ *     value of an invalid binding is requested, it is recalculated.<\/p>\n+ * <h2>High Level API and Low Level API<\/h2>\n+ * <p>The Binding API is roughly divided in two parts, the High Level\n+ *     Binding API and the Low Level Binding API. The High Level Binding API\n+ *     allows to construct simple bindings in an easy to use fashion.\n+ *     Defining a binding with the High Level API should be straightforward,\n+ *     especially when used in an IDE that provides code completion.\n+ *     Unfortunately it has its limitation and at that point the Low Level\n+ *     API comes into play. Experienced Java developers can use the Low Level\n+ *     API to define bindings, if the functionality of the High Level API is\n+ *     not sufficient or to improve the performance. The main goals of the\n+ *     Low Level API are fast execution and small memory footprint.<\/p>\n+ * <p>Following is an example of how both APIs can be used. Assuming\n+ *     we have four instances of {@link\n+ *     javafx.beans.property.DoubleProperty} {@code a}, {@code b}, {@code\n+ *     c} , and {@code d}, we can define a binding that calculates {@code a*b\n+ *     + c*d} with the High Level API for example like this:<\/p>\n+ * <p>{@code NumberBinding result = Bindings.add (a.multiply(b),\n+ *     c.multiply(d)); }<\/p>\n+ * <p>Defining the same binding using the Low Level API could be done\n+ *     like this:<\/p>\n+ * <pre>\n+ * <code>\n+ * DoubleBinding foo = new DoubleBinding() {\n+ *\n+ *     {\n+ *         super.bind(a, b, c, d);\n+ *     }\n+ *\n+ *     &#x40;Override\n+ *     protected double computeValue() {\n+ *         return a.getValue() * b.getValue() + c.getValue() * d.getValue();\n+ *     }\n+ * };\n+ * <\/code>\n+ * <\/pre>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/package-info.java","additions":54,"deletions":54,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -27,18 +27,18 @@\n-    <p>The package {@code javafx.beans} contains the interfaces that\n-        define the most generic form of observability. All other classes in\n-        the JavaFX library, that are observable, extend the {@link javafx.beans.Observable}\n-        interface.<\/p>\n-    <p>An implementation of {@code Observable} allows to attach an\n-        {@link javafx.beans.InvalidationListener}. The contentBinding gets notified every time\n-        the {@code Observable} may have changed. Typical implementations of\n-        {@code Observable} are all properties, all bindings, {@link\n-        javafx.collections.ObservableList}, and {@link\n-        javafx.collections.ObservableMap}.<\/p>\n-    <p>An {@code InvalidationListener} will get no further information,\n-        e.g. it will not get the old and the new value of a property. If you\n-        need more information consider using a {@link\n-        javafx.beans.value.ChangeListener} for properties and bindings, {@link\n-        javafx.collections.ListChangeListener} for {@code ObservableLists} or\n-        {@link javafx.collections.MapChangeListener} for {@code ObservableMap}\n-        instead.<\/p>\n-*\/\n+ * <p>The package {@code javafx.beans} contains the interfaces that\n+ *     define the most generic form of observability. All other classes in\n+ *     the JavaFX library, that are observable, extend the {@link javafx.beans.Observable}\n+ *     interface.<\/p>\n+ * <p>An implementation of {@code Observable} allows to attach an\n+ *     {@link javafx.beans.InvalidationListener}. The contentBinding gets notified every time\n+ *     the {@code Observable} may have changed. Typical implementations of\n+ *     {@code Observable} are all properties, all bindings, {@link\n+ *     javafx.collections.ObservableList}, and {@link\n+ *     javafx.collections.ObservableMap}.<\/p>\n+ * <p>An {@code InvalidationListener} will get no further information,\n+ *     e.g. it will not get the old and the new value of a property. If you\n+ *     need more information consider using a {@link\n+ *     javafx.beans.value.ChangeListener} for properties and bindings, {@link\n+ *     javafx.collections.ListChangeListener} for {@code ObservableLists} or\n+ *     {@link javafx.collections.MapChangeListener} for {@code ObservableMap}\n+ *     instead.<\/p>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/package-info.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-<p>Provides various classes that act as adapters between a regular Java Bean\n-property and a corresponding {@link javafx.beans.property.Property JavaFX\n-Property}.<\/p>\n-*\/\n+ * <p>Provides various classes that act as adapters between a regular Java Bean\n+ * property and a corresponding {@link javafx.beans.property.Property JavaFX\n+ * Property}.<\/p>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/adapter\/package-info.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,29 +27,29 @@\n-    <p>The package {@code javafx.beans.property} defines read-only\n-        properties and writable properties, plus a number of implementations.\n-    <\/p>\n-    <h2>Read-only Properties<\/h2>\n-    <p>Read-only properties have two getters, {@code get()} returns the\n-        primitive value, {@code getValue()} returns the boxed value.<\/p>\n-    <p>It is possible to observe read-only properties for changes. They\n-        define methods to add and remove {@link\n-        javafx.beans.InvalidationListener InvalidationListeners} and {@link\n-        javafx.beans.value.ChangeListener ChangeListeners}.<\/p>\n-    <p>To get the context of a read-only property, two methods {@code\n-        getBean()} and {@code getName()} are defined. They return the\n-        containing bean and the name of a property.<\/p>\n-\n-    <h2>Writable Properties<\/h2>\n-    <p>In addition to the functionality defined for read-only\n-        properties, writable properties contain the following methods.<\/p>\n-    <p>A writable property defines two setters in addition to the\n-        getters defined for read-only properties. The setter {@code set()}\n-        takes a primitive value, the second setter {@code setValue()} takes\n-        the boxed value.<\/p>\n-    <p>All properties can be bound to {@link\n-        javafx.beans.value.ObservableValue ObservableValues} of the same type,\n-        which means that the property will always contain the same value as\n-        the bound {@code ObservableValue}. It is also possible to define a\n-        bidirectional binding between two properties, so that both properties\n-        always contain the same value. If one of the properties changes, the\n-        other one will be updated.<\/p>\n-*\/\n+ * <p>The package {@code javafx.beans.property} defines read-only\n+ *     properties and writable properties, plus a number of implementations.\n+ * <\/p>\n+ * <h2>Read-only Properties<\/h2>\n+ * <p>Read-only properties have two getters, {@code get()} returns the\n+ *     primitive value, {@code getValue()} returns the boxed value.<\/p>\n+ * <p>It is possible to observe read-only properties for changes. They\n+ *     define methods to add and remove {@link\n+ *     javafx.beans.InvalidationListener InvalidationListeners} and {@link\n+ *     javafx.beans.value.ChangeListener ChangeListeners}.<\/p>\n+ * <p>To get the context of a read-only property, two methods {@code\n+ *     getBean()} and {@code getName()} are defined. They return the\n+ *     containing bean and the name of a property.<\/p>\n+ *\n+ * <h2>Writable Properties<\/h2>\n+ * <p>In addition to the functionality defined for read-only\n+ *     properties, writable properties contain the following methods.<\/p>\n+ * <p>A writable property defines two setters in addition to the\n+ *     getters defined for read-only properties. The setter {@code set()}\n+ *     takes a primitive value, the second setter {@code setValue()} takes\n+ *     the boxed value.<\/p>\n+ * <p>All properties can be bound to {@link\n+ *     javafx.beans.value.ObservableValue ObservableValues} of the same type,\n+ *     which means that the property will always contain the same value as\n+ *     the bound {@code ObservableValue}. It is also possible to define a\n+ *     bidirectional binding between two properties, so that both properties\n+ *     always contain the same value. If one of the properties changes, the\n+ *     other one will be updated.<\/p>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/package-info.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -27,95 +27,94 @@\n-    <p>The package {@code javafx.beans.value} contains the two\n-        fundamental interfaces {@link javafx.beans.value.ObservableValue} and {@link\n-        javafx.beans.value.WritableValue} and all of its sub-interfaces.<\/p>\n-\n-    <h2>ObservableValue<\/h2>\n-    An ObservableValue wraps a value that can be read and observed for\n-    invalidations and changes. Listeners have to implement either {@link\n-    javafx.beans.InvalidationListener} or {@link javafx.beans.value.ChangeListener}. To allow\n-    working with primitive types directly a number of sub-interfaces are\n-    defined.\n-    <table>\n-        <caption>ObservableValue Table<\/caption>\n-        <tr>\n-            <th scope=\"col\">Type<\/th>\n-            <th scope=\"col\">Sub-interface of ObservableValue<\/th>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code boolean}<\/th>\n-            <td>{@link javafx.beans.value.ObservableBooleanValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code double}<\/th>\n-            <td>{@link javafx.beans.value.ObservableDoubleValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code float}<\/th>\n-            <td>{@link javafx.beans.value.ObservableFloatValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code int}<\/th>\n-            <td>{@link javafx.beans.value.ObservableIntegerValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code long}<\/th>\n-            <td>{@link javafx.beans.value.ObservableLongValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code double}, {@code float}, {@code int}, {@code long}<\/th>\n-            <td>{@link javafx.beans.value.ObservableNumberValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code Object}<\/th>\n-            <td>{@link javafx.beans.value.ObservableObjectValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code String}<\/th>\n-            <td>{@link javafx.beans.value.ObservableStringValue}<\/td>\n-        <\/tr>\n-    <\/table>\n-\n-    <h2>WritableValue<\/h2>\n-    A WritableValue wraps a value that can be read and set. As with {@code\n-    ObservableValues}, a number of sub-interfaces are defined to work with\n-    primitive types directly.\n-    <table>\n-        <caption>WritableValue Table<\/caption>\n-        <tr>\n-            <th scope=\"col\">Type<\/th>\n-            <th scope=\"col\">Sub-interface of WritableValue<\/th>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code boolean}<\/th>\n-            <td>{@link javafx.beans.value.WritableBooleanValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code double}<\/th>\n-            <td>{@link javafx.beans.value.WritableDoubleValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code float}<\/th>\n-            <td>{@link javafx.beans.value.WritableFloatValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code int}<\/th>\n-            <td>{@link javafx.beans.value.WritableIntegerValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code long}<\/th>\n-            <td>{@link javafx.beans.value.WritableLongValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code double}, {@code float}, {@code int}, {@code long}<\/th>\n-            <td>{@link javafx.beans.value.WritableNumberValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code Object}<\/th>\n-            <td>{@link javafx.beans.value.WritableObjectValue}<\/td>\n-        <\/tr>\n-        <tr>\n-            <th scope=\"row\">{@code String}<\/th>\n-            <td>{@link javafx.beans.value.WritableStringValue}<\/td>\n-        <\/tr>\n-    <\/table>\n-\n-*\/\n+ * <p>The package {@code javafx.beans.value} contains the two\n+ *     fundamental interfaces {@link javafx.beans.value.ObservableValue} and {@link\n+ *     javafx.beans.value.WritableValue} and all of its sub-interfaces.<\/p>\n+ *\n+ * <h2>ObservableValue<\/h2>\n+ * An ObservableValue wraps a value that can be read and observed for\n+ * invalidations and changes. Listeners have to implement either {@link\n+ * javafx.beans.InvalidationListener} or {@link javafx.beans.value.ChangeListener}. To allow\n+ * working with primitive types directly a number of sub-interfaces are\n+ * defined.\n+ * <table>\n+ *     <caption>ObservableValue Table<\/caption>\n+ *     <tr>\n+ *         <th scope=\"col\">Type<\/th>\n+ *         <th scope=\"col\">Sub-interface of ObservableValue<\/th>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code boolean}<\/th>\n+ *         <td>{@link javafx.beans.value.ObservableBooleanValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code double}<\/th>\n+ *         <td>{@link javafx.beans.value.ObservableDoubleValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code float}<\/th>\n+ *         <td>{@link javafx.beans.value.ObservableFloatValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code int}<\/th>\n+ *         <td>{@link javafx.beans.value.ObservableIntegerValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code long}<\/th>\n+ *         <td>{@link javafx.beans.value.ObservableLongValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code double}, {@code float}, {@code int}, {@code long}<\/th>\n+ *         <td>{@link javafx.beans.value.ObservableNumberValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code Object}<\/th>\n+ *         <td>{@link javafx.beans.value.ObservableObjectValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code String}<\/th>\n+ *         <td>{@link javafx.beans.value.ObservableStringValue}<\/td>\n+ *     <\/tr>\n+ * <\/table>\n+ *\n+ * <h2>WritableValue<\/h2>\n+ * A WritableValue wraps a value that can be read and set. As with {@code\n+ * ObservableValues}, a number of sub-interfaces are defined to work with\n+ * primitive types directly.\n+ * <table>\n+ *     <caption>WritableValue Table<\/caption>\n+ *     <tr>\n+ *         <th scope=\"col\">Type<\/th>\n+ *         <th scope=\"col\">Sub-interface of WritableValue<\/th>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code boolean}<\/th>\n+ *         <td>{@link javafx.beans.value.WritableBooleanValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code double}<\/th>\n+ *         <td>{@link javafx.beans.value.WritableDoubleValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code float}<\/th>\n+ *         <td>{@link javafx.beans.value.WritableFloatValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code int}<\/th>\n+ *         <td>{@link javafx.beans.value.WritableIntegerValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code long}<\/th>\n+ *         <td>{@link javafx.beans.value.WritableLongValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code double}, {@code float}, {@code int}, {@code long}<\/th>\n+ *         <td>{@link javafx.beans.value.WritableNumberValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code Object}<\/th>\n+ *         <td>{@link javafx.beans.value.WritableObjectValue}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <th scope=\"row\">{@code String}<\/th>\n+ *         <td>{@link javafx.beans.value.WritableStringValue}<\/td>\n+ *     <\/tr>\n+ * <\/table>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/package-info.java","additions":94,"deletions":95,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-<p>Contains the essential JavaFX collections and collection utilities<\/p>\n-*\/\n+ * <p>Contains the essential JavaFX collections and collection utilities<\/p>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-<p>Provides JavaFX collections that wrap and transform (for example, sort\n-or filter) other JavaFX collections.<\/p>\n-*\/\n+ * <p>Provides JavaFX collections that wrap and transform (for example, sort\n+ * or filter) other JavaFX collections.<\/p>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/transformation\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-<p>Provides basic framework for FX events, their delivery and handling.<\/p>\n-*\/\n+ * <p>Provides basic framework for FX events, their delivery and handling.<\/p>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/event\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,9 +27,9 @@\n-This package is for standard {@link javafx.util.StringConverter string converters}\n-for JavaFX. Example use cases for these implementations include:\n-  <ul>\n-    <li><a href=\"..\/..\/..\/javafx\/beans\/binding\/package-summary.html\">JavaFX binding API<\/a>\n-        for converting Objects to and from Strings, when the binding requires this.<\/li>\n-    <li>In JavaFX UI controls such as {@link javafx.scene.control.ComboBox ComboBox}\n-        and {@link javafx.scene.control.ChoiceBox ChoiceBox}<\/li>\n-  <\/ul>\n-*\/\n+ * This package is for standard {@link javafx.util.StringConverter string converters}\n+ * for JavaFX. Example use cases for these implementations include:\n+ *   <ul>\n+ *     <li><a href=\"..\/..\/..\/javafx\/beans\/binding\/package-summary.html\">JavaFX binding API<\/a>\n+ *         for converting Objects to and from Strings, when the binding requires this.<\/li>\n+ *     <li>In JavaFX UI controls such as {@link javafx.scene.control.ComboBox ComboBox}\n+ *         and {@link javafx.scene.control.ChoiceBox ChoiceBox}<\/li>\n+ *   <\/ul>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/package-info.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-<p>Contains various utilities and helper classes.<\/p>\n-*\/\n+ * <p>Contains various utilities and helper classes.<\/p>\n+ *\/\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,216 +27,216 @@\n-<P>The JavaFX User Interface provides a set of chart components that\n-are a very convenient way for data visualization. Application\n-developers can make use of these off-the-rack graphical charts\n-provided by the JavaFX runtime, to visualize a wide variety of data.<\/P>\n-<P>Commom types of charts such as {@link javafx.scene.chart.BarChart\n-Bar}, {@link javafx.scene.chart.LineChart Line}, {@link\n-javafx.scene.chart.AreaChart Area}, {@link\n-javafx.scene.chart.PieChart Pie}, {@link\n-javafx.scene.chart.ScatterChart Scatter} and {@link\n-javafx.scene.chart.BubbleChart Bubble} charts are provided. These\n-charts are easy to create and are customizable. JavaFX Charts API is\n-a visual centric API rather than model centric.\n-<\/P>\n-<P>JavaFX charts supports animation of chart components as well as\n-auto ranging of chart Axis.  In addition, as with other JavaFX UI\n-controls, chart visual components can be styled via CSS. Thus, there\n-are several public visual properties that can be styled via CSS. An\n-example is provided later in the document.\n-<\/P>\n-<P>Below is a table listing the existing Chart types and a brief\n-summary of their intended use.<\/P>\n-<TABLE>\n-<CAPTION>Table of Chart Types<\/CAPTION>\n-    <TR>\n-        <TH scope=\"col\">\n-            <P>Chart<\/P>\n-        <\/TH>\n-        <TH scope=\"col\">\n-            <P>Summary<\/P>\n-        <\/TH>\n-    <\/TR>\n-    <TR>\n-        <TH scope=\"row\">\n-            <P>{@link javafx.scene.chart.LineChart}<\/P>\n-        <\/TH>\n-        <TD>\n-            <P>Plots line between the data points in a series. Used usually to\n-            view data trends over time.<\/P>\n-        <\/TD>\n-    <\/TR>\n-    <TR>\n-        <TH scope=\"row\">\n-            <P>{@link javafx.scene.chart.AreaChart}<\/P>\n-        <\/TH>\n-        <TD>\n-            <P>Plots the area between the line that connects the data points\n-            and the axis. Good for comparing cumulated totals over time.<\/P>\n-        <\/TD>\n-    <\/TR>\n-    <TR>\n-        <TH scope=\"row\">\n-            <P>{@link javafx.scene.chart.BarChart}<\/P>\n-        <\/TH>\n-        <TD>\n-            <P>Plots rectangular bars with heights indicating data values they\n-            represent, and corresponding to the categories they belongs to.\n-            Used for displaying discontinuous \/ discrete data<\/P>\n-        <\/TD>\n-    <\/TR>\n-    <TR>\n-        <TH scope=\"row\">\n-            <P>{@link javafx.scene.chart.PieChart}<\/P>\n-        <\/TH>\n-        <TD>\n-            <P>Plots circular chart divided into segments with each segment\n-            representing a value as a proportion of the total. It looks like a\n-            Pie and hence the name\n-            <\/P>\n-        <\/TD>\n-    <\/TR>\n-    <TR>\n-        <TH scope=\"row\">\n-            <P>{@link javafx.scene.chart.BubbleChart}<\/P>\n-        <\/TH>\n-        <TD>\n-            <P>Plots bubbles for data points in a series. Each plotted entity\n-            depicts three parameters in a 2D chart and hence a unique chart\n-            type.<\/P>\n-        <\/TD>\n-    <\/TR>\n-    <TR>\n-        <TH scope=\"row\">\n-            <P>{@link javafx.scene.chart.ScatterChart}<\/P>\n-        <\/TH>\n-        <TD>\n-            <P>Plots symbols for the data points in a series. This type of\n-            chart is useful in viewing distribution of data and its\n-            corelation, if there is any clustering.<\/P>\n-        <\/TD>\n-    <\/TR>\n-<\/TABLE>\n-<P>The {@link javafx.scene.chart.Chart} is the baseclass for all\n-charts. It is responsible for drawing the background, frame, title\n-and legend. It can be extended to create custom chart types. The\n-{@link javafx.scene.chart.XYChart} is the baseclass for all two axis\n-charts and it extends from Chart class. It is mostly responsible for\n-drawing the two axis and the background of the chart plot. Most\n-charts extend from XYChart class except for PieChart which extends\n-from Chart class as it is not a two axis chart.\n-<\/P>\n-<P>The {@link javafx.scene.chart} package includes axis classes that\n-can be used when creating two axis charts. {@link\n-javafx.scene.chart.Axis} is the abstract base class of all chart\n-axis. {@link javafx.scene.chart.CategoryAxis} plots string categories\n-where each value is a unique category along the axis. {@link\n-javafx.scene.chart.NumberAxis} plots a range of numbers with major\n-tick marks every tickUnit.\n-<\/P>\n-<P>For Example BarChart plots data from a sequence of {@link\n-javafx.scene.chart.XYChart.Series} objects. Each series contains\n-{@link javafx.scene.chart.XYChart.Data} objects.\n-<\/P>\n-<pre>{@code\n-    \/\/ add data\n-    XYChart.Series<String,Number> series1 = new XYChart.Series<String,Number>();\n-    series1.setName(\"Data Series 1\");\n-    series1.getData().add(new XYChart.Data<String,Number>(\"2007\", 567));\n-}<\/pre>\n-<P>We can define more series objects similarly. Following code\n-snippet shows how to create a BarChart with 3 categories and its X\n-and Y axis:\n-<\/P>\n-<pre>{@code\n-    static String[] years = {\"2007\", \"2008\", \"2009\"};\n-    final CategoryAxis xAxis = new CategoryAxis();\n-    final NumberAxis yAxis = new NumberAxis();\n-    final BarChart<String,Number> bc = new BarChart<String,Number>(xAxis, yAxis);\n-    xAxis.setCategories(FXCollections.<String>observableArrayList(Arrays.asList(years)));\n-    bc.getData().addAll(series1, series2, series3);\n-}<\/pre>\n-<P>JavaFX charts lends itself very well for real time or dynamic\n-Charting (like online stocks, web traffic etc) from live data sets.\n-Here is an example of a dynamic chart created with simulated data. A\n-{@link javafx.animation.Timeline} is used to simulate dynamic data\n-for stock price variations over time(hours).\n-<\/P>\n-<pre><code>\n-    {@literal private XYChart.Series<Number,Number> hourDataSeries;}\n-    private NumberAxis xAxis;\n-    private Timeline animation;\n-    private double hours = 0;\n-    private double timeInHours = 0;\n-    private double prevY = 10;\n-    private double y = 10;\n-\n-    \/\/ timeline to add new data every 60th of a second\n-    animation = new Timeline();\n-    {@literal animation.getKeyFrames().add(new KeyFrame(Duration.millis(1000 \/ 60), new EventHandler<ActionEvent>()} {\n-        {@literal @Override public void handle(ActionEvent actionEvent)} {\n-            \/\/ 6 minutes data per frame\n-            {@literal for(int count = 0; count < 6; count++)} {\n-                nextTime();\n-                plotTime();\n-            }\n-        }\n-    }));\n-    animation.setCycleCount(Animation.INDEFINITE);\n-    xAxis = new NumberAxis(0, 24, 3);\n-    final NumberAxis yAxis = new NumberAxis(0, 100, 10);\n-    {@literal final LineChart<Number,Number> lc = new LineChart<Number,Number>(xAxis, yAxis)};\n-\n-    lc.setCreateSymbols(false);\n-    lc.setAnimated(false);\n-    lc.setLegendVisible(false);\n-    lc.setTitle(\"ACME Company Stock\");\n-\n-    xAxis.setLabel(\"Time\");\n-    xAxis.setForceZeroInRange(false);\n-    yAxis.setLabel(\"Share Price\");\n-    yAxis.setTickLabelFormatter(new NumberAxis.DefaultFormatter(yAxis, \"$\", null));\n-\n-    {@literal hourDataSeries = new XYChart.Series<Number,Number>();}\n-    hourDataSeries.setName(\"Hourly Data\");\n-    {@literal hourDataSeries.getData().add(new XYChart.Data<Number,Number>(timeInHours, prevY));}\n-    lc.getData().add(hourDataSeries);\n-\n-    private void nextTime() {\n-        if (minutes == 59) {\n-            hours++;\n-            minutes = 0;\n-        } else {\n-            minutes++;\n-        }\n-        timeInHours = hours + ((1d\/60d) * minutes);\n-    }\n-\n-    private void plotTime() {\n-        if ((timeInHours % 1) == 0) {\n-            \/\/ change of hour\n-            double oldY = y;\n-            y = prevY - 10 + (Math.random() * 20);\n-            prevY = oldY;\n-            {@literal while (y < 10 || y > 90) y = y - 10 + (Math.random() * 20);}\n-            {@literal hourDataSeries.getData().add(new XYChart.Data<Number, Number>(timeInHours, prevY));}\n-            \/\/ after 25hours delete old data\n-            {@literal if (timeInHours > 25) hourDataSeries.getData().remove(0)};\n-            \/\/ every hour after 24 move range 1 hour\n-            {@literal if (timeInHours > 24)} {\n-                xAxis.setLowerBound(xAxis.getLowerBound() + 1);\n-                xAxis.setUpperBound(xAxis.getUpperBound() + 1);\n-            }\n-        }\n-    }\n-<\/code><\/pre>\n-\n-<P>The start method needs to call animation,.play() to start the\n-simulated dynamic chart.<\/P>\n-<P>Please refer to javafx.scene.control package documentation on CSS\n-styling. An example for styling a Chart via CSS is as follows:- to\n-set the chart content background to a certain color:<\/P>\n-<P>.chart-content { -fx-background-color: cyan;}<\/P>\n-<P>Line Chart line color can be styled as follows:-<\/P>\n-<P>.chart-series-line { -fx-stroke: green; -fx-stroke-width: 4px;}<\/P>\n-<P STYLE=\"margin-bottom: 0in\"><BR>\n-<\/P>\n-*\/\n+ * <P>The JavaFX User Interface provides a set of chart components that\n+ * are a very convenient way for data visualization. Application\n+ * developers can make use of these off-the-rack graphical charts\n+ * provided by the JavaFX runtime, to visualize a wide variety of data.<\/P>\n+ * <P>Commom types of charts such as {@link javafx.scene.chart.BarChart\n+ * Bar}, {@link javafx.scene.chart.LineChart Line}, {@link\n+ * javafx.scene.chart.AreaChart Area}, {@link\n+ * javafx.scene.chart.PieChart Pie}, {@link\n+ * javafx.scene.chart.ScatterChart Scatter} and {@link\n+ * javafx.scene.chart.BubbleChart Bubble} charts are provided. These\n+ * charts are easy to create and are customizable. JavaFX Charts API is\n+ * a visual centric API rather than model centric.\n+ * <\/P>\n+ * <P>JavaFX charts supports animation of chart components as well as\n+ * auto ranging of chart Axis.  In addition, as with other JavaFX UI\n+ * controls, chart visual components can be styled via CSS. Thus, there\n+ * are several public visual properties that can be styled via CSS. An\n+ * example is provided later in the document.\n+ * <\/P>\n+ * <P>Below is a table listing the existing Chart types and a brief\n+ * summary of their intended use.<\/P>\n+ * <TABLE>\n+ * <CAPTION>Table of Chart Types<\/CAPTION>\n+ *     <TR>\n+ *         <TH scope=\"col\">\n+ *             <P>Chart<\/P>\n+ *         <\/TH>\n+ *         <TH scope=\"col\">\n+ *             <P>Summary<\/P>\n+ *         <\/TH>\n+ *     <\/TR>\n+ *     <TR>\n+ *         <TH scope=\"row\">\n+ *             <P>{@link javafx.scene.chart.LineChart}<\/P>\n+ *         <\/TH>\n+ *         <TD>\n+ *             <P>Plots line between the data points in a series. Used usually to\n+ *             view data trends over time.<\/P>\n+ *         <\/TD>\n+ *     <\/TR>\n+ *     <TR>\n+ *         <TH scope=\"row\">\n+ *             <P>{@link javafx.scene.chart.AreaChart}<\/P>\n+ *         <\/TH>\n+ *         <TD>\n+ *             <P>Plots the area between the line that connects the data points\n+ *             and the axis. Good for comparing cumulated totals over time.<\/P>\n+ *         <\/TD>\n+ *     <\/TR>\n+ *     <TR>\n+ *         <TH scope=\"row\">\n+ *             <P>{@link javafx.scene.chart.BarChart}<\/P>\n+ *         <\/TH>\n+ *         <TD>\n+ *             <P>Plots rectangular bars with heights indicating data values they\n+ *             represent, and corresponding to the categories they belongs to.\n+ *             Used for displaying discontinuous \/ discrete data<\/P>\n+ *         <\/TD>\n+ *     <\/TR>\n+ *     <TR>\n+ *         <TH scope=\"row\">\n+ *             <P>{@link javafx.scene.chart.PieChart}<\/P>\n+ *         <\/TH>\n+ *         <TD>\n+ *             <P>Plots circular chart divided into segments with each segment\n+ *             representing a value as a proportion of the total. It looks like a\n+ *             Pie and hence the name\n+ *             <\/P>\n+ *         <\/TD>\n+ *     <\/TR>\n+ *     <TR>\n+ *         <TH scope=\"row\">\n+ *             <P>{@link javafx.scene.chart.BubbleChart}<\/P>\n+ *         <\/TH>\n+ *         <TD>\n+ *             <P>Plots bubbles for data points in a series. Each plotted entity\n+ *             depicts three parameters in a 2D chart and hence a unique chart\n+ *             type.<\/P>\n+ *         <\/TD>\n+ *     <\/TR>\n+ *     <TR>\n+ *         <TH scope=\"row\">\n+ *             <P>{@link javafx.scene.chart.ScatterChart}<\/P>\n+ *         <\/TH>\n+ *         <TD>\n+ *             <P>Plots symbols for the data points in a series. This type of\n+ *             chart is useful in viewing distribution of data and its\n+ *             corelation, if there is any clustering.<\/P>\n+ *         <\/TD>\n+ *     <\/TR>\n+ * <\/TABLE>\n+ * <P>The {@link javafx.scene.chart.Chart} is the baseclass for all\n+ * charts. It is responsible for drawing the background, frame, title\n+ * and legend. It can be extended to create custom chart types. The\n+ * {@link javafx.scene.chart.XYChart} is the baseclass for all two axis\n+ * charts and it extends from Chart class. It is mostly responsible for\n+ * drawing the two axis and the background of the chart plot. Most\n+ * charts extend from XYChart class except for PieChart which extends\n+ * from Chart class as it is not a two axis chart.\n+ * <\/P>\n+ * <P>The {@link javafx.scene.chart} package includes axis classes that\n+ * can be used when creating two axis charts. {@link\n+ * javafx.scene.chart.Axis} is the abstract base class of all chart\n+ * axis. {@link javafx.scene.chart.CategoryAxis} plots string categories\n+ * where each value is a unique category along the axis. {@link\n+ * javafx.scene.chart.NumberAxis} plots a range of numbers with major\n+ * tick marks every tickUnit.\n+ * <\/P>\n+ * <P>For Example BarChart plots data from a sequence of {@link\n+ * javafx.scene.chart.XYChart.Series} objects. Each series contains\n+ * {@link javafx.scene.chart.XYChart.Data} objects.\n+ * <\/P>\n+ * <pre>{@code\n+ *     \/\/ add data\n+ *     XYChart.Series<String,Number> series1 = new XYChart.Series<String,Number>();\n+ *     series1.setName(\"Data Series 1\");\n+ *     series1.getData().add(new XYChart.Data<String,Number>(\"2007\", 567));\n+ * }<\/pre>\n+ * <P>We can define more series objects similarly. Following code\n+ * snippet shows how to create a BarChart with 3 categories and its X\n+ * and Y axis:\n+ * <\/P>\n+ * <pre>{@code\n+ *     static String[] years = {\"2007\", \"2008\", \"2009\"};\n+ *     final CategoryAxis xAxis = new CategoryAxis();\n+ *     final NumberAxis yAxis = new NumberAxis();\n+ *     final BarChart<String,Number> bc = new BarChart<String,Number>(xAxis, yAxis);\n+ *     xAxis.setCategories(FXCollections.<String>observableArrayList(Arrays.asList(years)));\n+ *     bc.getData().addAll(series1, series2, series3);\n+ * }<\/pre>\n+ * <P>JavaFX charts lends itself very well for real time or dynamic\n+ * Charting (like online stocks, web traffic etc) from live data sets.\n+ * Here is an example of a dynamic chart created with simulated data. A\n+ * {@link javafx.animation.Timeline} is used to simulate dynamic data\n+ * for stock price variations over time(hours).\n+ * <\/P>\n+ * <pre><code>\n+ *     {@literal private XYChart.Series<Number,Number> hourDataSeries;}\n+ *     private NumberAxis xAxis;\n+ *     private Timeline animation;\n+ *     private double hours = 0;\n+ *     private double timeInHours = 0;\n+ *     private double prevY = 10;\n+ *     private double y = 10;\n+ *\n+ *     \/\/ timeline to add new data every 60th of a second\n+ *     animation = new Timeline();\n+ *     {@literal animation.getKeyFrames().add(new KeyFrame(Duration.millis(1000 \/ 60), new EventHandler<ActionEvent>()} {\n+ *         {@literal @Override public void handle(ActionEvent actionEvent)} {\n+ *             \/\/ 6 minutes data per frame\n+ *             {@literal for(int count = 0; count < 6; count++)} {\n+ *                 nextTime();\n+ *                 plotTime();\n+ *             }\n+ *         }\n+ *     }));\n+ *     animation.setCycleCount(Animation.INDEFINITE);\n+ *     xAxis = new NumberAxis(0, 24, 3);\n+ *     final NumberAxis yAxis = new NumberAxis(0, 100, 10);\n+ *     {@literal final LineChart<Number,Number> lc = new LineChart<Number,Number>(xAxis, yAxis)};\n+ *\n+ *     lc.setCreateSymbols(false);\n+ *     lc.setAnimated(false);\n+ *     lc.setLegendVisible(false);\n+ *     lc.setTitle(\"ACME Company Stock\");\n+ *\n+ *     xAxis.setLabel(\"Time\");\n+ *     xAxis.setForceZeroInRange(false);\n+ *     yAxis.setLabel(\"Share Price\");\n+ *     yAxis.setTickLabelFormatter(new NumberAxis.DefaultFormatter(yAxis, \"$\", null));\n+ *\n+ *     {@literal hourDataSeries = new XYChart.Series<Number,Number>();}\n+ *     hourDataSeries.setName(\"Hourly Data\");\n+ *     {@literal hourDataSeries.getData().add(new XYChart.Data<Number,Number>(timeInHours, prevY));}\n+ *     lc.getData().add(hourDataSeries);\n+ *\n+ *     private void nextTime() {\n+ *         if (minutes == 59) {\n+ *             hours++;\n+ *             minutes = 0;\n+ *         } else {\n+ *             minutes++;\n+ *         }\n+ *         timeInHours = hours + ((1d\/60d) * minutes);\n+ *     }\n+ *\n+ *     private void plotTime() {\n+ *         if ((timeInHours % 1) == 0) {\n+ *             \/\/ change of hour\n+ *             double oldY = y;\n+ *             y = prevY - 10 + (Math.random() * 20);\n+ *             prevY = oldY;\n+ *             {@literal while (y < 10 || y > 90) y = y - 10 + (Math.random() * 20);}\n+ *             {@literal hourDataSeries.getData().add(new XYChart.Data<Number, Number>(timeInHours, prevY));}\n+ *             \/\/ after 25hours delete old data\n+ *             {@literal if (timeInHours > 25) hourDataSeries.getData().remove(0)};\n+ *             \/\/ every hour after 24 move range 1 hour\n+ *             {@literal if (timeInHours > 24)} {\n+ *                 xAxis.setLowerBound(xAxis.getLowerBound() + 1);\n+ *                 xAxis.setUpperBound(xAxis.getUpperBound() + 1);\n+ *             }\n+ *         }\n+ *     }\n+ * <\/code><\/pre>\n+ *\n+ * <P>The start method needs to call animation,.play() to start the\n+ * simulated dynamic chart.<\/P>\n+ * <P>Please refer to javafx.scene.control package documentation on CSS\n+ * styling. An example for styling a Chart via CSS is as follows:- to\n+ * set the chart content background to a certain color:<\/P>\n+ * <P>.chart-content { -fx-background-color: cyan;}<\/P>\n+ * <P>Line Chart line color can be styled as follows:-<\/P>\n+ * <P>.chart-series-line { -fx-stroke: green; -fx-stroke-width: 4px;}<\/P>\n+ * <P STYLE=\"margin-bottom: 0in\"><BR>\n+ * <\/P>\n+ *\/\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/chart\/package-info.java","additions":216,"deletions":216,"binary":false,"changes":432,"status":"modified"},{"patch":"@@ -27,12 +27,12 @@\n-    <p>The <code>javafx.scene.control.cell<\/code> package is where all cell-related\n-    classes are located, other than the core classes such as\n-    {@link javafx.scene.control.Cell Cell}, {@link javafx.scene.control.IndexedCell IndexedCell},\n-    {@link javafx.scene.control.ListCell ListCell}, {@link javafx.scene.control.TreeCell TreeCell},\n-    and {@link javafx.scene.control.TableCell TableCell}. At present this package\n-    is relatively bare, but it is where future cell-related classes will be located.<\/p>\n-\n-    <p>It is important to note that whilst most cells in this package are editable,\n-        for a cells editing functionality to be enabled it is required that all\n-        related classes have editing enabled. For example, in a TableView, both\n-        the TableView and the relevant TableColumn must have setEditing(true) called.\n-*\/\n+ * <p>The <code>javafx.scene.control.cell<\/code> package is where all cell-related\n+ * classes are located, other than the core classes such as\n+ * {@link javafx.scene.control.Cell Cell}, {@link javafx.scene.control.IndexedCell IndexedCell},\n+ * {@link javafx.scene.control.ListCell ListCell}, {@link javafx.scene.control.TreeCell TreeCell},\n+ * and {@link javafx.scene.control.TableCell TableCell}. At present this package\n+ * is relatively bare, but it is where future cell-related classes will be located.<\/p>\n+ *\n+ * <p>It is important to note that whilst most cells in this package are editable,\n+ *     for a cells editing functionality to be enabled it is required that all\n+ *     related classes have editing enabled. For example, in a TableView, both\n+ *     the TableView and the relevant TableColumn must have setEditing(true) called.\n+ *\/\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/cell\/package-info.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,125 +27,125 @@\n-    <p>The JavaFX User Interface Controls (UI Controls or just Controls) are\n-    specialized Nodes in the JavaFX Scenegraph especially suited for reuse in\n-    many different application contexts. They are designed to be highly\n-    customizable visually by designers and developers. They are designed to work\n-    well with layout systems. Examples of prominent controls include {@link javafx.scene.control.Button Button},\n-    {@link javafx.scene.control.Label Label}, {@link javafx.scene.control.ListView ListView}, and {@link javafx.scene.control.TextField TextField}.<\/p>\n-\n-    <p>Since Controls are {@link javafx.scene.Node Nodes} in the scenegraph,\n-    they can be freely mixed with {@link javafx.scene.Group Groups},\n-    {@link javafx.scene.image.ImageView Images},\n-    {@link javafx.scene.media.MediaView Media},\n-    {@link javafx.scene.text.Text Text}, and\n-    {@link javafx.scene.shape.Shape basic geometric shapes}. While\n-    writing new UI Controls is not trivial, using and styling them\n-    is very easy, especially to existing web developers.<\/p>\n-\n-    <p>The remainder of this document will describe the basic architecture of\n-    the JavaFX UI Control library, how to style existing controls, write custom\n-    skins, and how to use controls to build up more complicated user interfaces.\n-    <\/p>\n-\n-    <h2>Architecture<\/h2>\n-\n-    <p>Controls follow the classic MVC design pattern. The {@link javafx.scene.control.Control Control} is\n-    the \"model\". It contains both the state and the functions which manipulate\n-    that state. The Control class itself does not know how it is rendered or\n-    what the user interaction is. These tasks are delegated to the\n-    {@link javafx.scene.control.Skin Skin} (\"view\"), which may internally separate\n-    out the view and controller functionality into separate classes, although\n-    at present there is no public API for the \"controller\" aspect.<\/p>\n-\n-    <p>All Controls extend from the Control class, which is in turn a\n-    {@link javafx.scene.Parent Parent} node, and which is a\n-    {@link javafx.scene.Node Node}. Every Control has a reference to a single Skin, which\n-    is the view implementation for the Control. The Control delegates to the\n-    Skin the responsibility of computing the min, max, and pref sizes of the\n-    Control, the baseline offset, and hit testing (containment and\n-    intersection). It is also the responsibility of the Skin, or a delegate of\n-    the Skin, to implement and repond to all relevant key\n-    events which occur on the Control when it contains the focus.<\/p>\n-\n-    <h2>Control<\/h2>\n-\n-    <p>Control extends from {@link javafx.scene.Parent Parent}, and as such, is\n-    not a leaf node. From the perspective of a developer or designer the Control\n-    can be thought of as if it were a leaf node in many cases. For example, the\n-    developer or designer can consider a Button as if it were a Rectangle or\n-    other simple leaf node.<\/p>\n-\n-    <p>Since a Control is resizable, a Control\n-    will be <strong>auto-sized to its preferred size<\/strong> on each scenegraph\n-    pulse. Setting the width and height of the Control does not affect its\n-    preferred size. When used in a layout container, the layout constraints\n-    imposed upon the Control (or manually specified on the Control) will\n-    determine how it is positioned and sized.<\/p>\n-\n-    <p>The Skin of a Control can be changed at any time. Doing so will mark the\n-    Control as needing to be laid out since changing the Skin likely has changed\n-    the preferred size of the Control. If no Skin is specified at the time that\n-    the Control is created, then a default CSS-based skin will be provided for\n-    all of the built-in Controls.<\/p>\n-\n-    <p>Each Control may have an optional tooltip specified. The Tooltip is a\n-    Control which displays some (usually textual) information about the control\n-    to the user when the mouse hovers over the Control from some period of time.\n-    It can be styled from CSS the same as with other Controls.<\/p>\n-\n-    <p>{@code focusTraversable} is overridden in Control to be true by default,\n-    whereas with Node it is false by default. Controls which should not be\n-    focusable by default (such as Label) override this to be false.<\/p>\n-\n-    <p>The getMinWidth, getMinHeight, getPrefWidth, getPrefHeight, getMaxWidth,\n-    and getMaxHeight functions are delegated directly to the Skin. The\n-    baselineOffset method is delegated to the node of the skin. It is not\n-    recommended that subclasses alter these delegations.<\/p>\n-\n-    <h2>Styling Controls<\/h2>\n-\n-    <p>There are two methods for customizing the look of a Control. The most\n-    difficult and yet most flexible approach is to write a new Skin for the\n-    Control which precisely implements the visuals which you\n-    desire for the Control. Consult the Skin documentation for more details.<\/p>\n-\n-    <p>The easiest and yet very powerful method for styling the built in\n-    Controls is by using CSS. Please note that in this release the following\n-    CSS description applies only to the default Skins provided for the built\n-    in Controls. Subsequent releases will make this generally available for\n-    any custom third party Controls which desire to take advantage of these\n-    CSS capabilities.<\/p>\n-\n-    <p>Each of the default Skins for the built in Controls is comprised of\n-    multiple individually styleable areas or regions. This is much like an\n-    HTML page which is made up of {@literal <div>'s} and then styled from\n-    CSS. Each individual region may be drawn with backgrounds, borders, images,\n-    padding, margins, and so on. The JavaFX CSS support includes the ability\n-    to have multiple backgrounds and borders, and to derive colors. These\n-    capabilities make it extremely easy to alter the look of Controls in\n-    JavaFX from CSS.<\/p>\n-\n-    <p>The colors used for drawing the default Skins of the built in Controls\n-    are all derived from a base color, an accent color and a background\n-    color. Simply by modifying the base color for a Control you can alter the\n-    derived gradients and create Buttons or other Controls which visually fit\n-    in with the default Skins but visually stand out.<\/p>\n-\n-    <p>As with all other Nodes in the scenegraph, Controls can be styled by\n-    using an external stylesheet, or by specifying the style directly on the\n-    Control. Although for examples it is easier to express and understand by\n-    specifying the style directly on the Node, it is recommended to use an\n-    external stylesheet and use either the styleClass or id of the Control,\n-    just as you would use the \"class\" or id of an HTML element with HTML\n-    CSS.<\/p>\n-\n-    <p>Each UI Control specifies a styleClass which may be used to\n-    style controls from an external stylesheet. For example, the Button\n-    control is given the \"button\" CSS style class. The CSS style class names\n-    are hyphen-separated lower case as opposed to camel case, otherwise, they\n-    are exactly the same. For example, Button is \"button\", RadioButton is\n-    \"radio-button\", Tooltip is \"tooltip\" and so on.<\/p>\n-\n-    <p>The class documentation for each Control defines the default Skin\n-    regions which can be styled. For further information regarding the CSS\n-    capabilities provided with JavaFX, see the\n-    <a href=\"..\/..\/..\/..\/javafx.graphics\/javafx\/scene\/doc-files\/cssref.html\">CSS Reference Guide<\/a>.<\/p>\n-*\/\n+ * <p>The JavaFX User Interface Controls (UI Controls or just Controls) are\n+ * specialized Nodes in the JavaFX Scenegraph especially suited for reuse in\n+ * many different application contexts. They are designed to be highly\n+ * customizable visually by designers and developers. They are designed to work\n+ * well with layout systems. Examples of prominent controls include {@link javafx.scene.control.Button Button},\n+ * {@link javafx.scene.control.Label Label}, {@link javafx.scene.control.ListView ListView}, and {@link javafx.scene.control.TextField TextField}.<\/p>\n+ *\n+ * <p>Since Controls are {@link javafx.scene.Node Nodes} in the scenegraph,\n+ * they can be freely mixed with {@link javafx.scene.Group Groups},\n+ * {@link javafx.scene.image.ImageView Images},\n+ * {@link javafx.scene.media.MediaView Media},\n+ * {@link javafx.scene.text.Text Text}, and\n+ * {@link javafx.scene.shape.Shape basic geometric shapes}. While\n+ * writing new UI Controls is not trivial, using and styling them\n+ * is very easy, especially to existing web developers.<\/p>\n+ *\n+ * <p>The remainder of this document will describe the basic architecture of\n+ * the JavaFX UI Control library, how to style existing controls, write custom\n+ * skins, and how to use controls to build up more complicated user interfaces.\n+ * <\/p>\n+ *\n+ * <h2>Architecture<\/h2>\n+ *\n+ * <p>Controls follow the classic MVC design pattern. The {@link javafx.scene.control.Control Control} is\n+ * the \"model\". It contains both the state and the functions which manipulate\n+ * that state. The Control class itself does not know how it is rendered or\n+ * what the user interaction is. These tasks are delegated to the\n+ * {@link javafx.scene.control.Skin Skin} (\"view\"), which may internally separate\n+ * out the view and controller functionality into separate classes, although\n+ * at present there is no public API for the \"controller\" aspect.<\/p>\n+ *\n+ * <p>All Controls extend from the Control class, which is in turn a\n+ * {@link javafx.scene.Parent Parent} node, and which is a\n+ * {@link javafx.scene.Node Node}. Every Control has a reference to a single Skin, which\n+ * is the view implementation for the Control. The Control delegates to the\n+ * Skin the responsibility of computing the min, max, and pref sizes of the\n+ * Control, the baseline offset, and hit testing (containment and\n+ * intersection). It is also the responsibility of the Skin, or a delegate of\n+ * the Skin, to implement and repond to all relevant key\n+ * events which occur on the Control when it contains the focus.<\/p>\n+ *\n+ * <h2>Control<\/h2>\n+ *\n+ * <p>Control extends from {@link javafx.scene.Parent Parent}, and as such, is\n+ * not a leaf node. From the perspective of a developer or designer the Control\n+ * can be thought of as if it were a leaf node in many cases. For example, the\n+ * developer or designer can consider a Button as if it were a Rectangle or\n+ * other simple leaf node.<\/p>\n+ *\n+ * <p>Since a Control is resizable, a Control\n+ * will be <strong>auto-sized to its preferred size<\/strong> on each scenegraph\n+ * pulse. Setting the width and height of the Control does not affect its\n+ * preferred size. When used in a layout container, the layout constraints\n+ * imposed upon the Control (or manually specified on the Control) will\n+ * determine how it is positioned and sized.<\/p>\n+ *\n+ * <p>The Skin of a Control can be changed at any time. Doing so will mark the\n+ * Control as needing to be laid out since changing the Skin likely has changed\n+ * the preferred size of the Control. If no Skin is specified at the time that\n+ * the Control is created, then a default CSS-based skin will be provided for\n+ * all of the built-in Controls.<\/p>\n+ *\n+ * <p>Each Control may have an optional tooltip specified. The Tooltip is a\n+ * Control which displays some (usually textual) information about the control\n+ * to the user when the mouse hovers over the Control from some period of time.\n+ * It can be styled from CSS the same as with other Controls.<\/p>\n+ *\n+ * <p>{@code focusTraversable} is overridden in Control to be true by default,\n+ * whereas with Node it is false by default. Controls which should not be\n+ * focusable by default (such as Label) override this to be false.<\/p>\n+ *\n+ * <p>The getMinWidth, getMinHeight, getPrefWidth, getPrefHeight, getMaxWidth,\n+ * and getMaxHeight functions are delegated directly to the Skin. The\n+ * baselineOffset method is delegated to the node of the skin. It is not\n+ * recommended that subclasses alter these delegations.<\/p>\n+ *\n+ * <h2>Styling Controls<\/h2>\n+ *\n+ * <p>There are two methods for customizing the look of a Control. The most\n+ * difficult and yet most flexible approach is to write a new Skin for the\n+ * Control which precisely implements the visuals which you\n+ * desire for the Control. Consult the Skin documentation for more details.<\/p>\n+ *\n+ * <p>The easiest and yet very powerful method for styling the built in\n+ * Controls is by using CSS. Please note that in this release the following\n+ * CSS description applies only to the default Skins provided for the built\n+ * in Controls. Subsequent releases will make this generally available for\n+ * any custom third party Controls which desire to take advantage of these\n+ * CSS capabilities.<\/p>\n+ *\n+ * <p>Each of the default Skins for the built in Controls is comprised of\n+ * multiple individually styleable areas or regions. This is much like an\n+ * HTML page which is made up of {@literal <div>'s} and then styled from\n+ * CSS. Each individual region may be drawn with backgrounds, borders, images,\n+ * padding, margins, and so on. The JavaFX CSS support includes the ability\n+ * to have multiple backgrounds and borders, and to derive colors. These\n+ * capabilities make it extremely easy to alter the look of Controls in\n+ * JavaFX from CSS.<\/p>\n+ *\n+ * <p>The colors used for drawing the default Skins of the built in Controls\n+ * are all derived from a base color, an accent color and a background\n+ * color. Simply by modifying the base color for a Control you can alter the\n+ * derived gradients and create Buttons or other Controls which visually fit\n+ * in with the default Skins but visually stand out.<\/p>\n+ *\n+ * <p>As with all other Nodes in the scenegraph, Controls can be styled by\n+ * using an external stylesheet, or by specifying the style directly on the\n+ * Control. Although for examples it is easier to express and understand by\n+ * specifying the style directly on the Node, it is recommended to use an\n+ * external stylesheet and use either the styleClass or id of the Control,\n+ * just as you would use the \"class\" or id of an HTML element with HTML\n+ * CSS.<\/p>\n+ *\n+ * <p>Each UI Control specifies a styleClass which may be used to\n+ * style controls from an external stylesheet. For example, the Button\n+ * control is given the \"button\" CSS style class. The CSS style class names\n+ * are hyphen-separated lower case as opposed to camel case, otherwise, they\n+ * are exactly the same. For example, Button is \"button\", RadioButton is\n+ * \"radio-button\", Tooltip is \"tooltip\" and so on.<\/p>\n+ *\n+ * <p>The class documentation for each Control defines the default Skin\n+ * regions which can be styled. For further information regarding the CSS\n+ * capabilities provided with JavaFX, see the\n+ * <a href=\"..\/..\/..\/..\/javafx.graphics\/javafx\/scene\/doc-files\/cssref.html\">CSS Reference Guide<\/a>.<\/p>\n+ *\/\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/package-info.java","additions":125,"deletions":125,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-  <p>The javafx.scene.control.skin package is where the skin classes, typically\n-    one for each UI control, are located<\/p>\n-*\/\n+ * <p>The javafx.scene.control.skin package is where the skin classes, typically\n+ *   one for each UI control, are located<\/p>\n+ *\/\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-<p>Contains classes for loading an object hierarchy from markup. For more\n-information, see the <a href=\"doc-files\/introduction_to_fxml.html\">Introduction\n-to FXML<\/a> document.<\/p>\n-*\/\n+ * <p>Contains classes for loading an object hierarchy from markup. For more\n+ * information, see the <a href=\"doc-files\/introduction_to_fxml.html\">Introduction\n+ * to FXML<\/a> document.<\/p>\n+ *\/\n","filename":"modules\/javafx.fxml\/src\/main\/java\/javafx\/fxml\/package-info.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,12 +27,12 @@\n-Provides image loading capability for Java FX.\n-\n-<p>A plugin for loading a given format is added by creating an\n-<code>ImageFormatDescription<\/code> to provide the principal attributes for\n-recognizing images stored in the format, an <code>ImageLoader<\/code> which\n-performs the actual loading of the image data and metadata, and an\n-<code>ImageLoaderFactory<\/code> which is able to create an\n-<code>ImageLoader<\/code> for a stream of image data stored in the format.\n-The <code>ImageLoaderFactory<\/code> is registered with the\n-<code>ImageStorage<\/code> object which manages all <code>ImageLoader<\/code>s\n-and which also supplies convenience loading methods for application use.\n-*\/\n+ * Provides image loading capability for Java FX.\n+ *\n+ * <p>A plugin for loading a given format is added by creating an\n+ * <code>ImageFormatDescription<\/code> to provide the principal attributes for\n+ * recognizing images stored in the format, an <code>ImageLoader<\/code> which\n+ * performs the actual loading of the image data and metadata, and an\n+ * <code>ImageLoaderFactory<\/code> which is able to create an\n+ * <code>ImageLoader<\/code> for a stream of image data stored in the format.\n+ * The <code>ImageLoaderFactory<\/code> is registered with the\n+ * <code>ImageStorage<\/code> object which manages all <code>ImageLoader<\/code>s\n+ * and which also supplies convenience loading methods for application use.\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/iio\/package-info.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-<p>Provides the set of classes for ease of use transition based animations.<\/p>\n-<p>It offers a simple framework for incorporating animations onto an internal\n-{@link javafx.animation.Timeline Timeline}. It also provides high level constructs to compose the effects\n-of multiple animations.<\/p>\n-*\/\n+ * <p>Provides the set of classes for ease of use transition based animations.<\/p>\n+ * <p>It offers a simple framework for incorporating animations onto an internal\n+ * {@link javafx.animation.Timeline Timeline}. It also provides high level constructs to compose the effects\n+ * of multiple animations.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/animation\/package-info.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-<p>Provides the application life-cycle classes.<\/p>\n-<p>The\n-<a href=\"Application.html\">Application<\/a> class is the primary class from\n-which JavaFX applications extend.<\/p>\n-*\/\n+ * <p>Provides the application life-cycle classes.<\/p>\n+ * <p>The\n+ * <a href=\"Application.html\">Application<\/a> class is the primary class from\n+ * which JavaFX applications extend.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/application\/package-info.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,7 +27,7 @@\n-<p>Provides the set of classes for javafx.concurrent.<\/p>\n-<p>This package provides the ability to run application code on threads other\n-than the JavaFX event dispatch thread. The ability to control the execution\n-and track the progress of the application code is also provided.<\/p>\n-\n-<!--Things to document: use of non-daemon threads, auto-restarting a Service.-->\n-*\/\n+ * <p>Provides the set of classes for javafx.concurrent.<\/p>\n+ * <p>This package provides the ability to run application code on threads other\n+ * than the JavaFX event dispatch thread. The ability to control the execution\n+ * and track the progress of the application code is also provided.<\/p>\n+ *\n+ * <!--Things to document: use of non-daemon threads, auto-restarting a Service.-->\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/concurrent\/package-info.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-<p>Provides various {@link javafx.css.StyleConverter StyleConverter} classes\n-that convert CSS parsed values.<\/p>\n-*\/\n+ * <p>Provides various {@link javafx.css.StyleConverter StyleConverter} classes\n+ * that convert CSS parsed values.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/converter\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,46 +27,44 @@\n-\n-<p>Provides API for making properties styleable via CSS and for supporting\n-pseudo-class state.<\/p>\n-\n-<p>The JavaFX Scene Graph provides the facility to style nodes using\n-CSS (Cascading Style Sheets).\n-The {@link javafx.scene.Node Node} class contains {@code id}, {@code styleClass}, and\n-{@code style} variables which are used by CSS selectors to find nodes\n-to which styles should be applied. The {@link javafx.scene.Scene Scene} class and\n-{@link javafx.scene.Parent Parent} class contain a\n-the {@code stylesheets} variable which is a list of URLs that\n-reference CSS style sheets that are to be applied to the nodes within\n-that scene or parent.\n-<p>The primary classes in this package are:<\/p>\n-\n-<dl>\n-\n-<dt>{@link javafx.css.CssMetaData CssMetaData}<\/dt>\n-<dd>Defines the CSS property and provides a link back to the\n-    {@link javafx.css.StyleableProperty StyleableProperty}.\n-    By convention, classes that have CssMetaData implement a\n-    {@code public static List<CssMetaData<? extends Styleable>> getClassCssMetaData()} method that\n-    allows other classes to include CssMetaData from an inherited class. The\n-    method {@link javafx.scene.Node#getCssMetaData() getCssMetaData()} should\n-    be overridden to return {@code getClassCssMetaData()}. The CSS implementation\n-    frequently calls {@code getCssMetaData()}. It is strongly recommended that\n-    the returned list be a {@code final static}.<\/dd>\n-\n-<dt>{@link javafx.css.StyleableProperty StyleableProperty}<\/dt>\n-<dd>Defines the interface that the CSS implementation uses to set values on a\n-    property and provides a link back to the {@code CssMetaData} that\n-    corresponds to the property. The {@link javafx.css.StyleablePropertyFactory StyleablePropertyFactory}\n-    greatly simplifies creating a StyleableProperty and its corresponding CssMetaData.<\/dd>\n-\n-<dt>{@link javafx.css.PseudoClass PseudoClass}<\/dt>\n-<dd>Defines a pseudo-class which can be set or cleared via the method\n-    {@link javafx.scene.Node#pseudoClassStateChanged(javafx.css.PseudoClass, boolean)\n-    pseudoClassStateChanged}. <\/dd>\n-\n-<\/dl>\n-\n-<p>For further information about CSS, how to apply CSS styles\n-to nodes, and what properties are available for styling, see the\n-<a href=\"..\/scene\/doc-files\/cssref.html\">CSS Reference Guide<\/a>.<\/p>\n-\n-*\/\n+ * <p>Provides API for making properties styleable via CSS and for supporting\n+ * pseudo-class state.<\/p>\n+ *\n+ * <p>The JavaFX Scene Graph provides the facility to style nodes using\n+ * CSS (Cascading Style Sheets).\n+ * The {@link javafx.scene.Node Node} class contains {@code id}, {@code styleClass}, and\n+ * {@code style} variables which are used by CSS selectors to find nodes\n+ * to which styles should be applied. The {@link javafx.scene.Scene Scene} class and\n+ * {@link javafx.scene.Parent Parent} class contain a\n+ * the {@code stylesheets} variable which is a list of URLs that\n+ * reference CSS style sheets that are to be applied to the nodes within\n+ * that scene or parent.\n+ * <p>The primary classes in this package are:<\/p>\n+ *\n+ * <dl>\n+ *\n+ * <dt>{@link javafx.css.CssMetaData CssMetaData}<\/dt>\n+ * <dd>Defines the CSS property and provides a link back to the\n+ *     {@link javafx.css.StyleableProperty StyleableProperty}.\n+ *     By convention, classes that have CssMetaData implement a\n+ *     {@code public static List<CssMetaData<? extends Styleable>> getClassCssMetaData()} method that\n+ *     allows other classes to include CssMetaData from an inherited class. The\n+ *     method {@link javafx.scene.Node#getCssMetaData() getCssMetaData()} should\n+ *     be overridden to return {@code getClassCssMetaData()}. The CSS implementation\n+ *     frequently calls {@code getCssMetaData()}. It is strongly recommended that\n+ *     the returned list be a {@code final static}.<\/dd>\n+ *\n+ * <dt>{@link javafx.css.StyleableProperty StyleableProperty}<\/dt>\n+ * <dd>Defines the interface that the CSS implementation uses to set values on a\n+ *     property and provides a link back to the {@code CssMetaData} that\n+ *     corresponds to the property. The {@link javafx.css.StyleablePropertyFactory StyleablePropertyFactory}\n+ *     greatly simplifies creating a StyleableProperty and its corresponding CssMetaData.<\/dd>\n+ *\n+ * <dt>{@link javafx.css.PseudoClass PseudoClass}<\/dt>\n+ * <dd>Defines a pseudo-class which can be set or cleared via the method\n+ *     {@link javafx.scene.Node#pseudoClassStateChanged(javafx.css.PseudoClass, boolean)\n+ *     pseudoClassStateChanged}. <\/dd>\n+ *\n+ * <\/dl>\n+ *\n+ * <p>For further information about CSS, how to apply CSS styles\n+ * to nodes, and what properties are available for styling, see the\n+ * <a href=\"..\/scene\/doc-files\/cssref.html\">CSS Reference Guide<\/a>.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/package-info.java","additions":44,"deletions":46,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-<p>Provides the set of 2D classes for defining and performing operations on\n-objects related to two-dimensional geometry. <\/p>\n-*\/\n+ * <p>Provides the set of 2D classes for defining and performing operations on\n+ * objects related to two-dimensional geometry. <\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n-\n-<p>Provides the public classes for the JavaFX Printing API.\n-*\/\n+ * <p>Provides the public classes for the JavaFX Printing API.\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/print\/package-info.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-<p>Provides the set of classes for canvas, an immediate mode style of rendering API.<\/p>\n-*\/\n+ * <p>Provides the set of classes for canvas, an immediate mode style of rendering API.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/canvas\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,17 +27,17 @@\n-<p>Provides the set of classes for attaching graphical filter effects to JavaFX Scene Graph Nodes.<\/p>\n-<p>An effect is a graphical algorithm that produces an image, typically\n-   as a modification of a source image.\n-   An effect can be associated with a scene graph {@code Node} by setting the\n-   {@link javafx.scene.Node#effectProperty effect}\n-   attribute.\n-   Some effects change the color properties of the source pixels\n-   (such as {@link javafx.scene.effect.ColorAdjust}),\n-   others combine multiple images together (such as\n-   {@link javafx.scene.effect.Blend Blend}),\n-   while still others warp or move the pixels of the source image around (such as\n-   {@link javafx.scene.effect.DisplacementMap DisplacementMap} or {@link javafx.scene.effect.PerspectiveTransform PerspectiveTransform}).\n-   All effects have at least one input defined and the input can be set\n-   to another effect to chain the effects together and combine their\n-   results, or it can be left unspecified in which case the effect will\n-   operate on a graphical rendering of the node it is attached to.<\/p>\n-*\/\n+ * <p>Provides the set of classes for attaching graphical filter effects to JavaFX Scene Graph Nodes.<\/p>\n+ * <p>An effect is a graphical algorithm that produces an image, typically\n+ *    as a modification of a source image.\n+ *    An effect can be associated with a scene graph {@code Node} by setting the\n+ *    {@link javafx.scene.Node#effectProperty effect}\n+ *    attribute.\n+ *    Some effects change the color properties of the source pixels\n+ *    (such as {@link javafx.scene.effect.ColorAdjust}),\n+ *    others combine multiple images together (such as\n+ *    {@link javafx.scene.effect.Blend Blend}),\n+ *    while still others warp or move the pixels of the source image around (such as\n+ *    {@link javafx.scene.effect.DisplacementMap DisplacementMap} or {@link javafx.scene.effect.PerspectiveTransform PerspectiveTransform}).\n+ *    All effects have at least one input defined and the input can be set\n+ *    to another effect to chain the effects together and combine their\n+ *    results, or it can be left unspecified in which case the effect will\n+ *    operate on a graphical rendering of the node it is attached to.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/effect\/package-info.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,15 +27,14 @@\n-<p>Provides the set of classes for loading and displaying images.<\/p>\n-<ul>\n-    <li> The {@link javafx.scene.image.Image} class is used to load images\n-    (synchronously or asynchronously). Image can be resized as it is loaded and\n-    the resizing can be performed with specified filtering quality and\n-    with an option of preserving image's original aspect ratio.\n-\n-    <li> The {@link javafx.scene.image.ImageView} is a {@code Node} used\n-    for displaying images loaded with {@code Image} class.\n-    It allows displaying a dynamically scaled and\/or cropped view of the source\n-    image. The scaling can be performed with specified filtering quality and\n-    with an option of preserving image's original aspect ratio.\n-<\/ul>\n-\n-*\/\n+ * <p>Provides the set of classes for loading and displaying images.<\/p>\n+ * <ul>\n+ *     <li> The {@link javafx.scene.image.Image} class is used to load images\n+ *     (synchronously or asynchronously). Image can be resized as it is loaded and\n+ *     the resizing can be performed with specified filtering quality and\n+ *     with an option of preserving image's original aspect ratio.\n+ *\n+ *     <li> The {@link javafx.scene.image.ImageView} is a {@code Node} used\n+ *     for displaying images loaded with {@code Image} class.\n+ *     It allows displaying a dynamically scaled and\/or cropped view of the source\n+ *     image. The scaling can be performed with specified filtering quality and\n+ *     with an option of preserving image's original aspect ratio.\n+ * <\/ul>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/image\/package-info.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-<p>Provides the set of classes for mouse and keyboard input event handling.<\/p>\n-*\/\n+ * <p>Provides the set of classes for mouse and keyboard input event handling.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/input\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,173 +27,172 @@\n-<p>\n-Provides classes to support user interface layout.\n-Each layout pane class supports a different layout strategy for its children\n-and applications may nest these layout panes to achieve the needed layout structure\n-in the user interface.  Once a node is added to one of the layout panes,\n-the pane will automatically manage the layout for the node, so the application\n-should not position or resize the node directly; see &quot;Node Resizability&quot;\n-for more details.\n-<\/p>\n-\n-<h2>Scene Graph Layout Mechanism<\/h2>\n-<p>\n-The scene graph layout mechanism is driven automatically by the system once\n-the application creates and displays a {@link javafx.scene.Scene Scene}.\n-The scene graph detects dynamic node changes which affect layout (such as a\n-change in size or content) and calls {@code requestLayout()}, which marks that\n-branch as needing layout so that on the next pulse, a top-down layout pass is\n-executed on that branch by invoking {@code layout()} on that branch's root.\n-During that layout pass, the {@code layoutChildren()} callback method will\n-be called on each parent to layout its children.  This mechanism is designed\n-to maximize layout efficiency by ensuring multiple layout requests are coalesced\n-and processed in a single pass rather than executing re-layout on on each minute\n-change. Therefore, applications should not invoke layout directly on nodes.\n-<\/p>\n-\n-\n-<h2>Node Resizability<\/h2>\n-<p>\n-The scene graph supports both resizable and non-resizable node classes.  The\n-{@code isResizable()} method on {@link javafx.scene.Node Node} returns whether a\n-given node is resizable or not.  {@literal A resizable node class is one which supports a range\n-of acceptable sizes (minimum <= preferred <= maximum), allowing its parent to resize\n-it within that range during layout, given the parent's own layout policy and the\n-layout needs of sibling nodes.}  Node supports the following methods for layout code\n-to determine a node's resizable range:\n-<pre><code>\n-    public Orientation getContentBias()\n-    public double minWidth(double height)\n-    public double minHeight(double width)\n-    public double prefWidth(double height)\n-    public double prefHeight(double width)\n-    public double maxWidth(double height)\n-    public double maxHeight(double width)\n-<\/code><\/pre>\n-<p>\n-Non-resizable node classes, on the other hand, do <em>not<\/em> have a consistent\n-resizing API and so are <em>not<\/em> resized by their parents during layout.\n-Applications must establish the size of non-resizable nodes by setting\n-appropriate properties on each instance. These classes return their current layout bounds for\n-min, pref, and max, and the {@code resize()} method becomes a no-op.<\/p>\n-<p>\n-<br>Resizable classes: {@link javafx.scene.layout.Region Region}, {@link javafx.scene.control.Control Control}, {@link javafx.scene.web.WebView WebView}\n-<br>Non-Resizable classes: {@link javafx.scene.Group Group}, {@link javafx.scene.shape.Shape Shape}, {@link javafx.scene.text.Text Text}\n-<\/p>\n-<p>\n-For example, a Button control (resizable) computes its min, pref, and max sizes\n-which its parent will use to resize it during layout, so the application only needs\n-to configure its content and properties:\n-\n-<pre><code>    Button button = new Button(\"Apply\");\n-<\/code><\/pre>\n-However, a Circle (non-resizable) cannot be resized by its parent, so the application\n-needs to set appropriate geometric properties which determine its size:\n-\n-<pre><code>    Circle circle = new Circle();\n-    circle.setRadius(50);\n-<\/code><\/pre>\n-\n-<h2>Resizable Range<\/h2>\n-\n-Each resizable node class computes an appropriate min, pref, and max size based\n-on its own content and property settings (it's 'intrinsic' size range).\n-Some resizable classes have an unbounded max size (all layout panes) while\n-others have a max size that is clamped by default to their preferred size (buttons)\n-(See individual class documentation for the default range of each class).\n-While these defaults are geared towards common usage, applications often need\n-to explicitly alter or set a node's resizable range to achieve certain layouts.\n-The resizable classes provide properties for overriding the min, pref and max\n-sizes for this purpose.\n-<p>For example, to override the preferred size of a ListView:<\/p>\n-<pre><code>    listview.setPrefSize(200,300);\n-<\/code><\/pre>\n-<p>Or, to change the max width of a button so it will resize wider to fill a space:\n-<pre><code>    button.setMaxWidth(Double.MAX_VALUE);\n-<\/code><\/pre>\n-<p>For the inverse case, where the application needs to clamp the node's min\n-or max size to its preferred:\n-<pre><code>    listview.setMaxSize(Region.USE_PREF_SIZE, Region.USE_PREF_SIZE);\n-<\/code><\/pre>\n-And finally, if the application needs to restore the intrinsically computed values:\n-<pre><code>    listview.setPrefSize(Region.USE_COMPUTED_SIZE, Region.USE_COMPUTED_SIZE);\n-<\/code><\/pre>\n-\n-<h2>CSS Styling and Node Sizing<\/h2>\n-\n-Applications cannot reliably query the bounds of a resizable node until it has been\n-added to a scene because the size of that node may be dependent on CSS.  This is\n-because CSS is used to style many aspects of a node which affect it's preferred size\n-(font, padding, borders, etc) and so the node cannot be laid out (resized) until\n-CSS has been applied and the parent can access valid size range metrics.\n-This is always true for Controls (and any panes that contain them), because they\n-rely on CSS for their default style, even if no user-level style sheets have been set.\n-Stylesheets are set at the Scene level, which means that styles cannot even\n-be determined until a node's enclosing scene has been initialized. Once a Scene\n-is initialized, CSS is applied to nodes on each pulse (when needed) just before\n-the layout pass.\n-\n-\n-\n-<h2>Visual Bounds vs. Layout Bounds<\/h2>\n-\n-A graphically rich user interface often has the need to make a distinction between\n-a node's visual bounds and the bounds used for layout.  For example, the tight visual\n-bounds of a Text node's character glyphs would not work for layout, as the text\n-would not be aligned and leading\/trailing whitespace would be discounted.  Also,\n-sometimes applications wish to apply affects and transforms to nodes without\n-disturbing the surrounding layout (bouncing, jiggling, drop shadows, glows, etc).\n-To support this distinction in the scene graph, {@link javafx.scene.Node Node}\n-provides the {@code layoutBounds} property to define the 'logical' bounds\n-of the node for layout and {@code boundsInParent} to define the visual bounds\n-once all effects, clipping, and transforms have been applied.\n-\n-<p>These two bounds properties will often differ for a given node and\n-{@code layoutBounds} is computed differently depending on the node class:\n-\n-<table border=\"1\">\n- <caption>Bounds Computation Table<\/caption>\n- <thead>\n-     <tr>\n-         <th scope=\"col\">Node Type<\/th>\n-         <th scope=\"col\">Layout Bounds<\/th>\n-     <\/tr>\n- <\/thead>\n- <tbody>\n-     <tr>\n-         <th scope=\"row\">{@link javafx.scene.shape.Shape Shape},{@link javafx.scene.image.ImageView ImageView}<\/th>\n-         <td>Includes geometric bounds (geometry plus stroke).\n-             Does NOT include effect, clip, or any transforms.\n-         <\/td>\n-     <\/tr>\n-     <tr>\n-         <th scope=\"row\">{@link javafx.scene.text.Text Text}<\/th>\n-         <td>logical bounds based on the font height and content width, including white space.\n-             can be configured to be tight bounds around chars glyphs by setting {@code boundsType}.\n-             Does NOT include effect, clip, or any transforms.\n-         <\/td>\n-     <\/tr>\n-     <tr>\n-         <th scope=\"row\">{@link javafx.scene.layout.Region Region}, {@link javafx.scene.control.Control Control}, {@link javafx.scene.web.WebView WebView}<\/th>\n-         <td>always {@code [0,0 width x height]} regardless of visual bounds,\n-             which might be larger or smaller than layout bounds.\n-         <\/td>\n-     <\/tr>\n-     <tr>\n-         <th scope=\"row\">{@link javafx.scene.Group Group}<\/th>\n-         <td>Union of all visible children's visual bounds ({@code boundsInParent})\n-             Does NOT include effect, clip, or transforms set directly on group,\n-             however DOES include effect, clip, transforms set on individual children since\n-             those are included in the child's {@code boundsInParent}.\n-         <\/td>\n-     <\/tr>\n- <\/tbody>\n-<\/table>\n-<p>\n-So for example, if a {@link javafx.scene.effect.DropShadow DropShadow} is added to a shape,\n-that shadow will <em>not<\/em>  be factored into layout by default.  Or, if a\n-{@link javafx.animation.ScaleTransition ScaleTransition} is used to\n-pulse the size of a button, that pulse animation will not disturb layout around\n-that button.  If an application wishes to have the effect, clip, or transform\n-factored into the layout of a node, it should wrap that node in a Group.\n-<\/p>\n-\n-*\/\n+ * <p>\n+ * Provides classes to support user interface layout.\n+ * Each layout pane class supports a different layout strategy for its children\n+ * and applications may nest these layout panes to achieve the needed layout structure\n+ * in the user interface.  Once a node is added to one of the layout panes,\n+ * the pane will automatically manage the layout for the node, so the application\n+ * should not position or resize the node directly; see &quot;Node Resizability&quot;\n+ * for more details.\n+ * <\/p>\n+ *\n+ * <h2>Scene Graph Layout Mechanism<\/h2>\n+ * <p>\n+ * The scene graph layout mechanism is driven automatically by the system once\n+ * the application creates and displays a {@link javafx.scene.Scene Scene}.\n+ * The scene graph detects dynamic node changes which affect layout (such as a\n+ * change in size or content) and calls {@code requestLayout()}, which marks that\n+ * branch as needing layout so that on the next pulse, a top-down layout pass is\n+ * executed on that branch by invoking {@code layout()} on that branch's root.\n+ * During that layout pass, the {@code layoutChildren()} callback method will\n+ * be called on each parent to layout its children.  This mechanism is designed\n+ * to maximize layout efficiency by ensuring multiple layout requests are coalesced\n+ * and processed in a single pass rather than executing re-layout on on each minute\n+ * change. Therefore, applications should not invoke layout directly on nodes.\n+ * <\/p>\n+ *\n+ *\n+ * <h2>Node Resizability<\/h2>\n+ * <p>\n+ * The scene graph supports both resizable and non-resizable node classes.  The\n+ * {@code isResizable()} method on {@link javafx.scene.Node Node} returns whether a\n+ * given node is resizable or not.  {@literal A resizable node class is one which supports a range\n+ * of acceptable sizes (minimum <= preferred <= maximum), allowing its parent to resize\n+ * it within that range during layout, given the parent's own layout policy and the\n+ * layout needs of sibling nodes.}  Node supports the following methods for layout code\n+ * to determine a node's resizable range:\n+ * <pre><code>\n+ *     public Orientation getContentBias()\n+ *     public double minWidth(double height)\n+ *     public double minHeight(double width)\n+ *     public double prefWidth(double height)\n+ *     public double prefHeight(double width)\n+ *     public double maxWidth(double height)\n+ *     public double maxHeight(double width)\n+ * <\/code><\/pre>\n+ * <p>\n+ * Non-resizable node classes, on the other hand, do <em>not<\/em> have a consistent\n+ * resizing API and so are <em>not<\/em> resized by their parents during layout.\n+ * Applications must establish the size of non-resizable nodes by setting\n+ * appropriate properties on each instance. These classes return their current layout bounds for\n+ * min, pref, and max, and the {@code resize()} method becomes a no-op.<\/p>\n+ * <p>\n+ * <br>Resizable classes: {@link javafx.scene.layout.Region Region}, {@link javafx.scene.control.Control Control}, {@link javafx.scene.web.WebView WebView}\n+ * <br>Non-Resizable classes: {@link javafx.scene.Group Group}, {@link javafx.scene.shape.Shape Shape}, {@link javafx.scene.text.Text Text}\n+ * <\/p>\n+ * <p>\n+ * For example, a Button control (resizable) computes its min, pref, and max sizes\n+ * which its parent will use to resize it during layout, so the application only needs\n+ * to configure its content and properties:\n+ *\n+ * <pre><code>    Button button = new Button(\"Apply\");\n+ * <\/code><\/pre>\n+ * However, a Circle (non-resizable) cannot be resized by its parent, so the application\n+ * needs to set appropriate geometric properties which determine its size:\n+ *\n+ * <pre><code>    Circle circle = new Circle();\n+ *     circle.setRadius(50);\n+ * <\/code><\/pre>\n+ *\n+ * <h2>Resizable Range<\/h2>\n+ *\n+ * Each resizable node class computes an appropriate min, pref, and max size based\n+ * on its own content and property settings (it's 'intrinsic' size range).\n+ * Some resizable classes have an unbounded max size (all layout panes) while\n+ * others have a max size that is clamped by default to their preferred size (buttons)\n+ * (See individual class documentation for the default range of each class).\n+ * While these defaults are geared towards common usage, applications often need\n+ * to explicitly alter or set a node's resizable range to achieve certain layouts.\n+ * The resizable classes provide properties for overriding the min, pref and max\n+ * sizes for this purpose.\n+ * <p>For example, to override the preferred size of a ListView:<\/p>\n+ * <pre><code>    listview.setPrefSize(200,300);\n+ * <\/code><\/pre>\n+ * <p>Or, to change the max width of a button so it will resize wider to fill a space:\n+ * <pre><code>    button.setMaxWidth(Double.MAX_VALUE);\n+ * <\/code><\/pre>\n+ * <p>For the inverse case, where the application needs to clamp the node's min\n+ * or max size to its preferred:\n+ * <pre><code>    listview.setMaxSize(Region.USE_PREF_SIZE, Region.USE_PREF_SIZE);\n+ * <\/code><\/pre>\n+ * And finally, if the application needs to restore the intrinsically computed values:\n+ * <pre><code>    listview.setPrefSize(Region.USE_COMPUTED_SIZE, Region.USE_COMPUTED_SIZE);\n+ * <\/code><\/pre>\n+ *\n+ * <h2>CSS Styling and Node Sizing<\/h2>\n+ *\n+ * Applications cannot reliably query the bounds of a resizable node until it has been\n+ * added to a scene because the size of that node may be dependent on CSS.  This is\n+ * because CSS is used to style many aspects of a node which affect it's preferred size\n+ * (font, padding, borders, etc) and so the node cannot be laid out (resized) until\n+ * CSS has been applied and the parent can access valid size range metrics.\n+ * This is always true for Controls (and any panes that contain them), because they\n+ * rely on CSS for their default style, even if no user-level style sheets have been set.\n+ * Stylesheets are set at the Scene level, which means that styles cannot even\n+ * be determined until a node's enclosing scene has been initialized. Once a Scene\n+ * is initialized, CSS is applied to nodes on each pulse (when needed) just before\n+ * the layout pass.\n+ *\n+ *\n+ *\n+ * <h2>Visual Bounds vs. Layout Bounds<\/h2>\n+ *\n+ * A graphically rich user interface often has the need to make a distinction between\n+ * a node's visual bounds and the bounds used for layout.  For example, the tight visual\n+ * bounds of a Text node's character glyphs would not work for layout, as the text\n+ * would not be aligned and leading\/trailing whitespace would be discounted.  Also,\n+ * sometimes applications wish to apply affects and transforms to nodes without\n+ * disturbing the surrounding layout (bouncing, jiggling, drop shadows, glows, etc).\n+ * To support this distinction in the scene graph, {@link javafx.scene.Node Node}\n+ * provides the {@code layoutBounds} property to define the 'logical' bounds\n+ * of the node for layout and {@code boundsInParent} to define the visual bounds\n+ * once all effects, clipping, and transforms have been applied.\n+ *\n+ * <p>These two bounds properties will often differ for a given node and\n+ * {@code layoutBounds} is computed differently depending on the node class:\n+ *\n+ * <table border=\"1\">\n+ *  <caption>Bounds Computation Table<\/caption>\n+ *  <thead>\n+ *      <tr>\n+ *          <th scope=\"col\">Node Type<\/th>\n+ *          <th scope=\"col\">Layout Bounds<\/th>\n+ *      <\/tr>\n+ *  <\/thead>\n+ *  <tbody>\n+ *      <tr>\n+ *          <th scope=\"row\">{@link javafx.scene.shape.Shape Shape},{@link javafx.scene.image.ImageView ImageView}<\/th>\n+ *          <td>Includes geometric bounds (geometry plus stroke).\n+ *              Does NOT include effect, clip, or any transforms.\n+ *          <\/td>\n+ *      <\/tr>\n+ *      <tr>\n+ *          <th scope=\"row\">{@link javafx.scene.text.Text Text}<\/th>\n+ *          <td>logical bounds based on the font height and content width, including white space.\n+ *              can be configured to be tight bounds around chars glyphs by setting {@code boundsType}.\n+ *              Does NOT include effect, clip, or any transforms.\n+ *          <\/td>\n+ *      <\/tr>\n+ *      <tr>\n+ *          <th scope=\"row\">{@link javafx.scene.layout.Region Region}, {@link javafx.scene.control.Control Control}, {@link javafx.scene.web.WebView WebView}<\/th>\n+ *          <td>always {@code [0,0 width x height]} regardless of visual bounds,\n+ *              which might be larger or smaller than layout bounds.\n+ *          <\/td>\n+ *      <\/tr>\n+ *      <tr>\n+ *          <th scope=\"row\">{@link javafx.scene.Group Group}<\/th>\n+ *          <td>Union of all visible children's visual bounds ({@code boundsInParent})\n+ *              Does NOT include effect, clip, or transforms set directly on group,\n+ *              however DOES include effect, clip, transforms set on individual children since\n+ *              those are included in the child's {@code boundsInParent}.\n+ *          <\/td>\n+ *      <\/tr>\n+ *  <\/tbody>\n+ * <\/table>\n+ * <p>\n+ * So for example, if a {@link javafx.scene.effect.DropShadow DropShadow} is added to a shape,\n+ * that shadow will <em>not<\/em>  be factored into layout by default.  Or, if a\n+ * {@link javafx.animation.ScaleTransition ScaleTransition} is used to\n+ * pulse the size of a button, that pulse animation will not disturb layout around\n+ * that button.  If an application wishes to have the effect, clip, or transform\n+ * factored into the layout of a node, it should wrap that node in a Group.\n+ * <\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/package-info.java","additions":172,"deletions":173,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -27,157 +27,156 @@\n-\n-<p>Provides the core set of base\n-classes for the JavaFX Scene Graph API. A scene graph is a tree-like\n-data structure, where each item in the tree has zero or one parent and\n-zero or more children.<\/p>\n-\n-<p>The two primary classes in this package are:<\/p>\n-\n-<ul>\n-\n-<li>{@link javafx.scene.Scene Scene} &ndash; Defines the scene to be rendered. It\n-contains a {@code fill} variable that specifies the background of\n-the scene, {@code width} and {@code height} variables that\n-specify the size of the scene, and a {@code content} sequence\n-that contains a list of \"root\" {@code Nodes} to be rendered onto\n-the scene. This sequence of {@code Nodes} is the scene graph for\n-this {@code Scene}.\n-A {@code Scene} is rendered onto a {@link javafx.stage.Stage}, which is the\n-top-level container for JavaFX content.<\/li>\n-\n-<li>{@link javafx.scene.Node Node} &ndash; Abstract base class for all nodes in the\n-scene graph. Each node is either a \"leaf\" node with no child nodes or\n-a \"branch\" node with zero or more child nodes. Each node in the tree\n-has zero or one parent. Only a single node within each tree in the\n-scene graph will have no parent, which is often referred to as the\n-\"root\" node.\n-There may be several trees in the scene graph. Some trees may be part of\n-a {@link javafx.scene.Scene Scene}, in which case they are eligible to be displayed.\n-Other trees might not be part of any {@link javafx.scene.Scene Scene}.<\/li>\n-\n-<\/ul>\n-\n-<p>Branch nodes are of type {@link javafx.scene.Parent Parent} or\n-subclasses thereof.<\/p>\n-\n-<p>Leaf nodes are classes such as\n-{@link javafx.scene.shape.Rectangle}, {@link javafx.scene.text.Text},\n-{@link javafx.scene.image.ImageView}, {@link javafx.scene.media.MediaView},\n-or other such leaf classes which cannot have children.\n-\n-<p>A node may occur at most once anywhere in the scene\n-graph. Specifically, a node must appear no more than once in the children\n-list of a {@link javafx.scene.Parent Parent} or as the clip of a\n-{@link javafx.scene.Node Node}.\n-See the {@link javafx.scene.Node Node} class for more details on these restrictions.<\/p>\n-\n-<h2>Example<\/h2>\n-\n-<p>An example JavaFX scene graph is as follows:<\/p>\n-\n-<pre>\n-package example;\n-\n-import javafx.application.Application;\n-import javafx.stage.Stage;\n-import javafx.scene.Scene;\n-import javafx.scene.Group;\n-import javafx.scene.paint.Color;\n-import javafx.scene.shape.Circle;\n-import javafx.scene.text.Text;\n-import javafx.scene.text.Font;\n-\n-public class Example extends Application {\n-\n-    &#64;Override public void start(Stage stage) {\n-\n-        Group root = new Group();\n-        Scene scene = new Scene(root, 200, 150);\n-        scene.setFill(Color.LIGHTGRAY);\n-\n-        Circle circle = new Circle(60, 40, 30, Color.GREEN);\n-\n-        Text text = new Text(10, 90, \"JavaFX Scene\");\n-        text.setFill(Color.DARKRED);\n-\n-        Font font = new Font(20);\n-        text.setFont(font);\n-\n-        root.getChildren().add(circle);\n-        root.getChildren().add(text);\n-        stage.setScene(scene);\n-        stage.show();\n-    }\n-\n-    public static void main(String[] args) {\n-        Application.launch(args);\n-    }\n-}\n-<\/pre>\n-\n-<p>The above example will generate the following image:<\/p>\n-\n-<p><img src=\"doc-files\/Scene1.png\" alt=\"A visual rendering of the JavaFX Scene example\"><\/p>\n-\n-<h2>Coordinate System and Transformations<\/h2>\n-\n-<p>The {@code Node} class defines a traditional computer graphics \"local\"\n-coordinate system in which the {@code x} axis increases to the right and the\n-{@code y} axis increases downwards. The concrete node classes for shapes\n-provide variables for defining the geometry and location of the shape\n-within this local coordinate space. For example,\n-{@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},\n-{@code width}, {@code height} variables while\n-{@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},\n-and {@code radius}.<\/p>\n-\n-<p>Any {@code Node} can have transformations applied to it. These include\n-translation, rotation, scaling, or shearing transformations. A transformation\n-will change the position, orientation, or size of the coordinate system as\n-viewed from the parent of the node that has been transformed.<\/p>\n-\n-<p>See the {@link javafx.scene.Node Node} class for more information on transformations.<\/p>\n-\n-<h2>Bounding Rectangle<\/h2>\n-\n-<p>Since every {@code Node} has transformations, every Node's geometric\n-bounding rectangle can be described differently depending on whether\n-transformations are accounted for or not.<\/p>\n-\n-<p>Each {@code Node} has the following properties which\n-specifies these bounding rectangles:<\/p>\n-\n-<ul>\n-\n-<li>{@code boundsInLocal} &ndash; specifies the bounds of the\n-{@code Node} in untransformed local coordinates.<\/li>\n-\n-<li>{@code boundsInParent} &ndash; specifies the bounds of the\n-{@code Node} after all transformations have been applied.\n-It is called \"boundsInParent\" because the\n-rectangle will be relative to the parent's coordinate system.<\/li>\n-\n-<li>{@code layoutBounds} &ndash; specifies the rectangular bounds of\n-the {@code Node} that should be used as the basis for layout\n-calculations, and may differ from the visual bounds of the node. For\n-shapes, Text, and ImageView, the default {@code layoutBounds} includes\n-only the shape geometry.<\/li>\n-\n-<\/ul>\n-\n-<p>See the {@link javafx.scene.Node Node} class for more information on bounding rectangles.<\/p>\n-\n-<h2>CSS<\/h2>\n-<p>\n-The JavaFX Scene Graph provides the facility to style nodes using\n-CSS (Cascading Style Sheets).\n-The {@link javafx.scene.Node Node} class contains {@code id}, {@code styleClass}, and\n-{@code style} variables are used by CSS selectors to find nodes\n-to which styles should be applied. The {@link javafx.scene.Scene Scene} class contains\n-the {@code stylesheets} variable which is a sequence of URLs that\n-reference CSS style sheets that are to be applied to the nodes within\n-that scene.\n-<p>\n-For further information about CSS, how to apply CSS styles\n-to nodes, and what properties are available for styling, see the\n-<a href=\"doc-files\/cssref.html\">CSS Reference Guide<\/a>.\n-*\/\n+ * <p>Provides the core set of base\n+ * classes for the JavaFX Scene Graph API. A scene graph is a tree-like\n+ * data structure, where each item in the tree has zero or one parent and\n+ * zero or more children.<\/p>\n+ *\n+ * <p>The two primary classes in this package are:<\/p>\n+ *\n+ * <ul>\n+ *\n+ * <li>{@link javafx.scene.Scene Scene} &ndash; Defines the scene to be rendered. It\n+ * contains a {@code fill} variable that specifies the background of\n+ * the scene, {@code width} and {@code height} variables that\n+ * specify the size of the scene, and a {@code content} sequence\n+ * that contains a list of \"root\" {@code Nodes} to be rendered onto\n+ * the scene. This sequence of {@code Nodes} is the scene graph for\n+ * this {@code Scene}.\n+ * A {@code Scene} is rendered onto a {@link javafx.stage.Stage}, which is the\n+ * top-level container for JavaFX content.<\/li>\n+ *\n+ * <li>{@link javafx.scene.Node Node} &ndash; Abstract base class for all nodes in the\n+ * scene graph. Each node is either a \"leaf\" node with no child nodes or\n+ * a \"branch\" node with zero or more child nodes. Each node in the tree\n+ * has zero or one parent. Only a single node within each tree in the\n+ * scene graph will have no parent, which is often referred to as the\n+ * \"root\" node.\n+ * There may be several trees in the scene graph. Some trees may be part of\n+ * a {@link javafx.scene.Scene Scene}, in which case they are eligible to be displayed.\n+ * Other trees might not be part of any {@link javafx.scene.Scene Scene}.<\/li>\n+ *\n+ * <\/ul>\n+ *\n+ * <p>Branch nodes are of type {@link javafx.scene.Parent Parent} or\n+ * subclasses thereof.<\/p>\n+ *\n+ * <p>Leaf nodes are classes such as\n+ * {@link javafx.scene.shape.Rectangle}, {@link javafx.scene.text.Text},\n+ * {@link javafx.scene.image.ImageView}, {@link javafx.scene.media.MediaView},\n+ * or other such leaf classes which cannot have children.\n+ *\n+ * <p>A node may occur at most once anywhere in the scene\n+ * graph. Specifically, a node must appear no more than once in the children\n+ * list of a {@link javafx.scene.Parent Parent} or as the clip of a\n+ * {@link javafx.scene.Node Node}.\n+ * See the {@link javafx.scene.Node Node} class for more details on these restrictions.<\/p>\n+ *\n+ * <h2>Example<\/h2>\n+ *\n+ * <p>An example JavaFX scene graph is as follows:<\/p>\n+ *\n+ * <pre>\n+ * package example;\n+ *\n+ * import javafx.application.Application;\n+ * import javafx.stage.Stage;\n+ * import javafx.scene.Scene;\n+ * import javafx.scene.Group;\n+ * import javafx.scene.paint.Color;\n+ * import javafx.scene.shape.Circle;\n+ * import javafx.scene.text.Text;\n+ * import javafx.scene.text.Font;\n+ *\n+ * public class Example extends Application {\n+ *\n+ *     &#64;Override public void start(Stage stage) {\n+ *\n+ *         Group root = new Group();\n+ *         Scene scene = new Scene(root, 200, 150);\n+ *         scene.setFill(Color.LIGHTGRAY);\n+ *\n+ *         Circle circle = new Circle(60, 40, 30, Color.GREEN);\n+ *\n+ *         Text text = new Text(10, 90, \"JavaFX Scene\");\n+ *         text.setFill(Color.DARKRED);\n+ *\n+ *         Font font = new Font(20);\n+ *         text.setFont(font);\n+ *\n+ *         root.getChildren().add(circle);\n+ *         root.getChildren().add(text);\n+ *         stage.setScene(scene);\n+ *         stage.show();\n+ *     }\n+ *\n+ *     public static void main(String[] args) {\n+ *         Application.launch(args);\n+ *     }\n+ * }\n+ * <\/pre>\n+ *\n+ * <p>The above example will generate the following image:<\/p>\n+ *\n+ * <p><img src=\"doc-files\/Scene1.png\" alt=\"A visual rendering of the JavaFX Scene example\"><\/p>\n+ *\n+ * <h2>Coordinate System and Transformations<\/h2>\n+ *\n+ * <p>The {@code Node} class defines a traditional computer graphics \"local\"\n+ * coordinate system in which the {@code x} axis increases to the right and the\n+ * {@code y} axis increases downwards. The concrete node classes for shapes\n+ * provide variables for defining the geometry and location of the shape\n+ * within this local coordinate space. For example,\n+ * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},\n+ * {@code width}, {@code height} variables while\n+ * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},\n+ * and {@code radius}.<\/p>\n+ *\n+ * <p>Any {@code Node} can have transformations applied to it. These include\n+ * translation, rotation, scaling, or shearing transformations. A transformation\n+ * will change the position, orientation, or size of the coordinate system as\n+ * viewed from the parent of the node that has been transformed.<\/p>\n+ *\n+ * <p>See the {@link javafx.scene.Node Node} class for more information on transformations.<\/p>\n+ *\n+ * <h2>Bounding Rectangle<\/h2>\n+ *\n+ * <p>Since every {@code Node} has transformations, every Node's geometric\n+ * bounding rectangle can be described differently depending on whether\n+ * transformations are accounted for or not.<\/p>\n+ *\n+ * <p>Each {@code Node} has the following properties which\n+ * specifies these bounding rectangles:<\/p>\n+ *\n+ * <ul>\n+ *\n+ * <li>{@code boundsInLocal} &ndash; specifies the bounds of the\n+ * {@code Node} in untransformed local coordinates.<\/li>\n+ *\n+ * <li>{@code boundsInParent} &ndash; specifies the bounds of the\n+ * {@code Node} after all transformations have been applied.\n+ * It is called \"boundsInParent\" because the\n+ * rectangle will be relative to the parent's coordinate system.<\/li>\n+ *\n+ * <li>{@code layoutBounds} &ndash; specifies the rectangular bounds of\n+ * the {@code Node} that should be used as the basis for layout\n+ * calculations, and may differ from the visual bounds of the node. For\n+ * shapes, Text, and ImageView, the default {@code layoutBounds} includes\n+ * only the shape geometry.<\/li>\n+ *\n+ * <\/ul>\n+ *\n+ * <p>See the {@link javafx.scene.Node Node} class for more information on bounding rectangles.<\/p>\n+ *\n+ * <h2>CSS<\/h2>\n+ * <p>\n+ * The JavaFX Scene Graph provides the facility to style nodes using\n+ * CSS (Cascading Style Sheets).\n+ * The {@link javafx.scene.Node Node} class contains {@code id}, {@code styleClass}, and\n+ * {@code style} variables are used by CSS selectors to find nodes\n+ * to which styles should be applied. The {@link javafx.scene.Scene Scene} class contains\n+ * the {@code stylesheets} variable which is a sequence of URLs that\n+ * reference CSS style sheets that are to be applied to the nodes within\n+ * that scene.\n+ * <p>\n+ * For further information about CSS, how to apply CSS styles\n+ * to nodes, and what properties are available for styling, see the\n+ * <a href=\"doc-files\/cssref.html\">CSS Reference Guide<\/a>.\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/package-info.java","additions":156,"deletions":157,"binary":false,"changes":313,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-<p>Provides the set of classes for colors and gradients used to fill shapes and\n-backgrounds when rendering the scene graph. <\/p>\n-*\/\n+ * <p>Provides the set of classes for colors and gradients used to fill shapes and\n+ * backgrounds when rendering the scene graph. <\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/paint\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-<p>Provides API for simulating user interaction such as typing keys on the keyboard and using the mouse. <\/p>\n-*\/\n+ * <p>Provides API for simulating user interaction such as typing keys on the keyboard and using the mouse. <\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/robot\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-<p>Provides the set of 2D classes for defining and performing operations on\n-objects related to two-dimensional geometry.<\/p>\n-*\/\n+ * <p>Provides the set of 2D classes for defining and performing operations on\n+ * objects related to two-dimensional geometry.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/shape\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-<p>Provides the set of classes for fonts and renderable Text Node.<\/p>\n-*\/\n+ * <p>Provides the set of classes for fonts and renderable Text Node.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-<p>Provides the set of convenient classes to perform rotating, scaling,\n-shearing, and translation transformations for {@code Affine} objects.<\/p>\n-*\/\n+ * <p>Provides the set of convenient classes to perform rotating, scaling,\n+ * shearing, and translation transformations for {@code Affine} objects.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/transform\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-<p>Provides the top-level container classes for JavaFX content.<\/p>\n-*\/\n+ * <p>Provides the top-level container classes for JavaFX content.<\/p>\n+ *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,273 +27,272 @@\n-<p>Provides the set of classes for integrating audio and video into Java FX\n-Applications. The primary use for this package is media playback. There are\n-three principal classes in the media package:\n-{@link javafx.scene.media.Media Media},\n-{@link javafx.scene.media.MediaPlayer MediaPlayer}, and\n-{@link javafx.scene.media.MediaView MediaView}.\n-<\/p>\n-<h2>Contents<\/h2>\n-<ol>\n-<li><a href=\"#SupportedMediaTypes\">Supported Media Types<\/a><\/li>\n-<li><a href=\"#SupportedProtocols\">Supported Protocols<\/a><\/li>\n-<li><a href=\"#SupportedMetadataTags\">Supported Metadata Tags<\/a><\/li>\n-<li><a href=\"#PlayingMediaInJavaFX\">Playing Media in Java FX<\/a><\/li>\n-<\/ol>\n-\n-<a id=\"SupportedMediaTypes\"><\/a>\n-<h3>Supported Media Types<\/h3>\n-\n-Java FX supports a number of different media types. A media type is considered to\n-be the combination of a container format and one or more encodings. In some\n-cases the container format might simply be an elementary stream containing the\n-encoded data.\n-\n-<h4>Supported Encoding Types<\/h4>\n-\n-<p>\n-An encoding type specifies how sampled audio or video data are stored. Usually\n-the encoding type implies a particular compression algorithm. The following\n-table indicates the encoding types supported by Java FX Media.\n-<\/p>\n-\n-<table border=\"1\">\n-<caption>Media Encoding Table<\/caption>\n-<tr><th scope=\"col\">Encoding<\/th><th scope=\"col\">Type<\/th><th scope=\"col\">Description<\/th><\/tr>\n-<tr><th scope=\"row\">AAC<\/th><td>Audio<\/td><td>Advanced Audio Coding audio compression<\/td><\/tr>\n-<tr><th scope=\"row\">MP3<\/th><td>Audio<\/td>\n-<td>Raw MPEG-1, 2, and 2.5 audio; layers I, II, and III; all supported\n-combinations of sampling frequencies and bit rates. Note: File must contain at least 3 MP3 frames.<\/td>\n-<\/tr>\n-<tr><th scope=\"row\">PCM<\/th><td>Audio<\/td><td>Uncompressed, raw audio samples<\/td><\/tr>\n-<tr><th scope=\"row\">H.264\/AVC<\/th><td>Video<\/td><td>H.264\/MPEG-4 Part 10 \/ AVC (Advanced Video Coding)\n-video compression<\/td><\/tr>\n-<tr><th scope=\"row\">H.265\/HEVC<\/th><td>Video<\/td><td>H.265\/MPEG-H Part 2 \/ HEVC (High Efficiency Video Coding)\n-video compression<\/td><\/tr>\n-<\/table>\n-\n-<h4>Supported Container Types<\/h4>\n-\n-<p>\n-A container type specifies the file format used to store the encoded audio,\n-video, and other media data. Each container type is associated with one or more\n-MIME types, file extensions, and file signatures (the initial bytes in the file).\n-The following table indicates the combination of container and encoding types\n-supported by Java FX Media.\n-<\/p>\n-\n-<table border=\"1\">\n-<caption>Media Container \/ Encoding Types Table<\/caption>\n-<tr><th scope=\"col\">Container<\/th><th scope=\"col\">Description<\/th><th scope=\"col\">Video Encoding<\/th>\n-<th scope=\"col\">Audio Encoding<\/th><th scope=\"col\">MIME Type<\/th><th scope=\"col\">File Extension<\/th><\/tr>\n-<tr><th scope=\"row\">AIFF<\/th><td>Audio Interchange File Format<\/td><td>N\/A<\/td>\n-    <td>PCM<\/td><td>audio\/x-aiff<\/td><td>.aif, .aiff<\/td><\/tr>\n-<tr><th scope=\"row\">HLS (*)<\/th><td>MP2T HTTP Live Streaming (audiovisual)<\/td><td>H.264\/AVC<\/td>\n-    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n-<tr><th scope=\"row\">HLS (*)<\/th><td>MP3 HTTP Live Streaming (audio-only)<\/td><td>N\/A<\/td>\n-    <td>MP3<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n-<tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audiovisual)<\/td><td>H.264\/AVC<\/td>\n-    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n-<tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audiovisual)<\/td><td>H.265\/HEVC<\/td>\n-    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n-<tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audio-only)<\/td><td>N\/A<\/td>\n-    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n-<tr><th scope=\"row\">HLS (*)<\/th><td>AAC HTTP Live Streaming (audio-only)<\/td><td>N\/A<\/td>\n-    <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n-<tr><th scope=\"row\">MP3<\/th><td>MPEG-1, 2, 2.5 raw audio stream possibly with ID3 metadata v2.3 or v2.4<\/td>\n-    <td>N\/A<\/td><td>MP3<\/td><td>audio\/mpeg<\/td><td>.mp3<\/td><\/tr>\n-<tr><th scope=\"row\">MP4<\/th><td>MPEG-4 Part 14<\/td><td>H.264\/AVC<\/td>\n-    <td>AAC<\/td><td>video\/mp4, audio\/x-m4a, video\/x-m4v<\/td><td>.mp4, .m4a, .m4v<\/td><\/tr>\n-<tr><th scope=\"row\">MP4<\/th><td>MPEG-4 Part 14<\/td><td>H.265\/HEVC<\/td>\n-    <td>AAC<\/td><td>video\/mp4, audio\/x-m4a, video\/x-m4v<\/td><td>.mp4, .m4a, .m4v<\/td><\/tr>\n-<tr><th scope=\"row\">WAV<\/th><td>Waveform Audio Format<\/td><td>N\/A<\/td>\n-    <td>PCM<\/td><td>audio\/x-wav<\/td><td>.wav<\/td><\/tr>\n-<\/table>\n-\n-<br>(*) HLS is a protocol rather than a container type but is included here to\n-aggregate similar attributes.\n-\n-<a id=\"SupportedProtocols\"><\/a>\n-<h3>Supported Protocols<\/h3>\n-\n-<table border=\"1\">\n-<caption>Supported Protocols Table<\/caption>\n-<tr><th scope=\"col\">Protocol<\/th><th scope=\"col\">Description<\/th><th scope=\"col\">Reference<\/th><\/tr>\n-<tr>\n-    <th scope=\"row\">FILE<\/th>\n-    <td>Protocol for URI representation of local files<\/td>\n-    <td><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/net\/URI.html\">java.net.URI<\/a><\/td>\n-<\/tr>\n-<tr>\n-    <th scope=\"row\">HTTP<\/th>\n-    <td>Hypertext transfer protocol for representation of remote files<\/td>\n-    <td><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/net\/URI.html\">java.net.URI<\/a><\/td>\n-<\/tr>\n-<tr>\n-    <th scope=\"row\">HTTPS<\/th>\n-    <td>Hypertext transfer protocol secure for representation of remote files<\/td>\n-    <td><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/net\/URI.html\">java.net.URI<\/a><\/td>\n-<\/tr>\n-<tr>\n-    <th scope=\"row\">JAR<\/th>\n-    <td>Representation of media entries in files accessible via the FILE, HTTP or HTTPS protocols<\/td>\n-    <td><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/net\/JarURLConnection.html\">java.net.JarURLConnection<\/a><\/td>\n-<\/tr>\n-<tr>\n-    <th scope=\"row\">HTTP Live Streaming (HLS)<\/th>\n-    <td>Playlist-based media streaming via HTTP or HTTPS<\/td>\n-    <td><a href=\"http:\/\/tools.ietf.org\/html\/draft-pantos-http-live-streaming\">Internet-Draft: HTTP Live Streaming<\/a><\/td>\n-<\/tr>\n-<\/table>\n-<br>\n-<h4>MPEG-4 Playback via HTTP<\/h4>\n-<p>\n-It is recommended that MPEG-4 media to be played over HTTP or HTTPS be formatted such that the\n-headers required to decode the stream appear at the beginning of the file. Otherwise,\n-playback might stall until the entire file is downloaded.\n-<\/p>\n-<h4>HTTP Live Streaming (HLS)<\/h4>\n-<p>\n-HLS playback handles sources with these characteristics:\n-<\/p>\n-<ul>\n-    <li>On-demand and live playlists.<\/li>\n-    <li>Elementary MP3 audio streams (audio\/mpegurl) and multiplexed MP2T streams\n-        (application\/vnd.apple.mpegurl) with one AAC audio and one H.264\/AVC video track.<\/li>\n-    <li>Playlists with integer or float duration.<\/li>\n-<\/ul>\n-<p>\n-Sources which do not conform to this basic profile are not guaranteed to be handled.\n-The playlist contains information about the streams comprising the source and is\n-downloaded at the start of playback. Switching between alternate streams, bit rates,\n-and video resolutions is handled automatically as a function of network conditions.\n-<\/p>\n-\n-<a id=\"SupportedMetadataTags\"><\/a>\n-<h3>Supported Metadata Tags<\/h3>\n-\n-A media container may also include certain metadata which describe the media in\n-the file. The Java FX Media API makes the metadata available via the\n-{@link javafx.scene.media.Media#getMetadata()} method. The keys in this mapping\n-are referred to as <i>tags<\/i> with the tags supported by Java FX Media listed in\n-the following table. Note that which tags are available for a given media source\n-depend on the metadata actually stored in that source, i.e., not all tags are\n-guaranteed to be available.\n-\n-<table border=\"1\">\n-<caption>\"Metadata Keys and Tags Table<\/caption>\n-<tr><th scope=\"col\"> Container <\/th><th scope=\"col\"> Tag (type String) <\/th><th scope=\"col\"> Type <\/th><th scope=\"col\"> Description <\/th><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> raw&nbsp;metadata <\/th><td> Map&lt;String,ByteBuffer&gt; <\/td><td>The raw metadata according to the appropriate media specification. The key \"ID3\" maps to MP3 ID3v2 metadata.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> album&nbsp;artist <\/th><td> java.lang.String <\/td><td>The artist for the overall album, possibly \"Various Artists\" for compilations.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> album <\/th><td> java.lang.String <\/td><td>The name of the album.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> artist <\/th><td> java.lang.String <\/td><td>The artist of the track.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> comment-N <\/th><td> java.lang.String <\/td><td>A comment where N is a 0-relative index. Comment format: ContentDescription[lng]=Comment <\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> composer <\/th><td> java.lang.String <\/td><td>The composer of the track.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> year <\/th><td> java.lang.Integer <\/td><td>The year the track was recorded.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> disc&nbsp;count <\/th><td> java.lang.Integer <\/td><td>The number of discs in the album.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> disc&nbsp;number <\/th><td> java.lang.Integer <\/td><td>The 1-relative index of the disc on which this track appears.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> duration <\/th><td> javafx.util.Duration <\/td><td>The duration of the track.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> genre <\/th><td> java.lang.String <\/td><td>The genre of the track, for example, \"Classical,\" \"Darkwave,\" or \"Jazz.\"<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> image <\/th><td> javafx.scene.image.Image <\/td><td>The album cover.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> title <\/th><td> java.lang.String <\/td><td>The name of the track.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> track&nbsp;count <\/th><td> java.lang.Integer <\/td><td>The number of tracks on the album.<\/td><\/tr>\n-<tr><td> MP3 <\/td><th scope=\"row\"> track&nbsp;number <\/th><td> java.lang.Integer <\/td><td>The 1-relative index of this track on the disc.<\/td><\/tr>\n-<\/table>\n-\n-<a id=\"PlayingMediaInJavaFX\"><\/a>\n-<h3>Playing Media in Java FX<\/h3>\n-<h4>Basic Playback<\/h4>\n-<p>\n-The basic steps required to play media in Java FX are:\n-<\/p>\n-<ol>\n-    <li>Create a {@link javafx.scene.media.Media} object for the desired media source.<\/li>\n-    <li>Create a {@link javafx.scene.media.MediaPlayer} object from the <code>Media<\/code> object.<\/li>\n-    <li>Create a {@link javafx.scene.media.MediaView} object.<\/li>\n-    <li>Add the <code>MediaPlayer<\/code> to the <code>MediaView<\/code>.<\/li>\n-    <li>Add the <code>MediaView<\/code> to the scene graph.<\/li>\n-    <li>Invoke {@link javafx.scene.media.MediaPlayer#play()}.<\/li>\n-<\/ol>\n-The foregoing steps are illustrated by the sample code in the <code>MediaView<\/code>\n-class documentation. Some things which should be noted are:\n-<ul>\n-    <li>One <code>Media<\/code> object may be shared among multiple <code>MediaPlayer<\/code>s.\n-    <li>One <code>MediaPlayer<\/code> may be shared amoung multiple <code>MediaView<\/code>s.\n-    <li>Media may be played directly by a <code>MediaPlayer<\/code>\n-        without creating a <code>MediaView<\/code> although a view is required for display.<\/li>\n-    <li>Instead of <code>MediaPlayer.play()<\/code>,\n-        {@link javafx.scene.media.MediaPlayer#setAutoPlay MediaPlayer.setAutoPlay(true)}\n-        may be used to request that playing start as soon as possible.<\/li>\n-    <li><code>MediaPlayer<\/code> has several operational states defined by\n-        {@link javafx.scene.media.MediaPlayer.Status}.\n-    <li>Audio-only media may instead be played using {@link javafx.scene.media.AudioClip}\n-        (recommended for low latency playback of short clips).<\/li>\n-<\/ul>\n-<h4>Error Handling<\/h4>\n-<p>\n-Errors using Java FX Media may be either synchronous or asynchronous. In general\n-synchronous errors will manifest themselves as a Java <code>Exception<\/code> and\n-asynchronous errors will cause a Java FX property to be set. In the latter case\n-either the <code>error<\/code> property may be observed directly, an\n-<code>onError<\/code> callback registered, or possibly both.<\/p>\n-\n-<p>The main sources of synchronous errors are\n-{@link javafx.scene.media.Media#Media Media()} and\n-{@link javafx.scene.media.MediaPlayer#MediaPlayer MediaPlayer()}.\n-The asynchronous error properties are\n-{@link javafx.scene.media.Media#errorProperty Media.error} and\n-{@link javafx.scene.media.MediaPlayer#errorProperty MediaPlayer.error}, and the\n-asynchronous error callbacks\n-{@link javafx.scene.media.Media#onErrorProperty Media.onError},\n-{@link javafx.scene.media.MediaPlayer#onErrorProperty MediaPlayer.onError}, and\n-{@link javafx.scene.media.MediaView#onErrorProperty MediaView.onError}.<\/p>\n-\n-<p>\n-Some errors might be duplicated. For example, a <code>MediaPlayer<\/code> will\n-propagate an error that it encounters to its associated <code>Media<\/code>, and\n-a <code>MediaPlayer<\/code> to all its associated <code>MediaView<\/code>s. As a\n-consequence, it is possible to receive multiple notifications of the occurrence\n-of a given error, depending on which properties are monitored.\n-<\/p>\n-\n-<p>The following code snippet illustrates error handling with media:<\/p>\n-<pre>{@code\n-    String source;\n-    Media media;\n-    MediaPlayer mediaPlayer;\n-    MediaView mediaView;\n-    try {\n-        media = new Media(source);\n-        if (media.getError() == null) {\n-            media.setOnError(new Runnable() {\n-                public void run() {\n-                    \/\/ Handle asynchronous error in Media object.\n-                }\n-            });\n-            try {\n-                mediaPlayer = new MediaPlayer(media);\n-                if (mediaPlayer.getError() == null) {\n-                    mediaPlayer.setOnError(new Runnable() {\n-                        public void run() {\n-                            \/\/ Handle asynchronous error in MediaPlayer object.\n-                        }\n-                    });\n-                    mediaView = new MediaView(mediaPlayer);\n-                    mediaView.setOnError(new EventHandler<MediaErrorEvent>() {\n-                        public void handle(MediaErrorEvent t) {\n-                            \/\/ Handle asynchronous error in MediaView.\n-                        }\n-                    });\n-                } else {\n-                    \/\/ Handle synchronous error creating MediaPlayer.\n-                }\n-            } catch (Exception mediaPlayerException) {\n-                \/\/ Handle exception in MediaPlayer constructor.\n-            }\n-        } else {\n-            \/\/ Handle synchronous error creating Media.\n-        }\n-    } catch (Exception mediaException) {\n-        \/\/ Handle exception in Media constructor.\n-    }\n-}<\/pre>\n-\n-*\/\n+ * <p>Provides the set of classes for integrating audio and video into Java FX\n+ * Applications. The primary use for this package is media playback. There are\n+ * three principal classes in the media package:\n+ * {@link javafx.scene.media.Media Media},\n+ * {@link javafx.scene.media.MediaPlayer MediaPlayer}, and\n+ * {@link javafx.scene.media.MediaView MediaView}.\n+ * <\/p>\n+ * <h2>Contents<\/h2>\n+ * <ol>\n+ * <li><a href=\"#SupportedMediaTypes\">Supported Media Types<\/a><\/li>\n+ * <li><a href=\"#SupportedProtocols\">Supported Protocols<\/a><\/li>\n+ * <li><a href=\"#SupportedMetadataTags\">Supported Metadata Tags<\/a><\/li>\n+ * <li><a href=\"#PlayingMediaInJavaFX\">Playing Media in Java FX<\/a><\/li>\n+ * <\/ol>\n+ *\n+ * <a id=\"SupportedMediaTypes\"><\/a>\n+ * <h3>Supported Media Types<\/h3>\n+ *\n+ * Java FX supports a number of different media types. A media type is considered to\n+ * be the combination of a container format and one or more encodings. In some\n+ * cases the container format might simply be an elementary stream containing the\n+ * encoded data.\n+ *\n+ * <h4>Supported Encoding Types<\/h4>\n+ *\n+ * <p>\n+ * An encoding type specifies how sampled audio or video data are stored. Usually\n+ * the encoding type implies a particular compression algorithm. The following\n+ * table indicates the encoding types supported by Java FX Media.\n+ * <\/p>\n+ *\n+ * <table border=\"1\">\n+ * <caption>Media Encoding Table<\/caption>\n+ * <tr><th scope=\"col\">Encoding<\/th><th scope=\"col\">Type<\/th><th scope=\"col\">Description<\/th><\/tr>\n+ * <tr><th scope=\"row\">AAC<\/th><td>Audio<\/td><td>Advanced Audio Coding audio compression<\/td><\/tr>\n+ * <tr><th scope=\"row\">MP3<\/th><td>Audio<\/td>\n+ * <td>Raw MPEG-1, 2, and 2.5 audio; layers I, II, and III; all supported\n+ * combinations of sampling frequencies and bit rates. Note: File must contain at least 3 MP3 frames.<\/td>\n+ * <\/tr>\n+ * <tr><th scope=\"row\">PCM<\/th><td>Audio<\/td><td>Uncompressed, raw audio samples<\/td><\/tr>\n+ * <tr><th scope=\"row\">H.264\/AVC<\/th><td>Video<\/td><td>H.264\/MPEG-4 Part 10 \/ AVC (Advanced Video Coding)\n+ * video compression<\/td><\/tr>\n+ * <tr><th scope=\"row\">H.265\/HEVC<\/th><td>Video<\/td><td>H.265\/MPEG-H Part 2 \/ HEVC (High Efficiency Video Coding)\n+ * video compression<\/td><\/tr>\n+ * <\/table>\n+ *\n+ * <h4>Supported Container Types<\/h4>\n+ *\n+ * <p>\n+ * A container type specifies the file format used to store the encoded audio,\n+ * video, and other media data. Each container type is associated with one or more\n+ * MIME types, file extensions, and file signatures (the initial bytes in the file).\n+ * The following table indicates the combination of container and encoding types\n+ * supported by Java FX Media.\n+ * <\/p>\n+ *\n+ * <table border=\"1\">\n+ * <caption>Media Container \/ Encoding Types Table<\/caption>\n+ * <tr><th scope=\"col\">Container<\/th><th scope=\"col\">Description<\/th><th scope=\"col\">Video Encoding<\/th>\n+ * <th scope=\"col\">Audio Encoding<\/th><th scope=\"col\">MIME Type<\/th><th scope=\"col\">File Extension<\/th><\/tr>\n+ * <tr><th scope=\"row\">AIFF<\/th><td>Audio Interchange File Format<\/td><td>N\/A<\/td>\n+ *     <td>PCM<\/td><td>audio\/x-aiff<\/td><td>.aif, .aiff<\/td><\/tr>\n+ * <tr><th scope=\"row\">HLS (*)<\/th><td>MP2T HTTP Live Streaming (audiovisual)<\/td><td>H.264\/AVC<\/td>\n+ *     <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+ * <tr><th scope=\"row\">HLS (*)<\/th><td>MP3 HTTP Live Streaming (audio-only)<\/td><td>N\/A<\/td>\n+ *     <td>MP3<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+ * <tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audiovisual)<\/td><td>H.264\/AVC<\/td>\n+ *     <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+ * <tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audiovisual)<\/td><td>H.265\/HEVC<\/td>\n+ *     <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+ * <tr><th scope=\"row\">HLS (*)<\/th><td>fMP4 HTTP Live Streaming (audio-only)<\/td><td>N\/A<\/td>\n+ *     <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+ * <tr><th scope=\"row\">HLS (*)<\/th><td>AAC HTTP Live Streaming (audio-only)<\/td><td>N\/A<\/td>\n+ *     <td>AAC<\/td><td>application\/vnd.apple.mpegurl, audio\/mpegurl<\/td><td>.m3u8<\/td><\/tr>\n+ * <tr><th scope=\"row\">MP3<\/th><td>MPEG-1, 2, 2.5 raw audio stream possibly with ID3 metadata v2.3 or v2.4<\/td>\n+ *     <td>N\/A<\/td><td>MP3<\/td><td>audio\/mpeg<\/td><td>.mp3<\/td><\/tr>\n+ * <tr><th scope=\"row\">MP4<\/th><td>MPEG-4 Part 14<\/td><td>H.264\/AVC<\/td>\n+ *     <td>AAC<\/td><td>video\/mp4, audio\/x-m4a, video\/x-m4v<\/td><td>.mp4, .m4a, .m4v<\/td><\/tr>\n+ * <tr><th scope=\"row\">MP4<\/th><td>MPEG-4 Part 14<\/td><td>H.265\/HEVC<\/td>\n+ *     <td>AAC<\/td><td>video\/mp4, audio\/x-m4a, video\/x-m4v<\/td><td>.mp4, .m4a, .m4v<\/td><\/tr>\n+ * <tr><th scope=\"row\">WAV<\/th><td>Waveform Audio Format<\/td><td>N\/A<\/td>\n+ *     <td>PCM<\/td><td>audio\/x-wav<\/td><td>.wav<\/td><\/tr>\n+ * <\/table>\n+ *\n+ * <br>(*) HLS is a protocol rather than a container type but is included here to\n+ * aggregate similar attributes.\n+ *\n+ * <a id=\"SupportedProtocols\"><\/a>\n+ * <h3>Supported Protocols<\/h3>\n+ *\n+ * <table border=\"1\">\n+ * <caption>Supported Protocols Table<\/caption>\n+ * <tr><th scope=\"col\">Protocol<\/th><th scope=\"col\">Description<\/th><th scope=\"col\">Reference<\/th><\/tr>\n+ * <tr>\n+ *     <th scope=\"row\">FILE<\/th>\n+ *     <td>Protocol for URI representation of local files<\/td>\n+ *     <td><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/net\/URI.html\">java.net.URI<\/a><\/td>\n+ * <\/tr>\n+ * <tr>\n+ *     <th scope=\"row\">HTTP<\/th>\n+ *     <td>Hypertext transfer protocol for representation of remote files<\/td>\n+ *     <td><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/net\/URI.html\">java.net.URI<\/a><\/td>\n+ * <\/tr>\n+ * <tr>\n+ *     <th scope=\"row\">HTTPS<\/th>\n+ *     <td>Hypertext transfer protocol secure for representation of remote files<\/td>\n+ *     <td><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/net\/URI.html\">java.net.URI<\/a><\/td>\n+ * <\/tr>\n+ * <tr>\n+ *     <th scope=\"row\">JAR<\/th>\n+ *     <td>Representation of media entries in files accessible via the FILE, HTTP or HTTPS protocols<\/td>\n+ *     <td><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/net\/JarURLConnection.html\">java.net.JarURLConnection<\/a><\/td>\n+ * <\/tr>\n+ * <tr>\n+ *     <th scope=\"row\">HTTP Live Streaming (HLS)<\/th>\n+ *     <td>Playlist-based media streaming via HTTP or HTTPS<\/td>\n+ *     <td><a href=\"http:\/\/tools.ietf.org\/html\/draft-pantos-http-live-streaming\">Internet-Draft: HTTP Live Streaming<\/a><\/td>\n+ * <\/tr>\n+ * <\/table>\n+ * <br>\n+ * <h4>MPEG-4 Playback via HTTP<\/h4>\n+ * <p>\n+ * It is recommended that MPEG-4 media to be played over HTTP or HTTPS be formatted such that the\n+ * headers required to decode the stream appear at the beginning of the file. Otherwise,\n+ * playback might stall until the entire file is downloaded.\n+ * <\/p>\n+ * <h4>HTTP Live Streaming (HLS)<\/h4>\n+ * <p>\n+ * HLS playback handles sources with these characteristics:\n+ * <\/p>\n+ * <ul>\n+ *     <li>On-demand and live playlists.<\/li>\n+ *     <li>Elementary MP3 audio streams (audio\/mpegurl) and multiplexed MP2T streams\n+ *         (application\/vnd.apple.mpegurl) with one AAC audio and one H.264\/AVC video track.<\/li>\n+ *     <li>Playlists with integer or float duration.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Sources which do not conform to this basic profile are not guaranteed to be handled.\n+ * The playlist contains information about the streams comprising the source and is\n+ * downloaded at the start of playback. Switching between alternate streams, bit rates,\n+ * and video resolutions is handled automatically as a function of network conditions.\n+ * <\/p>\n+ *\n+ * <a id=\"SupportedMetadataTags\"><\/a>\n+ * <h3>Supported Metadata Tags<\/h3>\n+ *\n+ * A media container may also include certain metadata which describe the media in\n+ * the file. The Java FX Media API makes the metadata available via the\n+ * {@link javafx.scene.media.Media#getMetadata()} method. The keys in this mapping\n+ * are referred to as <i>tags<\/i> with the tags supported by Java FX Media listed in\n+ * the following table. Note that which tags are available for a given media source\n+ * depend on the metadata actually stored in that source, i.e., not all tags are\n+ * guaranteed to be available.\n+ *\n+ * <table border=\"1\">\n+ * <caption>\"Metadata Keys and Tags Table<\/caption>\n+ * <tr><th scope=\"col\"> Container <\/th><th scope=\"col\"> Tag (type String) <\/th><th scope=\"col\"> Type <\/th><th scope=\"col\"> Description <\/th><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> raw&nbsp;metadata <\/th><td> Map&lt;String,ByteBuffer&gt; <\/td><td>The raw metadata according to the appropriate media specification. The key \"ID3\" maps to MP3 ID3v2 metadata.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> album&nbsp;artist <\/th><td> java.lang.String <\/td><td>The artist for the overall album, possibly \"Various Artists\" for compilations.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> album <\/th><td> java.lang.String <\/td><td>The name of the album.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> artist <\/th><td> java.lang.String <\/td><td>The artist of the track.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> comment-N <\/th><td> java.lang.String <\/td><td>A comment where N is a 0-relative index. Comment format: ContentDescription[lng]=Comment <\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> composer <\/th><td> java.lang.String <\/td><td>The composer of the track.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> year <\/th><td> java.lang.Integer <\/td><td>The year the track was recorded.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> disc&nbsp;count <\/th><td> java.lang.Integer <\/td><td>The number of discs in the album.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> disc&nbsp;number <\/th><td> java.lang.Integer <\/td><td>The 1-relative index of the disc on which this track appears.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> duration <\/th><td> javafx.util.Duration <\/td><td>The duration of the track.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> genre <\/th><td> java.lang.String <\/td><td>The genre of the track, for example, \"Classical,\" \"Darkwave,\" or \"Jazz.\"<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> image <\/th><td> javafx.scene.image.Image <\/td><td>The album cover.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> title <\/th><td> java.lang.String <\/td><td>The name of the track.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> track&nbsp;count <\/th><td> java.lang.Integer <\/td><td>The number of tracks on the album.<\/td><\/tr>\n+ * <tr><td> MP3 <\/td><th scope=\"row\"> track&nbsp;number <\/th><td> java.lang.Integer <\/td><td>The 1-relative index of this track on the disc.<\/td><\/tr>\n+ * <\/table>\n+ *\n+ * <a id=\"PlayingMediaInJavaFX\"><\/a>\n+ * <h3>Playing Media in Java FX<\/h3>\n+ * <h4>Basic Playback<\/h4>\n+ * <p>\n+ * The basic steps required to play media in Java FX are:\n+ * <\/p>\n+ * <ol>\n+ *     <li>Create a {@link javafx.scene.media.Media} object for the desired media source.<\/li>\n+ *     <li>Create a {@link javafx.scene.media.MediaPlayer} object from the <code>Media<\/code> object.<\/li>\n+ *     <li>Create a {@link javafx.scene.media.MediaView} object.<\/li>\n+ *     <li>Add the <code>MediaPlayer<\/code> to the <code>MediaView<\/code>.<\/li>\n+ *     <li>Add the <code>MediaView<\/code> to the scene graph.<\/li>\n+ *     <li>Invoke {@link javafx.scene.media.MediaPlayer#play()}.<\/li>\n+ * <\/ol>\n+ * The foregoing steps are illustrated by the sample code in the <code>MediaView<\/code>\n+ * class documentation. Some things which should be noted are:\n+ * <ul>\n+ *     <li>One <code>Media<\/code> object may be shared among multiple <code>MediaPlayer<\/code>s.\n+ *     <li>One <code>MediaPlayer<\/code> may be shared amoung multiple <code>MediaView<\/code>s.\n+ *     <li>Media may be played directly by a <code>MediaPlayer<\/code>\n+ *         without creating a <code>MediaView<\/code> although a view is required for display.<\/li>\n+ *     <li>Instead of <code>MediaPlayer.play()<\/code>,\n+ *         {@link javafx.scene.media.MediaPlayer#setAutoPlay MediaPlayer.setAutoPlay(true)}\n+ *         may be used to request that playing start as soon as possible.<\/li>\n+ *     <li><code>MediaPlayer<\/code> has several operational states defined by\n+ *         {@link javafx.scene.media.MediaPlayer.Status}.\n+ *     <li>Audio-only media may instead be played using {@link javafx.scene.media.AudioClip}\n+ *         (recommended for low latency playback of short clips).<\/li>\n+ * <\/ul>\n+ * <h4>Error Handling<\/h4>\n+ * <p>\n+ * Errors using Java FX Media may be either synchronous or asynchronous. In general\n+ * synchronous errors will manifest themselves as a Java <code>Exception<\/code> and\n+ * asynchronous errors will cause a Java FX property to be set. In the latter case\n+ * either the <code>error<\/code> property may be observed directly, an\n+ * <code>onError<\/code> callback registered, or possibly both.<\/p>\n+ *\n+ * <p>The main sources of synchronous errors are\n+ * {@link javafx.scene.media.Media#Media Media()} and\n+ * {@link javafx.scene.media.MediaPlayer#MediaPlayer MediaPlayer()}.\n+ * The asynchronous error properties are\n+ * {@link javafx.scene.media.Media#errorProperty Media.error} and\n+ * {@link javafx.scene.media.MediaPlayer#errorProperty MediaPlayer.error}, and the\n+ * asynchronous error callbacks\n+ * {@link javafx.scene.media.Media#onErrorProperty Media.onError},\n+ * {@link javafx.scene.media.MediaPlayer#onErrorProperty MediaPlayer.onError}, and\n+ * {@link javafx.scene.media.MediaView#onErrorProperty MediaView.onError}.<\/p>\n+ *\n+ * <p>\n+ * Some errors might be duplicated. For example, a <code>MediaPlayer<\/code> will\n+ * propagate an error that it encounters to its associated <code>Media<\/code>, and\n+ * a <code>MediaPlayer<\/code> to all its associated <code>MediaView<\/code>s. As a\n+ * consequence, it is possible to receive multiple notifications of the occurrence\n+ * of a given error, depending on which properties are monitored.\n+ * <\/p>\n+ *\n+ * <p>The following code snippet illustrates error handling with media:<\/p>\n+ * <pre>{@code\n+ *     String source;\n+ *     Media media;\n+ *     MediaPlayer mediaPlayer;\n+ *     MediaView mediaView;\n+ *     try {\n+ *         media = new Media(source);\n+ *         if (media.getError() == null) {\n+ *             media.setOnError(new Runnable() {\n+ *                 public void run() {\n+ *                     \/\/ Handle asynchronous error in Media object.\n+ *                 }\n+ *             });\n+ *             try {\n+ *                 mediaPlayer = new MediaPlayer(media);\n+ *                 if (mediaPlayer.getError() == null) {\n+ *                     mediaPlayer.setOnError(new Runnable() {\n+ *                         public void run() {\n+ *                             \/\/ Handle asynchronous error in MediaPlayer object.\n+ *                         }\n+ *                     });\n+ *                     mediaView = new MediaView(mediaPlayer);\n+ *                     mediaView.setOnError(new EventHandler<MediaErrorEvent>() {\n+ *                         public void handle(MediaErrorEvent t) {\n+ *                             \/\/ Handle asynchronous error in MediaView.\n+ *                         }\n+ *                     });\n+ *                 } else {\n+ *                     \/\/ Handle synchronous error creating MediaPlayer.\n+ *                 }\n+ *             } catch (Exception mediaPlayerException) {\n+ *                 \/\/ Handle exception in MediaPlayer constructor.\n+ *             }\n+ *         } else {\n+ *             \/\/ Handle synchronous error creating Media.\n+ *         }\n+ *     } catch (Exception mediaException) {\n+ *         \/\/ Handle exception in Media constructor.\n+ *     }\n+ * }<\/pre>\n+ *\/\n","filename":"modules\/javafx.media\/src\/main\/java\/javafx\/scene\/media\/package-info.java","additions":272,"deletions":273,"binary":false,"changes":545,"status":"modified"},{"patch":"@@ -27,19 +27,18 @@\n-<p>Defines APIs for the JavaFX \/ Swing interop support included with the\n-   JavaFX UI toolkit, including {@link javafx.embed.swing.SwingNode} (for\n-   embedding Swing inside a JavaFX application) and\n-   {@link javafx.embed.swing.JFXPanel} (for embedding JavaFX inside a Swing\n-   application). <\/p>\n-<p>The {@link javafx.embed.swing.JFXPanel JFXPanel} class defines a\n-   lightweight Swing component, which accepts and renders an instance of\n-   {@link javafx.scene.Scene Scene} and forwards all input events from Swing\n-   to the attached JavaFX scene.\n-   The {@link javafx.embed.swing.SwingNode} class is used to embed\n-   a Swing content into a JavaFX application.\n-   The content to be displayed is specified with the {@code SwingNode.setContent} method\n-   that accepts an instance of a Swing {@code JComponent}. The hierarchy of components\n-   contained in the {@code JComponent} instance should not contain any heavyweight\n-   components, otherwise {@code SwingNode} may fail to paint it. The content gets\n-   repainted automatically. All the input and focus events are forwarded to the\n-   {@code JComponent} instance.<\/p>\n-\n-*\/\n+ * <p>Defines APIs for the JavaFX \/ Swing interop support included with the\n+ *    JavaFX UI toolkit, including {@link javafx.embed.swing.SwingNode} (for\n+ *    embedding Swing inside a JavaFX application) and\n+ *    {@link javafx.embed.swing.JFXPanel} (for embedding JavaFX inside a Swing\n+ *    application). <\/p>\n+ * <p>The {@link javafx.embed.swing.JFXPanel JFXPanel} class defines a\n+ *    lightweight Swing component, which accepts and renders an instance of\n+ *    {@link javafx.scene.Scene Scene} and forwards all input events from Swing\n+ *    to the attached JavaFX scene.\n+ *    The {@link javafx.embed.swing.SwingNode} class is used to embed\n+ *    a Swing content into a JavaFX application.\n+ *    The content to be displayed is specified with the {@code SwingNode.setContent} method\n+ *    that accepts an instance of a Swing {@code JComponent}. The hierarchy of components\n+ *    contained in the {@code JComponent} instance should not contain any heavyweight\n+ *    components, otherwise {@code SwingNode} may fail to paint it. The content gets\n+ *    repainted automatically. All the input and focus events are forwarded to the\n+ *    {@code JComponent} instance.<\/p>\n+ *\/\n","filename":"modules\/javafx.swing\/src\/main\/java\/javafx\/embed\/swing\/package-info.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -27,7 +27,7 @@\n-<p>Provides the set of classes to use JavaFX inside SWT applications.<\/p>\n-<p>The {@link javafx.embed.swt.FXCanvas FXCanvas} class is the base class\n-that provides JavaFX and SWT interoperability. This class defines an\n-SWT component, which accepts and renders an instance of\n-{@link javafx.scene.Scene Scene} and forwards all input events from SWT\n-to the attached JavaFX scene.<\/p>\n-*\/\n+ * <p>Provides the set of classes to use JavaFX inside SWT applications.<\/p>\n+ * <p>The {@link javafx.embed.swt.FXCanvas FXCanvas} class is the base class\n+ * that provides JavaFX and SWT interoperability. This class defines an\n+ * SWT component, which accepts and renders an instance of\n+ * {@link javafx.scene.Scene Scene} and forwards all input events from SWT\n+ * to the attached JavaFX scene.<\/p>\n+ *\/\n","filename":"modules\/javafx.swt\/src\/main\/java\/javafx\/embed\/swt\/package-info.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,26 +27,25 @@\n-<p>This package provides means for loading and displaying Web content. Its\n-    functionality is implemented by two core classes:\n-\n-<p>{@link javafx.scene.web.WebEngine} is a non-visual component capable of\n-    loading Web pages, creating DOM objects for them, and running scripts\n-    inside pages.\n-\n-<p>{@link javafx.scene.web.WebView} is a {@link javafx.scene.Node} that\n-    presents a Web page managed by a {@code WebEngine}. Each {@code WebView}\n-    has a {@code WebEngine} associated with it. This association is\n-    established at the time {@code WebView} is instantiated, and cannot be\n-    changed later.\n-\n-<p>Both {@code WebEngine} and {@code WebView} should be created and\n-    manipulated on FX User thread.\n-\n-<p>The code snippet below shows a typical usage scenario:\n-\n-<pre>{@code\n-    WebView webView = new WebView();\n-    WebEngine webEngine = webView.getEngine();\n-    webEngine.load(\"http:\/\/javafx.com\");\n-    \/\/ add webView to the scene\n-}<\/pre>\n-\n-*\/\n+ * <p>This package provides means for loading and displaying Web content. Its\n+ *     functionality is implemented by two core classes:\n+ *\n+ * <p>{@link javafx.scene.web.WebEngine} is a non-visual component capable of\n+ *     loading Web pages, creating DOM objects for them, and running scripts\n+ *     inside pages.\n+ *\n+ * <p>{@link javafx.scene.web.WebView} is a {@link javafx.scene.Node} that\n+ *     presents a Web page managed by a {@code WebEngine}. Each {@code WebView}\n+ *     has a {@code WebEngine} associated with it. This association is\n+ *     established at the time {@code WebView} is instantiated, and cannot be\n+ *     changed later.\n+ *\n+ * <p>Both {@code WebEngine} and {@code WebView} should be created and\n+ *     manipulated on FX User thread.\n+ *\n+ * <p>The code snippet below shows a typical usage scenario:\n+ *\n+ * <pre>{@code\n+ *     WebView webView = new WebView();\n+ *     WebEngine webEngine = webView.getEngine();\n+ *     webEngine.load(\"http:\/\/javafx.com\");\n+ *     \/\/ add webView to the scene\n+ * }<\/pre>\n+ *\/\n","filename":"modules\/javafx.web\/src\/main\/java\/javafx\/scene\/web\/package-info.java","additions":25,"deletions":26,"binary":false,"changes":51,"status":"modified"}]}