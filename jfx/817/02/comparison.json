{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.util.HashMap;\n@@ -65,2 +66,0 @@\n-        \/\/ Eventually this needs to be updated to reflect when\n-        \/\/ the default has changed.\n@@ -99,3 +98,4 @@\n-    \/\/ This is static. Eventually I want it to be dynamic, but first\n-    \/\/ it needs to be enhanced to only create new instances where\n-    \/\/ there really has been a change, which will be rare.\n+    \/\/ The map is useful when updating\n+    private static HashMap<PrintService, Printer> pMap = new HashMap<>();\n+\n+    private static long lastTime = 0L;\n@@ -103,0 +103,2 @@\n+    private static ObservableSet<Printer> returnedPrinterSet = null;\n+\n@@ -104,2 +106,2 @@\n-        if (printerSet == null) {\n-            Set printers = new TreeSet<Printer>(nameComparator);\n+        if (returnedPrinterSet == null) {\n+            TreeSet<Printer> printers = new TreeSet<Printer>(nameComparator);\n@@ -119,0 +121,1 @@\n+                    pMap.put(defService, defPrinter);\n@@ -120,4 +123,50 @@\n-                    PrinterImpl impl = new J2DPrinter(allServices[i]);\n-                    Printer printer = PrintHelper.createPrinter(impl);\n-                    impl.setPrinter(printer);\n-                    printers.add(printer);\n+                    addNew(allServices[i], printers);\n+                }\n+            }\n+            printerSet = FXCollections.observableSet(printers);\n+            returnedPrinterSet =\n+                FXCollections.unmodifiableObservableSet(printerSet);\n+            lastTime = System.currentTimeMillis();\n+        } else {\n+            PrintService[] newServices =\n+                    PrintServiceLookup.lookupPrintServices(null, null);\n+            if ((newServices.length != printerSet.size()) ||\n+                    (lastTime + 120000) > System.currentTimeMillis()) {\n+                updatePrinters(newServices);\n+                lastTime = System.currentTimeMillis();\n+            }\n+        }\n+        return returnedPrinterSet;\n+    }\n+\n+    private void addNew(PrintService s, Set<Printer> printers) {\n+        PrinterImpl impl = new J2DPrinter(s);\n+        Printer printer = PrintHelper.createPrinter(impl);\n+        impl.setPrinter(printer);\n+        printers.add(printer);\n+        pMap.put(s, printer);\n+    }\n+\n+    \/* Only change a Printer instance if Java 2D changed it.\n+     * Otherwise re-map back to the existing Printer instance.\n+     * This relies on Java 2D not re-creating a printer too.\n+     * Update the existing set so that an app that has cached the printer list\n+     * automatically gets the updates. They can also observe changes .. but\n+     * if doing so they could see the work in progress, but that's probably\n+     * a good thing for an app that is interested.\n+     * Two passes -\n+     * First pass remove any printers that no longer exist.\n+     * Second pass add any new printers.\n+     * Finally update the default printer - if needed.\n+     *\/\n+    private void updatePrinters(PrintService[] newServices) {\n+\n+        Set<PrintService> oldServiceSet = pMap.keySet();\n+        PrintService[] oldServices = oldServiceSet.toArray(new PrintService[0]);\n+\n+        for (PrintService os : oldServices) {\n+            boolean present = false;\n+            for (PrintService ns : newServices) {\n+                if (os.equals(ns)) {\n+                    present = true;\n+                    break;\n@@ -126,3 +175,33 @@\n-            printerSet =\n-                FXCollections.unmodifiableObservableSet\n-                   (FXCollections.observableSet(printers));\n+            if (!present) {\n+                Printer printer = pMap.get(os);\n+                pMap.remove(os);\n+                printerSet.remove(printer);\n+            }\n+        }\n+        for (PrintService s : newServices) {\n+            if (!pMap.containsKey(s)) {\n+                addNew(s, printerSet);\n+            }\n+        }\n+        PrintService oldDefaultService =\n+            (defaultPrinter == null) ? null :\n+                ((J2DPrinter)PrintHelper.getPrinterImpl(defaultPrinter)).getService();\n+        PrintService newDefaultService = PrintServiceLookup.lookupDefaultPrintService();\n+        if (newDefaultService != null) {\n+            if (oldDefaultService == null ||\n+                (!oldDefaultService.equals(newDefaultService)))\n+             {\n+                defaultPrinter = findDefaultPrinter(printerSet, newDefaultService);\n+             }\n+        } else {\n+            defaultPrinter = null;\n+        }\n+    }\n+\n+    private static Printer findDefaultPrinter(Set<Printer> printers,\n+                                              PrintService defaultService) {\n+        for (Printer p : printers) {\n+            PrintService s = ((J2DPrinter)PrintHelper.getPrinterImpl(p)).getService();\n+            if (s.getName().equals(defaultService.getName())) {\n+                return p;\n+            }\n@@ -130,1 +209,1 @@\n-        return printerSet;\n+        return null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/j2d\/PrismPrintPipeline.java","additions":94,"deletions":15,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-     * Consequently there is no guarantee that the result will be\n+     * Consequently, there is no guarantee that the result will be\n@@ -89,0 +89,1 @@\n+        Printer p = PrintPipeline.getPrintPipeline().getDefaultPrinter();\n@@ -90,1 +91,0 @@\n-            Printer p = PrintPipeline.getPrintPipeline().getDefaultPrinter();\n@@ -93,0 +93,2 @@\n+        } else {\n+            defaultPrinter.setValue(p);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/print\/Printer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableSet;\n+import javafx.collections.SetChangeListener;\n+\n+import javafx.application.Application;\n+import javafx.print.PrinterJob;\n+import javafx.print.Printer;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+import javafx.scene.control.Button;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.text.Text;\n+\n+public class PrinterListenerTest extends Application {\n+\n+    public static void main(String[] args) {\n+        launch(args);\n+    }\n+\n+    ObservableSet<Printer> printers;\n+    Printer defaultPrinter;\n+    Stage window;\n+\n+    public void start(Stage stage) {\n+        window = stage;\n+        printPrinters();\n+        printers.addListener(new SetChangeListener<Printer>() {\n+           public void onChanged(SetChangeListener.Change<? extends Printer> change) {\n+               printChanged(change);\n+           }\n+        });\n+\n+       VBox root = new VBox();\n+       Scene scene = new Scene(root);\n+       Button b = new Button(\"List Printers\");\n+       b.setOnAction(e -> printPrinters());\n+       root.getChildren().add(b);\n+       Button p = new Button(\"Show Print Dialog\");\n+       p.setOnAction(e -> showPrintDialog());\n+       root.getChildren().add(p);\n+       Text t = new Text();\n+       t.setWrappingWidth(400);\n+       t.setText(\n+         \"This is a very manual test which to be useful \" +\n+         \"requires you to be adding and removing printers and changing \" +\n+         \"the default from System Settings or whatever is the norm for \" +\n+         \"the platform being tested and then pressing 'List Printers'. \\n\" +\n+         \"Updates happen only when you call the API - no background thread. \" +\n+         \"The Added or Removed printers will be reported by the change listener \" +\n+         \"demonstrating that the ObservableList works.\\n\" +\n+         \"The Print Dialog can be used to verify what is listed matches the dialog.\");\n+\n+       root.getChildren().add(t);\n+       stage.setScene(scene);\n+       stage.show();\n+    }\n+\n+    public void showPrintDialog() {\n+        PrinterJob job = PrinterJob.createPrinterJob();\n+        job.showPrintDialog(window);\n+    }\n+\n+    public void printPrinters() {\n+        if (printers != null) {\n+            System.out.println(\"Current default printer=\"+defaultPrinter);\n+            System.out.println(\"Current Printers :\");\n+            for (Printer p : printers) System.out.println(p);\n+            System.out.println();\n+        }\n+\n+        printers = Printer.getAllPrinters();\n+        defaultPrinter = Printer.getDefaultPrinter();\n+\n+        System.out.println(\"New Default Printer =\"+defaultPrinter);\n+        System.out.println(\"New Printers :\");\n+        for (Printer p : printers) System.out.println(p);\n+        System.out.println();\n+    }\n+\n+    static void printChanged(SetChangeListener.Change<? extends Printer> c) {\n+        if (c.wasAdded()) {\n+            System.out.println(\"Added : \" + c.getElementAdded());\n+        } else if (c.wasRemoved()) {\n+            System.out.println(\"Removed : \" + c.getElementRemoved());\n+        } else {\n+           System.out.println(\"Other change\");\n+        }\n+\n+    }\n+}\n","filename":"tests\/manual\/printing\/PrinterListenerTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}