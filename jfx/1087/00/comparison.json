{"files":[{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.collections;\n+\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.collections.ObservableListBase;\n+import javafx.collections.WeakListChangeListener;\n+import java.util.Objects;\n+\n+public final class ConcatenatedObservableList<E> extends ObservableListBase<E> {\n+\n+    private final ObservableList<? extends E>[] lists;\n+    private final ListChangeListener<? super E> listChangeListener;\n+    private int size;\n+\n+    public ConcatenatedObservableList(ObservableList<? extends E>[] lists) {\n+        this.lists = lists;\n+        this.listChangeListener = this::onListChanged;\n+\n+        ListChangeListener<? super E> weakListChangeListener = new WeakListChangeListener<>(listChangeListener);\n+        for (ObservableList<? extends E> list : lists) {\n+            list.addListener(weakListChangeListener);\n+            size = addSize(list.size());\n+        }\n+    }\n+\n+    private int computeListOffset(ObservableList<? extends E> list) {\n+        int offset = 0;\n+\n+        for (ObservableList<? extends E> l : lists) {\n+            if (l != list) {\n+                offset += l.size();\n+            } else {\n+                return offset;\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\"list\");\n+    }\n+\n+    private void onListChanged(ListChangeListener.Change<? extends E> change) {\n+        int listOffset = computeListOffset(change.getList());\n+\n+        while (change.next()) {\n+            beginChange();\n+\n+            if (change.wasPermutated()) {\n+                onPermutated(change, listOffset);\n+            } else if (change.wasUpdated()) {\n+                onUpdated(change, listOffset);\n+            } else {\n+                if (change.wasReplaced()) {\n+                    onReplaced(change, listOffset);\n+                } else if (change.wasRemoved()) {\n+                    onRemoved(change, listOffset);\n+                } else if (change.wasAdded()) {\n+                    onAdded(change, listOffset);\n+                }\n+            }\n+\n+            endChange();\n+        }\n+    }\n+\n+    private void onPermutated(ListChangeListener.Change<? extends E> change, int listOffset) {\n+        int from = change.getFrom();\n+        int to = change.getTo();\n+\n+        if (listOffset == 0 && change instanceof NonIterableChange.SimplePermutationChange<?> permChange) {\n+            nextPermutation(from, to, permChange.getPermutation());\n+        } else {\n+            int[] perm = new int[to - from];\n+\n+            for (int i = 0, oldIndex = change.getFrom(), max = change.getTo(); oldIndex < max; ++i, ++oldIndex) {\n+                int newIndex = change.getPermutation(oldIndex);\n+                perm[i] = newIndex + listOffset;\n+            }\n+\n+            nextPermutation(from, to, perm);\n+        }\n+    }\n+\n+    private void onUpdated(ListChangeListener.Change<? extends E> change, int listOffset) {\n+        for (int index = change.getFrom(), max = change.getTo(); index < max; ++index) {\n+            nextUpdate(listOffset + index);\n+        }\n+    }\n+\n+    private void onReplaced(ListChangeListener.Change<? extends E> change, int listOffset) {\n+        nextReplace(listOffset + change.getFrom(), listOffset + change.getTo(), change.getRemoved());\n+    }\n+\n+    private void onRemoved(ListChangeListener.Change<? extends E> change, int listOffset) {\n+        size -= change.getRemovedSize();\n+        nextRemove(change.getFrom() + listOffset, change.getRemoved());\n+    }\n+\n+    private void onAdded(ListChangeListener.Change<? extends E> change, int listOffset) {\n+        int from = change.getFrom(), to = change.getTo();\n+        size = addSize(to - from);\n+        nextAdd(from + listOffset, to + listOffset);\n+    }\n+\n+    @Override\n+    public E get(int index) {\n+        Objects.checkIndex(index, size);\n+        int newIndex = index;\n+\n+        for (ObservableList<? extends E> list : lists) {\n+            int listSize = list.size();\n+            if (newIndex >= listSize) {\n+                newIndex -= listSize;\n+            } else {\n+                return list.get(newIndex);\n+            }\n+        }\n+\n+        throw new IndexOutOfBoundsException(index);\n+    }\n+\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    private int addSize(int size) {\n+        int r = this.size + size;\n+        if (((this.size ^ r) & (size ^ r)) < 0) {\n+            throw new IndexOutOfBoundsException(\"Maximum list size exceeded\");\n+        }\n+\n+        return r;\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ConcatenatedObservableList.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import com.sun.javafx.collections.ListListenerHelper;\n-import com.sun.javafx.collections.MapListenerHelper;\n-import com.sun.javafx.collections.SetListenerHelper;\n@@ -48,0 +45,1 @@\n+import java.util.RandomAccess;\n@@ -50,2 +48,4 @@\n-import javafx.beans.InvalidationListener;\n-\n+import com.sun.javafx.collections.ConcatenatedObservableList;\n+import com.sun.javafx.collections.ListListenerHelper;\n+import com.sun.javafx.collections.MapListenerHelper;\n+import com.sun.javafx.collections.SetListenerHelper;\n@@ -62,1 +62,1 @@\n-import java.util.RandomAccess;\n+import javafx.beans.InvalidationListener;\n@@ -373,3 +373,8 @@\n-     * Concatenates more observable lists into one. The resulting list\n-     * would be backed by an array list.\n-     * @param <E> The type of List to be wrapped\n+     * Creates a modifiable {@code ObservableList} that contains a concatenated snapshot of the contents\n+     * of the specified observable lists. The returned list is backed by an {@link ArrayList} that\n+     * contains all of the elements of the source lists.\n+     * <p>\n+     * In contrast to {@link #concatenatedObservableList(ObservableList[])}, the returned list is not\n+     * a view onto the source lists, and is not updated when any of the source lists are changed.\n+     *\n+     * @param <E> the element type\n@@ -377,1 +382,1 @@\n-     * @return new observable array list concatenated from the arguments\n+     * @return new observable {@code ArrayList} concatenated from the arguments\n@@ -379,0 +384,1 @@\n+    @SafeVarargs\n@@ -394,0 +400,27 @@\n+    \/**\n+     * Returns an unmodifiable {@code ObservableList} that contains the concatenation of the contents\n+     * of the specified observable lists. The returned list is a view onto the source lists, which means\n+     * that read operations are delegated to the appropriate source list, and attempts to modify the\n+     * returned list result in an {@link UnsupportedOperationException}.\n+     * <p>\n+     * In contrast to {@link #concat(ObservableList[])}, the list returned from this method is updated\n+     * when any of the source lists are changed.\n+     *\n+     * @param lists the source lists\n+     * @param <E> the element type\n+     * @return an unmodifiable {@code ObservableList} view that contains the concatenation of the source lists\n+     * @throws IndexOutOfBoundsException if number of elements contained in all source lists\n+     *                                   exceeds {@link Integer#MAX_VALUE}\n+     * @since 21\n+     *\/\n+    @SafeVarargs\n+    public static <E> ObservableList<E> concatenatedObservableList(ObservableList<E>... lists) {\n+        if (lists.length == 0) {\n+            return emptyObservableList();\n+        }\n+        if (lists.length == 1) {\n+            return unmodifiableObservableList(lists[0]);\n+        }\n+        return new ConcatenatedObservableList<>(lists);\n+    }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/FXCollections.java","additions":44,"deletions":11,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.collections;\n+\n+import com.sun.javafx.collections.ConcatenatedObservableList;\n+import com.sun.javafx.collections.ObservableListWrapper;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.collections.ObservableListWrapperShim;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ConcatenatedObservableListTest {\n+\n+    private static class TestData {\n+        final ObservableListWrapper<String> list1 =\n+                (ObservableListWrapper<String>)FXCollections.observableArrayList(\"A\", \"B\");\n+\n+        final ObservableListWrapper<String> list2 =\n+                (ObservableListWrapper<String>)FXCollections.observableArrayList(\"C\");\n+\n+        final ObservableListWrapper<String> list3 =\n+                (ObservableListWrapper<String>)FXCollections.<String>observableArrayList();\n+\n+        final ObservableListWrapper<String> list4 =\n+                (ObservableListWrapper<String>)FXCollections.observableArrayList(\"D\", \"E\", \"F\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final ObservableList<String> concatList = new ConcatenatedObservableList<String>(\n+                new ObservableList[] { list1, list2, list3, list4 });\n+\n+        final List<String> trace = new ArrayList<>();\n+\n+        TestData() {\n+            concatList.addListener((ListChangeListener<? super String>) change -> {\n+                while (change.next()) {\n+                    trace.add(change.toString());\n+                }\n+            });\n+        }\n+\n+        void assertListEquals(String... expected) {\n+            assertEquals(List.of(expected), concatList);\n+            assertEquals(concatList.size(), list1.size() + list2.size() + list3.size() + list4.size());\n+        }\n+\n+        void assertTraceEquals(String... trace) {\n+            assertEquals(List.of(trace), this.trace);\n+        }\n+    }\n+\n+    private static Object[] getTestData() {\n+        return new Object[] { new TestData() };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testListIsUnmodifiable(TestData testData) {\n+        assertThrows(UnsupportedOperationException.class, () -> testData.concatList.set(0, \"foo\"));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testIndexOutOfBounds(TestData testData) {\n+        assertThrows(IndexOutOfBoundsException.class, () -> testData.concatList.get(-1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> testData.concatList.get(testData.concatList.size()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testConcat(TestData testData) {\n+        testData.assertListEquals(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testAddFront(TestData testData) {\n+        testData.list1.add(0, \"1\");\n+        testData.list1.addAll(\"2\", \"3\", \"4\");\n+        testData.assertListEquals(\"1\", \"A\", \"B\", \"2\", \"3\", \"4\", \"C\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\n+                \"{ [1] added at 0 }\",\n+                \"{ [2, 3, 4] added at 3 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testAddMiddle(TestData testData) {\n+        testData.list2.add(0, \"1\");\n+        testData.list3.addAll(\"2\", \"3\", \"4\");\n+        testData.assertListEquals(\"A\", \"B\", \"1\", \"C\", \"2\", \"3\", \"4\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\n+                \"{ [1] added at 2 }\",\n+                \"{ [2, 3, 4] added at 4 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testAddBack(TestData testData) {\n+        testData.list4.add(0, \"1\");\n+        testData.list4.addAll(\"2\", \"3\", \"4\");\n+        testData.assertListEquals(\"A\", \"B\", \"C\", \"1\", \"D\", \"E\", \"F\", \"2\", \"3\", \"4\");\n+        testData.assertTraceEquals(\n+                \"{ [1] added at 3 }\",\n+                \"{ [2, 3, 4] added at 7 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testRemoveFront(TestData testData) {\n+        testData.list1.remove(0);\n+        testData.assertListEquals(\"B\", \"C\", \"D\", \"E\", \"F\");\n+        testData.list1.clear();\n+        testData.assertListEquals(\"C\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\n+                \"{ [A] removed at 0 }\",\n+                \"{ [B] removed at 0 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testRemoveMiddle(TestData testData) {\n+        testData.list2.remove(0);\n+        testData.assertListEquals(\"A\", \"B\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\"{ [C] removed at 2 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testRemoveBack(TestData testData) {\n+        testData.list4.remove(0, 2);\n+        testData.assertListEquals(\"A\", \"B\", \"C\", \"F\");\n+        testData.assertTraceEquals(\"{ [D, E] removed at 3 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testReplaceFront(TestData testData) {\n+        testData.list1.set(0, \"1\");\n+        testData.assertListEquals(\"1\", \"B\", \"C\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\"{ [A] replaced by [1] at 0 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testReplaceMiddle(TestData testData) {\n+        testData.list2.set(0, \"1\");\n+        testData.assertListEquals(\"A\", \"B\", \"1\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\"{ [C] replaced by [1] at 2 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testReplaceBack(TestData testData) {\n+        testData.list4.set(1, \"1\");\n+        testData.assertListEquals(\"A\", \"B\", \"C\", \"D\", \"1\", \"F\");\n+        testData.assertTraceEquals(\"{ [E] replaced by [1] at 4 }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testPermuteFront(TestData testData) {\n+        testData.list1.addAll(\"2\", \"3\", \"1\");\n+        testData.assertListEquals(\"A\", \"B\", \"2\", \"3\", \"1\", \"C\", \"D\", \"E\", \"F\");\n+        testData.list1.sort();\n+        testData.assertListEquals(\"1\", \"2\", \"3\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\n+                \"{ [2, 3, 1] added at 2 }\",\n+                \"{ permutated by [3, 4, 1, 2, 0] }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testPermuteMiddle(TestData testData) {\n+        testData.list2.addAll(\"C2\", \"C3\", \"C1\");\n+        testData.assertListEquals(\"A\", \"B\", \"C\", \"C2\", \"C3\", \"C1\", \"D\", \"E\", \"F\");\n+        testData.list2.sort();\n+        testData.assertListEquals(\"A\", \"B\", \"C\", \"C1\", \"C2\", \"C3\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\n+                \"{ [C2, C3, C1] added at 3 }\",\n+                \"{ permutated by [2, 4, 5, 3] }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testPermuteBack(TestData testData) {\n+        testData.list4.addAll(\"2\", \"3\", \"1\");\n+        testData.assertListEquals(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"2\", \"3\", \"1\");\n+        testData.list4.sort();\n+        testData.assertListEquals(\"A\", \"B\", \"C\", \"1\", \"2\", \"3\", \"D\", \"E\", \"F\");\n+        testData.assertTraceEquals(\n+                \"{ [2, 3, 1] added at 6 }\",\n+                \"{ permutated by [6, 7, 8, 4, 5, 3] }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testUpdateFront(TestData testData) {\n+        ObservableListWrapperShim.beginChange(testData.list1);\n+        ObservableListWrapperShim.nextUpdate(testData.list1, 0);\n+        ObservableListWrapperShim.nextUpdate(testData.list1, 1);\n+        ObservableListWrapperShim.endChange(testData.list1);\n+        testData.assertTraceEquals(\"{ updated at range [0, 2) }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testUpdateMiddle(TestData testData) {\n+        ObservableListWrapperShim.beginChange(testData.list2);\n+        ObservableListWrapperShim.nextUpdate(testData.list2, 0);\n+        ObservableListWrapperShim.endChange(testData.list2);\n+        testData.assertTraceEquals(\"{ updated at range [2, 3) }\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestData\")\n+    void testUpdateBack(TestData testData) {\n+        ObservableListWrapperShim.beginChange(testData.list4);\n+        ObservableListWrapperShim.nextUpdate(testData.list4, 1);\n+        ObservableListWrapperShim.nextUpdate(testData.list4, 2);\n+        ObservableListWrapperShim.endChange(testData.list4);\n+        testData.assertTraceEquals(\"{ updated at range [4, 6) }\");\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ConcatenatedObservableListTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"}]}