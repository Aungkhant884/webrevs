{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import javafx.collections.transformation.FilteredList;\n@@ -43,0 +44,1 @@\n+import javafx.geometry.Orientation;\n@@ -140,1 +142,0 @@\n-\n@@ -159,1 +160,0 @@\n-        updateCells(true);\n@@ -161,0 +161,17 @@\n+        if(control instanceof TableRow){\n+            TableRow tableRow = (TableRow)control;\n+            TableView tableView = tableRow.getTableView();\n+            if(tableView!=null){\n+                fixedCellSize = tableView.getFixedCellSize();\n+                fixedCellSizeEnabled = fixedCellSize >= 0;\n+            }\n+        }else if(control instanceof TreeTableRow){\n+            TreeTableRow treeTableRow = (TreeTableRow)control;\n+            TreeTableView treeTableView = treeTableRow.getTreeTableView();\n+            if(treeTableView!=null){\n+                fixedCellSize = treeTableView.getFixedCellSize();\n+                fixedCellSizeEnabled = fixedCellSize >= 0;\n+            }\n+        }\n+\n+        updateCells(true);\n@@ -260,1 +277,2 @@\n-        if (visibleLeafColumns.isEmpty()) {\n+        final int visibleLeafColumnsSize =  visibleLeafColumns.size();\n+        if (visibleLeafColumnsSize==0) {\n@@ -309,3 +327,2 @@\n-                        final int thisIndex = getSkinnable().getIndex();\n-                        for (int i = 0; i < flow.cells.size(); i++) {\n-                            C cell = flow.cells.get(i);\n+                        for (int i = 0, max = flow.getCellCount(); i < max; i++) {\n+                            C cell = flow.getCell(i);\n@@ -329,1 +346,0 @@\n-        final double horizontalPadding = snappedLeftInset() + snappedRightInset();\n@@ -342,3 +358,7 @@\n-        for (int column = 0, max = cells.size(); column < max; column++) {\n-            R tableCell = cells.get(column);\n-            TableColumnBase<T, ?> tableColumn = getTableColumn(tableCell);\n+        int firstVisibleColumnIndex = -1;\n+        int lastVisibleColumnIndex = -1;\n+        final VirtualFlow<?> virtualFlow = getVirtualFlow();\n+        final double scrollX = virtualFlow == null ? 0.0 : virtualFlow.getHbar().getValue();\n+        final Insets padding = getSkinnable().getPadding();\n+        final double vfWidth = virtualFlow == null ? 0.0:virtualFlow.getWidth();\n+        final double headerWidth = vfWidth - (padding.getLeft() + padding.getRight());\n@@ -346,17 +366,12 @@\n-            boolean isVisible = true;\n-            if (fixedCellSizeEnabled) {\n-                \/\/ we determine if the cell is visible, and if not we have the\n-                \/\/ ability to take it out of the scenegraph to help improve\n-                \/\/ performance. However, we only do this when there is a\n-                \/\/ fixed cell length specified in the TableView. This is because\n-                \/\/ when we have a fixed cell length it is possible to know with\n-                \/\/ certainty the height of each TableCell - it is the fixed value\n-                \/\/ provided by the developer, and this means that we do not have\n-                \/\/ to concern ourselves with the possibility that the height\n-                \/\/ may be variable and \/ or dynamic.\n-                isVisible = isColumnPartiallyOrFullyVisible(tableColumn);\n-\n-                height = fixedCellSize;\n-            } else {\n-                height = Math.max(controlHeight, tableCell.prefHeight(-1));\n-                height = snapSizeY(height) - snapSizeY(verticalPadding);\n+        double start = 0;\n+        for (int i = 0; i < visibleLeafColumnsSize; i++) {\n+            TableColumnBase<?,?> c = visibleLeafColumns.get(i);\n+            double end = start + snapSizeX(c.getWidth());\n+            final boolean visible = isOverlap(start, end, scrollX, headerWidth + scrollX);\n+            if(visible) {\n+                if(firstVisibleColumnIndex == -1) {\n+                    firstVisibleColumnIndex = i;\n+                }\n+                lastVisibleColumnIndex = i;\n+            }else if( firstVisibleColumnIndex != -1 ) {\n+                break;\n@@ -364,0 +379,2 @@\n+            start = end;\n+        }\n@@ -365,3 +382,16 @@\n-            if (isVisible) {\n-                if (fixedCellSizeEnabled && tableCell.getParent() == null) {\n-                    getChildren().add(tableCell);\n+        final ObservableList<Node> children = getChildren();\n+        if(fixedCellSizeEnabled) {\n+            for (int column = cells.size()-1; column >= 0; column--) {\n+                R tableCell = cells.get(column);\n+                final boolean isVisible = firstVisibleColumnIndex <= column && column <= lastVisibleColumnIndex;\n+                if (isVisible ) {\n+                    if(tableCell.getParent()==null){\n+                        children.add(tableCell);\n+                    }\n+                }else{\n+                    \/\/ we only add\/remove to the scenegraph if the fixed cell\n+                    \/\/ length support is enabled - otherwise we keep all\n+                    \/\/ TableCells in the scenegraph\n+                    if(tableCell.getParent()!=null){\n+                        children.remove(tableCell);\n+                    }\n@@ -369,0 +399,2 @@\n+            }\n+        }\n@@ -370,1 +402,8 @@\n-                width = tableCell.prefWidth(height) - snapSizeX(horizontalPadding);\n+        \/\/ Added for RT-32700, and then updated for RT-34074.\n+        \/\/ We change the alignment from CENTER_LEFT to TOP_LEFT if the\n+        \/\/ height of the row is greater than the default size, and if\n+        \/\/ the alignment is the default alignment.\n+        \/\/ What I would rather do is only change the alignment if the\n+        \/\/ alignment has not been manually changed, but for now this will\n+        \/\/ do.\n+        final boolean centreContent = h <= 24.0;\n@@ -372,8 +411,2 @@\n-                \/\/ Added for RT-32700, and then updated for RT-34074.\n-                \/\/ We change the alignment from CENTER_LEFT to TOP_LEFT if the\n-                \/\/ height of the row is greater than the default size, and if\n-                \/\/ the alignment is the default alignment.\n-                \/\/ What I would rather do is only change the alignment if the\n-                \/\/ alignment has not been manually changed, but for now this will\n-                \/\/ do.\n-                final boolean centreContent = h <= 24.0;\n+        double layoutY = snappedTopInset();\n+        final double snapSizeYVerticalPadding = snapSizeY(verticalPadding);\n@@ -381,0 +414,7 @@\n+        for (int column = 0, max = cells.size(); column < max; column++) {\n+            R tableCell = cells.get(column);\n+            TableColumnBase<T, ?> tableColumn = getTableColumn(tableCell);\n+\n+            boolean isVisible = firstVisibleColumnIndex <= column && column <= lastVisibleColumnIndex;\n+            width = snapSizeX(tableColumn.getWidth());\n+            if (isVisible || isOverlap(tableCell.getLayoutX(), tableCell.getLayoutX()+width, scrollX, headerWidth + scrollX)) {\n@@ -432,0 +472,18 @@\n+\n+                if (fixedCellSizeEnabled) {\n+                    \/\/ we determine if the cell is visible, and if not we have the\n+                    \/\/ ability to take it out of the scenegraph to help improve\n+                    \/\/ performance. However, we only do this when there is a\n+                    \/\/ fixed cell length specified in the TableView. This is because\n+                    \/\/ when we have a fixed cell length it is possible to know with\n+                    \/\/ certainty the height of each TableCell - it is the fixed value\n+                    \/\/ provided by the developer, and this means that we do not have\n+                    \/\/ to concern ourselves with the possibility that the height\n+                    \/\/ may be variable and \/ or dynamic.\n+\n+                    height = fixedCellSize;\n+                } else {\n+                    height = Math.max(controlHeight, tableCell.prefHeight(-1));\n+                    height = snapSizeY(height) - snapSizeYVerticalPadding;\n+                }\n+\n@@ -435,3 +493,1 @@\n-\n-                tableCell.resize(width, height);\n-                tableCell.relocate(x, snappedTopInset());\n+                tableCell.resizeRelocate(x, layoutY, width, height);\n@@ -442,9 +498,2 @@\n-            } else {\n-                width = snapSizeX(tableCell.prefWidth(-1)) - snapSizeX(horizontalPadding);\n-\n-                if (fixedCellSizeEnabled) {\n-                    \/\/ we only add\/remove to the scenegraph if the fixed cell\n-                    \/\/ length support is enabled - otherwise we keep all\n-                    \/\/ TableCells in the scenegraph\n-                    getChildren().remove(tableCell);\n-                }\n+            }else if(fixedCellSizeEnabled && lastVisibleColumnIndex<column){\n+                break;\n@@ -452,1 +501,0 @@\n-\n@@ -519,2 +567,1 @@\n-        for (int i = 0, max = visibleLeafColumns.size(); i < max; i++) {\n-            TableColumnBase<T,?> col = visibleLeafColumns.get(i);\n+        for (TableColumnBase<T,?> col : visibleLeafColumns) {\n@@ -543,1 +590,0 @@\n-        \/\/ update children of each row\n@@ -545,12 +591,3 @@\n-            \/\/ we leave the adding \/ removing up to the layoutChildren method mostly,\n-            \/\/ but here we remove any children cells that refer to columns that are\n-            \/\/ not visible\n-            List<Node> toRemove = new ArrayList<>();\n-            for (Node cell : getChildren()) {\n-                if (! (cell instanceof IndexedCell)) continue;\n-                if (!getTableColumn((R)cell).isVisible()) {\n-                    toRemove.add(cell);\n-                }\n-            }\n-            getChildren().removeAll(toRemove);\n-        } else if (!fixedCellSizeEnabled && (resetChildren || cellsEmpty)) {\n+            return;\n+        }\n+        if (resetChildren || cellsEmpty) {\n@@ -574,3 +611,6 @@\n-        double prefWidth = 0.0;\n-        for (R cell : cells) {\n-            prefWidth += cell.prefWidth(height);\n+        double width = 0;\n+        ObservableList<? extends TableColumnBase> visibleLeafColumns = getVisibleLeafColumns();\n+        for (TableColumnBase<?,?> c: visibleLeafColumns) {\n+            if( c.isVisible() ) {\n+                width += snapSizeX(c.getWidth());\n+            }\n@@ -578,1 +618,2 @@\n-        return prefWidth;\n+        final Insets padding = getSkinnable().getPadding();\n+        return width + padding.getLeft() + padding.getRight();\n@@ -594,2 +635,3 @@\n-        if (getCellSize() < DEFAULT_CELL_SIZE) {\n-            return getCellSize();\n+        final double cellSize = getCellSize();\n+        if (cellSize < DEFAULT_CELL_SIZE) {\n+            return cellSize;\n@@ -606,2 +648,1 @@\n-        double ph = Math.max(prefHeight, Math.max(getCellSize(), getSkinnable().minHeight(-1)));\n-\n+        double ph = Math.max(prefHeight, Math.max(cellSize, getSkinnable().minHeight(-1)));\n@@ -624,2 +665,3 @@\n-        if (getCellSize() < DEFAULT_CELL_SIZE) {\n-            return getCellSize();\n+        final double cellSize = getCellSize();\n+        if (cellSize < DEFAULT_CELL_SIZE) {\n+            return cellSize;\n@@ -666,21 +708,2 @@\n-    private boolean isColumnPartiallyOrFullyVisible(TableColumnBase col) {\n-        if (col == null || !col.isVisible()) return false;\n-\n-        final VirtualFlow<?> virtualFlow = getVirtualFlow();\n-        double scrollX = virtualFlow == null ? 0.0 : virtualFlow.getHbar().getValue();\n-\n-        \/\/ work out where this column header is, and it's width (start -> end)\n-        double start = 0;\n-        final ObservableList<? extends TableColumnBase> visibleLeafColumns = getVisibleLeafColumns();\n-        for (int i = 0, max = visibleLeafColumns.size(); i < max; i++) {\n-            TableColumnBase<?,?> c = visibleLeafColumns.get(i);\n-            if (c.equals(col)) break;\n-            start += c.getWidth();\n-        }\n-        double end = start + col.getWidth();\n-\n-        \/\/ determine the width of the table\n-        final Insets padding = getSkinnable().getPadding();\n-        double headerWidth = getSkinnable().getWidth() - padding.getLeft() + padding.getRight();\n-\n-        return (start >= scrollX || end > scrollX) && (start < (headerWidth + scrollX) || end <= (headerWidth + scrollX));\n+    private static boolean isOverlap(double start, double end, double start2, double end2){\n+        return (start<=end2 && end >= start2);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkinBase.java","additions":122,"deletions":99,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import javafx.scene.control.ScrollBar;\n@@ -118,1 +119,5 @@\n-        flow.getHbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);\n+\n+        final ScrollBar hbar = flow.getHbar();\n+        hbar.addEventFilter(MouseEvent.MOUSE_PRESSED, ml);\n+        hbar.valueProperty().addListener(o -> flow.requestCellLayout());\n+        hbar.widthProperty().addListener(o -> flow.requestCellLayout());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableViewSkin.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -164,1 +164,4 @@\n-        flow.getHbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);\n+        final ScrollBar hbar = flow.getHbar();\n+        hbar.addEventFilter(MouseEvent.MOUSE_PRESSED, ml);\n+        hbar.valueProperty().addListener(o -> flow.requestCellLayout());\n+        hbar.widthProperty().addListener(o -> flow.requestCellLayout());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableViewSkin.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}