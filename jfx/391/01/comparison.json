{"files":[{"patch":"@@ -75,0 +75,13 @@\n+#if OS(WINDOWS) && PLATFORM(JAVA)\n+    \/\/ From empirical testing, we've seen CreateTimerQueueTimer() sometimes fire up to 5+ ms early.\n+    \/\/ This causes havoc for clients of this code that expect to not be called back until the\n+    \/\/ specified duration has expired. Other folks online have also observed some slop in the\n+    \/\/ firing times of CreateTimerQuqueTimer(). From the data posted at\n+    \/\/ http:\/\/omeg.pl\/blog\/2011\/11\/on-winapi-timers-and-their-resolution, it appears that the slop\n+    \/\/ can be up to about 10 ms. To ensure that we don't fire the timer early, we'll tack on a\n+    \/\/ slop adjustment to the duration, and we'll use double the worst amount of slop observed\n+    \/\/ so far.\n+    const Seconds slopAdjustment { 20_ms };\n+    if (delay)\n+        delay += slopAdjustment;\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/generic\/WorkQueueGeneric.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,197 +0,0 @@\n-\/*\n- * Copyright (C) 2010-2018 Apple Inc. All rights reserved.\n- * Copyright (C) 2017 Sony Interactive Entertainment Inc.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS\n- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n- * THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include <wtf\/WorkQueue.h>\n-\n-#include <wtf\/MathExtras.h>\n-#include <wtf\/Threading.h>\n-\n-#if PLATFORM(JAVA)\n-#include <wtf\/java\/JavaEnv.h>\n-#endif\n-\n-namespace WTF {\n-\n-DWORD WorkQueue::workThreadCallback(void* context)\n-{\n-    ASSERT_ARG(context, context);\n-\n-    WorkQueue* queue = static_cast<WorkQueue*>(context);\n-\n-    if (queue->tryRegisterAsWorkThread())\n-        queue->performWorkOnRegisteredWorkThread();\n-\n-    queue->deref();\n-\n-    return 0;\n-}\n-\n-void WorkQueue::performWorkOnRegisteredWorkThread()\n-{\n-    ASSERT(m_isWorkThreadRegistered);\n-\n-    m_functionQueueLock.lock();\n-#if PLATFORM(JAVA)\n-    AttachThreadAsDaemonToJavaEnv autoAttach;\n-#endif\n-\n-    while (!m_functionQueue.isEmpty()) {\n-        Vector<Function<void()>> functionQueue;\n-        m_functionQueue.swap(functionQueue);\n-\n-        \/\/ Allow more work to be scheduled while we're not using the queue directly.\n-        m_functionQueueLock.unlock();\n-        for (auto& function : functionQueue)\n-            function();\n-        m_functionQueueLock.lock();\n-    }\n-\n-    \/\/ One invariant we maintain is that any work scheduled while a work thread is registered will\n-    \/\/ be handled by that work thread. Unregister as the work thread while the queue lock is still\n-    \/\/ held so that no work can be scheduled while we're still registered.\n-    unregisterAsWorkThread();\n-\n-    m_functionQueueLock.unlock();\n-}\n-\n-void WorkQueue::platformInitialize(const char* name, Type, QOS)\n-{\n-    m_isWorkThreadRegistered = 0;\n-    m_timerQueue = ::CreateTimerQueue();\n-    ASSERT_WITH_MESSAGE(m_timerQueue, \"::CreateTimerQueue failed with error %lu\", ::GetLastError());\n-}\n-\n-bool WorkQueue::tryRegisterAsWorkThread()\n-{\n-    LONG result = ::InterlockedCompareExchange(&m_isWorkThreadRegistered, 1, 0);\n-    ASSERT(!result || result == 1);\n-    return !result;\n-}\n-\n-void WorkQueue::unregisterAsWorkThread()\n-{\n-    LONG result = ::InterlockedCompareExchange(&m_isWorkThreadRegistered, 0, 1);\n-    ASSERT_UNUSED(result, result == 1);\n-}\n-\n-void WorkQueue::platformInvalidate()\n-{\n-    \/\/ FIXME: We need to ensure that any timer-queue timers that fire after this point don't try to\n-    \/\/ access this WorkQueue <http:\/\/webkit.org\/b\/44690>.\n-    ::DeleteTimerQueueEx(m_timerQueue, 0);\n-}\n-\n-void WorkQueue::dispatch(Function<void()>&& function)\n-{\n-    auto locker = holdLock(m_functionQueueLock);\n-    m_functionQueue.append(WTFMove(function));\n-\n-    \/\/ Spawn a work thread to perform the work we just added. As an optimization, we avoid\n-    \/\/ spawning the thread if a work thread is already registered. This prevents multiple work\n-    \/\/ threads from being spawned in most cases. (Note that when a work thread has been spawned but\n-    \/\/ hasn't registered itself yet, m_isWorkThreadRegistered will be false and we'll end up\n-    \/\/ spawning a second work thread here. But work thread registration process will ensure that\n-    \/\/ only one thread actually ends up performing work.)\n-    if (!m_isWorkThreadRegistered) {\n-        ref();\n-        ::QueueUserWorkItem(workThreadCallback, this, WT_EXECUTEDEFAULT);\n-    }\n-}\n-\n-struct TimerContext : public ThreadSafeRefCounted<TimerContext> {\n-    static Ref<TimerContext> create() { return adoptRef(*new TimerContext); }\n-\n-    Lock timerLock;\n-    WorkQueue* queue { nullptr };\n-    HANDLE timer { nullptr };\n-    Function<void()> function;\n-\n-private:\n-    TimerContext() = default;\n-};\n-\n-void WorkQueue::timerCallback(void* context, BOOLEAN timerOrWaitFired)\n-{\n-    ASSERT_ARG(context, context);\n-    ASSERT_UNUSED(timerOrWaitFired, timerOrWaitFired);\n-\n-    \/\/ Balanced by leakRef in scheduleWorkAfterDelay.\n-    RefPtr<TimerContext> timerContext = adoptRef(static_cast<TimerContext*>(context));\n-\n-    timerContext->queue->dispatch(WTFMove(timerContext->function));\n-\n-    auto locker = holdLock(timerContext->timerLock);\n-    ASSERT(timerContext->timer);\n-    ASSERT(timerContext->queue->m_timerQueue);\n-    if (!::DeleteTimerQueueTimer(timerContext->queue->m_timerQueue, timerContext->timer, 0)) {\n-        \/\/ Getting ERROR_IO_PENDING here means that the timer will be destroyed once the callback is done executing.\n-        ASSERT_WITH_MESSAGE(::GetLastError() == ERROR_IO_PENDING, \"::DeleteTimerQueueTimer failed with error %lu\", ::GetLastError());\n-    }\n-}\n-\n-void WorkQueue::dispatchAfter(Seconds duration, Function<void()>&& function)\n-{\n-    ASSERT(m_timerQueue);\n-    ref();\n-\n-    Ref<TimerContext> context = TimerContext::create();\n-    context->queue = this;\n-    context->function = WTFMove(function);\n-\n-    {\n-        \/\/ The timer callback could fire before ::CreateTimerQueueTimer even returns, so we protect\n-        \/\/ context->timer with a mutex to ensure the timer callback doesn't access it before the\n-        \/\/ timer handle has been stored in it.\n-        auto locker = holdLock(context->timerLock);\n-\n-        int64_t milliseconds = duration.milliseconds();\n-\n-        \/\/ From empirical testing, we've seen CreateTimerQueueTimer() sometimes fire up to 5+ ms early.\n-        \/\/ This causes havoc for clients of this code that expect to not be called back until the\n-        \/\/ specified duration has expired. Other folks online have also observed some slop in the\n-        \/\/ firing times of CreateTimerQuqueTimer(). From the data posted at\n-        \/\/ http:\/\/omeg.pl\/blog\/2011\/11\/on-winapi-timers-and-their-resolution, it appears that the slop\n-        \/\/ can be up to about 10 ms. To ensure that we don't fire the timer early, we'll tack on a\n-        \/\/ slop adjustment to the duration, and we'll use double the worst amount of slop observed\n-        \/\/ so far.\n-        const int64_t slopAdjustment = 20;\n-        if (milliseconds)\n-            milliseconds += slopAdjustment;\n-\n-        \/\/ Since our timer callback is quick, we can execute in the timer thread itself and avoid\n-        \/\/ an extra thread switch over to a worker thread.\n-        if (!::CreateTimerQueueTimer(&context->timer, m_timerQueue, timerCallback, context.ptr(), clampTo<DWORD>(milliseconds), 0, WT_EXECUTEINTIMERTHREAD)) {\n-            ASSERT_WITH_MESSAGE(false, \"::CreateTimerQueueTimer failed with error %lu\", ::GetLastError());\n-            return;\n-        }\n-    }\n-\n-    \/\/ The timer callback will handle destroying context.\n-    context.leakRef();\n-}\n-\n-} \/\/ namespace WTF\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/win\/WorkQueueWin.cpp","additions":0,"deletions":197,"binary":false,"changes":197,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-import org.junit.Ignore;\n@@ -40,1 +39,0 @@\n-    @Ignore(\"JDK-8260163\")\n","filename":"modules\/javafx.web\/src\/test\/java\/test\/javafx\/scene\/web\/IrresponsiveScriptTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}