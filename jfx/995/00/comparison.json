{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n- * <h2>A warning about inserting Nodes into the ComboBox items list<\/h2>\n+ * <h2>Warning: Nodes should not be inserted directly into the ComboBox items list<\/h2>\n@@ -129,1 +129,2 @@\n- * the items list is <strong>strongly not recommended<\/strong>. This is because\n+ * the items list is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results. This is because\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ComboBox.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,49 @@\n- * description of how to write custom Cells.\n+ * description of how to write custom Cells.<\/p>\n+ *\n+ * <h3>Warning: Nodes should not be inserted directly into the items list<\/h3>\n+ * ListView allows for the items list to contain elements of any type, including\n+ * {@link Node} instances. Putting nodes into\n+ * the items list is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results.\n+ * <p>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link #cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the\n+ * data stored in the item for that cell.\n+ *\n+ * <p>For example, rather than use the following code:\n+ *\n+ * <pre>{@code   ListView<Rectangle> lv = new ListView<>();\n+ *  lv.getItems().addAll(\n+ *      new Rectangle(10, 10, Color.RED),\n+ *      new Rectangle(10, 10, Color.GREEN),\n+ *      new Rectangle(10, 10, Color.BLUE));}}<\/pre>\n+ *\n+ * <p>You should do the following:<\/p>\n+ *\n+ * <pre>{@code   ListView<Color> lv = new ListView<>();\n+ *  lv.getItems().addAll(Color.RED, Color.GREEN, Color.BLUE);\n+ *\n+ *  lv.setCellFactory(p -> {\n+ *    return new ListCell<>() {\n+ *        private final Rectangle rectangle;\n+ *        {\n+ *            setContentDisplay(ContentDisplay.GRAPHIC_ONLY);\n+ *            rectangle = new Rectangle(10, 10);\n+ *        }\n+ *\n+ *        @Override\n+ *        protected void updateItem(Color item, boolean empty) {\n+ *            super.updateItem(item, empty);\n+ *\n+ *            if (item == null || empty) {\n+ *                setGraphic(null);\n+ *            } else {\n+ *                rectangle.setFill(item);\n+ *                setGraphic(rectangle);\n+ *            }\n+ *         }\n+ *     };\n+ * });}<\/pre>\n+ * <p> This example has an anonymous custom {@code ListCell} class in the custom cell factory.\n+ * Note that the Rectangle (Node) object needs to be created in the custom {@code ListCell} class\n+ * or in it's constructor and updated\/used in it's updateItem method.\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ListView.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -259,0 +259,89 @@\n+ * <h4>Warning: Nodes should not be inserted directly into the TableView cells<\/h4>\n+ * TableView allows for it's cells to contain elements of any type, including\n+ * {@link Node} instances. Putting nodes into\n+ * the TableView cells is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results.\n+ * <p>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link TableColumn#cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the data stored in the item for that cell.\n+ *\n+ * <p>For example, rather than use the following code:\n+ * <pre>{@code  class CustomRectangle {\n+ *   private SimpleObjectProperty<Rectangle> rect;\n+ *\n+ *   CustomRectangle(Color col) {\n+ *       this.rect = new SimpleObjectProperty<Rectangle>(new Rectangle(10, 10, col));\n+ *   }\n+ *   public Rectangle getRect() { return rect.getValue(); }\n+ *   public void setRect(Rectangle r) { rect.setValue(r); }\n+ *   public SimpleObjectProperty<Rectangle> rectProperty() { return rect; }\n+ * }\n+ *\n+ * TableView<CustomRectangle> tableview = new TableView<CustomRectangle>();\n+ *\n+ * ObservableList<CustomRectangle> rectList = FXCollections.observableArrayList();\n+ * rectList.addAll(\n+ *     new CustomRectangle(Color.RED),\n+ *     new CustomRectangle(Color.GREEN),\n+ *     new CustomRectangle(Color.BLUE));\n+ *\n+ * TableColumn<CustomRectangle, Rectangle> col = new TableColumn<CustomRectangle, Rectangle>(\"Color\");\n+ * col.setCellValueFactory(data -> data.getValue().rectProperty());\n+ *\n+ * tableview.getColumns().add(col);\n+ * tableview.setItems(rectList);\n+ * }<\/pre>\n+ *\n+ * <p>You should do the following:<\/p>\n+ * <pre> {@code\n+ *  class CustomColor {\n+ *    private SimpleObjectProperty<Color> color;\n+ *\n+ *    CustomColor(Color col) {\n+ *      this.color = new SimpleObjectProperty<Color>(col);\n+ *    }\n+ *    public Color getColor() { return color.getValue(); }\n+ *    public void setColor(Color c) { color.setValue(c); }\n+ *    public SimpleObjectProperty<Color> colorProperty() { return color; }\n+ *  }\n+ *\n+ *  TableView<CustomColor> tableview = new TableView<CustomColor>();\n+ *\n+ *  ObservableList<CustomColor> colorList = FXCollections.observableArrayList();\n+ *  colorList.addAll(\n+ *      new CustomColor(Color.RED),\n+ *      new CustomColor(Color.GREEN),\n+ *      new CustomColor(Color.BLUE));\n+ *\n+ *  TableColumn<CustomColor, Color> col = new TableColumn<CustomColor, Color>(\"Color\");\n+ *  col.setCellValueFactory(data -> data.getValue().colorProperty());\n+ *\n+ *  col.setCellFactory(p -> {\n+ *    return new TableCell<CustomColor, Color> () {\n+ *        private final Rectangle rectangle;\n+ *        {\n+ *            setContentDisplay(ContentDisplay.GRAPHIC_ONLY);\n+ *            rectangle = new Rectangle(10, 10);\n+ *        }\n+ *\n+ *        @Override\n+ *        protected void updateItem(Color item, boolean empty) {\n+ *          super.updateItem(item, empty);\n+ *\n+ *          if (item == null || empty) {\n+ *              setGraphic(null);\n+ *          } else {\n+ *              rectangle.setFill(item);\n+ *              setGraphic(rectangle);\n+ *          }\n+ *        }\n+ *     };\n+ *  });\n+ *\n+ *  tableview.getColumns().add(col);\n+ *  tableview.setItems(colorList); }<\/pre>\n+ *\n+ * <p> This example has an anonymous custom {@code TableCell} class in the custom cell factory.\n+ * Note that the Rectangle (Node) object needs to be created in the custom {@code TableCell} class\n+ * or in it's constructor and updated\/used in it's updateItem method.<\/p>\n+ *\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableView.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -286,0 +286,110 @@\n+ * <h4>Warning: Nodes should not be inserted directly into the TreeTableView cells<\/h4>\n+ * TreeTableView allows for it's cells to contain elements of any type, including\n+ * {@link Node} instances. Putting nodes into\n+ * the TreeTableView cells is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results.\n+ * <p>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link TreeTableColumn#cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the data stored in the item for that cell.\n+ *\n+ * <p>For example, rather than use the following code:\n+ * <pre>{@code\n+ *  class ColorModel {\n+ *    private SimpleObjectProperty<Rectangle> rect;\n+ *    private StringProperty name;\n+ *\n+ *    public ColorModel (String name, Color col) {\n+ *      this.rect = new SimpleObjectProperty<Rectangle>(new Rectangle(10, 10, col));\n+ *      this.name = new SimpleStringProperty(name);\n+ *    }\n+ *\n+ *    public Rectangle getRect() { return rect.getValue(); }\n+ *    public void setRect(Rectangle r) { rect.setValue(r); }\n+ *    public SimpleObjectProperty<Rectangle> rectProperty() { return rect; }\n+ *\n+ *    public String getName() { return name.getValue(); }\n+ *    public void setName(String s) { name.setValue(s); }\n+ *    public StringProperty nameProperty() { return name; }\n+ *  }\n+ *\n+ *  ColorModel rootModel = new ColorModel(\"Color\", Color.WHITE);\n+ *  TreeItem<ColorModel> treeRoot = new TreeItem<ColorModel>(rootModel);\n+ *  treeRoot.setExpanded(true);\n+ *  treeRoot.getChildren().addAll(\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Red\", Color.RED)),\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Green\", Color.GREEN)),\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Blue\", Color.BLUE)));\n+ *\n+ *  TreeTableView<ColorModel> treeTable = new TreeTableView<ColorModel>(treeRoot);\n+ *\n+ *  TreeTableColumn<ColorModel, String> nameCol = new TreeTableColumn<>(\"Color Name\");\n+ *  TreeTableColumn<ColorModel, Rectangle> rectCol = new TreeTableColumn<>(\"Color\");\n+ *\n+ *  treeTable.getColumns().setAll(nameCol, rectCol);\n+ *  rectCol.setCellValueFactory(p -> p.getValue().getValue().rectProperty());\n+ *  nameCol.setCellValueFactory(p -> p.getValue().getValue().nameProperty());}<\/pre>\n+ *\n+ * <p>You should do the following:<\/p>\n+ * <pre> {@code\n+ *  class ColorModel {\n+ *    private SimpleObjectProperty<Color> color;\n+ *    private StringProperty name;\n+ *\n+ *    public ColorModel (String name, Color col) {\n+ *      this.color = new SimpleObjectProperty<Color>(col);\n+ *      this.name = new SimpleStringProperty(name);\n+ *    }\n+ *\n+ *    public Color getColor() { return color.getValue(); }\n+ *    public void setColor(Color c) { color.setValue(c); }\n+ *    public SimpleObjectProperty<Color> colorProperty() { return color; }\n+ *\n+ *    public String getName() { return name.getValue(); }\n+ *    public void setName(String s) { name.setValue(s); }\n+ *    public StringProperty nameProperty() { return name; }\n+ *  }\n+ *\n+ *  ColorModel rootModel = new ColorModel(\"Color\", Color.WHITE);\n+ *  TreeItem<ColorModel> treeRoot = new TreeItem<ColorModel>(rootModel);\n+ *  treeRoot.setExpanded(true);\n+ *  treeRoot.getChildren().addAll(\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Red\", Color.RED)),\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Green\", Color.GREEN)),\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Blue\", Color.BLUE)));\n+ *\n+ *  TreeTableView<ColorModel> treeTable = new TreeTableView<ColorModel>(treeRoot);\n+ *\n+ *  TreeTableColumn<ColorModel, String> nameCol = new TreeTableColumn<>(\"Color Name\");\n+ *  TreeTableColumn<ColorModel, Color> colorCol = new TreeTableColumn<>(\"Color\");\n+ *\n+ *  treeTable.getColumns().setAll(nameCol, colorCol);\n+ *\n+ *  colorCol.setCellValueFactory(p -> p.getValue().getValue().colorProperty());\n+ *  nameCol.setCellValueFactory(p -> p.getValue().getValue().nameProperty());\n+ *\n+ *  colorCol.setCellFactory(p -> {\n+ *      return new TreeTableCell<ColorModel, Color> () {\n+ *          private final Rectangle rectangle;\n+ *          {\n+ *              setContentDisplay(ContentDisplay.GRAPHIC_ONLY);\n+ *              rectangle = new Rectangle(10, 10);\n+ *          }\n+ *\n+ *          @Override\n+ *          protected void updateItem(Color item, boolean empty) {\n+ *              super.updateItem(item, empty);\n+ *\n+ *              if (item == null || empty) {\n+ *                  setGraphic(null);\n+ *              } else {\n+ *                  rectangle.setFill(item);\n+ *                  setGraphic(rectangle);\n+ *              }\n+ *          }\n+ *      };\n+ *  });}<\/pre>\n+ *\n+ * <p> This example has an anonymous custom {@code TreeTableCell} class in the custom cell factory.\n+ * Note that the Rectangle (Node) object needs to be created in the custom {@code TreeTableCell} class\n+ * or in it's constructor and updated\/used in it's updateItem method.<\/p>\n+ *\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableView.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,54 @@\n+ * <h3>Warning: Nodes should not be inserted directly into the TreeView cells<\/h3>\n+ * TreeView allows for it's cells to contain elements of any type, including\n+ * {@code Node} instances. Putting nodes into\n+ * the TreeView cells is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results.\n+ * <p>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link #cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the\n+ * data stored in the item for that cell.\n+ *\n+ * <p>For example, rather than use the following code:\n+ * <pre>{@code   TreeItem<Rectangle> treeRoot = new TreeItem<>();\n+ *  treeRoot.setExpanded(true);\n+ *  treeRoot.getChildren().addAll(\n+ *      new TreeItem<>(new Rectangle(10, 10, Color.RED)),\n+ *      new TreeItem<>(new Rectangle(10, 10, Color.GREEN)),\n+ *      new TreeItem<>(new Rectangle(10, 10, Color.BLUE))\n+ *  );\n+ *  TreeView<Rectangle> treeView = new TreeView<>(treeRoot);}<\/pre>\n+ *\n+ * <p>You should do the following:<\/p>\n+ * <pre> {@code  TreeItem<Color> treeRoot = new TreeItem<>();\n+ *  treeRoot.setExpanded(true);\n+ *  TreeView<Color> treeView = new TreeView<>(treeRoot);\n+ *\n+ *  treeRoot.getChildren().addAll(\n+ *      new TreeItem<>(Color.RED),\n+ *      new TreeItem<>(Color.GREEN),\n+ *      new TreeItem<>(Color.BLUE));\n+ *\n+ *  treeView.setCellFactory(p -> {\n+ *      return new TreeCell<Color>() {\n+ *      private final Rectangle rectangle;\n+ *      {\n+ *          setContentDisplay(ContentDisplay.GRAPHIC_ONLY);\n+ *          rectangle = new Rectangle(10, 10);\n+ *      }\n+ *\n+ *      @Override\n+ *      protected void updateItem(Color item, boolean empty) {\n+ *          super.updateItem(item, empty);\n+ *\n+ *          if (item == null || empty) {\n+ *              setGraphic(null);\n+ *          } else {\n+ *              rectangle.setFill(item);\n+ *              setGraphic(rectangle);\n+ *          }\n+ *      }\n+ *  };});}<\/pre>\n+ * <p> This example has an anonymous custom {@code TreeCell} class in the custom cell factory.\n+ * Note that the Rectangle (Node) object needs to be created in the custom {@code TreeCell} class\n+ * or in it's constructor and updated\/used in it's updateItem method.<\/p>\n+ *\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeView.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"}]}