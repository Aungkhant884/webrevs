{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,2 +126,2 @@\n- * <h2>A warning about inserting Nodes into the ComboBox items list<\/h2>\n- * ComboBox allows for the items list to contain elements of any type, including\n+ * <h2>Warning: Nodes should not be inserted directly into the ComboBox items list<\/h2>\n+ * {@code ComboBox} allows for the items list to contain elements of any type, including\n@@ -129,1 +129,2 @@\n- * the items list is <strong>strongly not recommended<\/strong>. This is because\n+ * the items list is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results. This is because\n@@ -137,12 +138,10 @@\n- * <p>The recommended approach, rather than inserting Node instances into the\n- * items list, is to put the relevant information into the ComboBox, and then\n- * provide a custom {@link #cellFactoryProperty() cell factory}. For example,\n- * rather than use the following code:\n- *\n- * <pre> {@code ComboBox<Rectangle> cmb = new ComboBox<>();\n- * cmb.getItems().addAll(\n- *     new Rectangle(10, 10, Color.RED),\n- *     new Rectangle(10, 10, Color.GREEN),\n- *     new Rectangle(10, 10, Color.BLUE));}}<\/pre>\n- *\n- * <p>You should do the following:<\/p>\n+ *<p>Important points to note:\n+ * <ul>\n+ * <li>Avoid inserting {@code Node} instances directly into the {@code ComboBox} items list or its data model.<\/li>\n+ * <li>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link #cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the data stored in the item for that cell.<\/li>\n+ * <li>Avoid creating new {@code Node}s in the {@code updateItem} method of\n+ * a custom {@link #cellFactoryProperty() cell factory}.<\/li>\n+ * <\/ul>\n+ * <p>The following minimal example shows how to create a custom cell factory for {@code ComboBox} containing {@code Node}s:\n@@ -176,0 +175,3 @@\n+ * <p> This example has an anonymous custom {@code ListCell} class in the custom cell factory.\n+ * Note that the {@code Rectangle} ({@code Node}) object needs to be created in the instance initialization block\n+ * or the constructor of the custom {@code ListCell} class and updated\/used in its {@code updateItem} method.\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ComboBox.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,44 @@\n- * description of how to write custom Cells.\n+ * description of how to write custom Cells.<\/p>\n+ *\n+ * <h3>Warning: Nodes should not be inserted directly into the items list<\/h3>\n+ * {@code ListView} allows for the items list to contain elements of any type, including\n+ * {@link Node} instances. Putting nodes into\n+ * the items list is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results.\n+ * <p>Important points to note:\n+ * <ul>\n+ * <li>Avoid inserting {@code Node} instances directly into the items list or its data model.<\/li>\n+ * <li>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link #cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the data stored in the item for that cell.<\/li>\n+ * <li>Avoid creating new {@code Node}s in the {@code updateItem} method of a custom {@link #cellFactoryProperty() cell factory}.<\/li>\n+ * <\/ul>\n+ * <p>The following minimal example shows how to create a custom cell factory for {@code ListView} containing {@code Node}s:\n+ *\n+ * <pre>{@code   ListView<Color> lv = new ListView<>();\n+ *  lv.getItems().addAll(Color.RED, Color.GREEN, Color.BLUE);\n+ *\n+ *  lv.setCellFactory(p -> {\n+ *    return new ListCell<>() {\n+ *        private final Rectangle rectangle;\n+ *        {\n+ *            setContentDisplay(ContentDisplay.GRAPHIC_ONLY);\n+ *            rectangle = new Rectangle(10, 10);\n+ *        }\n+ *\n+ *        @Override\n+ *        protected void updateItem(Color item, boolean empty) {\n+ *            super.updateItem(item, empty);\n+ *\n+ *            if (item == null || empty) {\n+ *                setGraphic(null);\n+ *            } else {\n+ *                rectangle.setFill(item);\n+ *                setGraphic(rectangle);\n+ *            }\n+ *         }\n+ *     };\n+ * });}<\/pre>\n+ * <p> This example has an anonymous custom {@code ListCell} class in the custom cell factory.\n+ * Note that the {@code Rectangle} ({@code Node}) object needs to be created in the instance initialization block\n+ * or the constructor of the custom {@code ListCell} class and updated\/used in its {@code updateItem} method.\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ListView.java","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -259,0 +259,67 @@\n+ * <h4>Warning: Nodes should not be inserted directly into the TableView cells<\/h4>\n+ * {@code TableView} allows for it's cells to contain elements of any type, including\n+ * {@link Node} instances. Putting nodes into\n+ * the TableView cells is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results.\n+ *\n+ * <p>Important points to note:\n+ * <ul>\n+ * <li>Avoid inserting {@code Node} instances directly into the {@code TableView} cells or its data model.<\/li>\n+ * <li>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link TableColumn#cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the data stored in the item for that cell.<\/li>\n+ * <li>Avoid creating new {@code Node}s in the {@code updateItem} method of a custom {@link TableColumn#cellFactoryProperty() cell factory}.<\/li>\n+ * <\/ul>\n+ * <p>The following minimal example shows how to create a custom cell factory for {@code TableView} containing {@code Node}s:\n+ * <pre> {@code\n+ *  class CustomColor {\n+ *    private SimpleObjectProperty<Color> color;\n+ *\n+ *    CustomColor(Color col) {\n+ *      this.color = new SimpleObjectProperty<Color>(col);\n+ *    }\n+ *    public Color getColor() { return color.getValue(); }\n+ *    public void setColor(Color c) { color.setValue(c); }\n+ *    public SimpleObjectProperty<Color> colorProperty() { return color; }\n+ *  }\n+ *\n+ *  TableView<CustomColor> tableview = new TableView<CustomColor>();\n+ *\n+ *  ObservableList<CustomColor> colorList = FXCollections.observableArrayList();\n+ *  colorList.addAll(\n+ *      new CustomColor(Color.RED),\n+ *      new CustomColor(Color.GREEN),\n+ *      new CustomColor(Color.BLUE));\n+ *\n+ *  TableColumn<CustomColor, Color> col = new TableColumn<CustomColor, Color>(\"Color\");\n+ *  col.setCellValueFactory(data -> data.getValue().colorProperty());\n+ *\n+ *  col.setCellFactory(p -> {\n+ *    return new TableCell<CustomColor, Color> () {\n+ *        private final Rectangle rectangle;\n+ *        {\n+ *            setContentDisplay(ContentDisplay.GRAPHIC_ONLY);\n+ *            rectangle = new Rectangle(10, 10);\n+ *        }\n+ *\n+ *        @Override\n+ *        protected void updateItem(Color item, boolean empty) {\n+ *          super.updateItem(item, empty);\n+ *\n+ *          if (item == null || empty) {\n+ *              setGraphic(null);\n+ *          } else {\n+ *              rectangle.setFill(item);\n+ *              setGraphic(rectangle);\n+ *          }\n+ *        }\n+ *     };\n+ *  });\n+ *\n+ *  tableview.getColumns().add(col);\n+ *  tableview.setItems(colorList); }<\/pre>\n+ *\n+ * <p> This example has an anonymous custom {@code TableCell} class in the custom cell factory.\n+ * Note that the {@code Rectangle} ({@code Node}) object needs to be created in the instance initialization block\n+ * or the constructor of the custom {@code TableCell} class and updated\/used in its {@code updateItem} method.\n+ *\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableView.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -286,0 +286,78 @@\n+ * <h4>Warning: Nodes should not be inserted directly into the TreeTableView cells<\/h4>\n+ * {@code TreeTableView} allows for it's cells to contain elements of any type, including\n+ * {@link Node} instances. Putting nodes into\n+ * the TreeTableView cells is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results.\n+ *\n+ * <p>Important points to note:\n+ * <ul>\n+ * <li>Avoid inserting {@code Node} instances directly into the {@code TreeTableView} cells or its data model.<\/li>\n+ * <li>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link TreeTableColumn#cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the data stored in the item for that cell.<\/li>\n+ * <li>Avoid creating new {@code Node}s in the {@code updateItem} method of a custom {@link TreeTableColumn#cellFactoryProperty() cell factory}.<\/li>\n+ * <\/ul>\n+ * <p>The following minimal example shows how to create a custom cell factory for {@code TreeTableView} containing {@code Node}s:\n+ * <pre> {@code\n+ *  class ColorModel {\n+ *    private SimpleObjectProperty<Color> color;\n+ *    private StringProperty name;\n+ *\n+ *    public ColorModel (String name, Color col) {\n+ *      this.color = new SimpleObjectProperty<Color>(col);\n+ *      this.name = new SimpleStringProperty(name);\n+ *    }\n+ *\n+ *    public Color getColor() { return color.getValue(); }\n+ *    public void setColor(Color c) { color.setValue(c); }\n+ *    public SimpleObjectProperty<Color> colorProperty() { return color; }\n+ *\n+ *    public String getName() { return name.getValue(); }\n+ *    public void setName(String s) { name.setValue(s); }\n+ *    public StringProperty nameProperty() { return name; }\n+ *  }\n+ *\n+ *  ColorModel rootModel = new ColorModel(\"Color\", Color.WHITE);\n+ *  TreeItem<ColorModel> treeRoot = new TreeItem<ColorModel>(rootModel);\n+ *  treeRoot.setExpanded(true);\n+ *  treeRoot.getChildren().addAll(\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Red\", Color.RED)),\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Green\", Color.GREEN)),\n+ *      new TreeItem<ColorModel>(new ColorModel(\"Blue\", Color.BLUE)));\n+ *\n+ *  TreeTableView<ColorModel> treeTable = new TreeTableView<ColorModel>(treeRoot);\n+ *\n+ *  TreeTableColumn<ColorModel, String> nameCol = new TreeTableColumn<>(\"Color Name\");\n+ *  TreeTableColumn<ColorModel, Color> colorCol = new TreeTableColumn<>(\"Color\");\n+ *\n+ *  treeTable.getColumns().setAll(nameCol, colorCol);\n+ *\n+ *  colorCol.setCellValueFactory(p -> p.getValue().getValue().colorProperty());\n+ *  nameCol.setCellValueFactory(p -> p.getValue().getValue().nameProperty());\n+ *\n+ *  colorCol.setCellFactory(p -> {\n+ *      return new TreeTableCell<ColorModel, Color> () {\n+ *          private final Rectangle rectangle;\n+ *          {\n+ *              setContentDisplay(ContentDisplay.GRAPHIC_ONLY);\n+ *              rectangle = new Rectangle(10, 10);\n+ *          }\n+ *\n+ *          @Override\n+ *          protected void updateItem(Color item, boolean empty) {\n+ *              super.updateItem(item, empty);\n+ *\n+ *              if (item == null || empty) {\n+ *                  setGraphic(null);\n+ *              } else {\n+ *                  rectangle.setFill(item);\n+ *                  setGraphic(rectangle);\n+ *              }\n+ *          }\n+ *      };\n+ *  });}<\/pre>\n+ *\n+ * <p> This example has an anonymous custom {@code TreeTableCell} class in the custom cell factory.\n+ * Note that the {@code Rectangle} ({@code Node}) object needs to be created in the instance initialization block\n+ * or the constructor of the custom {@code TreeTableCell} class and updated\/used in its {@code updateItem} method.\n+ *\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableView.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,49 @@\n+ * <h3>Warning: Nodes should not be inserted directly into the TreeView cells<\/h3>\n+ * {@code TreeView} allows for it's cells to contain elements of any type, including\n+ * {@code Node} instances. Putting nodes into\n+ * the TreeView cells is <strong>strongly discouraged<\/strong>, as it can\n+ * lead to unexpected results.\n+ * <p>Important points to note:\n+ * <ul>\n+ * <li>Avoid inserting {@code Node} instances directly into the {@code TreeView} cells or its data model.<\/li>\n+ * <li>The recommended approach is to put the relevant information into the items list, and\n+ * provide a custom {@link #cellFactoryProperty() cell factory} to create the nodes for a\n+ * given cell and update them on demand using the data stored in the item for that cell.<\/li>\n+ * <li>Avoid creating new {@code Node}s in the {@code updateItem} method of a custom {@link #cellFactoryProperty() cell factory}.<\/li>\n+ * <\/ul>\n+ * <p>The following minimal example shows how to create a custom cell factory for {@code TreeView} containing {@code Node}s:\n+ *\n+ * <pre> {@code  TreeItem<Color> treeRoot = new TreeItem<>();\n+ *  treeRoot.setExpanded(true);\n+ *  TreeView<Color> treeView = new TreeView<>(treeRoot);\n+ *\n+ *  treeRoot.getChildren().addAll(\n+ *      new TreeItem<>(Color.RED),\n+ *      new TreeItem<>(Color.GREEN),\n+ *      new TreeItem<>(Color.BLUE));\n+ *\n+ *  treeView.setCellFactory(p -> {\n+ *      return new TreeCell<Color>() {\n+ *      private final Rectangle rectangle;\n+ *      {\n+ *          setContentDisplay(ContentDisplay.GRAPHIC_ONLY);\n+ *          rectangle = new Rectangle(10, 10);\n+ *      }\n+ *\n+ *      @Override\n+ *      protected void updateItem(Color item, boolean empty) {\n+ *          super.updateItem(item, empty);\n+ *\n+ *          if (item == null || empty) {\n+ *              setGraphic(null);\n+ *          } else {\n+ *              rectangle.setFill(item);\n+ *              setGraphic(rectangle);\n+ *          }\n+ *      }\n+ *  };});}<\/pre>\n+ *\n+ * <p> This example has an anonymous custom {@code TreeCell} class in the custom cell factory.\n+ * Note that the {@code Rectangle} ({@code Node}) object needs to be created in the instance initialization block\n+ * or the constructor of the custom {@code TreeCell} class and updated\/used in its {@code updateItem} method.\n+ *\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeView.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"}]}