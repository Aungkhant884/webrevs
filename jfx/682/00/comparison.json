{"files":[{"patch":"@@ -220,7 +220,0 @@\n-            \/\/ RT-15127: cancel editing on scroll. This is a bit extreme\n-            \/\/ (we are cancelling editing on touching the scrollbars).\n-            \/\/ This can be improved at a later date.\n-            if (control.getEditingIndex() > -1) {\n-                control.edit(-1);\n-            }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ListViewSkin.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,7 +101,0 @@\n-            \/\/ RT-15127: cancel editing on scroll. This is a bit extreme\n-            \/\/ (we are cancelling editing on touching the scrollbars).\n-            \/\/ This can be improved at a later date.\n-            if (control.getEditingCell() != null) {\n-                control.edit(-1, null);\n-            }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableViewSkin.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -147,7 +147,0 @@\n-            \/\/ RT-15127: cancel editing on scroll. This is a bit extreme\n-            \/\/ (we are cancelling editing on touching the scrollbars).\n-            \/\/ This can be improved at a later date.\n-            if (control.getEditingCell() != null) {\n-                control.edit(-1, null);\n-            }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableViewSkin.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -169,7 +169,0 @@\n-            \/\/ RT-15127: cancel editing on scroll. This is a bit extreme\n-            \/\/ (we are cancelling editing on touching the scrollbars).\n-            \/\/ This can be improved at a later date.\n-            if (control.getEditingItem() != null) {\n-                control.edit(null);\n-            }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeViewSkin.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.List;\n+\n@@ -32,0 +34,1 @@\n+import javafx.scene.control.Skin;\n@@ -113,0 +116,30 @@\n+    \/**\n+     * Returns the VirtualFlow managed by the given skin.\n+     *\/\n+    public static <T extends IndexedCell<?>> VirtualFlow<T> getVirtualFlow(Skin<?> skin) {\n+        return ((VirtualContainerBase<?, T>) skin).getVirtualFlow();\n+    }\n+\n+    \/**\n+     * Returns the list of cells displayed in the viewport of the flow.\n+     *\n+     * @see VirtualFlow#getCells()\n+     *\/\n+    public static <T extends IndexedCell<?>> List<T> getCells(VirtualFlow<T> flow) {\n+        return flow.getCells();\n+    }\n+\n+    \/**\n+     * Returns the vertical scrollbar of the given flow.\n+     *\/\n+    public static ScrollBar getVBar(VirtualFlow<?> flow) {\n+        return flow.getVbar();\n+    }\n+\n+    \/**\n+     * Returns the horizontal scrollbar of the given flow.\n+     *\/\n+    public static ScrollBar getHBar(VirtualFlow<?> flow) {\n+        return flow.getHbar();\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/skin\/VirtualFlowShim.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,533 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control.skin;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.sun.javafx.tk.Toolkit;\n+\n+import static javafx.scene.control.skin.VirtualFlowShim.*;\n+import static org.junit.Assert.*;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.geometry.Orientation;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.ListView;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.ScrollBar;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TablePosition;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTablePosition;\n+import javafx.scene.control.TreeTableView;\n+import javafx.scene.control.TreeView;\n+import javafx.scene.control.cell.PropertyValueFactory;\n+import javafx.scene.control.cell.TextFieldListCell;\n+import javafx.scene.control.cell.TextFieldTableCell;\n+import javafx.scene.control.cell.TextFieldTreeCell;\n+import javafx.scene.control.cell.TextFieldTreeTableCell;\n+import javafx.scene.control.cell.TreeItemPropertyValueFactory;\n+import javafx.scene.control.skin.VirtualContainerBase;\n+import javafx.scene.control.skin.VirtualFlow;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.Stage;\n+import javafx.util.converter.DefaultStringConverter;\n+import test.com.sun.javafx.scene.control.infrastructure.MouseEventFirer;\n+\n+\/**\n+ * Test scrolling while editing, mainly fix for JDK-8272118 - do not cancel edit on mouse click.\n+ *\n+ * The basic test strategy is:\n+ *\n+ * - for each virtualized control and for each scroll direction,\n+ * - create and show the control such it is large enough in be scrollable\n+ *\n+ * Test the fix:\n+ *\n+ * - start editing a cell in the viewport\n+ * - click on the scrollBar to scroll the cell off the viewport and verify that\n+ *   control is still editing\n+ *\n+ * Test that clicking is still requesting focus:\n+ *\n+ * - add a focused control to the scene\n+ * - click on the scrollBar and verify that the control is focusOwner\n+ *\n+ *\/\n+public class EditAndScrollTest {\n+\n+    private Scene scene;\n+    private Stage stage;\n+    private Pane root;\n+\n+    int rows;\n+    int editingRow;\n+\n+\/\/----------------- TreeTableView\n+\n+    @Test\n+    public void testTreeTableViewEditingAfterMouseOnVerticalScrollBar() {\n+        TreeTableView<?> control = createAndShowTreeTableView(true);\n+        TreeTablePosition<?, ?> editingItem = new TreeTablePosition(control, editingRow, control.getColumns().get(0));\n+        fireMouseOnVerticalTrack(control);\n+        assertEquals(editingItem, control.getEditingCell());\n+    }\n+\n+    @Test\n+    public void testTreeTableViewEditingAfterMouseOnHorizontalScrollBar() {\n+        TreeTableView<?> control = createAndShowTreeTableView(true);\n+        TreeTablePosition<?, ?> editingItem = new TreeTablePosition(control, editingRow, control.getColumns().get(0));\n+        fireMouseOnHorizontalTrack(control);\n+        assertEquals(editingItem, control.getEditingCell());\n+    }\n+\n+    @Test\n+    public void testTreeTableViewFocusedAfterMouseOnVerticalScrollBar() {\n+        TreeTableView<?> control = createAndShowTreeTableView(false);\n+        assertFocusedAfterMouseOnScrollBar(control, Orientation.VERTICAL);\n+    }\n+\n+    @Test\n+    public void testTreeTableViewFocusedAfterMouseOnHorizontalScrollBar() {\n+        TreeTableView<?> control = createAndShowTreeTableView(false);\n+        assertFocusedAfterMouseOnScrollBar(control, Orientation.HORIZONTAL);\n+    }\n+\n+    \/**\n+     * Test the test setup for TreeTableView.\n+     *\/\n+    @Test\n+    public void testTreeTableViewEditing() {\n+        TreeTableView<?> control = createAndShowTreeTableView(true);\n+        assertEquals(rows + 1, control.getExpandedItemCount());\n+        assertEquals(100, scene.getWidth(), 1);\n+        assertEquals(330, scene.getHeight(), 1);\n+        assertTrue(\"sanity: vertical scrollbar visible for list \" ,\n+                getHorizontalScrollBar(control).isVisible());\n+        assertTrue(\"sanity: vertical scrollbar visible for list \" ,\n+                getVerticalScrollBar(control).isVisible());\n+        TreeTablePosition<?, ?> editingItem = new TreeTablePosition(control, editingRow, control.getColumns().get(0));\n+        assertEquals(\"control must be editing at\", editingItem, control.getEditingCell());\n+    }\n+\n+    \/**\n+     * Creates and shows a TableView configured to be\n+     * - not\/editing depending on the startEdit\n+     * - scrollable both horizontally and vertically\n+     *\/\n+    private TreeTableView<?> createAndShowTreeTableView(boolean startEdit) {\n+        TreeItem<MenuItem> root = new TreeItem<>(new MenuItem(\"root\"));\n+        root.setExpanded(true);\n+        ObservableList<String> baseData = createData(rows, false);\n+        baseData.forEach(s -> root.getChildren().add(new TreeItem<>(new MenuItem(s))));\n+        TreeTableView<MenuItem> control = new TreeTableView<>(root);\n+        control.setEditable(true);\n+        TreeTableColumn<MenuItem, String> first = createTreeTableColumn();\n+        control.getColumns().addAll(first);\n+        for (int i = 0; i < 10; i++) {\n+            control.getColumns().add(createTreeTableColumn());\n+        }\n+        showControl(control, true, 100, 330);\n+        if (startEdit) {\n+            control.edit(editingRow, first);\n+        }\n+        return control;\n+    }\n+\n+    private TreeTableColumn<MenuItem, String> createTreeTableColumn() {\n+        TreeTableColumn<MenuItem, String> first = new TreeTableColumn<>(\"Text\");\n+        first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());\n+        first.setCellValueFactory(new TreeItemPropertyValueFactory<>(\"text\"));\n+        return first;\n+    }\n+\n+\n+\/\/----------------- TableView\n+\n+    @Test\n+    public void testTableViewEditingAfterMouseOnVerticalScrollBar() {\n+        TableView<?> control = createAndShowTableView(true);\n+        TablePosition<?, ?> editingItem = new TablePosition(control, editingRow, control.getColumns().get(0));\n+        fireMouseOnVerticalTrack(control);\n+        assertEquals(editingItem, control.getEditingCell());\n+    }\n+\n+    @Test\n+    public void testTableViewEditingAfterMouseOnHorizontalScrollBar() {\n+        TableView<?> control = createAndShowTableView(true);\n+        TablePosition<?, ?> editingItem = new TablePosition(control, editingRow, control.getColumns().get(0));\n+        fireMouseOnHorizontalTrack(control);\n+        assertEquals(editingItem, control.getEditingCell());\n+    }\n+\n+    @Test\n+    public void testTableViewFocusedAfterMouseOnVerticalScrollBar() {\n+        TableView<?> control = createAndShowTableView(false);\n+        assertFocusedAfterMouseOnScrollBar(control, Orientation.VERTICAL);\n+    }\n+\n+    @Test\n+    public void testTableViewFocusedAfterMouseOnHorizontalScrollBar() {\n+        TableView<?> control = createAndShowTableView(false);\n+        assertFocusedAfterMouseOnScrollBar(control, Orientation.HORIZONTAL);\n+    }\n+\n+    \/**\n+     * Test the test setup for TreeView.\n+     *\/\n+    @Test\n+    public void testTableViewEditing() {\n+        TableView<?> control = createAndShowTableView(true);\n+        assertEquals(rows, control.getItems().size());\n+        assertEquals(100, scene.getWidth(), 1);\n+        assertEquals(330, scene.getHeight(), 1);\n+        assertTrue(\"sanity: vertical scrollbar visible for list \" ,\n+                getHorizontalScrollBar(control).isVisible());\n+        assertTrue(\"sanity: vertical scrollbar visible for list \" ,\n+                getVerticalScrollBar(control).isVisible());\n+        TablePosition<?, ?> editingItem = new TablePosition(control, editingRow, control.getColumns().get(0));\n+        assertEquals(\"control must be editing at\", editingItem, control.getEditingCell());\n+    }\n+\n+    \/**\n+     * Creates and shows a TableView configured to be\n+     * - not\/editing depending on the startEdit\n+     * - scrollable both horizontally and vertically\n+     *\/\n+    private TableView<?> createAndShowTableView(boolean startEdit) {\n+        TableView<MenuItem> control = new TableView<>();\n+        createData(60, false).forEach(s -> control.getItems().add(new MenuItem(s)));\n+        control.setEditable(true);\n+        TableColumn<MenuItem, String> first = createColumn();\n+        control.getColumns().addAll(first);\n+        for (int i = 0; i < 10; i++) {\n+            control.getColumns().add(createColumn());\n+        }\n+        showControl(control, true, 100, 330);\n+        if (startEdit) {\n+            control.edit(editingRow, first);\n+        }\n+        return control;\n+    }\n+\n+    private TableColumn<MenuItem, String> createColumn() {\n+        TableColumn<MenuItem, String> first = new TableColumn<>(\"Text\");\n+        first.setCellFactory(TextFieldTableCell.forTableColumn());\n+        first.setCellValueFactory(new PropertyValueFactory<>(\"text\"));\n+        return first;\n+    }\n+\n+\n+\/\/----------------- TreeView\n+\n+    @Test\n+    public void testTreeViewEditingAfterMouseOnVerticalScrollBar() {\n+        TreeView<?> control = createAndShowTreeView(true);\n+        TreeItem<?> editingItem = control.getTreeItem(editingRow);\n+        fireMouseOnVerticalTrack(control);\n+        assertEquals(editingItem, control.getEditingItem());\n+    }\n+\n+    @Test\n+    public void testTreeViewEditingAfterMouseOnHorizontalScrollBar() {\n+        TreeView<?> control = createAndShowTreeView(true);\n+        TreeItem<?> editingItem = control.getTreeItem(editingRow);\n+        fireMouseOnHorizontalTrack(control);\n+        assertEquals(editingItem, control.getEditingItem());\n+    }\n+\n+    @Test\n+    public void testTreeViewFocusedAfterMouseOnVerticalScrollBar() {\n+        TreeView<?> control = createAndShowTreeView(false);\n+        assertFocusedAfterMouseOnScrollBar(control, Orientation.VERTICAL);\n+    }\n+\n+    @Test\n+    public void testTreeViewFocusedAfterMouseOnHorizontalScrollBar() {\n+        TreeView<?> control = createAndShowTreeView(false);\n+        assertFocusedAfterMouseOnScrollBar(control, Orientation.HORIZONTAL);\n+    }\n+\n+    \/**\n+     * Test the test setup for TreeView.\n+     *\/\n+    @Test\n+    public void testTreeViewEditing() {\n+        TreeView<?> control = createAndShowTreeView(true);\n+        assertEquals(rows + 1, control.getExpandedItemCount());\n+        assertEquals(100, scene.getWidth(), 1);\n+        assertEquals(330, scene.getHeight(), 1);\n+        assertTrue(\"sanity: vertical scrollbar visible for list \" ,\n+                getHorizontalScrollBar(control).isVisible());\n+        assertTrue(\"sanity: vertical scrollbar visible for list \" ,\n+                getVerticalScrollBar(control).isVisible());\n+        TreeItem<?> editingItem = control.getTreeItem(editingRow);\n+        assertEquals(\"control must be editing at\", editingItem, control.getEditingItem());\n+    }\n+\n+    \/**\n+     * Creates and shows a TreeView configured to be\n+     * - not\/editing depending on the startEdit\n+     * - scrollable both horizontally and vertically\n+     *\/\n+    private TreeView<?> createAndShowTreeView(boolean startEdit) {\n+        TreeItem<String> root = new TreeItem<>(\"root\");\n+        root.setExpanded(true);\n+        ObservableList<String> baseData = createData(rows, true);\n+        baseData.forEach(s -> root.getChildren().add(new TreeItem<>(s)));\n+        TreeView<String> control = new TreeView<>(root);\n+        control.setEditable(true);\n+        control.setCellFactory(TextFieldTreeCell.forTreeView(new DefaultStringConverter()));\n+        showControl(control, true, 100, 330);\n+        if (startEdit) {\n+            TreeItem<String> editingItem = control.getTreeItem(editingRow);\n+            control.edit(editingItem);\n+        }\n+        return control;\n+    }\n+\n+\n+\/\/----------------- ListView\n+\n+    @Test\n+    public void testListViewEditingAfterMouseOnVerticalScrollBar() {\n+        ListView<?> control = createAndShowListView(true);\n+        fireMouseOnVerticalTrack(control);\n+        assertEquals(editingRow, control.getEditingIndex());\n+    }\n+\n+    @Test\n+    public void testListViewEditingAfterMouseOnHorizontalScrollBar() {\n+        ListView<?> control = createAndShowListView(true);\n+        fireMouseOnHorizontalTrack(control);\n+        assertEquals(editingRow, control.getEditingIndex());\n+    }\n+\n+    @Test\n+    public void testListViewFocusedAfterMouseOnVerticalScrollBar() {\n+        ListView<?> control = createAndShowListView(false);\n+        assertFocusedAfterMouseOnScrollBar(control, Orientation.VERTICAL);\n+    }\n+\n+    @Test\n+    public void testListViewFocusedAfterMouseOnHorizontalScrollBar() {\n+        ListView<?> control = createAndShowListView(false);\n+        assertFocusedAfterMouseOnScrollBar(control, Orientation.HORIZONTAL);\n+    }\n+\n+    \/**\n+     * Test the test setup for ListView.\n+     *\/\n+    @Test\n+    public void testListViewEditing() {\n+        ListView<?> control = createAndShowListView(true);\n+        assertEquals(rows, control.getItems().size());\n+        assertEquals(100, scene.getWidth(), 1);\n+        assertEquals(330, scene.getHeight(), 1);\n+        assertTrue(\"sanity: vertical scrollbar visible for list \" ,\n+                getHorizontalScrollBar(control).isVisible());\n+        assertTrue(\"sanity: vertical scrollbar visible for list \" ,\n+                getVerticalScrollBar(control).isVisible());\n+        assertEquals(\"control must be editing at\", editingRow, control.getEditingIndex());\n+    }\n+\n+    \/**\n+     * Creates and shows a ListView configured to be\n+     * - not\/editing depending on the startEdit\n+     * - scrollable both horizontally and vertically\n+     *\/\n+    private ListView<?> createAndShowListView(boolean startEdit) {\n+        ObservableList<String> baseData = createData(rows, true);\n+        ListView<String> control = new ListView<>(baseData);\n+        control.setEditable(true);\n+        control.setCellFactory(TextFieldListCell.forListView(new DefaultStringConverter()));\n+        showControl(control, true, 100, 330);\n+        if (startEdit) {\n+            control.edit(editingRow);\n+        }\n+        return control;\n+    }\n+\n+\n+\/\/--------------- test helpers\n+\n+    \/**\n+     * Tests that clicking on the scrollbar in the given direction requests\n+     * focus back to the given control.\n+     *\n+     * Note: the control must be showing in the default scene of this test and\n+     * have a skin of type VirtualContainerBase.\n+     *\n+     *\/\n+    private void assertFocusedAfterMouseOnScrollBar(Control control, Orientation dir) {\n+        \/\/ add and focus additional control\n+        Button focusableControl = new Button(\"dummy\");\n+        showControl(focusableControl, true);\n+        if (dir == Orientation.HORIZONTAL) {\n+           fireMouseOnHorizontalTrack(control);\n+        } else {\n+            fireMouseOnVerticalTrack(control);\n+        }\n+        assertEquals(\"virtualized control must be focusOwner after mouse on scrollbar\",\n+                control, scene.getFocusOwner());\n+    }\n+\n+\n+\/\/----------------- Utility methods (TODO: move into infrastructure)\n+\n+    \/**\n+     * Fires a mouse event onto the middle of the vertical scrollbar's track.\n+     * @throws IllegalStateException if control's skin is not VirtualContainerBase\n+     *\/\n+    public static void fireMouseOnVerticalTrack(Control control) {\n+        ScrollBar scrollBar = getVerticalScrollBar(control);\n+        Region track = (Region) scrollBar.lookup(\".track\");\n+        MouseEventFirer firer = new MouseEventFirer(track, true);\n+        firer.fireMousePressAndRelease();\n+        Toolkit.getToolkit().firePulse();\n+    }\n+\n+    \/**\n+     * Fires a mouse event onto the middle of the horizontal scrollbar's track.\n+     * @throws IllegalStateException if control's skin is not VirtualContainerBase\n+     *\/\n+    public static void fireMouseOnHorizontalTrack(Control control) {\n+        ScrollBar scrollBar = getHorizontalScrollBar(control);\n+        Region track = (Region) scrollBar.lookup(\".track\");\n+        MouseEventFirer firer = new MouseEventFirer(track, true);\n+        firer.fireMousePressAndRelease();\n+        Toolkit.getToolkit().firePulse();\n+    }\n+\n+    \/**\n+     * Returns a vertical ScrollBar of the control.\n+     * @throws IllegalStateException if control's skin is not VirtualContainerBase\n+     *\/\n+    public static ScrollBar getVerticalScrollBar(Control control) {\n+        if (control.getSkin() instanceof VirtualContainerBase) {\n+            VirtualFlow<?> flow = getVirtualFlow((VirtualContainerBase<?, ?>) control.getSkin());\n+            return getVBar(flow);\n+        }\n+        throw new IllegalStateException(\"control's skin must be of type VirtualContainerBase but was: \" + control.getSkin());\n+    }\n+\n+    \/**\n+     * Returns a vertical ScrollBar of the control.\n+     * @throws IllegalStateException if control's skin is not VirtualContainerBase\n+     *\/\n+    public static ScrollBar getHorizontalScrollBar(Control control) {\n+        if (control.getSkin() instanceof VirtualContainerBase) {\n+            VirtualFlow<?> flow = getVirtualFlow((VirtualContainerBase<?, ?>) control.getSkin());\n+            return getHBar(flow);\n+        }\n+        throw new IllegalStateException(\"control's skin must be of type VirtualContainerBase but was: \" + control.getSkin());\n+    }\n+\n+\/\/----------------- setup\n+\n+    \/**\n+     * Creates and returns a list of long\/short (depending on wide parameter) Strings.\n+     *\/\n+    private ObservableList<String> createData(int size, boolean wide) {\n+        ObservableList<String> data = FXCollections.observableArrayList();\n+        String item = wide ? \"something that really really guarantees a horizontal scrollbar is visible  \" : \"item\";\n+        for (int i = 0; i < size; i++) {\n+            data.add(item + i);\n+        }\n+        return data;\n+    }\n+\n+    \/**\n+     * Ensures the control is shown in an active scenegraph. Requests\n+     * focus on the control if focused == true.\n+     *\n+     * @param control the control to show\n+     * @param focused if true, requests focus on the added control\n+     *\/\n+    protected void showControl(Control control, boolean focused) {\n+        showControl(control, focused, -1, -1);\n+    }\n+\n+    \/**\n+     * Ensures the control is shown in an active scenegraph. Requests\n+     * focus on the control if focused == true.\n+     * On first call, sizes the scene to width\/height if width > 0\n+     *\n+     * @param control the control to show\n+     * @param focused if true, requests focus on the added control\n+     * @param width the width of the scene or -1 for auto-sizing\n+     * @param height the height of the scene or -1 for auto-sizing\n+     *\/\n+    protected void showControl(Control control, boolean focused, double width, double height) {\n+        if (root == null) {\n+            root = new VBox();\n+            if (width > 0) {\n+                scene = new Scene(root, width, height);\n+            } else {\n+                scene = new Scene(root);\n+            }\n+            stage = new Stage();\n+            stage.setScene(scene);\n+        }\n+        if (!root.getChildren().contains(control)) {\n+            root.getChildren().add(control);\n+        }\n+        stage.show();\n+        if (focused) {\n+            stage.requestFocus();\n+            control.requestFocus();\n+            assertTrue(control.isFocused());\n+            assertSame(control, scene.getFocusOwner());\n+        }\n+    }\n+\n+    @Before public void setup() {\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+        editingRow = 1;\n+        rows = 60;\n+    }\n+\n+    @After public void cleanup() {\n+        if (stage != null) stage.hide();\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/EditAndScrollTest.java","additions":533,"deletions":0,"binary":false,"changes":533,"status":"added"}]}