{"files":[{"patch":"@@ -91,16 +91,0 @@\n-    }\n-\n-    public Point3D getDirection() {\n-        return SIMULATED_DIRECTION;\n-    }\n-\n-    public float getInnerAngle() {\n-        return SIMULATED_INNER_ANGLE;\n-    }\n-\n-    public float getOuterAngle() {\n-        return SIMULATED_OUTER_ANGLE;\n-    }\n-\n-    public float getFalloff() {\n-        return SIMULATED_FALLOFF;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGPointLight.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.javafx.geom.Vec3f;\n@@ -39,1 +38,0 @@\n-import javafx.geometry.Point3D;\n@@ -121,1 +119,6 @@\n-        \/\/ Setup lights\n+        setupLights(g);\n+\n+        meshView.render(g);\n+    }\n+\n+    private void setupLights(Graphics g) {\n@@ -123,21 +126,4 @@\n-        if (g.getLights() == null || g.getLights()[0] == null) {\n-            \/\/ If no lights are in scene apply default light. Default light\n-            \/\/ is a single white point light at camera eye position.\n-            meshView.setAmbientLight(0.0f, 0.0f, 0.0f);\n-            Vec3d cameraPos = g.getCameraNoClone().getPositionInWorld(null);\n-            meshView.setLight(lightIndex++,\n-                    (float) cameraPos.x,\n-                    (float) cameraPos.y,\n-                    (float) cameraPos.z,\n-                    1.0f, 1.0f, 1.0f, 1.0f,\n-                    NGPointLight.getDefaultCa(),\n-                    NGPointLight.getDefaultLa(),\n-                    NGPointLight.getDefaultQa(),\n-                    1,\n-                    NGPointLight.getDefaultMaxRange(),\n-                    (float) NGPointLight.getSimulatedDirection().getX(),\n-                    (float) NGPointLight.getSimulatedDirection().getY(),\n-                    (float) NGPointLight.getSimulatedDirection().getZ(),\n-                    NGPointLight.getSimulatedInnerAngle(),\n-                    NGPointLight.getSimulatedOuterAngle(),\n-                    NGPointLight.getSimulatedFalloff());\n+        NGLightBase[] lights = g.getLights();\n+        if (noLights(lights)) {\n+            createDefaultLight(g);\n+            lightIndex++;\n@@ -149,1 +135,1 @@\n-            for (NGLightBase lightBase : g.getLights()) {\n+            for (NGLightBase lightBase : lights) {\n@@ -165,0 +151,6 @@\n+                if (lightBase instanceof NGAmbientLight) {\n+                    \/\/ Accumulate ambient lights\n+                    ambientRed   += rL;\n+                    ambientGreen += gL;\n+                    ambientBlue  += bL;\n+                }\n@@ -182,19 +174,4 @@\n-                if (lightBase instanceof NGPointLight) {\n-                    var light = (NGPointLight) lightBase;\n-                    Affine3D lightWT = light.getWorldTransform();\n-                    meshView.setLight(lightIndex++,\n-                            (float) lightWT.getMxt(),\n-                            (float) lightWT.getMyt(),\n-                            (float) lightWT.getMzt(),\n-                            rL, gL, bL, 1.0f,\n-                            light.getCa(),\n-                            light.getLa(),\n-                            light.getQa(),\n-                            1,\n-                            light.getMaxRange(),\n-                            (float) light.getDirection().getX(),\n-                            (float) light.getDirection().getY(),\n-                            (float) light.getDirection().getZ(),\n-                            light.getInnerAngle(),\n-                            light.getOuterAngle(),\n-                            light.getFalloff());\n+                else if (lightBase instanceof NGSpotLight) {\n+                    addSpotLight((NGSpotLight) lightBase, lightIndex++, rL, gL, bL);\n+                } else if (lightBase instanceof NGPointLight) {\n+                    addPointLight((NGPointLight) lightBase, lightIndex++, rL, gL, bL);\n@@ -202,16 +179,1 @@\n-                    var light = (NGDirectionalLight) lightBase;\n-                    meshView.setLight(lightIndex++,\n-                            0, 0, 0,                 \/\/ position is irrelevant\n-                            rL, gL, bL, 1.0f,\n-                            1, 0, 0,                 \/\/ attenuation is irrelevant\n-                            0,\n-                            Float.POSITIVE_INFINITY, \/\/ range is irrelevant\n-                            (float) light.getDirection().getX(),\n-                            (float) light.getDirection().getY(),\n-                            (float) light.getDirection().getZ(),\n-                            0, 0, 0);                \/\/ spotlight factors are irrelevant\n-                } else if (lightBase instanceof NGAmbientLight) {\n-                    \/\/ Accumulate ambient lights\n-                    ambientRed   += rL;\n-                    ambientGreen += gL;\n-                    ambientBlue  += bL;\n+                    addDirectionalLight((NGDirectionalLight) lightBase, lightIndex++, rL, gL, bL);\n@@ -220,4 +182,6 @@\n-            ambientRed = Utils.clamp(0, ambientRed, 1);\n-            ambientGreen = Utils.clamp(0, ambientGreen, 1);\n-            ambientBlue = Utils.clamp(0, ambientBlue, 1);\n-            meshView.setAmbientLight(ambientRed, ambientGreen, ambientBlue);\n+            if (ambientRed != 0.0f || ambientGreen != 0.0f || ambientBlue != 0.0f) {\n+                ambientRed = Utils.clamp(0, ambientRed, 1);\n+                ambientGreen = Utils.clamp(0, ambientGreen, 1);\n+                ambientBlue = Utils.clamp(0, ambientBlue, 1);\n+                meshView.setAmbientLight(ambientRed, ambientGreen, ambientBlue);\n+            }\n@@ -228,6 +192,1 @@\n-            meshView.setLight(lightIndex++,\n-                    0, 0, 0,    \/\/ x y z\n-                    0, 0, 0, 0, \/\/ r g b w\n-                    1, 0, 0, 1, 0, \/\/ ca la qa isAttenuated maxRange\n-                    0, 0, 1,    \/\/ dirX Y Z\n-                    0, 0, 0);   \/\/ inner outer falloff\n+            resetLight(lightIndex++);\n@@ -235,0 +194,1 @@\n+    }\n@@ -236,1 +196,67 @@\n-        meshView.render(g);\n+    private boolean noLights(NGLightBase[] lights) {\n+        return lights == null || lights[0] == null;\n+    }\n+\n+    \/**\n+     * If no lights are in the scene, add a default white point light at the camera's. The light uses the default\n+     * attenuation parameters, which means that it is not attenuated.\n+     *\/\n+    private void createDefaultLight(Graphics g) {\n+        meshView.setAmbientLight(0.0f, 0.0f, 0.0f);\n+        Vec3d cameraPos = g.getCameraNoClone().getPositionInWorld(null);\n+        var direction = NGPointLight.getSimulatedDirection();\n+        meshView.setLight(0,\n+                (float) cameraPos.x, (float) cameraPos.y, (float) cameraPos.z,\n+                1.0f, 1.0f, 1.0f, 1.0f,\n+                NGPointLight.getDefaultCa(), NGPointLight.getDefaultLa(), NGPointLight.getDefaultQa(), 0,\n+                NGPointLight.getDefaultMaxRange(),\n+                (float) direction.getX(), (float) direction.getY(), (float) direction.getZ(),\n+                NGPointLight.getSimulatedInnerAngle(),\n+                NGPointLight.getSimulatedOuterAngle(),\n+                NGPointLight.getSimulatedFalloff());\n+    }\n+\n+    private void addPointLight(NGPointLight light, int lightIndex, float r, float g, float b) {\n+        Affine3D lightWT = light.getWorldTransform();\n+        var direction = NGPointLight.getSimulatedDirection();\n+        meshView.setLight(lightIndex,\n+                (float) lightWT.getMxt(), (float) lightWT.getMyt(), (float) lightWT.getMzt(),\n+                r, g, b, 1.0f,\n+                light.getCa(), light.getLa(), light.getQa(), 1,\n+                light.getMaxRange(),\n+                (float) direction.getX(), (float) direction.getY(), (float) direction.getZ(),\n+                NGPointLight.getSimulatedInnerAngle(),\n+                NGPointLight.getSimulatedOuterAngle(),\n+                NGPointLight.getSimulatedFalloff());\n+    }\n+\n+    private void addSpotLight(NGSpotLight light, int lightIndex, float r, float g, float b) {\n+        Affine3D lightWT = light.getWorldTransform();\n+        var normDir = light.getDirection().normalize();\n+        meshView.setLight(lightIndex,\n+                (float) lightWT.getMxt(), (float) lightWT.getMyt(), (float) lightWT.getMzt(),\n+                r, g, b, 1.0f,\n+                light.getCa(), light.getLa(), light.getQa(), 1,\n+                light.getMaxRange(),\n+                (float) normDir.getX(), (float) normDir.getY(), (float) normDir.getZ(),\n+                light.getInnerAngle(), light.getOuterAngle(), light.getFalloff());\n+    }\n+\n+    private void addDirectionalLight(NGDirectionalLight light, int lightIndex, float r, float g, float b) {\n+        var normDir = light.getDirection().normalize();\n+        meshView.setLight(lightIndex,\n+                0, 0, 0,                 \/\/ position is irrelevant\n+                r, g, b, 1.0f,\n+                1, 0, 0, 0,              \/\/ attenuation is irrelevant\n+                Float.POSITIVE_INFINITY, \/\/ range is irrelevant\n+                (float) normDir.getX(), (float) normDir.getY(), (float) normDir.getZ(),\n+                0, 0, 0);                \/\/ spotlight factors are irrelevant\n+    }\n+\n+    private void resetLight(int lightIndex) {\n+        meshView.setLight(lightIndex,\n+                0, 0, 0,    \/\/ x y z\n+                0, 0, 0, 0, \/\/ r g b lightOn\n+                1, 0, 0, 1, 0, \/\/ ca la qa isAttenuated maxRange\n+                0, 0, 1,    \/\/ dirX Y Z\n+                0, 0, 0);   \/\/ inner outer falloff\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGShape3D.java","additions":97,"deletions":71,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-    @Override\n@@ -88,1 +87,0 @@\n-    @Override\n@@ -103,1 +101,0 @@\n-    @Override\n@@ -118,1 +115,0 @@\n-    @Override\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGSpotLight.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,15 +34,0 @@\n-D3DLight::~D3DLight() {\n-}\n-\n-D3DLight::D3DLight() :\n-    color(),\n-    position(),\n-    w(0),\n-    attenuation(),\n-    maxRange(0),\n-    direction(),\n-    innerAngle(0),\n-    outerAngle(0),\n-    falloff(0)\n-    {}\n-\n@@ -54,1 +39,1 @@\n-    \/\/ testing if w is 0 or 1 using <0.5 since equality check for floating points might not work well\n+    \/\/ testing if attenuation.w is 0 or 1 using <0.5 since equality check for floating points might not work well\n@@ -58,11 +43,11 @@\n-void D3DLight::setColor(float r, float g, float b) {\n-    color[0] = r;\n-    color[1] = g;\n-    color[2] = b;\n-}\n-\n-void D3DLight::setPosition(float x, float y, float z) {\n-    position[0] = x;\n-    position[1] = y;\n-    position[2] = z;\n-}\n+\/\/void D3DLight::setColor(float r, float g, float b) {\n+\/\/    color[0] = r;\n+\/\/    color[1] = g;\n+\/\/    color[2] = b;\n+\/\/}\n+\/\/\n+\/\/void D3DLight::setPosition(float x, float y, float z) {\n+\/\/    position[0] = x;\n+\/\/    position[1] = y;\n+\/\/    position[2] = z;\n+\/\/}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DLight.cc","additions":12,"deletions":27,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-#include \"D3DContext.h\"\n+\/\/#include <iostream>\n+\/\/#include \"D3DContext.h\"\n@@ -35,2 +36,2 @@\n-    D3DLight();\n-    virtual ~D3DLight();\n+    D3DLight() = default;\n+    virtual ~D3DLight() = default;\n@@ -39,12 +40,23 @@\n-    void setColor(float r, float g, float b);\n-    void setPosition(float x, float y, float z);\n-\n-    float position[3];\n-    float color[3];\n-    float w;\n-    float attenuation[4]; \/\/ ca, la, qa, isAttenuated\n-    float maxRange;\n-    float direction[3];\n-    float innerAngle;\n-    float outerAngle;\n-    float falloff;\n+\/\/    void setColor(float r, float g, float b);\n+\/\/    void setPosition(float x, float y, float z);\n+\n+    float position[3] = {0};\n+    float color[3] = {0};\n+    float lightOn = 0;\n+    float attenuation[4] = {0}; \/\/ ca, la, qa, isAttenuated\n+    float maxRange = 0;\n+    float direction[3] = {0};\n+    float innerAngle = 0;\n+    float outerAngle = 0;\n+    float falloff = 0;\n+\n+\/\/    void printString() {\n+\/\/        std::cout << \"Light\" << std::endl;\n+\/\/        std::cout << \"position = \" << position[0] << \", \" << position[1] << \", \" << position[2] << std::endl;\n+\/\/        std::cout << \"color = \" << color[0] << \", \" << color[1] << \", \" << color[2] << std::endl;\n+\/\/        std::cout << \"w = \" << w << std::endl;\n+\/\/        std::cout << \"attenuation = \" << attenuation[0] << \", \" << attenuation[1] << \", \" << attenuation[2] << \", \" << attenuation[3] << std::endl;\n+\/\/        std::cout << \"maxRange = \" << maxRange << std::endl;\n+\/\/        std::cout << \"innerAngle = \" << innerAngle << std::endl;\n+\/\/        std::cout << \"----------\" << std::endl;\n+\/\/    }\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DLight.h","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -44,13 +44,4 @@\n-D3DMeshView::D3DMeshView(D3DContext *ctx, D3DMesh *pMesh) {\n-    context = ctx;\n-    mesh = pMesh;\n-    material = NULL;\n-    ambientLightColor[0] = 0;\n-    ambientLightColor[1] = 0;\n-    ambientLightColor[2] = 0;\n-    numLights = 0;\n-    ZeroMemory(lights, sizeof(D3DLight) * 3);\n-    lightsDirty = TRUE;\n-    cullMode = D3DCULL_NONE;\n-    wireframe = FALSE;\n-}\n+D3DMeshView::D3DMeshView(D3DContext *ctx, D3DMesh *pMesh) :\n+    context(ctx),\n+    mesh(pMesh)\n+{}\n@@ -76,1 +67,1 @@\n-void D3DMeshView::setLight(int index, float x, float y, float z, float r, float g, float b, float w,\n+void D3DMeshView::setLight(int index, float x, float y, float z, float r, float g, float b, float lightOn,\n@@ -88,1 +79,1 @@\n-        light.w = w;\n+        light.lightOn = lightOn;\n@@ -110,2 +101,3 @@\n-    for (int i = 0; i != MAX_NUM_LIGHTS; ++i)\n-        n += lights[i].w ? 1 : 0;\n+    for (int i = 0; i != MAX_NUM_LIGHTS; ++i) {\n+        n += lights[i].lightOn ? 1 : 0;\n+    }\n@@ -117,2 +109,2 @@\n-    for (int i=0; i<4; i++) {\n-        for (int j=0; j<4; j++) {\n+    for (int i = 0; i < 4; i++) {\n+        for (int j = 0; j < 4; j++) {\n@@ -148,4 +140,0 @@\n-    \/\/ We only support up to 3 point lights at the present\n-    for (int i = 0; i < MAX_NUM_LIGHTS; i++) {\n-        status = SUCCEEDED(device->SetVertexShaderConstantF(VSR_LIGHTS + i*2, lights[i].position, 1));\n-    }\n@@ -153,7 +141,40 @@\n-    float lightsNormDirection[MAX_NUM_LIGHTS * 4]; \/\/ 3 lights x (3 coords + 1 padding)\n-    for (int i = 0, d = 0; i < MAX_NUM_LIGHTS; i++) {\n-        if (lights[i].isPointLight()) {\n-            lightsNormDirection[d++] = 0;\n-            lightsNormDirection[d++] = 0;\n-            lightsNormDirection[d++] = 1;\n-            lightsNormDirection[d++] = 0;\n+    \/\/ Prepare lights data\n+    float lightsPosition[MAX_NUM_LIGHTS * 4];      \/\/ 3 coords + 1 padding\n+    float lightsNormDirection[MAX_NUM_LIGHTS * 4]; \/\/ 3 coords + 1 padding\n+    float lightsColor[MAX_NUM_LIGHTS * 4];         \/\/ 3 color + 1 padding\n+    float lightsAttenuation[MAX_NUM_LIGHTS * 4];   \/\/ 3 attenuation factors + 1 isAttenuated\n+    float lightsRange[MAX_NUM_LIGHTS * 4];         \/\/ 1 maxRange + 3 padding\n+    float spotLightsFactors[MAX_NUM_LIGHTS * 4];   \/\/ 2 angles + 1 falloff + 1 padding\n+    for (int i = 0, d = 0, p = 0, c = 0, a = 0, r = 0, s = 0; i < MAX_NUM_LIGHTS; i++) {\n+        D3DLight light = lights[i];\n+\n+        lightsPosition[p++] = light.position[0];\n+        lightsPosition[p++] = light.position[1];\n+        lightsPosition[p++] = light.position[2];\n+        lightsPosition[p++] = 0;\n+\n+        lightsNormDirection[d++] = light.direction[0];\n+        lightsNormDirection[d++] = light.direction[1];\n+        lightsNormDirection[d++] = light.direction[2];\n+        lightsNormDirection[d++] = 0;\n+\n+        lightsColor[c++] = light.color[0];\n+        lightsColor[c++] = light.color[1];\n+        lightsColor[c++] = light.color[2];\n+        lightsColor[c++] = 1;\n+\n+        lightsAttenuation[a++] = light.attenuation[0];\n+        lightsAttenuation[a++] = light.attenuation[1];\n+        lightsAttenuation[a++] = light.attenuation[2];\n+        lightsAttenuation[a++] = light.attenuation[3];\n+\n+        lightsRange[r++] = light.maxRange;\n+        lightsRange[r++] = 0;\n+        lightsRange[r++] = 0;\n+        lightsRange[r++] = 0;\n+\n+        if (light.isPointLight() || light.isDirectionalLight()) {\n+            spotLightsFactors[s++] = -1; \/\/ cos(180)\n+            spotLightsFactors[s++] = 2;  \/\/ cos(0) - cos(180)\n+            spotLightsFactors[s++] = 0;\n+            spotLightsFactors[s++] = 0;\n@@ -161,8 +182,7 @@\n-            float dirX = lights[i].direction[0];\n-            float dirY = lights[i].direction[1];\n-            float dirZ = lights[i].direction[2];\n-            float length = sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);\n-            lightsNormDirection[d++] = dirX \/ length;\n-            lightsNormDirection[d++] = dirY \/ length;\n-            lightsNormDirection[d++] = dirZ \/ length;\n-            lightsNormDirection[d++] = 0;\n+            \/\/ preparing for: I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff)\n+            float cosInner = cos(light.innerAngle * M_PI \/ 180);\n+            float cosOuter = cos(light.outerAngle * M_PI \/ 180);\n+            spotLightsFactors[s++] = cosOuter;\n+            spotLightsFactors[s++] = cosInner - cosOuter;\n+            spotLightsFactors[s++] = light.falloff;\n+            spotLightsFactors[s++] = 0;\n@@ -172,1 +192,6 @@\n-    status = SUCCEEDED(device->SetVertexShaderConstantF(VSR_DIRS, lightsNormDirection, MAX_NUM_LIGHTS));\n+    \/\/ Set Vertex Shader constants \/\/\n+\n+    \/\/ ProjViewMatrix position is set from D3DContext.cc::SetProjViewMatrix at VSR_VIEWPROJMATRIX\n+    \/\/ Camera position is set from D3DContext.cc::SetCameraPosition at VSR_CAMERAPOS\n+\n+    status = SUCCEEDED(device->SetVertexShaderConstantF(VSR_LIGHT_POS, lightsPosition, MAX_NUM_LIGHTS));\n@@ -174,1 +199,1 @@\n-        cout << \"D3DMeshView.render() - SetVertexShaderConstantF (VSR_DIRS) failed !!!\" << endl;\n+        cout << \"D3DMeshView.render() - SetVertexShaderConstantF(VSR_LIGHT_POS) failed !!!\" << endl;\n@@ -178,1 +203,1 @@\n-    status = SUCCEEDED(device->SetVertexShaderConstantF(VSR_AMBIENTCOLOR, ambientLightColor, 1));\n+    status = SUCCEEDED(device->SetVertexShaderConstantF(VSR_LIGHT_DIRS, lightsNormDirection, MAX_NUM_LIGHTS));\n@@ -180,1 +205,1 @@\n-        cout << \"D3DMeshView.render() - SetVertexShaderConstantF (VSR_AMBIENTCOLOR) failed !!!\" << endl;\n+        cout << \"D3DMeshView.render() - SetVertexShaderConstantF (VSR_LIGHT_DIRS) failed !!!\" << endl;\n@@ -184,1 +209,17 @@\n-    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_DIFFUSECOLOR, material->getDiffuseColor(), 1));\n+    D3DMATRIX mat;\n+    matrixTransposed(mat, *(context->GetWorldTx()));\n+\/\/    std::cerr << \"Transposed world transform:\\n\";\n+\/\/    fprintf(stderr, \"  %5f %5f %5f %5f\\n\", mat._11, mat._12, mat._13, mat._14);\n+\/\/    fprintf(stderr, \"  %5f %5f %5f %5f\\n\", mat._21, mat._22, mat._23, mat._24);\n+\/\/    fprintf(stderr, \"  %5f %5f %5f %5f\\n\", mat._31, mat._32, mat._33, mat._34);\n+\/\/    fprintf(stderr, \"  %5f %5f %5f %5f\\n\", mat._41, mat._42, mat._43, mat._44);\n+\n+    SUCCEEDED(device->SetVertexShaderConstantF(VSR_WORLDMATRIX, (float*) mat.m, 3));\n+    if (!status) {\n+        cout << \"D3DMeshView.render() - SetVertexShaderConstantF(VSR_WORLDMATRIX) failed !!!\" << endl;\n+        return;\n+    }\n+\n+    \/\/ Set Pixel Shader constants \/\/\n+\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_MAT_DIFFUSE_COLOR, material->getDiffuseColor(), 1));\n@@ -190,1 +231,1 @@\n-    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_SPECULARCOLOR, material->getSpecularColor(), 1));\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_MAT_SPECULAR_COLOR, material->getSpecularColor(), 1));\n@@ -196,35 +237,4 @@\n-    float lightsColor[MAX_NUM_LIGHTS * 4];        \/\/ 3 lights x (3 color + 1 padding)\n-    float lightsAttenuation[MAX_NUM_LIGHTS * 4];  \/\/ 3 lights x (3 attenuation factors + 1 isAttenuated)\n-    float lightsRange[MAX_NUM_LIGHTS * 4];        \/\/ 3 lights x (1 maxRange + 3 padding)\n-    float spotLightsFactors[MAX_NUM_LIGHTS * 4];  \/\/ 3 lights x (2 angles + 1 falloff + 1 padding)\n-    for (int i = 0, c = 0, a = 0, r = 0, s = 0; i < MAX_NUM_LIGHTS; i++) {\n-        float w = lights[i].w;\n-        lightsColor[c++] = lights[i].color[0] * w;\n-        lightsColor[c++] = lights[i].color[1] * w;\n-        lightsColor[c++] = lights[i].color[2] * w;\n-        lightsColor[c++] = 1;\n-\n-        lightsAttenuation[a++] = lights[i].attenuation[0];\n-        lightsAttenuation[a++] = lights[i].attenuation[1];\n-        lightsAttenuation[a++] = lights[i].attenuation[2];\n-        lightsAttenuation[a++] = lights[i].attenuation[3];\n-\n-        lightsRange[r++] = lights[i].maxRange;\n-        lightsRange[r++] = 0;\n-        lightsRange[r++] = 0;\n-        lightsRange[r++] = 0;\n-\n-        if (lights[i].isPointLight() || lights[i].isDirectionalLight()) {\n-            spotLightsFactors[s++] = -1; \/\/ cos(180)\n-            spotLightsFactors[s++] = 2;  \/\/ cos(0) - cos(180)\n-            spotLightsFactors[s++] = 0;\n-            spotLightsFactors[s++] = 0;\n-        } else {\n-            \/\/ preparing for: I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff)\n-            float cosInner = cos(lights[i].innerAngle * M_PI \/ 180);\n-            float cosOuter = cos(lights[i].outerAngle * M_PI \/ 180);\n-            spotLightsFactors[s++] = cosOuter;\n-            spotLightsFactors[s++] = cosInner - cosOuter;\n-            spotLightsFactors[s++] = lights[i].falloff;\n-            spotLightsFactors[s++] = 0;\n-        }\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_AMBIENT_COLOR, ambientLightColor, 1));\n+    if (!status) {\n+        cout << \"D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHT_AMBIENT_COLOR) failed !!!\" << endl;\n+        return;\n@@ -233,1 +243,1 @@\n-    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHTCOLOR, lightsColor, MAX_NUM_LIGHTS));\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_COLOR, lightsColor, MAX_NUM_LIGHTS));\n@@ -257,0 +267,15 @@\n+\/\/ needed for pixel lighting\n+\/\/    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_DIRS, lightsNormDirection, MAX_NUM_LIGHTS));\n+\/\/    if (!status) {\n+\/\/        cout << \"D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHT_DIRS) failed !!!\" << endl;\n+\/\/        return;\n+\/\/    }\n+\/\/\n+\/\/    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_POS, lightsPosition, MAX_NUM_LIGHTS));\n+\/\/    if (!status) {\n+\/\/        cout << \"D3DMeshView.render() - SetPixelShaderConstantF(PSR_LIGHT_POS) failed !!!\" << endl;\n+\/\/        return;\n+\/\/    }\n+\n+    \/\/ Set material properties\n+\n@@ -267,14 +292,4 @@\n-    SUCCEEDED(device->SetTexture(SR_DIFFUSEMAP, material->getMap(DIFFUSE)));\n-    SUCCEEDED(device->SetTexture(SR_SPECULARMAP, material->getMap(SPECULAR)));\n-    SUCCEEDED(device->SetTexture(SR_BUMPHEIGHTMAP, material->getMap(BUMP)));\n-    SUCCEEDED(device->SetTexture(SR_SELFILLUMMAP, material->getMap(SELFILLUMINATION)));\n-\n-    D3DMATRIX mat;\n-    matrixTransposed(mat, *(context->GetWorldTx()));\n-\/\/    std::cerr << \"Transposed world transform:\\n\";\n-\/\/    fprintf(stderr, \"  %5f %5f %5f %5f\\n\", mat._11, mat._12, mat._13, mat._14);\n-\/\/    fprintf(stderr, \"  %5f %5f %5f %5f\\n\", mat._21, mat._22, mat._23, mat._24);\n-\/\/    fprintf(stderr, \"  %5f %5f %5f %5f\\n\", mat._31, mat._32, mat._33, mat._34);\n-\/\/    fprintf(stderr, \"  %5f %5f %5f %5f\\n\", mat._41, mat._42, mat._43, mat._44);\n-\n-    SUCCEEDED(device->SetVertexShaderConstantF(VSR_WORLDMATRIX, (float*) mat.m, 3));\n+    SUCCEEDED(device->SetTexture(SR_DIFFUSE_MAP, material->getMap(DIFFUSE)));\n+    SUCCEEDED(device->SetTexture(SR_SPECULAR_MAP, material->getMap(SPECULAR)));\n+    SUCCEEDED(device->SetTexture(SR_BUMPHEIGHT_MAP, material->getMap(BUMP)));\n+    SUCCEEDED(device->SetTexture(SR_SELFILLUM_MAP, material->getMap(SELFILLUMINATION)));\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.cc","additions":109,"deletions":94,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -53,3 +53,3 @@\n-    D3DContext *context;\n-    D3DMesh *mesh;\n-    D3DPhongMaterial *material;\n+    D3DContext *context = NULL;\n+    D3DMesh *mesh = NULL;\n+    D3DPhongMaterial *material = NULL;\n@@ -57,5 +57,5 @@\n-    float ambientLightColor[3];\n-    int numLights;\n-    bool lightsDirty;\n-    int cullMode;\n-    bool wireframe;\n+    float ambientLightColor[3] = {0};\n+    int numLights = 0;\n+    bool lightsDirty = TRUE;\n+    int cullMode = D3DCULL_NONE;\n+    bool wireframe = FALSE;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.h","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,9 +45,0 @@\n-    diffuseColor[0] = 0;\n-    diffuseColor[1] = 0;\n-    diffuseColor[2] = 0;\n-    diffuseColor[3] = 0;\n-    specularColorSet = false;\n-    specularColor[0] = 1;\n-    specularColor[1] = 1;\n-    specularColor[2] = 1;\n-    specularColor[3] = 32;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DPhongMaterial.cc","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,4 +54,5 @@\n-    D3DContext *context;\n-    float diffuseColor[4], specularColor[4];\n-    IDirect3DBaseTexture9 *map[4];\n-    bool specularColorSet;\n+    D3DContext *context = NULL;\n+    float diffuseColor[4] = {0};\n+    float specularColor[4] = {1 , 1, 1, 32};\n+    IDirect3DBaseTexture9 *map[4] = {NULL};\n+    bool specularColorSet = false;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DPhongMaterial.h","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,2 +35,3 @@\n-#define VSR_VIEWPROJMATRIX 0  \/\/ 4x4 matrix = 4: c0-3\n-#define VSR_CAMERAPOS 4       \/\/ 1 position: c4\n+\n+#define VSR_VIEWPROJMATRIX 0 \/\/ 4x4 matrix = 4: c0-3\n+#define VSR_CAMERAPOS 4      \/\/ 1 position: c4\n@@ -40,2 +41,3 @@\n-#define VSR_LIGHTS 10  \/\/ 1 position + 1 color = 5 * 2 = 10: c10-19\n-#define VSR_DIRS 20    \/\/ 1 direction = 5 * 1 = 5: c20-24\n+#define VSR_LIGHT_POS 10  \/\/ 1 position = 5 * 1 = 5: c10-14\n+\/\/ Registers 15-19 free\n+#define VSR_LIGHT_DIRS 20    \/\/ 1 direction = 5 * 1 = 5: c20-24\n@@ -43,1 +45,1 @@\n-#define VSR_AMBIENTCOLOR 25 \/\/ 8 ambient points + 2 coords = 10 (only 1 is used): c25-34\n+\/\/#define VSR_AMBIENT_LIGHT_COLOR 25 \/\/ 8 ambient points + 2 coords = 10 (only 1 is used): c25-34\n@@ -52,3 +54,4 @@\n-#define PSR_DIFFUSECOLOR 0       \/\/ 1 color: c0\n-#define PSR_SPECULARCOLOR 1      \/\/ 1 color (including the specular power): c1\n-\/\/ Registers 2-3 (inclusive) are reserved\n+#define PSR_MAT_DIFFUSE_COLOR 0   \/\/ 1 color: c0\n+#define PSR_MAT_SPECULAR_COLOR 1  \/\/ 1 color (including the specular power): c1\n+#define PSR_LIGHT_AMBIENT_COLOR 2 \/\/ 1 combined color of all ambient lights: c2\n+\/\/ Register 3 reserved\n@@ -57,1 +60,1 @@\n-#define PSR_LIGHTCOLOR 4         \/\/ 1 color: c4-8\n+#define PSR_LIGHT_COLOR 4        \/\/ 1 color: c4-8\n@@ -61,0 +64,3 @@\n+\/\/ needed for pixel lighting\n+\/\/#define PSR_LIGHT_DIRS 24        \/\/ 1 direction = 5 * 1 = 5: c24-28\n+\/\/#define PSR_LIGHT_POS 29         \/\/ 1 position = 5 * 1 = 5: c29-34\n@@ -63,4 +69,4 @@\n-#define SR_DIFFUSEMAP 0\n-#define SR_SPECULARMAP 1\n-#define SR_BUMPHEIGHTMAP 2\n-#define SR_SELFILLUMMAP 3\n+#define SR_DIFFUSE_MAP 0\n+#define SR_SPECULAR_MAP 1\n+#define SR_BUMPHEIGHT_MAP 2\n+#define SR_SELFILLUM_MAP 3\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DPhongShader.h","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+\/\/ lights number (not specular)\n+#ifndef Spec\n+    #define Spec 0\n+#endif\n+\n@@ -32,0 +37,8 @@\n+#ifndef Bump\n+    #define Bump 0\n+#endif\n+\n+#ifndef IllumMap\n+    #define IllumMap 0\n+#endif\n+\n@@ -37,0 +50,1 @@\n+static const int numShaderLights = Spec;\n@@ -38,0 +52,3 @@\n+static const bool bump = Bump;\n+static const bool isIlluminated = IllumMap;\n+\n@@ -49,1 +66,1 @@\n-float4 main(ObjectPsIn objAttr, LocalBump  lSpace) : color {\n+float4 main(float2 texD : texcoord0, PsInput psInput) : color {\n@@ -54,1 +71,2 @@\n-    float4 tDiff = tex2D(mapDiffuse, objAttr.texD);\n+    \/\/ diffuse\n+    float4 tDiff = tex2D(mapDiffuse, texD);\n@@ -60,2 +78,0 @@\n-    float3 nEye = normalize(lSpace.eye);\n-\n@@ -64,0 +80,1 @@\n+    \/\/bump\n@@ -65,2 +82,2 @@\n-        float4 BumpSpec = tex2D(mapBumpHeight, objAttr.texD);\n-        n = normalize(BumpSpec.xyz*2-1);\n+        float4 BumpSpec = tex2D(mapBumpHeight, texD);\n+        n = normalize(BumpSpec.xyz * 2 - 1);\n@@ -69,2 +86,1 @@\n-    float4 ambColor = objAttr.ambient;\n-\n+    \/\/ specular\n@@ -72,1 +88,1 @@\n-    float sPower = 0;\n+    float specPower = 0;\n@@ -75,1 +91,1 @@\n-        sPower = gSpecularColor.a;\n+        specPower = gSpecularColor.a;\n@@ -77,2 +93,2 @@\n-            tSpec = tex2D(mapSpecular, objAttr.texD);\n-            sPower *= NTSC_Gray(tSpec.rgb);\n+            tSpec = tex2D(mapSpecular, texD);\n+            specPower *= NTSC_Gray(tSpec.rgb);\n@@ -88,2 +104,15 @@\n-    float3 diff = 0;\n-    float3 spec = 0;\n+    \/\/ lighting\n+    float3 worldNormVecToEye = normalize(psInput.worldVecToEye);\n+    float3 refl = reflect(worldNormVecToEye, n);\n+    float3 diffLightColor = 0;\n+    float3 specLightColor = 0;\n+\n+    for (int i = 0; i < numShaderLights; i++) {\n+        \/\/  needed for pixel lighting\n+        \/\/  float3 worldVecToLight = gLightsPos[i].xyz - worldPixelPos;\n+        \/\/  worldVecToLight = getLocalVector(worldVecToLight, worldNormals);\n+        \/\/\n+        \/\/  float3 worldNormLightDir = gLightsNormDirs[i].xyz;\n+        \/\/  worldNormLightDir = getLocalVector(worldNormLightDir, worldNormals); \/\/ renormalize?\n+        computeLight(i, n, refl, specPower, psInput.worldVecsToLights[i], psInput.worldNormLightDirs[i], diffLightColor, specLightColor);\n+    }\n@@ -91,1 +120,1 @@\n-    phong(n, nEye, sPower, lSpace.lights, lSpace.lightDirs, diff, spec, 0, nSpecular);\n+    float3 ambLightColor = gAmbientLightColor.rgb;\n@@ -93,1 +122,1 @@\n-    float3 rez = (ambColor.xyz+diff)*tDiff.xyz + spec*tSpec.rgb;\n+    float3 rez = (ambLightColor + diffLightColor) * tDiff.rgb + specLightColor * tSpec.rgb;\n@@ -95,2 +124,4 @@\n-    if (isIlluminated)\n-        rez += tex2D(mapSelfIllum, objAttr.texD).xyz;\n+    \/\/ self-illumination\n+    if (isIlluminated) {\n+        rez += tex2D(mapSelfIllum, texD).rgb;\n+    }\n@@ -98,1 +129,1 @@\n-    return float4( saturate(rez), tDiff.a);\n+    return float4(saturate(rez), tDiff.a);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/Mtl1PS.hlsl","additions":50,"deletions":19,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-float2 transformTexture(float2 t) { return t; }\n+\/\/float2 transformTexture(float2 t) { return t; }\n@@ -32,2 +32,2 @@\n-ObjVsOutput main(VertexType i) {\n-    ObjVsOutput o;\n+VsOutput main(VsInput vsInput) {\n+    VsOutput vsOutput;\n@@ -35,2 +35,1 @@\n-    float4 _tangent = i.Tangent;\n-    float4 _pos = i.Pos;\n+    calcLocalBump(vsInput.modelVertexPos, vsInput.modelVertexNormal, vsOutput.psInput);\n@@ -38,1 +37,2 @@\n-    calcLocalBump(_pos, _tangent, mWorld, o.light);\n+\/\/    vsOutput.objAttr.texD = transformTexture(vsInput.texD);\n+    vsOutput.texD = vsInput.texD;\n@@ -40,4 +40,1 @@\n-    o.objAttr.ambient = gAmbinet;\n-    o.objAttr.texD = transformTexture(i.TexD);\n-\n-    return o;\n+    return vsOutput;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/Mtl1VS.hlsl","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-static const int numMaxLights = 5;\n+static const int numMaxLights = 3;\n@@ -32,0 +32,1 @@\n+float4 gAmbientLightColor : register(c2);\n@@ -37,1 +38,5 @@\n-float4 gSomethingElse : register(c24);\n+\/\/  needed for pixel lighting\n+\/\/float4 gLightsNormDirs[numMaxLights] : register(c24);\n+\/\/float4 gLightsPos[numMaxLights]     : register(c29);\n+\n+float4 gSomethingElse : register(c29);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/psConstants.h","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,16 +31,0 @@\n-#ifndef Spec\n-    #define Spec 0\n-#endif\n-\n-#ifndef Bump\n-    #define Bump 0\n-#endif\n-\n-#ifndef IllumMap\n-    #define IllumMap 0\n-#endif\n-\n-\n-static const bool bump = Bump;\n-static const int nSpecular = Spec;\n-static const bool isIlluminated = IllumMap;\n@@ -48,0 +32,4 @@\n+\/\/ needed for pixel lighting\n+\/\/float3 getLocalVector(float3 global, float3 N[3]) {\n+\/\/    return float3(dot(global, N[1]), dot(global, N[2]), dot(global, N[0]));\n+\/\/}\n@@ -53,3 +41,5 @@\n-float3 getBumpNormal(float3 bumpMap, float3 N[3]) {\n-    return bumpMap.z*N[0]+bumpMap.x*N[1]+bumpMap.y*N[2];\n-}\n+\/\/float3 getBumpNormal(float3 bumpMap, float3 N[3]) {\n+\/\/    return bumpMap.z * N[0] + bumpMap.x * N[1] + bumpMap.y * N[2];\n+\/\/}\n+\n+\/\/float4 retNormal(float3 n) { return float4(n * 0.5 + 0.5, 1); }\n@@ -57,1 +47,1 @@\n-float4 retNormal(float3 n) { return float4( n*0.5+0.5,1); }\n+\/\/float4 retr(float x) { return float4(x.xxx, 1); }\n@@ -59,1 +49,0 @@\n-float4 retr(float x) { return float4(x.xxx,1); }\n@@ -105,1 +94,5 @@\n-void computeLight(float i, float3 n, float3 refl, float specPower, float3 L, float3 lightDir, in out float3 d, in out float3 s) {\n+\/*\n+ * Computes the light's contribution by using the Phong shading model. A contribution consist of a diffuse component and a\n+ * specular component. The computation is done in world space.\n+ *\/\n+void computeLight(float i, float3 n, float3 refl, float specPower, float3 toLight, float3 lightDir, in out float3 d, in out float3 s) {\n@@ -112,1 +105,1 @@\n-    float dist = length(L);\n+    float dist = length(toLight);\n@@ -116,1 +109,1 @@\n-    float3 l = normalize(L);\n+    float3 l = normalize(toLight);\n@@ -132,8 +125,0 @@\n-\n-void phong(float3 n, float3 e, float specPower, in float4 L[LocalBump::nLights], in float4 lightDirs[LocalBump::nLights],\n-        in out float3 d, in out float3 s, int _s, int _e) {\n-    float3 refl = reflect(e, n);\n-    for (int i = _s; i < _e; i++) {\n-        computeLight(i, n, refl, specPower, L[i].xyz, lightDirs[i].xyz, d, s);\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/psMath.h","additions":17,"deletions":32,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -26,6 +26,1 @@\n-struct ObjectPsIn {\n-    float2  texD    : texcoord0;\n-    float4  ambient : texcoord1;\n-};\n-\n-struct LocalBump {\n+struct PsInput {\n@@ -35,5 +30,2 @@\n-    float3 eye                : texcoord2;\n-    float4 lights[nLights]    : texcoord3; \/\/ 3, 4, 5 [6]\n-    float4 lightDirs[nLights] : texcoord7; \/\/ 7, 8, 9 [10]\n-\/\/  float3 debug              : texcoord11;\n-};\n+    \/\/ projection space = homogeneous clip space\n+    float4 projPos : position; \/\/ must be outputed even if unused\n@@ -41,3 +33,2 @@\n-struct LocalBumpOut {\n-    float4  pos  : position;\n-    float   oFog : fog;\n+\/\/  needed for pixel lighting\n+\/\/  float3 worldPos           : texcoord1;\n@@ -45,2 +36,6 @@\n-    LocalBump lBump;\n-};\n+    float3 worldVecToEye               : texcoord2;\n+    float3 worldVecsToLights[nLights]  : texcoord3; \/\/ 3, 4, 5\n+    float3 worldNormLightDirs[nLights] : texcoord6; \/\/ 6, 7, 8\n+\n+\/\/  needed for pixel lighting\n+\/\/  float3 worldNormals[3] : texcoord3; \/\/ 3, 4, 5\n@@ -48,0 +43,3 @@\n+\/\/  float  oFog  : fog;\n+\/\/  float3 debug : texcoord11;\n+};\n@@ -49,3 +47,3 @@\n-struct ObjVsOutput {\n-    LocalBumpOut light;\n-    ObjectPsIn   objAttr;\n+struct VsOutput {\n+    float2  texD : texcoord0;\n+    PsInput psInput;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/vs2ps.h","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -36,4 +36,1 @@\n-struct Light {\n-    float4 pos;\n-    float4 color;\n-};\n+static const int maxLights = 3;\n@@ -44,2 +41,2 @@\n-float4x4    mViewProj   : register(c0);\n-float4      gCameraPos  : register(c4);\n+float4x4 mViewProj   : register(c0);\n+float4   gCameraPos  : register(c4);\n@@ -47,2 +44,1 @@\n-\n-float4      gReserved5[5] : register(c5);\n+float4   gReserved5[5] : register(c5);\n@@ -51,4 +47,4 @@\n-Light       sLights[5]        : register(c10);\n-float4      gLightsNormDir[5] : register(c20);\n-float4      gAmbinet          : register(c25);\n-float4      gAmbinetData[10]  : register(c25);\n+float4   gLightsPos[maxLights]     : register(c10);\n+float4   gLightsNormDir[maxLights] : register(c20);\n+\/\/float4 gAmbinetLightColor        : register(c25);\n+\/\/float4 gAmbinetData[10]          : register(c25);\n@@ -57,2 +53,2 @@\n-float4x3    mWorld            : register(c35);\n-float4x3    mBones[MAX_BONES] : register(c35);\n+float4x3 mWorld            : register(c35);\n+float4x3 mBones[MAX_BONES] : register(c35);\n@@ -60,1 +56,1 @@\n-float4      gReserved245[11] : register(c245);\n+float4   gReserved245[11] : register(c245);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/vsConstants.h","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,5 +30,5 @@\n-struct ObjVertex {\n-    float4  Pos       : position;\n-\n-    float2  TexD      : texcoord0;\n-    float4  Tangent   : texcoord1;\n+struct VsInput {\n+    \/\/ model space = local space = object space\n+    float4  modelVertexPos    : position;\n+    float2  texD              : texcoord0;\n+    float4  modelVertexNormal : texcoord1;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/vsDecl.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,4 +33,4 @@\n-    float3 t1 = q.xyz * q.yzx *2;\n-    float3 t2 = q.zxy * q.www *2;\n-    float3 t3 = q.xyz * q.xyz *2;\n-    float3 t4 = 1-(t3+t3.yzx);\n+    float3 t1 = q.xyz * q.yzx * 2;\n+    float3 t2 = q.zxy * q.www * 2;\n+    float3 t3 = q.xyz * q.xyz * 2;\n+    float3 t4 = 1 - (t3 + t3.yzx);\n@@ -45,1 +45,1 @@\n-    N[2] *= (q.w>=0) ? 1 : -1;   \/\/ ATI normal map generator compatibility\n+    N[2] *= (q.w >= 0) ? 1 : -1;   \/\/ ATI normal map generator compatibility\n@@ -48,3 +48,3 @@\n-float3 getNormal(float4 q) {\n-    return float3(1-2*(q.y*q.y+q.z*q.z),2*(q.x*q.y+q.z*q.w),2*(q.z*q.x-q.y*q.w));\n-}\n+\/\/float3 getNormal(float4 q) {\n+\/\/    return float3(1 - 2 * (q.y * q.y + q.z * q.z), 2 * (q.x * q.y + q.z * q.w), 2 * (q.z * q.x - q.y * q.w));\n+\/\/}\n@@ -53,1 +53,1 @@\n-    return float3( dot(global,N[1]), dot(global,N[2]), dot(global,N[0]) );\n+    return float3(dot(global, N[1]), dot(global, N[2]), dot(global, N[0]));\n@@ -56,2 +56,2 @@\n-void calcLocalBump(float4 ipos, float4 iTn, in float4x3 mW, out LocalBumpOut r) {\n-    float3 pos = mul(ipos, mW);\n+void calcLocalBump(float4 modelVertexPos, float4 modelVertexNormal, out PsInput psInput) {\n+    float3 worldVertexPos = mul(modelVertexPos, mWorld);\n@@ -59,1 +59,2 @@\n-    float3 n[3];\n+\/\/  needed for pixel lighting\n+\/\/  psInput.worldPos = worldVertexPos;\n@@ -61,1 +62,1 @@\n-    quatToMatrix(iTn, n);\n+    psInput.projPos = mul(float4(worldVertexPos, 1), mViewProj);\n@@ -63,2 +64,5 @@\n-    for (int i=0; i!=3; ++i)\n-        n[i] = mul(n[i], (float3x3)mW);\n+    float3 n[3];\n+    quatToMatrix(modelVertexNormal, n);\n+    for (int i = 0; i != 3; ++i) {\n+        n[i] = mul(n[i], (float3x3) mWorld);\n+    }\n@@ -66,0 +70,2 @@\n+\/\/  needed for pixel lighting\n+\/\/  psInput.worldNormals = n;\n@@ -72,2 +78,2 @@\n-    float3 Eye = gCameraPos.xyz - pos;\n-    r.lBump.eye = getLocalVector(Eye, n);\n+    float3 worldVecToEye = gCameraPos.xyz - worldVertexPos;\n+    psInput.worldVecToEye = getLocalVector(worldVecToEye, n);\n@@ -75,5 +81,5 @@\n-    for (int k=0; k<LocalBump::nLights; ++k) {\n-        float3 L = sLights[k].pos.xyz - pos;\n-        float3 D = gLightsNormDir[k].xyz;\n-        r.lBump.lights[k] = float4(getLocalVector(L, n), 1);\n-        r.lBump.lightDirs[k] = float4(getLocalVector(D, n), 1);\n+    for (int k = 0; k < PsInput::nLights; ++k) {\n+        float3 worldVecToLight = gLightsPos[k].xyz - worldVertexPos;\n+        psInput.worldVecsToLights[k] = getLocalVector(worldVecToLight, n);\n+        float3 worldNormLightDir = gLightsNormDir[k].xyz;\n+        psInput.worldNormLightDirs[k] = getLocalVector(worldNormLightDir, n);\n@@ -82,5 +88,1 @@\n-    r.pos  = mul(float4(pos,1), mViewProj);\n-\n-\/\/    r.Debug = r.Pos;\n-\n-\/\/    r.lBump.debug = n[0];\n+\/\/    psInput.debug = n[0];\n@@ -88,1 +90,1 @@\n-    r.oFog  = 1; \/\/ getFogExp2(pos);\n+\/\/    psInput.oFog  = 1; \/\/ getFogExp2(pos);\n@@ -92,1 +94,1 @@\n-float4 retFloat(float x) { return float4(x.xxx,1); }\n+\/\/float4 retFloat(float x) { return float4(x.xxx,1); }\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/vsMath.h","additions":31,"deletions":29,"binary":false,"changes":60,"status":"modified"}]}