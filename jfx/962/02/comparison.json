{"files":[{"patch":"@@ -369,1 +369,1 @@\n-                getKeyHandler().setFocusVisible(focusOwner, false);\n+                setFocusOwner(focusOwner, false);\n@@ -780,1 +780,1 @@\n-                    getKeyHandler().windowForSceneChanged(oldWindow, newWindow);\n+                    windowForSceneChanged(oldWindow, newWindow);\n@@ -2093,5 +2093,18 @@\n-    \/*\n-     * We cannot initialize keyHandler in init because some of the triggers\n-     * access it before the init block.\n-     * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}\n-     * does not compile.\n+    private void windowForSceneChanged(Window oldWindow, Window newWindow) {\n+        if (oldWindow != null) {\n+            oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);\n+        }\n+\n+        if (newWindow != null) {\n+            newWindow.focusedProperty().addListener(sceneWindowFocusedListener);\n+            setWindowFocused(newWindow.isFocused());\n+        } else {\n+            setWindowFocused(false);\n+        }\n+    }\n+\n+    private final InvalidationListener sceneWindowFocusedListener =\n+            valueModel -> setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());\n+\n+    \/**\n+     * Stores whether the window associated with this scene is currently focused.\n@@ -2099,4 +2112,13 @@\n-    private KeyHandler keyHandler = null;\n-    private KeyHandler getKeyHandler() {\n-        if (keyHandler == null) {\n-            keyHandler = new KeyHandler();\n+    private boolean windowFocused;\n+\n+    private void setWindowFocused(boolean value) {\n+        windowFocused = value;\n+\n+        Node node = getFocusOwner();\n+        if (node != null) {\n+            node.setFocusQuietly(windowFocused, focusOwner.focusVisible);\n+            node.notifyFocusListeners();\n+        }\n+\n+        if (windowFocused && accessible != null) {\n+            accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);\n@@ -2104,1 +2126,0 @@\n-        return keyHandler;\n@@ -2106,0 +2127,1 @@\n+\n@@ -2162,1 +2184,7 @@\n-        getKeyHandler().process(e);\n+        final Node sceneFocusOwner = getFocusOwner();\n+        final EventTarget eventTarget =\n+                (sceneFocusOwner != null && sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner : Scene.this;\n+\n+        \/\/ send the key event to the current focus owner or to scene if\n+        \/\/ the focus owner is not set\n+        Event.fireEvent(eventTarget, e);\n@@ -2166,1 +2194,5 @@\n-        getKeyHandler().requestFocus(node, focusVisible);\n+        if (node == null) {\n+            setFocusOwner(null, false);\n+        } else if (node.isCanReceiveFocus()) {\n+            setFocusOwner(node, focusVisible);\n+        }\n@@ -2169,2 +2201,0 @@\n-    private Node oldFocusOwner;\n-\n@@ -2177,1 +2207,21 @@\n-    private ReadOnlyObjectWrapper<Node> focusOwner = new ReadOnlyObjectWrapper<>(this, \"focusOwner\") {\n+    private FocusOwnerProperty focusOwner = new FocusOwnerProperty();\n+\n+    private class FocusOwnerProperty extends ReadOnlyObjectWrapper<Node> {\n+        Node oldFocusOwner;\n+\n+        \/**\n+         * Stores whether the current focus owner visibly indicates focus.\n+         * This value is used to restore visible focus when a window loses\n+         * and re-gains focus.\n+         *\/\n+        boolean focusVisible;\n+\n+        @Override\n+        public Object getBean() {\n+            return Scene.this;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return \"focusOwner\";\n+        }\n@@ -2186,1 +2236,1 @@\n-                value.setFocusQuietly(keyHandler.windowFocused, keyHandler.focusVisible);\n+                value.setFocusQuietly(windowFocused, focusVisible);\n@@ -2221,0 +2271,4 @@\n+    public final ReadOnlyObjectProperty<Node> focusOwnerProperty() {\n+        return focusOwner.getReadOnlyProperty();\n+    }\n+\n@@ -2225,2 +2279,29 @@\n-    public final ReadOnlyObjectProperty<Node> focusOwnerProperty() {\n-        return focusOwner.getReadOnlyProperty();\n+    private void setFocusOwner(Node node, boolean focusVisible) {\n+        \/\/ Cancel IM composition if there is one in progress.\n+        \/\/ This needs to be done before the focus owner is switched as it\n+        \/\/ generates event that needs to be delivered to the old focus owner.\n+        if (focusOwner.oldFocusOwner != null) {\n+            final Scene s = focusOwner.oldFocusOwner.getScene();\n+            if (s != null) {\n+                final TKScene peer = s.getPeer();\n+                if (peer != null) {\n+                    peer.finishInputMethodComposition();\n+                }\n+            }\n+        }\n+\n+        \/\/ Store the current focusVisible state of the focus owner in case it needs to be\n+        \/\/ restored when a window loses and re-gains focus.\n+        focusOwner.focusVisible = focusVisible;\n+\n+        if (focusOwner.get() != node) {\n+            \/\/ If the focus owner has changed, FocusOwnerProperty::invalidated will update\n+            \/\/ the node's focusVisible flag.\n+            focusOwner.set(node);\n+        } else if (node != null) {\n+            \/\/ If the focus owner has not changed (i.e. only focusVisible has changed),\n+            \/\/ FocusOwnerProperty::invalidated will not be called, therefore we need to\n+            \/\/ update the node's focusVisible flag manually.\n+            node.focusVisible.set(focusVisible);\n+            node.focusVisible.notifyListeners();\n+        }\n@@ -4047,86 +4128,0 @@\n-    \/* *****************************************************************************\n-     *                                                                             *\n-     * Key Event Handling                                                          *\n-     *                                                                             *\n-     ******************************************************************************\/\n-\n-    class KeyHandler {\n-        boolean focusVisible;\n-\n-        private void setFocusOwner(Node value, boolean focusVisible) {\n-            this.focusVisible = focusVisible;\n-\n-            \/\/ Cancel IM composition if there is one in progress.\n-            \/\/ This needs to be done before the focus owner is switched as it\n-            \/\/ generates event that needs to be delivered to the old focus owner.\n-            if (oldFocusOwner != null) {\n-                final Scene s = oldFocusOwner.getScene();\n-                if (s != null) {\n-                    final TKScene peer = s.getPeer();\n-                    if (peer != null) {\n-                        peer.finishInputMethodComposition();\n-                    }\n-                }\n-            }\n-            focusOwner.set(value);\n-        }\n-\n-        private void setFocusVisible(Node node, boolean focusVisible) {\n-            this.focusVisible = focusVisible;\n-            node.focusVisible.set(focusVisible);\n-            node.focusVisible.notifyListeners();\n-        }\n-\n-        private boolean windowFocused;\n-        protected boolean isWindowFocused() { return windowFocused; }\n-        protected void setWindowFocused(boolean value) {\n-            windowFocused = value;\n-            if (getFocusOwner() != null) {\n-                getFocusOwner().setFocusQuietly(windowFocused, focusVisible);\n-                getFocusOwner().notifyFocusListeners();\n-            }\n-            if (windowFocused) {\n-                if (accessible != null) {\n-                    accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);\n-                }\n-            }\n-        }\n-\n-        private void windowForSceneChanged(Window oldWindow, Window window) {\n-            if (oldWindow != null) {\n-                oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);\n-            }\n-\n-            if (window != null) {\n-                window.focusedProperty().addListener(sceneWindowFocusedListener);\n-                setWindowFocused(window.isFocused());\n-            } else {\n-                setWindowFocused(false);\n-            }\n-        }\n-\n-        private final InvalidationListener sceneWindowFocusedListener = valueModel -> setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());\n-\n-        private void process(KeyEvent e) {\n-            final Node sceneFocusOwner = getFocusOwner();\n-            final EventTarget eventTarget =\n-                    (sceneFocusOwner != null && sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner\n-                                              : Scene.this;\n-\n-            \/\/ send the key event to the current focus owner or to scene if\n-            \/\/ the focus owner is not set\n-            Event.fireEvent(eventTarget, e);\n-        }\n-\n-        private void requestFocus(Node node, boolean focusVisible) {\n-            if (node == null) {\n-                setFocusOwner(null, false);\n-            } else if (node.isCanReceiveFocus()) {\n-                if (node != getFocusOwner()) {\n-                    setFocusOwner(node, focusVisible);\n-                } else {\n-                    setFocusVisible(node, focusVisible);\n-                }\n-            }\n-        }\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":101,"deletions":106,"binary":false,"changes":207,"status":"modified"}]}