{"files":[{"patch":"@@ -369,1 +369,1 @@\n-                getKeyHandler().setFocusVisible(focusOwner, false);\n+                setFocusOwner(focusOwner, false);\n@@ -778,1 +778,1 @@\n-                    getKeyHandler().windowForSceneChanged(oldWindow, newWindow);\n+                    windowForSceneChanged(oldWindow, newWindow);\n@@ -2091,5 +2091,18 @@\n-    \/*\n-     * We cannot initialize keyHandler in init because some of the triggers\n-     * access it before the init block.\n-     * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}\n-     * does not compile.\n+    private void windowForSceneChanged(Window oldWindow, Window window) {\n+        if (oldWindow != null) {\n+            oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);\n+        }\n+\n+        if (window != null) {\n+            window.focusedProperty().addListener(sceneWindowFocusedListener);\n+            setWindowFocused(window.isFocused());\n+        } else {\n+            setWindowFocused(false);\n+        }\n+    }\n+\n+    private final InvalidationListener sceneWindowFocusedListener =\n+            valueModel -> setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());\n+\n+    \/**\n+     * Stores whether the window associated with this scene is currently focused.\n@@ -2097,4 +2110,13 @@\n-    private KeyHandler keyHandler = null;\n-    private KeyHandler getKeyHandler() {\n-        if (keyHandler == null) {\n-            keyHandler = new KeyHandler();\n+    private boolean windowFocused;\n+\n+    private void setWindowFocused(boolean value) {\n+        windowFocused = value;\n+\n+        Node node = getFocusOwner();\n+        if (node != null) {\n+            node.setFocusQuietly(windowFocused, focusOwner.focusVisible);\n+            node.notifyFocusListeners();\n+        }\n+\n+        if (windowFocused && accessible != null) {\n+            accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);\n@@ -2102,1 +2124,0 @@\n-        return keyHandler;\n@@ -2104,0 +2125,1 @@\n+\n@@ -2160,1 +2182,7 @@\n-        getKeyHandler().process(e);\n+        final Node sceneFocusOwner = getFocusOwner();\n+        final EventTarget eventTarget =\n+                (sceneFocusOwner != null && sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner : Scene.this;\n+\n+        \/\/ send the key event to the current focus owner or to scene if\n+        \/\/ the focus owner is not set\n+        Event.fireEvent(eventTarget, e);\n@@ -2164,1 +2192,5 @@\n-        getKeyHandler().requestFocus(node, focusVisible);\n+        if (node == null) {\n+            setFocusOwner(null, false);\n+        } else if (node.isCanReceiveFocus()) {\n+            setFocusOwner(node, focusVisible);\n+        }\n@@ -2167,2 +2199,0 @@\n-    private Node oldFocusOwner;\n-\n@@ -2175,1 +2205,21 @@\n-    private ReadOnlyObjectWrapper<Node> focusOwner = new ReadOnlyObjectWrapper<Node>(this, \"focusOwner\") {\n+    private FocusOwnerProperty focusOwner = new FocusOwnerProperty();\n+\n+    private class FocusOwnerProperty extends ReadOnlyObjectWrapper<Node> {\n+        Node oldValue;\n+\n+        \/**\n+         * Stores whether the current focus owner visibly indicates focus.\n+         * This value is used to restore visible focus when a window loses\n+         * and re-gains focus.\n+         *\/\n+        boolean focusVisible;\n+\n+        @Override\n+        public Object getBean() {\n+            return Scene.this;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return \"focusOwner\";\n+        }\n@@ -2179,2 +2229,2 @@\n-            if (oldFocusOwner != null) {\n-                oldFocusOwner.setFocusQuietly(false, false);\n+            if (oldValue != null) {\n+                oldValue.setFocusQuietly(false, false);\n@@ -2184,2 +2234,2 @@\n-                value.setFocusQuietly(keyHandler.windowFocused, keyHandler.focusVisible);\n-                if (value != oldFocusOwner) {\n+                value.setFocusQuietly(windowFocused, focusVisible);\n+                if (value != oldValue) {\n@@ -2194,2 +2244,2 @@\n-            Node localOldOwner = oldFocusOwner;\n-            oldFocusOwner = value;\n+            Node localOldOwner = oldValue;\n+            oldValue = value;\n@@ -2219,0 +2269,4 @@\n+    public final ReadOnlyObjectProperty<Node> focusOwnerProperty() {\n+        return focusOwner.getReadOnlyProperty();\n+    }\n+\n@@ -2223,2 +2277,29 @@\n-    public final ReadOnlyObjectProperty<Node> focusOwnerProperty() {\n-        return focusOwner.getReadOnlyProperty();\n+    private void setFocusOwner(Node node, boolean focusVisible) {\n+        \/\/ Cancel IM composition if there is one in progress.\n+        \/\/ This needs to be done before the focus owner is switched as it\n+        \/\/ generates event that needs to be delivered to the old focus owner.\n+        if (focusOwner.oldValue != null) {\n+            final Scene s = focusOwner.oldValue.getScene();\n+            if (s != null) {\n+                final TKScene peer = s.getPeer();\n+                if (peer != null) {\n+                    peer.finishInputMethodComposition();\n+                }\n+            }\n+        }\n+\n+        \/\/ Store the current focusVisible state of the focus owner in case it needs to be\n+        \/\/ restored when a window loses and re-gains focus.\n+        focusOwner.focusVisible = focusVisible;\n+\n+        if (focusOwner.get() != node) {\n+            \/\/ If the focus owner has changed, FocusOwnerProperty::invalidated will update\n+            \/\/ the node's focusVisible flag.\n+            focusOwner.set(node);\n+        } else if (node != null) {\n+            \/\/ If the focus owner has not changed (i.e. only focusVisible has changed),\n+            \/\/ FocusOwnerProperty::invalidated will not be called, therefore we need to\n+            \/\/ update the node's focusVisible flag manually.\n+            node.focusVisible.set(focusVisible);\n+            node.focusVisible.notifyListeners();\n+        }\n@@ -4044,86 +4125,0 @@\n-    \/* *****************************************************************************\n-     *                                                                             *\n-     * Key Event Handling                                                          *\n-     *                                                                             *\n-     ******************************************************************************\/\n-\n-    class KeyHandler {\n-        boolean focusVisible;\n-\n-        private void setFocusOwner(Node value, boolean focusVisible) {\n-            this.focusVisible = focusVisible;\n-\n-            \/\/ Cancel IM composition if there is one in progress.\n-            \/\/ This needs to be done before the focus owner is switched as it\n-            \/\/ generates event that needs to be delivered to the old focus owner.\n-            if (oldFocusOwner != null) {\n-                final Scene s = oldFocusOwner.getScene();\n-                if (s != null) {\n-                    final TKScene peer = s.getPeer();\n-                    if (peer != null) {\n-                        peer.finishInputMethodComposition();\n-                    }\n-                }\n-            }\n-            focusOwner.set(value);\n-        }\n-\n-        private void setFocusVisible(Node node, boolean focusVisible) {\n-            this.focusVisible = focusVisible;\n-            node.focusVisible.set(focusVisible);\n-            node.focusVisible.notifyListeners();\n-        }\n-\n-        private boolean windowFocused;\n-        protected boolean isWindowFocused() { return windowFocused; }\n-        protected void setWindowFocused(boolean value) {\n-            windowFocused = value;\n-            if (getFocusOwner() != null) {\n-                getFocusOwner().setFocusQuietly(windowFocused, focusVisible);\n-                getFocusOwner().notifyFocusListeners();\n-            }\n-            if (windowFocused) {\n-                if (accessible != null) {\n-                    accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);\n-                }\n-            }\n-        }\n-\n-        private void windowForSceneChanged(Window oldWindow, Window window) {\n-            if (oldWindow != null) {\n-                oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);\n-            }\n-\n-            if (window != null) {\n-                window.focusedProperty().addListener(sceneWindowFocusedListener);\n-                setWindowFocused(window.isFocused());\n-            } else {\n-                setWindowFocused(false);\n-            }\n-        }\n-\n-        private final InvalidationListener sceneWindowFocusedListener = valueModel -> setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());\n-\n-        private void process(KeyEvent e) {\n-            final Node sceneFocusOwner = getFocusOwner();\n-            final EventTarget eventTarget =\n-                    (sceneFocusOwner != null && sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner\n-                                              : Scene.this;\n-\n-            \/\/ send the key event to the current focus owner or to scene if\n-            \/\/ the focus owner is not set\n-            Event.fireEvent(eventTarget, e);\n-        }\n-\n-        private void requestFocus(Node node, boolean focusVisible) {\n-            if (node == null) {\n-                setFocusOwner(null, false);\n-            } else if (node.isCanReceiveFocus()) {\n-                if (node != getFocusOwner()) {\n-                    setFocusOwner(node, focusVisible);\n-                } else {\n-                    setFocusVisible(node, focusVisible);\n-                }\n-            }\n-        }\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":106,"deletions":111,"binary":false,"changes":217,"status":"modified"}]}