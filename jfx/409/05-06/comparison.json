{"files":[{"patch":"@@ -212,5 +212,8 @@\n-     * Subclasses can invoke this method to register that they want to listen to\n-     * property change events for the given property. Registered {@link Consumer} instances\n-     * will be executed in the order in which they are registered.\n-     * @param property the property\n-     * @param consumer the consumer\n+     * Registers an operation to perform when the given {@code property} sends a change event.\n+     * Does nothing if either {@code property} or {@code operation} are {@code null}.\n+     * If multiple operations are registered on the same property, they will be performed in the\n+     * order in which they were registered.\n+     *\n+     * @param property the property to observe for change events, may be {@code null}\n+     * @param operation the operation to perform when the property sends a change event,\n+     *  may be {@code null}\n@@ -218,1 +221,1 @@\n-    protected final void registerChangeListener(ObservableValue<?> property, Consumer<ObservableValue<?>> consumer) {\n+    protected final void registerChangeListener(ObservableValue<?> property, Consumer<ObservableValue<?>> operation) {\n@@ -222,1 +225,1 @@\n-        lambdaChangeListenerHandler.registerChangeListener(property, consumer);\n+        lambdaChangeListenerHandler.registerChangeListener(property, operation);\n@@ -226,4 +229,3 @@\n-     * Unregisters all change listeners that have been registered using {@link #registerChangeListener(ObservableValue, Consumer)}\n-     * for the given property. The end result is that the given property is no longer observed by any of the change\n-     * listeners, but it may still have additional listeners registered on it through means outside of\n-     * {@link #registerChangeListener(ObservableValue, Consumer)}.\n+     * Unregisters all operations that have been registered using\n+     * {@link #registerChangeListener(ObservableValue, Consumer)}\n+     * for the given {@code property}. Does nothing if {@code property} is {@code null}.\n@@ -231,4 +233,4 @@\n-     * @param property The property for which all listeners should be removed.\n-     * @return A single chained {@link Consumer} consisting of all {@link Consumer consumers} registered through\n-     *      {@link #registerChangeListener(ObservableValue, Consumer)}. If no consumers have been registered on this\n-     *      property, null will be returned.\n+     * @param property the property for which the registered operations should be removed,\n+     *  may be {@code null}\n+     * @return a composed consumer representing all previously registered operations, or\n+     *  {@code null} if none have been registered or the propery is {@code null}\n@@ -265,1 +267,1 @@\n-     * for the given {@code observable}. Does nothing if {@code observable} is {@code null}\n+     * for the given {@code observable}. Does nothing if {@code observable} is {@code null}.\n@@ -282,3 +284,4 @@\n-     * Subclasses can invoke this method to register that they want to listen to\n-     * list change events for the given observable list. Registered {@link Consumer} instances\n-     * will be executed in the order in which they are registered.\n+     * Registers an operation to perform when the given {@code observableList} sends a list change event.\n+     * Does nothing if either {@code observableList} or {@code operation} are {@code null}.\n+     * If multiple operations are registered on the same observableList, they will be performed in the\n+     * order in which they were registered.\n@@ -286,2 +289,3 @@\n-     * @param observableList the observable list to observe for list change events\n-     * @param consumer the consumer\n+     * @param observableList the observableList to observe for list change events, may be {@code null}\n+     * @param operation the operation to perform when the observableList sends a list change event,\n+     *  may be {@code null}\n@@ -290,1 +294,1 @@\n-    protected final void registerListChangeListener(ObservableList<?> observableList, Consumer<Change<?>> consumer) {\n+    protected final void registerListChangeListener(ObservableList<?> observableList, Consumer<Change<?>> operation) {\n@@ -294,1 +298,1 @@\n-        lambdaChangeListenerHandler.registerListChangeListener(observableList, consumer);\n+        lambdaChangeListenerHandler.registerListChangeListener(observableList, operation);\n@@ -298,1 +302,1 @@\n-     * Unregisters all list change listeners that have been registered using\n+     * Unregisters all operations that have been registered using\n@@ -300,4 +304,1 @@\n-     * for the given list. The end result is that the given observable is no longer observed by any of the\n-     * list change listeners,\n-     * but it may still have additional listeners registered on it through means outside of\n-     * {@link #registerListChangeListener(ObservableList, Consumer)}.\n+     * for the given {@code observableList}. Does nothing if {@code observableList} is {@code null}.\n@@ -305,4 +306,4 @@\n-     * @param observableList The list for which all listeners should be removed.\n-     * @return A single chained {@link Consumer} consisting of all {@link Consumer consumers} registered through\n-     *      {@link #registerListChangeListener(ObservableList, Consumer)}. If no consumers have been registered on this\n-     *      list, null will be returned.\n+     * @param observableList the observableList for which the registered operations should be removed,\n+     *  may be {@code null}\n+     * @return a composed consumer representing all previously registered operations, or\n+     *  {@code null} if none have been registered or the observableList is {@code null}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/SkinBase.java","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"}]}