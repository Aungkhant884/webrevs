{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import javafx.beans.value.ChangeListener;\n-import javafx.beans.value.ObservableValue;\n-import javafx.beans.value.WeakChangeListener;\n-\n@@ -33,0 +29,1 @@\n+import java.util.IdentityHashMap;\n@@ -36,0 +33,29 @@\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.WeakInvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.beans.value.WeakChangeListener;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ListChangeListener.Change;\n+import javafx.collections.ObservableList;\n+import javafx.collections.WeakListChangeListener;\n+\n+\/**\n+ * Handler to manage multiple listeners to multiple observables. It handles\n+ * adding\/removing listeners for common notification events (change,\n+ * invalidation and list change) on particular instances of observables. The\n+ * listeners are wrapped into their weak counterparts to minimize the potential of\n+ * memory leaks.\n+ * <p>\n+ * Clients can register consumers to be invoked on receiving notification.\n+ * Un-\/Registration api is separate per notification type and per observable.\n+ * It is allowed to register multiple consumers per observable. They\n+ * are executed in the order of registration. Note that unregistration\n+ * of a given observable stops observing that observable (for the notification\n+ * type of the unregistration) completely, that is none of the consumers\n+ * previously registered with this handler will be executed after unregistering.\n+ * <p>\n+ * Disposing removes all listeners added by this handler from all registered observables.\n+ *\n+ *\/\n@@ -37,0 +63,1 @@\n+\/\/ FIXME: name doesn't fit after widening to support more notification event types\n@@ -38,0 +65,4 @@\n+    @SuppressWarnings(\"rawtypes\")\n+    private  static final Consumer EMPTY_CONSUMER = e -> {};\n+\n+    \/\/ support change listeners\n@@ -42,1 +73,9 @@\n-    private static final Consumer<ObservableValue<?>> EMPTY_CONSUMER = e -> {};\n+    \/\/ support invalidation listeners\n+    private final Map<Observable, Consumer<Observable>> observableReferenceMap;\n+    private final InvalidationListener invalidationListener;\n+    private final WeakInvalidationListener weakInvalidationListener;\n+\n+    \/\/ support list change listeners\n+    private final Map<ObservableList<?>, Consumer<Change<?>>> observableListReferenceMap;\n+    private final ListChangeListener<Object> listChangeListener;\n+    private final WeakListChangeListener<Object> weakListChangeListener;\n@@ -45,0 +84,1 @@\n+        \/\/ change listening support\n@@ -52,0 +92,14 @@\n+\n+        \/\/ invalidation listening support\n+        this.observableReferenceMap = new HashMap<>();\n+        this.invalidationListener =  obs -> {\n+            observableReferenceMap.getOrDefault(obs, EMPTY_CONSUMER).accept(obs);\n+        };\n+        this.weakInvalidationListener = new WeakInvalidationListener(invalidationListener);\n+\n+        \/\/ list change listening support\n+        this.observableListReferenceMap = new IdentityHashMap<>();\n+        this.listChangeListener = change -> {\n+            observableListReferenceMap.getOrDefault(change.getList(), EMPTY_CONSUMER).accept(change);\n+        };\n+        this.weakListChangeListener = new WeakListChangeListener<>(listChangeListener);\n@@ -55,2 +109,3 @@\n-     * Subclasses can invoke this method to register that we want to listen to\n-     * property change events for the given property.\n+     * Registers a consumer to be invoked on change notification from the given property. Does nothing\n+     * if property or consumer is null. Consumers registered to the same property will be executed\n+     * in the order they have been registered.\n@@ -58,1 +113,2 @@\n-     * @param property\n+     * @param property the property to observe for change notification\n+     * @param consumer the consumer to be invoked on change notification from the property\n@@ -61,1 +117,1 @@\n-        if (consumer == null) return;\n+        if (property == null || consumer == null) return;\n@@ -73,1 +129,10 @@\n-    \/\/ need to be careful here - removing all listeners on the specific property!\n+    \/**\n+     * Stops observing the given property for change notification. Returns\n+     * a single chained consumer consisting of all consumers registered with\n+     * {@link #registerChangeListener(ObservableValue, Consumer)} in the order they\n+     * have been registered.\n+     *\n+     * @param property the property to stop observing for change notification\n+     * @return a single chained consumer consisting of all consumers registered for the given property\n+     *    or null if none has been registered or the property is null\n+     *\/\n@@ -75,0 +140,1 @@\n+        if (property == null) return null;\n@@ -79,0 +145,72 @@\n+    \/**\n+     * Registers a consumer to be invoked on invalidation notification from the given observable.\n+     * Does nothing if observable or consumer is null. Consumers registered to the same observable will be executed\n+     * in the order they have been registered.\n+     *\n+     * @param observable the observable to observe for invalidation notification\n+     * @param consumer the consumer to be invoked on invalidation notification from the observable\n+     *\n+     *\/\n+    public final void registerInvalidationListener(Observable observable, Consumer<Observable> consumer) {\n+        if (observable == null || consumer == null) return;\n+        if (!observableReferenceMap.containsKey(observable)) {\n+            observable.addListener(weakInvalidationListener);\n+        }\n+        observableReferenceMap.merge(observable, consumer, Consumer::andThen);\n+    }\n+\n+    \/**\n+     * Stops observing the given observable for invalidation notification.\n+     * Returns a single chained consumer consisting of all consumers registered with\n+     * {@link #registerInvalidationListener(Observable, Consumer)} in the\n+     * order they have been registered.\n+     *\n+     * @param observable the observable to stop observing for invalidation notification\n+     * @return a single chained consumer consisting of all consumers registered for given observable\n+     *    or null if none has been registered or the observable is null\n+     *\n+     *\/\n+    public final Consumer<Observable> unregisterInvalidationListeners(Observable observable) {\n+        if (observable == null) return null;\n+        observable.removeListener(weakInvalidationListener);\n+        return observableReferenceMap.remove(observable);\n+    }\n+\n+    \/**\n+     * Registers a consumer to be invoked on list change notification from the given observable list.\n+     * Does nothing if list or consumer is null. Consumers registered to the same observable list\n+     * will be executed in the order they have been registered.\n+     *\n+     * @param list the observable list observe for list change notification\n+     * @param consumer the consumer to be invoked on list change notification from the list\n+     *\n+     *\/\n+    public final void registerListChangeListener(ObservableList<?> list, Consumer<Change<?>> consumer) {\n+        if (list == null || consumer == null) return;\n+        if (!observableListReferenceMap.containsKey(list)) {\n+            list.addListener(weakListChangeListener);\n+        }\n+        observableListReferenceMap.merge(list, consumer, Consumer::andThen);\n+    }\n+\n+    \/**\n+     * Stops observing the given observable list for list change notification.\n+     * Returns a single chained consumer consisting of all consumers registered with\n+     * {@link #registerListChangeListener(ObservableList, Consumer)} in the order they have been registered.\n+     *\n+     * @param list the observable list to stop observing for list change notification\n+     * @return a single chained consumer consisting of all consumers added for the given list\n+     *    or null if none has been registered or the list is null\n+     *\/\n+    public final Consumer<Change<?>> unregisterListChangeListeners(ObservableList<?> list) {\n+        if (list == null) return null;\n+        list.removeListener(weakListChangeListener);\n+        return observableListReferenceMap.remove(list);\n+    }\n+\n+\n+    \/**\n+     * Stops observing all types of notification from all registered observables.\n+     * <p>\n+     * Note: this handler is still usable after calling this method.\n+     *\/\n@@ -80,1 +218,1 @@\n-        \/\/ unhook listeners\n+        \/\/ unhook change listeners\n@@ -85,0 +223,10 @@\n+        \/\/ unhook invalidation listeners\n+        for (Observable value : observableReferenceMap.keySet()) {\n+            value.removeListener(weakInvalidationListener);\n+        }\n+        observableReferenceMap.clear();\n+        \/\/ unhook list change listeners\n+        for (ObservableList<?> list : observableListReferenceMap.keySet()) {\n+            list.removeListener(weakListChangeListener);\n+        }\n+        observableListReferenceMap.clear();\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/LambdaMultiplePropertyChangeListenerHandler.java","additions":160,"deletions":12,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;\n-import javafx.beans.value.ObservableValue;\n-import javafx.css.CssMetaData;\n-import javafx.css.PseudoClass;\n@@ -36,0 +32,5 @@\n+import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;\n+\n+import javafx.beans.Observable;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.ListChangeListener.Change;\n@@ -37,0 +38,2 @@\n+import javafx.css.CssMetaData;\n+import javafx.css.PseudoClass;\n@@ -209,5 +212,8 @@\n-     * Subclasses can invoke this method to register that they want to listen to\n-     * property change events for the given property. Registered {@link Consumer} instances\n-     * will be executed in the order in which they are registered.\n-     * @param property the property\n-     * @param consumer the consumer\n+     * Registers an operation to perform when the given {@code property} sends a change event.\n+     * Does nothing if either {@code property} or {@code operation} are {@code null}.\n+     * If multiple operations are registered on the same property, they will be performed in the\n+     * order in which they were registered.\n+     *\n+     * @param property the property to observe for change events, may be {@code null}\n+     * @param operation the operation to perform when the property sends a change event,\n+     *  may be {@code null}\n@@ -215,1 +221,1 @@\n-    protected final void registerChangeListener(ObservableValue<?> property, Consumer<ObservableValue<?>> consumer) {\n+    protected final void registerChangeListener(ObservableValue<?> property, Consumer<ObservableValue<?>> operation) {\n@@ -219,1 +225,1 @@\n-        lambdaChangeListenerHandler.registerChangeListener(property, consumer);\n+        lambdaChangeListenerHandler.registerChangeListener(property, operation);\n@@ -223,4 +229,3 @@\n-     * Unregisters all change listeners that have been registered using {@link #registerChangeListener(ObservableValue, Consumer)}\n-     * for the given property. The end result is that the given property is no longer observed by any of the change\n-     * listeners, but it may still have additional listeners registered on it through means outside of\n-     * {@link #registerChangeListener(ObservableValue, Consumer)}.\n+     * Unregisters all operations that have been registered using\n+     * {@link #registerChangeListener(ObservableValue, Consumer)}\n+     * for the given {@code property}. Does nothing if {@code property} is {@code null}.\n@@ -228,4 +233,4 @@\n-     * @param property The property for which all listeners should be removed.\n-     * @return A single chained {@link Consumer} consisting of all {@link Consumer consumers} registered through\n-     *      {@link #registerChangeListener(ObservableValue, Consumer)}. If no consumers have been registered on this\n-     *      property, null will be returned.\n+     * @param property the property for which the registered operations should be removed,\n+     *  may be {@code null}\n+     * @return a composed consumer representing all previously registered operations, or\n+     *  {@code null} if none have been registered or the propery is {@code null}\n@@ -241,0 +246,17 @@\n+    \/**\n+     * Registers an operation to perform when the given {@code observable} sends an invalidation event.\n+     * Does nothing if either {@code observable} or {@code operation} are {@code null}.\n+     * If multiple operations are registered on the same observable, they will be performed in the\n+     * order in which they were registered.\n+     *\n+     * @param observable the observable to observe for invalidation events, may be {@code null}\n+     * @param operation the operation to perform when the observable sends an invalidation event,\n+     *  may be {@code null}\n+     * @since 17\n+     *\/\n+    protected final void registerInvalidationListener(Observable observable, Consumer<Observable> operation) {\n+        if (lambdaChangeListenerHandler == null) {\n+            lambdaChangeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();\n+        }\n+        lambdaChangeListenerHandler.registerInvalidationListener(observable, operation);\n+    }\n@@ -242,0 +264,54 @@\n+    \/**\n+     * Unregisters all operations that have been registered using\n+     * {@link #registerInvalidationListener(Observable, Consumer)}\n+     * for the given {@code observable}. Does nothing if {@code observable} is {@code null}.\n+     *\n+     * @param observable the observable for which the registered operations should be removed,\n+     *  may be {@code null}\n+     * @return a composed consumer representing all previously registered operations, or\n+     *  {@code null} if none have been registered or the observable is {@code null}\n+     * @since 17\n+     *\/\n+    protected final Consumer<Observable> unregisterInvalidationListeners(Observable observable) {\n+        if (lambdaChangeListenerHandler == null) {\n+            return null;\n+        }\n+        return lambdaChangeListenerHandler.unregisterInvalidationListeners(observable);\n+    }\n+\n+\n+    \/**\n+     * Registers an operation to perform when the given {@code observableList} sends a list change event.\n+     * Does nothing if either {@code observableList} or {@code operation} are {@code null}.\n+     * If multiple operations are registered on the same observableList, they will be performed in the\n+     * order in which they were registered.\n+     *\n+     * @param observableList the observableList to observe for list change events, may be {@code null}\n+     * @param operation the operation to perform when the observableList sends a list change event,\n+     *  may be {@code null}\n+     * @since 17\n+     *\/\n+    protected final void registerListChangeListener(ObservableList<?> observableList, Consumer<Change<?>> operation) {\n+        if (lambdaChangeListenerHandler == null) {\n+            lambdaChangeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();\n+        }\n+        lambdaChangeListenerHandler.registerListChangeListener(observableList, operation);\n+    }\n+\n+    \/**\n+     * Unregisters all operations that have been registered using\n+     * {@link #registerListChangeListener(ObservableList, Consumer)}\n+     * for the given {@code observableList}. Does nothing if {@code observableList} is {@code null}.\n+     *\n+     * @param observableList the observableList for which the registered operations should be removed,\n+     *  may be {@code null}\n+     * @return a composed consumer representing all previously registered operations, or\n+     *  {@code null} if none have been registered or the observableList is {@code null}\n+     * @since 17\n+     *\/\n+    protected final Consumer<Change<?>> unregisterListChangeListeners(ObservableList<?> observableList) {\n+        if (lambdaChangeListenerHandler == null) {\n+            return null;\n+        }\n+        return lambdaChangeListenerHandler.unregisterListChangeListeners(observableList);\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/SkinBase.java","additions":96,"deletions":20,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-public class SkinBaseShim<C extends Control> extends SkinBase {\n+public class SkinBaseShim<C extends Control> extends SkinBase<C> {\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/SkinBaseShim.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.scene.control;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;\n+\n+import static org.junit.Assert.*;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n+\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ListChangeListener.Change;\n+import javafx.collections.ObservableList;\n+\n+\/**\n+ * Test support of listChange listeners.\n+ *\/\n+public class LambdaMultipleHandlerTest {\n+\n+    private LambdaMultiplePropertyChangeListenerHandler handler;\n+    private ObservableList<String> items;\n+\n+\/\/------------ unregister\n+\n+    \/**\n+     * Single consumer for multiple lists: test that\n+     * removing from one list doesn't effect listening to other list\n+     *\/\n+    @Test\n+    public void testUnregistersSingleConsumerMultipleLists() {\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = change -> changes.add(change);\n+        ObservableList<String> otherList = FXCollections.observableArrayList(\"other\");\n+        handler.registerListChangeListener(items, consumer);\n+        handler.registerListChangeListener(otherList, consumer);\n+        handler.unregisterListChangeListeners(otherList);\n+        items.add(\"added\");\n+        otherList.add(\"added other\");\n+        assertEquals(1, changes.size());\n+        assertEquals(items, changes.get(0).getList());\n+    }\n+\n+    \/**\n+     * Test that all consumers for a single list are removed\n+     * and manually adding the removed consumer chain as listener\n+     * has the same effect as when invoked via handler.\n+     *\/\n+    @Test\n+    public void testUnregistersMultipleConsumers() {\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = change -> changes.add(change);\n+        List<Change<?>> secondChanges = new ArrayList<>();\n+        Consumer<Change<?>> secondConsumer = change -> secondChanges.addAll(changes);\n+        handler.registerListChangeListener(items, consumer);\n+        handler.registerListChangeListener(items, secondConsumer);\n+        \/\/ remove listener chain\n+        Consumer<Change<?>> removedChain = handler.unregisterListChangeListeners(items);\n+        items.add(\"added after removed\");\n+        assertEquals(\"none of the removed listeners must be notified\",\n+                0, changes.size() + secondChanges.size());\n+       \/\/ manually add the chained listener\n+        items.addListener((ListChangeListener)(c -> removedChain.accept(c)));\n+        items.add(\"added\");\n+        assertEquals(1, changes.size());\n+        assertEquals(changes, secondChanges);\n+    }\n+\n+    @Test\n+    public void testUnregistersSingleConsumer() {\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = change -> changes.add(change);\n+        ObservableList<String> otherList = FXCollections.observableArrayList(\"other\");\n+        handler.registerListChangeListener(items, consumer);\n+        Consumer<Change<?>> removed = handler.unregisterListChangeListeners(items);\n+        items.add(\"added\");\n+        assertEquals(0, changes.size());\n+        assertSame(consumer, removed);\n+    }\n+\n+    \/**\n+     * Test unregisters not registered list.\n+     *\/\n+    @Test\n+    public void testUnregistersNotRegistered() {\n+        assertNull(handler.unregisterListChangeListeners(items));\n+    }\n+\n+    @Test\n+    public void testUnregistersNull() {\n+        assertNull(handler.unregisterListChangeListeners(null));\n+    }\n+\n+\n+\/\/------------- register\n+\n+    @Test\n+    public void testRegisterConsumerToMultipleLists() {\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = change -> changes.add(change);\n+        ObservableList<String> otherList = FXCollections.observableArrayList(\"other\");\n+        handler.registerListChangeListener(items, consumer);\n+        handler.registerListChangeListener(otherList, consumer);\n+        items.add(\"added\");\n+        otherList.add(\"added other\");\n+        assertEquals(2, changes.size());\n+        assertEquals(items, changes.get(0).getList());\n+        assertEquals(otherList, changes.get(1).getList());\n+    }\n+\n+    \/**\n+     * Test that multiple consumers to same observable are invoked in order\n+     * of registration.\n+     *\/\n+    @Test\n+    public void testRegisterMultipleConsumerToSingleList() {\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = change -> changes.add(change);\n+        List<Change<?>> secondChanges = new ArrayList<>();\n+        Consumer<Change<?>> secondConsumer = change -> secondChanges.addAll(changes);\n+        handler.registerListChangeListener(items, consumer);\n+        handler.registerListChangeListener(items, secondConsumer);\n+        items.add(\"added\");\n+        assertEquals(1, changes.size());\n+        assertEquals(changes, secondChanges);\n+    }\n+\n+    @Test\n+    public void testRegister() {\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = change -> changes.add(change);\n+        handler.registerListChangeListener(items, consumer);\n+        String added = \"added\";\n+        items.add(added);\n+        assertEquals(1, changes.size());\n+        Change<?> change = changes.get(0);\n+        change.next();\n+        assertTrue(change.wasAdded());\n+        assertTrue(change.getAddedSubList().contains(added));\n+    }\n+\n+    @Test\n+    public void testRegisterNullConsumer() {\n+        handler.registerListChangeListener(items, null);\n+    }\n+\n+    @Test\n+    public void testRegisterNullList() {\n+        handler.registerListChangeListener(null, c -> {});\n+    }\n+\n+\/\/--------- dispose\n+\n+    @Test\n+    public void testDispose() {\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = change -> changes.add(change);\n+        handler.registerListChangeListener(items, consumer);\n+        handler.dispose();\n+        items.add(\"added\");\n+        assertEquals(\"listener must not be invoked after dispose\", 0, changes.size());\n+        handler.registerListChangeListener(items, consumer);\n+        items.add(\"added\");\n+        assertEquals(\"listener must be invoked when re-registered after dispose\", 1, changes.size());\n+    }\n+\n+\n+\/\/--------- test weak registration\n+\n+    \/**\n+     * Test that handler is gc'ed and listener no longer notified.\n+     *\/\n+    @Test\n+    public void testRegisterMemoryLeak() {\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = change -> changes.add(change);\n+        WeakReference<LambdaMultiplePropertyChangeListenerHandler> ref =\n+                new WeakReference<>(new LambdaMultiplePropertyChangeListenerHandler());\n+        ref.get().registerListChangeListener(items, consumer);\n+        items.add(\"added\");\n+        assertEquals(1, changes.size());\n+        attemptGC(ref);\n+        assertNull(\"handler must be gc'ed\", ref.get());\n+        items.add(\"another\");\n+        assertEquals(\"listener must not be invoked after gc\", 1, changes.size());\n+    }\n+\n+\n+\/\/----------- setup and intial\n+\n+    @Before\n+    public void setup() {\n+        handler = new LambdaMultiplePropertyChangeListenerHandler();\n+        items = FXCollections.observableArrayList(\"one\", \"two\", \"four\");\n+    }\n+\n+    \/**\n+     * Demonstrating why we need an invalidation listener for list-valued observables.\n+     *\/\n+    @Test\n+    public void testInvalidationOfListValuedObservable() {\n+        String[] data = {\"one\", \"two\", \"other\"};\n+        ObservableList<String> first = FXCollections.observableArrayList(data);\n+        ObjectProperty<ObservableList<String>> itemsProperty = new SimpleObjectProperty<>(first);\n+        assertSame(first, itemsProperty.get());\n+        int[] invalidations = new int[] {0};\n+        int[] changes = new int[] {0};\n+        itemsProperty.addListener(obs -> invalidations[0]++);\n+        itemsProperty.addListener((obs, ov, nv) -> changes[0]++);\n+        itemsProperty.set(FXCollections.observableArrayList(data));\n+        \/\/ notifications when newList.equals(oldList)\n+        assertEquals(\"changeListener not notified\", 0, changes[0]);\n+        assertEquals(\"invalidationListener notified\", 1, invalidations[0]);\n+        itemsProperty.get().add(\"added\");\n+        \/\/ sanity: no notification on modifications to the list\n+        assertEquals(0, changes[0]);\n+        assertEquals(1, invalidations[0]);\n+        \/\/ sanity: notification from both when !newList.equals(oldList)\n+        itemsProperty.set(first);\n+        assertEquals(1, changes[0]);\n+        assertEquals(2, invalidations[0]);\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/LambdaMultipleHandlerTest.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.scene.control;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;\n+\n+import static org.junit.Assert.*;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n+\n+import javafx.beans.Observable;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.binding.NumberBinding;\n+import javafx.beans.property.IntegerProperty;\n+import javafx.beans.property.SimpleIntegerProperty;\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * Test LambdaMultiplePropertyChangeListenerHandler.\n+ * <p>\n+ *\n+ * This test is parameterized in testing change- or invalidationListener api.\n+ *\/\n+@RunWith(Parameterized.class)\n+public class LambdaMultipleObservableHandlerTest {\n+\n+    private LambdaMultiplePropertyChangeListenerHandler handler;\n+    private boolean useChangeListener;\n+\n+\/\/ -------------- unregister\n+\n+    \/**\n+     * Single consumer for multiple observables: test that\n+     * removing from one observable doesn't effect listening to other observable\n+     *\/\n+    @Test\n+    public void testUnregistersSingleConsumerMultipleObservables() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        IntegerProperty other = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        Consumer<ObservableValue<?>> consumer = c -> count[0]++;\n+        registerListener(p, consumer);\n+        registerListener(other, consumer);\n+        unregisterListeners(other);\n+        p.set(100);\n+        other.set(100);\n+        assertEquals(1, count[0]);\n+    }\n+\n+    \/**\n+     * Test that all consumers for a single observable are removed\n+     * and manually adding the removed consumer chain as listener\n+     * has the same effect as when invoked via handler.\n+     *\/\n+    @Test\n+    public void testUnregistersMultipleConsumers() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] action = new int[] {0};\n+        int actionValue = 10;\n+        int[] secondAction = new int[] {0};\n+        \/\/ register multiple consumers\n+        registerListener(p, c -> action[0] = actionValue);\n+        registerListener(p, c -> secondAction[0] = action[0]);\n+        \/\/ remove all\n+        Consumer removedChain = unregisterListeners(p);\n+        p.set(100);\n+        assertEquals(\"none of the removed listeners must be notified\", 0, action[0] + secondAction[0]);\n+\n+        \/\/ manually add the chained consumers\n+        addListener(p, removedChain);\n+        p.set(200);\n+        \/\/ assert effect of manually added chain is same\n+        assertEquals(\"effect of removed consumer chain\", actionValue, action[0]);\n+        assertEquals(\"effect of removed consumer chain\", action[0], secondAction[0]);\n+    }\n+\n+    @Test\n+    public void testUnregistersSingleConsumer() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        Consumer<Observable> consumer = c -> count[0]++;\n+        registerListener(p, consumer);\n+        Consumer<Observable> removed = unregisterListeners(p);\n+        p.set(100);\n+        assertEquals(0, count[0]);\n+        assertSame(\"single registered listener must be returned\", consumer, removed);\n+    }\n+\n+    \/**\n+     * Test unregisters not registered observable.\n+     *\/\n+    @Test\n+    public void testUnregistersNotRegistered() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        assertNull(unregisterListeners(p));\n+    }\n+\n+    @Test\n+    public void testUnregistersNull() {\n+        assertNull(unregisterListeners(null));\n+    }\n+\n+\n+\/\/------------ register\n+\n+    @Test\n+    public void testRegisterConsumerToMultipleObservables() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        IntegerProperty other = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        Consumer<Observable> consumer = c -> count[0]++;\n+        registerListener(p, consumer);\n+        registerListener(other, consumer);\n+        p.set(100);\n+        other.set(100);\n+        assertEquals(2, count[0]);\n+    }\n+\n+    \/**\n+     * Test that multiple consumers to same observable are invoked in order\n+     * of registration.\n+     *\/\n+    @Test\n+    public void testRegisterMultipleConsumerToSingleObservable() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] action = new int[] {0};\n+        int actionValue = 10;\n+        int[] secondAction = new int[] {0};\n+        registerListener(p, c -> action[0] = actionValue);\n+        registerListener(p, c -> secondAction[0] = action[0]);\n+        p.set(100);\n+        assertEquals(actionValue, action[0]);\n+        assertEquals(action[0], secondAction[0]);\n+    }\n+\n+    @Test\n+    public void testRegister() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        registerListener(p, c -> count[0]++);\n+        p.set(100);\n+        assertEquals(1, count[0]);\n+    }\n+\n+    @Test\n+    public void testRegisterNullConsumer() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        registerListener(p, null);\n+    }\n+\n+    @Test\n+    public void testRegisterNullObservable() {\n+        registerListener(null, c -> {});\n+    }\n+\n+\/\/--------- dispose\n+\n+    @Test\n+    public void testDispose() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        registerListener(p, c -> count[0]++);\n+        handler.dispose();\n+        p.set(100);\n+        assertEquals(\"listener must not be invoked after dispose\", 0, count[0]);\n+        \/\/ re-register\n+        registerListener(p, c -> count[0]++);\n+        p.set(200);\n+        assertEquals(\"listener must be invoked when re-registered after dispose\", 1, count[0]);\n+    }\n+\n+\n+\/\/--------- test weak registration\n+\n+    \/**\n+     * Test that handler is gc'ed and listener no longer notified.\n+     *\/\n+    @Test\n+    public void testRegisterMemoryLeak() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        Consumer<ObservableValue<?>> consumer = c -> count[0]++;\n+        WeakReference<LambdaMultiplePropertyChangeListenerHandler> ref =\n+                new WeakReference<>(new LambdaMultiplePropertyChangeListenerHandler());\n+        registerListener(ref.get(), p, consumer);\n+        p.setValue(100);\n+        int notified = count[0];\n+        assertEquals(\"sanity: listener invoked\", notified, count[0]);\n+        assertNotNull(ref.get());\n+        attemptGC(ref);\n+        assertNull(\"handler must be gc'ed\", ref.get());\n+        p.setValue(200);\n+        assertEquals(\"listener must not be invoked after gc\", notified, count[0]);\n+    }\n+\n+\n+\/\/-------------- not-parameterized tests\n+\/\/ guard against cross-over effects for change\/invalidationListener on same observable\n+\n+    \/**\n+     * Register both invalidation\/change listener on same property.\n+     *\/\n+    @Test\n+    public void testRegisterBoth() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        handler.registerChangeListener(p, c -> count[0]++);\n+        handler.registerInvalidationListener(p, c -> count[0]++);\n+        p.set(100);\n+        assertEquals(\"both listener types must be invoked\", 2, count[0]);\n+    }\n+\n+    \/**\n+     * Register both invalidation\/change listener, remove change listener\n+     *\/\n+    @Test\n+    public void testRegisterBothRemoveChangeListener() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        handler.registerChangeListener(p, c -> count[0]++);\n+        handler.registerInvalidationListener(p, c -> count[0]++);\n+        handler.unregisterChangeListeners(p);\n+        p.set(200);\n+        assertEquals(\"\", 1, count[0]);\n+    }\n+\n+    \/**\n+     * Register both invalidation\/change listener, remove invalidationListener.\n+     *\/\n+    @Test\n+    public void testRegisterBothRemoveInvalidationListener() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        handler.registerChangeListener(p, c -> count[0]++);\n+        handler.registerInvalidationListener(p, c -> count[0]++);\n+        handler.unregisterInvalidationListeners(p);\n+        p.set(200);\n+        assertEquals(\"\", 1, count[0]);\n+    }\n+\n+    \/**\n+     * Test that binding is invalid.\n+     *\/\n+    @Test\n+    public void testBindingInvalid() {\n+        IntegerProperty num1 = new SimpleIntegerProperty(1);\n+        IntegerProperty num2 = new SimpleIntegerProperty(2);\n+        NumberBinding p = Bindings.add(num1,num2);\n+        int[] count = new int[] {0};\n+        handler.registerChangeListener(p, c -> count[0]++);\n+        handler.registerInvalidationListener(p, c -> count[0]++);\n+        handler.unregisterChangeListeners(p);\n+        num1.set(200);\n+        assertEquals(\"sanity: received invalidation\", 1, count[0]);\n+        assertFalse(\"binding must not be valid\", p.isValid());\n+    }\n+\n+\n+\/\/----------------------- helpers to un\/registration listeners\n+\n+    \/**\n+     * Registers the consumer for notification from the observable,\n+     * using the default handler.\n+     *\n+     *\/\n+    protected void registerListener(Observable p, Consumer consumer) {\n+        registerListener(handler, p, consumer);\n+    }\n+\n+    \/**\n+     * Registers the consumer for notification from the observable,\n+     * using the given handler.\n+     *\/\n+    protected void registerListener(LambdaMultiplePropertyChangeListenerHandler handler, Observable p, Consumer consumer) {\n+        if (useChangeListener) {\n+            handler.registerChangeListener((ObservableValue<?>) p, consumer);\n+        } else {\n+            handler.registerInvalidationListener(p, consumer);\n+        }\n+    }\n+\n+    \/**\n+     * Unregisters listeners from observable, using default handler\n+     *\/\n+    protected Consumer unregisterListeners(Observable p) {\n+        return unregisterListeners(handler, p);\n+    }\n+\n+    \/**\n+     * Unregisters listeners from observable, using default handler\n+     *\/\n+    protected Consumer unregisterListeners(LambdaMultiplePropertyChangeListenerHandler handler, Observable p) {\n+        if (useChangeListener) {\n+            return handler.unregisterChangeListeners((ObservableValue<?>) p);\n+        }\n+        return handler.unregisterInvalidationListeners(p);\n+    }\n+\n+    protected void addListener(ObservableValue<?> p, Consumer<Observable> consumer) {\n+        if (useChangeListener) {\n+           p.addListener((obs, ov, nv) -> consumer.accept(obs));\n+        } else {\n+           p.addListener(obs -> consumer.accept(obs));\n+        }\n+    }\n+\n+\n+\/\/-------------- parameters\n+\n+    \/\/ Note: name property not supported before junit 4.11\n+    @Parameterized.Parameters \/\/(name = \"{index}: changeListener {0} \")\n+    public static Collection<Object[]> data() {\n+        Object[][] data = new Object[][] {\n+                {true}, \/\/ test changeListener api\n+                {false} \/\/ test invalidationListener api\n+        };\n+        return Arrays.asList(data);\n+    }\n+\n+    public LambdaMultipleObservableHandlerTest(boolean useChangeListener) {\n+        this.useChangeListener = useChangeListener;\n+    }\n+\n+\n+\/\/------------ setup and initial\n+\n+    @Before\n+    public void setup() {\n+        this.handler = new LambdaMultiplePropertyChangeListenerHandler();\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/LambdaMultipleObservableHandlerTest.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,3 @@\n-import javafx.scene.control.Control;\n-import javafx.scene.control.SkinBaseShim;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertSame;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n@@ -36,0 +35,12 @@\n+import static org.junit.Assert.*;\n+\n+import javafx.beans.Observable;\n+import javafx.beans.property.IntegerProperty;\n+import javafx.beans.property.SimpleIntegerProperty;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener.Change;\n+import javafx.collections.ObservableList;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.SkinBaseShim;\n+\n@@ -60,1 +71,61 @@\n-    public static final class SkinBaseStub<C extends Control> extends SkinBaseShim<C> {\n+\/\/-------------- testing listener registration\n+\/\/ Note: the behavior is fully tested in the handler test, here we only verify that the\n+\/\/ expected methods are actually used\n+\n+    @Test\n+    public void testChangeSupport() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        Consumer<ObservableValue<?>> consumer = c -> count[0]++;\n+        s.addChangeListener(p, consumer);\n+        p.set(200);\n+        assertEquals(\"change listener must be notified\", 1, count[0]);\n+        Consumer<ObservableValue<?>> removed = s.removeChangeListeners(p);\n+        p.set(100);\n+        assertEquals(\"changeListener must not be notified\", 1, count[0]);\n+        assertSame(consumer, removed);\n+    }\n+\n+    @Test\n+    public void testInvalidationSupport() {\n+        IntegerProperty p = new SimpleIntegerProperty();\n+        int[] count = new int[] {0};\n+        Consumer<Observable> consumer = c -> count[0]++;\n+        s.addInvalidationListener(p, consumer);\n+        p.set(200);\n+        assertEquals(\"invalidation listener must be notified\", 1, count[0]);\n+        Consumer<Observable> removed = s.removeInvalidationListeners(p);\n+        p.set(100);\n+        assertEquals(\"invalidation listener must not be notified\", 1, count[0]);\n+        assertSame(consumer, removed);\n+    }\n+\n+    @Test\n+    public void testListChangeSupport() {\n+        ObservableList<String> list = FXCollections.observableArrayList(\"one\");\n+        List<Change<?>> changes = new ArrayList<>();\n+        Consumer<Change<?>> consumer = c -> changes.add(c);\n+        s.addListChangeListener(list, consumer);\n+        list.add(\"added\");\n+        assertEquals(1, changes.size());\n+        Consumer<Change<?>> removed = s.removeListChangeListeners(list);\n+        list.add(\"another\");\n+        assertEquals(1, changes.size());\n+        assertSame(consumer, removed);\n+    }\n+\n+    @Test\n+    public void testRegisterNull() {\n+        s.addChangeListener(null, null);\n+        s.addInvalidationListener(null, null);\n+        s.addListChangeListener(null, null);\n+    }\n+\n+    @Test\n+    public void testUnregistersNull() {\n+        assertNull(s.removeChangeListeners(null));\n+        assertNull(s.removeInvalidationListeners(null));\n+        assertNull(s.removeListChangeListeners(null));\n+    }\n+\n+    public static class SkinBaseStub<C extends Control> extends SkinBaseShim<C> {\n@@ -64,0 +135,27 @@\n+\n+        \/\/ FIXME: un\/registerXXListener are final protected\n+        \/\/ - how to access without adding a wrapper (with potential of introducing bugs)?\n+        void addChangeListener(ObservableValue<?> p, Consumer<ObservableValue<?>> consumer) {\n+            registerChangeListener(p, consumer);\n+        }\n+\n+        Consumer<ObservableValue<?>> removeChangeListeners(ObservableValue<?> p) {\n+            return unregisterChangeListeners(p);\n+        }\n+\n+        void addInvalidationListener(Observable p, Consumer<Observable> consumer) {\n+            registerInvalidationListener(p, consumer);\n+        }\n+\n+        Consumer<Observable> removeInvalidationListeners(Observable p) {\n+            return unregisterInvalidationListeners(p);\n+        }\n+\n+        void addListChangeListener(ObservableList<?> list, Consumer<Change<?>> consumer) {\n+            registerListChangeListener(list, consumer);\n+        }\n+\n+        Consumer<Change<?>> removeListChangeListeners(ObservableList<?> list) {\n+            return unregisterListChangeListeners(list);\n+        }\n+\n@@ -65,0 +163,1 @@\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/SkinBaseTest.java","additions":105,"deletions":6,"binary":false,"changes":111,"status":"modified"}]}