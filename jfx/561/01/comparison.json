{"files":[{"patch":"@@ -302,0 +302,3 @@\n+    \/\/ editing location at start of edit - fix for JDK-8187229\n+    private TablePosition<S, T> editingCellAtStartEdit;\n+\n@@ -336,0 +339,1 @@\n+        editingCellAtStartEdit = new TablePosition<>(table, getIndex(), column);\n@@ -387,1 +391,0 @@\n-            TablePosition<S,?> editingCell = table.getEditingCell();\n@@ -398,1 +401,1 @@\n-                editingCell,\n+                editingCellAtStartEdit,\n@@ -707,3 +710,0 @@\n-\n-\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableCell.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        List<S> items = tableView.getItems();\n+        List<S> items = tableView != null ? tableView.getItems() : null;\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TablePosition.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -303,0 +303,3 @@\n+    \/\/ editing location at start of edit - fix for JDK-8187229\n+    private TreeTablePosition<S, T> editingCellAtStartEdit = null;\n+\n@@ -339,0 +342,1 @@\n+        editingCellAtStartEdit = new TreeTablePosition<>(table, getIndex(), column);\n@@ -393,3 +397,0 @@\n-            @SuppressWarnings(\"unchecked\")\n-            TreeTablePosition<S,T> editingCell = (TreeTablePosition<S,T>) table.getEditingCell();\n-\n@@ -406,1 +407,1 @@\n-                editingCell,\n+                editingCellAtStartEdit,\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableCell.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,2 @@\n-        this.treeItemRef = new WeakReference<>(doLookup ? treeTableView.getTreeItem(row) : null);\n+        this.treeItemRef = new WeakReference<>(doLookup ?\n+                (treeTableView != null ? treeTableView.getTreeItem(row) : null) : null);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTablePosition.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,11 +28,3 @@\n-import javafx.scene.control.TableRow;\n-import javafx.scene.control.TreeTableRow;\n-import javafx.scene.control.skin.TableCellSkin;\n-import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n-import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n-import javafx.collections.FXCollections;\n-import javafx.collections.ObservableList;\n-import javafx.scene.control.TableCell;\n-import javafx.scene.control.TableCellShim;\n-import javafx.scene.control.TableColumn;\n-import javafx.scene.control.TableView;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -44,1 +36,2 @@\n-import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;\n+import com.sun.javafx.tk.Toolkit;\n+\n@@ -46,1 +39,17 @@\n-import static org.junit.Assert.assertEquals;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.*;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n+\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableCellShim;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumn.CellEditEvent;\n+import javafx.scene.control.TablePosition;\n+import javafx.scene.control.TableRow;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.skin.TableCellSkin;\n+import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n@@ -53,0 +62,1 @@\n+    private TableColumn<String, String> editingColumn;\n@@ -55,0 +65,1 @@\n+    private StageLoader stageLoader;\n@@ -68,0 +79,1 @@\n+        editingColumn = new TableColumn<>(\"TEST\");\n@@ -74,0 +86,1 @@\n+        if (stageLoader != null) stageLoader.dispose();\n@@ -405,0 +418,114 @@\n+    \/**\n+     * Basic config of table-\/cell to allow testing of editEvents:\n+     * table is editable, has editingColumn and cell is configured with table and column.\n+     *\/\n+    private void setupForEditing() {\n+        table.setEditable(true);\n+        table.getColumns().add(editingColumn);\n+        \/\/ FIXME: default cell (of tableColumn) needs not-null value for firing cancel\n+        editingColumn.setCellValueFactory(cc -> new SimpleObjectProperty<>(\"\"));\n+\n+        cell.updateTableView(table);\n+        cell.updateTableColumn(editingColumn);\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterCancelOnCell() {\n+        setupForEditing();\n+        int editingIndex = 1;\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        TablePosition<?, ?> editingPosition = table.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        cell.cancelEdit();\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTablePosition());\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterCancelOnTable() {\n+        setupForEditing();\n+        int editingIndex = 1;\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        TablePosition<?, ?> editingPosition = table.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        table.edit(-1, null);\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTablePosition());\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterCellReuse() {\n+        setupForEditing();\n+        int editingIndex = 1;\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        TablePosition<?, ?> editingPosition = table.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        cell.updateIndex(0);\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTablePosition());\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterModifyItems() {\n+        setupForEditing();\n+        stageLoader = new StageLoader(table);\n+        int editingIndex = 1;\n+        table.edit(editingIndex, editingColumn);\n+        TablePosition<?, ?> editingPosition = table.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        table.getItems().add(0, \"added\");\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTablePosition());\n+    }\n+\n+    \/**\n+     * Test that removing the editing item implicitly cancels an ongoing\n+     * edit and fires a correct cancel event.\n+     *\/\n+    @Test\n+    public void testEditCancelEventAfterRemoveEditingItem() {\n+        setupForEditing();\n+        stageLoader = new StageLoader(table);\n+        int editingIndex = 1;\n+        table.edit(editingIndex, editingColumn);\n+        TablePosition<?, ?> editingPosition = table.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        table.getItems().remove(editingIndex);\n+        Toolkit.getToolkit().firePulse();\n+        assertNull(\"sanity: editing terminated on items modification\", table.getEditingCell());\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTablePosition());\n+    }\n+\n+    \/**\n+     * Test that removing the editing item does not cause a memory leak.\n+     *\/\n+    @Test\n+    public void testEditCancelMemoryLeakAfterRemoveEditingItem() {\n+        TableView<MenuItem> table = new TableView<>(FXCollections.observableArrayList(\n+                new MenuItem(\"some\"), new MenuItem(\"other\")));\n+        TableColumn<MenuItem, String> editingColumn = new TableColumn<>(\"Text\");\n+        editingColumn.setCellValueFactory(cc -> new SimpleObjectProperty<>(\"\"));\n+        table.setEditable(true);\n+        table.getColumns().add(editingColumn);\n+        stageLoader = new StageLoader(table);\n+        int editingIndex = 1;\n+        MenuItem editingItem = table.getItems().get(editingIndex);\n+        WeakReference<MenuItem> itemRef = new WeakReference<>(editingItem);\n+        table.edit(editingIndex, editingColumn);\n+        table.getItems().remove(editingIndex);\n+        editingItem = null;\n+        Toolkit.getToolkit().firePulse();\n+        attemptGC(itemRef);\n+        assertEquals(\"item must be gc'ed\", null, itemRef.get());\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableCellTest.java","additions":140,"deletions":13,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import org.junit.Test;\n+\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TablePosition;\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTablePosition;\n+\n+\/**\n+ * Test Tree\/TablePosition.\n+ *\/\n+public class TablePositionBaseTest {\n+\n+\/\/---------- TableView\n+\n+    \/**\n+     * JDK-8269136: must not throw on null Table.\n+     *\/\n+    @Test\n+    public void testNullTable() {\n+        new TablePosition<>(null, 2, new TableColumn<>());\n+    }\n+\n+\/\/------------- TreeTableView\n+\n+    \/**\n+     * JDK-8269136: must not throw on null TreeTable.\n+     *\/\n+    @Test\n+    public void testNullTreeTable() {\n+        new TreeTablePosition<>(null, 2, new TreeTableColumn<>());\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TablePositionBaseTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -35,0 +36,2 @@\n+import javafx.scene.control.TreeTableColumn.CellEditEvent;\n+import javafx.scene.control.TreeTablePosition;\n@@ -37,1 +40,4 @@\n-import javafx.util.Callback;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -44,0 +50,3 @@\n+import com.sun.javafx.tk.Toolkit;\n+\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n@@ -61,0 +70,3 @@\n+    private StageLoader stageLoader;\n+\n+    private TreeTableColumn<String, String> editingColumn;\n@@ -81,0 +93,1 @@\n+        editingColumn = new TreeTableColumn<>(\"TEST\");\n@@ -87,0 +100,1 @@\n+        if (stageLoader != null) stageLoader.dispose();\n@@ -711,0 +725,129 @@\n+    \/**\n+     * Basic config of treeTable-\/cell to allow testing of editEvents:\n+     * table is editable, has editingColumn and cell is configured with table and column.\n+     *\/\n+    private void setupForEditing() {\n+        tree.setEditable(true);\n+        tree.getColumns().add(editingColumn);\n+        \/\/ FIXME: default cell (of tableColumn) needs not-null value for firing cancel\n+        editingColumn.setCellValueFactory(cc -> new SimpleObjectProperty<>(\"\"));\n+\n+        cell.updateTreeTableView(tree);\n+        cell.updateTreeTableColumn(editingColumn);\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterCancelOnCell() {\n+        setupForEditing();\n+        int editingIndex = 1;\n+        cell.updateIndex(editingIndex);\n+        tree.edit(editingIndex, editingColumn);\n+        TreeTablePosition<?,?> editingPosition = tree.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        cell.cancelEdit();\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTreeTablePosition());\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterCancelOnTreeTable() {\n+        setupForEditing();\n+        int editingIndex = 1;\n+        cell.updateIndex(editingIndex);\n+        tree.edit(editingIndex, editingColumn);\n+        TreeTablePosition<?, ?> editingPosition = tree.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        tree.edit(-1, null);\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTreeTablePosition());\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterCellReuse() {\n+        setupForEditing();\n+        int editingIndex = 1;\n+        cell.updateIndex(editingIndex);\n+        tree.edit(editingIndex, editingColumn);\n+        TreeTablePosition<?, ?> editingPosition = tree.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        cell.updateIndex(0);\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTreeTablePosition());\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterCollapse() {\n+        setupForEditing();\n+        stageLoader = new StageLoader(tree);\n+        int editingIndex = 1;\n+        tree.edit(editingIndex, editingColumn);\n+        TreeTablePosition<?, ?> editingPosition = tree.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        root.setExpanded(false);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTreeTablePosition());\n+    }\n+\n+    @Test\n+    public void testEditCancelEventAfterModifyItems() {\n+        setupForEditing();\n+        stageLoader = new StageLoader(tree);\n+        int editingIndex = 2;\n+        tree.edit(editingIndex, editingColumn);\n+        TreeTablePosition<?, ?> editingPosition = tree.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        root.getChildren().add(0, new TreeItem<>(\"added\"));\n+        Toolkit.getToolkit().firePulse();\n+        assertNull(\"sanity: editing terminated on items modification\", tree.getEditingCell());\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTreeTablePosition());\n+    }\n+\n+    \/**\n+     * Test that removing the editing item implicitly cancels an ongoing\n+     * edit and fires a correct cancel event.\n+     *\/\n+    @Test\n+    public void testEditCancelEventAfterRemoveEditingItem() {\n+        setupForEditing();\n+        stageLoader = new StageLoader(tree);\n+        int editingIndex = 1;\n+        tree.edit(editingIndex, editingColumn);\n+        TreeTablePosition<?, ?> editingPosition = tree.getEditingCell();\n+        List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(events::add);\n+        root.getChildren().remove(editingIndex - 1);\n+        Toolkit.getToolkit().firePulse();\n+        assertNull(\"sanity: editing terminated on items modification\", tree.getEditingCell());\n+        assertEquals(\"column must have received editCancel\", 1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingPosition, events.get(0).getTreeTablePosition());\n+    }\n+\n+    \/**\n+     * Test that removing the editing item does not cause a memory leak.\n+     *\/\n+    @Test\n+    public void testEditCancelMemoryLeakAfterRemoveEditingItem() {\n+        setupForEditing();\n+        stageLoader = new StageLoader(tree);\n+        \/\/ the item to test for being gc'ed\n+        TreeItem<String> editingItem = new TreeItem<>(\"added\");\n+        WeakReference<TreeItem<?>> itemRef = new WeakReference<>(editingItem);\n+        root.getChildren().add(0, editingItem);\n+        Toolkit.getToolkit().firePulse();\n+        int editingIndex = tree.getRow(editingItem);\n+        tree.edit(editingIndex, editingColumn);\n+        root.getChildren().remove(editingItem);\n+        Toolkit.getToolkit().firePulse();\n+        editingItem = null;\n+        attemptGC(itemRef);\n+        assertEquals(\"treeItem must be gc'ed\", null, itemRef.get());\n+    }\n+\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableCellTest.java","additions":144,"deletions":1,"binary":false,"changes":145,"status":"modified"}]}