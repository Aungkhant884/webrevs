{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,2 +274,1 @@\n-        MultipleSelectionModel<?> sm = getSelectionModel();\n-        boolean isAlreadySelected = sm.isSelected(index);\n+        boolean isAlreadySelected;\n@@ -277,3 +276,2 @@\n-        if (isAlreadySelected && shortcutDown) {\n-            sm.clearSelection(index);\n-            getFocusModel().focus(index);\n+        MultipleSelectionModel<?> sm = getSelectionModel();\n+        if (sm == null) {\n@@ -282,1 +280,9 @@\n-            sm.clearAndSelect(index);\n+            isAlreadySelected = sm.isSelected(index);\n+\n+            if (isAlreadySelected && shortcutDown) {\n+                sm.clearSelection(index);\n+                getFocusModel().focus(index);\n+                isAlreadySelected = false;\n+            } else {\n+                sm.clearAndSelect(index);\n+            }\n@@ -303,0 +309,4 @@\n+        if (getSelectionModel() == null) {\n+            return;\n+        }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/CellBehaviorBase.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,3 +203,1 @@\n-        final int row = getNode().getIndex();\n-        final TableColumnBase<S,T> column = getTableColumn();\n-        boolean isAlreadySelected = sm.isSelected(row, column);\n+        boolean isAlreadySelected;\n@@ -207,3 +205,1 @@\n-        if (isAlreadySelected && shortcutDown) {\n-            sm.clearSelection(row, column);\n-            getFocusModel().focus(row, (TC) column);\n+        if (sm == null) {\n@@ -212,2 +208,12 @@\n-            \/\/ we check if cell selection is enabled to fix RT-33897\n-            sm.clearAndSelect(row, column);\n+            final int row = getNode().getIndex();\n+            final TableColumnBase<S,T> column = getTableColumn();\n+            isAlreadySelected = sm.isSelected(row, column);\n+\n+            if (isAlreadySelected && shortcutDown) {\n+                sm.clearSelection(row, column);\n+                getFocusModel().focus(row, (TC) column);\n+                isAlreadySelected = false;\n+            } else {\n+                \/\/ we check if cell selection is enabled to fix RT-33897\n+                sm.clearAndSelect(row, column);\n+            }\n@@ -220,0 +226,1 @@\n+        \/\/ this method will not be called if selection model is null\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TableCellBehaviorBase.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import javafx.collections.FXCollections;\n@@ -117,1 +118,6 @@\n-        return getNode().getSelectionModel().getSelectedCells();\n+        TableViewSelectionModel<T> sm = getNode().getSelectionModel();\n+        if (sm == null) {\n+            return FXCollections.emptyObservableList();\n+        } else {\n+            return sm.getSelectedCells();\n+        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TableViewBehavior.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javafx.collections.FXCollections;\n@@ -41,0 +42,1 @@\n+import javafx.scene.control.TreeTableView.TreeTableViewSelectionModel;\n@@ -124,1 +126,6 @@\n-        return getNode().getSelectionModel().getSelectedCells();\n+        TreeTableViewSelectionModel<T> sm = getNode().getSelectionModel();\n+        if (sm == null) {\n+            return FXCollections.observableArrayList();\n+        } else {\n+            return sm.getSelectedCells();\n+        }\n@@ -190,1 +197,2 @@\n-        if (getNode().getSelectionModel().isCellSelectionEnabled()) {\n+        TreeTableViewSelectionModel<T> sm = getNode().getSelectionModel();\n+        if ((sm != null) && sm.isCellSelectionEnabled()) {\n@@ -202,1 +210,2 @@\n-        if (getNode().getSelectionModel().isCellSelectionEnabled()) {\n+        TreeTableViewSelectionModel<T> sm = getNode().getSelectionModel();\n+        if ((sm != null) && sm.isCellSelectionEnabled()) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TreeTableViewBehavior.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -998,0 +998,1 @@\n+                oldValue.clearSelection();\n@@ -1570,2 +1571,4 @@\n-        final List<TablePosition> prevState = new ArrayList<>(getSelectionModel().getSelectedCells());\n-        final int itemCount = prevState.size();\n+        TableViewSelectionModel<S> selectionModel = getSelectionModel();\n+        final List<TablePosition> prevState = selectionModel == null ?\n+                null :\n+                new ArrayList<>(selectionModel.getSelectedCells());\n@@ -1576,1 +1579,3 @@\n-        getSelectionModel().startAtomic();\n+        if (selectionModel != null) {\n+            selectionModel.startAtomic();\n+        }\n@@ -1583,1 +1588,3 @@\n-        getSelectionModel().stopAtomic();\n+        if (selectionModel != null) {\n+            selectionModel.stopAtomic();\n+        }\n@@ -1596,2 +1603,2 @@\n-            if (getSelectionModel() instanceof TableViewArrayListSelectionModel) {\n-                final TableViewArrayListSelectionModel<S> sm = (TableViewArrayListSelectionModel<S>) getSelectionModel();\n+            if (selectionModel instanceof TableViewArrayListSelectionModel) {\n+                final TableViewArrayListSelectionModel<S> sm = (TableViewArrayListSelectionModel<S>)selectionModel;\n@@ -1601,4 +1608,5 @@\n-                for (int i = 0; i < itemCount; i++) {\n-                    TablePosition<S, ?> prevItem = prevState.get(i);\n-                    if (!newState.contains(prevItem)) {\n-                        removed.add(prevItem);\n+                if(prevState != null) {\n+                    for (TablePosition<S, ?> prevItem: prevState) {\n+                        if (!newState.contains(prevItem)) {\n+                            removed.add(prevItem);\n+                        }\n@@ -1614,0 +1622,1 @@\n+                    int itemCount = prevState == null ? 0 : prevState.size();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableView.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -442,1 +442,0 @@\n-        if (getTreeTableView().getSelectionModel() == null) return;\n@@ -444,2 +443,7 @@\n-        boolean isSelected = getTreeTableView().getSelectionModel().isSelected(index);\n-        if (isSelected() == isSelected) return;\n+        TreeTableViewSelectionModel<T> sm = getTreeTableView().getSelectionModel();\n+        if (sm == null) {\n+            if (isSelected()) {\n+                updateSelected(false);\n+            }\n+            return;\n+        }\n@@ -447,1 +451,4 @@\n-        updateSelected(isSelected);\n+        boolean isSelected = !sm.isCellSelectionEnabled() && sm.isSelected(index);\n+        if (isSelected() != isSelected) {\n+            updateSelected(isSelected);\n+        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableRow.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1072,0 +1072,1 @@\n+                        oldValue.clearSelection();\n@@ -1081,1 +1082,6 @@\n-                    if (oldValue != null) {\n+                    if (oldValue == null) {\n+                        \/\/ show no focused rows with a null selection model\n+                        if (getFocusModel() != null) {\n+                            getFocusModel().setFocusedIndex(-1);\n+                        }\n+                    } else {\n@@ -1851,2 +1857,4 @@\n-        final List<TreeTablePosition<S,?>> prevState = new ArrayList<>(getSelectionModel().getSelectedCells());\n-        final int itemCount = prevState.size();\n+        TreeTableViewSelectionModel<S> selectionModel = getSelectionModel();\n+        final List<TreeTablePosition<S,?>> prevState = (selectionModel == null) ?\n+                null :\n+                new ArrayList<>(selectionModel.getSelectedCells());\n@@ -1857,1 +1865,3 @@\n-        getSelectionModel().startAtomic();\n+        if (selectionModel != null) {\n+            selectionModel.startAtomic();\n+        }\n@@ -1867,11 +1877,13 @@\n-        if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {\n-            Set<TreeItem<S>> sortedParents = new HashSet<>();\n-            for (TreeTablePosition<S,?> selectedPosition : prevState) {\n-                \/\/ This null check is not required ideally.\n-                \/\/ The selectedPosition.getTreeItem() should always return a valid TreeItem.\n-                \/\/ But, it is possible to be null due to JDK-8248217.\n-                if (selectedPosition.getTreeItem() != null) {\n-                    TreeItem<S> parent = selectedPosition.getTreeItem().getParent();\n-                    while (parent != null && sortedParents.add(parent)) {\n-                        parent.getChildren();\n-                        parent = parent.getParent();\n+        if (prevState != null) {\n+            if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {\n+                Set<TreeItem<S>> sortedParents = new HashSet<>();\n+                for (TreeTablePosition<S,?> selectedPosition : prevState) {\n+                    \/\/ This null check is not required ideally.\n+                    \/\/ The selectedPosition.getTreeItem() should always return a valid TreeItem.\n+                    \/\/ But, it is possible to be null due to JDK-8248217.\n+                    if (selectedPosition.getTreeItem() != null) {\n+                        TreeItem<S> parent = selectedPosition.getTreeItem().getParent();\n+                        while (parent != null && sortedParents.add(parent)) {\n+                            parent.getChildren();\n+                            parent = parent.getParent();\n+                        }\n@@ -1882,1 +1894,4 @@\n-        getSelectionModel().stopAtomic();\n+\n+        if (selectionModel != null) {\n+            selectionModel.stopAtomic();\n+        }\n@@ -1895,2 +1910,2 @@\n-            if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {\n-                final TreeTableViewArrayListSelectionModel<S> sm = (TreeTableViewArrayListSelectionModel<S>) getSelectionModel();\n+            if (selectionModel instanceof TreeTableViewArrayListSelectionModel) {\n+                final TreeTableViewArrayListSelectionModel<S> sm = (TreeTableViewArrayListSelectionModel<S>)selectionModel;\n@@ -1900,4 +1915,5 @@\n-                for (int i = 0; i < itemCount; i++) {\n-                    TreeTablePosition<S, ?> prevItem = prevState.get(i);\n-                    if (!newState.contains(prevItem)) {\n-                        removed.add(prevItem);\n+                if (prevState != null) {\n+                    for (TreeTablePosition<S, ?> prevItem: prevState) {\n+                        if (!newState.contains(prevItem)) {\n+                            removed.add(prevItem);\n+                        }\n@@ -1906,0 +1922,1 @@\n+\n@@ -1912,0 +1929,1 @@\n+                    int itemCount = prevState == null ? 0 : prevState.size();\n@@ -1916,2 +1934,6 @@\n-            getSelectionModel().setSelectedIndex(getRow(getSelectionModel().getSelectedItem()));\n-            getFocusModel().focus(getSelectionModel().getSelectedIndex());\n+\n+            if (selectionModel != null) {\n+                selectionModel.setSelectedIndex(getRow(selectionModel.getSelectedItem()));\n+            }\n+\n+            getFocusModel().focus(selectionModel == null ? -1 : selectionModel.getSelectedIndex());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableView.java","additions":46,"deletions":24,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,10 +150,14 @@\n-                \/\/ FIXME this could be optimised to iterate over cellsMap only\n-                \/\/ (selectedCells could be big, cellsMap is much smaller)\n-                List<Node> selection = new ArrayList<>();\n-                int index = getSkinnable().getIndex();\n-                for (TablePosition<T,?> pos : getTableView().getSelectionModel().getSelectedCells()) {\n-                    if (pos.getRow() == index) {\n-                        TableColumn<T,?> column = pos.getTableColumn();\n-                        if (column == null) {\n-                            \/* This is the row-based case *\/\n-                            column = getTableView().getVisibleLeafColumn(0);\n+                if (getTableView().getSelectionModel() != null) {\n+                    \/\/ FIXME this could be optimised to iterate over cellsMap only\n+                    \/\/ (selectedCells could be big, cellsMap is much smaller)\n+                    List<Node> selection = new ArrayList<>();\n+                    int index = getSkinnable().getIndex();\n+                    for (TablePosition<T,?> pos : getTableView().getSelectionModel().getSelectedCells()) {\n+                        if (pos.getRow() == index) {\n+                            TableColumn<T,?> column = pos.getTableColumn();\n+                            if (column == null) {\n+                                \/* This is the row-based case *\/\n+                                column = getTableView().getVisibleLeafColumn(0);\n+                            }\n+                            TableCell<T,?> cell = cellsMap.get(column).get();\n+                            if (cell != null) selection.add(cell);\n@@ -161,2 +165,1 @@\n-                        TableCell<T,?> cell = cellsMap.get(column).get();\n-                        if (cell != null) selection.add(cell);\n+                        return FXCollections.observableArrayList(selection);\n@@ -164,1 +167,0 @@\n-                    return FXCollections.observableArrayList(selection);\n@@ -167,0 +169,1 @@\n+            \/\/ fall through\n@@ -175,0 +178,1 @@\n+            \/\/ fall through\n@@ -188,0 +192,1 @@\n+            \/\/ fall through\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkin.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,3 +155,5 @@\n-                for (TablePosition<T,?> pos : sm.getSelectedCells()) {\n-                    TableRow<T> row = flow.getPrivateCell(pos.getRow());\n-                    if (row != null) selection.add(row);\n+                if (sm != null) {\n+                    for (TablePosition<T,?> pos : sm.getSelectedCells()) {\n+                        TableRow<T> row = flow.getPrivateCell(pos.getRow());\n+                        if (row != null) selection.add(row);\n+                    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableViewSkin.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -808,0 +808,4 @@\n+        if (sm == null) {\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableViewSkinBase.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -458,10 +458,14 @@\n-                \/\/ FIXME this could be optimised to iterate over cellsMap only\n-                \/\/ (selectedCells could be big, cellsMap is much smaller)\n-                List<Node> selection = new ArrayList<>();\n-                int index = getSkinnable().getIndex();\n-                for (TreeTablePosition<T,?> pos : treeTableView.getSelectionModel().getSelectedCells()) {\n-                    if (pos.getRow() == index) {\n-                        TreeTableColumn<T,?> column = pos.getTableColumn();\n-                        if (column == null) {\n-                            \/* This is the row-based case *\/\n-                            column = treeTableView.getVisibleLeafColumn(0);\n+                if (treeTableView.getSelectionModel() != null) {\n+                    \/\/ FIXME this could be optimised to iterate over cellsMap only\n+                    \/\/ (selectedCells could be big, cellsMap is much smaller)\n+                    List<Node> selection = new ArrayList<>();\n+                    int index = getSkinnable().getIndex();\n+                    for (TreeTablePosition<T,?> pos : treeTableView.getSelectionModel().getSelectedCells()) {\n+                        if (pos.getRow() == index) {\n+                            TreeTableColumn<T,?> column = pos.getTableColumn();\n+                            if (column == null) {\n+                                \/* This is the row-based case *\/\n+                                column = treeTableView.getVisibleLeafColumn(0);\n+                            }\n+                            TreeTableCell<T,?> cell = cellsMap.get(column).get();\n+                            if (cell != null) selection.add(cell);\n@@ -469,2 +473,1 @@\n-                        TreeTableCell<T,?> cell = cellsMap.get(column).get();\n-                        if (cell != null) selection.add(cell);\n+                        return FXCollections.observableArrayList(selection);\n@@ -472,1 +475,0 @@\n-                    return FXCollections.observableArrayList(selection);\n@@ -475,0 +477,1 @@\n+            \/\/ fall through\n@@ -483,0 +486,1 @@\n+            \/\/ fall through\n@@ -496,0 +500,1 @@\n+            \/\/ fall through\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableRowSkin.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,3 +221,5 @@\n-                for (TreeTablePosition<T,?> pos : sm.getSelectedCells()) {\n-                    TreeTableRow<T> row = flow.getPrivateCell(pos.getRow());\n-                    if (row != null) selection.add(row);\n+                if (sm != null) {\n+                    for (TreeTablePosition<T,?> pos : sm.getSelectedCells()) {\n+                        TreeTableRow<T> row = flow.getPrivateCell(pos.getRow());\n+                        if (row != null) selection.add(row);\n+                    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableViewSkin.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}