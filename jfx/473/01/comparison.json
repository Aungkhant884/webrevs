{"files":[{"patch":"@@ -552,1 +552,7 @@\n-        if (getIndex() == -1 || getTableView() == null) return;\n+        if (getIndex() == -1 || getTableView() == null) {\n+            \/\/ JDK-8265206: must cancel edit if index changed to -1 by re-use\n+            if (isEditing()) {\n+                doCancelEdit();\n+            }\n+            return;\n+        }\n@@ -560,6 +566,17 @@\n-            \/\/ If my index is not the one being edited then I need to cancel\n-            \/\/ the edit. The tricky thing here is that as part of this call\n-            \/\/ I cannot end up calling list.edit(-1) the way that the standard\n-            \/\/ cancelEdit method would do. Yet, I need to call cancelEdit\n-            \/\/ so that subclasses which override cancelEdit can execute. So,\n-            \/\/ I have to use a kind of hacky flag workaround.\n+            doCancelEdit();\n+        }\n+    }\n+\n+    \/**\n+     * Switches an editing cell into not editing without changing control's\n+     * editing state.\n+     *\/\n+    private void doCancelEdit() {\n+        \/\/ If my index is not the one being edited then I need to cancel\n+        \/\/ the edit. The tricky thing here is that as part of this call\n+        \/\/ I cannot end up calling list.edit(-1) the way that the standard\n+        \/\/ cancelEdit method would do. Yet, I need to call cancelEdit\n+        \/\/ so that subclasses which override cancelEdit can execute. So,\n+        \/\/ I have to use a kind of hacky flag workaround.\n+        try {\n+            \/\/ try-finally to make certain that the flag is reliably reset to true\n@@ -568,0 +585,1 @@\n+        } finally {\n@@ -571,0 +589,1 @@\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableCell.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -538,1 +538,7 @@\n-        if (getIndex() == -1 || tv == null) return;\n+        if (getIndex() == -1 || tv == null) {\n+            \/\/ JDK-8265206: must cancel edit if index changed to -1 by re-use\n+            if (isEditing()) {\n+                doCancelEdit();\n+            }\n+            return;\n+        }\n@@ -546,6 +552,17 @@\n-            \/\/ If my index is not the one being edited then I need to cancel\n-            \/\/ the edit. The tricky thing here is that as part of this call\n-            \/\/ I cannot end up calling list.edit(-1) the way that the standard\n-            \/\/ cancelEdit method would do. Yet, I need to call cancelEdit\n-            \/\/ so that subclasses which override cancelEdit can execute. So,\n-            \/\/ I have to use a kind of hacky flag workaround.\n+            doCancelEdit();\n+        }\n+    }\n+\n+    \/**\n+     * Switches an editing cell into not editing without changing control's\n+     * editing state.\n+     *\/\n+    private void doCancelEdit() {\n+        \/\/ If my index is not the one being edited then I need to cancel\n+        \/\/ the edit. The tricky thing here is that as part of this call\n+        \/\/ I cannot end up calling list.edit(-1) the way that the standard\n+        \/\/ cancelEdit method would do. Yet, I need to call cancelEdit\n+        \/\/ so that subclasses which override cancelEdit can execute. So,\n+        \/\/ I have to use a kind of hacky flag workaround.\n+        try {\n+            \/\/ try-finally to make certain that the flag is reliably reset to true\n@@ -554,0 +571,1 @@\n+        } finally {\n@@ -557,0 +575,1 @@\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableCell.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.junit.Assert.*;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumn.CellEditEvent;\n+import javafx.scene.control.TableView;\n+\n+\/**\n+ * Test TableCell editing state updated on re-use (aka after updateIndex(old, new)).\n+ *\n+ * This test is parameterized in cellIndex and editingIndex.\n+ *\/\n+@RunWith(Parameterized.class)\n+public class TableCellEditingTest {\n+    private TableCell<String,String> cell;\n+    private TableView<String> table;\n+    private TableColumn<String, String> editingColumn;\n+    private ObservableList<String> model;\n+\n+    private int cellIndex;\n+    private int editingIndex;\n+\n+\/\/--------------- change off editing index\n+\n+    @Test\n+    public void testOffEditingIndex() {\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        cell.updateIndex(cellIndex);\n+        assertEquals(\"sanity: cell index changed\", cellIndex, cell.getIndex());\n+        assertEquals(\"sanity: table editingIndex must be unchanged\", editingIndex, table.getEditingCell().getRow());\n+        assertEquals(\"sanity: table editingColumn must be unchanged\", editingColumn, table.getEditingCell().getTableColumn());\n+        assertFalse(\"cell must not be editing on update from editingIndex\" + editingIndex\n+                + \" to cellIndex \" + cellIndex, cell.isEditing());\n+    }\n+\n+    @Test\n+    public void testCancelOffEditingIndex() {\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        List<CellEditEvent<String, String>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(e -> {\n+            events.add(e);\n+        });\n+        cell.updateIndex(cellIndex);\n+        assertEquals(\"cell must have fired edit cancel\", 1, events.size());\n+        assertEquals(\"cancel event index must be same as editingIndex\", editingIndex,\n+                events.get(0).getTablePosition().getRow());\n+    }\n+\n+\/\/--------------- change to editing index\n+\n+    @Test\n+    public void testToEditingIndex() {\n+        cell.updateIndex(cellIndex);\n+        table.edit(editingIndex, editingColumn);\n+        cell.updateIndex(editingIndex);\n+        assertEquals(\"sanity: cell at editing index\", editingIndex, cell.getIndex());\n+        assertEquals(\"sanity: table editingIndex must be unchanged\", editingIndex, table.getEditingCell().getRow());\n+        assertEquals(\"sanity: table editingColumn must be unchanged\", editingColumn, table.getEditingCell().getTableColumn());\n+        assertTrue(\"cell must be editing on update from \" + cellIndex\n+                + \" to editingIndex \" + editingIndex, cell.isEditing());\n+    }\n+\n+    @Test\n+    public void testStartEvent() {\n+        cell.updateIndex(cellIndex);\n+        table.edit(editingIndex, editingColumn);\n+        List<CellEditEvent<String, String>> events = new ArrayList<>();\n+        editingColumn.setOnEditStart(e -> {\n+            events.add(e);\n+        });\n+        cell.updateIndex(editingIndex);\n+        assertEquals(\"cell must have fired edit start on update from \" + cellIndex + \" to \" + editingIndex,\n+                1, events.size());\n+        assertEquals(\"start event index must be same as editingIndex\", editingIndex,\n+                events.get(0).getTablePosition().getRow());\n+    }\n+\n+\/\/------------- parameterized\n+\n+    \/\/ Note: name property not supported before junit 4.11\n+    @Parameterized.Parameters \/\/ (name = \"{index}: cellIndex {0}, editingIndex {1}\")\n+    public static Collection<Object[]> data() {\n+     \/\/ [0] is cellIndex, [1] is editingIndex\n+        Object[][] data = new Object[][] {\n+            {1, 2}, \/\/ normal\n+            {0, 1}, \/\/ zero cell index\n+            {1, 0}, \/\/ zero editing index\n+            {-1, 1}, \/\/ negative cell - JDK-8265206\n+        };\n+        return Arrays.asList(data);\n+    }\n+\n+    public TableCellEditingTest(int cellIndex, int editingIndex) {\n+        this.cellIndex = cellIndex;\n+        this.editingIndex = editingIndex;\n+    }\n+\n+\/\/-------------- setup and sanity\n+\n+    \/**\n+     * Sanity: cell editing state updated when on editing index.\n+     *\/\n+    @Test\n+    public void testEditOnCellIndex() {\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        assertTrue(\"sanity: cell must be editing\", cell.isEditing());\n+    }\n+\n+    \/**\n+     * Sanity: cell editing state unchanged when off editing index.\n+     *\/\n+    @Test\n+    public void testEditOffCellIndex() {\n+        cell.updateIndex(cellIndex);\n+        table.edit(editingIndex, editingColumn);\n+        assertFalse(\"sanity: cell editing must be unchanged\", cell.isEditing());\n+    }\n+\n+    @Before\n+    public void setup() {\n+        cell = new TableCell<String,String>();\n+        model = FXCollections.observableArrayList(\"Four\", \"Five\", \"Fear\"); \/\/ \"Flop\", \"Food\", \"Fizz\"\n+        table = new TableView<String>(model);\n+        table.setEditable(true);\n+        editingColumn = new TableColumn<>(\"TEST\");\n+        editingColumn.setCellValueFactory(param -> null);\n+        table.getColumns().add(editingColumn);\n+        cell.updateTableView(table);\n+        cell.updateTableColumn(editingColumn);\n+        \/\/ make sure that focus change doesn't interfere with tests\n+        \/\/ (editing cell loosing focus will be canceled from focusListener in Cell)\n+        \/\/ Note: not really needed for Tree\/TableCell because the cell is never focused\n+        \/\/ if !cellSelectionEnabled nor if not in Tree\/TableRow\n+        \/\/ done here for consistency across analogous tests for List\/Tree\/Cell\n+        table.getFocusModel().focus(-1);\n+        assertFalse(\"sanity: cellIndex not same as editingIndex\", cellIndex == editingIndex);\n+        assertTrue(\"sanity: valid editingIndex\", editingIndex < model.size());\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableCellEditingTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import org.junit.After;\n@@ -53,0 +54,8 @@\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+\n@@ -58,0 +67,6 @@\n+    @After\n+    public void cleanup() {\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+\n@@ -309,0 +324,56 @@\n+\n+    \/**\n+     * Test that cell.cancelEdit can switch table editing off\n+     * even if a subclass violates its contract.\n+     *\n+     * For details, see https:\/\/bugs.openjdk.java.net\/browse\/JDK-8265206\n+     *\n+     *\/\n+    @Test\n+    public void testMisbehavingCancelEditTerminatesEdit() {\n+        \/\/ setup for editing\n+        TableCell<String, String> cell = new MisbehavingOnCancelTableCell<>();\n+        table.setEditable(true);\n+        TableColumn<String, String> editingColumn = new TableColumn<>(\"TEST\");\n+        editingColumn.setCellValueFactory(param -> null);\n+        table.getColumns().add(editingColumn);\n+        cell.updateTableView(table);\n+        cell.updateTableColumn(editingColumn);\n+        \/\/ test editing: first round\n+        \/\/ switch cell off editing by table api\n+        int editingIndex = 1;\n+        int intermediate = 0;\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        assertTrue(\"sanity: \", cell.isEditing());\n+        try {\n+            table.edit(intermediate, editingColumn);\n+        } catch (Exception ex) {\n+            \/\/ just catching to test in finally\n+        } finally {\n+            assertFalse(\"cell must not be editing\", cell.isEditing());\n+            assertEquals(\"table must be editing at intermediate index\", intermediate, table.getEditingCell().getRow());\n+        }\n+        \/\/ test editing: second round\n+        \/\/ switch cell off editing by cell api\n+        table.edit(editingIndex, editingColumn);\n+        assertTrue(\"sanity: \", cell.isEditing());\n+        try {\n+            cell.cancelEdit();\n+        } catch (Exception ex) {\n+            \/\/ just catching to test in finally\n+        } finally {\n+            assertFalse(\"cell must not be editing\", cell.isEditing());\n+            assertNull(\"table editing must be cancelled by cell\", table.getEditingCell());\n+        }\n+    }\n+\n+    public static class MisbehavingOnCancelTableCell<S, T> extends TableCell<S, T> {\n+\n+        @Override\n+        public void cancelEdit() {\n+            super.cancelEdit();\n+            throw new RuntimeException(\"violating contract\");\n+        }\n+\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableCellTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.junit.Assert.*;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableCell;\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTableColumn.CellEditEvent;\n+import javafx.scene.control.TreeTableView;\n+\n+\/**\n+ * Test TreeTableCell editing state updated on re-use (aka after updateIndex(old, new)).\n+ *\n+ * This test is parameterized in cellIndex and editingIndex.\n+ *\n+ *\/\n+@RunWith(Parameterized.class)\n+public class TreeTableCellEditingTest {\n+    private TreeTableCell<String,String> cell;\n+    private TreeTableView<String> table;\n+    private TreeTableColumn<String, String> editingColumn;\n+    private ObservableList<TreeItem<String>> model;\n+\n+    private int cellIndex;\n+    private int editingIndex;\n+\n+\/\/--------------- change off editing index\n+\n+    @Test\n+    public void testOffEditingIndex() {\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        cell.updateIndex(cellIndex);\n+        assertEquals(\"sanity: cell index changed\", cellIndex, cell.getIndex());\n+        assertEquals(\"sanity: treeTable editingIndex must be unchanged\", editingIndex, table.getEditingCell().getRow());\n+        assertEquals(\"sanity: treeTable editingColumn must be unchanged\", editingColumn, table.getEditingCell().getTableColumn());\n+        assertFalse(\"cell must not be editing on update from editingIndex\" + editingIndex\n+                + \" to cellIndex \" + cellIndex, cell.isEditing());\n+    }\n+\n+    @Test\n+    public void testCancelOffEditingIndex() {\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        List<CellEditEvent<String, String>> events = new ArrayList<>();\n+        editingColumn.setOnEditCancel(e -> {\n+            events.add(e);\n+        });\n+        cell.updateIndex(cellIndex);\n+        assertEquals(\"cell must have fired edit cancel\", 1, events.size());\n+        assertEquals(\"cancel event index must be same as editingIndex\", editingIndex,\n+                events.get(0).getTreeTablePosition().getRow());\n+    }\n+\n+\/\/--------------- change to editing index\n+\n+    @Test\n+    public void testToEditingIndex() {\n+        cell.updateIndex(cellIndex);\n+        table.edit(editingIndex, editingColumn);\n+        cell.updateIndex(editingIndex);\n+        assertEquals(\"sanity: cell at editing index\", editingIndex, cell.getIndex());\n+        assertEquals(\"sanity: treeTable editingIndex must be unchanged\", editingIndex, table.getEditingCell().getRow());\n+        assertEquals(\"sanity: treeTable editingColumn must be unchanged\", editingColumn, table.getEditingCell().getTableColumn());\n+        assertTrue(\"cell must be editing on update from \" + cellIndex\n+                + \" to editingIndex \" + editingIndex, cell.isEditing());\n+    }\n+\n+    @Test\n+    public void testStartEvent() {\n+        cell.updateIndex(cellIndex);\n+        table.edit(editingIndex, editingColumn);\n+        List<CellEditEvent<String, String>> events = new ArrayList<>();\n+        editingColumn.setOnEditStart(e -> {\n+            events.add(e);\n+        });\n+        cell.updateIndex(editingIndex);\n+        assertEquals(\"cell must have fired edit start on update from \" + cellIndex + \" to \" + editingIndex,\n+                1, events.size());\n+        assertEquals(\"start event index must be same as editingIndex\", editingIndex,\n+                events.get(0).getTreeTablePosition().getRow());\n+    }\n+\n+\/\/------------- parameterized\n+\n+    \/\/ Note: name property not supported before junit 4.11\n+    @Parameterized.Parameters \/\/(name = \"{index}: cellIndex {0}, editingIndex {1}\")\n+    public static Collection<Object[]> data() {\n+     \/\/ [0] is cellIndex, [1] is editingIndex\n+        Object[][] data = new Object[][] {\n+            {1, 2}, \/\/ normal\n+            {0, 1}, \/\/ zero cell index\n+            {1, 0}, \/\/ zero editing index\n+            {-1, 1}, \/\/ negative cell - JDK-8265206\n+        };\n+        return Arrays.asList(data);\n+    }\n+\n+    public TreeTableCellEditingTest(int cellIndex, int editingIndex) {\n+        this.cellIndex = cellIndex;\n+        this.editingIndex = editingIndex;\n+    }\n+\n+\/\/-------------- setup and sanity\n+\n+    \/**\n+     * Sanity: cell editing state updated when on editing index.\n+     *\/\n+    @Test\n+    public void testEditOnCellIndex() {\n+        cell.updateIndex(editingIndex);\n+        table.edit(editingIndex, editingColumn);\n+        assertTrue(\"sanity: cell must be editing\", cell.isEditing());\n+    }\n+\n+    \/**\n+     * Sanity: cell editing state unchanged when off editing index.\n+     *\/\n+    @Test\n+    public void testEditOffCellIndex() {\n+        cell.updateIndex(cellIndex);\n+        table.edit(editingIndex, editingColumn);\n+        assertFalse(\"sanity: cell editing must be unchanged\", cell.isEditing());\n+    }\n+\n+    @Before\n+    public void setup() {\n+        cell = new TreeTableCell<String,String>();\n+        model = FXCollections.observableArrayList(new TreeItem<>(\"Four\"),\n+                new TreeItem<>(\"Five\"), new TreeItem<>(\"Fear\")); \/\/ \"Flop\", \"Food\", \"Fizz\"\n+        TreeItem<String> root = new TreeItem<>(\"root\");\n+        root.getChildren().addAll(model);\n+        root.setExpanded(true);\n+        table = new TreeTableView<String>(root);\n+        table.setEditable(true);\n+        editingColumn = new TreeTableColumn<>(\"TEST\");\n+        editingColumn.setCellValueFactory(param -> null);\n+        table.getColumns().add(editingColumn);\n+        cell.updateTreeTableView(table);\n+        cell.updateTreeTableColumn(editingColumn);\n+        \/\/ make sure that focus change doesn't interfere with tests\n+        \/\/ (editing cell loosing focus will be canceled from focusListener in Cell)\n+        \/\/ Note: not really needed for Tree\/TableCell because the cell is never focused\n+        \/\/ if !cellSelectionEnabled nor if not in Tree\/TableRow\n+        \/\/ done here for consistency across analogous tests for List\/Tree\/Cell\n+        table.getFocusModel().focus(-1);\n+        assertFalse(\"sanity: cellIndex not same as editingIndex\", cellIndex == editingIndex);\n+        assertTrue(\"sanity: valid editingIndex\", editingIndex < model.size());\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableCellEditingTest.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -38,0 +38,2 @@\n+\n+import org.junit.After;\n@@ -61,0 +63,8 @@\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+\n@@ -75,0 +85,6 @@\n+    @After\n+    public void cleanup() {\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+\n@@ -619,0 +635,57 @@\n+\n+    \/**\n+     * Test that cell.cancelEdit can switch table editing off\n+     * even if a subclass violates its contract.\n+     *\n+     * For details, see https:\/\/bugs.openjdk.java.net\/browse\/JDK-8265206\n+     *\n+     *\/\n+    @Test\n+    public void testMisbehavingCancelEditTerminatesEdit() {\n+        \/\/ setup for editing\n+        TreeTableCell<String, String> cell = new MisbehavingOnCancelTreeTableCell<>();\n+        tree.setEditable(true);\n+        TreeTableColumn<String, String> editingColumn = new TreeTableColumn<>(\"TEST\");\n+        editingColumn.setCellValueFactory(param -> null);\n+        tree.getColumns().add(editingColumn);\n+        cell.updateTreeTableView(tree);\n+        cell.updateTreeTableColumn(editingColumn);\n+        \/\/ test editing: first round\n+        \/\/ switch cell off editing by table api\n+        int editingIndex = 1;\n+        int intermediate = 0;\n+        cell.updateIndex(editingIndex);\n+        tree.edit(editingIndex, editingColumn);\n+        assertTrue(\"sanity: \", cell.isEditing());\n+        try {\n+            tree.edit(intermediate, editingColumn);\n+        } catch (Exception ex) {\n+            \/\/ catching to test in finally\n+        } finally {\n+            assertFalse(\"cell must not be editing\", cell.isEditing());\n+            assertEquals(\"table must be editing at intermediate index\", intermediate, tree.getEditingCell().getRow());\n+        }\n+        \/\/ test editing: second round\n+        \/\/ switch cell off editing by cell api\n+        tree.edit(editingIndex, editingColumn);\n+        assertTrue(\"sanity: \", cell.isEditing());\n+        try {\n+            cell.cancelEdit();\n+        } catch (Exception ex) {\n+            \/\/ catching to test in finally\n+        } finally {\n+            assertFalse(\"cell must not be editing\", cell.isEditing());\n+            assertNull(\"table editing must be cancelled by cell\", tree.getEditingCell());\n+        }\n+    }\n+\n+    public static class MisbehavingOnCancelTreeTableCell<S, T> extends TreeTableCell<S, T> {\n+\n+        @Override\n+        public void cancelEdit() {\n+            super.cancelEdit();\n+            throw new RuntimeException(\"violating contract\");\n+        }\n+\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableCellTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"}]}