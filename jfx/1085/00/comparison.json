{"files":[{"patch":"@@ -5,1 +5,1 @@\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_11\" project-jdk-name=\"11\" project-jdk-type=\"JavaSDK\">\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_19\" default=\"true\" project-jdk-name=\"11\" project-jdk-type=\"JavaSDK\">\n","filename":".idea\/misc.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    WindowContext* ctx = new WindowContextTop(obj,\n+    WindowContext* ctx = new WindowContext(obj,\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassWindow.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-WindowContext * WindowContextBase::sm_grab_window = NULL;\n-WindowContext * WindowContextBase::sm_mouse_drag_window = NULL;\n+WindowContext * WindowContext::sm_grab_window = NULL;\n+WindowContext * WindowContext::sm_mouse_drag_window = NULL;\n@@ -57,2 +57,22 @@\n-GdkWindow* WindowContextBase::get_gdk_window(){\n-    return gdk_window;\n+\/\/ Work-around because frame extents are only obtained after window is shown.\n+\/\/ This is used to know the total window size (content + decoration)\n+\/\/ The first window will have a duplicated resize event, subsequent windows will use the cached value.\n+WindowFrameExtents WindowContext::normal_extents = {0, 0, 0, 0};\n+WindowFrameExtents WindowContext::utility_extents = {0, 0, 0, 0};\n+\n+static inline jint gtk_button_number_to_mouse_button(guint button) {\n+    switch (button) {\n+        case 1:\n+            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+        case 2:\n+            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+        case 3:\n+            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+        case MOUSE_BACK_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n+        case MOUSE_FORWARD_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+        default:\n+            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n+            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+    }\n@@ -61,2 +81,6 @@\n-jobject WindowContextBase::get_jview() {\n-    return jview;\n+static int geometry_get_window_width(const WindowGeometry *windowGeometry) {\n+     return (windowGeometry->final_width.type == BOUNDSTYPE_WINDOW)\n+                   ? windowGeometry->final_width.value\n+                   : windowGeometry->final_width.value\n+                         + windowGeometry->extents.left\n+                         + windowGeometry->extents.right;\n@@ -65,2 +89,6 @@\n-jobject WindowContextBase::get_jwindow() {\n-    return jwindow;\n+static int geometry_get_window_height(const WindowGeometry *windowGeometry) {\n+    return (windowGeometry->final_height.type == BOUNDSTYPE_WINDOW)\n+                   ? windowGeometry->final_height.value\n+                   : windowGeometry->final_height.value\n+                         + windowGeometry->extents.top\n+                         + windowGeometry->extents.bottom;\n@@ -69,8 +97,6 @@\n-bool WindowContextBase::isEnabled() {\n-    if (jwindow) {\n-        bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));\n-        LOG_EXCEPTION(mainEnv)\n-        return result;\n-    } else {\n-        return false;\n-    }\n+static int geometry_get_content_width(WindowGeometry *windowGeometry) {\n+    return (windowGeometry->final_width.type == BOUNDSTYPE_CONTENT)\n+                   ? windowGeometry->final_width.value\n+                   : windowGeometry->final_width.value\n+                         - windowGeometry->extents.left\n+                         - windowGeometry->extents.right;\n@@ -79,5 +105,7 @@\n-void WindowContextBase::notify_state(jint glass_state) {\n-    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {\n-        if (is_maximized) {\n-            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;\n-        }\n+static int geometry_get_content_height(WindowGeometry *windowGeometry) {\n+    return (windowGeometry->final_height.type == BOUNDSTYPE_CONTENT)\n+                   ? windowGeometry->final_height.value\n+                   : windowGeometry->final_height.value\n+                         - windowGeometry->extents.top\n+                         - windowGeometry->extents.bottom;\n+}\n@@ -85,7 +113,27 @@\n-        int w, h;\n-        glass_gdk_window_get_size(gdk_window, &w, &h);\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview,\n-                    jViewNotifyRepaint,\n-                    0, 0, w, h);\n-            CHECK_JNI_EXCEPTION(mainEnv);\n+static GdkAtom get_net_frame_extents_atom() {\n+    static const char * extents_str = \"_NET_FRAME_EXTENTS\";\n+    return gdk_atom_intern(extents_str, FALSE);\n+}\n+\n+WindowContext::WindowContext(jobject _jwindow, WindowContext* _owner, long _screen,\n+        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n+            screen(_screen),\n+            frame_type(_frame_type),\n+            window_type(type),\n+            owner(_owner),\n+            geometry(),\n+            resizable(),\n+            jview(NULL) {\n+    jwindow = mainEnv->NewGlobalRef(_jwindow);\n+\n+    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);\n+\n+    if (gchar* app_name = get_application_name()) {\n+        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);\n+        g_free(app_name);\n+    }\n+\n+    if (owner) {\n+        owner->add_child(this);\n+        if (on_top_inherited()) {\n+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n@@ -95,5 +143,2 @@\n-    if (jwindow) {\n-       mainEnv->CallVoidMethod(jwindow,\n-               jGtkWindowNotifyStateChanged,\n-               glass_state);\n-       CHECK_JNI_EXCEPTION(mainEnv);\n+    if (type == UTILITY) {\n+        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);\n@@ -101,1 +146,0 @@\n-}\n@@ -103,2 +147,2 @@\n-void WindowContextBase::process_state(GdkEventWindowState* event) {\n-    if (event->changed_mask & (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {\n+    const char* wm_name = gdk_x11_screen_get_window_manager_name(gdk_screen_get_default());\n+    wmanager = (g_strcmp0(\"Compiz\", wm_name) == 0) ? COMPIZ : UNKNOWN;\n@@ -106,3 +150,3 @@\n-        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {\n-            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;\n-        }\n+\/\/    glong xdisplay = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationDisplay);\n+\/\/    gint  xscreenID = (gint)mainEnv->GetStaticIntField(jApplicationCls, jApplicationScreen);\n+    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n@@ -110,3 +154,4 @@\n-        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n-            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;\n-        }\n+    if (xvisualID != 0) {\n+        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n+        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n+    }\n@@ -114,1 +159,3 @@\n-        jint stateChangeEvent;\n+    gtk_widget_set_events(gtk_widget, GDK_FILTERED_EVENTS_MASK);\n+    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n+    glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);\n@@ -116,13 +163,3 @@\n-        if (is_iconified) {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;\n-        } else if (is_maximized) {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;\n-        } else {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;\n-            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0\n-                || (gdk_windowManagerFunctions & GDK_FUNC_MAXIMIZE) == 0) {\n-                \/\/ in this case - the window manager will not support the programatic\n-                \/\/ request to iconify \/ maximize - so we need to restore it now.\n-                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n-            }\n-        }\n+    gtk_window_set_title(GTK_WINDOW(gtk_widget), \"\");\n+    gdk_window = gtk_widget_get_window(gtk_widget);\n+    gdk_window_set_events(gdk_window, GDK_FILTERED_EVENTS_MASK);\n@@ -130,5 +167,1 @@\n-        notify_state(stateChangeEvent);\n-    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n-        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n-    }\n-}\n+    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n@@ -136,4 +169,1 @@\n-void WindowContextBase::process_focus(GdkEventFocus* event) {\n-    if (!event->in && WindowContextBase::sm_grab_window == this) {\n-        ungrab_focus();\n-    }\n+    gdk_window_register_dnd(gdk_window);\n@@ -141,6 +171,3 @@\n-    if (xim.enabled && xim.ic) {\n-        if (event->in) {\n-            XSetICFocus(xim.ic);\n-        } else {\n-            XUnsetICFocus(xim.ic);\n-        }\n+    gdk_windowManagerFunctions = wmf;\n+    if (wmf) {\n+        gdk_window_set_functions(gdk_window, wmf);\n@@ -149,11 +176,5 @@\n-    if (jwindow) {\n-        if (!event->in || isEnabled()) {\n-            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,\n-                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED\n-                              : com_sun_glass_events_WindowEvent_FOCUS_LOST);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        } else {\n-            \/\/ when the user tries to activate a disabled window, send FOCUS_DISABLED\n-            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusDisabled);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n+    if (frame_type != TITLED) {\n+        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);\n+    } else {\n+        request_frame_extents();\n+        geometry.extents = get_cached_extents();\n@@ -163,3 +184,0 @@\n-void WindowContextBase::increment_events_counter() {\n-    ++events_processing_cnt;\n-}\n@@ -167,2 +185,2 @@\n-void WindowContextBase::decrement_events_counter() {\n-    --events_processing_cnt;\n+GdkWindow* WindowContext::get_gdk_window(){\n+    return gdk_window;\n@@ -171,2 +189,2 @@\n-size_t WindowContextBase::get_events_count() {\n-    return events_processing_cnt;\n+jobject WindowContext::get_jwindow() {\n+    return jwindow;\n@@ -175,2 +193,2 @@\n-bool WindowContextBase::is_dead() {\n-    return can_be_deleted;\n+jobject WindowContext::get_jview() {\n+    return jview;\n@@ -179,9 +197,7 @@\n-void destroy_and_delete_ctx(WindowContext* ctx) {\n-    if (ctx) {\n-        ctx->process_destroy();\n-\n-        if (!ctx->get_events_count()) {\n-            delete ctx;\n-        }\n-        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n-        \/\/ an event processing\n+bool WindowContext::isEnabled() {\n+    if (jwindow) {\n+        bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));\n+        LOG_EXCEPTION(mainEnv)\n+        return result;\n+    } else {\n+        return false;\n@@ -191,4 +207,3 @@\n-void WindowContextBase::process_destroy() {\n-    if (WindowContextBase::sm_mouse_drag_window == this) {\n-        ungrab_mouse_drag_focus();\n-    }\n+WindowFrameExtents WindowContext::get_frame_extents() {\n+    return geometry.extents;\n+}\n@@ -196,3 +211,3 @@\n-    if (WindowContextBase::sm_grab_window == this) {\n-        ungrab_focus();\n-    }\n+GtkWindow *WindowContext::get_gtk_window() {\n+    return GTK_WINDOW(gtk_widget);\n+}\n@@ -200,11 +215,7 @@\n-    std::set<WindowContextTop*>::iterator it;\n-    for (it = children.begin(); it != children.end(); ++it) {\n-        \/\/ FIX JDK-8226537: this method calls set_owner(NULL) which prevents\n-        \/\/ WindowContextTop::process_destroy() to call remove_child() (because children\n-        \/\/ is being iterated here) but also prevents gtk_window_set_transient_for from\n-        \/\/ being called - this causes the crash on gnome.\n-        gtk_window_set_transient_for((*it)->get_gtk_window(), NULL);\n-        (*it)->set_owner(NULL);\n-        destroy_and_delete_ctx(*it);\n-    }\n-    children.clear();\n+void WindowContext::paint(void* data, jint width, jint height) {\n+#ifdef GLASS_GTK3\n+    cairo_rectangle_int_t rect = {0, 0, width, height};\n+    cairo_region_t *region = cairo_region_create_rectangle(&rect);\n+    gdk_window_begin_paint_region(gdk_window, region);\n+#endif\n+    cairo_t* context = gdk_cairo_create(gdk_window);\n@@ -212,4 +223,5 @@\n-    if (jwindow) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyDestroy);\n-        EXCEPTION_OCCURED(mainEnv);\n-    }\n+    cairo_surface_t* cairo_surface =\n+        cairo_image_surface_create_for_data(\n+            (unsigned char*)data,\n+            CAIRO_FORMAT_ARGB32,\n+            width, height, width * 4);\n@@ -217,4 +229,1 @@\n-    if (jview) {\n-        mainEnv->DeleteGlobalRef(jview);\n-        jview = NULL;\n-    }\n+    applyShapeMask(data, width, height);\n@@ -222,4 +231,3 @@\n-    if (jwindow) {\n-        mainEnv->DeleteGlobalRef(jwindow);\n-        jwindow = NULL;\n-    }\n+    cairo_set_source_surface(context, cairo_surface, 0, 0);\n+    cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);\n+    cairo_paint(context);\n@@ -227,2 +235,4 @@\n-    can_be_deleted = true;\n-}\n+#ifdef GLASS_GTK3\n+    gdk_window_end_paint(gdk_window);\n+    cairo_region_destroy(region);\n+#endif\n@@ -230,5 +240,2 @@\n-void WindowContextBase::process_delete() {\n-    if (jwindow && isEnabled()) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyClose);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n+    cairo_destroy(context);\n+    cairo_surface_destroy(cairo_surface);\n@@ -237,5 +244,4 @@\n-void WindowContextBase::process_expose(GdkEventExpose* event) {\n-    if (jview) {\n-        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y, event->area.width, event->area.height);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n+\n+void WindowContext::add_child(WindowContext* child) {\n+    children.insert(child);\n+    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());\n@@ -244,15 +250,159 @@\n-static inline jint gtk_button_number_to_mouse_button(guint button) {\n-    switch (button) {\n-        case 1:\n-            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n-        case 2:\n-            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n-        case 3:\n-            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n-        case MOUSE_BACK_BTN:\n-            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n-        case MOUSE_FORWARD_BTN:\n-            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n-        default:\n-            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n-            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+void WindowContext::remove_child(WindowContext* child) {\n+    children.erase(child);\n+    gtk_window_set_transient_for(child->get_gtk_window(), NULL);\n+}\n+\n+void WindowContext::show_or_hide_children(bool show) {\n+    std::set<WindowContext*>::iterator it;\n+    for (it = children.begin(); it != children.end(); ++it) {\n+        (*it)->set_minimized(!show);\n+        (*it)->show_or_hide_children(show);\n+    }\n+}\n+\n+bool WindowContext::is_visible() {\n+    return gtk_widget_get_visible(gtk_widget);\n+}\n+\n+bool WindowContext::set_view(jobject view) {\n+    if (jview) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                com_sun_glass_events_MouseEvent_EXIT,\n+                com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                0, 0,\n+                0, 0,\n+                0,\n+                JNI_FALSE,\n+                JNI_FALSE);\n+        mainEnv->DeleteGlobalRef(jview);\n+    }\n+\n+    if (view) {\n+        jview = mainEnv->NewGlobalRef(view);\n+    } else {\n+        jview = NULL;\n+    }\n+    return TRUE;\n+}\n+\n+bool WindowContext::grab_focus() {\n+    if (WindowContext::sm_mouse_drag_window\n+            || glass_gdk_mouse_devices_grab(gdk_window)) {\n+        WindowContext::sm_grab_window = this;\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+bool WindowContext::grab_mouse_drag_focus() {\n+    if (glass_gdk_mouse_devices_grab_with_cursor(\n+            gdk_window, gdk_window_get_cursor(gdk_window), FALSE)) {\n+        WindowContext::sm_mouse_drag_window = this;\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+void WindowContext::ungrab_focus() {\n+    if (!WindowContext::sm_mouse_drag_window) {\n+        glass_gdk_mouse_devices_ungrab();\n+    }\n+    WindowContext::sm_grab_window = NULL;\n+\n+    if (jwindow) {\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n+void WindowContext::ungrab_mouse_drag_focus() {\n+    WindowContext::sm_mouse_drag_window = NULL;\n+    glass_gdk_mouse_devices_ungrab();\n+    if (WindowContext::sm_grab_window) {\n+        WindowContext::sm_grab_window->grab_focus();\n+    }\n+}\n+\n+void WindowContext::process_focus(GdkEventFocus* event) {\n+    if (!event->in && WindowContext::sm_grab_window == this) {\n+        ungrab_focus();\n+    }\n+\n+    if (xim.enabled && xim.ic) {\n+        if (event->in) {\n+            XSetICFocus(xim.ic);\n+        } else {\n+            XUnsetICFocus(xim.ic);\n+        }\n+    }\n+\n+    if (jwindow) {\n+        if (!event->in || isEnabled()) {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,\n+                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED\n+                              : com_sun_glass_events_WindowEvent_FOCUS_LOST);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        } else {\n+            \/\/ when the user tries to activate a disabled window, send FOCUS_DISABLED\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusDisabled);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+}\n+\n+void WindowContext::process_destroy() {\n+    if (owner) {\n+        owner->remove_child(this);\n+    }\n+\n+    if (WindowContext::sm_mouse_drag_window == this) {\n+        ungrab_mouse_drag_focus();\n+    }\n+\n+    if (WindowContext::sm_grab_window == this) {\n+        ungrab_focus();\n+    }\n+\n+    std::set<WindowContext*>::iterator it;\n+    for (it = children.begin(); it != children.end(); ++it) {\n+        \/\/ FIX JDK-8226537: this method calls set_owner(NULL) which prevents\n+        \/\/ WindowContext::process_destroy() to call remove_child() (because children\n+        \/\/ is being iterated here) but also prevents gtk_window_set_transient_for from\n+        \/\/ being called - this causes the crash on gnome.\n+        gtk_window_set_transient_for((*it)->get_gtk_window(), NULL);\n+        (*it)->set_owner(NULL);\n+        destroy_and_delete_ctx(*it);\n+    }\n+    children.clear();\n+\n+    if (jwindow) {\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyDestroy);\n+        EXCEPTION_OCCURED(mainEnv);\n+    }\n+\n+    if (jview) {\n+        mainEnv->DeleteGlobalRef(jview);\n+        jview = NULL;\n+    }\n+\n+    if (jwindow) {\n+        mainEnv->DeleteGlobalRef(jwindow);\n+        jwindow = NULL;\n+    }\n+\n+    can_be_deleted = true;\n+}\n+\n+void WindowContext::process_delete() {\n+    if (jwindow && isEnabled()) {\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyClose);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n+void WindowContext::process_expose(GdkEventExpose* event) {\n+    if (jview) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y, event->area.width, event->area.height);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -262,1 +412,1 @@\n-void WindowContextBase::process_mouse_button(GdkEventButton* event) {\n+void WindowContext::process_mouse_button(GdkEventButton* event) {\n@@ -340,1 +490,1 @@\n-void WindowContextBase::process_mouse_motion(GdkEventMotion* event) {\n+void WindowContext::process_mouse_motion(GdkEventMotion* event) {\n@@ -350,1 +500,1 @@\n-    if (isDrag && WindowContextBase::sm_mouse_drag_window == NULL) {\n+    if (isDrag && WindowContext::sm_mouse_drag_window == NULL) {\n@@ -383,1 +533,1 @@\n-void WindowContextBase::process_mouse_scroll(GdkEventScroll* event) {\n+void WindowContext::process_mouse_scroll(GdkEventScroll* event) {\n@@ -426,1 +576,1 @@\n-void WindowContextBase::process_mouse_cross(GdkEventCrossing* event) {\n+void WindowContext::process_mouse_cross(GdkEventCrossing* event) {\n@@ -449,1 +599,1 @@\n-void WindowContextBase::process_key(GdkEventKey* event) {\n+void WindowContext::process_key(GdkEventKey* event) {\n@@ -514,432 +664,2 @@\n-    }\n-}\n-\n-void WindowContextBase::paint(void* data, jint width, jint height) {\n-#ifdef GLASS_GTK3\n-    cairo_rectangle_int_t rect = {0, 0, width, height};\n-    cairo_region_t *region = cairo_region_create_rectangle(&rect);\n-    gdk_window_begin_paint_region(gdk_window, region);\n-#endif\n-    cairo_t* context = gdk_cairo_create(gdk_window);\n-\n-    cairo_surface_t* cairo_surface =\n-        cairo_image_surface_create_for_data(\n-            (unsigned char*)data,\n-            CAIRO_FORMAT_ARGB32,\n-            width, height, width * 4);\n-\n-    applyShapeMask(data, width, height);\n-\n-    cairo_set_source_surface(context, cairo_surface, 0, 0);\n-    cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);\n-    cairo_paint(context);\n-\n-#ifdef GLASS_GTK3\n-    gdk_window_end_paint(gdk_window);\n-    cairo_region_destroy(region);\n-#endif\n-\n-    cairo_destroy(context);\n-    cairo_surface_destroy(cairo_surface);\n-}\n-\n-void WindowContextBase::add_child(WindowContextTop* child) {\n-    children.insert(child);\n-    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());\n-}\n-\n-void WindowContextBase::remove_child(WindowContextTop* child) {\n-    children.erase(child);\n-    gtk_window_set_transient_for(child->get_gtk_window(), NULL);\n-}\n-\n-void WindowContextBase::show_or_hide_children(bool show) {\n-    std::set<WindowContextTop*>::iterator it;\n-    for (it = children.begin(); it != children.end(); ++it) {\n-        (*it)->set_minimized(!show);\n-        (*it)->show_or_hide_children(show);\n-    }\n-}\n-\n-void WindowContextBase::set_visible(bool visible) {\n-    if (visible) {\n-        gtk_widget_show(gtk_widget);\n-    } else {\n-        gtk_widget_hide(gtk_widget);\n-        if (jview && is_mouse_entered) {\n-            is_mouse_entered = false;\n-            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n-                    com_sun_glass_events_MouseEvent_EXIT,\n-                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n-                    0, 0,\n-                    0, 0,\n-                    0,\n-                    JNI_FALSE,\n-                    JNI_FALSE);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n-    }\n-}\n-\n-bool WindowContextBase::is_visible() {\n-    return gtk_widget_get_visible(gtk_widget);\n-}\n-\n-bool WindowContextBase::set_view(jobject view) {\n-    if (jview) {\n-        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n-                com_sun_glass_events_MouseEvent_EXIT,\n-                com_sun_glass_events_MouseEvent_BUTTON_NONE,\n-                0, 0,\n-                0, 0,\n-                0,\n-                JNI_FALSE,\n-                JNI_FALSE);\n-        mainEnv->DeleteGlobalRef(jview);\n-    }\n-\n-    if (view) {\n-        jview = mainEnv->NewGlobalRef(view);\n-    } else {\n-        jview = NULL;\n-    }\n-    return TRUE;\n-}\n-\n-bool WindowContextBase::grab_mouse_drag_focus() {\n-    if (glass_gdk_mouse_devices_grab_with_cursor(\n-            gdk_window, gdk_window_get_cursor(gdk_window), FALSE)) {\n-        WindowContextBase::sm_mouse_drag_window = this;\n-        return true;\n-    } else {\n-        return false;\n-    }\n-}\n-\n-void WindowContextBase::ungrab_mouse_drag_focus() {\n-    WindowContextBase::sm_mouse_drag_window = NULL;\n-    glass_gdk_mouse_devices_ungrab();\n-    if (WindowContextBase::sm_grab_window) {\n-        WindowContextBase::sm_grab_window->grab_focus();\n-    }\n-}\n-\n-bool WindowContextBase::grab_focus() {\n-    if (WindowContextBase::sm_mouse_drag_window\n-            || glass_gdk_mouse_devices_grab(gdk_window)) {\n-        WindowContextBase::sm_grab_window = this;\n-        return true;\n-    } else {\n-        return false;\n-    }\n-}\n-\n-void WindowContextBase::ungrab_focus() {\n-    if (!WindowContextBase::sm_mouse_drag_window) {\n-        glass_gdk_mouse_devices_ungrab();\n-    }\n-    WindowContextBase::sm_grab_window = NULL;\n-\n-    if (jwindow) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n-}\n-\n-void WindowContextBase::set_cursor(GdkCursor* cursor) {\n-    if (!is_in_drag()) {\n-        if (WindowContextBase::sm_mouse_drag_window) {\n-            glass_gdk_mouse_devices_grab_with_cursor(\n-                    WindowContextBase::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);\n-        } else if (WindowContextBase::sm_grab_window) {\n-            glass_gdk_mouse_devices_grab_with_cursor(\n-                    WindowContextBase::sm_grab_window->get_gdk_window(), cursor, TRUE);\n-        }\n-    }\n-    gdk_window_set_cursor(gdk_window, cursor);\n-}\n-\n-void WindowContextBase::set_background(float r, float g, float b) {\n-#ifdef GLASS_GTK3\n-    GdkRGBA rgba = {0, 0, 0, 1.};\n-    rgba.red = r;\n-    rgba.green = g;\n-    rgba.blue = b;\n-    gdk_window_set_background_rgba(gdk_window, &rgba);\n-#else\n-    GdkColor color;\n-    color.red   = (guint16) (r * 65535);\n-    color.green = (guint16) (g * 65535);\n-    color.blue  = (guint16) (b * 65535);\n-    gtk_widget_modify_bg(gtk_widget, GTK_STATE_NORMAL, &color);\n-#endif\n-}\n-\n-WindowContextBase::~WindowContextBase() {\n-    if (xim.ic) {\n-        XDestroyIC(xim.ic);\n-        xim.ic = NULL;\n-    }\n-    if (xim.im) {\n-        XCloseIM(xim.im);\n-        xim.im = NULL;\n-    }\n-\n-    gtk_widget_destroy(gtk_widget);\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ WindowContextTop \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\n-\/\/ Work-around because frame extents are only obtained after window is shown.\n-\/\/ This is used to know the total window size (content + decoration)\n-\/\/ The first window will have a duplicated resize event, subsequent windows will use the cached value.\n-WindowFrameExtents WindowContextTop::normal_extents = {0, 0, 0, 0};\n-WindowFrameExtents WindowContextTop::utility_extents = {0, 0, 0, 0};\n-\n-static int geometry_get_window_width(const WindowGeometry *windowGeometry) {\n-     return (windowGeometry->final_width.type == BOUNDSTYPE_WINDOW)\n-                   ? windowGeometry->final_width.value\n-                   : windowGeometry->final_width.value\n-                         + windowGeometry->extents.left\n-                         + windowGeometry->extents.right;\n-}\n-\n-static int geometry_get_window_height(const WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_height.type == BOUNDSTYPE_WINDOW)\n-                   ? windowGeometry->final_height.value\n-                   : windowGeometry->final_height.value\n-                         + windowGeometry->extents.top\n-                         + windowGeometry->extents.bottom;\n-}\n-\n-static int geometry_get_content_width(WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_width.type == BOUNDSTYPE_CONTENT)\n-                   ? windowGeometry->final_width.value\n-                   : windowGeometry->final_width.value\n-                         - windowGeometry->extents.left\n-                         - windowGeometry->extents.right;\n-}\n-\n-static int geometry_get_content_height(WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_height.type == BOUNDSTYPE_CONTENT)\n-                   ? windowGeometry->final_height.value\n-                   : windowGeometry->final_height.value\n-                         - windowGeometry->extents.top\n-                         - windowGeometry->extents.bottom;\n-}\n-\n-static GdkAtom get_net_frame_extents_atom() {\n-    static const char * extents_str = \"_NET_FRAME_EXTENTS\";\n-    return gdk_atom_intern(extents_str, FALSE);\n-}\n-\n-WindowContextTop::WindowContextTop(jobject _jwindow, WindowContext* _owner, long _screen,\n-        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n-            WindowContextBase(),\n-            screen(_screen),\n-            frame_type(_frame_type),\n-            window_type(type),\n-            owner(_owner),\n-            geometry(),\n-            resizable(),\n-            on_top(false),\n-            is_fullscreen(false) {\n-    jwindow = mainEnv->NewGlobalRef(_jwindow);\n-\n-    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);\n-\n-    if (gchar* app_name = get_application_name()) {\n-        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);\n-        g_free(app_name);\n-    }\n-\n-    if (owner) {\n-        owner->add_child(this);\n-        if (on_top_inherited()) {\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n-        }\n-    }\n-\n-    if (type == UTILITY) {\n-        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);\n-    }\n-\n-    const char* wm_name = gdk_x11_screen_get_window_manager_name(gdk_screen_get_default());\n-    wmanager = (g_strcmp0(\"Compiz\", wm_name) == 0) ? COMPIZ : UNKNOWN;\n-\n-\/\/    glong xdisplay = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationDisplay);\n-\/\/    gint  xscreenID = (gint)mainEnv->GetStaticIntField(jApplicationCls, jApplicationScreen);\n-    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n-\n-    if (xvisualID != 0) {\n-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n-        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n-    }\n-\n-    gtk_widget_set_events(gtk_widget, GDK_FILTERED_EVENTS_MASK);\n-    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n-    glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);\n-\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), \"\");\n-    gdk_window = gtk_widget_get_window(gtk_widget);\n-    gdk_window_set_events(gdk_window, GDK_FILTERED_EVENTS_MASK);\n-\n-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n-\n-    gdk_window_register_dnd(gdk_window);\n-\n-    gdk_windowManagerFunctions = wmf;\n-    if (wmf) {\n-        gdk_window_set_functions(gdk_window, wmf);\n-    }\n-\n-    if (frame_type != TITLED) {\n-        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);\n-    } else {\n-        request_frame_extents();\n-        geometry.extents = get_cached_extents();\n-    }\n-}\n-\n-\/\/ Applied to a temporary full screen window to prevent sending events to Java\n-void WindowContextTop::detach_from_java() {\n-    if (jview) {\n-        mainEnv->DeleteGlobalRef(jview);\n-        jview = NULL;\n-    }\n-    if (jwindow) {\n-        mainEnv->DeleteGlobalRef(jwindow);\n-        jwindow = NULL;\n-    }\n-}\n-\n-void WindowContextTop::request_frame_extents() {\n-    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n-    static Atom rfeAtom = XInternAtom(display, \"_NET_REQUEST_FRAME_EXTENTS\", False);\n-\n-    if (rfeAtom != None) {\n-        XClientMessageEvent clientMessage;\n-        memset(&clientMessage, 0, sizeof(clientMessage));\n-\n-        clientMessage.type = ClientMessage;\n-        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n-        clientMessage.message_type = rfeAtom;\n-        clientMessage.format = 32;\n-\n-        XSendEvent(display, XDefaultRootWindow(display), False,\n-                   SubstructureRedirectMask | SubstructureNotifyMask,\n-                   (XEvent *) &clientMessage);\n-        XFlush(display);\n-    }\n-}\n-\n-void WindowContextTop::update_frame_extents() {\n-    int top, left, bottom, right;\n-\n-    if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n-        if (top > 0 || right > 0 || bottom > 0 || left > 0) {\n-            bool changed = geometry.extents.top != top\n-                            || geometry.extents.left != left\n-                            || geometry.extents.bottom != bottom\n-                            || geometry.extents.right != right;\n-\n-            if (changed) {\n-                geometry.extents.top = top;\n-                geometry.extents.left = left;\n-                geometry.extents.bottom = bottom;\n-                geometry.extents.right = right;\n-\n-                set_cached_extents(geometry.extents);\n-\n-                \/\/ set bounds again to correct window size\n-                \/\/ accounting decorations\n-                int w = geometry_get_window_width(&geometry);\n-                int h = geometry_get_window_height(&geometry);\n-                int cw = geometry_get_content_width(&geometry);\n-                int ch = geometry_get_content_height(&geometry);\n-\n-                int x = geometry.x;\n-                int y = geometry.y;\n-\n-                if (geometry.gravity_x != 0) {\n-                    x -= geometry.gravity_x * (float) (left + right);\n-                }\n-\n-                if (geometry.gravity_y != 0) {\n-                    y -= geometry.gravity_y * (float) (top + bottom);\n-                }\n-\n-                set_bounds(x, y, true, true, w, h, cw, ch, 0, 0);\n-           }\n-        }\n-    }\n-}\n-\n-void WindowContextTop::set_cached_extents(WindowFrameExtents ex) {\n-    if (window_type == NORMAL) {\n-        normal_extents = ex;\n-    } else {\n-        utility_extents = ex;\n-    }\n-}\n-\n-WindowFrameExtents WindowContextTop::get_cached_extents() {\n-    return window_type == NORMAL ? normal_extents : utility_extents;\n-}\n-\n-bool WindowContextTop::get_frame_extents_property(int *top, int *left,\n-        int *bottom, int *right) {\n-    unsigned long *extents;\n-\n-    if (gdk_property_get(gdk_window,\n-            get_net_frame_extents_atom(),\n-            gdk_atom_intern(\"CARDINAL\", FALSE),\n-            0,\n-            sizeof (unsigned long) * 4,\n-            FALSE,\n-            NULL,\n-            NULL,\n-            NULL,\n-            (guchar**) & extents)) {\n-        *left = extents [0];\n-        *right = extents [1];\n-        *top = extents [2];\n-        *bottom = extents [3];\n-\n-        g_free(extents);\n-        return true;\n-    }\n-\n-    return false;\n-}\n-\n-void WindowContextTop::work_around_compiz_state() {\n-    \/\/ Workaround for https:\/\/bugs.launchpad.net\/unity\/+bug\/998073\n-    if (wmanager != COMPIZ) {\n-        return;\n-    }\n-\n-    static GdkAtom atom_atom = gdk_atom_intern_static_string(\"ATOM\");\n-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n-    static GdkAtom atom_net_wm_state_hidden = gdk_atom_intern_static_string(\"_NET_WM_STATE_HIDDEN\");\n-    static GdkAtom atom_net_wm_state_above = gdk_atom_intern_static_string(\"_NET_WM_STATE_ABOVE\");\n-\n-    gint length;\n-\n-    glong* atoms = NULL;\n-\n-    if (gdk_property_get(gdk_window, atom_net_wm_state, atom_atom,\n-            0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar**) &atoms)) {\n-\n-        bool is_hidden = false;\n-        bool is_above = false;\n-        for (gint i = 0; i < (gint)(length \/ sizeof(glong)); i++) {\n-            if (atom_net_wm_state_hidden == (GdkAtom)atoms[i]) {\n-                is_hidden = true;\n-            } else if (atom_net_wm_state_above == (GdkAtom)atoms[i]) {\n-                is_above = true;\n-            }\n-        }\n-\n-        g_free(atoms);\n+    }\n+}\n@@ -947,2 +667,2 @@\n-        if (is_iconified != is_hidden) {\n-            is_iconified = is_hidden;\n+void WindowContext::process_state(GdkEventWindowState* event) {\n+    if (event->changed_mask & (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {\n@@ -950,3 +670,2 @@\n-            notify_state((is_hidden)\n-                    ? com_sun_glass_events_WindowEvent_MINIMIZE\n-                    : com_sun_glass_events_WindowEvent_RESTORE);\n+        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {\n+            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;\n@@ -955,3 +674,3 @@\n-        notify_on_top(is_above);\n-    }\n-}\n+        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n+            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;\n+        }\n@@ -959,2 +678,1 @@\n-void WindowContextTop::process_property_notify(GdkEventProperty* event) {\n-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n+        jint stateChangeEvent;\n@@ -962,5 +680,12 @@\n-    if (event->window == gdk_window) {\n-        if (event->atom == get_net_frame_extents_atom()) {\n-            update_frame_extents();\n-        } else if (event->atom == atom_net_wm_state) {\n-            work_around_compiz_state();\n+        if (is_iconified) {\n+            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;\n+        } else if (is_maximized) {\n+            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;\n+        } else {\n+            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;\n+            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0\n+                || (gdk_windowManagerFunctions & GDK_FUNC_MAXIMIZE) == 0) {\n+                \/\/ in this case - the window manager will not support the programatic\n+                \/\/ request to iconify \/ maximize - so we need to restore it now.\n+                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n+            }\n@@ -968,0 +693,4 @@\n+\n+        notify_state(stateChangeEvent);\n+    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n+        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n@@ -969,1 +698,0 @@\n-}\n@@ -971,1 +699,0 @@\n-void WindowContextTop::process_state(GdkEventWindowState* event) {\n@@ -981,0 +708,4 @@\n+}\n+\n+void WindowContext::process_property_notify(GdkEventProperty* event) {\n+    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n@@ -982,1 +713,7 @@\n-    WindowContextBase::process_state(event);\n+    if (event->window == gdk_window) {\n+        if (event->atom == get_net_frame_extents_atom()) {\n+            update_frame_extents();\n+        } else if (event->atom == atom_net_wm_state) {\n+            work_around_compiz_state();\n+        }\n+    }\n@@ -985,1 +722,1 @@\n-void WindowContextTop::process_configure(GdkEventConfigure* event) {\n+void WindowContext::process_configure(GdkEventConfigure* event) {\n@@ -1041,2 +778,5 @@\n-void WindowContextTop::update_window_constraints() {\n-    GdkGeometry hints;\n+void WindowContext::notify_state(jint glass_state) {\n+    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {\n+        if (is_maximized) {\n+            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;\n+        }\n@@ -1044,5 +784,9 @@\n-    if (resizable.value && !is_disabled) {\n-        int min_w = (resizable.minw == -1) ? 1\n-                      : resizable.minw - geometry.extents.left - geometry.extents.right;\n-        int min_h =  (resizable.minh == -1) ? 1\n-                      : resizable.minh - geometry.extents.top - geometry.extents.bottom;\n+        int w, h;\n+        glass_gdk_window_get_size(gdk_window, &w, &h);\n+        if (jview) {\n+            mainEnv->CallVoidMethod(jview,\n+                    jViewNotifyRepaint,\n+                    0, 0, w, h);\n+            CHECK_JNI_EXCEPTION(mainEnv);\n+        }\n+    }\n@@ -1050,2 +794,7 @@\n-        hints.min_width = (min_w < 1) ? 1 : min_w;\n-        hints.min_height = (min_h < 1) ? 1 : min_h;\n+    if (jwindow) {\n+       mainEnv->CallVoidMethod(jwindow,\n+               jGtkWindowNotifyStateChanged,\n+               glass_state);\n+       CHECK_JNI_EXCEPTION(mainEnv);\n+    }\n+}\n@@ -1053,2 +802,5 @@\n-        hints.max_width = (resizable.maxw == -1) ? G_MAXINT\n-                            : resizable.maxw - geometry.extents.left - geometry.extents.right;\n+void WindowContext::work_around_compiz_state() {\n+    \/\/ Workaround for https:\/\/bugs.launchpad.net\/unity\/+bug\/998073\n+    if (wmanager != COMPIZ) {\n+        return;\n+    }\n@@ -1056,5 +808,4 @@\n-        hints.max_height = (resizable.maxh == -1) ? G_MAXINT\n-                           : resizable.maxh - geometry.extents.top - geometry.extents.bottom;\n-    } else {\n-        int w = geometry_get_content_width(&geometry);\n-        int h = geometry_get_content_height(&geometry);\n+    static GdkAtom atom_atom = gdk_atom_intern_static_string(\"ATOM\");\n+    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n+    static GdkAtom atom_net_wm_state_hidden = gdk_atom_intern_static_string(\"_NET_WM_STATE_HIDDEN\");\n+    static GdkAtom atom_net_wm_state_above = gdk_atom_intern_static_string(\"_NET_WM_STATE_ABOVE\");\n@@ -1062,4 +813,28 @@\n-        hints.min_width = w;\n-        hints.min_height = h;\n-        hints.max_width = w;\n-        hints.max_height = h;\n+    gint length;\n+\n+    glong* atoms = NULL;\n+\n+    if (gdk_property_get(gdk_window, atom_net_wm_state, atom_atom,\n+            0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar**) &atoms)) {\n+\n+        bool is_hidden = false;\n+        bool is_above = false;\n+        for (gint i = 0; i < (gint)(length \/ sizeof(glong)); i++) {\n+            if (atom_net_wm_state_hidden == (GdkAtom)atoms[i]) {\n+                is_hidden = true;\n+            } else if (atom_net_wm_state_above == (GdkAtom)atoms[i]) {\n+                is_above = true;\n+            }\n+        }\n+\n+        g_free(atoms);\n+\n+        if (is_iconified != is_hidden) {\n+            is_iconified = is_hidden;\n+\n+            notify_state((is_hidden)\n+                    ? com_sun_glass_events_WindowEvent_MINIMIZE\n+                    : com_sun_glass_events_WindowEvent_RESTORE);\n+        }\n+\n+        notify_on_top(is_above);\n@@ -1067,0 +842,1 @@\n+}\n@@ -1068,2 +844,11 @@\n-    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &hints,\n-                                  (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n+void WindowContext::set_cursor(GdkCursor* cursor) {\n+    if (!is_in_drag()) {\n+        if (WindowContext::sm_mouse_drag_window) {\n+            glass_gdk_mouse_devices_grab_with_cursor(\n+                    WindowContext::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);\n+        } else if (WindowContext::sm_grab_window) {\n+            glass_gdk_mouse_devices_grab_with_cursor(\n+                    WindowContext::sm_grab_window->get_gdk_window(), cursor, TRUE);\n+        }\n+    }\n+    gdk_window_set_cursor(gdk_window, cursor);\n@@ -1072,3 +857,14 @@\n-void WindowContextTop::set_resizable(bool res) {\n-    resizable.value = res;\n-    update_window_constraints();\n+void WindowContext::set_background(float r, float g, float b) {\n+#ifdef GLASS_GTK3\n+    GdkRGBA rgba = {0, 0, 0, 1.};\n+    rgba.red = r;\n+    rgba.green = g;\n+    rgba.blue = b;\n+    gdk_window_set_background_rgba(gdk_window, &rgba);\n+#else\n+    GdkColor color;\n+    color.red   = (guint16) (r * 65535);\n+    color.green = (guint16) (g * 65535);\n+    color.blue  = (guint16) (b * 65535);\n+    gtk_widget_modify_bg(gtk_widget, GTK_STATE_NORMAL, &color);\n+#endif\n@@ -1077,2 +873,7 @@\n-void WindowContextTop::set_visible(bool visible) {\n-    WindowContextBase::set_visible(visible);\n+void WindowContext::set_minimized(bool minimize) {\n+    is_iconified = minimize;\n+    if (minimize) {\n+        if (frame_type == TRANSPARENT && wmanager == COMPIZ) {\n+            \/\/ https:\/\/bugs.launchpad.net\/ubuntu\/+source\/unity\/+bug\/1245571\n+            glass_window_reset_input_shape_mask(gtk_widget_get_window(gtk_widget));\n+        }\n@@ -1080,2 +881,10 @@\n-    if (visible && !geometry.size_assigned) {\n-        set_bounds(0, 0, false, false, 320, 200, -1, -1, 0, 0);\n+        if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {\n+            \/\/ in this case - the window manager will not support the programatic\n+            \/\/ request to iconify - so we need to disable this until we are restored.\n+            GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MINIMIZE);\n+            gdk_window_set_functions(gdk_window, wmf);\n+        }\n+        gtk_window_iconify(GTK_WINDOW(gtk_widget));\n+    } else {\n+        gtk_window_deiconify(GTK_WINDOW(gtk_widget));\n+        gdk_window_focus(gdk_window, GDK_CURRENT_TIME);\n@@ -1083,0 +892,1 @@\n+}\n@@ -1084,4 +894,11 @@\n-    \/\/JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order\n-    if (visible && jwindow && isEnabled()) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n-        CHECK_JNI_EXCEPTION(mainEnv);\n+void WindowContext::set_maximized(bool maximize) {\n+    is_maximized = maximize;\n+    if (maximize) {\n+        \/\/ enable the functionality on the window manager as it might ignore the maximize command,\n+        \/\/ for example when the window is undecorated.\n+        GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);\n+        gdk_window_set_functions(gdk_window, wmf);\n+\n+        gtk_window_maximize(GTK_WINDOW(gtk_widget));\n+    } else {\n+        gtk_window_unmaximize(GTK_WINDOW(gtk_widget));\n@@ -1091,1 +908,1 @@\n-void WindowContextTop::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch,\n+void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch,\n@@ -1144,3 +961,44 @@\n-void WindowContextTop::applyShapeMask(void* data, uint width, uint height) {\n-    if (frame_type != TRANSPARENT) {\n-        return;\n+void WindowContext::set_resizable(bool res) {\n+    resizable.value = res;\n+    update_window_constraints();\n+}\n+\n+void WindowContext::set_focusable(bool focusable) {\n+    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);\n+}\n+\n+void WindowContext::set_title(const char* title) {\n+    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);\n+}\n+\n+void WindowContext::set_alpha(double alpha) {\n+    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);\n+}\n+\n+void WindowContext::set_enabled(bool enabled) {\n+    is_disabled = !enabled;\n+    update_window_constraints();\n+}\n+\n+void WindowContext::set_minimum_size(int w, int h) {\n+    resizable.minw = (w <= 0) ? 1 : w;\n+    resizable.minh = (h <= 0) ? 1 : h;\n+    update_window_constraints();\n+}\n+\n+void WindowContext::set_maximum_size(int w, int h) {\n+    resizable.maxw = w;\n+    resizable.maxh = h;\n+    update_window_constraints();\n+}\n+\n+void WindowContext::set_icon(GdkPixbuf* pixbuf) {\n+    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);\n+}\n+\n+void WindowContext::set_modal(bool modal, WindowContext* parent) {\n+    if (modal) {\n+        \/\/gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);\n+        if (parent) {\n+            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());\n+        }\n@@ -1148,0 +1006,2 @@\n+    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);\n+}\n@@ -1149,1 +1009,12 @@\n-    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);\n+void WindowContext::set_level(int level) {\n+    if (level == com_sun_glass_ui_Window_Level_NORMAL) {\n+        on_top = false;\n+    } else if (level == com_sun_glass_ui_Window_Level_FLOATING\n+            || level == com_sun_glass_ui_Window_Level_TOPMOST) {\n+        on_top = true;\n+    }\n+    \/\/ We need to emulate always on top behaviour on child windows\n+\n+    if (!on_top_inherited()) {\n+        update_ontop_tree(on_top);\n+    }\n@@ -1152,6 +1023,6 @@\n-void WindowContextTop::set_minimized(bool minimize) {\n-    is_iconified = minimize;\n-    if (minimize) {\n-        if (frame_type == TRANSPARENT && wmanager == COMPIZ) {\n-            \/\/ https:\/\/bugs.launchpad.net\/ubuntu\/+source\/unity\/+bug\/1245571\n-            glass_window_reset_input_shape_mask(gtk_widget_get_window(gtk_widget));\n+void WindowContext::set_visible(bool visible) {\n+    if (visible) {\n+        gtk_widget_show(gtk_widget);\n+\n+        if (!geometry.size_assigned) {\n+            set_bounds(0, 0, false, false, 320, 200, -1, -1, 0, 0);\n@@ -1160,5 +1031,18 @@\n-        if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {\n-            \/\/ in this case - the window manager will not support the programatic\n-            \/\/ request to iconify - so we need to disable this until we are restored.\n-            GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MINIMIZE);\n-            gdk_window_set_functions(gdk_window, wmf);\n+        \/\/JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order\n+        if (jwindow && isEnabled()) {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n+            CHECK_JNI_EXCEPTION(mainEnv);\n+        }\n+    } else {\n+        gtk_widget_hide(gtk_widget);\n+        if (jview && is_mouse_entered) {\n+            is_mouse_entered = false;\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                    com_sun_glass_events_MouseEvent_EXIT,\n+                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                    0, 0,\n+                    0, 0,\n+                    0,\n+                    JNI_FALSE,\n+                    JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n@@ -1166,4 +1050,0 @@\n-        gtk_window_iconify(GTK_WINDOW(gtk_widget));\n-    } else {\n-        gtk_window_deiconify(GTK_WINDOW(gtk_widget));\n-        gdk_window_focus(gdk_window, GDK_CURRENT_TIME);\n@@ -1173,7 +1053,3 @@\n-void WindowContextTop::set_maximized(bool maximize) {\n-    is_maximized = maximize;\n-    if (maximize) {\n-        \/\/ enable the functionality on the window manager as it might ignore the maximize command,\n-        \/\/ for example when the window is undecorated.\n-        GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);\n-        gdk_window_set_functions(gdk_window, wmf);\n+void WindowContext::set_owner(WindowContext * owner_ctx) {\n+    owner = owner_ctx;\n+}\n@@ -1181,3 +1057,28 @@\n-        gtk_window_maximize(GTK_WINDOW(gtk_widget));\n-    } else {\n-        gtk_window_unmaximize(GTK_WINDOW(gtk_widget));\n+void WindowContext::to_front() {\n+    gdk_window_raise(gdk_window);\n+}\n+\n+void WindowContext::to_back() {\n+    gdk_window_lower(gdk_window);\n+}\n+\n+void WindowContext::request_focus() {\n+    if (is_visible()) {\n+        gtk_window_present(GTK_WINDOW(gtk_widget));\n+    }\n+}\n+\n+void WindowContext::notify_on_top(bool top) {\n+    \/\/ Do not report effective (i.e. native) values to the FX, only if the user sets it manually\n+    if (top != effective_on_top() && jwindow) {\n+        if (on_top_inherited() && !top) {\n+            \/\/ Disallow user's \"on top\" handling on windows that inherited the property\n+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n+        } else {\n+            on_top = top;\n+            update_ontop_tree(top);\n+            mainEnv->CallVoidMethod(jwindow,\n+                    jWindowNotifyLevelChanged,\n+                    top ? com_sun_glass_ui_Window_Level_FLOATING :  com_sun_glass_ui_Window_Level_NORMAL);\n+            CHECK_JNI_EXCEPTION(mainEnv);\n+        }\n@@ -1187,1 +1088,1 @@\n-void WindowContextTop::enter_fullscreen() {\n+void WindowContext::enter_fullscreen() {\n@@ -1192,1 +1093,1 @@\n-void WindowContextTop::exit_fullscreen() {\n+void WindowContext::exit_fullscreen() {\n@@ -1196,3 +1097,10 @@\n-void WindowContextTop::request_focus() {\n-    if (is_visible()) {\n-        gtk_window_present(GTK_WINDOW(gtk_widget));\n+\n+\/\/ Applied to a temporary full screen window to prevent sending events to Java\n+void WindowContext::detach_from_java() {\n+    if (jview) {\n+        mainEnv->DeleteGlobalRef(jview);\n+        jview = NULL;\n+    }\n+    if (jwindow) {\n+        mainEnv->DeleteGlobalRef(jwindow);\n+        jwindow = NULL;\n@@ -1202,2 +1110,2 @@\n-void WindowContextTop::set_focusable(bool focusable) {\n-    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);\n+void WindowContext::increment_events_counter() {\n+    ++events_processing_cnt;\n@@ -1206,2 +1114,2 @@\n-void WindowContextTop::set_title(const char* title) {\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);\n+void WindowContext::decrement_events_counter() {\n+    --events_processing_cnt;\n@@ -1210,2 +1118,2 @@\n-void WindowContextTop::set_alpha(double alpha) {\n-    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);\n+size_t WindowContext::get_events_count() {\n+    return events_processing_cnt;\n@@ -1214,3 +1122,2 @@\n-void WindowContextTop::set_enabled(bool enabled) {\n-    is_disabled = !enabled;\n-    update_window_constraints();\n+bool WindowContext::is_dead() {\n+    return can_be_deleted;\n@@ -1219,4 +1126,6 @@\n-void WindowContextTop::set_minimum_size(int w, int h) {\n-    resizable.minw = (w <= 0) ? 1 : w;\n-    resizable.minh = (h <= 0) ? 1 : h;\n-    update_window_constraints();\n+void WindowContext::applyShapeMask(void* data, uint width, uint height) {\n+    if (frame_type != TRANSPARENT) {\n+        return;\n+    }\n+\n+    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);\n@@ -1225,4 +1134,18 @@\n-void WindowContextTop::set_maximum_size(int w, int h) {\n-    resizable.maxw = w;\n-    resizable.maxh = h;\n-    update_window_constraints();\n+void WindowContext::request_frame_extents() {\n+    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n+    static Atom rfeAtom = XInternAtom(display, \"_NET_REQUEST_FRAME_EXTENTS\", False);\n+\n+    if (rfeAtom != None) {\n+        XClientMessageEvent clientMessage;\n+        memset(&clientMessage, 0, sizeof(clientMessage));\n+\n+        clientMessage.type = ClientMessage;\n+        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n+        clientMessage.message_type = rfeAtom;\n+        clientMessage.format = 32;\n+\n+        XSendEvent(display, XDefaultRootWindow(display), False,\n+                   SubstructureRedirectMask | SubstructureNotifyMask,\n+                   (XEvent *) &clientMessage);\n+        XFlush(display);\n+    }\n@@ -1231,2 +1154,40 @@\n-void WindowContextTop::set_icon(GdkPixbuf* pixbuf) {\n-    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);\n+void WindowContext::update_frame_extents() {\n+    int top, left, bottom, right;\n+\n+    if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n+        if (top > 0 || right > 0 || bottom > 0 || left > 0) {\n+            bool changed = geometry.extents.top != top\n+                            || geometry.extents.left != left\n+                            || geometry.extents.bottom != bottom\n+                            || geometry.extents.right != right;\n+\n+            if (changed) {\n+                geometry.extents.top = top;\n+                geometry.extents.left = left;\n+                geometry.extents.bottom = bottom;\n+                geometry.extents.right = right;\n+\n+                set_cached_extents(geometry.extents);\n+\n+                \/\/ set bounds again to correct window size\n+                \/\/ accounting decorations\n+                int w = geometry_get_window_width(&geometry);\n+                int h = geometry_get_window_height(&geometry);\n+                int cw = geometry_get_content_width(&geometry);\n+                int ch = geometry_get_content_height(&geometry);\n+\n+                int x = geometry.x;\n+                int y = geometry.y;\n+\n+                if (geometry.gravity_x != 0) {\n+                    x -= geometry.gravity_x * (float) (left + right);\n+                }\n+\n+                if (geometry.gravity_y != 0) {\n+                    y -= geometry.gravity_y * (float) (top + bottom);\n+                }\n+\n+                set_bounds(x, y, true, true, w, h, cw, ch, 0, 0);\n+           }\n+        }\n+    }\n@@ -1235,2 +1196,6 @@\n-void WindowContextTop::to_front() {\n-    gdk_window_raise(gdk_window);\n+void WindowContext::set_cached_extents(WindowFrameExtents ex) {\n+    if (window_type == NORMAL) {\n+        normal_extents = ex;\n+    } else {\n+        utility_extents = ex;\n+    }\n@@ -1239,2 +1204,2 @@\n-void WindowContextTop::to_back() {\n-    gdk_window_lower(gdk_window);\n+WindowFrameExtents WindowContext::get_cached_extents() {\n+    return window_type == NORMAL ? normal_extents : utility_extents;\n@@ -1243,6 +1208,21 @@\n-void WindowContextTop::set_modal(bool modal, WindowContext* parent) {\n-    if (modal) {\n-        \/\/gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);\n-        if (parent) {\n-            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());\n-        }\n+bool WindowContext::get_frame_extents_property(int *top, int *left,\n+        int *bottom, int *right) {\n+    unsigned long *extents;\n+\n+    if (gdk_property_get(gdk_window,\n+            get_net_frame_extents_atom(),\n+            gdk_atom_intern(\"CARDINAL\", FALSE),\n+            0,\n+            sizeof (unsigned long) * 4,\n+            FALSE,\n+            NULL,\n+            NULL,\n+            NULL,\n+            (guchar**) & extents)) {\n+        *left = extents [0];\n+        *right = extents [1];\n+        *top = extents [2];\n+        *bottom = extents [3];\n+\n+        g_free(extents);\n+        return true;\n@@ -1250,2 +1230,0 @@\n-    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);\n-}\n@@ -1253,2 +1231,1 @@\n-GtkWindow *WindowContextTop::get_gtk_window() {\n-    return GTK_WINDOW(gtk_widget);\n+    return false;\n@@ -1257,2 +1234,29 @@\n-WindowFrameExtents WindowContextTop::get_frame_extents() {\n-    return geometry.extents;\n+void WindowContext::update_window_constraints() {\n+    GdkGeometry hints;\n+\n+    if (resizable.value && !is_disabled) {\n+        int min_w = (resizable.minw == -1) ? 1\n+                      : resizable.minw - geometry.extents.left - geometry.extents.right;\n+        int min_h =  (resizable.minh == -1) ? 1\n+                      : resizable.minh - geometry.extents.top - geometry.extents.bottom;\n+\n+        hints.min_width = (min_w < 1) ? 1 : min_w;\n+        hints.min_height = (min_h < 1) ? 1 : min_h;\n+\n+        hints.max_width = (resizable.maxw == -1) ? G_MAXINT\n+                            : resizable.maxw - geometry.extents.left - geometry.extents.right;\n+\n+        hints.max_height = (resizable.maxh == -1) ? G_MAXINT\n+                           : resizable.maxh - geometry.extents.top - geometry.extents.bottom;\n+    } else {\n+        int w = geometry_get_content_width(&geometry);\n+        int h = geometry_get_content_height(&geometry);\n+\n+        hints.min_width = w;\n+        hints.min_height = h;\n+        hints.max_width = w;\n+        hints.max_height = h;\n+    }\n+\n+    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &hints,\n+                                  (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n@@ -1261,1 +1265,1 @@\n-void WindowContextTop::update_ontop_tree(bool on_top) {\n+void WindowContext::update_ontop_tree(bool on_top) {\n@@ -1264,1 +1268,1 @@\n-    for (std::set<WindowContextTop*>::iterator it = children.begin(); it != children.end(); ++it) {\n+    for (std::set<WindowContext*>::iterator it = children.begin(); it != children.end(); ++it) {\n@@ -1269,1 +1273,1 @@\n-bool WindowContextTop::on_top_inherited() {\n+bool WindowContext::on_top_inherited() {\n@@ -1272,1 +1276,1 @@\n-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(o);\n+        WindowContext* topO = dynamic_cast<WindowContext*>(o);\n@@ -1282,1 +1286,1 @@\n-bool WindowContextTop::effective_on_top() {\n+bool WindowContext::effective_on_top() {\n@@ -1284,1 +1288,1 @@\n-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(owner);\n+        WindowContext* topO = dynamic_cast<WindowContext*>(owner);\n@@ -1290,25 +1294,5 @@\n-void WindowContextTop::notify_on_top(bool top) {\n-    \/\/ Do not report effective (i.e. native) values to the FX, only if the user sets it manually\n-    if (top != effective_on_top() && jwindow) {\n-        if (on_top_inherited() && !top) {\n-            \/\/ Disallow user's \"on top\" handling on windows that inherited the property\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n-        } else {\n-            on_top = top;\n-            update_ontop_tree(top);\n-            mainEnv->CallVoidMethod(jwindow,\n-                    jWindowNotifyLevelChanged,\n-                    top ? com_sun_glass_ui_Window_Level_FLOATING :  com_sun_glass_ui_Window_Level_NORMAL);\n-            CHECK_JNI_EXCEPTION(mainEnv);\n-        }\n-    }\n-}\n-\n-void WindowContextTop::set_level(int level) {\n-    if (level == com_sun_glass_ui_Window_Level_NORMAL) {\n-        on_top = false;\n-    } else if (level == com_sun_glass_ui_Window_Level_FLOATING\n-            || level == com_sun_glass_ui_Window_Level_TOPMOST) {\n-        on_top = true;\n-    }\n-    \/\/ We need to emulate always on top behaviour on child windows\n+void WindowContext::notify_window_move() {\n+    if (jwindow) {\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove,\n+                                 geometry.x, geometry.y);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -1316,2 +1300,5 @@\n-    if (!on_top_inherited()) {\n-        update_ontop_tree(on_top);\n+        if (jview) {\n+            mainEnv->CallVoidMethod(jview, jViewNotifyView,\n+                    com_sun_glass_events_ViewEvent_MOVE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n@@ -1321,5 +1308,1 @@\n-void WindowContextTop::set_owner(WindowContext * owner_ctx) {\n-    owner = owner_ctx;\n-}\n-\n-void WindowContextTop::notify_window_resize() {\n+void WindowContext::notify_window_resize() {\n@@ -1342,5 +1325,3 @@\n-void WindowContextTop::notify_window_move() {\n-    if (jwindow) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove,\n-                                 geometry.x, geometry.y);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n+void destroy_and_delete_ctx(WindowContext* ctx) {\n+    if (ctx) {\n+        ctx->process_destroy();\n@@ -1348,4 +1329,2 @@\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyView,\n-                    com_sun_glass_events_ViewEvent_MOVE);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n+        if (!ctx->get_events_count()) {\n+            delete ctx;\n@@ -1353,0 +1332,2 @@\n+        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n+        \/\/ an event processing\n@@ -1356,3 +1337,8 @@\n-void WindowContextTop::process_destroy() {\n-    if (owner) {\n-        owner->remove_child(this);\n+WindowContext::~WindowContext() {\n+    if (xim.ic) {\n+        XDestroyIC(xim.ic);\n+        xim.ic = NULL;\n+    }\n+    if (xim.im) {\n+        XCloseIM(xim.im);\n+        xim.im = NULL;\n@@ -1361,1 +1347,1 @@\n-    WindowContextBase::process_destroy();\n+    gtk_widget_destroy(gtk_widget);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":754,"deletions":768,"binary":false,"changes":1522,"status":"modified"},{"patch":"@@ -93,2 +93,0 @@\n-class WindowContextTop;\n-\n@@ -96,71 +94,0 @@\n-public:\n-    virtual bool isEnabled() = 0;\n-    virtual bool hasIME() = 0;\n-    virtual bool filterIME(GdkEvent *) = 0;\n-    virtual void enableOrResetIME() = 0;\n-    virtual void disableIME() = 0;\n-    virtual void paint(void* data, jint width, jint height) = 0;\n-    virtual WindowFrameExtents get_frame_extents() = 0;\n-\n-    virtual void enter_fullscreen() = 0;\n-    virtual void exit_fullscreen() = 0;\n-    virtual void show_or_hide_children(bool) = 0;\n-    virtual void set_visible(bool) = 0;\n-    virtual bool is_visible() = 0;\n-    virtual void set_bounds(int, int, bool, bool, int, int, int, int, float, float) = 0;\n-    virtual void set_resizable(bool) = 0;\n-    virtual void request_focus() = 0;\n-    virtual void set_focusable(bool)= 0;\n-    virtual bool grab_focus() = 0;\n-    virtual bool grab_mouse_drag_focus() = 0;\n-    virtual void ungrab_focus() = 0;\n-    virtual void ungrab_mouse_drag_focus() = 0;\n-    virtual void set_title(const char*) = 0;\n-    virtual void set_alpha(double) = 0;\n-    virtual void set_enabled(bool) = 0;\n-    virtual void set_minimum_size(int, int) = 0;\n-    virtual void set_maximum_size(int, int) = 0;\n-    virtual void set_minimized(bool) = 0;\n-    virtual void set_maximized(bool) = 0;\n-    virtual void set_icon(GdkPixbuf*) = 0;\n-    virtual void to_front() = 0;\n-    virtual void to_back() = 0;\n-    virtual void set_cursor(GdkCursor*) = 0;\n-    virtual void set_modal(bool, WindowContext* parent = NULL) = 0;\n-    virtual void set_level(int) = 0;\n-    virtual void set_background(float, float, float) = 0;\n-\n-    virtual void process_property_notify(GdkEventProperty*) = 0;\n-    virtual void process_configure(GdkEventConfigure*) = 0;\n-    virtual void process_focus(GdkEventFocus*) = 0;\n-    virtual void process_destroy() = 0;\n-    virtual void process_delete() = 0;\n-    virtual void process_expose(GdkEventExpose*) = 0;\n-    virtual void process_mouse_button(GdkEventButton*) = 0;\n-    virtual void process_mouse_motion(GdkEventMotion*) = 0;\n-    virtual void process_mouse_scroll(GdkEventScroll*) = 0;\n-    virtual void process_mouse_cross(GdkEventCrossing*) = 0;\n-    virtual void process_key(GdkEventKey*) = 0;\n-    virtual void process_state(GdkEventWindowState*) = 0;\n-\n-    virtual void notify_state(jint) = 0;\n-    virtual void notify_on_top(bool) {}\n-\n-    virtual void add_child(WindowContextTop* child) = 0;\n-    virtual void remove_child(WindowContextTop* child) = 0;\n-    virtual bool set_view(jobject) = 0;\n-\n-    virtual GdkWindow *get_gdk_window() = 0;\n-    virtual GtkWindow *get_gtk_window() = 0;\n-    virtual jobject get_jview() = 0;\n-    virtual jobject get_jwindow() = 0;\n-\n-    virtual void increment_events_counter() = 0;\n-    virtual void decrement_events_counter() = 0;\n-    virtual size_t get_events_count() = 0;\n-    virtual bool is_dead() = 0;\n-    virtual ~WindowContext() {}\n-};\n-\n-class WindowContextBase: public WindowContext {\n-\n@@ -175,7 +102,0 @@\n-protected:\n-    std::set<WindowContextTop*> children;\n-    jobject jwindow;\n-    jobject jview;\n-    GtkWidget* gtk_widget;\n-    GdkWindow* gdk_window;\n-    GdkWMFunction gdk_windowManagerFunctions;\n@@ -183,0 +103,15 @@\n+    jlong screen;\n+    WindowFrameType frame_type;\n+    WindowType window_type;\n+    struct WindowContext *owner;\n+    WindowGeometry geometry;\n+    struct _Resizable {\/\/ we can't use set\/get gtk_window_resizable function\n+        _Resizable(): value(true),\n+                minw(-1), minh(-1), maxw(-1), maxh(-1) {}\n+        bool value; \/\/actual value of resizable for a window\n+        int minw, minh, maxw, maxh; \/\/minimum and maximum window width\/height;\n+    } resizable;\n+\n+    bool map_received;\n+    bool on_top;\n+    bool is_fullscreen;\n@@ -188,0 +123,12 @@\n+    static WindowFrameExtents normal_extents;\n+    static WindowFrameExtents utility_extents;\n+\n+    WindowManager wmanager;\n+    std::set<WindowContext*> children;\n+    jobject jwindow;\n+    jobject jview;\n+\n+    GtkWidget* gtk_widget;\n+    GdkWindow* gdk_window;\n+    GdkWMFunction gdk_windowManagerFunctions;\n+\n@@ -206,0 +153,1 @@\n+\n@@ -207,1 +155,2 @@\n-    bool isEnabled();\n+    WindowContext(jobject, WindowContext*, long, WindowFrameType, WindowType, GdkWMFunction);\n+\n@@ -212,1 +161,0 @@\n-    void paint(void*, jint, jint);\n@@ -216,0 +164,3 @@\n+    bool isEnabled();\n+    WindowFrameExtents get_frame_extents();\n+    GtkWindow *get_gtk_window();\n@@ -217,2 +168,3 @@\n-    void add_child(WindowContextTop*);\n-    void remove_child(WindowContextTop*);\n+    void paint(void*, jint, jint);\n+    void add_child(WindowContext*);\n+    void remove_child(WindowContext*);\n@@ -220,1 +172,0 @@\n-    void set_visible(bool);\n@@ -227,3 +178,0 @@\n-    void set_cursor(GdkCursor*);\n-    void set_level(int) {}\n-    void set_background(float, float, float);\n@@ -241,38 +189,0 @@\n-\n-    void notify_state(jint);\n-\n-    void increment_events_counter();\n-    void decrement_events_counter();\n-    size_t get_events_count();\n-    bool is_dead();\n-\n-    ~WindowContextBase();\n-protected:\n-    virtual void applyShapeMask(void*, uint width, uint height) = 0;\n-private:\n-    bool im_filter_keypress(GdkEventKey*);\n-};\n-\n-class WindowContextTop: public WindowContextBase {\n-    jlong screen;\n-    WindowFrameType frame_type;\n-    WindowType window_type;\n-    struct WindowContext *owner;\n-    WindowGeometry geometry;\n-    struct _Resizable {\/\/ we can't use set\/get gtk_window_resizable function\n-        _Resizable(): value(true),\n-                minw(-1), minh(-1), maxw(-1), maxh(-1) {}\n-        bool value; \/\/actual value of resizable for a window\n-        int minw, minh, maxw, maxh; \/\/minimum and maximum window width\/height;\n-    } resizable;\n-\n-    bool map_received;\n-    bool on_top;\n-    bool is_fullscreen;\n-\n-    static WindowFrameExtents normal_extents;\n-    static WindowFrameExtents utility_extents;\n-\n-    WindowManager wmanager;\n-public:\n-    WindowContextTop(jobject, WindowContext*, long, WindowFrameType, WindowType, GdkWMFunction);\n@@ -280,1 +190,0 @@\n-    void process_state(GdkEventWindowState*);\n@@ -282,2 +191,0 @@\n-    void process_destroy();\n-    void work_around_compiz_state();\n@@ -285,1 +192,2 @@\n-    WindowFrameExtents get_frame_extents();\n+    void notify_state(jint);\n+    void work_around_compiz_state();\n@@ -287,0 +195,2 @@\n+    void set_cursor(GdkCursor*);\n+    void set_background(float, float, float);\n@@ -291,1 +201,0 @@\n-    void request_focus();\n@@ -299,2 +208,0 @@\n-    void to_front();\n-    void to_back();\n@@ -304,0 +211,5 @@\n+    void set_owner(WindowContext*);\n+    void to_front();\n+    void to_back();\n+    void request_focus();\n+\n@@ -309,3 +221,0 @@\n-    void set_owner(WindowContext*);\n-\n-    GtkWindow *get_gtk_window();\n@@ -313,0 +222,6 @@\n+    void increment_events_counter();\n+    void decrement_events_counter();\n+    size_t get_events_count();\n+    bool is_dead();\n+\n+    ~WindowContext();\n@@ -316,0 +231,1 @@\n+    bool im_filter_keypress(GdkEventKey*);\n@@ -327,2 +243,2 @@\n-    WindowContextTop(WindowContextTop&);\n-    WindowContextTop& operator= (const WindowContextTop&);\n+    WindowContext(WindowContext&);\n+    WindowContext& operator= (const WindowContext&);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":54,"deletions":138,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-bool WindowContextBase::hasIME() {\n+bool WindowContext::hasIME() {\n@@ -54,1 +54,1 @@\n-bool WindowContextBase::im_filter_keypress(GdkEventKey* event) {\n+bool WindowContext::im_filter_keypress(GdkEventKey* event) {\n@@ -110,1 +110,1 @@\n-bool WindowContextBase::filterIME(GdkEvent * event) {\n+bool WindowContext::filterIME(GdkEvent * event) {\n@@ -223,1 +223,1 @@\n-void WindowContextBase::enableOrResetIME() {\n+void WindowContext::enableOrResetIME() {\n@@ -271,1 +271,1 @@\n-void WindowContextBase::disableIME() {\n+void WindowContext::disableIME() {\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window_ime.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}