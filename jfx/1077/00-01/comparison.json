{"files":[{"patch":"@@ -356,2 +356,2 @@\n-                \/\/ Note: We have to determine the pref width here because the add operation above may trigger the skin\n-                \/\/ creation first, which is what makes it possible to get a correct value here in the first place.\n+                \/\/ Note: prefWidth() has to be called only after the tableCell is added to the tableRow, if it wasn't\n+                \/\/ already. Otherwise, it might not have its skin yet, and its pref width is therefore 0.\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkinBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import javafx.scene.control.TableCell;\n@@ -42,1 +43,0 @@\n-import javafx.scene.layout.Region;\n@@ -251,1 +251,2 @@\n-     * When we make an invisible column visible we expect the underlying cells to be visible, e.g. as width > 0.\n+     * When we set a fixed cell size and make an invisible column visible we expect the underlying cells to be visible,\n+     * e.g. width > 0.\n@@ -267,3 +268,5 @@\n-        for (Node cellNode : row.getChildrenUnmodifiable()) {\n-            double width = ((Region) cellNode).getWidth();\n-            assertNotEquals(0.0, width);\n+        for (Node node : row.getChildrenUnmodifiable()) {\n+            if (node instanceof TableCell<?, ?> cell) {\n+                double width = cell.getWidth();\n+                assertNotEquals(0.0, width);\n+            }\n@@ -277,0 +280,1 @@\n+        assertTrue(firstColumn.isVisible());\n@@ -285,3 +289,5 @@\n-        for (Node cellNode : row.getChildrenUnmodifiable()) {\n-            double width = ((Region) cellNode).getWidth();\n-            assertNotEquals(0.0, width);\n+        for (Node node : row.getChildrenUnmodifiable()) {\n+            if (node instanceof TableCell<?, ?> cell) {\n+                double width = cell.getWidth();\n+                assertNotEquals(0.0, width);\n+            }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TableRowSkinTest.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javafx.scene.Node;\n@@ -33,2 +34,0 @@\n-import javafx.collections.FXCollections;\n-import javafx.collections.ObservableList;\n@@ -36,2 +35,0 @@\n-import javafx.scene.control.TableRow;\n-import javafx.scene.control.TableView;\n@@ -39,0 +36,1 @@\n+import javafx.scene.control.TreeTableCell;\n@@ -53,0 +51,1 @@\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n@@ -255,0 +254,47 @@\n+    \/**\n+     * When we set a fixed cell size and make an invisible column visible we expect the underlying cells to be visible,\n+     * e.g. width > 0.\n+     * See also: JDK-8305248\n+     *\/\n+    @Test\n+    public void testMakeInvisibleColumnVisible() {\n+        treeTableView.setFixedCellSize(24);\n+        TreeTableColumn<Person, ?> firstColumn = treeTableView.getColumns().get(0);\n+        firstColumn.setVisible(false);\n+\n+        treeTableView.refresh();\n+        Toolkit.getToolkit().firePulse();\n+\n+        firstColumn.setVisible(true);\n+        Toolkit.getToolkit().firePulse();\n+\n+        IndexedCell<?> row = VirtualFlowTestUtils.getCell(treeTableView, 0);\n+        for (Node node : row.getChildrenUnmodifiable()) {\n+            if (node instanceof TreeTableCell<?, ?> cell) {\n+                double width = cell.getWidth();\n+                assertNotEquals(0.0, width);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMakeVisibleColumnInvisible() {\n+        treeTableView.setFixedCellSize(24);\n+        TreeTableColumn<Person, ?> firstColumn = treeTableView.getColumns().get(0);\n+        assertTrue(firstColumn.isVisible());\n+\n+        treeTableView.refresh();\n+        Toolkit.getToolkit().firePulse();\n+\n+        firstColumn.setVisible(false);\n+        Toolkit.getToolkit().firePulse();\n+\n+        IndexedCell<?> row = VirtualFlowTestUtils.getCell(treeTableView, 0);\n+        for (Node cellNode : row.getChildrenUnmodifiable()) {\n+            if (cellNode instanceof TreeTableCell<?, ?> cell) {\n+                double width = cell.getWidth();\n+                assertNotEquals(0.0, width);\n+            }\n+        }\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TreeTableRowSkinTest.java","additions":51,"deletions":5,"binary":false,"changes":56,"status":"modified"}]}