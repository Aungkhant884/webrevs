{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -352,2 +352,0 @@\n-            width = tableCell.prefWidth(height);\n-\n@@ -358,0 +356,3 @@\n+                \/\/ Note: prefWidth() has to be called only after the tableCell is added to the tableRow, if it wasn't\n+                \/\/ already. Otherwise, it might not have its skin yet, and its pref width is therefore 0.\n+                width = tableCell.prefWidth(height);\n@@ -429,0 +430,1 @@\n+                width = tableCell.prefWidth(height);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkinBase.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javafx.scene.Node;\n@@ -34,0 +35,1 @@\n+import javafx.scene.control.TableCell;\n@@ -49,0 +51,1 @@\n+import static org.junit.Assert.assertNotEquals;\n@@ -247,0 +250,47 @@\n+    \/**\n+     * When we set a fixed cell size and make an invisible column visible we expect the underlying cells to be visible,\n+     * e.g. width > 0.\n+     * See also: JDK-8305248\n+     *\/\n+    @Test\n+    public void testMakeInvisibleColumnVisible() {\n+        tableView.setFixedCellSize(24);\n+        TableColumn<Person, ?> firstColumn = tableView.getColumns().get(0);\n+        firstColumn.setVisible(false);\n+\n+        tableView.refresh();\n+        Toolkit.getToolkit().firePulse();\n+\n+        firstColumn.setVisible(true);\n+        Toolkit.getToolkit().firePulse();\n+\n+        IndexedCell<?> row = VirtualFlowTestUtils.getCell(tableView, 0);\n+        for (Node node : row.getChildrenUnmodifiable()) {\n+            if (node instanceof TableCell<?, ?> cell) {\n+                double width = cell.getWidth();\n+                assertNotEquals(0.0, width);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMakeVisibleColumnInvisible() {\n+        tableView.setFixedCellSize(24);\n+        TableColumn<Person, ?> firstColumn = tableView.getColumns().get(0);\n+        assertTrue(firstColumn.isVisible());\n+\n+        tableView.refresh();\n+        Toolkit.getToolkit().firePulse();\n+\n+        firstColumn.setVisible(false);\n+        Toolkit.getToolkit().firePulse();\n+\n+        IndexedCell<?> row = VirtualFlowTestUtils.getCell(tableView, 0);\n+        for (Node node : row.getChildrenUnmodifiable()) {\n+            if (node instanceof TableCell<?, ?> cell) {\n+                double width = cell.getWidth();\n+                assertNotEquals(0.0, width);\n+            }\n+        }\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TableRowSkinTest.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javafx.scene.Node;\n@@ -33,2 +34,0 @@\n-import javafx.collections.FXCollections;\n-import javafx.collections.ObservableList;\n@@ -36,2 +35,0 @@\n-import javafx.scene.control.TableRow;\n-import javafx.scene.control.TableView;\n@@ -39,0 +36,1 @@\n+import javafx.scene.control.TreeTableCell;\n@@ -53,0 +51,1 @@\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n@@ -255,0 +254,47 @@\n+    \/**\n+     * When we set a fixed cell size and make an invisible column visible we expect the underlying cells to be visible,\n+     * e.g. width > 0.\n+     * See also: JDK-8305248\n+     *\/\n+    @Test\n+    public void testMakeInvisibleColumnVisible() {\n+        treeTableView.setFixedCellSize(24);\n+        TreeTableColumn<Person, ?> firstColumn = treeTableView.getColumns().get(0);\n+        firstColumn.setVisible(false);\n+\n+        treeTableView.refresh();\n+        Toolkit.getToolkit().firePulse();\n+\n+        firstColumn.setVisible(true);\n+        Toolkit.getToolkit().firePulse();\n+\n+        IndexedCell<?> row = VirtualFlowTestUtils.getCell(treeTableView, 0);\n+        for (Node node : row.getChildrenUnmodifiable()) {\n+            if (node instanceof TreeTableCell<?, ?> cell) {\n+                double width = cell.getWidth();\n+                assertNotEquals(0.0, width);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMakeVisibleColumnInvisible() {\n+        treeTableView.setFixedCellSize(24);\n+        TreeTableColumn<Person, ?> firstColumn = treeTableView.getColumns().get(0);\n+        assertTrue(firstColumn.isVisible());\n+\n+        treeTableView.refresh();\n+        Toolkit.getToolkit().firePulse();\n+\n+        firstColumn.setVisible(false);\n+        Toolkit.getToolkit().firePulse();\n+\n+        IndexedCell<?> row = VirtualFlowTestUtils.getCell(treeTableView, 0);\n+        for (Node cellNode : row.getChildrenUnmodifiable()) {\n+            if (cellNode instanceof TreeTableCell<?, ?> cell) {\n+                double width = cell.getWidth();\n+                assertNotEquals(0.0, width);\n+            }\n+        }\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TreeTableRowSkinTest.java","additions":51,"deletions":5,"binary":false,"changes":56,"status":"modified"}]}