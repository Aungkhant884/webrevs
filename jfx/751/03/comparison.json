{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,0 +171,5 @@\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty() || backingList.isEmpty()) {\n+            return false;\n+        }\n+\n@@ -190,0 +195,10 @@\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty() && !backingList.isEmpty()) {\n+            clear();\n+            return true;\n+        }\n+\n+        if (backingList.isEmpty()) {\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableListWrapper.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,0 +324,10 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty() && !backingMap.isEmpty()) {\n+                clear();\n+                return true;\n+            }\n+\n+            if (backingMap.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -344,0 +354,5 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty() || backingMap.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -453,0 +468,5 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty() || backingMap.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -473,0 +493,10 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty() && !backingMap.isEmpty()) {\n+                clear();\n+                return true;\n+            }\n+\n+            if (backingMap.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -649,0 +679,10 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty() && !backingMap.isEmpty()) {\n+                clear();\n+                return true;\n+            }\n+\n+            if (backingMap.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -669,0 +709,5 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty() || backingMap.isEmpty()) {\n+                return false;\n+            }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableMapWrapper.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-public final class ObservableSequentialListWrapper<E> extends ModifiableObservableListBase<E> implements SortableList<E>{\n+public class ObservableSequentialListWrapper<E> extends ModifiableObservableListBase<E> implements SortableList<E>{\n@@ -178,0 +178,9 @@\n+        if (index < 0 || index > size()) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index);\n+        }\n+\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty()) {\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableSequentialListWrapper.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -334,0 +334,10 @@\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty() && !backingSet.isEmpty()) {\n+            clear();\n+            return true;\n+        }\n+\n+        if (backingSet.isEmpty()) {\n+            return false;\n+        }\n+\n@@ -347,0 +357,5 @@\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty() || backingSet.isEmpty()) {\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableSetWrapper.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,5 @@\n-        if (isEmpty() && col.isEmpty()) return false;\n+        \/\/ implicit check to ensure col != null\n+        if (col.isEmpty() && isEmpty()) {\n+            return false;\n+        }\n+\n@@ -104,0 +108,5 @@\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty()) {\n+            return false;\n+        }\n+\n@@ -106,2 +115,1 @@\n-            boolean res = super.addAll(c);\n-            return res;\n+            return super.addAll(c);\n@@ -115,0 +123,9 @@\n+        if (index < 0 || index > size()) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index);\n+        }\n+\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty()) {\n+            return false;\n+        }\n+\n@@ -117,2 +134,1 @@\n-            boolean res = super.addAll(index, c);\n-            return res;\n+            return super.addAll(index, c);\n@@ -126,0 +142,9 @@\n+        if (fromIndex < 0 || fromIndex > size()) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + fromIndex);\n+        }\n+\n+        \/\/ return early if the range is empty\n+        if (fromIndex == toIndex) {\n+            return;\n+        }\n+\n@@ -136,0 +161,5 @@\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty() || isEmpty()) {\n+            return false;\n+        }\n+\n@@ -138,2 +168,1 @@\n-            boolean res = super.removeAll(c);\n-            return res;\n+            return super.removeAll(c);\n@@ -147,0 +176,10 @@\n+        \/\/ implicit check to ensure c != null\n+        if (c.isEmpty() && !isEmpty()) {\n+            clear();\n+            return true;\n+        }\n+\n+        if (isEmpty()) {\n+            return false;\n+        }\n+\n@@ -149,2 +188,1 @@\n-            boolean res = super.retainAll(c);\n-            return res;\n+            return super.retainAll(c);\n@@ -257,1 +295,2 @@\n-    private class SubObservableList implements List<E> {\n+    \/\/ package-private for testing\n+    class SubObservableList implements List<E> {\n@@ -311,0 +350,5 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -313,2 +357,1 @@\n-                boolean res = sublist.addAll(c);\n-                return res;\n+                return sublist.addAll(c);\n@@ -322,0 +365,9 @@\n+            if (index < 0 || index > sublist.size()) {\n+                throw new IndexOutOfBoundsException(\"Index: \" + index);\n+            }\n+\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -324,2 +376,1 @@\n-                boolean res = sublist.addAll(index, c);\n-                return res;\n+                return sublist.addAll(index, c);\n@@ -333,0 +384,5 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty() || sublist.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -335,2 +391,1 @@\n-                boolean res = sublist.removeAll(c);\n-                return res;\n+                return sublist.removeAll(c);\n@@ -344,0 +399,10 @@\n+            \/\/ implicit check to ensure c != null\n+            if (c.isEmpty() && !sublist.isEmpty()) {\n+                sublist.clear();\n+                return true;\n+            }\n+\n+            if (sublist.isEmpty()) {\n+                return false;\n+            }\n+\n@@ -346,2 +411,1 @@\n-                boolean res = sublist.retainAll(c);\n-                return res;\n+                return sublist.retainAll(c);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/ModifiableObservableListBase.java","additions":83,"deletions":19,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.collections;\n+\n+import java.util.List;\n+\n+public abstract class ModifiableObservableListBaseShim<T> extends ModifiableObservableListBase<T> {\n+\n+    @Override\n+    public List<T> subList(int fromIndex, int toIndex) {\n+        return new SubObservableList(getTestSubList(fromIndex, toIndex));\n+    }\n+\n+    protected abstract List<T> getTestSubList(int fromIndex, int toIndex);\n+\n+}\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/collections\/ModifiableObservableListBaseShim.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.collections;\n+\n+import com.sun.javafx.collections.ObservableListWrapper;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ObservableListWrapperTest {\n+\n+    @Nested\n+    class RemoveAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var list = new ObservableListWrapper<>(List.of(\"a\", \"b\", \"c\"));\n+            assertThrows(NullPointerException.class, () -> list.removeAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotEnumerateBackingList() {\n+            var list = new ObservableListWrapper<>(new ArrayList<>(List.of(\"a\", \"b\", \"c\")) {\n+                @Override\n+                public String get(int index) {\n+                    throw new AssertionError(\"get() was not elided\");\n+                }\n+            });\n+\n+            list.removeAll(Collections.<String>emptyList());\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentWorksCorrectly() {\n+            var list = new ObservableListWrapper<>(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+            assertFalse(list.removeAll(List.of()));\n+            assertEquals(List.of(\"a\", \"b\", \"c\"), list);\n+        }\n+    }\n+\n+    @Nested\n+    class RetainAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var list = new ObservableListWrapper<>(List.of(\"a\", \"b\", \"c\"));\n+            assertThrows(NullPointerException.class, () -> list.retainAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotCallContains() {\n+            var list = new ObservableListWrapper<>(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+            list.retainAll(new ArrayList<String>() {\n+                @Override\n+                public boolean contains(Object o) {\n+                    throw new AssertionError(\"contains() was not elided\");\n+                }\n+            });\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentWorksCorrectly() {\n+            var list = new ObservableListWrapper<>(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+            assertTrue(list.retainAll(List.of()));\n+            assertTrue(list.isEmpty());\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ObservableListWrapperTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.collections;\n+\n+import com.sun.javafx.collections.ObservableMapWrapper;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ObservableMapWrapperTest {\n+\n+    @Nested\n+    class RemoveAllTest {\n+        @Test\n+        public void testEntrySetNullArgumentThrowsNPE() {\n+            var map1 = new ObservableMapWrapper<>(new HashMap<>());\n+            assertThrows(NullPointerException.class, () -> map1.entrySet().removeAll((Collection<?>) null));\n+\n+            var map2 = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            assertThrows(NullPointerException.class, () -> map2.entrySet().removeAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testKeySetNullArgumentThrowsNPE() {\n+            var map1 = new ObservableMapWrapper<>(new HashMap<>());\n+            assertThrows(NullPointerException.class, () -> map1.keySet().removeAll((Collection<?>) null));\n+\n+            var map2 = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            assertThrows(NullPointerException.class, () -> map2.keySet().removeAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testValueSetNullArgumentThrowsNPE() {\n+            var map1 = new ObservableMapWrapper<>(new HashMap<>());\n+            assertThrows(NullPointerException.class, () -> map1.values().removeAll((Collection<?>) null));\n+\n+            var map2 = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            assertThrows(NullPointerException.class, () -> map2.values().removeAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testRemoveAllKeysWithEmptyCollectionArgumentDoesNotEnumerateBackingMap() {\n+            ObservableMapWrapper<String, String> map = newNonIterableObservableMapWrapper();\n+            map.keySet().removeAll(Collections.<String>emptySet());\n+        }\n+\n+        @Test\n+        public void testRemoveAllValuesWithEmptyCollectionArgumentDoesNotEnumerateBackingMap() {\n+            ObservableMapWrapper<String, String> map = newNonIterableObservableMapWrapper();\n+            map.values().removeAll(Collections.<String>emptySet());\n+        }\n+\n+        @Test\n+        public void testRemoveAllEntriesWithEmptyCollectionArgumentDoesNotEnumerateBackingMap() {\n+            ObservableMapWrapper<String, String> map = newNonIterableObservableMapWrapper();\n+            map.entrySet().removeAll(Collections.<Map.Entry<String, String>>emptySet());\n+        }\n+\n+        @Test\n+        public void testRemoveAllEntriesWithEmptyCollectionArgumentWorksCorrectly() {\n+            var content = Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\");\n+            var map = new ObservableMapWrapper<>(new HashMap<>(content));\n+            assertFalse(map.entrySet().removeAll(Set.of()));\n+            assertEquals(content, map);\n+        }\n+    }\n+\n+    @Nested\n+    class RetainAllTest {\n+        @Test\n+        public void testEntrySetNullArgumentThrowsNPE() {\n+            var map1 = new ObservableMapWrapper<>(new HashMap<>());\n+            assertThrows(NullPointerException.class, () -> map1.entrySet().retainAll((Collection<?>) null));\n+\n+            var map2 = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            assertThrows(NullPointerException.class, () -> map2.entrySet().retainAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testKeySetNullArgumentThrowsNPE() {\n+            var map1 = new ObservableMapWrapper<>(new HashMap<>());\n+            assertThrows(NullPointerException.class, () -> map1.keySet().retainAll((Collection<?>) null));\n+\n+            var map2 = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            assertThrows(NullPointerException.class, () -> map2.keySet().retainAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testValueSetNullArgumentThrowsNPE() {\n+            var map1 = new ObservableMapWrapper<>(new HashMap<>());\n+            assertThrows(NullPointerException.class, () -> map1.values().retainAll((Collection<?>) null));\n+\n+            var map2 = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            assertThrows(NullPointerException.class, () -> map2.values().retainAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testRetainAllKeysWithEmptyCollectionArgumentDoesNotCallContains() {\n+            var map = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            map.keySet().retainAll(newNoContainsHashSet());\n+        }\n+\n+        @Test\n+        public void testRetainAllValuesWithEmptyCollectionArgumentDoesNotCallContains() {\n+            var map = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            map.values().retainAll(newNoContainsHashSet());\n+        }\n+\n+        @Test\n+        public void testRetainAllEntriesWithEmptyCollectionArgumentDoesNotCallContains() {\n+            var map = new ObservableMapWrapper<>(new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")));\n+            map.entrySet().retainAll(newNoContainsHashSet());\n+        }\n+\n+        @Test\n+        public void testRetainAllWithEmptyCollectionArgumentWorksCorrectly() {\n+            var content = Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\");\n+            var map = new ObservableMapWrapper<>(new HashMap<>(content));\n+            assertTrue(map.entrySet().retainAll(Set.of()));\n+            assertTrue(map.isEmpty());\n+        }\n+    }\n+\n+    private ObservableMapWrapper<String, String> newNonIterableObservableMapWrapper() {\n+        return new ObservableMapWrapper<>(\n+            new HashMap<>(Map.of(\"k0\", \"v0\", \"k1\", \"v1\", \"k2\", \"v2\")) {\n+                Set<Entry<String, String>> entrySet;\n+\n+                @Override\n+                public Set<Entry<String, String>> entrySet() {\n+                    if (entrySet == null) {\n+                        entrySet = new AbstractSet<>() {\n+                            @Override\n+                            public Iterator<Entry<String, String>> iterator() {\n+                                throw new AssertionError(\"iterator() was not elided\");\n+                            }\n+\n+                            @Override\n+                            public int size() {\n+                                throw new UnsupportedOperationException();\n+                            }\n+                        };\n+                    }\n+                    return entrySet;\n+                }\n+            });\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private HashSet newNoContainsHashSet() {\n+        return new HashSet() {\n+            @Override\n+            public boolean contains(Object o) {\n+                throw new AssertionError(\"contains() was not elided\");\n+            }\n+        };\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ObservableMapWrapperTest.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.collections;\n+\n+import com.sun.javafx.collections.ObservableSequentialListWrapper;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ObservableSequentialListWrapperTest {\n+\n+    @Test\n+    public void testAddAllWithEmptyCollectionArgumentDoesNotEnumerateCollection() {\n+        var list = new ObservableSequentialListWrapper<String>(Collections.emptyList()) {\n+            @Override\n+            public Iterator<String> iterator() {\n+                throw new AssertionError(\"iterator() was not elided\");\n+            }\n+\n+            @Override\n+            public ListIterator<String> listIterator() {\n+                throw new AssertionError(\"listIterator() was not elided\");\n+            }\n+        };\n+\n+        assertDoesNotThrow(() -> list.addAll(Collections.emptyList()));\n+        assertDoesNotThrow(() -> list.addAll(0, Collections.emptyList()));\n+    }\n+\n+    @Test\n+    public void testAddAllWithInvalidIndexThrowsIOOBE() {\n+        var nonEmptyList = new ObservableSequentialListWrapper<>(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+        assertThrows(IndexOutOfBoundsException.class, () -> nonEmptyList.addAll(-1, Collections.emptyList()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> nonEmptyList.addAll(4, Collections.emptyList()));\n+        assertDoesNotThrow(() -> nonEmptyList.addAll(3, List.of(\"d\", \"e\")));\n+\n+        var emptyList = new ObservableSequentialListWrapper<>(new ArrayList<>());\n+        assertThrows(IndexOutOfBoundsException.class, () -> emptyList.addAll(-1, Collections.emptyList()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> emptyList.addAll(1, Collections.emptyList()));\n+        assertDoesNotThrow(() -> emptyList.addAll(0, List.of(\"d\", \"e\")));\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ObservableSequentialListWrapperTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.collections;\n+\n+import com.sun.javafx.collections.ObservableSetWrapper;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ObservableSetWrapperTest {\n+\n+    @Nested\n+    class RemoveAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var set = new ObservableSetWrapper<>(Set.of(\"a\", \"b\", \"c\"));\n+            assertThrows(NullPointerException.class, () -> set.removeAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotEnumerateBackingSet() {\n+            ObservableSetWrapper<String> set = new ObservableSetWrapper<>(new HashSet<>(Set.of(\"a\", \"b\", \"c\")) {\n+                @Override\n+                public Iterator<String> iterator() {\n+                    throw new AssertionError(\"iterator() was not elided\");\n+                }\n+            });\n+\n+            set.removeAll(Collections.<String>emptySet());\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentWorksCorrectly() {\n+            var set = new ObservableSetWrapper<>(new HashSet<>(Set.of(\"a\", \"b\", \"c\")));\n+            assertFalse(set.removeAll(Set.of()));\n+            assertEquals(Set.of(\"a\", \"b\", \"c\"), set);\n+        }\n+    }\n+\n+    @Nested\n+    class RetainAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var set = new ObservableSetWrapper<>(Set.of(\"a\", \"b\", \"c\"));\n+            assertThrows(NullPointerException.class, () -> set.retainAll((Collection<?>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotCallContains() {\n+            ObservableSetWrapper<String> set = new ObservableSetWrapper<>(new HashSet<>(Set.of(\"a\", \"b\", \"c\")));\n+            set.removeAll(new HashSet<String>() {\n+                @Override\n+                public boolean contains(Object o) {\n+                    throw new AssertionError(\"contains() was not elided\");\n+                }\n+            });\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentWorksCorrectly() {\n+            var set = new ObservableSetWrapper<>(new HashSet<>(Set.of(\"a\", \"b\", \"c\")));\n+            assertTrue(set.retainAll(Set.of()));\n+            assertTrue(set.isEmpty());\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ObservableSetWrapperTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.collections;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import javafx.collections.ModifiableObservableListBaseShim;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ModifiableObservableListBaseTest {\n+\n+    @Test\n+    public void testRemoveEmptyRangeDoesNotEnumerateList() {\n+        var list = new MockModifiableObservableList(List.of(\"a\", \"b\", \"c\")) {\n+            @Override\n+            public Iterator<String> iterator() {\n+                throw new AssertionError(\"iterator() was not elided\");\n+            }\n+\n+            @Override\n+            public ListIterator<String> listIterator() {\n+                throw new AssertionError(\"listIterator() was not elided\");\n+            }\n+        };\n+\n+        assertDoesNotThrow(() -> list.removeRange(0, 0));\n+    }\n+\n+    @Nested\n+    class SetAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var list = new MockModifiableObservableList(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+            assertThrows(NullPointerException.class, () -> list.setAll((Collection<? extends String>) null));\n+        }\n+    }\n+\n+    @Nested\n+    class AddAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var list = new MockModifiableObservableList(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+            assertThrows(NullPointerException.class, () -> list.addAll((Collection<? extends String>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotEnumerateCollection() {\n+            var list = new MockModifiableObservableList(Collections.emptyList()) {\n+                @Override\n+                public Iterator<String> iterator() {\n+                    throw new AssertionError(\"iterator() was not elided\");\n+                }\n+\n+                @Override\n+                public ListIterator<String> listIterator() {\n+                    throw new AssertionError(\"listIterator() was not elided\");\n+                }\n+            };\n+\n+            assertDoesNotThrow(() -> list.addAll(Collections.emptyList()));\n+            assertDoesNotThrow(() -> list.addAll(0, Collections.emptyList()));\n+        }\n+\n+        @Test\n+        public void testInvalidIndexThrowsIOOBE() {\n+            var nonEmptyList = new MockModifiableObservableList(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+            assertThrows(IndexOutOfBoundsException.class, () -> nonEmptyList.addAll(-1, Collections.emptyList()));\n+            assertThrows(IndexOutOfBoundsException.class, () -> nonEmptyList.addAll(4, Collections.emptyList()));\n+            assertDoesNotThrow(() -> nonEmptyList.addAll(3, List.of(\"d\", \"e\")));\n+\n+            var emptyList = new MockModifiableObservableList(new ArrayList<>());\n+            assertThrows(IndexOutOfBoundsException.class, () -> emptyList.addAll(-1, Collections.emptyList()));\n+            assertThrows(IndexOutOfBoundsException.class, () -> emptyList.addAll(1, Collections.emptyList()));\n+            assertDoesNotThrow(() -> emptyList.addAll(0, List.of(\"d\", \"e\")));\n+        }\n+    }\n+\n+    @Nested\n+    class RemoveAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var list = new MockModifiableObservableList(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+            assertThrows(NullPointerException.class, () -> list.removeAll((Collection<? extends String>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotEnumerateBackingList() {\n+            var list = new MockModifiableObservableList(List.of(\"a\", \"b\", \"c\")) {\n+                @Override\n+                public String get(int index) {\n+                    throw new AssertionError(\"get() was not elided\");\n+                }\n+            };\n+\n+            assertDoesNotThrow(() -> list.removeAll(Collections.<String>emptyList()));\n+        }\n+    }\n+\n+    @Nested\n+    class RetainAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var list = new MockModifiableObservableList(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+            assertThrows(NullPointerException.class, () -> list.retainAll((Collection<? extends String>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotCallContains() {\n+            var list = new MockModifiableObservableList(new ArrayList<>(List.of(\"a\", \"b\", \"c\")));\n+\n+            assertDoesNotThrow(() -> list.retainAll(new ArrayList<String>() {\n+                @Override\n+                public boolean contains(Object o) {\n+                    throw new AssertionError(\"contains() was not elided\");\n+                }\n+            }));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentCallsClear() {\n+            boolean[] flag = new boolean[1];\n+            new MockModifiableObservableList(new ArrayList<>(List.of(\"a\", \"b\", \"c\"))) {\n+                @Override\n+                public void clear() {\n+                    flag[0] = true;\n+                    super.clear();\n+                }\n+            }.retainAll(Collections.<String>emptyList());\n+\n+            assertTrue(flag[0], \"clear() was not called\");\n+        }\n+\n+        @Test\n+        public void testRetainAllOnEmptyListDoesNotCallClear() {\n+            var list = new MockModifiableObservableList(new ArrayList<>()) {\n+                @Override\n+                public void clear() {\n+                    throw new AssertionError(\"clear() was not elided\");\n+                }\n+            };\n+\n+            assertDoesNotThrow(() -> list.retainAll(Collections.<String>emptyList()));\n+        }\n+    }\n+\n+    @Nested\n+    class SubList_AddAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var subList = new MockModifiableObservableList(List.of(\"a\", \"b\", \"c\"), List.of(\"a\", \"b\")).subList(0, 2);\n+            assertThrows(NullPointerException.class, () -> subList.addAll((Collection<? extends String>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotEnumerateCollection() {\n+            var backingSubList = new ArrayList<>(Collections.<String>emptyList()) {\n+                @Override\n+                public Iterator<String> iterator() {\n+                    throw new AssertionError(\"iterator() was not elided\");\n+                }\n+\n+                @Override\n+                public ListIterator<String> listIterator() {\n+                    throw new AssertionError(\"listIterator() was not elided\");\n+                }\n+            };\n+\n+            var subList = new MockModifiableObservableList(Collections.emptyList(), backingSubList).subList(0, 0);\n+            assertDoesNotThrow(() -> subList.addAll(Collections.emptyList()));\n+            assertDoesNotThrow(() -> subList.addAll(0, Collections.emptyList()));\n+        }\n+\n+        @Test\n+        public void testInvalidIndexThrowsIOOBE() {\n+            var nonEmptySubList = new MockModifiableObservableList(\n+                    new ArrayList<>(List.of(\"a\", \"b\", \"c\")),\n+                    new ArrayList<>(List.of(\"a\", \"b\")))\n+                .subList(0, 2);\n+            assertThrows(IndexOutOfBoundsException.class, () -> nonEmptySubList.addAll(-1, Collections.emptyList()));\n+            assertThrows(IndexOutOfBoundsException.class, () -> nonEmptySubList.addAll(3, Collections.emptyList()));\n+            assertDoesNotThrow(() -> nonEmptySubList.addAll(2, List.of(\"d\", \"e\")));\n+\n+            var emptySubList = new MockModifiableObservableList(\n+                    new ArrayList<>(List.of(\"a\", \"b\", \"c\")),\n+                    new ArrayList<>())\n+                .subList(0, 0);\n+            assertThrows(IndexOutOfBoundsException.class, () -> emptySubList.addAll(-1, Collections.emptyList()));\n+            assertThrows(IndexOutOfBoundsException.class, () -> emptySubList.addAll(1, Collections.emptyList()));\n+            assertDoesNotThrow(() -> emptySubList.addAll(0, List.of(\"d\", \"e\")));\n+        }\n+    }\n+\n+    @Nested\n+    class SubList_RemoveAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var subList = new MockModifiableObservableList(List.of(\"a\", \"b\", \"c\"), List.of(\"a\", \"b\")).subList(0, 2);\n+            assertThrows(NullPointerException.class, () -> subList.removeAll((Collection<? extends String>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotCallRemoveAll() {\n+            var backingList = List.of(\"a\", \"b\", \"c\");\n+            var backingSubList = new ArrayList<>(List.of(\"a\", \"b\")) {\n+                @Override\n+                public boolean removeAll(Collection<?> c) {\n+                    throw new AssertionError(\"removeAll() was not elided\");\n+                }\n+            };\n+\n+            var subList = new MockModifiableObservableList(backingList, backingSubList).subList(0, 2);\n+            assertDoesNotThrow(() -> subList.removeAll(Collections.<String>emptyList()));\n+        }\n+    }\n+\n+    @Nested\n+    class SubList_RetainAllTest {\n+        @Test\n+        public void testNullArgumentThrowsNPE() {\n+            var subList = new MockModifiableObservableList(List.of(\"a\", \"b\", \"c\"), List.of(\"a\", \"b\")).subList(0, 2);\n+            assertThrows(NullPointerException.class, () -> subList.retainAll((Collection<? extends String>) null));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentDoesNotCallContains() {\n+            var backingList = List.of(\"a\", \"b\", \"c\");\n+            var backingSubList = new ArrayList<>(List.of(\"a\", \"b\"));\n+            var subList = new MockModifiableObservableList(backingList, backingSubList).subList(0, 2);\n+\n+            assertDoesNotThrow(() -> subList.retainAll(new ArrayList<String>() {\n+                @Override\n+                public boolean contains(Object o) {\n+                    throw new AssertionError(\"contains() was not elided\");\n+                }\n+            }));\n+        }\n+\n+        @Test\n+        public void testEmptyCollectionArgumentCallsClear() {\n+            boolean[] flag = new boolean[1];\n+            var backingList = List.of(\"a\", \"b\", \"c\");\n+            var backingSubList = new ArrayList<>(List.of(\"a\", \"b\")) {\n+                @Override\n+                public void clear() {\n+                    flag[0] = true;\n+                    super.clear();\n+                }\n+            };\n+\n+            var subList = new MockModifiableObservableList(backingList, backingSubList).subList(0, 2);\n+            subList.retainAll(Collections.<String>emptyList());\n+            assertTrue(flag[0], \"clear() was not called\");\n+        }\n+\n+        @Test\n+        public void testRetainAllOnEmptyListDoesNotCallClear() {\n+            var backingList = new ArrayList<String>();\n+            var backingSubList = new ArrayList<String>() {\n+                @Override\n+                public void clear() {\n+                    throw new AssertionError(\"clear() was not elided\");\n+                }\n+            };\n+\n+            var subList = new MockModifiableObservableList(backingList, backingSubList).subList(0, 0);\n+            assertDoesNotThrow(() -> subList.retainAll(Collections.<String>emptyList()));\n+        }\n+    }\n+\n+    private static class MockModifiableObservableList extends ModifiableObservableListBaseShim<String> {\n+        private final List<String> backingList;\n+        private final List<String> subList;\n+\n+        MockModifiableObservableList(List<String> list) {\n+            this.backingList = list;\n+            this.subList = Collections.emptyList();\n+        }\n+\n+        MockModifiableObservableList(List<String> list, List<String> subList) {\n+            this.backingList = list;\n+            this.subList = subList;\n+        }\n+\n+        @Override public String get(int index) { return backingList.get(index); }\n+        @Override public int size() { return backingList.size(); }\n+        @Override protected void doAdd(int index, String element) { backingList.add(index, element); }\n+        @Override protected String doSet(int index, String element) { return backingList.set(index, element); }\n+        @Override protected String doRemove(int index) { return backingList.remove(index); }\n+        @Override public void removeRange(int fromIndex, int toIndex) { super.removeRange(fromIndex, toIndex); }\n+        @Override protected List<String> getTestSubList(int fromIndex, int toIndex) { return subList; }\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/collections\/ModifiableObservableListBaseTest.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"}]}