{"files":[{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package dragdrop;\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.Pos;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.ProgressBar;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.input.ClipboardContent;\n+import javafx.scene.input.Dragboard;\n+import javafx.scene.input.TransferMode;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.Text;\n+import javafx.stage.Stage;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+\n+public class DragDropDuke extends Application {\n+    private Image image;\n+    private ProgressBar progressBar;\n+    private ImageView imageView;\n+    private Label posLabel;\n+\n+    @Override\n+    public void start(Stage stage) {\n+        progressBar = new ProgressBar();\n+        progressBar.prefWidthProperty().bind(stage.widthProperty().multiply(0.80d));\n+\n+        new Thread(this::download).start();\n+\n+        Text text = new Text(\"Instructions:\\n\" +\n+                \"1. Wait for the image download.\\n\" +\n+                \"2. Drag image and notice it's a transparent png.\\n\" +\n+                \"3. Notice Position changes from \\\"Mouse Move\\\" to \\\"Mouse Drag\\\".\\n\" +\n+                \"4. Drag over and drop on the tomato square (should change colors).\\n\" +\n+                \"5. Open another instance of this Window and drag from one\\ninstance to another.\\n\" +\n+                \"6. While dragging image, press ALT+F4 (should stop Drag).\");\n+\n+        imageView = new ImageView(image);\n+        imageView.setFitHeight(200D);\n+        imageView.setPreserveRatio(true);\n+\n+        Pane pane = new Pane();\n+        pane.setPrefSize(200, 200);\n+        pane.setBackground(Background.fill(Color.TOMATO));\n+        HBox hBox = new HBox(imageView, pane);\n+        hBox.setAlignment(Pos.CENTER);\n+\n+        posLabel = new Label();\n+        VBox vBox = new VBox(text, posLabel, progressBar, hBox);\n+        vBox.setSpacing(5.0);\n+        vBox.setAlignment(Pos.CENTER);\n+        stage.setScene(new Scene(vBox, 480, 480));\n+        stage.setTitle(\"Drag & Drop Duke\");\n+\n+        imageView.setOnDragDetected(event -> {\n+            ClipboardContent content = new ClipboardContent();\n+            content.putImage(image);\n+\n+            Dragboard dragboard = imageView.startDragAndDrop(TransferMode.ANY);\n+            dragboard.setContent(content);\n+            dragboard.setDragViewOffsetX(100);\n+            dragboard.setDragViewOffsetY(100);\n+            dragboard.setDragView(image);\n+        });\n+\n+        stage.getScene().setOnMouseMoved(e -> showPos(\"Mouse Move\", e.getSceneX(), e.getSceneY()));\n+        stage.getScene().setOnDragOver(e -> showPos(\"Mouse Drag\", e.getSceneX(), e.getScreenY()));\n+\n+        pane.setOnDragOver(e -> {\n+            e.acceptTransferModes(TransferMode.ANY);\n+            pane.setBackground(Background.fill(Color.CADETBLUE));\n+        });\n+        pane.setOnDragDropped(e -> pane.setBackground(Background.fill(Color.LAWNGREEN)));\n+        stage.show();\n+    }\n+\n+    private void showPos(String prefix, double x, double y) {\n+        posLabel.setText(String.format(\"%s -> x: %f, y: %f\", prefix, x, y));\n+    }\n+\n+    private void download() {\n+        try {\n+            subDownload();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void subDownload() throws IOException {\n+        URL url = new URL(\"http:\/\/cr.openjdk.java.net\/~jeff\/Duke\/png\/Hips.png\");\n+        HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n+        int cl = urlConn.getContentLength();\n+\n+        int total = 0;\n+        int read = 0;\n+        try (InputStream in = urlConn.getInputStream();\n+             ByteArrayOutputStream out = new ByteArrayOutputStream(cl)) {\n+            byte[] buf = new byte[1024];\n+\n+            while ((read = in.read(buf)) > 0) {\n+                out.write(buf, 0, read);\n+                total += read;\n+                double percent = (double) total \/ (double) cl * 100d;\n+\n+                Platform.runLater(() -> progressBar.setProgress(percent \/ 100));\n+            }\n+\n+            Platform.runLater(() -> {\n+                image = new Image(new ByteArrayInputStream(out.toByteArray()));\n+                imageView.setImage(image);\n+            });\n+        }\n+    }\n+\n+    public static String info() {\n+        return \"Drag & Drop Duke\";\n+    }\n+\n+    public static void main(String[] args) {\n+        Application.launch(DragDropDuke.class, args);\n+    }\n+}\n","filename":"apps\/toys\/DragDrop\/src\/dragdrop\/DragDropDuke.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package dragdrop;\n+\n+import javafx.application.Application;\n+import javafx.geometry.Pos;\n+import javafx.scene.Scene;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.image.PixelWriter;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.input.ClipboardContent;\n+import javafx.scene.input.Dragboard;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.input.TransferMode;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.Text;\n+import javafx.stage.Stage;\n+\n+public class DragDropKeys extends Application {\n+    @Override\n+    public void start(Stage stage) {\n+        Text text = new Text(\"Instructions:\\n\" +\n+                             \"1. Press and release any key.\\n\" +\n+                             \"2. Notice key events appearing in text area.\\n\" +\n+                             \"3. While dragging image, press any key.\\n\" +\n+                             \"4. Notice the key events while dragging.\\n\" +\n+                             \"5. Also notice that the image should be RED, GREEN, BLUE.\\n\");\n+        Image image = createImage(180, 180);\n+        ImageView imageView = new ImageView(image);\n+        imageView.setOnDragDetected(event -> {\n+            ClipboardContent content = new ClipboardContent();\n+            content.putImage(image);\n+            Dragboard dragboard = imageView.startDragAndDrop(TransferMode.ANY);\n+            dragboard.setContent(content);\n+            dragboard.setDragView(image);\n+        });\n+        TextArea textArea = new TextArea(\"KeyEvent log:\\n\");\n+        textArea.setEditable(false);\n+\n+        VBox vBox = new VBox(text, imageView, textArea);\n+        vBox.setSpacing(5.0);\n+        vBox.setAlignment(Pos.BOTTOM_CENTER);\n+        stage.setScene(new Scene(vBox, 480, 480));\n+        stage.setTitle(\"KeyEvents During Drag & Drop\");\n+        stage.addEventFilter(KeyEvent.KEY_PRESSED, event ->\n+                textArea.appendText(event.getEventType().getName() + \": \" + event.getCode().getName() + \"\\n\"));\n+        stage.addEventFilter(KeyEvent.KEY_RELEASED, event ->\n+                textArea.appendText(event.getEventType().getName() + \": \" + event.getCode().getName() + \"\\n\"));\n+        stage.show();\n+    }\n+\n+    private static Image createImage(int width, int height) {\n+        WritableImage image = new WritableImage(width, height);\n+        PixelWriter pixelWriter = image.getPixelWriter();\n+        for (int y = 0; y < height; y++) {\n+            for (int x = 0; x < width; x++) {\n+                if (x < width * 0.33) {\n+                    pixelWriter.setColor(x, y, Color.RED);\n+                } else if (x < width * 0.66) {\n+                    pixelWriter.setColor(x, y, Color.GREEN);\n+                } else {\n+                    pixelWriter.setColor(x, y, Color.BLUE);\n+                }\n+            }\n+        }\n+\n+        return image;\n+    }\n+\n+    public static String info() {\n+        return \"Drag and press keys\";\n+    }\n+\n+    public static void main(String[] args) {\n+        Application.launch(DragDropKeys.class, args);\n+    }\n+}\n","filename":"apps\/toys\/DragDrop\/src\/dragdrop\/DragDropKeys.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -68,0 +68,2 @@\n+        register(\"Keys\", DragDropKeys.class, DragDropKeys.info());\n+        register(\"Drag Duke\", DragDropDuke.class, DragDropDuke.info());\n","filename":"apps\/toys\/DragDrop\/src\/dragdrop\/Main.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -421,2 +421,1 @@\n-static void process_events(GdkEvent* event, gpointer data)\n-{\n+static void process_events(GdkEvent* event, gpointer data) {\n@@ -438,0 +437,4 @@\n+    if (!process_dnd_source(event)) {\n+        return;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-static jint translate_gdk_action_to_glass(GdkDragAction action)\n-{\n+static jint translate_gdk_action_to_glass(GdkDragAction action) {\n@@ -49,2 +48,1 @@\n-static GdkDragAction translate_glass_action_to_gdk(jint action)\n-{\n+static GdkDragAction translate_glass_action_to_gdk(jint action) {\n@@ -63,1 +61,0 @@\n-\n@@ -65,1 +62,0 @@\n-\n@@ -91,2 +87,1 @@\n-static gboolean target_is_text(GdkAtom target)\n-{\n+static gboolean target_is_text(GdkAtom target) {\n@@ -101,2 +96,1 @@\n-static gboolean target_is_uri(GdkAtom target)\n-{\n+static gboolean target_is_uri(GdkAtom target) {\n@@ -107,2 +101,1 @@\n-static gboolean target_is_image(GdkAtom target)\n-{\n+static gboolean target_is_image(GdkAtom target) {\n@@ -116,2 +109,1 @@\n-static void clear_global_ref(gpointer data)\n-{\n+static void clear_global_ref(gpointer data) {\n@@ -121,3 +113,0 @@\n-static void dnd_set_performed_action(jint performed_action);\n-static jint dnd_get_performed_action();\n-\n@@ -144,6 +133,0 @@\n-GtkWidget *drag_widget = NULL;\n-\n-gboolean is_in_drag() {\n-    return drag_widget != NULL;\n-}\n-\n@@ -154,1 +137,0 @@\n-\n@@ -158,2 +140,1 @@\n-static void process_dnd_target_drag_enter(WindowContext *ctx, GdkEventDND *event)\n-{\n+static void process_dnd_target_drag_enter(WindowContext *ctx, GdkEventDND *event) {\n@@ -167,2 +148,1 @@\n-static void process_dnd_target_drag_motion(WindowContext *ctx, GdkEventDND *event)\n-{\n+static void process_dnd_target_drag_motion(WindowContext *ctx, GdkEventDND *event) {\n@@ -173,0 +153,1 @@\n+\n@@ -184,0 +165,1 @@\n+\n@@ -187,2 +169,1 @@\n-static void process_dnd_target_drag_leave(WindowContext *ctx, GdkEventDND *event)\n-{\n+static void process_dnd_target_drag_leave(WindowContext *ctx, GdkEventDND *event) {\n@@ -195,2 +176,13 @@\n-static void process_dnd_target_drop_start(WindowContext *ctx, GdkEventDND *event)\n-{\n+static void wait_for_selection_data_hook(GdkEvent * event, void * data) {\n+    selection_data_ctx *ctx = (selection_data_ctx*)data;\n+    GdkWindow *dest = glass_gdk_drag_context_get_dest_window(enter_ctx.ctx);\n+    if (event->type == GDK_SELECTION_NOTIFY &&\n+            event->selection.window == dest) {\n+        if (event->selection.property) { \/\/ if 0, that we received negative response\n+            ctx->length = gdk_selection_property_get(dest, &(ctx->data), &(ctx->type), &(ctx->format));\n+        }\n+        ctx->received = TRUE;\n+    }\n+}\n+\n+static void process_dnd_target_drop_start(WindowContext *ctx, GdkEventDND *event) {\n@@ -202,1 +194,0 @@\n-    GdkDragAction selected = gdk_drag_context_get_selected_action(event->context);\n@@ -204,0 +195,1 @@\n+    GdkDragAction selected = gdk_drag_context_get_selected_action(event->context);\n@@ -214,2 +206,1 @@\n-static gboolean check_state_in_drag(JNIEnv *env)\n-{\n+static gboolean check_state_in_drag(JNIEnv *env) {\n@@ -228,2 +219,1 @@\n-void process_dnd_target(WindowContext *ctx, GdkEventDND *event)\n-{\n+void process_dnd_target(WindowContext *ctx, GdkEventDND *event) {\n@@ -248,2 +238,1 @@\n-jobjectArray dnd_target_get_mimes(JNIEnv *env)\n-{\n+jobjectArray dnd_target_get_mimes(JNIEnv *env) {\n@@ -316,2 +305,1 @@\n-jint dnd_target_get_supported_actions(JNIEnv *env)\n-{\n+jint dnd_target_get_supported_actions(JNIEnv *env) {\n@@ -324,15 +312,1 @@\n-static void wait_for_selection_data_hook(GdkEvent * event, void * data)\n-{\n-    selection_data_ctx *ctx = (selection_data_ctx*)data;\n-    GdkWindow *dest = glass_gdk_drag_context_get_dest_window(enter_ctx.ctx);\n-    if (event->type == GDK_SELECTION_NOTIFY &&\n-            event->selection.window == dest) {\n-        if (event->selection.property) { \/\/ if 0, that we received negative response\n-            ctx->length = gdk_selection_property_get(dest, &(ctx->data), &(ctx->type), &(ctx->format));\n-        }\n-        ctx->received = TRUE;\n-    }\n-}\n-\n-static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx)\n-{\n+static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx) {\n@@ -341,3 +315,3 @@\n-    memset(selection_ctx, 0, sizeof(selection_data_ctx));\n-\n-    gdk_selection_convert(glass_gdk_drag_context_get_dest_window(enter_ctx.ctx), gdk_drag_get_selection(enter_ctx.ctx), target,\n+    gdk_selection_convert(glass_gdk_drag_context_get_dest_window(enter_ctx.ctx),\n+                          gdk_drag_get_selection(enter_ctx.ctx),\n+                          target,\n@@ -346,7 +320,6 @@\n-    hookReg =\n-            glass_evloop_hook_add(\n-                    (GevlHookFunction) wait_for_selection_data_hook,\n-                    selection_ctx);\n-    if (HANDLE_MEM_ALLOC_ERROR(env, hookReg,\n-                               \"Failed to allocate event hook\")) {\n-        return TRUE;\n+    memset(selection_ctx, 0, sizeof(selection_data_ctx));\n+\n+    hookReg = glass_evloop_hook_add((GevlHookFunction) wait_for_selection_data_hook,\n+                                  selection_ctx);\n+    if (HANDLE_MEM_ALLOC_ERROR(env, hookReg, \"Failed to allocate event hook\")) {\n+      return TRUE;\n@@ -359,1 +332,0 @@\n-\n@@ -364,2 +336,1 @@\n-static jobject dnd_target_get_string(JNIEnv *env)\n-{\n+static jobject dnd_target_get_string(JNIEnv *env) {\n@@ -395,2 +366,1 @@\n-static jobject dnd_target_get_list(JNIEnv *env, gboolean files)\n-{\n+static jobject dnd_target_get_list(JNIEnv *env, gboolean files) {\n@@ -408,2 +378,1 @@\n-static jobject dnd_target_get_image(JNIEnv *env)\n-{\n+static jobject dnd_target_get_image(JNIEnv *env) {\n@@ -479,2 +448,1 @@\n-static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data)\n-{\n+static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data) {\n@@ -506,2 +474,1 @@\n-jobject dnd_target_get_data(JNIEnv *env, jstring mime)\n-{\n+jobject dnd_target_get_data(JNIEnv *env, jstring mime) {\n@@ -511,0 +478,1 @@\n+\n@@ -536,0 +504,3 @@\n+static bool in_drag = false;\n+const char * const SOURCE_DND_CONTEXT = \"fx-dnd-context\";\n+const char * const SOURCE_DND_DRAG_VIEW = \"fx-dnd-drag-view\";\n@@ -537,7 +508,2 @@\n-static jint dnd_performed_action;\n-\n-const char * const SOURCE_DND_DATA = \"fx-dnd-data\";\n-\n-static void dnd_set_performed_action(jint performed_action)\n-{\n-    dnd_performed_action = performed_action;\n+gboolean is_in_drag() {\n+    return in_drag;\n@@ -546,4 +512,15 @@\n-static jint dnd_get_performed_action()\n-{\n-    return dnd_performed_action;\n-}\n+static void determine_actions(DragSourceContext *ctx, uint state, GdkDragAction *action,\n+                              GdkDragAction *possible_actions) {\n+    GdkDragAction suggested = ctx->actions;\n+    if (state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) {\n+        if ((state & GDK_CONTROL_MASK) && (state & GDK_SHIFT_MASK) && (suggested & GDK_ACTION_LINK)) {\n+            *action = *possible_actions = GDK_ACTION_LINK;\n+            return;\n+        } else if ((state & GDK_SHIFT_MASK) && (suggested & GDK_ACTION_MOVE)) {\n+            *action = *possible_actions = GDK_ACTION_MOVE;\n+            return;\n+        } else if (suggested & GDK_ACTION_COPY) {\n+            *action = *possible_actions = GDK_ACTION_COPY;\n+            return;\n+        }\n+    }\n@@ -551,4 +528,10 @@\n-static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer)\n-{\n-    if (pixels != NULL) {\n-        g_free(pixels);\n+    *possible_actions = suggested;\n+\n+    if (suggested & GDK_ACTION_COPY) {\n+        *action = GDK_ACTION_COPY;\n+    } else if (suggested & GDK_ACTION_MOVE) {\n+        *action = GDK_ACTION_MOVE;\n+    } else if (suggested & GDK_ACTION_LINK) {\n+        *action = GDK_ACTION_LINK;\n+    } else {\n+        *action = static_cast<GdkDragAction>(0);\n@@ -558,3 +541,1 @@\n-static jobject dnd_source_get_data(GtkWidget *widget, const char *key)\n-{\n-    jobject data = (jobject)g_object_get_data(G_OBJECT(widget), SOURCE_DND_DATA);\n+static jobject dnd_source_get_data(jobject obj, const char *key) {\n@@ -563,1 +544,1 @@\n-    jobject result = mainEnv->CallObjectMethod(data, jMapGet, string, NULL);\n+    jobject result = mainEnv->CallObjectMethod(obj, jMapGet, string, NULL);\n@@ -568,22 +549,4 @@\n-static void add_gtk_target_from_jstring(JNIEnv *env, GtkTargetList **list, jstring string, guint flags)\n-{\n-    const char *gstring = env->GetStringUTFChars(string, NULL);\n-\n-    if (g_strcmp0(gstring, \"text\/plain\") == 0) {\n-        gtk_target_list_add(*list, TARGET_UTF8_STRING_ATOM, flags, 0);\n-        gtk_target_list_add(*list, TARGET_MIME_TEXT_PLAIN_ATOM, flags, 0);\n-        gtk_target_list_add(*list, TARGET_STRING_ATOM, flags, 0);\n-        \/\/gtk_target_list_add(*list, TARGET_COMPOUND_TEXT_ATOM, flags, ??);\n-    } else if (g_strcmp0(gstring, \"application\/x-java-rawimage\") == 0) {\n-        gtk_target_list_add(*list, TARGET_MIME_PNG_ATOM, flags, 0);\n-        gtk_target_list_add(*list, TARGET_MIME_JPEG_ATOM, flags, 0);\n-        gtk_target_list_add(*list, TARGET_MIME_TIFF_ATOM, flags, 0);\n-        gtk_target_list_add(*list, TARGET_MIME_BMP_ATOM, flags, 0);\n-    } else if (g_strcmp0(gstring, \"application\/x-java-file-list\") == 0) {\n-        gtk_target_list_add(*list, TARGET_MIME_URI_LIST_ATOM, flags, 0);\n-    } else if (g_strcmp0(gstring, \"application\/x-java-drag-image\") == 0\n-        || g_strcmp0(gstring, \"application\/x-java-drag-image-offset\") == 0) {\n-        \/\/ do nothing - those are DragView information\n-    } else {\n-        GdkAtom atom = gdk_atom_intern(gstring, FALSE);\n-        gtk_target_list_add(*list, atom, flags, 0);\n+static gboolean dnd_source_set_utf8_string(DragSourceContext *ctx, GdkWindow *requestor, GdkAtom property) {\n+    jstring string = (jstring)dnd_source_get_data(ctx->data, \"text\/plain\");\n+    if (!string) {\n+        return FALSE;\n@@ -592,25 +555,3 @@\n-    env->ReleaseStringUTFChars(string, gstring);\n-}\n-\n-static GtkTargetList* data_to_gtk_target_list(JNIEnv *env, jobject data)\n-{\n-    guint flags = GTK_TARGET_OTHER_APP | GTK_TARGET_SAME_APP;\n-\n-    jobject keys;\n-    jobject keysIterator;\n-    jstring next;\n-\n-    GtkTargetList *tlist = gtk_target_list_new (NULL, 0);\n-\n-    init_target_atoms();\n-\n-    gint added_count = 0;\n-\n-    keys = env->CallObjectMethod(data, jMapKeySet, NULL);\n-    JNI_EXCEPTION_TO_CPP(env)\n-    keysIterator = env->CallObjectMethod(keys, jIterableIterator, NULL);\n-    JNI_EXCEPTION_TO_CPP(env)\n-    while (env->CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {\n-        next = (jstring)env->CallObjectMethod(keysIterator, jIteratorNext, NULL);\n-        JNI_EXCEPTION_TO_CPP(env)\n-        add_gtk_target_from_jstring(env, &tlist, next, flags);\n+    const char *cstring = mainEnv->GetStringUTFChars(string, NULL);\n+    if (!cstring) {\n+        return FALSE;\n@@ -618,0 +559,1 @@\n+    gint size = strlen(cstring);\n@@ -619,2 +561,2 @@\n-    return tlist;\n-}\n+    gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,\n+            8, GDK_PROP_MODE_REPLACE, (guchar *)cstring, size);\n@@ -622,3 +564,3 @@\n-static gboolean dnd_source_set_string(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)\n-{\n-    gboolean is_data_set;\n+    mainEnv->ReleaseStringUTFChars(string, cstring);\n+    return TRUE;\n+}\n@@ -626,1 +568,2 @@\n-    jstring string = (jstring)dnd_source_get_data(widget, \"text\/plain\");\n+static gboolean dnd_source_set_string(DragSourceContext *ctx, GdkWindow *requestor, GdkAtom property) {\n+    jstring string = (jstring)dnd_source_get_data(ctx->data, \"text\/plain\");\n@@ -631,0 +574,1 @@\n+    gboolean is_data_set = FALSE;\n@@ -633,11 +577,1 @@\n-        if (atom == TARGET_MIME_TEXT_PLAIN_ATOM) {\n-            gchar *res_str = g_convert((gchar *) cstring, -1, \"ISO-8859-1\", \"UTF-8\", NULL, NULL, NULL);\n-            if (res_str) {\n-                is_data_set = gtk_selection_data_set_text(data, res_str, strlen(res_str));\n-                g_free(res_str);\n-            }\n-        } else {\n-            gint size = strlen(cstring);\n-            is_data_set = gtk_selection_data_set_text(data, (gchar *) cstring, size);\n-        }\n-    }\n+        gchar *res_str = g_convert((gchar *)cstring, -1, \"ISO-8859-1\", \"UTF-8\", NULL, NULL, NULL);\n@@ -645,1 +579,6 @@\n-    mainEnv->ReleaseStringUTFChars(string, cstring);\n+        if (res_str) {\n+            gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,\n+                    8, GDK_PROP_MODE_REPLACE, (guchar *)res_str, strlen(res_str));\n+            g_free(res_str);\n+            is_data_set = TRUE;\n+        }\n@@ -647,0 +586,2 @@\n+        mainEnv->ReleaseStringUTFChars(string, cstring);\n+    }\n@@ -650,3 +591,2 @@\n-static gboolean dnd_source_set_image(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)\n-{\n-    jobject pixels = dnd_source_get_data(widget, \"application\/x-java-rawimage\");\n+static gboolean dnd_source_set_image(DragSourceContext *ctx, GdkWindow *requestor, GdkAtom property, GdkAtom target) {\n+    jobject pixels = dnd_source_get_data(ctx->data, \"application\/x-java-rawimage\");\n@@ -661,1 +601,13 @@\n-    gboolean is_data_set;\n+    gboolean result = FALSE;\n+\n+    if (target == TARGET_MIME_PNG_ATOM) {\n+        type = \"png\";\n+    } else if (target == TARGET_MIME_JPEG_ATOM) {\n+        type = \"jpeg\";\n+    } else if (target == TARGET_MIME_TIFF_ATOM) {\n+        type = \"tiff\";\n+    } else if (target == TARGET_MIME_BMP_ATOM) {\n+        type = \"bmp\";\n+    } else {\n+        return FALSE;\n+    }\n@@ -665,2 +617,5 @@\n-    if (!EXCEPTION_OCCURED(mainEnv)) {\n-        is_data_set = gtk_selection_data_set_pixbuf(data, pixbuf);\n+    if (!EXCEPTION_OCCURED(mainEnv)\n+            && gdk_pixbuf_save_to_buffer(pixbuf, &buffer, &size, type, NULL, NULL)) {\n+        gdk_property_change(requestor, property, target,\n+                8, GDK_PROP_MODE_REPLACE, (guchar *)buffer, size);\n+        result = TRUE;\n@@ -668,1 +623,0 @@\n-\n@@ -670,2 +624,1 @@\n-\n-    return is_data_set;\n+    return result;\n@@ -674,2 +627,1 @@\n-static gboolean dnd_source_set_uri(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)\n-{\n+static gboolean dnd_source_set_uri_list(DragSourceContext *ctx, GdkWindow *requestor, GdkAtom property) {\n@@ -682,1 +634,1 @@\n-    if (jurl = (jstring) dnd_source_get_data(widget, \"text\/uri-list\")) {\n+    if (jurl = (jstring) dnd_source_get_data(ctx->data, \"text\/uri-list\")) {\n@@ -686,1 +638,1 @@\n-    if (files_array = (jobjectArray) dnd_source_get_data(widget, \"application\/x-java-file-list\")) {\n+    if (files_array = (jobjectArray) dnd_source_get_data(ctx->data, \"application\/x-java-file-list\")) {\n@@ -689,1 +641,0 @@\n-\n@@ -694,1 +645,0 @@\n-    gboolean is_data_set;\n@@ -717,5 +667,2 @@\n-    gchar *uri[2];\n-    uri[0] = g_string_free(res, FALSE);\n-    uri[1] = NULL;\n-\n-    is_data_set = gtk_selection_data_set_uris(data, uri);\n+    gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,\n+            8, GDK_PROP_MODE_REPLACE, (guchar *) res->str, res->len);\n@@ -723,3 +670,2 @@\n-    g_free(uri[0]);\n-\n-    return is_data_set;\n+    g_string_free(res, TRUE);\n+    return TRUE;\n@@ -728,4 +674,3 @@\n-static gboolean dnd_source_set_raw(GtkWidget *widget, GtkSelectionData *sel_data, GdkAtom atom)\n-{\n-    gchar *target_name = gdk_atom_name(atom);\n-    jobject data = dnd_source_get_data(widget, target_name);\n+static gboolean dnd_source_set_raw(DragSourceContext *ctx, GdkWindow *requestor, GdkAtom property, GdkAtom target) {\n+    gchar *target_name = gdk_atom_name(target);\n+    jobject data = dnd_source_get_data(ctx->data, target_name);\n@@ -737,1 +682,3 @@\n-                is_data_set = gtk_selection_data_set_text(sel_data, (gchar *) cstring, strlen(cstring));\n+                gdk_property_change(requestor, property, GDK_SELECTION_TYPE_STRING,\n+                        8, GDK_PROP_MODE_REPLACE, (guchar *) cstring, strlen(cstring));\n+\n@@ -739,0 +686,1 @@\n+                is_data_set = TRUE;\n@@ -746,1 +694,4 @@\n-                    gtk_selection_data_set(sel_data, atom, 8, (guchar *) raw, nraw);\n+\n+                    gdk_property_change(requestor, property, target,\n+                            8, GDK_PROP_MODE_REPLACE, (guchar *) raw, nraw);\n+\n@@ -758,4 +709,40 @@\n-static gboolean dnd_destroy_drag_widget_callback(gpointer) {\n-    if (drag_widget) {\n-        gtk_widget_destroy(drag_widget);\n-        drag_widget = NULL;\n+static void process_dnd_source_selection_req(DragSourceContext *ctx, GdkEvent *gdkEvent) {\n+    GdkEventSelection *event = &gdkEvent->selection;\n+\n+#ifdef GLASS_GTK3\n+    GdkWindow *requestor = (event->requestor);\n+#else\n+    GdkWindow *requestor =\n+        gdk_x11_window_foreign_new_for_display(gdk_display_get_default(), event->requestor);\n+#endif\n+\n+    gboolean is_data_set = FALSE;\n+    if (event->target == TARGET_UTF8_STRING_ATOM\n+            || event->target == TARGET_MIME_TEXT_PLAIN_ATOM) {\n+        is_data_set = dnd_source_set_utf8_string(ctx, requestor, event->property);\n+    } else if (event->target == TARGET_STRING_ATOM) {\n+        is_data_set = dnd_source_set_string(ctx, requestor, event->property);\n+\/\/    } else if (event->target == TARGET_COMPOUND_TEXT_ATOM) { \/\/ XXX compound text\n+    } else if (target_is_image(event->target)) {\n+        is_data_set = dnd_source_set_image(ctx, requestor, event->property, event->target);\n+    } else if (event->target == TARGET_MIME_URI_LIST_ATOM) {\n+        is_data_set = dnd_source_set_uri_list(ctx, requestor, event->property);\n+    } else {\n+        is_data_set = dnd_source_set_raw(ctx, requestor, event->property, event->target);\n+    }\n+\n+    gdk_selection_send_notify(event->requestor, event->selection, event->target,\n+                               (is_data_set) ? event->property : GDK_NONE, event->time);\n+}\n+\n+static gboolean in_drag_end(gpointer data) {\n+    in_drag = false;\n+    return G_SOURCE_REMOVE;\n+}\n+\n+static void process_dnd_source_grab_broken(DragSourceContext *ctx, GdkEvent *event) {\n+    GdkEventGrabBroken *gb_event = &event->grab_broken;\n+\n+    \/\/ grabbed the same window\n+    if (gb_event->implicit || gb_event->grab_window == ctx->dnd_window) {\n+        return;\n@@ -764,1 +751,2 @@\n-    return FALSE;\n+    gdk_drag_abort(ctx->dnd_ctx, GDK_CURRENT_TIME);\n+    gdk_threads_add_idle_full(G_PRIORITY_DEFAULT, in_drag_end, ctx, NULL);\n@@ -767,7 +755,8 @@\n-static void dnd_end_callback(GtkWidget *widget,\n-                             GdkDragContext *context,\n-                             gpointer user_data)\n-{\n-    if (drag_widget) {\n-        GdkDragAction action = gdk_drag_context_get_selected_action(context);\n-        dnd_set_performed_action(translate_gdk_action_to_glass(action));\n+static void process_dnd_source_mouse_release(DragSourceContext *ctx, GdkEvent *event) {\n+    GdkDragAction selected = gdk_drag_context_get_selected_action(ctx->dnd_ctx);\n+\n+    if (selected) {\n+        ctx->performed_action = translate_gdk_action_to_glass(selected);\n+        gdk_drag_drop(ctx->dnd_ctx, GDK_CURRENT_TIME);\n+    } else {\n+        gdk_drag_abort(ctx->dnd_ctx, GDK_CURRENT_TIME);\n@@ -775,1 +764,5 @@\n-    gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);\n+\n+    \/\/ the GDK_BUTTON_RELEASE will be put at the end of the queue because\n+    \/\/ WindowContext mouse release would stop DND before it's completed\n+    gdk_display_put_event(gdk_display_get_default(), event);\n+    gdk_threads_add_idle_full(G_PRIORITY_DEFAULT, in_drag_end, ctx, NULL);\n@@ -778,7 +771,4 @@\n-static gboolean dnd_drag_failed_callback(GtkWidget *widget,\n-                                     GdkDragContext *context,\n-                                     GtkDragResult result,\n-                                     gpointer user_data)\n-{\n-    dnd_set_performed_action(com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE);\n-    gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);\n+static void process_drag_motion(DragSourceContext *ctx, gint x_root, gint y_root, guint state) {\n+    GdkWindow *dest_window;\n+    GdkDragProtocol prot;\n+    GdkWindow *ignore = NULL;\n@@ -786,1 +776,14 @@\n-    return FALSE;\n+    if (ctx->drag_view) {\n+        ctx->drag_view->move(x_root, y_root);\n+        ignore = ctx->drag_view->get_window();\n+    }\n+\n+    gdk_drag_find_window_for_screen(ctx->dnd_ctx, ignore, gdk_screen_get_default(),\n+            x_root, y_root, &dest_window, &prot);\n+\n+    if (prot != GDK_DRAG_PROTO_NONE) {\n+        GdkDragAction action, possible_actions;\n+        determine_actions(ctx, state, &action, &possible_actions);\n+        gdk_drag_motion(ctx->dnd_ctx, dest_window, prot, x_root, y_root,\n+                action, possible_actions, GDK_CURRENT_TIME);\n+    }\n@@ -789,15 +792,92 @@\n-static void dnd_data_get_callback(GtkWidget *widget,\n-                                  GdkDragContext *context,\n-                                  GtkSelectionData *data,\n-                                  guint info,\n-                                  guint time,\n-                                  gpointer user_data)\n-{\n-    GdkAtom atom = gtk_selection_data_get_target(data);\n-\n-    if (target_is_text(atom)) {\n-        dnd_source_set_string(widget, data, atom);\n-    } else if (target_is_image(atom)) {\n-        dnd_source_set_image(widget, data, atom);\n-    } else if (target_is_uri(atom)) {\n-        dnd_source_set_uri(widget, data, atom);\n+static void process_dnd_source_mouse_motion(DragSourceContext *ctx, GdkEvent *event) {\n+    GdkEventMotion *eventMotion = &event->motion;\n+    process_drag_motion(ctx, eventMotion->x_root, eventMotion->y_root, eventMotion->state);\n+}\n+\n+static void process_dnd_source_key_press_release(DragSourceContext *ctx, GdkEvent *event) {\n+    GdkEventKey *eventKey = &event->key;\n+\n+    if (eventKey->is_modifier) {\n+        guint state = eventKey->state;\n+        guint new_mod = 0;\n+        gint x,y;\n+        if (eventKey->keyval == GLASS_GDK_KEY_CONSTANT(Control_L) ||\n+                eventKey->keyval == GLASS_GDK_KEY_CONSTANT(Control_R)) {\n+            new_mod = GDK_CONTROL_MASK;\n+        } else if (eventKey->keyval == GLASS_GDK_KEY_CONSTANT(Alt_L) ||\n+                eventKey->keyval == GLASS_GDK_KEY_CONSTANT(Alt_R)) {\n+            new_mod = GDK_MOD1_MASK;\n+        } else if (eventKey->keyval == GLASS_GDK_KEY_CONSTANT(Shift_L) ||\n+                eventKey->keyval == GLASS_GDK_KEY_CONSTANT(Shift_R)) {\n+            new_mod = GDK_SHIFT_MASK;\n+        }\n+\n+        if (eventKey->type == GDK_KEY_PRESS) {\n+            state |= new_mod;\n+        } else {\n+            state ^= new_mod;\n+        }\n+\n+        glass_gdk_master_pointer_get_position(&x, &y);\n+        process_drag_motion(ctx, x, y, state);\n+    }\n+}\n+\n+static GdkCursor * get_action_cursor(GdkDragAction selected) {\n+    GdkCursor* cursor = NULL;\n+\n+    if (selected & GDK_ACTION_COPY) {\n+        cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"dnd-copy\");\n+        if (cursor == NULL) {\n+            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"copy\");\n+        }\n+    } else if (selected & (GDK_ACTION_MOVE | GDK_ACTION_PRIVATE)) {\n+        cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"dnd-move\");\n+\n+        if (cursor == NULL) {\n+            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"pointer-move\");\n+        }\n+    } else if (selected & GDK_ACTION_LINK) {\n+        cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"dnd-link\");\n+\n+        if (cursor == NULL) {\n+            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"link\");\n+        }\n+\n+        if (cursor == NULL) {\n+            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"alias\");\n+        }\n+    }\n+\n+    if (cursor == NULL) {\n+        cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"dnd-no-drop\");\n+\n+        if (cursor == NULL) {\n+            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"no-drop\");\n+        }\n+    }\n+\n+    return cursor;\n+}\n+\n+static void process_dnd_source_drag_status(DragSourceContext *ctx, GdkEvent *event) {\n+    GdkEventDND *eventDnd = &event->dnd;\n+    GdkDragAction selected = gdk_drag_context_get_selected_action(eventDnd->context);\n+    gdk_pointer_grab(ctx->dnd_window, FALSE, GDK_MOUSE_EVENTS_MASK, NULL,\n+                        get_action_cursor(selected), GDK_CURRENT_TIME);\n+}\n+\n+static void add_target_from_jstring(JNIEnv *env, GList **list, jstring string) {\n+    const char *gstring = env->GetStringUTFChars(string, NULL);\n+    if (g_strcmp0(gstring, \"text\/plain\") == 0) {\n+        *list = g_list_append(*list, TARGET_UTF8_STRING_ATOM);\n+        *list = g_list_append(*list, TARGET_MIME_TEXT_PLAIN_ATOM);\n+        *list = g_list_append(*list, TARGET_STRING_ATOM);\n+        *list = g_list_append(*list, TARGET_COMPOUND_TEXT_ATOM);\n+    } else if (g_strcmp0(gstring, \"application\/x-java-rawimage\") == 0) {\n+        *list = g_list_append(*list, TARGET_MIME_PNG_ATOM);\n+        *list = g_list_append(*list, TARGET_MIME_JPEG_ATOM);\n+        *list = g_list_append(*list, TARGET_MIME_TIFF_ATOM);\n+        *list = g_list_append(*list, TARGET_MIME_BMP_ATOM);\n+    } else if (g_strcmp0(gstring, \"application\/x-java-file-list\") == 0) {\n+        *list = g_list_append(*list, TARGET_MIME_URI_LIST_ATOM);\n@@ -805,1 +885,1 @@\n-        dnd_source_set_raw(widget, data, atom);\n+        *list = g_list_append(*list, gdk_atom_intern(gstring, FALSE));\n@@ -807,0 +887,1 @@\n+    env->ReleaseStringUTFChars(string, gstring);\n@@ -809,5 +890,19 @@\n-static void dnd_drag_begin_callback(GtkWidget *widget,\n-                                    GdkDragContext *context,\n-                                    gpointer user_data)\n-{\n-    DragView::set_drag_view(widget, context);\n+static GList* data_to_targets(JNIEnv *env, jobject data) {\n+    jobject keys;\n+    jobject keysIterator;\n+    jstring next;\n+\n+    GList *list = NULL;\n+\n+    init_target_atoms();\n+\n+    keys = env->CallObjectMethod(data, jMapKeySet, NULL);\n+    JNI_EXCEPTION_TO_CPP(env)\n+    keysIterator = env->CallObjectMethod(keys, jIterableIterator, NULL);\n+    JNI_EXCEPTION_TO_CPP(env)\n+    while (env->CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {\n+        next = (jstring)env->CallObjectMethod(keysIterator, jIteratorNext, NULL);\n+        JNI_EXCEPTION_TO_CPP(env)\n+        add_target_from_jstring(env, &list, next);\n+    }\n+    return list;\n@@ -816,2 +911,10 @@\n-static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported)\n-{\n+static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported, DragSourceContext *ctx) {\n+    GList *targets;\n+    if (WindowContextBase:: sm_mouse_drag_window == NULL) {\n+        ERROR0(\"Drag not started on source window.\");\n+        return;\n+    }\n+\n+    in_drag = true;\n+    ctx->dnd_window = WindowContextBase:: sm_mouse_drag_window->get_gdk_window();\n+\n@@ -822,1 +925,4 @@\n-    data = env->NewGlobalRef(data);\n+    targets = data_to_targets(env, data);\n+    ctx->data = env->NewGlobalRef(data);\n+\n+    g_object_set_data(G_OBJECT(ctx->dnd_window), SOURCE_DND_CONTEXT, ctx);\n@@ -825,0 +931,15 @@\n+    ctx->actions = actions;\n+    ctx->dnd_ctx = gdk_drag_begin(ctx->dnd_window, targets);\n+    if (!gdk_pointer_is_grabbed()) {\n+        \/\/ Grab will start on glass_window, unless disabled\n+        gdk_pointer_grab(ctx->dnd_window, FALSE, GDK_MOUSE_EVENTS_MASK, NULL,\n+                         get_action_cursor(GDK_ACTION_DEFAULT), GDK_CURRENT_TIME);\n+    }\n+\n+    g_list_free(targets);\n+\n+    gboolean is_raw_image = FALSE;\n+    gint w = 0, h = 0;\n+    GdkPixbuf* pixbuf = DragView::get_drag_image(data, &is_raw_image, &w, &h);\n+    gint offset_x = -2;\n+    gint offset_y = -2;\n@@ -826,6 +947,3 @@\n-    \/\/ this widget is used only to pass events and will\n-    \/\/ be destroyed on drag end\n-    drag_widget = gtk_window_new(GTK_WINDOW_POPUP);\n-    gtk_window_resize(GTK_WINDOW(drag_widget), 1, 1);\n-    gtk_window_move(GTK_WINDOW(drag_widget), -200, -200);\n-    gtk_widget_show(drag_widget);\n+    if (GDK_IS_PIXBUF(pixbuf)) {\n+        offset_x = w \/ 2;\n+        offset_y = h \/ 2;\n@@ -833,1 +951,10 @@\n-    g_object_set_data_full(G_OBJECT(drag_widget), SOURCE_DND_DATA, data, clear_global_ref);\n+        DragView::get_drag_image_offset(data, &offset_x, &offset_y);\n+    } else {\n+        GError *error = NULL;\n+        GtkIconTheme *icon_theme = gtk_icon_theme_get_default();\n+        gtk_icon_size_lookup(GTK_ICON_SIZE_DND, &w, &h);\n+        pixbuf = gtk_icon_theme_load_icon(icon_theme,\n+                                         \"text-x-generic\", w,\n+                                         GTK_ICON_LOOKUP_USE_BUILTIN,\n+                                         &error);\n+    }\n@@ -835,2 +962,4 @@\n-    g_signal_connect(drag_widget, \"drag-begin\",\n-        G_CALLBACK(dnd_drag_begin_callback), NULL);\n+    if (GDK_IS_PIXBUF(pixbuf)) {\n+        ctx->drag_view = new DragView(pixbuf, is_raw_image, offset_x, offset_y);\n+    }\n+}\n@@ -838,2 +967,3 @@\n-    g_signal_connect(drag_widget, \"drag-failed\",\n-        G_CALLBACK(dnd_drag_failed_callback), NULL);\n+\/\/true = continue\n+bool process_dnd_source(GdkEvent *event) {\n+    GdkWindow* window = event->any.window;\n@@ -841,2 +971,3 @@\n-    g_signal_connect(drag_widget, \"drag-data-get\",\n-        G_CALLBACK(dnd_data_get_callback), NULL);\n+    if (!in_drag || !window) {\n+        return true;\n+    }\n@@ -844,2 +975,5 @@\n-    g_signal_connect(drag_widget, \"drag-end\",\n-        G_CALLBACK(dnd_end_callback), NULL);\n+    DragView *drag_view = (DragView *) g_object_get_data(G_OBJECT(window), SOURCE_DND_DRAG_VIEW);\n+    if (drag_view != NULL && event->type == GDK_EXPOSE && window == drag_view->get_window()) {\n+        drag_view->expose();\n+        return true;\n+    }\n@@ -847,1 +981,2 @@\n-    GtkTargetList *tlist = data_to_gtk_target_list(env, data);\n+    DragSourceContext *ctx = (DragSourceContext*)\n+        g_object_get_data(G_OBJECT(window), SOURCE_DND_CONTEXT);\n@@ -849,1 +984,3 @@\n-    GdkDragContext *context;\n+    if (!ctx) {\n+        return true;\n+    }\n@@ -851,2 +988,5 @@\n-    gint x, y;\n-    glass_gdk_master_pointer_get_position(&x, &y);\n+    if (event->type == GDK_DELETE && window == ctx->dnd_window) {\n+        gdk_drag_abort(ctx->dnd_ctx, GDK_CURRENT_TIME);\n+        in_drag = false;\n+        return true;\n+    }\n@@ -854,1 +994,4 @@\n-    is_dnd_owner = TRUE;\n+    \/\/ the window has grab\n+    if (window != ctx->dnd_window) {\n+        return true;\n+    }\n@@ -856,1 +999,27 @@\n-    context = gtk_drag_begin(drag_widget, tlist, actions, 1, NULL);\n+    switch(event->type) {\n+        case GDK_GRAB_BROKEN:\n+            process_dnd_source_grab_broken(ctx, event);\n+            break;\n+        case GDK_MOTION_NOTIFY:\n+            process_dnd_source_mouse_motion(ctx, event);\n+            break;\n+        case GDK_BUTTON_RELEASE:\n+            process_dnd_source_mouse_release(ctx, event);\n+            return false;\n+        case GDK_KEY_PRESS:\n+        case GDK_KEY_RELEASE:\n+            process_dnd_source_key_press_release(ctx, event);\n+            break;\n+        case GDK_DRAG_ENTER:\n+            gdk_selection_owner_set(ctx->dnd_window, gdk_drag_get_selection(ctx->dnd_ctx),\n+                                    GDK_CURRENT_TIME, FALSE);\n+            break;\n+        case GDK_DRAG_STATUS:\n+            process_dnd_source_drag_status(ctx, event);\n+            break;\n+        case GDK_SELECTION_REQUEST:\n+            process_dnd_source_selection_req(ctx, event);\n+            break;\n+        default:\n+            break;\n+    }\n@@ -858,1 +1027,1 @@\n-    gtk_target_list_unref(tlist);\n+    return true;\n@@ -861,2 +1030,4 @@\n-jint execute_dnd(JNIEnv *env, jobject data, jint supported)\n-{\n+jint execute_dnd(JNIEnv *env, jobject data, jint supported) {\n+    DragSourceContext *ctx = new DragSourceContext();\n+    ctx->performed_action = com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE;\n+\n@@ -864,1 +1035,1 @@\n-        dnd_source_push_data(env, data, supported);\n+        dnd_source_push_data(env, data, supported, ctx);\n@@ -866,2 +1037,1 @@\n-        gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);\n-        return com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE;\n+        goto end;\n@@ -874,1 +1044,5 @@\n-    return dnd_get_performed_action();\n+    end:\n+    jint performed_action = ctx->performed_action;\n+    delete ctx;\n+\n+    return performed_action;\n@@ -877,2 +1051,1 @@\n- \/******************** DRAG VIEW ***************************\/\n- DragView::View* DragView::view = NULL;\n+\/******************** DRAG VIEW **************************\/\n@@ -880,2 +1053,1 @@\n- gboolean DragView::get_drag_image_offset(GtkWidget *widget, int* x, int* y)\n- {\n+gboolean DragView::get_drag_image_offset(jobject obj, int* x, int* y) {\n@@ -883,1 +1055,1 @@\n-    jobject bb = dnd_source_get_data(widget, \"application\/x-java-drag-image-offset\");\n+    jobject bb = dnd_source_get_data(obj, \"application\/x-java-drag-image-offset\");\n@@ -903,2 +1075,7 @@\n-GdkPixbuf* DragView::get_drag_image(GtkWidget *widget, gboolean* is_raw_image, gint* width, gint* height)\n-{\n+static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer) {\n+    if (pixels != NULL) {\n+        g_free(pixels);\n+    }\n+}\n+\n+GdkPixbuf* DragView::get_drag_image(jobject obj, gboolean* is_raw_image, gint* width, gint* height) {\n@@ -908,1 +1085,1 @@\n-    jobject drag_image = dnd_source_get_data(widget, \"application\/x-java-drag-image\");\n+    jobject drag_image = dnd_source_get_data(obj, \"application\/x-java-drag-image\");\n@@ -919,1 +1096,1 @@\n-            \/\/ in this byteArray: width and height\n+                                         \/\/ in this byteArray: width and height\n@@ -948,1 +1125,1 @@\n-        jobject pixels = dnd_source_get_data(widget, \"application\/x-java-rawimage\");\n+        jobject pixels = dnd_source_get_data(obj, \"application\/x-java-rawimage\");\n@@ -989,14 +1166,22 @@\n-void DragView::set_drag_view(GtkWidget *widget, GdkDragContext *context)\n-{\n-    gboolean is_raw_image = FALSE;\n-    gint w = 0, h = 0;\n-    GdkPixbuf* pixbuf = get_drag_image(widget, &is_raw_image, &w, &h);\n-\n-    if (GDK_IS_PIXBUF(pixbuf)) {\n-        gint offset_x = w \/ 2;\n-        gint offset_y = h \/ 2;\n-\n-        gboolean is_offset_set = get_drag_image_offset(widget, &offset_x, &offset_y);\n-\n-        DragView::view = new DragView::View(context, pixbuf, w, h, is_raw_image,\n-            is_offset_set, offset_x, offset_y);\n+DragView::DragView(GdkPixbuf* _pixbuf, gboolean _is_raw_image,\n+                   gint _offset_x, gint _offset_y) :\n+        pixbuf(_pixbuf),\n+        is_raw_image(_is_raw_image),\n+        offset_x(_offset_x),\n+        offset_y(_offset_y) {\n+    width = gdk_pixbuf_get_width(pixbuf);\n+    height = gdk_pixbuf_get_height(pixbuf);\n+\n+    GdkScreen* screen = gdk_screen_get_default();\n+    GdkWindowAttr attrs;\n+\n+    attrs.width = width;\n+    attrs.height = height;\n+    attrs.wclass = GDK_INPUT_OUTPUT;\n+    attrs.window_type = GDK_WINDOW_TEMP;\n+    attrs.type_hint = GDK_WINDOW_TYPE_HINT_DND;\n+    attrs.visual = gdk_screen_get_rgba_visual(screen);\n+    attrs.event_mask = GDK_EXPOSURE_MASK;\n+\n+    if (!attrs.visual) {\n+        attrs.visual = gdk_screen_get_system_visual(screen);\n@@ -1004,1 +1189,0 @@\n-}\n@@ -1006,4 +1190,2 @@\n-static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view)\n-{\n-    (void)widget;\n-    (void)previous_screen;\n+    int mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_TYPE_HINT;\n+    glass_gdk_master_pointer_get_position(&attrs.x, &attrs.y);\n@@ -1011,2 +1193,2 @@\n-    ((DragView::View*) view)->screen_changed();\n-}\n+    attrs.x -= offset_x;\n+    attrs.y -= offset_y;\n@@ -1014,4 +1196,2 @@\n-static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view)\n-{\n-    (void)widget;\n-    (void)event;\n+    window = gdk_window_new(gdk_screen_get_root_window(screen), &attrs, mask);\n+    g_object_set_data(G_OBJECT(window), SOURCE_DND_DRAG_VIEW, this);\n@@ -1019,15 +1199,0 @@\n-    ((DragView::View*) view)->expose();\n-    return FALSE;\n-}\n-\n-DragView::View::View(GdkDragContext* _context, GdkPixbuf* _pixbuf, gint _width, gint _height,\n-                     gboolean _is_raw_image, gboolean _is_offset_set, gint _offset_x, gint _offset_y) :\n-    context(_context),\n-    pixbuf(_pixbuf),\n-    width(_width),\n-    height(_height),\n-    is_raw_image(_is_raw_image),\n-    is_offset_set(_is_offset_set),\n-    offset_x(_offset_x),\n-    offset_y(_offset_y)\n-{\n@@ -1035,1 +1200,3 @@\n-    gtk_drag_set_icon_pixbuf(context, pixbuf, offset_x, offset_y);\n+    gdk_window_set_opaque_region(window, NULL);\n+    GdkRGBA rgba = {0, 0, 0, 0};\n+    gdk_window_set_background_rgba(window, &rgba);\n@@ -1037,5 +1204,3 @@\n-    widget = gtk_window_new(GTK_WINDOW_POPUP);\n-    gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);\n-    gtk_widget_set_events(widget, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);\n-\n-    screen_changed();\n+    gdk_window_set_opacity(window, .7);\n+#endif\n+}\n@@ -1043,1 +1208,5 @@\n-    gtk_widget_realize(widget);\n+void DragView::expose() {\n+#ifdef GLASS_GTK3\n+    cairo_region_t *region = gdk_window_get_clip_region(window);\n+    gdk_window_begin_paint_region(window, region);\n+#endif\n@@ -1045,5 +1214,5 @@\n-    gtk_widget_set_app_paintable(widget, TRUE);\n-    g_signal_connect(G_OBJECT(widget), \"expose-event\", G_CALLBACK(on_expose), this);\n-    g_signal_connect(G_OBJECT(widget), \"screen-changed\", G_CALLBACK(on_screen_changed), this);\n-    gtk_widget_set_size_request(widget, width, height);\n-    gtk_window_set_decorated(GTK_WINDOW(widget), FALSE);\n+    cairo_t *cr = gdk_cairo_create(window);\n+    cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);\n+    gdk_cairo_set_source_pixbuf(cr, pixbuf, 0, 0);\n+    cairo_paint(cr);\n+    cairo_destroy(cr);\n@@ -1051,2 +1220,3 @@\n-    gtk_widget_show_all(widget);\n-    gtk_drag_set_icon_widget(context, widget, offset_x, offset_y);\n+#ifdef GLASS_GTK3\n+    gdk_window_end_paint(window);\n+    cairo_region_destroy(region);\n@@ -1056,3 +1226,2 @@\n-void DragView::View::screen_changed()\n-{\n-    GdkScreen *screen = gtk_widget_get_screen(widget);\n+void DragView::move(gint x, gint y) {\n+    gdk_window_move(window, x - offset_x, y - offset_y);\n@@ -1060,7 +1229,3 @@\n-    glass_configure_window_transparency(widget, true);\n-\n-    if (!gdk_screen_is_composited(screen)) {\n-        if (!is_offset_set) {\n-            offset_x = 1;\n-            offset_y = 1;\n-        }\n+    if (!gdk_window_is_visible(window)) {\n+        gdk_window_show(window);\n+        gdk_window_raise(window);\n@@ -1070,3 +1235,3 @@\n-void DragView::View::expose()\n-{\n-    cairo_t *context = gdk_cairo_create(gtk_widget_get_window(widget));\n+GdkWindow* DragView::get_window() {\n+    return window;\n+}\n@@ -1074,2 +1239,5 @@\n-    gdk_cairo_set_source_pixbuf(context, pixbuf, 0, 0);\n-    cairo_paint(context);\n+DragView::~DragView() {\n+    if (window) {\n+        gdk_window_destroy(window);\n+        window = NULL;\n+    }\n@@ -1077,2 +1245,5 @@\n-    cairo_destroy(context);\n-}\n+    if (pixbuf) {\n+        g_object_unref(pixbuf);\n+        pixbuf = NULL;\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_dnd.cpp","additions":515,"deletions":344,"binary":false,"changes":859,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-void process_dnd_source(GdkWindow *, GdkEvent *);\n+bool process_dnd_source(GdkEvent *);\n@@ -53,0 +53,5 @@\n+    GdkWindow* window;\n+    GdkPixbuf* pixbuf;\n+    gint width, height;\n+    gboolean is_raw_image;\n+    gint offset_x, offset_y;\n@@ -54,23 +59,7 @@\n-    class View {\n-        GdkDragContext* context;\n-        GtkWidget* widget;\n-        GdkPixbuf* pixbuf;\n-        gint width, height;\n-        gboolean is_raw_image;\n-        gboolean is_offset_set;\n-        gint offset_x, offset_y;\n-    public:\n-        View(GdkDragContext* context, GdkPixbuf* pixbuf, gint width, gint height,\n-                gboolean is_raw_image, gboolean is_offset_set, gint offset_x, gint offset_y);\n-        void screen_changed();\n-        void expose();\n-        void move(gint x, gint y);\n-        ~View();\n-    private:\n-        View(View&);\n-        View& operator=(const View&);\n-    };\n-\n-    static void reset_drag_view();\n-    static void set_drag_view(GtkWidget* widget, GdkDragContext* context);\n-    static void move(gint x, gint y);\n+    DragView(GdkPixbuf* pixbuf, gboolean is_raw_image, gint offset_x, gint offset_y);\n+    void expose();\n+    void move(gint x, gint y);\n+    GdkWindow * get_window();\n+    ~DragView();\n+    static gboolean get_drag_image_offset(jobject obj, int* x, int* y);\n+    static GdkPixbuf* get_drag_image(jobject obj, gboolean* is_raw_image, gint* width, gint* height);\n@@ -79,5 +68,0 @@\n-    static View* view;\n-    static gboolean get_drag_image_offset(GtkWidget *widget, int* x, int* y);\n-    static GdkPixbuf* get_drag_image(GtkWidget* widget, gboolean* is_raw_image, gint* width, gint* height);\n-\n-    DragView() {}\n@@ -88,0 +72,19 @@\n+struct DragSourceContext {\n+    GdkDragContext *dnd_ctx;\n+    GdkWindow *dnd_window;\n+    DragView *drag_view;\n+    GdkDragAction actions;\n+    jobject data;\n+    jint performed_action;\n+\n+    ~DragSourceContext() {\n+        if (drag_view) {\n+            delete drag_view;\n+        }\n+\n+        if (data) {\n+            mainEnv->DeleteGlobalRef(data);\n+        }\n+    };\n+};\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_dnd.h","additions":32,"deletions":29,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -544,9 +544,1 @@\n-    GdkGrabStatus status = gdk_pointer_grab(gdkWindow, owner_events, (GdkEventMask)\n-                                            (GDK_POINTER_MOTION_MASK\n-                                                | GDK_POINTER_MOTION_HINT_MASK\n-                                                | GDK_BUTTON_MOTION_MASK\n-                                                | GDK_BUTTON1_MOTION_MASK\n-                                                | GDK_BUTTON2_MOTION_MASK\n-                                                | GDK_BUTTON3_MOTION_MASK\n-                                                | GDK_BUTTON_PRESS_MASK\n-                                                | GDK_BUTTON_RELEASE_MASK),\n+    GdkGrabStatus status = gdk_pointer_grab(gdkWindow, owner_events, GDK_MOUSE_EVENTS_MASK,\n@@ -584,11 +576,0 @@\n-void\n-glass_gdk_device_ungrab(GdkDevice *device) {\n-#ifdef GLASS_GTK3\n-        gdk_device_ungrab(device, GDK_CURRENT_TIME);\n-#else\n-        (void) device;\n-        gdk_pointer_ungrab(GDK_CURRENT_TIME);\n-#endif\n-}\n-\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -52,0 +52,8 @@\n+#define GDK_MOUSE_EVENTS_MASK static_cast<GdkEventMask>(GDK_POINTER_MOTION_MASK \\\n+                                              | GDK_BUTTON_MOTION_MASK \\\n+                                              | GDK_BUTTON1_MOTION_MASK \\\n+                                              | GDK_BUTTON2_MOTION_MASK \\\n+                                              | GDK_BUTTON3_MOTION_MASK \\\n+                                              | GDK_BUTTON_PRESS_MASK \\\n+                                              | GDK_BUTTON_RELEASE_MASK)\n+\n@@ -294,6 +302,0 @@\n-void\n-glass_gdk_master_pointer_grab(GdkEvent *event, GdkWindow *window, GdkCursor *cursor);\n-\n-void\n-glass_gdk_master_pointer_ungrab(GdkEvent *event);\n-\n@@ -306,3 +308,0 @@\n-void\n-glass_gdk_device_ungrab(GdkDevice *device);\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+public:\n@@ -214,1 +215,0 @@\n-public:\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}