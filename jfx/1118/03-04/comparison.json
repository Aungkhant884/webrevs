{"files":[{"patch":"@@ -0,0 +1,79 @@\n+package com.sun.javafx.scene.layout;\n+\n+\/**\n+ * Math functions which deal with rounding scaled values.\n+ *\/\n+public class ScaledMath {\n+\n+    \/**\n+     * The value is floored for a given scale using Math.floor.\n+     * When the absolute value of the given value multiplied by the\n+     * current scale is less than 10^15, then this method guarantees that:\n+     *\n+     * <pre>scaledFloor(scaledFloor(value, scale), scale) == scaledFloor(value, scale)<\/pre>\n+     *\n+     * The limit is about 10^15 because double values will no longer be able to represent\n+     * larger integers with exact precision beyond this limit.\n+     *\n+     * @param value The value that needs to be floored\n+     * @param scale The scale that will be used\n+     * @return value floored with scale\n+     *\/\n+    public static double floor(double value, double scale) {\n+        double d = value * scale;\n+\n+        if (Double.isInfinite(d)) {  \/\/ Avoids returning NaN for high magnitude inputs\n+            return value;\n+        }\n+\n+        return Math.floor(d + Math.ulp(d)) \/ scale;\n+    }\n+\n+    \/**\n+     * The value is ceiled with a given scale using Math.ceil.\n+     * When the absolute value of the given value multiplied by the\n+     * current scale is less than 10^15, then this method guarantees that:\n+     *\n+     * <pre>scaledCeil(scaledCeil(value, scale), scale) == scaledCeil(value, scale)<\/pre>\n+     *\n+     * The limit is about 10^15 because double values will no longer be able to represent\n+     * larger integers with exact precision beyond this limit.\n+     *\n+     * @param value The value that needs to be ceiled\n+     * @param scale The scale that will be used\n+     * @return value ceiled with scale\n+     *\/\n+    public static double ceil(double value, double scale) {\n+        double d = value * scale;\n+\n+        if (Double.isInfinite(d)) {  \/\/ Avoids returning NaN for high magnitude inputs\n+            return value;\n+        }\n+\n+        return Math.ceil(d - Math.ulp(d)) \/ scale;\n+    }\n+\n+    \/**\n+     * The value is rounded with a given scale using {@link Math#round(double)}.\n+     *\n+     * @param value The value that needs to be rounded\n+     * @param scale The scale that will be used\n+     * @return value rounded with scale\n+     * @deprecated uses {@link Math#round(double)} instead of {@link Math#rint(double)}, don't use in new code, use {@link #rint(double, double)}\n+     *\/\n+    @Deprecated\n+    public static double round(double value, double scale) {\n+        return Math.round(value * scale) \/ scale;\n+    }\n+\n+    \/**\n+     * The value is rounded with a given scale using {@link Math#rint(double)}.\n+     *\n+     * @param value The value that needs to be rounded\n+     * @param scale The scale that will be used\n+     * @return value rounded with scale\n+     *\/\n+    public static double rint(double value, double scale) {\n+        return Math.rint(value * scale) \/ scale;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/ScaledMath.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -77,0 +77,1 @@\n+import com.sun.javafx.scene.layout.ScaledMath;\n@@ -290,44 +291,0 @@\n-    private static double scaledRound(double value, double scale) {\n-        return Math.round(value * scale) \/ scale;\n-    }\n-\n-    \/**\n-     * The value is floored for a given scale using Math.floor.\n-     * When the absolute value of the given value multiplied by the\n-     * current scale is less than 10^15, then this method guarantees that:\n-     *\n-     * <pre>scaledFloor(scaledFloor(value, scale), scale) == scaledFloor(value, scale)<\/pre>\n-     *\n-     * The limit is about 10^15 because double values will no longer be able to represent\n-     * larger integers with exact precision beyond this limit.\n-     *\n-     * @param value The value that needs to be floored\n-     * @param scale The scale that will be used\n-     * @return value floored with scale\n-     *\/\n-    private static double scaledFloor(double value, double scale) {\n-        double d = value * scale;\n-\n-        return Math.floor(d + Math.ulp(d)) \/ scale;\n-    }\n-\n-    \/**\n-     * The value is ceiled with a given scale using Math.ceil.\n-     * When the absolute value of the given value multiplied by the\n-     * current scale is less than 10^15, then this method guarantees that:\n-     *\n-     * <pre>scaledCeil(scaledCeil(value, scale), scale) == scaledCeil(value, scale)<\/pre>\n-     *\n-     * The limit is about 10^15 because double values will no longer be able to represent\n-     * larger integers with exact precision beyond this limit.\n-     *\n-     * @param value The value that needs to be ceiled\n-     * @param scale The scale that will be used\n-     * @return value ceiled with scale\n-     *\/\n-    private static double scaledCeil(double value, double scale) {\n-        double d = value * scale;\n-\n-        return Math.ceil(d - Math.ulp(d)) \/ scale;\n-    }\n-\n@@ -347,1 +304,1 @@\n-        return snapToPixel ? scaledRound(value, getSnapScaleX()) : value;\n+        return snapToPixel ? ScaledMath.round(value, getSnapScaleX()) : value;\n@@ -350,1 +307,1 @@\n-        return snapToPixel ? scaledRound(value, getSnapScaleY()) : value;\n+        return snapToPixel ? ScaledMath.round(value, getSnapScaleY()) : value;\n@@ -354,1 +311,1 @@\n-        return snapToPixel ? scaledRound(value, snapScale) : value;\n+        return snapToPixel ? ScaledMath.round(value, snapScale) : value;\n@@ -366,1 +323,1 @@\n-        return snapToPixel ? scaledCeil(value, getSnapScaleX()) : value;\n+        return snapToPixel ? ScaledMath.ceil(value, getSnapScaleX()) : value;\n@@ -369,1 +326,1 @@\n-        return snapToPixel ? scaledCeil(value, getSnapScaleY()) : value;\n+        return snapToPixel ? ScaledMath.ceil(value, getSnapScaleY()) : value;\n@@ -373,1 +330,1 @@\n-        return snapToPixel ? scaledCeil(value, snapScale) : value;\n+        return snapToPixel ? ScaledMath.ceil(value, snapScale) : value;\n@@ -385,1 +342,1 @@\n-        return snapToPixel ? scaledRound(value, getSnapScaleX()) : value;\n+        return snapToPixel ? ScaledMath.round(value, getSnapScaleX()) : value;\n@@ -388,1 +345,1 @@\n-        return snapToPixel ? scaledRound(value, getSnapScaleY()) : value;\n+        return snapToPixel ? ScaledMath.round(value, getSnapScaleY()) : value;\n@@ -392,1 +349,1 @@\n-        return snapToPixel ? scaledRound(value, snapScale) : value;\n+        return snapToPixel ? ScaledMath.round(value, snapScale) : value;\n@@ -414,1 +371,1 @@\n-        return value > 0 ? scaledFloor(value, s) : scaledCeil(value, s);\n+        return value > 0 ? ScaledMath.floor(value, s) : ScaledMath.ceil(value, s);\n@@ -436,1 +393,1 @@\n-        return value > 0 ? scaledFloor(value, s) : scaledCeil(value, s);\n+        return value > 0 ? ScaledMath.floor(value, s) : ScaledMath.ceil(value, s);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":12,"deletions":55,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+--add-exports javafx.graphics\/com.sun.javafx.scene.layout=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+package test.com.sun.javafx.scene.layout;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.scene.layout.ScaledMath;\n+\n+public class ScaledMathTest {\n+\n+    @Test\n+    void ceilShouldBeStable() {\n+        for (double scale : new double[] {0.5, 2.0 \/ 3.0, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 4.0 \/ 3.0}) {\n+            for (double d = 0; d < 1e13; d++, d *= 1.1) {  \/\/ larger values break down because there are not enough fractional digits anymore\n+                double expected = Math.ceil(d * scale) \/ scale;\n+\n+                assertEquals(expected, ScaledMath.ceil(d, scale), 0.0);\n+                assertEquals(expected, ScaledMath.ceil(ScaledMath.ceil(d, scale), scale), 0.0);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void floorShouldBeStable() {\n+        for (double scale : new double[] {0.5, 2.0 \/ 3.0, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 4.0 \/ 3.0}) {\n+            for (double d = 0; d < 1e13; d++, d *= 1.1) {  \/\/ larger values break down because there are not enough fractional digits anymore\n+                double expected = Math.floor(d * scale) \/ scale;\n+\n+                assertEquals(expected, ScaledMath.floor(d, scale), 0.0);\n+                assertEquals(expected, ScaledMath.floor(ScaledMath.floor(d, scale), scale), 0.0);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void ceilShouldHandleLargeMagnitudeValuesWithoutReturningNaN() {\n+        assertEquals(Double.MAX_VALUE, ScaledMath.ceil(Double.MAX_VALUE, 0.5), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.MAX_VALUE, ScaledMath.ceil(Double.MAX_VALUE, 1.0), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.MAX_VALUE, ScaledMath.ceil(Double.MAX_VALUE, 1.5), Math.ulp(Double.MAX_VALUE));\n+\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(-Double.MAX_VALUE, 0.5), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(-Double.MAX_VALUE, 1.0), 0.0);\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.ceil(-Double.MAX_VALUE, 1.5), Math.ulp(-Double.MAX_VALUE));\n+\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.ceil(Double.POSITIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.ceil(Double.POSITIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.ceil(Double.POSITIVE_INFINITY, 1.5), 0.0);\n+\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(Double.NEGATIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(Double.NEGATIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(Double.NEGATIVE_INFINITY, 1.5), 0.0);\n+    }\n+\n+    @Test\n+    void floorShouldHandleLargeMagnitudeValuesWithoutReturningNaN() {\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.MAX_VALUE, 0.5), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.MAX_VALUE, 1.0), 0.0);\n+        assertEquals(Double.MAX_VALUE, ScaledMath.floor(Double.MAX_VALUE, 1.5), Math.ulp(Double.MAX_VALUE));\n+\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.floor(-Double.MAX_VALUE, 0.5), Math.ulp(-Double.MAX_VALUE));\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.floor(-Double.MAX_VALUE, 1.0), Math.ulp(-Double.MAX_VALUE));\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.floor(-Double.MAX_VALUE, 1.5), Math.ulp(-Double.MAX_VALUE));\n+\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.POSITIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.POSITIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.POSITIVE_INFINITY, 1.5), 0.0);\n+\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.floor(Double.NEGATIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.floor(Double.NEGATIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.floor(Double.NEGATIVE_INFINITY, 1.5), 0.0);\n+    }\n+\n+    @Test\n+    void rintShouldHandleLargeMagnitudeValuesWithoutReturningNaN() {\n+        assertEquals(Double.MAX_VALUE, ScaledMath.rint(Double.MAX_VALUE, 0.5), 0.0);\n+        assertEquals(Double.MAX_VALUE, ScaledMath.rint(Double.MAX_VALUE, 1.0), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.rint(Double.MAX_VALUE, 1.5), 0.0);\n+\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.rint(-Double.MAX_VALUE, 0.5), 0.0);\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.rint(-Double.MAX_VALUE, 1.0), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.rint(-Double.MAX_VALUE, 1.5), 0.0);\n+\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.rint(Double.POSITIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.rint(Double.POSITIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.rint(Double.POSITIVE_INFINITY, 1.5), 0.0);\n+\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.rint(Double.NEGATIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.rint(Double.NEGATIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.rint(Double.NEGATIVE_INFINITY, 1.5), 0.0);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/layout\/ScaledMathTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -1253,0 +1253,61 @@\n+    @Test\n+    public void snapFunctionsShouldHandleExtremelyLargeValuesWithoutReturningNaN() {\n+        Stage stage = new Stage();\n+        Region region = new Region();\n+        Scene scene = new Scene(region);\n+        stage.setScene(scene);\n+\n+        \/\/ Size functions:\n+\n+        assertEquals(Double.MAX_VALUE, region.snapSizeX(Double.MAX_VALUE), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.MAX_VALUE, region.snapSizeY(Double.MAX_VALUE), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeX(-Double.MAX_VALUE), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeY(-Double.MAX_VALUE), 0.0);\n+\n+        assertEquals(Double.POSITIVE_INFINITY, region.snapSizeX(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, region.snapSizeY(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeX(Double.NEGATIVE_INFINITY), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeY(Double.NEGATIVE_INFINITY), 0.0);\n+\n+        \/\/ Space functions:\n+\n+        \/\/ These are bugged because they use Math.round instead of Math.rint, but better than Double.NaN...\n+        assertEquals(Long.MAX_VALUE, region.snapSpaceX(Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MAX_VALUE, region.snapSpaceY(Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MIN_VALUE, region.snapSpaceX(-Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MIN_VALUE, region.snapSpaceY(-Double.MAX_VALUE), 0.0);\n+\n+        assertEquals(Long.MAX_VALUE, region.snapSpaceX(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Long.MAX_VALUE, region.snapSpaceY(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Long.MIN_VALUE, region.snapSpaceX(Double.NEGATIVE_INFINITY), 0.0);\n+        assertEquals(Long.MIN_VALUE, region.snapSpaceY(Double.NEGATIVE_INFINITY), 0.0);\n+\n+        stage.setRenderScaleX(1.5);\n+        stage.setRenderScaleY(1.5);\n+\n+        \/\/ Size functions:\n+\n+        assertEquals(Double.MAX_VALUE, region.snapSizeX(Double.MAX_VALUE), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.MAX_VALUE, region.snapSizeY(Double.MAX_VALUE), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(-Double.MAX_VALUE, region.snapSizeX(-Double.MAX_VALUE), 0.0);\n+        assertEquals(-Double.MAX_VALUE, region.snapSizeY(-Double.MAX_VALUE), 0.0);\n+\n+        assertEquals(Double.POSITIVE_INFINITY, region.snapSizeX(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, region.snapSizeY(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeX(Double.NEGATIVE_INFINITY), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeY(Double.NEGATIVE_INFINITY), 0.0);\n+\n+        \/\/ Space functions:\n+\n+        \/\/ These are even more bugged, they divide the long max\/min value by scale after using the round instead of rint\n+        assertEquals(Long.MAX_VALUE \/ 1.5, region.snapSpaceX(Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MAX_VALUE \/ 1.5, region.snapSpaceY(Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MIN_VALUE \/ 1.5, region.snapSpaceX(-Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MIN_VALUE \/ 1.5, region.snapSpaceY(-Double.MAX_VALUE), 0.0);\n+\n+        assertEquals(Long.MAX_VALUE \/ 1.5, region.snapSpaceX(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Long.MAX_VALUE \/ 1.5, region.snapSpaceY(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Long.MIN_VALUE \/ 1.5, region.snapSpaceX(Double.NEGATIVE_INFINITY), 0.0);\n+        assertEquals(Long.MIN_VALUE \/ 1.5, region.snapSpaceY(Double.NEGATIVE_INFINITY), 0.0);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/RegionTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"}]}