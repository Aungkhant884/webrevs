{"files":[{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.layout;\n+\n+\/**\n+ * Math functions which deal with rounding scaled values.\n+ *\/\n+public class ScaledMath {\n+\n+    \/**\n+     * The value is floored for a given scale using Math.floor.\n+     * When the absolute value of the given value multiplied by the\n+     * current scale is less than 10^15, then this method guarantees that:\n+     *\n+     * <pre>scaledFloor(scaledFloor(value, scale), scale) == scaledFloor(value, scale)<\/pre>\n+     *\n+     * The limit is about 10^15 because double values will no longer be able to represent\n+     * larger integers with exact precision beyond this limit.\n+     *\n+     * @param value The value that needs to be floored\n+     * @param scale The scale that will be used\n+     * @return value floored with scale\n+     *\/\n+    public static double floor(double value, double scale) {\n+        double d = value * scale;\n+\n+        if (Double.isInfinite(d)) {  \/\/ Avoids returning NaN for high magnitude inputs\n+            return value;\n+        }\n+\n+        return Math.floor(d + Math.ulp(d)) \/ scale;\n+    }\n+\n+    \/**\n+     * The value is ceiled with a given scale using Math.ceil.\n+     * When the absolute value of the given value multiplied by the\n+     * current scale is less than 10^15, then this method guarantees that:\n+     *\n+     * <pre>scaledCeil(scaledCeil(value, scale), scale) == scaledCeil(value, scale)<\/pre>\n+     *\n+     * The limit is about 10^15 because double values will no longer be able to represent\n+     * larger integers with exact precision beyond this limit.\n+     *\n+     * @param value The value that needs to be ceiled\n+     * @param scale The scale that will be used\n+     * @return value ceiled with scale\n+     *\/\n+    public static double ceil(double value, double scale) {\n+        double d = value * scale;\n+\n+        if (Double.isInfinite(d)) {  \/\/ Avoids returning NaN for high magnitude inputs\n+            return value;\n+        }\n+\n+        return Math.ceil(d - Math.ulp(d)) \/ scale;\n+    }\n+\n+    \/**\n+     * The value is rounded with a given scale using {@link Math#round(double)}.\n+     *\n+     * @param value The value that needs to be rounded\n+     * @param scale The scale that will be used\n+     * @return value rounded with scale\n+     * @deprecated uses {@link Math#round(double)} instead of {@link Math#rint(double)}, don't use in new code, use {@link #rint(double, double)}\n+     *\/\n+    @Deprecated\n+    public static double round(double value, double scale) {\n+        return Math.round(value * scale) \/ scale;\n+    }\n+\n+    \/**\n+     * The value is rounded with a given scale using {@link Math#rint(double)}.\n+     *\n+     * @param value The value that needs to be rounded\n+     * @param scale The scale that will be used\n+     * @return value rounded with scale\n+     *\/\n+    public static double rint(double value, double scale) {\n+        return Math.rint(value * scale) \/ scale;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/ScaledMath.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -514,0 +514,1 @@\n+        double pixelSize = isSnapToPixel() ? 1 \/ Region.getSnapScaleX(this) : 0.0;\n@@ -515,2 +516,11 @@\n-        outer:while (Math.abs(available) > 1 && adjustingNumber > 0) {\n-            final double portion = snapPortionX(available \/ adjustingNumber); \/\/ negative in shrinking case\n+        outer:while (Math.abs(available) >= pixelSize && adjustingNumber > 0) {\n+            double portion = snapPortionX(available \/ adjustingNumber); \/\/ negative in shrinking case\n+\n+            if (portion == 0) {\n+                if (pixelSize == 0) {\n+                    break;\n+                }\n+\n+                portion = pixelSize * Math.signum(available);\n+            }\n+\n@@ -525,1 +535,1 @@\n-                if (Math.abs(available) < 1) {\n+                if (Math.abs(available) < pixelSize) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HBox.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+import com.sun.javafx.scene.layout.ScaledMath;\n@@ -213,2 +214,0 @@\n-    private static final double EPSILON = 1e-14;\n-\n@@ -264,1 +263,1 @@\n-    private static double getSnapScaleX(Node n) {\n+    static double getSnapScaleX(Node n) {\n@@ -274,1 +273,1 @@\n-    private static double getSnapScaleY(Node n) {\n+    static double getSnapScaleY(Node n) {\n@@ -292,32 +291,0 @@\n-    private static double scaledRound(double value, double scale) {\n-        return Math.round(value * scale) \/ scale;\n-    }\n-\n-    \/**\n-     * The value is floored for a given scale using Math.floor.\n-     * This method guarantees that:\n-     *\n-     * scaledFloor(scaledFloor(value, scale), scale) == scaledFloor(value, scale)\n-     *\n-     * @param value The value that needs to be floored\n-     * @param scale The scale that will be used\n-     * @return value floored with scale\n-     *\/\n-    private static double scaledFloor(double value, double scale) {\n-        return Math.floor(value * scale + EPSILON) \/ scale;\n-    }\n-\n-    \/**\n-     * The value is ceiled with a given scale using Math.ceil.\n-     * This method guarantees that:\n-     *\n-     * scaledCeil(scaledCeil(value, scale), scale) == scaledCeil(value, scale)\n-     *\n-     * @param value The value that needs to be ceiled\n-     * @param scale The scale that will be used\n-     * @return value ceiled with scale\n-     *\/\n-    private static double scaledCeil(double value, double scale) {\n-        return Math.ceil(value * scale - EPSILON) \/ scale;\n-    }\n-\n@@ -337,1 +304,1 @@\n-        return snapToPixel ? scaledRound(value, getSnapScaleX()) : value;\n+        return snapToPixel ? ScaledMath.round(value, getSnapScaleX()) : value;\n@@ -340,1 +307,1 @@\n-        return snapToPixel ? scaledRound(value, getSnapScaleY()) : value;\n+        return snapToPixel ? ScaledMath.round(value, getSnapScaleY()) : value;\n@@ -344,1 +311,1 @@\n-        return snapToPixel ? scaledRound(value, snapScale) : value;\n+        return snapToPixel ? ScaledMath.round(value, snapScale) : value;\n@@ -356,1 +323,1 @@\n-        return snapToPixel ? scaledCeil(value, getSnapScaleX()) : value;\n+        return snapToPixel ? ScaledMath.ceil(value, getSnapScaleX()) : value;\n@@ -359,1 +326,1 @@\n-        return snapToPixel ? scaledCeil(value, getSnapScaleY()) : value;\n+        return snapToPixel ? ScaledMath.ceil(value, getSnapScaleY()) : value;\n@@ -363,1 +330,1 @@\n-        return snapToPixel ? scaledCeil(value, snapScale) : value;\n+        return snapToPixel ? ScaledMath.ceil(value, snapScale) : value;\n@@ -375,1 +342,1 @@\n-        return snapToPixel ? scaledRound(value, getSnapScaleX()) : value;\n+        return snapToPixel ? ScaledMath.round(value, getSnapScaleX()) : value;\n@@ -378,1 +345,1 @@\n-        return snapToPixel ? scaledRound(value, getSnapScaleY()) : value;\n+        return snapToPixel ? ScaledMath.round(value, getSnapScaleY()) : value;\n@@ -382,1 +349,1 @@\n-        return snapToPixel ? scaledRound(value, snapScale) : value;\n+        return snapToPixel ? ScaledMath.round(value, snapScale) : value;\n@@ -387,1 +354,2 @@\n-     * ceiled (negative values) with a scale. This method guarantees that:\n+     * ceiled (negative values) with a scale. When the absolute value of the given value\n+     * multiplied by the current scale is less than 10^15, then this method guarantees that:\n@@ -389,1 +357,4 @@\n-     * snapPortionX(snapPortionX(value, snapToPixel), snapToPixel) == snapPortionX(value, snapToPixel)\n+     * <pre>snapPortionX(snapPortionX(value, snapToPixel), snapToPixel) == snapPortionX(value, snapToPixel)<\/pre>\n+     *\n+     * The limit is about 10^15 because double values will no longer be able to represent\n+     * larger integers with exact precision beyond this limit.\n@@ -397,0 +368,1 @@\n+\n@@ -398,7 +370,2 @@\n-        value *= s;\n-        if (value > 0) {\n-            value = Math.max(1, Math.floor(value + EPSILON));\n-        } else {\n-            value = Math.min(-1, Math.ceil(value - EPSILON));\n-        }\n-        return value \/ s;\n+\n+        return value > 0 ? ScaledMath.floor(value, s) : ScaledMath.ceil(value, s);\n@@ -409,1 +376,4 @@\n-     * ceiled (negative values) with a scale. This method guarantees that:\n+     * ceiled (negative values) with a scale. When the absolute value of the given value\n+     * multiplied by the current scale is less than 10^15, then this method guarantees that:\n+     *\n+     * <pre>snapPortionY(snapPortionY(value, snapToPixel), snapToPixel) == snapPortionY(value, snapToPixel)<\/pre>\n@@ -411,1 +381,2 @@\n-     * snapPortionY(snapPortionY(value, snapToPixel), snapToPixel) == snapPortionY(value, snapToPixel)\n+     * The limit is about 10^15 because double values will no longer be able to represent\n+     * larger integers with exact precision beyond this limit.\n@@ -419,0 +390,1 @@\n+\n@@ -420,7 +392,2 @@\n-        value *= s;\n-        if (value > 0) {\n-            value = Math.max(1, Math.floor(value + EPSILON));\n-        } else {\n-            value = Math.min(-1, Math.ceil(value - EPSILON));\n-        }\n-        return value \/ s;\n+\n+        return value > 0 ? ScaledMath.floor(value, s) : ScaledMath.ceil(value, s);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":30,"deletions":63,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -504,0 +504,1 @@\n+        double pixelSize = isSnapToPixel() ? 1 \/ Region.getSnapScaleY(this) : 0.0;\n@@ -505,2 +506,11 @@\n-        outer: while (Math.abs(available) > 1 && adjustingNumber > 0) {\n-            final double portion = snapPortionY(available \/ adjustingNumber); \/\/ negative in shrinking case\n+        outer: while (Math.abs(available) >= pixelSize && adjustingNumber > 0) {\n+            double portion = snapPortionY(available \/ adjustingNumber); \/\/ negative in shrinking case\n+\n+            if (portion == 0) {\n+                if (pixelSize == 0) {\n+                    break;\n+                }\n+\n+                portion = pixelSize * Math.signum(available);\n+            }\n+\n@@ -515,1 +525,1 @@\n-                if (Math.abs(available) < 1) {\n+                if (Math.abs(available) < pixelSize) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/VBox.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+--add-exports javafx.graphics\/com.sun.javafx.scene.layout=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.scene.layout;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.scene.layout.ScaledMath;\n+\n+public class ScaledMathTest {\n+    private static final double[] SCALES = new double[] {0.5, 2.0 \/ 3.0, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 4.0 \/ 3.0};\n+\n+    @Test\n+    void ceilShouldBeStable() {\n+        for (double scale : SCALES) {\n+            for (double d = 0; d < 1e13; d++, d *= 1.1) {  \/\/ larger values break down because there are not enough fractional digits anymore\n+                double expected = Math.ceil(d * scale) \/ scale;\n+\n+                assertEquals(expected, ScaledMath.ceil(d, scale), 0.0);\n+                assertEquals(expected, ScaledMath.ceil(ScaledMath.ceil(d, scale), scale), 0.0);\n+            }\n+        }\n+\n+        for (double scale : SCALES) {\n+            for (double d = 0; d > -1e13; d--, d *= 1.1) {  \/\/ larger values break down because there are not enough fractional digits anymore\n+                double expected = Math.ceil(d * scale) \/ scale;\n+\n+                assertEquals(expected, ScaledMath.ceil(d, scale), 0.0);\n+                assertEquals(expected, ScaledMath.ceil(ScaledMath.ceil(d, scale), scale), 0.0);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void floorShouldBeStable() {\n+        for (double scale : SCALES) {\n+            for (double d = 0; d < 1e13; d++, d *= 1.1) {  \/\/ larger values break down because there are not enough fractional digits anymore\n+                double expected = Math.floor(d * scale) \/ scale;\n+\n+                assertEquals(expected, ScaledMath.floor(d, scale), 0.0);\n+                assertEquals(expected, ScaledMath.floor(ScaledMath.floor(d, scale), scale), 0.0);\n+            }\n+        }\n+\n+        for (double scale : SCALES) {\n+            for (double d = 0; d > -1e13; d--, d *= 1.1) {  \/\/ larger values break down because there are not enough fractional digits anymore\n+                double expected = Math.floor(d * scale) \/ scale;\n+\n+                assertEquals(expected, ScaledMath.floor(d, scale), 0.0);\n+                assertEquals(expected, ScaledMath.floor(ScaledMath.floor(d, scale), scale), 0.0);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void ceilShouldHandleLargeMagnitudeValuesWithoutReturningNaN() {\n+        assertEquals(Double.MAX_VALUE, ScaledMath.ceil(Double.MAX_VALUE, 0.5), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.MAX_VALUE, ScaledMath.ceil(Double.MAX_VALUE, 1.0), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.MAX_VALUE, ScaledMath.ceil(Double.MAX_VALUE, 1.5), Math.ulp(Double.MAX_VALUE));\n+\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(-Double.MAX_VALUE, 0.5), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(-Double.MAX_VALUE, 1.0), 0.0);\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.ceil(-Double.MAX_VALUE, 1.5), Math.ulp(-Double.MAX_VALUE));\n+\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.ceil(Double.POSITIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.ceil(Double.POSITIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.ceil(Double.POSITIVE_INFINITY, 1.5), 0.0);\n+\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(Double.NEGATIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(Double.NEGATIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.ceil(Double.NEGATIVE_INFINITY, 1.5), 0.0);\n+    }\n+\n+    @Test\n+    void floorShouldHandleLargeMagnitudeValuesWithoutReturningNaN() {\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.MAX_VALUE, 0.5), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.MAX_VALUE, 1.0), 0.0);\n+        assertEquals(Double.MAX_VALUE, ScaledMath.floor(Double.MAX_VALUE, 1.5), Math.ulp(Double.MAX_VALUE));\n+\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.floor(-Double.MAX_VALUE, 0.5), Math.ulp(-Double.MAX_VALUE));\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.floor(-Double.MAX_VALUE, 1.0), Math.ulp(-Double.MAX_VALUE));\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.floor(-Double.MAX_VALUE, 1.5), Math.ulp(-Double.MAX_VALUE));\n+\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.POSITIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.POSITIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.floor(Double.POSITIVE_INFINITY, 1.5), 0.0);\n+\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.floor(Double.NEGATIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.floor(Double.NEGATIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.floor(Double.NEGATIVE_INFINITY, 1.5), 0.0);\n+    }\n+\n+    @Test\n+    void rintShouldHandleLargeMagnitudeValuesWithoutReturningNaN() {\n+        assertEquals(Double.MAX_VALUE, ScaledMath.rint(Double.MAX_VALUE, 0.5), 0.0);\n+        assertEquals(Double.MAX_VALUE, ScaledMath.rint(Double.MAX_VALUE, 1.0), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.rint(Double.MAX_VALUE, 1.5), 0.0);\n+\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.rint(-Double.MAX_VALUE, 0.5), 0.0);\n+        assertEquals(-Double.MAX_VALUE, ScaledMath.rint(-Double.MAX_VALUE, 1.0), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.rint(-Double.MAX_VALUE, 1.5), 0.0);\n+\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.rint(Double.POSITIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.rint(Double.POSITIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, ScaledMath.rint(Double.POSITIVE_INFINITY, 1.5), 0.0);\n+\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.rint(Double.NEGATIVE_INFINITY, 0.5), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.rint(Double.NEGATIVE_INFINITY, 1.0), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, ScaledMath.rint(Double.NEGATIVE_INFINITY, 1.5), 0.0);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/layout\/ScaledMathTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -1253,0 +1253,61 @@\n+    @Test\n+    public void snapFunctionsShouldHandleExtremelyLargeValuesWithoutReturningNaN() {\n+        Stage stage = new Stage();\n+        Region region = new Region();\n+        Scene scene = new Scene(region);\n+        stage.setScene(scene);\n+\n+        \/\/ Size functions:\n+\n+        assertEquals(Double.MAX_VALUE, region.snapSizeX(Double.MAX_VALUE), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.MAX_VALUE, region.snapSizeY(Double.MAX_VALUE), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeX(-Double.MAX_VALUE), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeY(-Double.MAX_VALUE), 0.0);\n+\n+        assertEquals(Double.POSITIVE_INFINITY, region.snapSizeX(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, region.snapSizeY(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeX(Double.NEGATIVE_INFINITY), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeY(Double.NEGATIVE_INFINITY), 0.0);\n+\n+        \/\/ Space functions:\n+\n+        \/\/ These are bugged because they use Math.round instead of Math.rint, but better than Double.NaN...\n+        assertEquals(Long.MAX_VALUE, region.snapSpaceX(Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MAX_VALUE, region.snapSpaceY(Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MIN_VALUE, region.snapSpaceX(-Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MIN_VALUE, region.snapSpaceY(-Double.MAX_VALUE), 0.0);\n+\n+        assertEquals(Long.MAX_VALUE, region.snapSpaceX(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Long.MAX_VALUE, region.snapSpaceY(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Long.MIN_VALUE, region.snapSpaceX(Double.NEGATIVE_INFINITY), 0.0);\n+        assertEquals(Long.MIN_VALUE, region.snapSpaceY(Double.NEGATIVE_INFINITY), 0.0);\n+\n+        stage.setRenderScaleX(1.5);\n+        stage.setRenderScaleY(1.5);\n+\n+        \/\/ Size functions:\n+\n+        assertEquals(Double.MAX_VALUE, region.snapSizeX(Double.MAX_VALUE), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(Double.MAX_VALUE, region.snapSizeY(Double.MAX_VALUE), Math.ulp(Double.MAX_VALUE));\n+        assertEquals(-Double.MAX_VALUE, region.snapSizeX(-Double.MAX_VALUE), 0.0);\n+        assertEquals(-Double.MAX_VALUE, region.snapSizeY(-Double.MAX_VALUE), 0.0);\n+\n+        assertEquals(Double.POSITIVE_INFINITY, region.snapSizeX(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, region.snapSizeY(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeX(Double.NEGATIVE_INFINITY), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, region.snapSizeY(Double.NEGATIVE_INFINITY), 0.0);\n+\n+        \/\/ Space functions:\n+\n+        \/\/ These are even more bugged, they divide the long max\/min value by scale after using the round instead of rint\n+        assertEquals(Long.MAX_VALUE \/ 1.5, region.snapSpaceX(Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MAX_VALUE \/ 1.5, region.snapSpaceY(Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MIN_VALUE \/ 1.5, region.snapSpaceX(-Double.MAX_VALUE), 0.0);\n+        assertEquals(Long.MIN_VALUE \/ 1.5, region.snapSpaceY(-Double.MAX_VALUE), 0.0);\n+\n+        assertEquals(Long.MAX_VALUE \/ 1.5, region.snapSpaceX(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Long.MAX_VALUE \/ 1.5, region.snapSpaceY(Double.POSITIVE_INFINITY), 0.0);\n+        assertEquals(Long.MIN_VALUE \/ 1.5, region.snapSpaceX(Double.NEGATIVE_INFINITY), 0.0);\n+        assertEquals(Long.MIN_VALUE \/ 1.5, region.snapSpaceY(Double.NEGATIVE_INFINITY), 0.0);\n+    }\n+\n@@ -1254,1 +1315,2 @@\n-    @Test public void snappingASnappedValueGivesTheSameValueTest() {\n+    @Test\n+    public void snappingASnappedValueGivesTheSameValueTest() {\n@@ -1260,1 +1322,3 @@\n-        double[] scales = new double[] {1.0, 1.25, 1.5, 1.75, 2.0, 1.374562997};\n+        double[] scales = new double[] {1.0, 1.25, 1.5, 1.75, 2.0, 1.374562997, 20.0};\n+        Random random = new Random();\n+        long seed = random.nextLong();\n@@ -1264,0 +1328,4 @@\n+        String failMessage = \"Seed was: \" + seed;\n+\n+        random.setSeed(seed);\n+\n@@ -1267,1 +1335,1 @@\n-                double value = new Random().nextDouble() * 100 - 50;\n+                double value = random.nextDouble() * Integer.MAX_VALUE;\n@@ -1270,1 +1338,1 @@\n-                assertEquals(snappedValue, snapOfSnappedValue, 1.0e-14);\n+                assertEquals(failMessage, snappedValue, snapOfSnappedValue, 0.0);\n@@ -1277,1 +1345,1 @@\n-                double value = new Random().nextDouble() * 100 - 50;\n+                double value = random.nextDouble() * Integer.MAX_VALUE;\n@@ -1280,1 +1348,1 @@\n-                assertEquals(snappedValue, snapOfSnappedValue, 1.0e-14);\n+                assertEquals(failMessage, snappedValue, snapOfSnappedValue, 0.0);\n@@ -1289,1 +1357,1 @@\n-                double value = new Random().nextDouble() * 100 - 50;\n+                double value = random.nextDouble() * Integer.MAX_VALUE;\n@@ -1292,1 +1360,1 @@\n-                assertEquals(snappedValue, snapOfSnappedValue, 1.0e-14);\n+                assertEquals(failMessage, snappedValue, snapOfSnappedValue, 0.0);\n@@ -1299,1 +1367,1 @@\n-                double value = new Random().nextDouble() * 100 - 50;\n+                double value = random.nextDouble() * Integer.MAX_VALUE;\n@@ -1302,1 +1370,1 @@\n-                assertEquals(snappedValue, snapOfSnappedValue, 1.0e-14);\n+                assertEquals(failMessage, snappedValue, snapOfSnappedValue, 0.0);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/RegionTest.java","additions":78,"deletions":10,"binary":false,"changes":88,"status":"modified"}]}