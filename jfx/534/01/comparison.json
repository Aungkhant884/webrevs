{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import com.sun.javafx.PlatformUtil;\n@@ -34,1 +33,0 @@\n-import com.sun.javafx.stage.WindowHelper;\n@@ -42,1 +40,0 @@\n-import javafx.geometry.Bounds;\n@@ -62,0 +59,3 @@\n+\n+    \/\/ listeners to focus-related state\n+    private ChangeListener<Boolean> focusListener;\n@@ -63,0 +63,1 @@\n+    private WeakChangeListener<Scene> weakSceneListener;\n@@ -64,0 +65,2 @@\n+    private WeakChangeListener<Node> weakFocusOwnerListener;\n+\n@@ -72,4 +75,1 @@\n-        handleFocusChange();\n-\n-        \/\/ Register for change events\n-        textField.focusedProperty().addListener((observable, oldValue, newValue) -> {\n+        focusListener = (observable, oldValue, newValue) -> {\n@@ -77,1 +77,3 @@\n-        });\n+        };\n+        textField.focusedProperty().addListener(focusListener);\n+        handleFocusChange();\n@@ -91,0 +93,1 @@\n+        weakFocusOwnerListener = new WeakChangeListener<Node>(focusOwnerListener);\n@@ -92,2 +95,0 @@\n-        final WeakChangeListener<Node> weakFocusOwnerListener =\n-                                new WeakChangeListener<Node>(focusOwnerListener);\n@@ -102,1 +103,1 @@\n-        textField.sceneProperty().addListener(new WeakChangeListener<Scene>(sceneListener));\n+        weakSceneListener = new WeakChangeListener<Scene>(sceneListener);\n@@ -104,0 +105,1 @@\n+        textField.sceneProperty().addListener(weakSceneListener);\n@@ -115,0 +117,5 @@\n+        getNode().focusedProperty().removeListener(focusListener);\n+        getNode().sceneProperty().removeListener(weakSceneListener);\n+        if (getNode().getScene() != null) {\n+            getNode().getScene().focusOwnerProperty().removeListener(weakFocusOwnerListener);\n+        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextFieldBehavior.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import com.sun.javafx.scene.control.inputmap.InputMap.Mapping;\n@@ -112,2 +113,0 @@\n-        textInputControl.textProperty().addListener(textListener);\n-\n@@ -303,3 +302,12 @@\n-        \/\/ Install mappings\n-        for (Object o : tmpMap.getMappings()) {\n-            map.getMappings().add((KeyMapping)o);\n+\n+        if (map == getInputMap()) {\n+            \/\/ install mappings in the top-level inputMap\n+            \/\/ as default mappings to clear them on dispose\n+            for (Mapping<?> mapping : tmpMap.getMappings()) {\n+                addDefaultMapping(map, mapping);\n+            }\n+        } else {\n+            \/\/ Install mappings in child maps\n+            for (Object o : tmpMap.getMappings()) {\n+                map.getMappings().add((KeyMapping)o);\n+            }\n@@ -308,0 +316,3 @@\n+        \/\/ temporary inputMap must be disposed to prevent memory leak\n+        tmpMap.dispose();\n+\n@@ -312,0 +323,1 @@\n+\n@@ -412,0 +424,5 @@\n+    \/\/ test-only\n+    Bidi getRawBidi() {\n+        return bidi;\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextInputControlBehavior.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import com.sun.javafx.scene.control.behavior.BehaviorBase;\n-import com.sun.javafx.scene.control.behavior.TextAreaBehavior;\n+import java.util.List;\n+\n+import com.sun.javafx.scene.control.behavior.PasswordFieldBehavior;\n+import com.sun.javafx.scene.control.behavior.TextFieldBehavior;\n@@ -31,0 +33,1 @@\n+\n@@ -47,2 +50,0 @@\n-import javafx.scene.control.Accordion;\n-import javafx.scene.control.Button;\n@@ -60,1 +61,0 @@\n-import javafx.scene.text.Text;\n@@ -62,3 +62,1 @@\n-import java.util.List;\n-import com.sun.javafx.scene.control.behavior.TextFieldBehavior;\n-import com.sun.javafx.scene.control.behavior.PasswordFieldBehavior;\n+import javafx.scene.text.Text;\n@@ -157,1 +155,1 @@\n-        control.caretPositionProperty().addListener((observable, oldValue, newValue) -> {\n+        registerChangeListener(control.caretPositionProperty(), e -> {\n@@ -222,3 +220,1 @@\n-        control.selectionProperty().addListener(observable -> {\n-            updateSelection();\n-        });\n+        registerInvalidationListener(control.selectionProperty(), e -> updateSelection());\n@@ -232,3 +228,2 @@\n-        textNode.selectionShapeProperty().addListener(observable -> {\n-            updateSelection();\n-        });\n+\n+        registerInvalidationListener(textNode.selectionShapeProperty(), e -> updateSelection());\n@@ -265,1 +260,1 @@\n-        control.fontProperty().addListener(observable -> {\n+        registerInvalidationListener(control.fontProperty(), e -> {\n@@ -276,1 +271,1 @@\n-        control.alignmentProperty().addListener(observable -> {\n+        registerInvalidationListener(control.alignmentProperty(), e -> {\n@@ -301,1 +296,1 @@\n-        control.textProperty().addListener(observable -> {\n+        registerInvalidationListener(control.textProperty(), e -> {\n@@ -312,1 +307,1 @@\n-        usePromptText.addListener(observable -> {\n+        registerInvalidationListener(usePromptText, e -> {\n@@ -394,0 +389,2 @@\n+        if (getSkinnable() == null) return;\n+        getChildren().removeAll(textGroup, handleGroup);\n@@ -924,0 +921,16 @@\n+\n+    \/\/ for testing only!\n+    Text getTextNode() {\n+        return textNode;\n+    }\n+\n+    \/\/ for testing only!\n+    Text getPromptNode() {\n+        return promptNode;\n+    }\n+\n+    \/\/ for testing only!\n+    double getTextTranslateX() {\n+        return textTranslateX.get();\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TextFieldSkin.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,8 @@\n+import java.lang.ref.WeakReference;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.sun.javafx.PlatformUtil;\n@@ -29,0 +37,1 @@\n+import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;\n@@ -31,0 +40,6 @@\n+import com.sun.javafx.tk.FontMetrics;\n+import com.sun.javafx.tk.Toolkit;\n+\n+import static com.sun.javafx.PlatformUtil.*;\n+\n+import javafx.animation.Animation.Status;\n@@ -48,0 +63,3 @@\n+import javafx.css.converter.BooleanConverter;\n+import javafx.css.converter.PaintConverter;\n+import javafx.event.EventHandler;\n@@ -72,1 +90,0 @@\n-import javafx.scene.text.HitInfo;\n@@ -75,13 +92,0 @@\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import com.sun.javafx.PlatformUtil;\n-import javafx.css.converter.BooleanConverter;\n-import javafx.css.converter.PaintConverter;\n-import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;\n-import com.sun.javafx.tk.FontMetrics;\n-import com.sun.javafx.tk.Toolkit;\n-import static com.sun.javafx.PlatformUtil.isWindows;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -167,0 +171,1 @@\n+    private EventHandler<InputMethodEvent> inputMethodTextChangedHandler;\n@@ -283,1 +288,1 @@\n-            control.focusedProperty().addListener(observable -> {\n+            registerInvalidationListener(control.focusedProperty(), observable -> {\n@@ -299,0 +304,1 @@\n+        \/\/ FIXME: JDK-8268877 - incorrectly wired handler on replacing skin\n@@ -300,3 +306,2 @@\n-            control.setOnInputMethodTextChanged(event -> {\n-                handleInputMethodEvent(event);\n-            });\n+            inputMethodTextChangedHandler = this::handleInputMethodEvent;\n+            control.setOnInputMethodTextChanged(inputMethodTextChangedHandler);\n@@ -362,0 +367,12 @@\n+    @Override\n+    public void dispose() {\n+        if (getSkinnable() == null) return;\n+        \/\/ the inputMethodEvent handler installed by this skin must be removed to prevent a memory leak\n+        \/\/ while a handler installed by the control must not be removed\n+        if (getSkinnable().getOnInputMethodTextChanged() == inputMethodTextChangedHandler) {\n+            getSkinnable().setOnInputMethodTextChanged(null);\n+        }\n+        \/\/ cleanup to guard against potential NPE\n+        getSkinnable().setInputMethodRequests(null);\n+        super.dispose();\n+    }\n@@ -769,0 +786,5 @@\n+    \/\/ for testing only!\n+    boolean isCaretBlinking() {\n+        return caretBlinking.caretTimeline.getStatus() == Status.RUNNING;\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TextInputControlSkin.java","additions":41,"deletions":19,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.control.behavior;\n+\n+import java.text.Bidi;\n+\n+\/**\n+ * Utility class to access package-private api of text related behaviors.\n+ *\/\n+public class TextBehaviorShim {\n+\n+    \/**\n+     * Returns the value of the bidi field.\n+     *\/\n+    public static Bidi getRawBidi(TextInputControlBehavior<?> behavior) {\n+        return behavior.getRawBidi();\n+    }\n+\n+    public static boolean isRTLText(TextInputControlBehavior<?> behavior) {\n+        return behavior.isRTLText();\n+    }\n+\n+    private TextBehaviorShim() {};\n+}\n","filename":"modules\/javafx.controls\/src\/shims\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextBehaviorShim.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.control.skin;\n+\n+import javafx.scene.control.TextField;\n+import javafx.scene.control.TextInputControl;\n+import javafx.scene.text.Text;\n+\n+\/**\n+ * Utility methods to access package-private api in TextInput-related skins.\n+ *\/\n+public class TextInputSkinShim {\n+\n+    \/**\n+     * Returns the promptNode from the textField's skin. The skin must be of type\n+     * TextFieldSkin.\n+     *\/\n+    public static Text getPromptNode(TextField textField) {\n+        TextFieldSkin skin = (TextFieldSkin) textField.getSkin();\n+        return skin.getPromptNode();\n+    }\n+\n+    \/**\n+     * Returns the textNode from the textField's skin. The skin must be of type\n+     * TextFieldSkin.\n+     *\/\n+    public static Text getTextNode(TextField textField) {\n+        TextFieldSkin skin = (TextFieldSkin) textField.getSkin();\n+        return skin.getTextNode();\n+    }\n+\n+    \/**\n+     * Returns the textTranslateX from the textField's skin. The skin must be of type\n+     * TextFieldSkin.\n+     *\/\n+    public static double getTextTranslateX(TextField textField) {\n+        TextFieldSkin skin = (TextFieldSkin) textField.getSkin();\n+        return skin.getTextTranslateX();\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating whether or not the control's caret is blinking.\n+     * The control's skin must be of type TextInputControlSkin.\n+     *\/\n+    public static boolean isCaretBlinking(TextInputControl control) {\n+        TextInputControlSkin<?> skin = (TextInputControlSkin<?>) control.getSkin();\n+        return skin.isCaretBlinking();\n+    }\n+\n+    private TextInputSkinShim() {}\n+}\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/skin\/TextInputSkinShim.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,4 @@\n+import com.sun.javafx.scene.control.behavior.TextFieldBehavior;\n+import com.sun.javafx.scene.control.inputmap.InputMap;\n+import com.sun.javafx.scene.control.inputmap.KeyBinding;\n+import com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n@@ -37,0 +41,1 @@\n+import static com.sun.javafx.scene.control.behavior.TextBehaviorShim.*;\n@@ -38,0 +43,1 @@\n+import static javafx.scene.control.skin.TextInputSkinShim.*;\n@@ -41,0 +47,3 @@\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Control;\n@@ -42,0 +51,1 @@\n+import javafx.scene.control.TextField;\n@@ -44,0 +54,4 @@\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.Stage;\n@@ -52,0 +66,174 @@\n+    private Scene scene;\n+    private Stage stage;\n+    private Pane root;\n+\n+\n+\/\/---------- TextField\n+\n+    @Test\n+    public void testFocusListener() {\n+        TextField control = new TextField(\"some text\");\n+        showControl(control, true);\n+        assertTrue(\"caret must be blinking if focused\", isCaretBlinking(control));\n+        Button button = new Button(\"dummy\");\n+        showControl(button, true);\n+        assertFalse(\"caret must not be blinking if not focused\", isCaretBlinking(control));\n+    }\n+\n+    @Test\n+    public void testFocusOwnerListenerRegisteredInitially() {\n+        TextField control = new TextField(\"some text\");\n+        showControl(control, true);\n+        assertEquals(\"all text selected\", control.getText(), control.getSelectedText());\n+        Button button = new Button(\"dummy\");\n+        showControl(button, true);\n+        assertEquals(\"selection cleared\", 0, control.getSelectedText().length());\n+    }\n+\n+    \/**\n+     * Tests that focusOwnerListener is re-wired as expected on changing scene\n+     * (here: by removing\/adding the textField)\n+     *\n+     * Note: this tests both sceneListener and focusOwnerListener are properly updated.\n+     *\/\n+    @Test\n+    public void testFocusOwnerListenerOnSceneChanged() {\n+        \/\/ setup: two focusable nodes, textField focused\n+        String firstWord = \"some\";\n+        String secondWord = \"text\";\n+        String text = firstWord + \" \" + secondWord;\n+        TextField control = new TextField(text);\n+        showControl(control, true);\n+        Button button = new Button(\"dummy\");\n+        showControl(button, false);\n+        control.selectNextWord();\n+        assertEquals(\"sanity: \", secondWord, control.getSelectedText());\n+        \/\/ detach textfield from scene\n+        root.getChildren().remove(control);\n+        assertEquals(\"selection unchanged after remove\", secondWord, control.getSelectedText());\n+        \/\/ change scene's focusOwner to another node\n+        Button secondButton = new Button(\"another dummy\");\n+        showControl(secondButton, true);\n+        assertEquals(\"selection unchanged after focusOwner change in old scene\",\n+                secondWord, control.getSelectedText());\n+        \/\/ re-add textField\n+        root.getChildren().add(control);\n+        control.requestFocus();\n+        assertEquals(\"selection changed on becoming scene's focusOwner\",\n+                text, control.getSelectedText());\n+    }\n+\n+    \/**\n+     * Guard against regression of JDK-8116975: activate another stage must not affect\n+     * selection of textField.\n+     *\/\n+    @Test\n+    public void testFocusOwnerListenerSecondStage() {\n+        String firstWord = \"some\";\n+        String secondWord = \"text\";\n+        String text = firstWord + \" \" + secondWord;\n+        TextField control = new TextField(text);\n+        showControl(control, true);\n+        Button button = new Button(\"dummy\");\n+        showControl(button, false);\n+        control.selectNextWord();\n+        assertEquals(\"sanity: \", secondWord, control.getSelectedText());\n+\n+        \/\/ build and activate second stage\n+        VBox secondRoot = new VBox(10, new Button(\"secondButton\"));\n+        Scene secondScene = new Scene(secondRoot);\n+        Stage secondStage = new Stage();\n+        secondStage.setScene(secondScene);\n+        secondStage.show();\n+        secondStage.requestFocus();\n+\n+        try {\n+            assertTrue(\"sanity: \", secondStage.isFocused());\n+            assertEquals(\"selection unchanged\", secondWord, control.getSelectedText());\n+            \/\/ back to first\n+            stage.requestFocus();\n+            assertTrue(\"sanity: \", stage.isFocused());\n+            assertTrue(\"sanity: \", control.isFocused());\n+            assertEquals(\"selection unchanged\", secondWord, control.getSelectedText());\n+        } finally {\n+            \/\/ cleanup\n+            secondStage.hide();\n+        }\n+    }\n+\n+\/\/---------- TextInputControl\n+\n+    @Test\n+    public void testChildMapsCleared() {\n+        TextField control = new TextField(\"some text\");\n+        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n+        InputMap<?> inputMap = behavior.getInputMap();\n+        assertFalse(\"sanity: inputMap has child maps\", inputMap.getChildInputMaps().isEmpty());\n+        behavior.dispose();\n+        assertEquals(\"default child maps must be cleared\", 0, inputMap.getChildInputMaps().size());\n+    }\n+\n+    @Test\n+    public void testDefaultMappingsCleared() {\n+        TextField control = new TextField(\"some text\");\n+        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n+        InputMap<?> inputMap = behavior.getInputMap();\n+        assertFalse(\"sanity: inputMap has mappings\", inputMap.getMappings().isEmpty());\n+        behavior.dispose();\n+        assertEquals(\"default mappings must be cleared\", 0, inputMap.getMappings().size());\n+    }\n+\n+    \/**\n+     * Sanity test: mappings to key pad keys.\n+     *\/\n+    @Test\n+    public void testKeyPadMapping() {\n+        TextField control = new TextField(\"some text\");\n+        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n+        InputMap<?> inputMap = behavior.getInputMap();\n+        \/\/ FIXME: test for all?\n+        \/\/ Here we take one of the expected only - assumption being that\n+        \/\/ if the one is properly registered, it's siblings are handled as well\n+        KeyCode expectedCode = KeyCode.KP_LEFT;\n+        KeyMapping expectedMapping = new KeyMapping(expectedCode, null);\n+        assertTrue(inputMap.getMappings().contains(expectedMapping));\n+    }\n+\n+    \/**\n+     * Sanity test: child mappings to key pad keys.\n+     *\/\n+    @Test\n+    public void testKeyPadMappingChildInputMap() {\n+        TextField control = new TextField(\"some text\");\n+        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n+        InputMap<?> inputMap = behavior.getInputMap();\n+        \/\/ FIXME: test for all?\n+        \/\/ Here we take one of the expected only - assumption being that\n+        \/\/ if the one is properly registered, its siblings are handled as well\n+        KeyCode expectedCode = KeyCode.KP_LEFT;\n+        \/\/ test os specific child mappings\n+        InputMap<?> childInputMapMac = inputMap.getChildInputMaps().get(0);\n+        KeyMapping expectedMac = new KeyMapping(new KeyBinding(expectedCode).shortcut(), null);\n+        assertTrue(childInputMapMac.getMappings().contains(expectedMac));\n+\n+        InputMap<?> childInputMapNotMac = inputMap.getChildInputMaps().get(1);\n+        KeyMapping expectedNotMac = new KeyMapping(new KeyBinding(expectedCode).ctrl(), null);\n+        assertTrue(childInputMapNotMac.getMappings().contains(expectedNotMac));\n+    }\n+\n+    \/**\n+     * Sanity test: listener to textProperty still effective after fix\n+     * (accidentally added twice)\n+     *\/\n+    @Test\n+    public void testTextPropertyListener() {\n+        TextField control = new TextField(\"some text\");\n+        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n+        assertNull(\"sanity: initial bidi\", getRawBidi(behavior));\n+        \/\/ validate bidi field\n+        isRTLText(behavior);\n+        assertNotNull(getRawBidi(behavior));\n+        control.setText(\"dummy\");\n+        assertNull(\"listener working (bidi is reset)\", getRawBidi(behavior));\n+    }\n+\n@@ -191,0 +379,35 @@\n+    \/**\n+     * Ensures the control is shown and focused in an active scenegraph.\n+     *\n+     * @param control the control to show\n+     *\/\n+    protected void showControl(Control control) {\n+        showControl(control, true);\n+    }\n+\n+    \/**\n+     * Ensures the control is shown in an active scenegraph. Requests\n+     * focus on the control if focused == true.\n+     *\n+     * @param control the control to show\n+     * @param focused if true, requests focus on the added control\n+     *\/\n+    protected void showControl(Control control, boolean focused) {\n+        if (root == null) {\n+            root = new VBox();\n+            scene = new Scene(root);\n+            stage = new Stage();\n+            stage.setScene(scene);\n+        }\n+        if (!root.getChildren().contains(control)) {\n+            root.getChildren().add(control);\n+        }\n+        stage.show();\n+        if (focused) {\n+            stage.requestFocus();\n+            control.requestFocus();\n+            assertTrue(control.isFocused());\n+            assertSame(control, scene.getFocusOwner());\n+        }\n+    }\n+\n@@ -193,0 +416,3 @@\n+        if (stage != null) {\n+            stage.hide();\n+        }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/behavior\/BehaviorCleanupTest.java","additions":227,"deletions":1,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import javafx.scene.control.TextField;\n@@ -87,1 +86,0 @@\n-                TextField.class,\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/behavior\/BehaviorMemoryLeakTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -32,0 +33,1 @@\n+import org.junit.Ignore;\n@@ -34,0 +36,2 @@\n+import com.sun.javafx.tk.Toolkit;\n+\n@@ -36,0 +40,1 @@\n+import static javafx.scene.control.skin.TextInputSkinShim.*;\n@@ -39,0 +44,3 @@\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Pos;\n@@ -40,1 +48,0 @@\n-import javafx.scene.control.skin.TabPaneSkin;\n@@ -48,0 +55,1 @@\n+import javafx.scene.control.TextField;\n@@ -52,0 +60,1 @@\n+import javafx.scene.input.InputMethodEvent;\n@@ -55,0 +64,2 @@\n+import javafx.scene.text.Font;\n+import javafx.scene.text.Text;\n@@ -66,0 +77,235 @@\n+\/\/ ----------- TextField\n+\n+    \/**\n+     * NPE from listener to caretPosition\n+     *\/\n+    @Test\n+    public void testTextFieldCaretPosition() {\n+        TextField field = new TextField(\"some text\");\n+        showControl(field, true);\n+        int index = 2;\n+        field.positionCaret(index);\n+        replaceSkin(field);\n+        field.positionCaret(index + 1);\n+    }\n+\n+    \/**\n+     * Sanity: textNode caret must be updated on change of control caret.\n+     *\/\n+    @Test\n+    public void testTextFieldCaretPositionUpdate() {\n+        TextField field = new TextField(\"some text\");\n+        showControl(field, true);\n+        Text textNode = getTextNode(field);\n+        field.positionCaret(2);\n+        assertEquals(\"textNode caret\", field.getCaretPosition(), textNode.getCaretPosition());\n+    }\n+\n+    \/**\n+     * NPE from listener to selection\n+     *\/\n+    @Test\n+    public void testTextFieldSelection() {\n+        TextField field = new TextField(\"some text\");\n+        installDefaultSkin(field);\n+        replaceSkin(field);\n+        field.selectAll();\n+    }\n+\n+    \/**\n+     * Sanity: ensure that skin's updating itself on selection change\n+     *\/\n+    @Test\n+    public void testTextFieldSelectionUpdate() {\n+        TextField field = new TextField(\"some text\");\n+        installDefaultSkin(field);\n+        Text textNode = getTextNode(field);\n+        field.selectAll();\n+        int end = field.getLength();\n+        assertEquals(\"sanity: field caret moved to end\", end, field.getCaretPosition());\n+        assertEquals(\"sanity: field selection updated\", end, field.getSelection().getEnd());\n+        assertEquals(\"textNode end\", end, textNode.getSelectionEnd());\n+    }\n+\n+    \/**\n+     * NPE on changing text: binding of text triggers internal listener to selectionShape.\n+     *\/\n+    @Test\n+    public void testTextFieldText() {\n+        TextField field = new TextField(\"some text\");\n+        installDefaultSkin(field);\n+        replaceSkin(field);\n+        field.setText(\"replaced\");\n+    }\n+\n+    \/**\n+     * NPE on changing font: binding of font triggers internal listener to selectionShape.\n+     *\/\n+    @Test\n+    public void testTextFieldFont() {\n+        TextField field = new TextField(\"some text\");\n+        installDefaultSkin(field);\n+        replaceSkin(field);\n+        field.setFont(new Font(30));\n+    }\n+\n+    \/**\n+     * NPE from listener to alignment\n+     *\/\n+    @Test\n+    public void testTextFieldAlignment() {\n+        TextField field = new TextField(\"some text\");\n+        showControl(field, true);\n+        assertTrue(field.getWidth() > 0);\n+        replaceSkin(field);\n+        field.setAlignment(Pos.TOP_RIGHT);\n+    }\n+\n+    \/**\n+     * Sanity: alignment updates still work after the fix.\n+     *\/\n+    @Test\n+    public void testTextFieldAlignmentUpdate() {\n+        \/\/ field to get the textTranslateX from\n+        TextField rightAligned = new TextField(\"dummy\");\n+        rightAligned.setPrefColumnCount(50);\n+        rightAligned.setAlignment(Pos.CENTER_RIGHT);\n+        showControl(rightAligned, true);\n+        double rightTranslate = getTextTranslateX(rightAligned);\n+        \/\/ field to test: start with left, then change to right align while showing\n+        TextField field = new TextField(\"dummy\");\n+        field.setPrefColumnCount(50);\n+        assertEquals(\"sanity: \", Pos.CENTER_LEFT, field.getAlignment());\n+        showControl(field, true);\n+        Toolkit.getToolkit().firePulse();\n+        double textTranslate = getTextTranslateX(field);\n+        assertEquals(\"sanity:\", 0, textTranslate, 1);\n+        field.setAlignment(Pos.CENTER_RIGHT);\n+        assertEquals(\"translateX must be updated\", rightTranslate, getTextTranslateX(field), 1);\n+    }\n+\n+    \/**\n+     * NPE on changing promptText: binding to promptText triggers internal listener to usePromptText.\n+     *\/\n+    @Test\n+    public void testTextFieldPrompt() {\n+        TextField field = new TextField();\n+        installDefaultSkin(field);\n+        replaceSkin(field);\n+        field.setPromptText(\"prompt\");\n+    }\n+\n+    \/**\n+     * Sanity: prompt updates still working after the fix\n+     *\/\n+    @Test\n+    public void testTextFieldPromptUpdate() {\n+        TextField field = new TextField();\n+        installDefaultSkin(field);\n+        assertNull(\"sanity: default prompt is null\", getPromptNode(field));\n+        field.setPromptText(\"prompt\");\n+        assertNotNull(\"prompt node must be created\", getPromptNode(field));\n+    }\n+\n+    @Test\n+    public void testTextFieldChildren() {\n+        TextField field = new TextField(\"some text\");\n+        installDefaultSkin(field);\n+        int children = field.getChildrenUnmodifiable().size();\n+        replaceSkin(field);\n+        assertEquals(\"children size must be unchanged: \", children, field.getChildrenUnmodifiable().size());\n+    }\n+\n+\/\/--------------- TextInputControl\n+\n+    \/**\n+     * NPE from inputMethodRequests installed by TextInputControlSkin\n+     *\n+     * Note: this is a rather artificial test - in RL the replacing\n+     * skin will set its own and there's no valid path to invoking the old\n+     *\/\n+    @Test\n+    public void testTextInputMethodRequests() {\n+        TextField field = new TextField(\"some text\");\n+        field.selectRange(2, 5);\n+        String selected = field.getSelectedText();\n+        installDefaultSkin(field);\n+        assertEquals(\"sanity: skin has set requests\", selected, field.getInputMethodRequests().getSelectedText());\n+        field.getSkin().dispose();\n+        if (field.getInputMethodRequests() != null) {\n+            assertEquals(selected, field.getInputMethodRequests().getSelectedText());\n+        }\n+    }\n+\n+    @Test\n+    public void testTextInputOnInputMethodTextChangedNoHandler() {\n+        TextField field = new TextField(\"some text\");\n+        field.setOnInputMethodTextChanged(null);\n+        installDefaultSkin(field);\n+        field.getSkin().dispose();\n+        assertNull(\"skin dispose must remove handler it has installed\", field.getOnInputMethodTextChanged());\n+    }\n+\n+    @Test\n+    public void testTextInputOnInputMethodTextChangedWithHandler() {\n+        TextField field = new TextField(\"some text\");\n+        EventHandler<? super InputMethodEvent> handler = e -> {};\n+        field.setOnInputMethodTextChanged(handler);\n+        installDefaultSkin(field);\n+        assertSame(\"sanity: skin must not replace handler\", handler, field.getOnInputMethodTextChanged());\n+        field.getSkin().dispose();\n+        assertSame(\"skin dispose must not remove handler that was installed by control\",\n+                handler, field.getOnInputMethodTextChanged());\n+    }\n+\n+    \/**\n+     * Test that skin does not remove a handler that's installed on the field\n+     * during the skin's lifetime.\n+     *\/\n+    @Test\n+    public void testTextInputOnInputMethodTextChangedReplacedHandler() {\n+        TextField field = new TextField(\"some text\");\n+        installDefaultSkin(field);\n+        EventHandler<? super InputMethodEvent> handler = e -> {};\n+        field.setOnInputMethodTextChanged(handler);\n+        field.getSkin().dispose();\n+        assertSame(\"skin dispose must not remove handler that was installed by control\",\n+                handler, field.getOnInputMethodTextChanged());\n+    }\n+\n+    \/**\n+     * Test that handler installed by skin is reset on replacing skin.\n+     * Here we test the effect by firing an inputEvent.\n+     *\/\n+    @Ignore(\"JDK-8268877\")\n+    @Test\n+    public void testTextInputOnInputMethodTextChangedEvent() {\n+        String initialText = \"some text\";\n+        String prefix = \"from input event\";\n+        TextField field = new TextField(initialText);\n+        installDefaultSkin(field);\n+        InputMethodEvent event = new InputMethodEvent(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED,\n+                List.of(), prefix, 0);\n+        Event.fireEvent(field, event);\n+        assertEquals(\"sanity: prefix must be committed\", prefix + initialText, field.getText());\n+        replaceSkin(field);\n+        Event.fireEvent(field, event);\n+        assertEquals(\" prefix must be committed again\", prefix + prefix + initialText, field.getText());\n+    }\n+\n+    \/**\n+     * Test that handler installed by skin is reset on replacing skin.\n+     * Here we test the instance of the handler.\n+     *\/\n+    @Ignore(\"JDK-8268877\")\n+    @Test\n+    public void testTextInputOnInputMethodTextChangedHandler() {\n+        TextField field = new TextField(\"some text\");\n+        installDefaultSkin(field);\n+        EventHandler<? super InputMethodEvent> handler = field.getOnInputMethodTextChanged();\n+        replaceSkin(field);\n+        assertNotSame(\"replaced skin must replace skin handler\", handler, field.getOnInputMethodTextChanged());\n+        assertNotNull(\"handler must not be null  \", field.getOnInputMethodTextChanged());\n+    }\n+\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinCleanupTest.java","additions":248,"deletions":2,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,2 +120,0 @@\n-                \/\/ @Ignore(\"8240506\")\n-                TextField.class,\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinMemoryLeakTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}