{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -961,2 +961,0 @@\n-                        oldParent.disabledProperty().removeListener(parentDisabledChangedListener);\n-                        oldParent.treeVisibleProperty().removeListener(parentTreeVisibleChangedListener);\n@@ -972,2 +970,0 @@\n-                        newParent.disabledProperty().addListener(parentDisabledChangedListener);\n-                        newParent.treeVisibleProperty().addListener(parentTreeVisibleChangedListener);\n@@ -991,1 +987,1 @@\n-                    updateTreeVisible(true);\n+                    updateTreeVisible(true, false);\n@@ -1012,4 +1008,0 @@\n-    private final InvalidationListener parentDisabledChangedListener = valueModel -> updateDisabled();\n-\n-    private final InvalidationListener parentTreeVisibleChangedListener = valueModel -> updateTreeVisible(true);\n-\n@@ -1379,1 +1371,1 @@\n-                        updateTreeVisible(false);\n+                        updateTreeVisible(false, false);\n@@ -1921,0 +1913,6 @@\n+\n+                    if (Node.this instanceof Parent parent) {\n+                        for (Node child : parent.getChildren()) {\n+                            child.updateDisabled();\n+                        }\n+                    }\n@@ -2604,1 +2602,1 @@\n-        updateTreeVisible(false);\n+        updateTreeVisible(false, true);\n@@ -6963,1 +6961,1 @@\n-                                oldClip.updateTreeVisible(false);\n+                                oldClip.updateTreeVisible(false, false);\n@@ -6969,1 +6967,1 @@\n-                                newClip.updateTreeVisible(true);\n+                                newClip.updateTreeVisible(true, false);\n@@ -8529,1 +8527,1 @@\n-    private void updateTreeVisible(boolean parentChanged) {\n+    private void updateTreeVisible(boolean parentChanged, boolean underInitialization) {\n@@ -8544,1 +8542,1 @@\n-        setTreeVisible(isTreeVisible);\n+        setTreeVisible(isTreeVisible, underInitialization);\n@@ -8551,0 +8549,9 @@\n+        setTreeVisible(value, false);\n+    }\n+\n+    \/**\n+     * When this method is called from the initializer of this class, the {@code underInitialization}\n+     * flag must be set. In this case, the calls to overridden methods are elided to prevent leaking\n+     * the partially initialized object instance to subclasses.\n+     *\/\n+    private void setTreeVisible(boolean value, boolean underInitialization) {\n@@ -8556,1 +8563,1 @@\n-                getClip().updateTreeVisible(true);\n+                getClip().updateTreeVisible(true, false);\n@@ -8562,6 +8569,13 @@\n-            if (Node.this instanceof SubScene) {\n-                Node subSceneRoot = ((SubScene)Node.this).getRoot();\n-                if (subSceneRoot != null) {\n-                    \/\/ SubScene.getRoot() is only null if it's constructor\n-                    \/\/ has not finished.\n-                    subSceneRoot.setTreeVisible(value && subSceneRoot.isVisible());\n+\n+            \/\/ We can only treat this node as an instance of a derived class after the initializer\n+            \/\/ has run to completion, as otherwise several methods of derived classes return 'null'.\n+            if (!underInitialization) {\n+                if (Node.this instanceof SubScene subScene) {\n+                    Node subSceneRoot = subScene.getRoot();\n+                    subSceneRoot.setTreeVisible(value && subSceneRoot.isVisible(), false);\n+                }\n+\n+                if (Node.this instanceof Parent parent) {\n+                    for (Node child : parent.getChildren()) {\n+                        child.updateTreeVisible(true, false);\n+                    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":37,"deletions":23,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,8 @@\n+\n+    public static boolean isTreeVisible(Node n) {\n+        return n.isTreeVisible();\n+    }\n+\n+    public static void setTreeVisible(Node n, boolean visible) {\n+        n.setTreeVisible(visible);\n+    }\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/NodeShim.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -127,2 +127,0 @@\n-        \/\/ Test that a disabled Group affects the disabled property of child nodes\n-\n@@ -2026,0 +2024,32 @@\n+\n+    @Test\n+    public void disabledFlagUpdatesChildrenDisabledFlag() {\n+        var g = new Group();\n+        var n1 = new Rectangle();\n+        var n2 = new Rectangle();\n+        g.getChildren().addAll(n1, n2);\n+        assertFalse(g.isDisabled());\n+        assertFalse(n2.isDisabled());\n+        assertFalse(n2.isDisabled());\n+\n+        g.setDisable(true);\n+        assertTrue(g.isDisabled());\n+        assertTrue(n2.isDisabled());\n+        assertTrue(n2.isDisabled());\n+    }\n+\n+    @Test\n+    public void treeVisibleFlagUpdatesChildrenTreeVisibleFlag() {\n+        var g = new Group();\n+        var n1 = new Rectangle();\n+        var n2 = new Rectangle();\n+        g.getChildren().addAll(n1, n2);\n+        assertTrue(NodeShim.isTreeVisible(g));\n+        assertTrue(NodeShim.isTreeVisible(n1));\n+        assertTrue(NodeShim.isTreeVisible(n2));\n+\n+        NodeShim.setTreeVisible(g, false);\n+        assertFalse(NodeShim.isTreeVisible(g));\n+        assertFalse(NodeShim.isTreeVisible(n1));\n+        assertFalse(NodeShim.isTreeVisible(n2));\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/NodeTest.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"}]}