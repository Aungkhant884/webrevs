{"files":[{"patch":"@@ -430,0 +430,1 @@\n+        treeItemAtStartEdit = null;\n@@ -459,0 +460,1 @@\n+        treeItemAtStartEdit = null;\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeCell.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.ref.WeakReference;\n@@ -36,0 +37,2 @@\n+import com.sun.javafx.tk.Toolkit;\n+\n@@ -38,0 +41,1 @@\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n@@ -52,0 +56,1 @@\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n@@ -757,0 +762,1 @@\n+        Toolkit.getToolkit().firePulse();\n@@ -771,0 +777,21 @@\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(1, events.size());\n+        assertEquals(\"editing location of cancel event\", editingItem, events.get(0).getTreeItem());\n+    }\n+\n+    \/**\n+     * Test that removing the editing item implicitly cancels an ongoing\n+     * edit and fires a correct cancel event.\n+     *\/\n+    @Test\n+    public void testEditCancelEventAfterRemoveEditingItem() {\n+        stageLoader = new StageLoader(tree);\n+        tree.setEditable(true);\n+        int editingIndex = 2;\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        List<EditEvent<String>> events = new ArrayList<>();\n+        tree.setOnEditCancel(events::add);\n+        root.getChildren().remove(editingItem);\n+        Toolkit.getToolkit().firePulse();\n+        assertNull(\"removing item must cancel edit on tree\", tree.getEditingItem());\n@@ -775,0 +802,45 @@\n+    \/**\n+     * Test that removing the editing item does not cause a memory leak.\n+     *\/\n+    @Test\n+    public void testEditCancelMemoryLeakAfterRemoveEditingItem() {\n+        stageLoader = new StageLoader(tree);\n+        tree.setEditable(true);\n+        \/\/ the item to test for being gc'ed\n+        TreeItem<String> editingItem = new TreeItem<>(\"added\");\n+        WeakReference<TreeItem<?>> itemRef = new WeakReference<>(editingItem);\n+        root.getChildren().add(0, editingItem);\n+        Toolkit.getToolkit().firePulse();\n+        tree.edit(editingItem);\n+        root.getChildren().remove(editingItem);\n+        Toolkit.getToolkit().firePulse();\n+        assertNull(\"removing item must cancel edit on tree\", tree.getEditingItem());\n+        editingItem = null;\n+        attemptGC(itemRef);\n+        assertEquals(\"treeItem must be gc'ed\", null, itemRef.get());\n+    }\n+\n+    \/**\n+     * Test that removing a committed editing item does not cause a memory leak.\n+     *\/\n+    @Test\n+    public void testEditCommitMemoryLeakAfterRemoveEditingItem() {\n+        stageLoader = new StageLoader(tree);\n+        tree.setEditable(true);\n+        \/\/ the item to test for being gc'ed\n+        TreeItem<String> editingItem = new TreeItem<>(\"added\");\n+        WeakReference<TreeItem<?>> itemRef = new WeakReference<>(editingItem);\n+        root.getChildren().add(0, editingItem);\n+        int editingIndex = tree.getRow(editingItem);\n+        Toolkit.getToolkit().firePulse();\n+        tree.edit(editingItem);\n+        TreeCell<String> editingCell = (TreeCell<String>) VirtualFlowTestUtils.getCell(tree, editingIndex);\n+        editingCell.commitEdit(\"added changed\");\n+        root.getChildren().remove(editingItem);\n+        Toolkit.getToolkit().firePulse();\n+        assertNull(\"removing item must cancel edit on tree\", tree.getEditingItem());\n+        editingItem = null;\n+        attemptGC(itemRef);\n+        assertEquals(\"treeItem must be gc'ed\", null, itemRef.get());\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeCellTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"}]}