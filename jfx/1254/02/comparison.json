{"files":[{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -44,2 +43,2 @@\n-    public ColorPickerBehavior(final ColorPicker colorPicker) {\n-        super(colorPicker);\n+    public ColorPickerBehavior(ColorPicker c) {\n+        super(c);\n@@ -57,1 +56,1 @@\n-        if (!popup.isShowing() && getNode().isShowing()) {\n+        if (!popup.isShowing() && getControl().isShowing()) {\n@@ -60,1 +59,1 @@\n-            getNode().hide();\n+            getControl().hide();\n@@ -64,1 +63,1 @@\n-        if (!getNode().isShowing()) {\n+        if (!getControl().isShowing()) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/ColorPickerBehavior.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n-\n@@ -32,1 +30,0 @@\n-import javafx.event.EventHandler;\n@@ -40,0 +37,6 @@\n+import javafx.scene.control.behavior.BehaviorBase;\n+import javafx.scene.control.behavior.KeyBinding;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n@@ -41,7 +44,0 @@\n-import javafx.scene.input.*;\n-import com.sun.javafx.scene.control.inputmap.KeyBinding;\n-\n-import static javafx.scene.input.KeyCode.*;\n-import static javafx.scene.input.KeyEvent.*;\n-import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n-import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;\n@@ -51,1 +47,0 @@\n-    private final InputMap<ComboBoxBase<T>> inputMap;\n@@ -65,31 +60,3 @@\n-    public ComboBoxBaseBehavior(final ComboBoxBase<T> comboBox) {\n-        super(comboBox);\n-\n-        \/\/ create a map for comboBox-specific mappings (this reuses the default\n-        \/\/ InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)\n-        inputMap = createInputMap();\n-\n-        final EventHandler<KeyEvent> togglePopup = e -> {\n-            \/\/ If popup is shown, KeyEvent causes popup to close\n-            showPopupOnMouseRelease = true;\n-\n-            if (getNode().isShowing()) hide();\n-            else show();\n-        };\n-\n-        \/\/ comboBox-specific mappings for key and mouse input\n-        KeyMapping enterPressed, enterReleased;\n-        addDefaultMapping(inputMap,\n-            new KeyMapping(F4, KEY_RELEASED, togglePopup),\n-            new KeyMapping(new KeyBinding(UP).alt(), togglePopup),\n-            new KeyMapping(new KeyBinding(DOWN).alt(), togglePopup),\n-\n-            new KeyMapping(SPACE, KEY_PRESSED, this::keyPressed),\n-            new KeyMapping(SPACE, KEY_RELEASED, this::keyReleased),\n-\n-            enterPressed = new KeyMapping(ENTER, KEY_PRESSED, this::keyPressed),\n-            enterReleased = new KeyMapping(ENTER, KEY_RELEASED, this::keyReleased),\n-\n-            \/\/ The following keys are forwarded to the parent container\n-            new KeyMapping(ESCAPE, KEY_PRESSED, this::cancelEdit),\n-            new KeyMapping(F10,    KEY_PRESSED, this::forwardToParent),\n+    public ComboBoxBaseBehavior(ComboBoxBase<T> c) {\n+        super(c);\n+    }\n@@ -97,5 +64,8 @@\n-            new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),\n-            new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),\n-            new MouseMapping(MouseEvent.MOUSE_ENTERED, this::mouseEntered),\n-            new MouseMapping(MouseEvent.MOUSE_EXITED, this::mouseExited)\n-        );\n+    @Override\n+    public void install() {\n+        addHandler(KeyBinding.with(KeyCode.SPACE).build(), true, this::keyPressed);\n+        addHandler(KeyBinding.withRelease(KeyCode.SPACE).build(), true, this::keyReleased);\n+        addHandler(KeyBinding.with(KeyCode.ENTER).build(), false, this::keyPressed);\n+        addHandler(KeyBinding.withRelease(KeyCode.ENTER).build(), false, this::keyReleased);\n+        addHandler(KeyBinding.with(KeyCode.ESCAPE).build(), true, this::cancelEdit);\n+        addHandler(KeyBinding.with(KeyCode.F10).build(), true, this::forwardToParent);\n@@ -103,3 +73,4 @@\n-        \/\/ we don't want to consume events on enter press - let them carry on through\n-        enterPressed.setAutoConsume(false);\n-        enterReleased.setAutoConsume(false);\n+        addHandler(MouseEvent.MOUSE_PRESSED, this::mousePressed);\n+        addHandler(MouseEvent.MOUSE_RELEASED, this::mouseReleased);\n+        addHandler(MouseEvent.MOUSE_ENTERED, this::mouseEntered);\n+        addHandler(MouseEvent.MOUSE_EXITED, this::mouseExited);\n@@ -108,1 +79,1 @@\n-        comboBox.focusedProperty().addListener(focusListener);\n+        getControl().focusedProperty().addListener(focusListener);\n@@ -112,1 +83,1 @@\n-            tlFocus = new TwoLevelFocusComboBehavior(comboBox); \/\/ needs to be last.\n+            tlFocus = new TwoLevelFocusComboBehavior(getControl()); \/\/ needs to be last.\n@@ -114,0 +85,6 @@\n+\n+        registerFunction(ComboBoxBase.TOGGLE_POPUP, this::togglePopup);\n+\n+        registerKey(KeyBinding.withRelease(KeyCode.F4).build(), ComboBoxBase.TOGGLE_POPUP);\n+        registerKey(KeyBinding.alt(KeyCode.DOWN), ComboBoxBase.TOGGLE_POPUP);\n+        registerKey(KeyBinding.alt(KeyCode.UP), ComboBoxBase.TOGGLE_POPUP);\n@@ -118,1 +95,1 @@\n-        getNode().focusedProperty().removeListener(focusListener);\n+        getControl().focusedProperty().removeListener(focusListener);\n@@ -122,4 +99,0 @@\n-    @Override public InputMap<ComboBoxBase<T>> getInputMap() {\n-        return inputMap;\n-    }\n-\n@@ -135,1 +108,1 @@\n-        final ComboBoxBase<T> box = getNode();\n+        final ComboBoxBase<T> box = getControl();\n@@ -172,1 +145,1 @@\n-            if (! getNode().isPressed() && ! getNode().isArmed()) {\n+            if (! getControl().isPressed() && ! getControl().isArmed()) {\n@@ -174,1 +147,1 @@\n-                getNode().arm();\n+                getControl().arm();\n@@ -190,2 +163,2 @@\n-                if (getNode().isArmed()) {\n-                    getNode().disarm();\n+                if (getControl().isArmed()) {\n+                    getControl().disarm();\n@@ -198,2 +171,2 @@\n-        if (getNode().getParent() != null) {\n-            getNode().getParent().fireEvent(event);\n+        if (getControl().getParent() != null) {\n+            getControl().getParent().fireEvent(event);\n@@ -208,1 +181,1 @@\n-        ComboBoxBase comboBoxBase = getNode();\n+        ComboBoxBase comboBoxBase = getControl();\n@@ -251,1 +224,1 @@\n-        if (!getNode().isEditable()) {\n+        if (!getControl().isEditable()) {\n@@ -277,2 +250,2 @@\n-        if (! getNode().isArmed() && valid) {\n-            getNode().arm();\n+        if (! getControl().isArmed() && valid) {\n+            getControl().arm();\n@@ -283,3 +256,3 @@\n-        if (! getNode().isShowing()) {\n-            if (getNode().isFocusTraversable()) {\n-                getNode().requestFocus();\n+        if (! getControl().isShowing()) {\n+            if (getControl().isFocusTraversable()) {\n+                getControl().requestFocus();\n@@ -287,1 +260,1 @@\n-            getNode().show();\n+            getControl().show();\n@@ -292,2 +265,2 @@\n-        if (getNode().isShowing()) {\n-            getNode().hide();\n+        if (getControl().isShowing()) {\n+            getControl().hide();\n@@ -310,2 +283,2 @@\n-        if (getNode().isPressed()) {\n-            getNode().arm();\n+        if (getControl().isPressed()) {\n+            getControl().arm();\n@@ -316,2 +289,2 @@\n-        if (! keyDown && getNode().isArmed()) {\n-            getNode().disarm();\n+        if (! keyDown && getControl().isArmed()) {\n+            getControl().disarm();\n@@ -321,0 +294,10 @@\n+    private void togglePopup() {\n+        \/\/ If popup is shown, KeyEvent causes popup to close\n+        showPopupOnMouseRelease = true;\n+\n+        if (getControl().isShowing()) {\n+            hide();\n+        } else {\n+            show();\n+        }\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/ComboBoxBaseBehavior.java","additions":62,"deletions":79,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,1 @@\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n-\n-import static javafx.scene.input.KeyCode.DOWN;\n-import static javafx.scene.input.KeyCode.UP;\n+import javafx.scene.input.KeyCode;\n@@ -47,2 +44,10 @@\n-    public ComboBoxListViewBehavior(final ComboBox<T> comboBox) {\n-        super(comboBox);\n+    public ComboBoxListViewBehavior(ComboBoxBase<T> c) {\n+        super(c);\n+    }\n+\n+    @Override\n+    public void install() {\n+        super.install();\n+\n+        registerFunction(ComboBox.SELECT_PREV, this::selectPrevious);\n+        registerFunction(ComboBox.SELECT_NEXT, this::selectNext);\n@@ -50,7 +55,2 @@\n-        \/\/ Add these bindings as a child input map, so they take precedence\n-        InputMap<ComboBoxBase<T>> comboBoxListViewInputMap = new InputMap<>(comboBox);\n-        comboBoxListViewInputMap.getMappings().addAll(\n-            new InputMap.KeyMapping(UP, e -> selectPrevious()),\n-            new InputMap.KeyMapping(DOWN, e -> selectNext())\n-        );\n-        addDefaultChildMap(getInputMap(), comboBoxListViewInputMap);\n+        registerKey(KeyCode.UP, ComboBox.SELECT_PREV);\n+        registerKey(KeyCode.DOWN, ComboBox.SELECT_NEXT);\n@@ -66,1 +66,1 @@\n-        return (ComboBox<T>) getNode();\n+        return (ComboBox<T>) getControl();\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/ComboBoxListViewBehavior.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.time.LocalDate;\n@@ -31,2 +32,0 @@\n-import java.time.LocalDate;\n-\n@@ -45,2 +44,2 @@\n-    public DatePickerBehavior(final DatePicker datePicker) {\n-        super(datePicker);\n+    public DatePickerBehavior(DatePicker c) {\n+        super(c);\n@@ -59,1 +58,1 @@\n-        if (!popup.isShowing() && getNode().isShowing()) {\n+        if (!popup.isShowing() && getControl().isShowing()) {\n@@ -62,1 +61,1 @@\n-            getNode().hide();\n+            getControl().hide();\n@@ -66,1 +65,1 @@\n-        if (!getNode().isShowing()) {\n+        if (!getControl().isShowing()) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/DatePickerBehavior.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -140,0 +140,8 @@\n+    \/**\n+     * Calls the focus traversal engine and indicates that traversal should\n+     * go the next focusTraversable Node in the focus traversal cycle.\n+     *\/\n+    public static final void traverseNext(Node n) {\n+        traverse(n, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n+    }\n+\n@@ -148,0 +156,8 @@\n+    \/**\n+     * Calls the focus traversal engine and indicates that traversal should\n+     * go the previous focusTraversable Node in the focus traversal cycle.\n+     *\/\n+    public static final void traversePrevious(Node n) {\n+        traverse(n, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/FocusTraversalInputMap.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.scene.control.skin.TextFieldSkin;\n@@ -36,2 +37,2 @@\n-    public PasswordFieldBehavior(PasswordField passwordField) {\n-        super(passwordField);\n+    public PasswordFieldBehavior(PasswordField c, TextFieldSkin skin) {\n+        super(c, skin);\n@@ -60,1 +61,1 @@\n-        getNode().selectAll();\n+        getControl().selectAll();\n@@ -62,1 +63,0 @@\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/PasswordFieldBehavior.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import com.sun.javafx.PlatformUtil;\n-import com.sun.javafx.scene.control.Properties;\n-import javafx.scene.control.skin.TextAreaSkin;\n@@ -36,1 +33,4 @@\n-import com.sun.javafx.scene.control.skin.Utils;\n+import javafx.scene.control.behavior.KeyBinding;\n+import javafx.scene.control.skin.TextAreaSkin;\n+import javafx.scene.control.skin.TextInputControlSkin.Direction;\n+import javafx.scene.control.skin.TextInputControlSkin.TextUnit;\n@@ -38,3 +38,1 @@\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n-import com.sun.javafx.scene.control.inputmap.KeyBinding;\n-import javafx.scene.input.KeyEvent;\n+import javafx.scene.input.KeyCode;\n@@ -46,8 +44,3 @@\n-\n-import java.util.function.Predicate;\n-\n-import static com.sun.javafx.PlatformUtil.isMac;\n-import static com.sun.javafx.PlatformUtil.isWindows;\n-import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;\n-import static javafx.scene.control.skin.TextInputControlSkin.Direction;\n-import static javafx.scene.input.KeyCode.*;\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.scene.control.Properties;\n+import com.sun.javafx.scene.control.skin.Utils;\n@@ -60,1 +53,1 @@\n-    private TextAreaSkin skin;\n+    private final TextAreaSkin skin;\n@@ -69,1 +62,1 @@\n-    public TextAreaBehavior(final TextArea c) {\n+    public TextAreaBehavior(TextArea c, TextAreaSkin skin) {\n@@ -71,1 +64,1 @@\n-\n+        this.skin = skin;\n@@ -75,0 +68,5 @@\n+    }\n+\n+    @Override\n+    public void install() {\n+        super.install();\n@@ -76,62 +74,1 @@\n-        \/\/ some of the mappings are only valid when the control is editable, or\n-        \/\/ only on certain platforms, so we create the following predicates that filters out the mapping when the\n-        \/\/ control is not in the correct state \/ on the correct platform\n-        final Predicate<KeyEvent> validWhenEditable = e -> !c.isEditable();\n-\n-        \/\/ Add these bindings as a child input map, so they take precedence\n-        InputMap<TextArea> textAreaInputMap = new InputMap<>(c);\n-        textAreaInputMap.getMappings().addAll(\n-            keyMapping(HOME,      e -> lineStart(false)),\n-            keyMapping(END,       e -> lineEnd(false)),\n-            keyMapping(UP,        e -> skin.moveCaret(TextUnit.LINE, Direction.UP,   false)),\n-            keyMapping(DOWN,      e -> skin.moveCaret(TextUnit.LINE, Direction.DOWN, false)),\n-            keyMapping(PAGE_UP,   e -> skin.moveCaret(TextUnit.PAGE, Direction.UP,   false)),\n-            keyMapping(PAGE_DOWN, e -> skin.moveCaret(TextUnit.PAGE, Direction.DOWN, false)),\n-\n-            keyMapping(new KeyBinding(HOME).shift(),      e -> lineStart(true)),\n-            keyMapping(new KeyBinding(END).shift(),       e -> lineEnd(true)),\n-            keyMapping(new KeyBinding(UP).shift(),        e -> skin.moveCaret(TextUnit.LINE, Direction.UP,   true)),\n-            keyMapping(new KeyBinding(DOWN).shift(),      e -> skin.moveCaret(TextUnit.LINE, Direction.DOWN, true)),\n-            keyMapping(new KeyBinding(PAGE_UP).shift(),   e -> skin.moveCaret(TextUnit.PAGE, Direction.UP,   true)),\n-            keyMapping(new KeyBinding(PAGE_DOWN).shift(), e -> skin.moveCaret(TextUnit.PAGE, Direction.DOWN, true)),\n-\n-            \/\/ editing-only mappings\n-            keyMapping(new KeyBinding(ENTER), e -> insertNewLine(), validWhenEditable),\n-            keyMapping(new KeyBinding(TAB), e -> insertTab(), validWhenEditable)\n-        );\n-        addDefaultChildMap(getInputMap(), textAreaInputMap);\n-\n-        \/\/ mac os specific mappings\n-        InputMap<TextArea> macOsInputMap = new InputMap<>(c);\n-        macOsInputMap.setInterceptor(e -> !PlatformUtil.isMac());\n-        macOsInputMap.getMappings().addAll(\n-            \/\/ Mac OS specific mappings\n-            keyMapping(new KeyBinding(LEFT).shortcut(),  e -> lineStart(false)),\n-            keyMapping(new KeyBinding(RIGHT).shortcut(), e -> lineEnd(false)),\n-            keyMapping(new KeyBinding(UP).shortcut(),    e -> c.home()),\n-            keyMapping(new KeyBinding(DOWN).shortcut(),  e -> c.end()),\n-\n-            keyMapping(new KeyBinding(LEFT).shortcut().shift(),  e -> lineStart(true)),\n-            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -> lineEnd(true)),\n-            keyMapping(new KeyBinding(UP).shortcut().shift(),    e -> selectHomeExtend()),\n-            keyMapping(new KeyBinding(DOWN).shortcut().shift(),  e -> selectEndExtend()),\n-\n-            keyMapping(new KeyBinding(UP).alt(),           e -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   false)),\n-            keyMapping(new KeyBinding(DOWN).alt(),         e -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, false)),\n-            keyMapping(new KeyBinding(UP).alt().shift(),   e -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   true)),\n-            keyMapping(new KeyBinding(DOWN).alt().shift(), e -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, true))\n-        );\n-        addDefaultChildMap(textAreaInputMap, macOsInputMap);\n-\n-        \/\/ windows \/ linux specific mappings\n-        InputMap<TextArea> nonMacOsInputMap = new InputMap<>(c);\n-        nonMacOsInputMap.setInterceptor(e -> PlatformUtil.isMac());\n-        nonMacOsInputMap.getMappings().addAll(\n-            keyMapping(new KeyBinding(UP).ctrl(),           e -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   false)),\n-            keyMapping(new KeyBinding(DOWN).ctrl(),         e -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, false)),\n-            keyMapping(new KeyBinding(UP).ctrl().shift(),   e -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   true)),\n-            keyMapping(new KeyBinding(DOWN).ctrl().shift(), e -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, true))\n-        );\n-        addDefaultChildMap(textAreaInputMap, nonMacOsInputMap);\n-\n-        addKeyPadMappings(textAreaInputMap);\n+        TextArea c = getControl();\n@@ -147,0 +84,62 @@\n+\n+        \/\/ functions\n+        registerFunction(TextArea.DOCUMENT_END, c::end); \/\/ TODO move end() to behavior\n+        registerFunction(TextArea.DOCUMENT_START, c::home); \/\/ TODO move home() to behavior\n+        registerFunction(TextArea.DOWN, () -> skin.moveCaret(TextUnit.LINE, Direction.DOWN, false));\n+        registerFunction(TextArea.LINE_START, () -> lineStart(false));\n+        registerFunction(TextArea.LINE_END, () -> lineEnd(false));\n+        registerFunction(TextArea.PARAGRAPH_DOWN, () -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, false));\n+        registerFunction(TextArea.PARAGRAPH_UP, () -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP, false));\n+        registerFunction(TextArea.PAGE_DOWN, () -> skin.moveCaret(TextUnit.PAGE, Direction.DOWN, false));\n+        registerFunction(TextArea.PAGE_UP, () -> skin.moveCaret(TextUnit.PAGE, Direction.UP, false));\n+        registerFunction(TextArea.SELECT_DOWN, () -> skin.moveCaret(TextUnit.LINE, Direction.DOWN, true));\n+        \/\/func(TextArea.SELECT_END_EXTEND, this::selectEndExtend);\n+        \/\/func(TextArea.SELECT_HOME_EXTEND, this::selectHomeExtend);\n+        registerFunction(TextArea.SELECT_LINE_END, () -> lineEnd(true));\n+        registerFunction(TextArea.SELECT_PAGE_DOWN, () -> skin.moveCaret(TextUnit.PAGE, Direction.DOWN, true));\n+        registerFunction(TextArea.SELECT_PAGE_UP, () -> skin.moveCaret(TextUnit.PAGE, Direction.UP, true));\n+        registerFunction(TextArea.SELECT_PARAGRAPH_DOWN, () -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, true));\n+        registerFunction(TextArea.SELECT_PARAGRAPH_UP, () -> skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP, true));\n+        registerFunction(TextArea.SELECT_LINE_START, () -> lineStart(true));\n+        registerFunction(TextArea.SELECT_UP, () -> skin.moveCaret(TextUnit.LINE, Direction.UP, true));\n+        registerFunction(TextArea.UP, () -> skin.moveCaret(TextUnit.LINE, Direction.UP, false));\n+        registerFunction(TextArea.INSERT_NEW_LINE, this::insertNewLine);\n+        registerFunction(TextArea.INSERT_TAB, this::insertTab);\n+\n+        \/\/ common keys\n+        registerKey(KeyCode.DOWN, TextArea.DOWN);\n+        registerKey(KeyBinding.shift(KeyCode.DOWN), TextArea.SELECT_DOWN);\n+        registerKey(KeyBinding.shift(KeyCode.END), TextArea.SELECT_LINE_END);\n+        registerKey(KeyCode.END, TextArea.LINE_END);\n+        registerKey(KeyCode.ENTER, TextArea.INSERT_NEW_LINE);\n+        registerKey(KeyCode.HOME, TextArea.LINE_START);\n+        registerKey(KeyBinding.shift(KeyCode.HOME), TextArea.SELECT_LINE_START);\n+        registerKey(KeyCode.PAGE_UP, TextArea.PAGE_UP);\n+        registerKey(KeyBinding.shift(KeyCode.PAGE_UP), TextArea.SELECT_PAGE_UP);\n+        registerKey(KeyCode.PAGE_DOWN, TextArea.PAGE_DOWN);\n+        registerKey(KeyBinding.shift(KeyCode.PAGE_DOWN), TextArea.SELECT_PAGE_DOWN);\n+        registerKey(KeyCode.TAB, TextArea.INSERT_TAB);\n+        registerKey(KeyCode.UP, TextArea.UP);\n+        registerKey(KeyBinding.shift(KeyCode.UP), TextArea.SELECT_UP);\n+\n+        \/\/ macOS specific mappings\n+        registerKey(KeyBinding.with(KeyCode.DOWN).alt().forMac().build(), TextArea.PARAGRAPH_DOWN);\n+        registerKey(KeyBinding.with(KeyCode.DOWN).alt().shift().forMac().build(), TextArea.SELECT_PARAGRAPH_DOWN);\n+        registerKey(KeyBinding.with(KeyCode.DOWN).shortcut().forMac().build(), TextArea.DOCUMENT_END);\n+        registerKey(KeyBinding.with(KeyCode.DOWN).shortcut().shift().forMac().build(), TextArea.SELECT_END_EXTEND);\n+        registerKey(KeyBinding.with(KeyCode.LEFT).shortcut().forMac().build(), TextArea.LINE_START);\n+        registerKey(KeyBinding.with(KeyCode.LEFT).shortcut().shift().forMac().build(), TextArea.SELECT_LINE_START);\n+        registerKey(KeyBinding.with(KeyCode.RIGHT).shortcut().forMac().build(), TextArea.LINE_END);\n+        registerKey(KeyBinding.with(KeyCode.RIGHT).shortcut().shift().forMac().build(), TextArea.SELECT_LINE_END);\n+        registerKey(KeyBinding.with(KeyCode.UP).alt().forMac().build(), TextArea.PARAGRAPH_UP);\n+        registerKey(KeyBinding.with(KeyCode.UP).alt().shift().forMac().build(), TextArea.SELECT_PARAGRAPH_UP);\n+        registerKey(KeyBinding.with(KeyCode.UP).shortcut().forMac().build(), TextArea.DOCUMENT_START);\n+        registerKey(KeyBinding.with(KeyCode.UP).shortcut().shift().forMac().build(), TextArea.SELECT_HOME_EXTEND);\n+\n+        \/\/ non-macOS specific mappings\n+        registerKey(KeyBinding.with(KeyCode.DOWN).control().notForMac().build(), TextArea.PARAGRAPH_DOWN);\n+        registerKey(KeyBinding.with(KeyCode.DOWN).control().shift().notForMac().build(), TextArea.SELECT_PARAGRAPH_DOWN);\n+        registerKey(KeyBinding.with(KeyCode.UP).control().notForMac().build(), TextArea.PARAGRAPH_UP);\n+        registerKey(KeyBinding.with(KeyCode.UP).control().shift().notForMac().build(), TextArea.SELECT_PARAGRAPH_UP);\n+\n+        addKeyPadMappings();\n@@ -149,3 +148,6 @@\n-    @Override public void dispose() {\n-        getNode().focusedProperty().removeListener(focusListener);\n-        if (tlFocus != null) tlFocus.dispose();\n+    @Override\n+    public void dispose() {\n+        getControl().focusedProperty().removeListener(focusListener);\n+        if (tlFocus != null) {\n+            tlFocus.dispose();\n+        }\n@@ -169,1 +171,1 @@\n-        final TextArea textArea = getNode();\n+        final TextArea textArea = getControl();\n@@ -181,5 +183,0 @@\n-    \/\/ An unholy back-reference!\n-    public void setTextAreaSkin(TextAreaSkin skin) {\n-        this.skin = skin;\n-    }\n-\n@@ -187,3 +184,5 @@\n-        setEditing(true);\n-        getNode().replaceSelection(\"\\n\");\n-        setEditing(false);\n+        if (isEditable()) {\n+            setEditing(true);\n+            getControl().replaceSelection(\"\\n\");\n+            setEditing(false);\n+        }\n@@ -193,3 +192,5 @@\n-        setEditing(true);\n-        getNode().replaceSelection(\"\\t\");\n-        setEditing(false);\n+        if (isEditable()) {\n+            setEditing(true);\n+            getControl().replaceSelection(\"\\t\");\n+            setEditing(false);\n+        }\n@@ -200,1 +201,1 @@\n-            getNode().deletePreviousChar();\n+            getControl().deletePreviousChar();\n@@ -202,1 +203,1 @@\n-            getNode().deleteNextChar();\n+            getControl().deleteNextChar();\n@@ -207,1 +208,1 @@\n-        TextArea textArea = getNode();\n+        TextArea textArea = getControl();\n@@ -228,1 +229,1 @@\n-        getNode().replaceText(start, end, txt);\n+        getControl().replaceText(start, end, txt);\n@@ -240,1 +241,1 @@\n-        TextArea textArea = getNode();\n+        TextArea textArea = getControl();\n@@ -293,1 +294,1 @@\n-                    if (isMac()) {\n+                    if (PlatformUtil.isMac()) {\n@@ -310,1 +311,1 @@\n-        final TextArea textArea = getNode();\n+        final TextArea textArea = getControl();\n@@ -324,1 +325,1 @@\n-        final TextArea textArea = getNode();\n+        final TextArea textArea = getControl();\n@@ -339,1 +340,1 @@\n-        final TextArea textArea = getNode();\n+        final TextArea textArea = getControl();\n@@ -363,2 +364,2 @@\n-                    Point2D p = getNode().localToScene(menuPos);\n-                    Scene scene = getNode().getScene();\n+                    Point2D p = getControl().localToScene(menuPos);\n+                    Scene scene = getControl().getScene();\n@@ -381,3 +382,3 @@\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n-                contextMenu.show(getNode(), bounds.getMinX(), screenY);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n+                contextMenu.show(getControl(), bounds.getMinX(), screenY);\n@@ -386,3 +387,3 @@\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n-                contextMenu.show(getNode(), screenX - leftOver, screenY);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n+                contextMenu.show(getControl(), screenX - leftOver, screenY);\n@@ -390,3 +391,3 @@\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", 0);\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCENE_X\", 0);\n-                contextMenu.show(getNode(), menuX, screenY);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", 0);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCENE_X\", 0);\n+                contextMenu.show(getControl(), menuX, screenY);\n@@ -404,1 +405,1 @@\n-        final TextArea textArea = getNode();\n+        final TextArea textArea = getControl();\n@@ -406,1 +407,1 @@\n-        if (isWindows()) {\n+        if (PlatformUtil.isWindows()) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextAreaBehavior.java","additions":119,"deletions":118,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,7 +29,0 @@\n-import com.sun.javafx.geom.transform.Affine3D;\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.control.Properties;\n-import com.sun.javafx.scene.control.skin.Utils;\n-\n-import static com.sun.javafx.PlatformUtil.*;\n-\n@@ -45,0 +38,1 @@\n+import javafx.scene.control.behavior.KeyBinding;\n@@ -47,0 +41,1 @@\n+import javafx.scene.input.KeyCode;\n@@ -52,0 +47,5 @@\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.geom.transform.Affine3D;\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.scene.control.Properties;\n+import com.sun.javafx.scene.control.skin.Utils;\n@@ -57,1 +57,1 @@\n-    private TextFieldSkin skin;\n+    private final TextFieldSkin skin;\n@@ -68,3 +68,3 @@\n-    public TextFieldBehavior(final TextField textField) {\n-        super(textField);\n-\n+    public TextFieldBehavior(TextField c, TextFieldSkin skin) {\n+        super(c);\n+        this.skin = skin;\n@@ -74,0 +74,7 @@\n+    }\n+\n+    @Override\n+    public void install() {\n+        super.install();\n+\n+        TextField textField = getControl();\n@@ -114,0 +121,3 @@\n+\n+        addHandler(KeyBinding.of(KeyCode.ENTER), false, this::fire);\n+        addHandler(KeyBinding.of(KeyCode.ESCAPE), false, this::cancelEdit);\n@@ -116,5 +126,6 @@\n-    @Override public void dispose() {\n-        getNode().focusedProperty().removeListener(focusListener);\n-        getNode().sceneProperty().removeListener(weakSceneListener);\n-        if (getNode().getScene() != null) {\n-            getNode().getScene().focusOwnerProperty().removeListener(weakFocusOwnerListener);\n+    @Override\n+    public void dispose() {\n+        getControl().focusedProperty().removeListener(focusListener);\n+        getControl().sceneProperty().removeListener(weakSceneListener);\n+        if (getControl().getScene() != null) {\n+            getControl().getScene().focusOwnerProperty().removeListener(weakFocusOwnerListener);\n@@ -127,1 +138,1 @@\n-        TextField textField = getNode();\n+        TextField textField = getControl();\n@@ -149,7 +160,2 @@\n-    \/\/ An unholy back-reference!\n-    public void setTextFieldSkin(TextFieldSkin skin) {\n-        this.skin = skin;\n-    }\n-\n-    @Override protected void fire(KeyEvent event) {\n-        TextField textField = getNode();\n+    protected void fire(KeyEvent event) {\n+        TextField textField = getControl();\n@@ -169,1 +175,0 @@\n-    @Override\n@@ -171,1 +176,1 @@\n-        TextField textField = getNode();\n+        TextField textField = getControl();\n@@ -175,2 +180,0 @@\n-        } else {\n-            super.cancelEdit(event);\n@@ -190,1 +193,1 @@\n-        TextField textField = getNode();\n+        TextField textField = getControl();\n@@ -222,1 +225,1 @@\n-        TextField textField = getNode();\n+        TextField textField = getControl();\n@@ -275,1 +278,1 @@\n-                    if (isMac()) {\n+                    if (PlatformUtil.isMac()) {\n@@ -292,1 +295,1 @@\n-        final TextField textField = getNode();\n+        final TextField textField = getControl();\n@@ -305,1 +308,1 @@\n-        final TextField textField = getNode();\n+        final TextField textField = getControl();\n@@ -320,1 +323,1 @@\n-        final TextField textField = getNode();\n+        final TextField textField = getControl();\n@@ -344,2 +347,2 @@\n-                    Point2D p = getNode().localToScene(menuPos);\n-                    Scene scene = getNode().getScene();\n+                    Point2D p = getControl().localToScene(menuPos);\n+                    Scene scene = getControl().getScene();\n@@ -362,3 +365,3 @@\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n-                contextMenu.show(getNode(), bounds.getMinX(), screenY);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n+                contextMenu.show(getControl(), bounds.getMinX(), screenY);\n@@ -367,3 +370,3 @@\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n-                contextMenu.show(getNode(), screenX - leftOver, screenY);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n+                contextMenu.show(getControl(), screenX - leftOver, screenY);\n@@ -371,3 +374,3 @@\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", 0);\n-                getNode().getProperties().put(\"CONTEXT_MENU_SCENE_X\", 0);\n-                contextMenu.show(getNode(), menuX, screenY);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCREEN_X\", 0);\n+                getControl().getProperties().put(\"CONTEXT_MENU_SCENE_X\", 0);\n+                contextMenu.show(getControl(), menuX, screenY);\n@@ -385,1 +388,1 @@\n-        final TextField textField = getNode();\n+        final TextField textField = getControl();\n@@ -387,1 +390,1 @@\n-        if (isWindows()) {\n+        if (PlatformUtil.isWindows()) {\n@@ -395,1 +398,1 @@\n-        getNode().selectAll();\n+        getControl().selectAll();\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextFieldBehavior.java","additions":52,"deletions":49,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,9 +27,6 @@\n-import com.sun.javafx.PlatformUtil;\n-import com.sun.javafx.application.PlatformImpl;\n-import com.sun.javafx.scene.control.Properties;\n-import com.sun.javafx.scene.control.skin.FXVK;\n-\n-import javafx.event.ActionEvent;\n-import javafx.event.Event;\n-import javafx.event.EventHandler;\n-import javafx.scene.control.skin.TextInputControlSkin;\n+import static com.sun.javafx.PlatformUtil.isLinux;\n+import static com.sun.javafx.PlatformUtil.isMac;\n+import static com.sun.javafx.PlatformUtil.isWindows;\n+import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;\n+import java.text.Bidi;\n+import java.util.Set;\n@@ -39,0 +36,3 @@\n+import javafx.event.ActionEvent;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n@@ -46,1 +46,7 @@\n-import javafx.scene.input.ContextMenuEvent;\n+import javafx.scene.control.behavior.BehaviorBase;\n+import javafx.scene.control.behavior.EventCriteria;\n+import javafx.scene.control.behavior.InputMap;\n+import javafx.scene.control.behavior.KeyBinding;\n+import javafx.scene.control.skin.TextInputControlSkin;\n+import javafx.scene.control.skin.TextInputControlSkin.Direction;\n+import javafx.scene.control.skin.TextInputControlSkin.TextUnit;\n@@ -48,3 +54,1 @@\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n-import com.sun.javafx.scene.control.inputmap.InputMap.Mapping;\n-import com.sun.javafx.scene.control.inputmap.KeyBinding;\n+import javafx.scene.input.ContextMenuEvent;\n@@ -54,15 +58,3 @@\n-\n-import java.text.Bidi;\n-import java.util.function.Predicate;\n-\n-import static com.sun.javafx.PlatformUtil.isLinux;\n-import static com.sun.javafx.PlatformUtil.isMac;\n-import static com.sun.javafx.PlatformUtil.isWindows;\n-import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean;\n-import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;\n-import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;\n-import static javafx.scene.control.skin.TextInputControlSkin.Direction;\n-import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n-import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;\n-import static javafx.scene.input.KeyCode.*;\n-import static javafx.scene.input.KeyEvent.*;\n+import com.sun.javafx.application.PlatformImpl;\n+import com.sun.javafx.scene.control.Properties;\n+import com.sun.javafx.scene.control.skin.FXVK;\n@@ -91,2 +83,0 @@\n-    final T textInputControl;\n-\n@@ -97,4 +87,0 @@\n-    private final InputMap<T> inputMap;\n-\n-\n-\n@@ -110,0 +96,3 @@\n+        \/\/ TODO create upon demand\n+        contextMenu = new ContextMenu();\n+    }\n@@ -111,100 +100,117 @@\n-        this.textInputControl = c;\n-\n-        \/\/ create a map for text input-specific mappings (this reuses the default\n-        \/\/ InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)\n-        inputMap = createInputMap();\n-\n-        \/\/ some of the mappings are only valid when the control is editable, or\n-        \/\/ only on certain platforms, so we create the following predicates that filters out the mapping when the\n-        \/\/ control is not in the correct state \/ on the correct platform\n-        final Predicate<KeyEvent> validWhenEditable = e -> !c.isEditable();\n-        final Predicate<KeyEvent> validOnWindows = e -> !PlatformUtil.isWindows();\n-        final Predicate<KeyEvent> validOnLinux = e -> !PlatformUtil.isLinux();\n-\n-        KeyMapping cancelEditMapping;\n-        KeyMapping fireMapping;\n-        KeyMapping consumeMostPressedEventsMapping;\n-\n-        \/\/ create a child input map for mappings which are applicable on all\n-        \/\/ platforms, and regardless of editing state\n-        addDefaultMapping(inputMap,\n-                \/\/ caret movement\n-                keyMapping(RIGHT, e -> nextCharacterVisually(true)),\n-                keyMapping(LEFT, e -> nextCharacterVisually(false)),\n-                keyMapping(UP, e -> c.home()),\n-                keyMapping(HOME, e -> c.home()),\n-                keyMapping(DOWN, e -> c.end()),\n-                keyMapping(END, e -> c.end()),\n-                fireMapping = keyMapping(ENTER, this::fire),\n-\n-                keyMapping(new KeyBinding(HOME).shortcut(), e -> c.home()),\n-                keyMapping(new KeyBinding(END).shortcut(), e -> c.end()),\n-\n-                \/\/ deletion (only applies when control is editable)\n-                keyMapping(new KeyBinding(BACK_SPACE), e -> deletePreviousChar(), validWhenEditable),\n-                keyMapping(new KeyBinding(BACK_SPACE).shift(), e -> deletePreviousChar(), validWhenEditable),\n-                keyMapping(new KeyBinding(DELETE), e -> deleteNextChar(), validWhenEditable),\n-\n-                \/\/ cut (only applies when control is editable)\n-                keyMapping(new KeyBinding(X).shortcut(), e -> cut(), validWhenEditable),\n-                keyMapping(new KeyBinding(CUT), e -> cut(), validWhenEditable),\n-\n-                \/\/ copy\n-                keyMapping(new KeyBinding(C).shortcut(), e -> c.copy()),\n-                keyMapping(new KeyBinding(INSERT).shortcut(), e -> c.copy()),\n-                keyMapping(COPY, e -> c.copy()),\n-\n-                \/\/ paste (only applies when control is editable)\n-                keyMapping(new KeyBinding(V).shortcut(), e -> paste(), validWhenEditable),\n-                keyMapping(new KeyBinding(PASTE), e -> paste(), validWhenEditable),\n-                keyMapping(new KeyBinding(INSERT).shift(), e -> paste(), validWhenEditable),\n-\n-                \/\/ selection\n-                keyMapping(new KeyBinding(RIGHT).shift(), e -> selectRight()),\n-                keyMapping(new KeyBinding(LEFT).shift(), e -> selectLeft()),\n-                keyMapping(new KeyBinding(UP).shift(), e -> selectHome()),\n-                keyMapping(new KeyBinding(DOWN).shift(), e -> selectEnd()),\n-                keyMapping(new KeyBinding(HOME).shortcut().shift(), e -> selectHome()),\n-                keyMapping(new KeyBinding(END).shortcut().shift(), e -> selectEnd()),\n-                keyMapping(new KeyBinding(A).shortcut(), e -> c.selectAll()),\n-\n-                \/\/ Traversal Bindings\n-                new KeyMapping(new KeyBinding(TAB), FocusTraversalInputMap::traverseNext),\n-                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),\n-                new KeyMapping(new KeyBinding(TAB).ctrl(), FocusTraversalInputMap::traverseNext),\n-                new KeyMapping(new KeyBinding(TAB).ctrl().shift(), FocusTraversalInputMap::traversePrevious),\n-\n-                \/\/ The following keys are forwarded to the parent container\n-                cancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),\n-\n-                keyMapping(new KeyBinding(Z).shortcut(), e -> undo()),\n-\n-                \/\/ character input.\n-                \/\/ Any other key press first goes to normal text input\n-                \/\/ Note this is KEY_TYPED because otherwise the character is not available in the event.\n-                keyMapping(new KeyBinding(null, KEY_TYPED)\n-                                    .alt(OptionalBoolean.ANY)\n-                                    .shift(OptionalBoolean.ANY)\n-                                    .ctrl(OptionalBoolean.ANY)\n-                                    .meta(OptionalBoolean.ANY),\n-                           this::defaultKeyTyped),\n-\n-                \/\/ However, we want to consume other key press \/ release events too, for\n-                \/\/ things that would have been handled by the InputCharacter normally\n-                consumeMostPressedEventsMapping =\n-                    keyMapping(new KeyBinding(null, KEY_PRESSED).shift(OptionalBoolean.ANY),\n-                               e -> { if (!e.getCode().isFunctionKey()) e.consume(); }),\n-\n-                \/\/ VK\n-                new KeyMapping(new KeyBinding(DIGIT9).ctrl().shift(), e -> {\n-                    FXVK.toggleUseVK(textInputControl);\n-                }, p -> !PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)),\n-\n-                \/\/ mouse and context menu mappings\n-                new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),\n-                new MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged),\n-                new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),\n-                new InputMap.Mapping<>(ContextMenuEvent.CONTEXT_MENU_REQUESTED, this::contextMenuRequested) {\n-                    @Override public int getSpecificity(Event event) {\n-                        return 1;\n-                    }\n+    @Override\n+    public void install() {\n+        TextInputControl c = getControl();\n+\n+        setOnKeyEventEnter(() -> setCaretAnimating(false));\n+        setOnKeyEventExit(() -> setCaretAnimating(true));\n+\n+        c.textProperty().addListener(textListener);\n+\n+        registerFunction(TextInputControl.COPY, c::copy);\n+        registerFunction(TextInputControl.CUT, this::cut);\n+        registerFunction(TextInputControl.DELETE_FROM_LINE_START, this::deleteFromLineStart);\n+        registerFunction(TextInputControl.DELETE_NEXT_CHAR, this::deleteNextChar);\n+        registerFunction(TextInputControl.DELETE_NEXT_WORD, this::deleteNextWord);\n+        registerFunction(TextInputControl.DELETE_PREVIOUS_CHAR, this::deletePreviousChar);\n+        registerFunction(TextInputControl.DELETE_PREVIOUS_WORD, this::deletePreviousWord);\n+        registerFunction(TextInputControl.DESELECT, c::deselect);\n+        registerFunction(TextInputControl.DOCUMENT_START, c::home);\n+        registerFunction(TextInputControl.DOCUMENT_END, c::end);\n+        registerFunction(TextInputControl.LEFT, () -> nextCharacterVisually(false));\n+        registerFunction(TextInputControl.LEFT_WORD, this::leftWord);\n+        registerFunction(TextInputControl.PASTE, this::paste);\n+        registerFunction(TextInputControl.REDO, this::redo);\n+        registerFunction(TextInputControl.RIGHT, () -> nextCharacterVisually(true));\n+        registerFunction(TextInputControl.RIGHT_WORD, this::rightWord);\n+        registerFunction(TextInputControl.SELECT_ALL, this::selectAll);\n+        registerFunction(TextInputControl.SELECT_END, this::selectEnd);\n+        registerFunction(TextInputControl.SELECT_END_EXTEND, this::selectEndExtend);\n+        registerFunction(TextInputControl.SELECT_HOME, this::selectHome);\n+        registerFunction(TextInputControl.SELECT_HOME_EXTEND, this::selectHomeExtend);\n+        registerFunction(TextInputControl.SELECT_LEFT, this::selectLeft);\n+        registerFunction(TextInputControl.SELECT_LEFT_WORD, this::selectLeftWord);\n+        registerFunction(TextInputControl.SELECT_RIGHT, this::selectRight);\n+        registerFunction(TextInputControl.SELECT_RIGHT_WORD, this::selectRightWord);\n+        registerFunction(TextInputControl.TRAVERSE_NEXT, () -> FocusTraversalInputMap.traverseNext(c));\n+        registerFunction(TextInputControl.TRAVERSE_PREVIOUS, () -> FocusTraversalInputMap.traversePrevious(c));\n+        registerFunction(TextInputControl.UNDO, this::undo);\n+\n+        \/\/ common key bindings\n+        registerKey(KeyBinding.shortcut(KeyCode.C), TextInputControl.COPY);\n+        registerKey(KeyBinding.of(KeyCode.COPY), TextInputControl.COPY);\n+        registerKey(KeyBinding.shortcut(KeyCode.INSERT), TextInputControl.COPY);\n+        registerKey(KeyBinding.of(KeyCode.CUT), TextInputControl.CUT);\n+        registerKey(KeyBinding.shortcut(KeyCode.X), TextInputControl.CUT);\n+        registerKey(KeyBinding.of(KeyCode.DELETE), TextInputControl.DELETE_NEXT_CHAR);\n+        registerKey(KeyBinding.of(KeyCode.BACK_SPACE), TextInputControl.DELETE_PREVIOUS_CHAR);\n+        registerKey(KeyBinding.with(KeyCode.BACK_SPACE).shift().build(), TextInputControl.DELETE_PREVIOUS_CHAR);\n+        registerKey(KeyBinding.of(KeyCode.HOME), TextInputControl.DOCUMENT_START);\n+        registerKey(KeyBinding.with(KeyCode.HOME).shortcut().build(), TextInputControl.DOCUMENT_START);\n+        registerKey(KeyBinding.of(KeyCode.UP), TextInputControl.DOCUMENT_START);\n+        registerKey(KeyBinding.of(KeyCode.DOWN), TextInputControl.DOCUMENT_END);\n+        registerKey(KeyBinding.of(KeyCode.END), TextInputControl.DOCUMENT_END);\n+        registerKey(KeyBinding.with(KeyCode.END).shortcut().build(), TextInputControl.DOCUMENT_END);\n+        registerKey(KeyBinding.of(KeyCode.LEFT), TextInputControl.LEFT);\n+        registerKey(KeyBinding.of(KeyCode.PASTE), TextInputControl.PASTE);\n+        registerKey(KeyBinding.shift(KeyCode.INSERT), TextInputControl.PASTE);\n+        registerKey(KeyBinding.shortcut(KeyCode.V), TextInputControl.PASTE);\n+        registerKey(KeyBinding.of(KeyCode.RIGHT), TextInputControl.RIGHT);\n+        registerKey(KeyBinding.shift(KeyCode.DOWN), TextInputControl.SELECT_END);\n+        registerKey(KeyBinding.with(KeyCode.END).shortcut().shift().build(), TextInputControl.SELECT_END);\n+        registerKey(KeyBinding.with(KeyCode.HOME).shortcut().shift().build(), TextInputControl.SELECT_HOME);\n+        registerKey(KeyBinding.shift(KeyCode.UP), TextInputControl.SELECT_HOME);\n+        registerKey(KeyBinding.shift(KeyCode.LEFT), TextInputControl.SELECT_LEFT);\n+        registerKey(KeyBinding.shift(KeyCode.RIGHT), TextInputControl.SELECT_RIGHT);\n+        registerKey(KeyBinding.of(KeyCode.TAB), TextInputControl.TRAVERSE_NEXT);\n+        registerKey(KeyBinding.ctrl(KeyCode.TAB), TextInputControl.TRAVERSE_NEXT);\n+        registerKey(KeyBinding.shift(KeyCode.TAB), TextInputControl.TRAVERSE_PREVIOUS);\n+        registerKey(KeyBinding.with(KeyCode.TAB).control().shift().build(), TextInputControl.TRAVERSE_PREVIOUS);\n+        registerKey(KeyBinding.shortcut(KeyCode.Z), TextInputControl.UNDO);\n+\n+        \/\/ macOS key bindings\n+        registerKey(KeyBinding.with(KeyCode.BACK_SPACE).shortcut().forMac().build(), TextInputControl.DELETE_FROM_LINE_START);\n+        registerKey(KeyBinding.with(KeyCode.DELETE).alt().forMac().build(), TextInputControl.DELETE_NEXT_WORD);\n+        registerKey(KeyBinding.with(KeyCode.BACK_SPACE).alt().forMac().build(), TextInputControl.DELETE_PREVIOUS_WORD);\n+        registerKey(KeyBinding.with(KeyCode.HOME).shift().forMac().build(), TextInputControl.SELECT_HOME_EXTEND);\n+        registerKey(KeyBinding.with(KeyCode.LEFT).shortcut().forMac().build(), TextInputControl.DOCUMENT_START);\n+        registerKey(KeyBinding.with(KeyCode.RIGHT).shortcut().forMac().build(), TextInputControl.DOCUMENT_END);\n+        registerKey(KeyBinding.with(KeyCode.LEFT).alt().forMac().build(), TextInputControl.LEFT_WORD);\n+        registerKey(KeyBinding.with(KeyCode.Z).shortcut().shift().forMac().build(), TextInputControl.REDO);\n+        registerKey(KeyBinding.with(KeyCode.RIGHT).alt().forMac().build(), TextInputControl.RIGHT_WORD);\n+        registerKey(KeyBinding.shortcut(KeyCode.A), TextInputControl.SELECT_ALL);\n+        registerKey(KeyBinding.with(KeyCode.LEFT).shortcut().shift().forMac().build(), TextInputControl.SELECT_HOME_EXTEND);\n+        registerKey(KeyBinding.with(KeyCode.RIGHT).shortcut().shift().forMac().build(), TextInputControl.SELECT_END_EXTEND);\n+        registerKey(KeyBinding.with(KeyCode.END).shift().forMac().build(), TextInputControl.SELECT_END_EXTEND);\n+        registerKey(KeyBinding.with(KeyCode.LEFT).shift().alt().forMac().build(), TextInputControl.SELECT_LEFT_WORD);\n+        registerKey(KeyBinding.with(KeyCode.RIGHT).shift().alt().forMac().build(), TextInputControl.SELECT_RIGHT_WORD);\n+\n+        \/\/ windows key bindings\n+        registerKey(KeyBinding.with(KeyCode.Y).control().forWindows().build(), TextInputControl.REDO);\n+\n+        \/\/ linux key bindings\n+        registerKey(KeyBinding.with(KeyCode.Z).control().shift().forLinux().build(), TextInputControl.REDO);\n+\n+        \/\/ not-mac key bindings\n+        registerKey(KeyBinding.with(KeyCode.DELETE).control().notForMac().build(), TextInputControl.DELETE_NEXT_WORD);\n+        registerKey(KeyBinding.with(KeyCode.H).control().notForMac().build(), TextInputControl.DELETE_PREVIOUS_CHAR);\n+        registerKey(KeyBinding.with(KeyCode.BACK_SPACE).control().notForMac().build(), TextInputControl.DELETE_PREVIOUS_WORD);\n+        registerKey(KeyBinding.with(KeyCode.BACK_SLASH).control().notForMac().build(), TextInputControl.DESELECT);\n+        registerKey(KeyBinding.with(KeyCode.LEFT).control().notForMac().build(), TextInputControl.LEFT_WORD);\n+        registerKey(KeyBinding.with(KeyCode.RIGHT).control().notForMac().build(), TextInputControl.RIGHT_WORD);\n+        registerKey(KeyBinding.with(KeyCode.HOME).shift().notForMac().build(), TextInputControl.SELECT_HOME);\n+        registerKey(KeyBinding.with(KeyCode.END).shift().notForMac().build(), TextInputControl.SELECT_END);\n+        registerKey(KeyBinding.with(KeyCode.LEFT).control().shift().notForMac().build(), TextInputControl.SELECT_LEFT_WORD);\n+        registerKey(KeyBinding.with(KeyCode.RIGHT).control().shift().notForMac().build(), TextInputControl.SELECT_RIGHT_WORD);\n+\n+        \/\/ key pad mappings\n+        addKeyPadMappings();\n+\n+        addHandler(KeyEvent.KEY_TYPED, this::defaultKeyTyped);\n+\n+        \/\/ However, we want to consume other key press \/ release events too, for\n+        \/\/ things that would have been handled by the InputCharacter normally\n+        addHandlerLast(\n+            new EventCriteria<KeyEvent>() {\n+                @Override\n+                public EventType<KeyEvent> getEventType() {\n+                    return KeyEvent.KEY_PRESSED;\n@@ -212,1 +218,0 @@\n-        );\n@@ -214,45 +219,17 @@\n-        cancelEditMapping.setAutoConsume(false);\n-        \/\/ fix of JDK-8207759: don't auto-consume\n-        fireMapping.setAutoConsume(false);\n-        consumeMostPressedEventsMapping.setAutoConsume(false);\n-\n-        \/\/ mac os specific mappings\n-        InputMap<T> macOsInputMap = new InputMap<>(c);\n-        macOsInputMap.setInterceptor(e -> !PlatformUtil.isMac());\n-        macOsInputMap.getMappings().addAll(\n-            \/\/ Mac OS specific mappings\n-            keyMapping(new KeyBinding(HOME).shift(), e -> selectHomeExtend()),\n-            keyMapping(new KeyBinding(END).shift(), e -> selectEndExtend()),\n-            keyMapping(new KeyBinding(LEFT).shortcut(), e -> c.home()),\n-            keyMapping(new KeyBinding(RIGHT).shortcut(), e -> c.end()),\n-            keyMapping(new KeyBinding(LEFT).alt(), e -> leftWord()),\n-            keyMapping(new KeyBinding(RIGHT).alt(), e -> rightWord()),\n-            keyMapping(new KeyBinding(DELETE).alt(), e -> deleteNextWord()),\n-            keyMapping(new KeyBinding(BACK_SPACE).alt(), e -> deletePreviousWord()),\n-            keyMapping(new KeyBinding(BACK_SPACE).shortcut(), e -> deleteFromLineStart()),\n-            keyMapping(new KeyBinding(Z).shortcut().shift(), e -> redo()),\n-            keyMapping(new KeyBinding(LEFT).shortcut().shift(), e -> selectHomeExtend()),\n-            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -> selectEndExtend()),\n-\n-            \/\/ Mac OS specific selection mappings\n-            keyMapping(new KeyBinding(LEFT).shift().alt(), e -> selectLeftWord()),\n-            keyMapping(new KeyBinding(RIGHT).shift().alt(), e -> selectRightWord())\n-        );\n-        addDefaultChildMap(inputMap, macOsInputMap);\n-\n-        \/\/ windows \/ linux specific mappings\n-        InputMap<T> nonMacOsInputMap = new InputMap<>(c);\n-        nonMacOsInputMap.setInterceptor(e -> PlatformUtil.isMac());\n-        nonMacOsInputMap.getMappings().addAll(\n-            keyMapping(new KeyBinding(HOME).shift(), e -> selectHome()),\n-            keyMapping(new KeyBinding(END).shift(), e -> selectEnd()),\n-            keyMapping(new KeyBinding(LEFT).ctrl(), e -> leftWord()),\n-            keyMapping(new KeyBinding(RIGHT).ctrl(), e -> rightWord()),\n-            keyMapping(new KeyBinding(H).ctrl(), e -> deletePreviousChar()),\n-            keyMapping(new KeyBinding(DELETE).ctrl(), e -> deleteNextWord()),\n-            keyMapping(new KeyBinding(BACK_SPACE).ctrl(), e -> deletePreviousWord()),\n-            keyMapping(new KeyBinding(BACK_SLASH).ctrl(), e -> c.deselect()),\n-            keyMapping(new KeyBinding(Y).ctrl(), e -> redo(), validOnWindows),\n-            keyMapping(new KeyBinding(Z).ctrl().shift(), e -> redo(), validOnLinux),\n-            keyMapping(new KeyBinding(LEFT).ctrl().shift(), e -> selectLeftWord()),\n-            keyMapping(new KeyBinding(RIGHT).ctrl().shift(), e -> selectRightWord())\n+                @Override\n+                public boolean isEventAcceptable(KeyEvent ev) {\n+                    switch(ev.getCode()) {\n+                    case ESCAPE:\n+                    case ENTER:\n+                        return false;\n+                    };\n+                    return\n+                        !ev.getCode().isFunctionKey() &&\n+                        !ev.isAltDown() &&\n+                        !ev.isControlDown() &&\n+                        !ev.isMetaDown() &&\n+                        !ev.isShortcutDown();\n+                }\n+            },\n+            false,\n+            (ev) -> ev.consume()\n@@ -260,1 +237,0 @@\n-        addDefaultChildMap(inputMap, nonMacOsInputMap);\n@@ -262,1 +238,7 @@\n-        addKeyPadMappings(inputMap);\n+        \/\/ VK\n+        \/\/ TODO can PlatformImpl.isSupported(ConditionalFeature) change at runtime?\n+        if (PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {\n+            addHandler(KeyBinding.builder().with(KeyCode.DIGIT9).control().shift().build(), true, (ev) -> {\n+                FXVK.toggleUseVK(getControl());\n+            });\n+        }\n@@ -264,1 +246,4 @@\n-        textInputControl.textProperty().addListener(textListener);\n+        \/\/ mouse and context menu mappings\n+        addHandler(MouseEvent.MOUSE_PRESSED, this::mousePressed);\n+        addHandler(MouseEvent.MOUSE_DRAGGED, this::mouseDragged);\n+        addHandler(MouseEvent.MOUSE_RELEASED, this::mouseReleased);\n@@ -266,5 +251,1 @@\n-        contextMenu = new ContextMenu();\n-}\n-\n-    @Override public InputMap<T> getInputMap() {\n-        return inputMap;\n+        addHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, this::contextMenuRequested);\n@@ -274,1 +255,1 @@\n-     * Bind keypad arrow keys to the same as the regular arrow keys.\n+     * Binds keypad arrow keys to the same function tags as the regular arrow keys.\n@@ -276,23 +257,23 @@\n-    protected void addKeyPadMappings(InputMap<T> map) {\n-        \/\/ First create a temporary map for the keypad mappings\n-        InputMap<T> tmpMap = new InputMap<>(getNode());\n-        for (Object o : map.getMappings()) {\n-            if (o instanceof KeyMapping) {\n-                KeyMapping mapping = (KeyMapping)o;\n-                KeyBinding kb = (KeyBinding)mapping.getMappingKey();\n-                if (kb.getCode() != null) {\n-                    KeyCode newCode = null;\n-                    switch (kb.getCode()) {\n-                        case LEFT:  newCode = KP_LEFT;  break;\n-                        case RIGHT: newCode = KP_RIGHT; break;\n-                        case UP:    newCode = KP_UP;    break;\n-                        case DOWN:  newCode = KP_DOWN;  break;\n-                        default:\n-                    }\n-                    if (newCode != null) {\n-                        KeyBinding newkb = new KeyBinding(newCode).shift(kb.getShift())\n-                                                                  .ctrl(kb.getCtrl())\n-                                                                  .alt(kb.getAlt())\n-                                                                  .meta(kb.getMeta());\n-                        tmpMap.getMappings().add(new KeyMapping(newkb, mapping.getEventHandler()));\n-                    }\n+    protected void addKeyPadMappings() {\n+        InputMap m = getInputMap();\n+        Set<KeyBinding> keys = m.getKeyBindings();\n+        for (KeyBinding k: keys) {\n+            KeyCode cd = k.getKeyCode();\n+            if (cd != null) {\n+                KeyCode newCode = null;\n+                switch (cd) {\n+                case LEFT:\n+                    newCode = KeyCode.KP_LEFT;\n+                    break;\n+                case RIGHT:\n+                    newCode = KeyCode.KP_RIGHT;\n+                    break;\n+                case UP:\n+                    newCode = KeyCode.KP_UP;\n+                    break;\n+                case DOWN:\n+                    newCode = KeyCode.KP_DOWN;\n+                    break;\n+                default:\n+                    newCode = null;\n+                    break;\n@@ -300,2 +281,0 @@\n-            }\n-        }\n@@ -303,10 +282,12 @@\n-        if (map == getInputMap()) {\n-            \/\/ install mappings in the top-level inputMap\n-            \/\/ as default mappings to clear them on dispose\n-            for (Mapping<?> mapping : tmpMap.getMappings()) {\n-                addDefaultMapping(map, mapping);\n-            }\n-        } else {\n-            \/\/ Install mappings in child maps\n-            for (Object o : tmpMap.getMappings()) {\n-                map.getMappings().add((KeyMapping)o);\n+                if (newCode != null) {\n+                    KeyBinding newBinding = KeyBinding.\n+                        with(newCode).\n+                        alt(k.isAlt()).\n+                        command(k.isCommand()).\n+                        control(k.isControl()).\n+                        meta(k.isMeta()).\n+                        option(k.isOption()).\n+                        shift(k.isShift()).\n+                        build();\n+                    duplicateMapping(k, newBinding);\n+                }\n@@ -315,33 +296,0 @@\n-\n-        \/\/ temporary inputMap must be disposed to prevent memory leak\n-        tmpMap.dispose();\n-\n-        \/\/ Recursive call for child maps\n-        for (Object o : map.getChildInputMaps()) {\n-            addKeyPadMappings((InputMap<T>)o);\n-        }\n-\n-    }\n-\n-\n-    \/**\n-     * Wraps the event handler to pause caret blinking when\n-     * processing the key event.\n-     *\/\n-    protected KeyMapping keyMapping(final KeyCode keyCode, final EventHandler<KeyEvent> eventHandler) {\n-        return keyMapping(new KeyBinding(keyCode), eventHandler);\n-    }\n-\n-    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler<KeyEvent> eventHandler) {\n-        return keyMapping(keyBinding, eventHandler, null);\n-    }\n-\n-    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler<KeyEvent> eventHandler,\n-                                    Predicate<KeyEvent> interceptor) {\n-        return new KeyMapping(keyBinding,\n-                              e -> {\n-                                  setCaretAnimating(false);\n-                                  eventHandler.handle(e);\n-                                  setCaretAnimating(true);\n-                              },\n-                              interceptor);\n@@ -351,3 +299,0 @@\n-\n-\n-\n@@ -358,2 +303,3 @@\n-    @Override public void dispose() {\n-        textInputControl.textProperty().removeListener(textListener);\n+    @Override\n+    public void dispose() {\n+        getControl().textProperty().removeListener(textListener);\n@@ -388,1 +334,1 @@\n-        final TextInputControl textInput = getNode();\n+        final TextInputControl textInput = getControl();\n@@ -437,2 +383,2 @@\n-            bidi = new Bidi(textInputControl.textProperty().getValueSafe(),\n-                    (textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)\n+            bidi = new Bidi(getControl().textProperty().getValueSafe(),\n+                    (getControl().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)\n@@ -458,1 +404,1 @@\n-                                    textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT));\n+                                getControl().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT));\n@@ -465,1 +411,1 @@\n-            TextInputControlSkin<?> skin = (TextInputControlSkin<?>)textInputControl.getSkin();\n+            TextInputControlSkin<?> skin = (TextInputControlSkin<?>)getControl().getSkin();\n@@ -468,1 +414,1 @@\n-            textInputControl.forward();\n+            getControl().forward();\n@@ -470,1 +416,1 @@\n-            textInputControl.backward();\n+            getControl().backward();\n@@ -476,1 +422,1 @@\n-            textInputControl.selectForward();\n+            getControl().selectForward();\n@@ -478,1 +424,1 @@\n-            textInputControl.selectBackward();\n+            getControl().selectBackward();\n@@ -484,1 +430,1 @@\n-            textInputControl.selectBackward();\n+            getControl().selectBackward();\n@@ -486,1 +432,1 @@\n-            textInputControl.selectForward();\n+            getControl().selectForward();\n@@ -490,0 +436,4 @@\n+    boolean isEditable() {\n+        return getControl().isEditable();\n+    }\n+\n@@ -491,3 +441,5 @@\n-        setEditing(true);\n-        deleteChar(true);\n-        setEditing(false);\n+        if (isEditable()) {\n+            setEditing(true);\n+            deleteChar(true);\n+            setEditing(false);\n+        }\n@@ -497,3 +449,5 @@\n-        setEditing(true);\n-        deleteChar(false);\n-        setEditing(false);\n+        if (isEditable()) {\n+            setEditing(true);\n+            deleteChar(false);\n+            setEditing(false);\n+        }\n@@ -504,1 +458,1 @@\n-        TextInputControl textInputControl = getNode();\n+        TextInputControl textInputControl = getControl();\n@@ -517,1 +471,1 @@\n-        TextInputControl textInputControl = getNode();\n+        TextInputControl textInputControl = getControl();\n@@ -530,1 +484,1 @@\n-        TextInputControl textInputControl = getNode();\n+        TextInputControl textInputControl = getControl();\n@@ -540,3 +494,5 @@\n-        setEditing(true);\n-        getNode().cut();\n-        setEditing(false);\n+        if (isEditable()) {\n+            setEditing(true);\n+            getControl().cut();\n+            setEditing(false);\n+        }\n@@ -546,3 +502,5 @@\n-        setEditing(true);\n-        getNode().paste();\n-        setEditing(false);\n+        if (isEditable()) {\n+            setEditing(true);\n+            getControl().paste();\n+            setEditing(false);\n+        }\n@@ -553,1 +511,1 @@\n-        getNode().undo();\n+        getControl().undo();\n@@ -559,1 +517,1 @@\n-        getNode().redo();\n+        getControl().redo();\n@@ -564,1 +522,1 @@\n-        getNode().selectPreviousWord();\n+        getControl().selectPreviousWord();\n@@ -568,1 +526,1 @@\n-        TextInputControl textInputControl = getNode();\n+        TextInputControl textInputControl = getControl();\n@@ -593,1 +551,1 @@\n-        final TextInputControl textInputControl = getNode();\n+        final TextInputControl textInputControl = getControl();\n@@ -606,1 +564,1 @@\n-        getNode().selectAll();\n+        getControl().selectAll();\n@@ -613,1 +571,1 @@\n-        getNode().previousWord();\n+        getControl().previousWord();\n@@ -617,1 +575,1 @@\n-        TextInputControl textInputControl = getNode();\n+        TextInputControl textInputControl = getControl();\n@@ -641,3 +599,0 @@\n-    protected void fire(KeyEvent event) { } \/\/ TODO move to TextFieldBehavior\n-    protected void cancelEdit(KeyEvent event) { }\n-\n@@ -645,1 +600,1 @@\n-        getNode().selectHome();\n+        getControl().selectHome();\n@@ -649,1 +604,1 @@\n-        getNode().selectEnd();\n+        getControl().selectEnd();\n@@ -653,1 +608,1 @@\n-        getNode().extendSelection(0);\n+        getControl().extendSelection(0);\n@@ -657,1 +612,1 @@\n-        TextInputControl textInputControl = getNode();\n+        TextInputControl textInputControl = getControl();\n@@ -670,1 +625,1 @@\n-        TextInputControl textInputControl = getNode();\n+        TextInputControl textInputControl = getControl();\n@@ -704,2 +659,2 @@\n-            undoMI.setDisable(!getNode().isUndoable());\n-            redoMI.setDisable(!getNode().isRedoable());\n+            undoMI.setDisable(!getControl().isUndoable());\n+            redoMI.setDisable(!getControl().isRedoable());\n@@ -723,1 +678,1 @@\n-    private final MenuItem copyMI   = new ContextMenuItem(\"Copy\", e -> getNode().copy());\n+    private final MenuItem copyMI   = new ContextMenuItem(\"Copy\", e -> getControl().copy());\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextInputControlBehavior.java","additions":263,"deletions":308,"binary":false,"changes":571,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.control.input;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import javafx.event.EventHandler;\n+\n+\/**\n+ * List of event handlers, which can be added to its head or tail.\n+ * the order of handlers in the list is guaranteed to be:\n+ * (first added to the head), (second added to the head), ..., (second added to the tail), (first added to the tail).\n+ *\/\n+public class HList implements Iterable<EventHandler<?>> {\n+    private final ArrayList<EventHandler<?>> handlers = new ArrayList<>(4);\n+    private int insertIndex;\n+\n+    public HList() {\n+    }\n+\n+    public static HList from(Object x) {\n+        if (x instanceof HList h) {\n+            return h;\n+        }\n+        return new HList();\n+    }\n+\n+    public void add(EventHandler<?> h, boolean tail) {\n+        if (insertIndex == handlers.size()) {\n+            handlers.add(h);\n+        } else {\n+            handlers.add(insertIndex, h);\n+        }\n+\n+        if (!tail) {\n+            insertIndex++;\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<EventHandler<?>> iterator() {\n+        return handlers.iterator();\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/input\/HList.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -65,0 +65,1 @@\n+@Deprecated \/\/ TODO to be replaced with new InputMap\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/inputmap\/InputMap.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+@Deprecated \/\/ TODO remove in favor of javafx.scene.control.input.KeyBinding\n@@ -68,0 +69,1 @@\n+    @Deprecated\n@@ -72,0 +74,1 @@\n+    @Deprecated\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/inputmap\/KeyBinding.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.scene.control.FakeFocusTextField;\n+import java.lang.ref.WeakReference;\n@@ -32,3 +32,6 @@\n-import javafx.collections.WeakListChangeListener;\n-import javafx.scene.control.skin.ComboBoxListViewSkin;\n-import javafx.beans.property.*;\n+import javafx.beans.property.IntegerProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.property.SimpleIntegerProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -40,0 +43,1 @@\n+import javafx.collections.WeakListChangeListener;\n@@ -43,0 +47,2 @@\n+import javafx.scene.control.behavior.FunctionTag;\n+import javafx.scene.control.skin.ComboBoxListViewSkin;\n@@ -45,2 +51,1 @@\n-\n-import java.lang.ref.WeakReference;\n+import com.sun.javafx.scene.control.FakeFocusTextField;\n@@ -193,0 +198,4 @@\n+    \/** Denotes the function that selects the next item. *\/\n+    public static final FunctionTag SELECT_NEXT = new FunctionTag();\n+    \/** Denotes the function that selects the previous item. *\/\n+    public static final FunctionTag SELECT_PREV = new FunctionTag();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ComboBox.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import javafx.scene.control.behavior.FunctionTag;\n@@ -72,7 +73,3 @@\n-\n-\n-    \/* *************************************************************************\n-     *                                                                         *\n-     * Static properties and methods                                           *\n-     *                                                                         *\n-     **************************************************************************\/\n+    \/** Denotes the function that toggles this combo box popup. *\/\n+    public static final FunctionTag TOGGLE_POPUP = new FunctionTag();\n+    \/\/CANCEL_EDIT, \/\/ TODO forwards to parent, child class logic in the base class, looks poorly thought out\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ComboBoxBase.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-\n-import com.sun.javafx.scene.control.ControlAcceleratorSupport;\n@@ -42,0 +40,1 @@\n+import javafx.css.CssMetaData;\n@@ -43,0 +42,5 @@\n+import javafx.css.Styleable;\n+import javafx.css.StyleableObjectProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.css.StyleableStringProperty;\n+import javafx.css.converter.StringConverter;\n@@ -47,0 +51,2 @@\n+import javafx.scene.control.behavior.FunctionTag;\n+import javafx.scene.control.behavior.InputMap;\n@@ -50,1 +56,0 @@\n-import javafx.css.CssMetaData;\n@@ -52,0 +57,2 @@\n+import com.sun.javafx.logging.PlatformLogger;\n+import com.sun.javafx.logging.PlatformLogger.Level;\n@@ -53,0 +60,1 @@\n+import com.sun.javafx.scene.control.ControlAcceleratorSupport;\n@@ -54,3 +62,0 @@\n-import javafx.css.StyleableObjectProperty;\n-import javafx.css.StyleableStringProperty;\n-import javafx.css.converter.StringConverter;\n@@ -58,4 +63,0 @@\n-import javafx.css.Styleable;\n-import javafx.css.StyleableProperty;\n-import com.sun.javafx.logging.PlatformLogger;\n-import com.sun.javafx.logging.PlatformLogger.Level;\n@@ -204,0 +205,1 @@\n+    private InputMap inputMap2;\n@@ -469,9 +471,26 @@\n-    \/\/ Proposed dispose() API.\n-    \/\/ Note that there is impl code for a dispose method in TableRowSkinBase\n-    \/\/ and TableCell (just search for dispose())\n-\/\/    public void dispose() {\n-\/\/        Skin skin = getSkin();\n-\/\/        if (skin != null) {\n-\/\/            skin.dispose();\n-\/\/        }\n-\/\/    }\n+    \/**\n+     * Returns the {@link InputMap} for this {@code Control}.\n+     *\n+     * @since 22\n+     * @return the input map\n+     *\/\n+    public InputMap getInputMap() {\n+        if (inputMap2 == null) {\n+            inputMap2 = new InputMap(this);\n+        }\n+        return inputMap2;\n+    }\n+\n+    \/**\n+     * Executes function mapped to the {@link FunctionTag}.\n+     * This method does nothing if no mapping is found.\n+     *\n+     * @since 22\n+     * @param tag the function tag\n+     *\/\n+    protected final void execute(FunctionTag tag) {\n+        Runnable f = getInputMap().getFunction(tag);\n+        if (f != null) {\n+            f.run();\n+        }\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/Control.java","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import javafx.scene.control.behavior.FunctionTag;\n@@ -84,0 +85,45 @@\n+    \/** Denotes the function that moves the caret to the document end. *\/\n+    public static final FunctionTag DOCUMENT_END = new FunctionTag();\n+    \/** Denotes the function that moves the caret to the document start. *\/\n+    public static final FunctionTag DOCUMENT_START = new FunctionTag();\n+    \/** Denotes the function that moves the caret one line down. *\/\n+    public static final FunctionTag DOWN = new FunctionTag();\n+    \/** Denotes the function that inserts a TAB character at the caret position. *\/\n+    public static final FunctionTag INSERT_TAB = new FunctionTag();\n+    \/** Denotes the function that insert a new line at the caret position. *\/\n+    public static final FunctionTag INSERT_NEW_LINE = new FunctionTag();\n+    \/** Denotes the function that moves the caret to the end of the visible line. *\/\n+    public static final FunctionTag LINE_END = new FunctionTag();\n+    \/** Denotes the function that moves the caret to the start of the visible line. *\/\n+    public static final FunctionTag LINE_START = new FunctionTag();\n+    \/** Denotes the function that moves the caret one paragraph down. *\/\n+    public static final FunctionTag PARAGRAPH_DOWN = new FunctionTag();\n+    \/** Denotes the function that moves the caret one paragraph up. *\/\n+    public static final FunctionTag PARAGRAPH_UP = new FunctionTag();\n+    \/** Denotes the function that moves the caret one page down. *\/\n+    public static final FunctionTag PAGE_DOWN = new FunctionTag();\n+    \/** Denotes the function that moves the caret one page up. *\/\n+    public static final FunctionTag PAGE_UP = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection one line down. *\/\n+    public static final FunctionTag SELECT_DOWN = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection to the end of the current paragraph. *\/\n+    \/\/public static final FunctionTag SELECT_END_EXTEND = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection to the start of the current paragraph. *\/\n+    \/\/public static final FunctionTag SELECT_HOME_EXTEND = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection to the end of the visible line. *\/\n+    public static final FunctionTag SELECT_LINE_END = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection to the start of the visible line. *\/\n+    public static final FunctionTag SELECT_LINE_START = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection one page down. *\/\n+    public static final FunctionTag SELECT_PAGE_DOWN = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection one page up. *\/\n+    public static final FunctionTag SELECT_PAGE_UP = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection one paragraph down. *\/\n+    public static final FunctionTag SELECT_PARAGRAPH_DOWN = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection one paragraph up. *\/\n+    public static final FunctionTag SELECT_PARAGRAPH_UP = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection one line up. *\/\n+    public static final FunctionTag SELECT_UP = new FunctionTag();\n+    \/** Denotes the function that moves the caret one line up. *\/\n+    public static final FunctionTag UP = new FunctionTag();\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TextArea.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import javafx.scene.control.behavior.FunctionTag;\n@@ -80,0 +81,59 @@\n+    \/** Denotes the function that copies the content to the clipboard. *\/\n+    public static final FunctionTag COPY = new FunctionTag();\n+    \/** Denotes the function that cuts the content to the clipboard. *\/\n+    public static final FunctionTag CUT = new FunctionTag();\n+    \/** Denotes the function that deletes text from the line start. *\/\n+    public static final FunctionTag DELETE_FROM_LINE_START = new FunctionTag();\n+    \/** Denotes the function that deletes the next character. *\/\n+    public static final FunctionTag DELETE_NEXT_CHAR = new FunctionTag();\n+    \/** Denotes the function that deletes the next word. *\/\n+    public static final FunctionTag DELETE_NEXT_WORD = new FunctionTag();\n+    \/** Denotes the function that deletes the previous character. *\/\n+    public static final FunctionTag DELETE_PREVIOUS_CHAR = new FunctionTag();\n+    \/** Denotes the function that deletes the previous word. *\/\n+    public static final FunctionTag DELETE_PREVIOUS_WORD = new FunctionTag();\n+    \/** Denotes the function that deselects. *\/\n+    public static final FunctionTag DESELECT = new FunctionTag();\n+    \/** Denotes the function that moves the caret to the document start. *\/\n+    public static final FunctionTag DOCUMENT_START = new FunctionTag();\n+    \/** Denotes the function that moves the caret to the document end. *\/\n+    public static final FunctionTag DOCUMENT_END = new FunctionTag();\n+    \/** Denotes the function that moves the caret one symbol left. *\/\n+    public static final FunctionTag LEFT = new FunctionTag();\n+    \/** Denotes the function that moves the caret one word left. *\/\n+    public static final FunctionTag LEFT_WORD = new FunctionTag();\n+    \/** Denotes the function that pastes from the clipboard. *\/\n+    public static final FunctionTag PASTE = new FunctionTag();\n+    \/** Denotes the function that redoes the last undo. *\/\n+    public static final FunctionTag REDO = new FunctionTag();\n+    \/** Denotes the function that moves the caret one symbol right. *\/\n+    public static final FunctionTag RIGHT = new FunctionTag();\n+    \/** Denotes the function that moves the caret one word right. *\/\n+    public static final FunctionTag RIGHT_WORD = new FunctionTag();\n+    \/** Denotes the function that selects all. *\/\n+    public static final FunctionTag SELECT_ALL = new FunctionTag();\n+    \/** Denotes the function that selects to after the last char of text. *\/\n+    public static final FunctionTag SELECT_END = new FunctionTag();\n+    \/** Denotes the function that ?? TODO how is this different from SELECT_END?. *\/\n+    public static final FunctionTag SELECT_END_EXTEND = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection to before the first char of text. *\/\n+    public static final FunctionTag SELECT_HOME = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection to before the first char of text. *\/\n+    \/\/ TODO how is this different from SELECT_HOME?\n+    public static final FunctionTag SELECT_HOME_EXTEND = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection one character to the left. *\/\n+    public static final FunctionTag SELECT_LEFT = new FunctionTag();\n+    \/** Denotes the function that moves the caret to the beginning or end of the word to the left. *\/\n+    \/\/ TODO explain platform-specific behavior\n+    public static final FunctionTag SELECT_LEFT_WORD = new FunctionTag();\n+    \/** Denotes the function that moves the caret and extends selection one character to the right. *\/\n+    public static final FunctionTag SELECT_RIGHT = new FunctionTag();\n+    \/** Denotes the function that moves the caret to the beginning or end of the word to the right. *\/\n+    public static final FunctionTag SELECT_RIGHT_WORD = new FunctionTag();\n+    \/** Denotes the function that moves the focus to the next focusTraversable Node. *\/\n+    public static final FunctionTag TRAVERSE_NEXT = new FunctionTag();\n+    \/** Denotes the function that moves the focus to the previous focusTraversable Node. *\/\n+    public static final FunctionTag TRAVERSE_PREVIOUS = new FunctionTag();\n+    \/** Denotes the function that undoes the last change. *\/\n+    public static final FunctionTag UNDO = new FunctionTag();\n+\n@@ -1745,1 +1805,0 @@\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TextInputControl.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javafx.scene.control.behavior;\n+\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.control.Control;\n+import javafx.scene.input.KeyCode;\n+\n+\/**\n+ * Class provides a foundation for behaviors.\n+ * <p>\n+ * A concrete behavior implementation should do three things:\n+ * 1. provide default behavior methods (a.k.a. functions)\n+ * 2. in install() method, called from Skin.install(), map control's function tags to\n+ *    behavior methods, map key bindings to function tags, and add additional event handlers,\n+ *    using regFunc(), regKey(), and addHandler() methods correspondingly.\n+ *    Important: no mapping should be made in the behavior constructor, only in install().\n+ * <p>\n+ * The base class adds a dispose() method (called from Skin.dispose()),\n+ * which undoes the mappings done in install().\n+ * <p>\n+ * @since 22\n+ *\/\n+public abstract class BehaviorBase<C extends Control> {\n+    \/** the instance of Control associated with this behavior *\/\n+    protected final C control;\n+\n+    \/** The constructor. *\/\n+    public BehaviorBase(C control) {\n+        this.control = control;\n+    }\n+\n+    \/**\n+     * Returns the associated Control instance.\n+     * @return the owner\n+     *\/\n+    protected final C getControl() {\n+        return control;\n+    }\n+\n+    \/**\n+     * Returns the input map of the associated Control.\n+     * TODO rename getInputMap()\n+     * @return the input map\n+     *\/\n+    protected final InputMap getInputMap() {\n+        return control.getInputMap();\n+    }\n+\n+    \/**\n+     * Installs this behavior by registering default key mappings and event handlers.\n+     *\/\n+    public abstract void install();\n+\n+    \/**\n+     * Disposes of this behavior by unregistering all key mappings and event handlers registered by\n+     * this behavior.  This method gets invoked by {@code Skin.dispose()}, the application should not need\n+     * to call it directly.\n+     * <p>\n+     * If a subclass overrides this method, it is important to call the superclass\n+     * implementation.\n+     *\/\n+    public void dispose() {\n+        getInputMap().unregister(this);\n+    }\n+\n+    \/**\n+     * Maps a function to the specified function tag.\n+     * This method will not override any previous mapping added by {@link #registerFunction(FunctionTag,Runnable)}.\n+     *\n+     * @param tag the function tag\n+     * @param function the function\n+     *\/\n+    protected void registerFunction(FunctionTag tag, Runnable function) {\n+        getInputMap().registerFunction(this, tag, function);\n+    }\n+\n+    \/**\n+     * Maps a key binding to the specified function tag.\n+     * A null key binding will result in no change to this input map.\n+     * This method will not override a user mapping.\n+     *\n+     * @param k the key binding, can be null (TODO or KB.NA)\n+     * @param tag the function tag\n+     *\/\n+    protected void registerKey(KeyBinding k, FunctionTag tag) {\n+        getInputMap().registerKey(this, k, tag);\n+    }\n+\n+    \/**\n+     * Maps a key binding to the specified function tag.\n+     * This method will not override a user mapping added by {@link #registerKey(KeyBinding,FunctionTag)}.\n+     *\n+     * @param code the key code to construct a {@link KeyBinding}\n+     * @param tag the function tag\n+     *\/\n+    protected void registerKey(KeyCode code, FunctionTag tag) {\n+        getInputMap().registerKey(this, code, tag);\n+    }\n+\n+    \/**\n+     * This convenience method maps the function tag to the specified function, and at the same time\n+     * maps the specified key binding to that function tag.\n+     * @param tag the function tag\n+     * @param k the key binding\n+     * @param func the function\n+     *\/\n+    protected void register(FunctionTag tag, KeyBinding k, Runnable func) {\n+        getInputMap().registerFunction(tag, func);\n+        getInputMap().registerKey(k, tag);\n+    }\n+\n+    \/**\n+     * This convenience method maps the function tag to the specified function, and at the same time\n+     * maps the specified key binding to that function tag.\n+     * @param tag the function tag\n+     * @param code the key code\n+     * @param func the function\n+     *\/\n+    protected void register(FunctionTag tag, KeyCode code, Runnable func) {\n+        getInputMap().registerFunction(tag, func);\n+        getInputMap().registerKey(KeyBinding.of(code), tag);\n+    }\n+\n+    \/**\n+     * This convenience method registers a copy of the behavior-specific mappings from one key binding to another.\n+     * The method does nothing if no behavior specific mapping can be found.\n+     * @param existing the existing key binding\n+     * @param newk the new key binding\n+     *\/\n+    protected void duplicateMapping(KeyBinding existing, KeyBinding newk) {\n+        getInputMap().duplicateMapping(existing, newk);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, in the context of this Behavior.\n+     * The handler will get removed in {@link#dispose()} method.\n+     * This mapping always consumes the matching event.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param handler the event handler\n+     *\/\n+    protected <T extends Event> void addHandler(EventType<T> type, EventHandler<T> handler) {\n+        getInputMap().addHandler(this, type, true, false, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, in the context of this Behavior.\n+     * The handler will get removed in {@link#dispose()} method.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    protected <T extends Event> void addHandler(EventType<T> type, boolean consume, EventHandler<T> handler) {\n+        getInputMap().addHandler(this, type, consume, false, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, in the context of this Behavior.\n+     * This event handler will get invoked after all handlers added via map() methods.\n+     * The handler will get removed in {@link#dispose()} method.\n+     * This mapping always consumes the matching event.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param handler the event handler\n+     *\/\n+    protected <T extends Event> void addHandlerLast(EventType<T> type, EventHandler<T> handler) {\n+        getInputMap().addHandler(this, type, true, true, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, in the context of this Behavior.\n+     * This event handler will get invoked after all handlers added via map() methods.\n+     * The handler will get removed in {@link#dispose()} method.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    protected <T extends Event> void addHandlerLast(EventType<T> type, boolean consume, EventHandler<T> handler) {\n+        getInputMap().addHandler(this, type, consume, true, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specific event criteria, in the context of this Behavior.\n+     * This is a more specific version of {@link #addHandler(EventType,EventHandler)} method.\n+     * The handler will get removed in {@link#dispose()} method.\n+     *\n+     * @param <T> the actual event type\n+     * @param criteria the matching criteria\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    protected <T extends Event> void addHandler(EventCriteria<T> criteria, boolean consume, EventHandler<T> handler) {\n+        getInputMap().addHandler(this, criteria, consume, false, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specific event criteria, in the context of this Behavior.\n+     * This event handler will get invoked after all handlers added via map() methods.\n+     * The handler will get removed in {@link#dispose()} method.\n+     *\n+     * @param <T> the actual event type\n+     * @param criteria the matching criteria\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    protected <T extends Event> void addHandlerLast(\n+        EventCriteria<T> criteria,\n+        boolean consume,\n+        EventHandler<T> handler\n+    ) {\n+        getInputMap().addHandler(this, criteria, consume, true, handler);\n+    }\n+\n+    \/**\n+     * Sets the code to be executed just before handling of the key events.\n+     * @param action the action or null\n+     *\/\n+    protected void setOnKeyEventEnter(Runnable action) {\n+        getInputMap().setOnKeyEventEnter(this, action);\n+    }\n+\n+    \/**\n+     * Sets the code to be executed just after handling of the key events.\n+     * @param action the action or null\n+     *\/\n+    protected void setOnKeyEventExit(Runnable action) {\n+        getInputMap().setOnKeyEventExit(this, action);\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/behavior\/BehaviorBase.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javafx.scene.control.behavior;\n+\n+import javafx.event.Event;\n+import javafx.event.EventType;\n+\n+\/**\n+ * Determines whether an event passes certain criteria.\n+ *\n+ * @since 22\n+ *\/\n+public interface EventCriteria<T extends Event> {\n+    \/**\n+     * Returns the event type for which this criteria are valid.\n+     * @return the event type\n+     *\/\n+    public EventType<T> getEventType();\n+\n+    \/**\n+     * Returns true if the specified event matches this criteria.\n+     * @param ev the event\n+     * @return true if match occurs\n+     *\/\n+    public boolean isEventAcceptable(T ev);\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/behavior\/EventCriteria.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.control.behavior;\n+\n+\/**\n+ * A function tag is a public handle for a function in the context of InputMap.\n+ *\n+ * @since 22\n+ *\/\n+public final class FunctionTag {\n+    \/** Constructs the function tag. *\/\n+    public FunctionTag() {\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/behavior\/FunctionTag.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,584 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javafx.scene.control.behavior;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.control.Control;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import com.sun.javafx.scene.control.input.HList;\n+\n+\/**\n+ * InputMap is a class that is set on a given {@link Control}. When the Node receives\n+ * an input event from the system, it passes this event in to the InputMap where\n+ * the InputMap can check all installed mappings to see if there is any\n+ * suitable mapping, and if so, fire the provided {@link EventHandler}.\n+ *\n+ * @param <C> The type of the Control that the InputMap is installed in.\n+ * @since 22\n+ *\/\n+public final class InputMap<C extends Control> {\n+    \/** contains user- and behavior-specific key bindings and function mappings *\/\n+    private static class Entry { \/\/ TODO rename to Mapping?\n+        Object value;\n+        BehaviorBase behavior;\n+        Object behaviorValue;\n+\n+        public Object getValue() {\n+            if (value == NULL) {\n+                return null;\n+            } else if (value == null) {\n+                return behaviorValue;\n+            }\n+            return value;\n+        }\n+    }\n+\n+    private static final Object NULL = new Object();\n+    private static final Object ON_KEY_ENTER = new Object();\n+    private static final Object ON_KEY_EXIT = new Object();\n+    private final C control;\n+    \/\/ EventType<?> -> Entry with value=List<EventHandler> (behavior only)\n+    \/\/ KeyBinding -> Entry with value=FunctionTag\n+    \/\/ FunctionTag -> Entry with value=Runnable\n+    \/\/ ON_KEY_ENTER\/EXIT -> Entry with value=Runnable\n+    private final HashMap<Object,Entry> map = new HashMap<>();\n+\n+    \/**\n+     * The constructor.\n+     * @param control the owner\n+     *\/\n+    public InputMap(C control) {\n+        if (control == null) {\n+            throw new IllegalArgumentException(\"control cannot be null\");\n+        }\n+        this.control = control;\n+    }\n+\n+    \/**\n+     * The Control to which this InputMap is attached.\n+     *\/\n+    private final C getControl() {\n+        return control;\n+    }\n+\n+    private void handleEvent(Event ev) {\n+        if (ev == null || ev.isConsumed()) {\n+            return;\n+        }\n+\n+        EventType<?> t = ev.getEventType();\n+        HList handlers = getHandlers(t);\n+        if (handlers != null) {\n+            for (EventHandler h: handlers) {\n+                h.handle(ev);\n+                if (ev.isConsumed()) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void handleKeyEvent(Event ev) {\n+        if (ev == null || ev.isConsumed()) {\n+            return;\n+        }\n+\n+        KeyBinding k = KeyBinding.from((KeyEvent)ev);\n+        Runnable f = getFunction(k);\n+        if (f != null) {\n+            handleKeyFunctionEnter();\n+            try {\n+                f.run();\n+                ev.consume();\n+            } finally {\n+                handleKeyFunctionExit();\n+            }\n+            return;\n+        }\n+\n+        EventType<?> t = ev.getEventType();\n+        HList handlers = getHandlers(t);\n+        if (handlers != null) {\n+            handleKeyFunctionEnter();\n+            try {\n+                for (EventHandler h: handlers) {\n+                    h.handle(ev);\n+                    if (ev.isConsumed()) {\n+                        break;\n+                    }\n+                }\n+            } finally {\n+                handleKeyFunctionExit();\n+            }\n+        }\n+    }\n+\n+    private void handleKeyFunctionEnter() {\n+        Entry en = map.get(ON_KEY_ENTER);\n+        if (en != null) {\n+            Object x = en.getValue();\n+            if (x instanceof Runnable r) {\n+                r.run();\n+            }\n+        }\n+    }\n+\n+    private void handleKeyFunctionExit() {\n+        Entry en = map.get(ON_KEY_EXIT);\n+        if (en != null) {\n+            Object x = en.getValue();\n+            if (x instanceof Runnable r) {\n+                r.run();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Removes all the mappings set by the behavior.\n+     * Behavior developers do not need to call this method directly, as it is being called in BehaviorBase.dispose().\n+     *\n+     * @param behavior\n+     *\/\n+    void unregister(BehaviorBase behavior) {\n+        Objects.nonNull(behavior);\n+\n+        for (Entry en: map.values()) {\n+            if (en.behavior == behavior) {\n+                en.behavior = null;\n+                en.behaviorValue = null;\n+            }\n+        }\n+    }\n+\n+    <T extends Event> void addHandler(\n+        BehaviorBase behavior,\n+        EventType<T> type,\n+        boolean consume,\n+        boolean tail,\n+        EventHandler<T> handler\n+    ) {\n+        if (consume) {\n+            extendHandlers(behavior, type, tail, new EventHandler<T>() {\n+                @Override\n+                public void handle(T ev) {\n+                    handler.handle(ev);\n+                    ev.consume();\n+                }\n+            });\n+        } else {\n+            extendHandlers(behavior, type, tail, handler);\n+        }\n+    }\n+\n+    <T extends Event> void addHandler(\n+        BehaviorBase behavior,\n+        EventCriteria<T> criteria,\n+        boolean consume,\n+        boolean tail,\n+        EventHandler<T> handler\n+    ) {\n+        EventType<T> type = criteria.getEventType();\n+        extendHandlers(behavior, type, tail, new EventHandler<T>() {\n+            @Override\n+            public void handle(T ev) {\n+                if (criteria.isEventAcceptable(ev)) {\n+                    handler.handle(ev);\n+                    if (consume) {\n+                        ev.consume();\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    private <T extends Event> void extendHandlers(\n+        BehaviorBase behavior,\n+        EventType<T> t,\n+        boolean tail,\n+        EventHandler<T> h\n+    ) {\n+        Objects.nonNull(behavior);\n+        Entry en = addListenerIfNeeded(t);\n+\n+        HList handlers = HList.from(en.behaviorValue);\n+        handlers.add(h, tail);\n+        en.behavior = behavior;\n+        en.behaviorValue = handlers;\n+    }\n+\n+    \/**\n+     * Adds a user-specified function under the given function tag.\n+     * This function will override any function set by the behavior.\n+     * @param tag the function tag\n+     * @param function the function\n+     *\/\n+    public void registerFunction(FunctionTag tag, Runnable function) {\n+        Objects.requireNonNull(tag, \"function tag must not be null\");\n+        Objects.requireNonNull(function, \"function must not be null\");\n+        addFunction(tag, function, null);\n+    }\n+\n+    \/**\n+     * Maps a function to the function tag, for use by the behavior.\n+     * This method will not override any previous mapping added by {@link #registerFunction(FunctionTag,Runnable)}.\n+     *\n+     * @param behavior the owner\n+     * @param tag the function tag\n+     * @param function the function\n+     *\/\n+    void registerFunction(BehaviorBase behavior, FunctionTag tag, Runnable function) {\n+        Objects.requireNonNull(behavior, \"behavior must not be null\");\n+        Objects.requireNonNull(tag, \"tag must not be null\");\n+        Objects.requireNonNull(function, \"function must not be null\");\n+        addFunction(tag, function, behavior);\n+    }\n+\n+    \/**\n+     * Link a key binding to the specified function tag.\n+     * This method will override a mapping set by the behavior.\n+     *\n+     * @param k the key binding\n+     * @param tag the function tag\n+     *\/\n+    public void registerKey(KeyBinding k, FunctionTag tag) {\n+        Objects.requireNonNull(k, \"KeyBinding must not be null\");\n+        Objects.requireNonNull(tag, \"function tag must not be null\");\n+        addBinding(k, tag, null);\n+    }\n+\n+    \/**\n+     * Maps a key binding to the specified function tag, for use by the behavior.\n+     * A null key binding will result in no change to this input map.\n+     * This method will not override a user mapping added by {@link #registerKey(KeyBinding,FunctionTag)}.\n+     *\n+     * @param behavior the owner\n+     * @param k the key binding, can be null TODO variant: KeyBinding.NA\n+     * @param tag the function tag\n+     *\/\n+    void registerKey(BehaviorBase behavior, KeyBinding k, FunctionTag tag) {\n+        if (k == null) {\n+            return;\n+        }\n+        Objects.requireNonNull(behavior, \"behavior must not be null\");\n+        Objects.requireNonNull(tag, \"function tag must not be null\");\n+        addBinding(k, tag, behavior);\n+    }\n+\n+    \/**\n+     * Maps a key binding to the specified function tag, as a part of the behavior.\n+     * This method will not override a user mapping added by {@link #registerKey(KeyBinding,FunctionTag)}.\n+     *\n+     * @param behavior the owner\n+     * @param code the key code to construct a {@link KeyBinding}\n+     * @param tag the function tag\n+     *\/\n+    void registerKey(BehaviorBase behavior, KeyCode code, FunctionTag tag) {\n+        registerKey(behavior, KeyBinding.of(code), tag);\n+    }\n+\n+    private void addFunction(FunctionTag tag, Runnable function, BehaviorBase behavior) {\n+        Entry en = map.get(tag);\n+        if (en == null) {\n+            en = new Entry();\n+            map.put(tag, en);\n+        }\n+\n+        if (behavior == null) {\n+            \/\/ user mapping\n+            en.value = function;\n+        } else {\n+            \/\/ behavior mapping\n+            en.behavior = behavior;\n+            en.behaviorValue = function;\n+        }\n+    }\n+\n+    private void addBinding(KeyBinding k, FunctionTag tag, BehaviorBase behavior) {\n+        Entry en = map.get(k);\n+        if (en == null) {\n+            en = new Entry();\n+            map.put(k, en);\n+        }\n+\n+        if (behavior == null) {\n+            \/\/ user mapping\n+        } else {\n+            \/\/ behavior mapping\n+            en.behavior = behavior;\n+            en.behaviorValue = tag;\n+        }\n+\n+        EventType<KeyEvent> type = k.getEventType();\n+        addListenerIfNeeded(type);\n+    }\n+\n+    \/**\n+     * Returns a {@code Runnable} mapped to the specified function tag, or null if no such mapping exists.\n+     *\n+     * @param tag the function tag\n+     * @return the function, or null\n+     *\/\n+    public Runnable getFunction(FunctionTag tag) {\n+        Entry en = map.get(tag);\n+        if (en != null) {\n+            Object v = en.getValue();\n+            if (v instanceof Runnable r) {\n+                return r;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns a default {@code Runnable} mapped to the specified function tag, or null if no such mapping exists.\n+     *\n+     * @param tag the function tag\n+     * @return the function, or null\n+     *\/\n+    public Runnable getDefaultFunction(FunctionTag tag) {\n+        Entry en = map.get(tag);\n+        if (en != null) {\n+            Object v = en.behaviorValue;\n+            if (v instanceof Runnable r) {\n+                return r;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns a {@code Runnable} mapped to the specified {@link KeyBinding},\n+     * or null if no such mapping exists.\n+     * <p>\n+     * @implNote\n+     * This method is a functional equivalent of calling {@link #getFunctionTag(KeyBinding)}\n+     * followed by {@link #getFunction(FunctionTag)} (if the tag is not null).\n+     *\n+     * @param k the key binding\n+     * @return the function, or null\n+     *\/\n+    public Runnable getFunction(KeyBinding k) {\n+        FunctionTag tag = getFunctionTag(k);\n+        if (tag != null) {\n+            return getFunction(tag);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns a {@code FunctionTag} mapped to the specified {@link KeyBinding},\n+     * or null if no such mapping exists.\n+     *\n+     * @param k the key binding\n+     * @return the function tag, or null\n+     *\/\n+    public FunctionTag getFunctionTag(KeyBinding k) {\n+        Entry en = map.get(k);\n+        if (en != null) {\n+            Object v = en.getValue();\n+            if (v instanceof FunctionTag tag) {\n+                return tag;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns a default {@code Runnable} mapped to the specified {@link KeyBinding},\n+     * or null if no such mapping exists.\n+     *\n+     * @param k the key binding\n+     * @return the function, or null\n+     *\/\n+    public Runnable getDefaultFunction(KeyBinding k) {\n+        \/\/ TODO this needs to be tested\n+        Entry en = map.get(k);\n+        if (en != null) {\n+            Object v = en.behaviorValue;\n+            if (v instanceof FunctionTag tag) {\n+                return getDefaultFunction(tag);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private HList getHandlers(EventType<?> t) {\n+        Entry en = map.get(t);\n+        if (en != null) {\n+            Object v = en.getValue();\n+            if (v instanceof HList list) {\n+                return list;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Entry addListenerIfNeeded(EventType<?> t) {\n+        Entry en = map.get(t);\n+        if (en == null) {\n+            en = new Entry();\n+            map.put(t, en);\n+\n+            if (t.getSuperType() == KeyEvent.ANY) {\n+                \/\/ key handler is special because of key bindings\n+                getControl().addEventHandler(t, this::handleKeyEvent);\n+            } else {\n+                getControl().addEventHandler(t, this::handleEvent);\n+            }\n+        }\n+        return en;\n+    }\n+\n+    \/**\n+     * Unbinds the specified key binding.\n+     *\n+     * @param k the key binding\n+     *\/\n+    public void unbind(KeyBinding k) {\n+        Entry en = map.get(k);\n+        if (en != null) {\n+            en.value = NULL;\n+        }\n+    }\n+\n+    \/**\n+     * Resets all key bindings set by user to the values set by the behavior, if any.\n+     *\/\n+    public void resetKeyBindings() {\n+        Iterator<Map.Entry<Object, Entry>> it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry<Object, Entry> me = it.next();\n+            if (me.getKey() instanceof KeyBinding) {\n+                Entry en = me.getValue();\n+                en.value = null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Restores the specified key binding to the value set by the behavior, if any.\n+     *\n+     * @param k the key binding\n+     *\/\n+    public void restoreDefaultKeyBinding(KeyBinding k) {\n+        Entry en = map.get(k);\n+        if (en != null) {\n+            en.value = null;\n+            if (en.behaviorValue == null) {\n+                map.remove(k);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Restores the specified function tag to the value set by the behavior, if any.\n+     *\n+     * @param tag the function tag\n+     *\/\n+    public void restoreDefaultFunction(FunctionTag tag) {\n+        Objects.requireNonNull(tag, \"function tag must not be null\");\n+        Entry en = map.get(tag);\n+        if (en != null) {\n+            en.value = null;\n+            if (en.behaviorValue == null) {\n+                map.remove(tag);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Collects all mapped key bindings (set either by the user or the behavior).\n+     *\n+     * @return a Set of key bindings\n+     *\/\n+    public Set<KeyBinding> getKeyBindings() {\n+        return map.keySet().stream().\n+            filter((k) -> (k instanceof KeyBinding)).\n+            map((x) -> (KeyBinding)x).\n+            collect(Collectors.toSet());\n+    }\n+\n+    \/**\n+     * Maps a new KeyBinding as an alias to the existing one with the same owner and function tag.\n+     * This method does nothing if there is no mapping for k1.\n+     * Subsequent changes to the original mapping are not propagated to the alias.\n+     *\n+     * @param existing the existing key binding\n+     * @param newk the new key binding\n+     *\/\n+    void duplicateMapping(KeyBinding existing, KeyBinding newk) {\n+        Entry en1 = map.get(existing);\n+        if ((en1 != null) && (en1.behaviorValue != null)) {\n+            Entry en2 = map.get(newk);\n+            if (en2 == null) {\n+                en2 = new Entry();\n+            }\n+            en2.behavior = en1.behavior;\n+            en2.behaviorValue = en1.behaviorValue;\n+            map.put(newk, en2);\n+        }\n+    }\n+\n+    void setOnKeyEventEnter(BehaviorBase behavior, Runnable action) {\n+        Objects.nonNull(behavior);\n+        Entry en = map.get(ON_KEY_ENTER);\n+        if (en == null) {\n+            en = new Entry();\n+            map.put(ON_KEY_ENTER, en);\n+        }\n+\n+        if (behavior == null) {\n+            en.value = action;\n+        } else {\n+            en.behavior = behavior;\n+            en.behaviorValue = action;\n+        }\n+    }\n+\n+   void setOnKeyEventExit(BehaviorBase behavior, Runnable action) {\n+        Objects.nonNull(behavior);\n+        Entry en = map.get(ON_KEY_EXIT);\n+        if (en == null) {\n+            en = new Entry();\n+            map.put(ON_KEY_EXIT, en);\n+        }\n+\n+        if (behavior == null) {\n+            en.value = action;\n+        } else {\n+            en.behavior = behavior;\n+            en.behaviorValue = action;\n+        }\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/behavior\/InputMap.java","additions":584,"deletions":0,"binary":false,"changes":584,"status":"added"},{"patch":"@@ -0,0 +1,838 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.control.behavior;\n+\n+import java.util.EnumSet;\n+import java.util.Objects;\n+import javafx.event.EventType;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import com.sun.javafx.PlatformUtil;\n+\n+\/**\n+ * Key binding provides a way to map key event to a hash table key for easy matching.\n+ * Also it allows for encoding platform-specific keys without resorting to nested and\/or\n+ * multiple key maps.\n+ *\n+ * @since 22\n+ *\/\n+public class KeyBinding implements EventCriteria<KeyEvent> {\n+    \/**\n+     * Condition used to build input key mappings.\n+     * <p>\n+     * The KCondition values are used as keys in a hash table, so when the platform sends a key event with multiple\n+     * modifiers, some modifiers are dropped in order to make the final key binding to function lookup unambiguous.\n+     * <p>\n+     * The mapping is as follows:\n+     * <pre>\n+     * KCondition    Mac         Windows\/Linux\n+     * ALT           OPTION      ALT\n+     * COMMAND       COMMAND     (ignored)\n+     * CTRL          CTRL        CTRL\n+     * META          COMMAND     META\n+     * OPTION        OPTION      (ignored)\n+     * SHIFT         SHIFT       SHIFT\n+     * SHORTCUT      COMMAND     CTRL\n+     * WINDOWS       (ignored)   META\n+     * <\/pre>\n+     *\/\n+    private enum KCondition {\n+        \/\/ modifier keys\n+        \/** ALT modifier, mapped to OPTION on Mac, ALT on Windows\/Linux *\/\n+        ALT,\n+        \/** COMMAND modifier, mapped to COMMAND on Mac only *\/\n+        COMMAND,\n+        \/** CTRL modifier *\/\n+        CTRL,\n+        \/** META modifier, mapped to COMMAND on Mac, META on Windows\/Linux *\/\n+        META,\n+        \/** OPTION modifier, mapped to OPTION on Mac only *\/\n+        OPTION,\n+        \/** SHIFT modifier *\/\n+        SHIFT,\n+        \/** SHORTCUT modifier, mapped to COMMAND on Mac, CTRL on Windows\/Linux *\/\n+        SHORTCUT,\n+        \/** Windows key modifier (⊞), mapped to WINDOWS on Windows only *\/\n+        WINDOWS,\n+\n+        \/\/ event types\n+        \/** a key press event *\/\n+        KEY_PRESS,\n+        \/** a key release event *\/\n+        KEY_RELEASE,\n+        \/** a key typed event *\/\n+        KEY_TYPED,\n+\n+        \/\/ platform specificity\n+        \/** specifies Linux platform *\/\n+        FOR_LINUX,\n+        \/** specifies non-Linux platform *\/\n+        NOT_FOR_LINUX,\n+        \/** specifies Mac platform *\/\n+        FOR_MAC,\n+        \/** specifies non-Mac platform *\/\n+        NOT_FOR_MAC,\n+        \/** specifies Windows platform *\/\n+        FOR_WIN,\n+        \/** specifies non-Windows platform *\/\n+        NOT_FOR_WIN,\n+    }\n+\n+    private final Object key; \/\/ KeyCode or String\n+    private final EnumSet<KCondition> modifiers;\n+\n+    private KeyBinding(Object key, EnumSet<KCondition> modifiers) {\n+        this.key = key;\n+        this.modifiers = modifiers;\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a key press.\n+     *\n+     * @param code key code\n+     * @return KeyBinding\n+     *\/\n+    public static KeyBinding of(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESS);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a command-code key press.\n+     *\n+     * @param code key code\n+     * @return KeyBinding\n+     *\/\n+    public static KeyBinding command(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESS, KCondition.COMMAND);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a alt-code key press.\n+     *\n+     * @param code key code\n+     * @return KeyBinding\n+     *\/\n+    public static KeyBinding alt(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESS, KCondition.ALT);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a ctrl-code key press.\n+     *\n+     * @param code key code\n+     * @return KeyBinding\n+     *\/\n+    public static KeyBinding ctrl(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESS, KCondition.CTRL);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a shift-code key press.\n+     *\n+     * @param code key code\n+     * @return KeyBinding\n+     *\/\n+    public static KeyBinding shift(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESS, KCondition.SHIFT);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a shortcut-code key press.\n+     *\n+     * @param code key code\n+     * @return KeyBinding\n+     *\/\n+    public static KeyBinding shortcut(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESS, KCondition.SHORTCUT);\n+    }\n+\n+    private static KeyBinding create(Object key, KCondition... mods) {\n+        return builder().init(key, mods).build();\n+    }\n+\n+    \/**\n+     * Determines whether this key binding if for the key press event.\n+     * @return true if this key binding if for the key press event\n+     *\/\n+    public boolean isKeyPress() {\n+        return modifiers.contains(KCondition.KEY_PRESS);\n+    }\n+\n+    \/**\n+     * Determines whether this key binding if for the key release event.\n+     * @return true if this key binding if for the key release event\n+     *\/\n+    public boolean isKeyRelease() {\n+        return modifiers.contains(KCondition.KEY_RELEASE);\n+    }\n+\n+    \/**\n+     * Determines whether this key binding if for the key typed event.\n+     * @return true if this key binding if for the key typed event\n+     *\/\n+    public boolean isKeyTyped() {\n+        return modifiers.contains(KCondition.KEY_TYPED);\n+    }\n+\n+    \/**\n+     * Determines whether {@code shortcut} key is down in this key binding.\n+     * @return true if {@code shortcut} key is down in this key binding\n+     *\/\n+    public boolean isShortcut() {\n+        if (PlatformUtil.isMac()) {\n+            return modifiers.contains(KCondition.COMMAND);\n+        }\n+        return modifiers.contains(KCondition.CTRL);\n+    }\n+\n+    \/**\n+     * Determines whether {@code alt} key is down in this key binding.\n+     * @return true if {@code alt} key is down in this key binding\n+     *\/\n+    public boolean isAlt() {\n+        return modifiers.contains(KCondition.ALT);\n+    }\n+\n+    \/**\n+     * Determines whether {@code control} key is down in this key binding.\n+     * @return true if {@code control} key is down in this key binding\n+     *\/\n+    public boolean isControl() {\n+        return modifiers.contains(KCondition.CTRL);\n+    }\n+\n+    \/**\n+     * Determines whether {@code control} key is down in this key binding.\n+     * Applies to macOS platform only.\n+     * @return true if {@code control} key is down in this key binding\n+     *\/\n+    public boolean isCommand() {\n+        return modifiers.contains(KCondition.COMMAND);\n+    }\n+\n+    \/**\n+     * Determines whether {@code meta} key is down in this key binding.\n+     * @return true if {@code meta} key is down in this key binding\n+     *\/\n+    public boolean isMeta() {\n+        return modifiers.contains(KCondition.META);\n+    }\n+\n+    \/**\n+     * Determines whether {@code option} key is down in this key binding.\n+     * Applies to macOS only.\n+     * @return true if {@code option} key is down in this key binding\n+     *\/\n+    public boolean isOption() {\n+        return modifiers.contains(KCondition.OPTION);\n+    }\n+\n+    \/**\n+     * Determines whether {@code shift} key is down in this key binding.\n+     * @return true if {@code shift} key is down in this key binding\n+     *\/\n+    public boolean isShift() {\n+        return modifiers.contains(KCondition.SHIFT);\n+    }\n+\n+    \/**\n+     * Returns a {@link KeyCode} or null if the key binding is not for a key code.\n+     * @return key code\n+     *\/\n+    public KeyCode getKeyCode() {\n+        if (key instanceof KeyCode c) {\n+            return c;\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Creates a {@link Builder}.\n+     * @return the Builder instance\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int h = KeyBinding.class.hashCode();\n+        h = 31 * h + key.hashCode();\n+        h = 31 * h + modifiers.hashCode();\n+        return h;\n+    }\n+\n+    @Override\n+    public boolean equals(Object x) {\n+        if (x == this) {\n+            return true;\n+        } else if (x instanceof KeyBinding k) {\n+            return\n+                Objects.equals(key, k.key) &&\n+                modifiers.equals(k.modifiers);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Creates a Builder with a key pressed event.\n+     * @param c key code\n+     * @return Builder instance\n+     *\/\n+    public static Builder with(KeyCode c) {\n+        return builder().with(c);\n+    }\n+\n+    \/**\n+     * Creates a Builder with a key released event.\n+     * @param c key code\n+     * @return Builder instance\n+     *\/\n+    public static Builder withRelease(KeyCode c) {\n+        return builder().withRelease(c);\n+    }\n+\n+    \/**\n+     * Creates a Builder with a key pressed event.\n+     * @param c character pressed\n+     * @return Builder instance\n+     *\/\n+    public static Builder with(String c) {\n+        return builder().with(c);\n+    }\n+\n+    \/**\n+     * Creates a KeyBinding from a KeyEvent.  This call drops multiple key modifiers, performing\n+     * translation when necessary.  May return null if the event does not correspond to a valid KeyBinding.\n+     * @param ev key event\n+     * @return the key binding\n+     *\/\n+    public static KeyBinding from(KeyEvent ev) {\n+        Object key;\n+        EnumSet<KCondition> m = EnumSet.noneOf(KCondition.class);\n+        EventType<KeyEvent> t = ev.getEventType();\n+        if(t == KeyEvent.KEY_PRESSED) {\n+            m.add(KCondition.KEY_PRESS);\n+            key = ev.getCode();\n+        } else if(t == KeyEvent.KEY_RELEASED) {\n+            m.add(KCondition.KEY_RELEASE);\n+            key = ev.getCode();\n+        } else if(t == KeyEvent.KEY_TYPED) {\n+            m.add(KCondition.KEY_TYPED);\n+            key = ev.getCharacter();\n+        } else {\n+            return null;\n+        }\n+\n+        boolean alt = ev.isAltDown();\n+        boolean ctrl = ev.isControlDown();\n+        boolean meta = ev.isMetaDown();\n+        boolean shortcut = ev.isShortcutDown();\n+        boolean option = false;\n+        boolean command = false;\n+\n+        boolean mac = PlatformUtil.isMac();\n+        boolean win = PlatformUtil.isWindows();\n+\n+        \/\/ drop multiple modifiers, translating when necessary\n+\n+        if (mac) {\n+            if (alt) {\n+                alt = false;\n+                option = true;\n+            }\n+            if (shortcut) {\n+                meta = false;\n+                command = true;\n+            }\n+        } else {\n+            if (ctrl) {\n+                shortcut = false;\n+            }\n+        }\n+\n+        if (alt) {\n+            m.add(KCondition.ALT);\n+        }\n+\n+        if (command) {\n+            m.add(KCondition.COMMAND);\n+        }\n+\n+        if (ctrl) {\n+            m.add(KCondition.CTRL);\n+        }\n+\n+        if (meta) {\n+            m.add(KCondition.META);\n+        }\n+\n+        if (option) {\n+            m.add(KCondition.OPTION);\n+        }\n+\n+        if (ev.isShiftDown()) {\n+            m.add(KCondition.SHIFT);\n+        }\n+\n+        KeyBinding keyBinding = new KeyBinding(key, m);\n+        \/\/System.err.println(\"kb=\" + keyBinding + \" ev=\" + toString(ev)); \/\/ FIX\n+        return keyBinding;\n+    }\n+\n+    \/\/ FIX remove, debug\n+\/\/    private static String toString(KeyEvent ev) {\n+\/\/        StringBuilder sb = new StringBuilder(\"KeyEvent{\");\n+\/\/        sb.append(\"type=\").append(ev.getEventType());\n+\/\/        sb.append(\", char=\").append(ev.getCharacter());\n+\/\/\n+\/\/        String ch = ev.getCharacter();\n+\/\/        int sz = ch.length();\n+\/\/        if (sz > 0) {\n+\/\/            sb.append(\"(\");\n+\/\/            for (int i = 0; i < ch.length(); i++) {\n+\/\/                sb.append(String.format(\"%02X\", (int)ch.charAt(i)));\n+\/\/            }\n+\/\/            sb.append(\")\");\n+\/\/        }\n+\/\/\n+\/\/        sb.append(\", code=\").append(ev.getCode());\n+\/\/\n+\/\/        if (ev.isShiftDown()) {\n+\/\/            sb.append(\", shift\");\n+\/\/        }\n+\/\/        if (ev.isControlDown()) {\n+\/\/            sb.append(\", control\");\n+\/\/        }\n+\/\/        if (ev.isAltDown()) {\n+\/\/            sb.append(\", alt\");\n+\/\/        }\n+\/\/        if (ev.isMetaDown()) {\n+\/\/            sb.append(\", meta\");\n+\/\/        }\n+\/\/        if (ev.isShortcutDown()) {\n+\/\/            sb.append(\", shortcut\");\n+\/\/        }\n+\/\/\n+\/\/        return sb.append(\"}\").toString();\n+\/\/    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"KeyBinding{key=\");\n+        sb.append(key);\n+        sb.append(\", modifiers=\");\n+        sb.append(modifiers);\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Returns the event type for this key binding.\n+     * @return KeyEvent\n+     *\/\n+    @Override\n+    public EventType<KeyEvent> getEventType() {\n+        if (isKeyPress()) {\n+            return KeyEvent.KEY_PRESSED;\n+        } else if (isKeyRelease()) {\n+            return KeyEvent.KEY_RELEASED;\n+        } else {\n+            return KeyEvent.KEY_TYPED;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isEventAcceptable(KeyEvent ev) {\n+        return KeyBinding.from(ev).equals(this);\n+    }\n+\n+    \/** Key bindings builder *\/\n+    public static class Builder {\n+        private Object key; \/\/ KeyCode or String\n+        private final EnumSet<KCondition> m = EnumSet.noneOf(KCondition.class);\n+\n+        \/** Constructs a Builder *\/\n+        public Builder() {\n+        }\n+\n+        \/**\n+         * Creates a Builder with key pressed event.\n+         * @param c key code\n+         * @return the Builder instance\n+         *\/\n+        public Builder with(KeyCode c) {\n+            if (key != null) {\n+                throw new IllegalArgumentException(\"only one KeyCode or character can be set\");\n+            }\n+            key = c;\n+            return this;\n+        }\n+\n+        \/**\n+         * Creates a Builder with key released event.\n+         * @param c key code\n+         * @return the Builder instance\n+         *\/\n+        public Builder withRelease(KeyCode c) {\n+            if (key != null) {\n+                throw new IllegalArgumentException(\"only one KeyCode or character can be set\");\n+            }\n+            key = c;\n+            m.add(KCondition.KEY_RELEASE);\n+            return this;\n+        }\n+\n+        \/**\n+         * Creates a Builder with a key pressed event.\n+         * @param c key character\n+         * @return the Builder instance\n+         *\/\n+        public Builder with(String c) {\n+            if (key != null) {\n+                throw new IllegalArgumentException(\"only one KeyCode or character can be set\");\n+            }\n+            key = c;\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code alt} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder alt() {\n+            m.add(KCondition.ALT);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code alt} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder alt(boolean on) {\n+            if (on) {\n+                m.add(KCondition.ALT);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code command} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder command() {\n+            m.add(KCondition.COMMAND);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code command} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder command(boolean on) {\n+            if (on) {\n+                m.add(KCondition.COMMAND);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code control} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder control() {\n+            m.add(KCondition.CTRL);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code control} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder control(boolean on) {\n+            if (on) {\n+                m.add(KCondition.CTRL);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code meta} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder meta() {\n+            m.add(KCondition.META);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code meta} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder meta(boolean on) {\n+            if (on) {\n+                m.add(KCondition.META);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code option} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder option() {\n+            m.add(KCondition.OPTION);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code option} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder option(boolean on) {\n+            if (on) {\n+                m.add(KCondition.OPTION);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code shift} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder shift() {\n+            m.add(KCondition.SHIFT);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code shift} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder shift(boolean on) {\n+            if (on) {\n+                m.add(KCondition.SHIFT);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code shortcut} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder shortcut() {\n+            m.add(KCondition.SHORTCUT);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code shortcut} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder shortcut(boolean on) {\n+            if (on) {\n+                m.add(KCondition.SHORTCUT);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets this key binding applicable to the macOS platform.\n+         * @return this Builder\n+         *\/\n+        public Builder forMac() {\n+            m.add(KCondition.FOR_MAC);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets this key binding applicable to any but the macOS platform.\n+         * @return this Builder\n+         *\/\n+        public Builder notForMac() {\n+            m.add(KCondition.NOT_FOR_MAC);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets this key binding applicable to the Windows platform.\n+         * @return this Builder\n+         *\/\n+        public Builder forWindows() {\n+            m.add(KCondition.FOR_WIN);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets this key binding applicable to any but the Windows platform.\n+         * @return this Builder\n+         *\/\n+        public Builder notForWindows() {\n+            m.add(KCondition.NOT_FOR_WIN);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets this key binding applicable to the Linux platform.\n+         * @return this Builder\n+         *\/\n+        public Builder forLinux() {\n+            m.add(KCondition.FOR_LINUX);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets this key binding applicable to any but the Linux platform.\n+         * @return this Builder\n+         *\/\n+        public Builder notForLinux() {\n+            m.add(KCondition.NOT_FOR_LINUX);\n+            return this;\n+        }\n+\n+        private Builder init(Object key, KCondition... mods) {\n+            this.key = key;\n+            for (KCondition c : mods) {\n+                m.add(c);\n+            }\n+            return this;\n+        }\n+\n+        private void replace(KCondition c, KCondition replaceWith) {\n+            if (m.contains(c)) {\n+                m.remove(c);\n+                m.add(replaceWith);\n+            }\n+        }\n+\n+        \/**\n+         * Creates a new {@link KeyBinding} instance, or null if the key binding is not applicable to this platform.\n+         * TODO variant: KeyBinding.NA\n+         * TODO alternatively, remove forMac and use Platform.isXXX\n+         *\n+         * @return a new key binding instance.\n+         *\/\n+        public KeyBinding build() {\n+            \/\/ mac-windows for now.  we might rethink the logic later if necessary.\n+            boolean mac = PlatformUtil.isMac();\n+            boolean win = PlatformUtil.isWindows();\n+            boolean linux = PlatformUtil.isLinux();\n+\n+            if (mac) {\n+                if (m.contains(KCondition.NOT_FOR_MAC)) {\n+                    return null;\n+                } else if (m.contains(KCondition.FOR_WIN)) {\n+                    return null;\n+                } else if (m.contains(KCondition.FOR_LINUX)) {\n+                    return null;\n+                } else if (m.contains(KCondition.WINDOWS)) {\n+                    return null;\n+                }\n+\n+                replace(KCondition.ALT, KCondition.OPTION);\n+                replace(KCondition.META, KCondition.COMMAND);\n+                replace(KCondition.SHORTCUT, KCondition.COMMAND);\n+            } else if (win) {\n+                if (m.contains(KCondition.NOT_FOR_WIN)) {\n+                    return null;\n+                } else if (m.contains(KCondition.FOR_MAC)) {\n+                    return null;\n+                } else if (m.contains(KCondition.FOR_LINUX)) {\n+                    return null;\n+                }\n+\n+                replace(KCondition.SHORTCUT, KCondition.CTRL);\n+            } else if (linux) {\n+                if (m.contains(KCondition.NOT_FOR_LINUX)) {\n+                    return null;\n+                } else if (m.contains(KCondition.FOR_MAC)) {\n+                    return null;\n+                } else if (m.contains(KCondition.FOR_WIN)) {\n+                    return null;\n+                }\n+\n+                replace(KCondition.SHORTCUT, KCondition.CTRL);\n+            }\n+\n+            if (!mac) {\n+                if (m.contains(KCondition.COMMAND)) {\n+                    return null;\n+                } else if (m.contains(KCondition.OPTION)) {\n+                    return null;\n+                }\n+\n+                replace(KCondition.WINDOWS, KCondition.META);\n+            }\n+\n+            \/\/ remove platform entries\n+            m.remove(KCondition.FOR_LINUX);\n+            m.remove(KCondition.NOT_FOR_LINUX);\n+            m.remove(KCondition.FOR_MAC);\n+            m.remove(KCondition.NOT_FOR_MAC);\n+            m.remove(KCondition.FOR_WIN);\n+            m.remove(KCondition.NOT_FOR_WIN);\n+\n+            boolean pressed = m.contains(KCondition.KEY_PRESS);\n+            boolean released = m.contains(KCondition.KEY_RELEASE);\n+            boolean typed = m.contains(KCondition.KEY_TYPED);\n+\n+            int ct = 0;\n+            KCondition t = null;\n+            if (pressed) {\n+                ct++;\n+                t = KCondition.KEY_PRESS;\n+            }\n+            if (released) {\n+                ct++;\n+                t = KCondition.KEY_RELEASE;\n+            }\n+            if (typed) {\n+                ct++;\n+                t = KCondition.KEY_TYPED;\n+            }\n+\n+            \/\/ validate event type\n+            if (ct > 1) {\n+                throw new IllegalArgumentException(\"more than one key event type is specified\");\n+            }\n+\n+            if (t == null) {\n+                t = KCondition.KEY_PRESS;\n+            }\n+            m.add(t);\n+\n+            \/\/ TODO validate: shortcut and !(other shortcut modifier)\n+            return new KeyBinding(key, m);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/behavior\/KeyBinding.java","additions":838,"deletions":0,"binary":false,"changes":838,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * <p>The <code>javafx.scene.control.behavior<\/code> package contains classes related\n+ * to control's behavior: input map, key bindings, and base class for behavior implementations.\n+ * <\/p>\n+ *\/\n+package javafx.scene.control.behavior;\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/behavior\/package-info.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-\n@@ -34,1 +33,0 @@\n-\n@@ -57,1 +55,0 @@\n-\n@@ -83,1 +80,0 @@\n-\n@@ -104,3 +100,0 @@\n-        \/\/ install default input map for the control\n-        this.behavior = new ColorPickerBehavior(control);\n-\n@@ -122,0 +115,2 @@\n+        behavior = new ColorPickerBehavior(control);\n+\n@@ -262,3 +257,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public void dispose() {\n-        super.dispose();\n+    @Override\n+    public void install() {\n+        super.install();\n@@ -266,0 +261,5 @@\n+        behavior.install();\n+    }\n+\n+    @Override\n+    public void dispose() {\n@@ -269,0 +269,1 @@\n+        super.dispose();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ColorPickerSkin.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-\n@@ -57,1 +56,0 @@\n-\n@@ -103,1 +101,1 @@\n-    private final ComboBoxListViewBehavior behavior;\n+    private final ComboBoxListViewBehavior<T> behavior;\n@@ -141,3 +139,0 @@\n-        \/\/ install default input map for the control\n-        this.behavior = new ComboBoxListViewBehavior<>(control);\n-\n@@ -170,0 +165,2 @@\n+        behavior = new ComboBoxListViewBehavior<>(control);\n+\n@@ -237,3 +234,5 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public void dispose() {\n-        super.dispose();\n+    @Override\n+    public void install() {\n+        super.install();\n+        behavior.install();\n+    }\n@@ -241,0 +240,2 @@\n+    @Override\n+    public void dispose() {\n@@ -244,0 +245,1 @@\n+        super.dispose();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ComboBoxListViewSkin.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-\n@@ -41,1 +40,0 @@\n-\n@@ -65,1 +63,0 @@\n-\n@@ -87,3 +84,1 @@\n-\n-        \/\/ install default input map for the control\n-        this.behavior = new DatePickerBehavior(control);\n+        behavior = new DatePickerBehavior(control);\n@@ -166,3 +161,6 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public void dispose() {\n-        super.dispose();\n+    @Override\n+    public void install() {\n+        super.install();\n+\n+        behavior.install();\n+    }\n@@ -170,0 +168,2 @@\n+    @Override\n+    public void dispose() {\n@@ -173,0 +173,1 @@\n+        super.dispose();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/DatePickerSkin.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import com.sun.javafx.scene.control.behavior.TextAreaBehavior;\n-import com.sun.javafx.scene.control.skin.Utils;\n+import java.util.List;\n@@ -59,1 +58,0 @@\n-import javafx.scene.text.Text;\n@@ -61,0 +59,1 @@\n+import javafx.scene.text.Text;\n@@ -62,5 +61,3 @@\n-\n-import java.util.List;\n-\n-import static com.sun.javafx.PlatformUtil.isMac;\n-import static com.sun.javafx.PlatformUtil.isWindows;\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.scene.control.behavior.TextAreaBehavior;\n+import com.sun.javafx.scene.control.skin.Utils;\n@@ -166,5 +163,0 @@\n-        \/\/ install default input map for the text area control\n-        this.behavior = new TextAreaBehavior(control);\n-        this.behavior.setTextAreaSkin(this);\n-\/\/        control.setInputMap(behavior.getInputMap());\n-\n@@ -231,0 +223,3 @@\n+        \/\/ instantiate, but not install, the behavior\n+        behavior = new TextAreaBehavior(control, this);\n+\n@@ -521,1 +516,1 @@\n-                        lineStart(select, select && isMac());\n+                        lineStart(select, select && PlatformUtil.isMac());\n@@ -524,1 +519,1 @@\n-                        lineEnd(select, select && isMac());\n+                        lineEnd(select, select && PlatformUtil.isMac());\n@@ -714,1 +709,1 @@\n-        boolean goPastTrailingNewline = isWindows();\n+        boolean goPastTrailingNewline = PlatformUtil.isWindows();\n@@ -832,9 +827,17 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public void dispose() {\n-        if (getSkinnable() == null) return;\n-        getSkinnable().removeEventFilter(ScrollEvent.ANY, scrollEventFilter);\n-        getChildren().remove(scrollPane);\n-        super.dispose();\n-\n-        if (behavior != null) {\n-            behavior.dispose();\n+    @Override\n+    public void install() {\n+        super.install();\n+        behavior.install();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (getSkinnable() != null) {\n+            getSkinnable().removeEventFilter(ScrollEvent.ANY, scrollEventFilter);\n+            getChildren().remove(scrollPane);\n+\n+            if (behavior != null) {\n+                behavior.dispose();\n+            }\n+\n+            super.dispose();\n@@ -1019,5 +1022,0 @@\n-    @Override\n-    TextAreaBehavior getBehavior() {\n-        return behavior;\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TextAreaSkin.java","additions":28,"deletions":30,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -29,5 +29,0 @@\n-\n-import com.sun.javafx.scene.control.behavior.PasswordFieldBehavior;\n-import com.sun.javafx.scene.control.behavior.TextFieldBehavior;\n-import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;\n-\n@@ -63,0 +58,2 @@\n+import com.sun.javafx.scene.control.behavior.PasswordFieldBehavior;\n+import com.sun.javafx.scene.control.behavior.TextFieldBehavior;\n@@ -78,1 +75,1 @@\n-    private final TextFieldBehavior behavior;\n+    private TextFieldBehavior behavior;\n@@ -148,7 +145,0 @@\n-        \/\/ install default input map for the text field control\n-        this.behavior = (control instanceof PasswordField)\n-                ? new PasswordFieldBehavior((PasswordField)control)\n-                : new TextFieldBehavior(control);\n-        this.behavior.setTextFieldSkin(this);\n-\/\/        control.setInputMap(behavior.getInputMap());\n-\n@@ -387,5 +377,10 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public void dispose() {\n-        if (getSkinnable() == null) return;\n-        getChildren().removeAll(textGroup, handleGroup);\n-        super.dispose();\n+    @Override\n+    public void install() {\n+        super.install();\n+\n+        var c = getSkinnable();\n+        behavior = (c instanceof PasswordField f) ?\n+            new PasswordFieldBehavior(f, this) :\n+            new TextFieldBehavior(c, this);\n+        behavior.install();\n+    }\n@@ -393,2 +388,10 @@\n-        if (behavior != null) {\n-            behavior.dispose();\n+    @Override\n+    public void dispose() {\n+        if (getSkinnable() != null) {\n+            getChildren().removeAll(textGroup, handleGroup);\n+            super.dispose();\n+\n+            if (behavior != null) {\n+                behavior.dispose();\n+                behavior = null;\n+            }\n@@ -707,5 +710,0 @@\n-    @Override\n-    TextInputControlBehavior getBehavior() {\n-        return behavior;\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TextFieldSkin.java","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -34,11 +34,0 @@\n-\n-import com.sun.javafx.PlatformUtil;\n-import com.sun.javafx.scene.control.Properties;\n-import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;\n-import com.sun.javafx.scene.control.skin.FXVK;\n-import com.sun.javafx.scene.input.ExtendedInputMethodRequests;\n-import com.sun.javafx.tk.FontMetrics;\n-import com.sun.javafx.tk.Toolkit;\n-\n-import static com.sun.javafx.PlatformUtil.*;\n-\n@@ -93,0 +82,6 @@\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.scene.control.Properties;\n+import com.sun.javafx.scene.control.skin.FXVK;\n+import com.sun.javafx.scene.input.ExtendedInputMethodRequests;\n+import com.sun.javafx.tk.FontMetrics;\n+import com.sun.javafx.tk.Toolkit;\n@@ -238,1 +233,1 @@\n-                        (isWindows() || (control.getCaretPosition() == control.getAnchor())) &&\n+                        (PlatformUtil.isWindows() || (control.getCaretPosition() == control.getAnchor())) &&\n@@ -829,4 +824,0 @@\n-    TextInputControlBehavior getBehavior() {\n-        return null;\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TextInputControlSkin.java","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    exports javafx.scene.control.behavior;\n","filename":"modules\/javafx.controls\/src\/main\/java\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,8 @@\n+import static javafx.collections.FXCollections.observableArrayList;\n+import static javafx.scene.control.skin.TextInputSkinShim.isCaretBlinking;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.createBehavior;\n@@ -29,18 +37,1 @@\n-\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import com.sun.javafx.scene.control.behavior.BehaviorBase;\n-import com.sun.javafx.scene.control.behavior.ListCellBehavior;\n-import com.sun.javafx.scene.control.behavior.TextFieldBehavior;\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n-import com.sun.javafx.scene.control.inputmap.KeyBinding;\n-import com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n-\n-import static com.sun.javafx.scene.control.behavior.TextBehaviorShim.*;\n-import static javafx.collections.FXCollections.*;\n-import static javafx.scene.control.skin.TextInputSkinShim.*;\n-import static org.junit.Assert.*;\n-import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n-\n+import java.util.Set;\n@@ -50,0 +41,1 @@\n+import javafx.scene.control.ControlShim;\n@@ -55,0 +47,1 @@\n+import javafx.scene.control.behavior.KeyBinding;\n@@ -59,0 +52,6 @@\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.scene.control.behavior.BehaviorBase;\n+import com.sun.javafx.scene.control.behavior.ListCellBehavior;\n@@ -178,9 +177,10 @@\n-    @Test\n-    public void testChildMapsCleared() {\n-        TextField control = new TextField(\"some text\");\n-        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n-        InputMap<?> inputMap = behavior.getInputMap();\n-        assertFalse(\"sanity: inputMap has child maps\", inputMap.getChildInputMaps().isEmpty());\n-        behavior.dispose();\n-        assertEquals(\"default child maps must be cleared\", 0, inputMap.getChildInputMaps().size());\n-    }\n+\/\/    @Test\n+\/\/    public void testChildMapsCleared() {\n+\/\/        TextField control = new TextField(\"some text\");\n+\/\/        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n+\/\/        InputMap<?> inputMap = behavior.getInputMap();\n+\/\/        \/\/ child maps are not used anymore\n+\/\/        \/\/assertFalse(\"sanity: inputMap has child maps\", inputMap.getChildInputMaps().isEmpty());\n+\/\/        behavior.dispose();\n+\/\/        assertEquals(\"default child maps must be cleared\", 0, inputMap.getChildInputMaps().size());\n+\/\/    }\n@@ -188,9 +188,9 @@\n-    @Test\n-    public void testDefaultMappingsCleared() {\n-        TextField control = new TextField(\"some text\");\n-        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n-        InputMap<?> inputMap = behavior.getInputMap();\n-        assertFalse(\"sanity: inputMap has mappings\", inputMap.getMappings().isEmpty());\n-        behavior.dispose();\n-        assertEquals(\"default mappings must be cleared\", 0, inputMap.getMappings().size());\n-    }\n+\/\/    @Test\n+\/\/    public void testDefaultMappingsCleared() {\n+\/\/        TextField control = new TextField(\"some text\");\n+\/\/        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n+\/\/        InputMap<?> inputMap = behavior.getInputMap();\n+\/\/        assertFalse(\"sanity: inputMap has mappings\", inputMap.getMappings().isEmpty());\n+\/\/        behavior.dispose();\n+\/\/        assertEquals(\"default mappings must be cleared\", 0, inputMap.getMappings().size());\n+\/\/    }\n@@ -203,0 +203,1 @@\n+        \/*\n@@ -212,0 +213,15 @@\n+        *\/\n+        TextField control = new TextField(\"some text\");\n+        ControlShim.installDefaultSkin(control);\n+        KeyCode[] codes = {\n+            KeyCode.KP_DOWN,\n+            KeyCode.KP_LEFT,\n+            KeyCode.KP_RIGHT,\n+            KeyCode.KP_UP,\n+        };\n+\n+        Set<KeyBinding> keys = control.getInputMap().getKeyBindings();\n+        for (KeyCode c: codes) {\n+            KeyBinding k = KeyBinding.of(c);\n+            assertTrue(keys.contains(k));\n+        }\n@@ -217,0 +233,2 @@\n+    \/*\n+    \/\/ this test relies on too many assumptions on internals\n@@ -235,0 +253,1 @@\n+    *\/\n@@ -237,2 +256,2 @@\n-     * Sanity test: listener to textProperty still effective after fix\n-     * (accidentally added twice)\n+     * Ensures that ctrl- key pad keys are also mapped.\n+     * This test executes different code path between Mac and non-Mac platforms.\n@@ -241,1 +260,1 @@\n-    public void testTextPropertyListener() {\n+    public void testKeyPadMappingOnPlatform() {\n@@ -243,7 +262,18 @@\n-        TextFieldBehavior behavior = (TextFieldBehavior) createBehavior(control);\n-        assertNull(\"sanity: initial bidi\", getRawBidi(behavior));\n-        \/\/ validate bidi field\n-        isRTLText(behavior);\n-        assertNotNull(getRawBidi(behavior));\n-        control.setText(\"dummy\");\n-        assertNull(\"listener working (bidi is reset)\", getRawBidi(behavior));\n+        ControlShim.installDefaultSkin(control);\n+        KeyCode[] codes = {\n+            KeyCode.KP_LEFT,\n+            KeyCode.KP_RIGHT,\n+        };\n+\n+        Set<KeyBinding> keys = control.getInputMap().getKeyBindings();\n+        System.out.println(keys);\n+        for (KeyCode c: codes) {\n+            if (PlatformUtil.isMac()) {\n+                KeyBinding expectedMac = KeyBinding.command(c);\n+                System.out.println(expectedMac);\n+                assertTrue(\"code=\" + c, keys.contains(expectedMac));\n+            } else {\n+                KeyBinding expectedNotMac = KeyBinding.ctrl(c);\n+                assertTrue(\"code=\" + c, keys.contains(expectedNotMac));\n+            }\n+        }\n@@ -252,0 +282,17 @@\n+    \/**\n+     * Sanity test: listener to textProperty still effective after fix\n+     * (accidentally added twice)\n+     *\/\n+    \/\/ behavior must be added in Skin.install() now\n+\/\/    @Test\n+\/\/    public void testTextPropertyListener() {\n+\/\/        TextField control = new TextField(\"some text\");\n+\/\/        TextFieldBehavior behavior = new TextFieldBehavior();\n+\/\/        assertNull(\"sanity: initial bidi\", getRawBidi(behavior));\n+\/\/        \/\/ validate bidi field\n+\/\/        isRTLText(behavior);\n+\/\/        assertNotNull(getRawBidi(behavior));\n+\/\/        control.setText(\"dummy\");\n+\/\/        assertNull(\"listener working (bidi is reset)\", getRawBidi(behavior));\n+\/\/    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/behavior\/BehaviorCleanupTest.java","additions":94,"deletions":47,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -28,0 +28,7 @@\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.asArrays;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.attemptGC;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.createBehavior;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.createControl;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.getControlClassesWithBehavior;\n@@ -31,1 +38,9 @@\n-\n+import javafx.scene.control.ColorPicker;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.DatePicker;\n+import javafx.scene.control.PasswordField;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.control.TextField;\n+import javafx.scene.control.TreeTableView;\n@@ -37,1 +52,0 @@\n-\n@@ -40,8 +54,0 @@\n-import static org.junit.Assert.*;\n-import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n-\n-import javafx.scene.control.Control;\n-import javafx.scene.control.PasswordField;\n-import javafx.scene.control.TableView;\n-import javafx.scene.control.TreeTableView;\n-\n@@ -82,3 +88,11 @@\n-                PasswordField.class,\n-                TableView.class,\n-                TreeTableView.class\n+            \/\/ the following use Behavior that must be installed by Skin.install()\n+            TextField.class,\n+            TextArea.class,\n+            PasswordField.class,\n+            ColorPicker.class,\n+            DatePicker.class,\n+            ComboBox.class,\n+            \/\/ FIX as part of JDK-8241364\n+            TableView.class,\n+            \/\/ FIX as part of JDK-8241364\n+            TreeTableView.class\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/behavior\/BehaviorMemoryLeakTest.java","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.fail;\n@@ -34,9 +36,0 @@\n-\n-import com.sun.javafx.scene.control.behavior.BehaviorBase;\n-import com.sun.javafx.scene.control.behavior.ButtonBehavior;\n-import com.sun.javafx.scene.control.behavior.ComboBoxListViewBehavior;\n-import com.sun.javafx.scene.control.behavior.ToggleButtonBehavior;\n-\n-import static java.util.stream.Collectors.*;\n-import static org.junit.Assert.*;\n-\n@@ -128,0 +121,3 @@\n+import com.sun.javafx.scene.control.behavior.BehaviorBase;\n+import com.sun.javafx.scene.control.behavior.ButtonBehavior;\n+import com.sun.javafx.scene.control.behavior.ToggleButtonBehavior;\n@@ -237,1 +233,2 @@\n-        specialBehaviorMap.put(ComboBox.class, (Function<Control, BehaviorBase>) c -> new ComboBoxListViewBehavior((ComboBox) c));\n+        \/\/ TODO temporarily, while migration to new behavior is ongoing\n+        \/\/specialBehaviorMap.put(ComboBox.class, (Function<Control, BehaviorBase>) c -> new ComboBoxListViewBehavior());\n@@ -243,1 +240,1 @@\n-    \/\/ list of control classes that have no behavior\n+    \/** list of control classes that have no behavior, or use BehaviorBase2 *\/\n@@ -251,1 +248,8 @@\n-            SplitPane.class\n+            SplitPane.class,\n+            \/\/ these use BehaviorBase2\n+            ColorPicker.class,\n+            ComboBox.class,\n+            DatePicker.class,\n+            PasswordField.class,\n+            TextArea.class,\n+            TextField.class\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/infrastructure\/ControlSkinFactory.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"}]}