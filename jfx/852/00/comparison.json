{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,3 @@\n+        \/\/ Use the alternative creation path for MouseEvent by default, see JDK-8253769\n+        this.alternative = true;\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/infrastructure\/MouseEventFirer.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -363,0 +363,6 @@\n+\n+        \/\/ Any mouse or touch press on the scene will clear the focusVisible flag of\n+        \/\/ the current focus owner, if there is one.\n+        EventHandler<InputEvent> handler = event -> setFocusVisible(getFocusOwner(), false);\n+        addEventFilter(MouseEvent.MOUSE_PRESSED, handler);\n+        addEventFilter(TouchEvent.TOUCH_PRESSED, handler);\n@@ -766,1 +772,1 @@\n-                    getKeyHandler().windowForSceneChanged(oldWindow, newWindow);\n+                    windowForSceneChanged(oldWindow, newWindow);\n@@ -2078,5 +2084,33 @@\n-    \/*\n-     * We cannot initialize keyHandler in init because some of the triggers\n-     * access it before the init block.\n-     * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}\n-     * does not compile.\n+    private void windowForSceneChanged(Window oldWindow, Window window) {\n+        if (oldWindow != null) {\n+            oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);\n+        }\n+\n+        if (window != null) {\n+            window.focusedProperty().addListener(sceneWindowFocusedListener);\n+            setWindowFocused(window.isFocused());\n+        } else {\n+            setWindowFocused(false);\n+        }\n+    }\n+\n+    private final InvalidationListener sceneWindowFocusedListener =\n+            valueModel -> setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());\n+\n+    \/**\n+     * Stores whether the current focus owner visibly indicates focus.\n+     * This value is used to restore visible focus when a window loses and re-gains focus.\n+     *\/\n+    private boolean focusVisible;\n+\n+    private void setFocusVisible(Node node, boolean focusVisible) {\n+        this.focusVisible = focusVisible;\n+\n+        if (node != null) {\n+            node.focusVisible.set(focusVisible);\n+            node.focusVisible.notifyListeners();\n+        }\n+    }\n+\n+    \/**\n+     * Stores whether the window associated with this scene is currently focused.\n@@ -2084,4 +2118,12 @@\n-    private KeyHandler keyHandler = null;\n-    private KeyHandler getKeyHandler() {\n-        if (keyHandler == null) {\n-            keyHandler = new KeyHandler();\n+    private boolean windowFocused;\n+\n+    private void setWindowFocused(boolean value) {\n+        windowFocused = value;\n+\n+        if (getFocusOwner() != null) {\n+            getFocusOwner().setFocusQuietly(windowFocused, focusVisible);\n+            getFocusOwner().notifyFocusListeners();\n+        }\n+\n+        if (windowFocused && accessible != null) {\n+            accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);\n@@ -2089,1 +2131,0 @@\n-        return keyHandler;\n@@ -2091,0 +2132,1 @@\n+\n@@ -2147,1 +2189,7 @@\n-        getKeyHandler().process(e);\n+        final Node sceneFocusOwner = getFocusOwner();\n+        final EventTarget eventTarget =\n+                (sceneFocusOwner != null && sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner : Scene.this;\n+\n+        \/\/ send the key event to the current focus owner or to scene if\n+        \/\/ the focus owner is not set\n+        Event.fireEvent(eventTarget, e);\n@@ -2151,1 +2199,10 @@\n-        getKeyHandler().requestFocus(node, focusVisible);\n+        if (node == null) {\n+            setFocusOwner(null);\n+        } else if (node.isCanReceiveFocus()) {\n+            this.focusVisible = focusVisible;\n+            if (node != getFocusOwner()) {\n+                setFocusOwner(node);\n+            } else {\n+                setFocusVisible(node, focusVisible);\n+            }\n+        }\n@@ -2171,1 +2228,1 @@\n-                value.setFocusQuietly(keyHandler.windowFocused, keyHandler.focusVisible);\n+                value.setFocusQuietly(windowFocused, focusVisible);\n@@ -2206,0 +2263,4 @@\n+    public final ReadOnlyObjectProperty<Node> focusOwnerProperty() {\n+        return focusOwner.getReadOnlyProperty();\n+    }\n+\n@@ -2210,2 +2271,15 @@\n-    public final ReadOnlyObjectProperty<Node> focusOwnerProperty() {\n-        return focusOwner.getReadOnlyProperty();\n+    private void setFocusOwner(Node value) {\n+        \/\/ Cancel IM composition if there is one in progress.\n+        \/\/ This needs to be done before the focus owner is switched as it\n+        \/\/ generates event that needs to be delivered to the old focus owner.\n+        if (oldFocusOwner != null) {\n+            final Scene s = oldFocusOwner.getScene();\n+            if (s != null) {\n+                final TKScene peer = s.getPeer();\n+                if (peer != null) {\n+                    peer.finishInputMethodComposition();\n+                }\n+            }\n+        }\n+\n+        focusOwner.set(value);\n@@ -4030,84 +4104,0 @@\n-    \/* *****************************************************************************\n-     *                                                                             *\n-     * Key Event Handling                                                          *\n-     *                                                                             *\n-     ******************************************************************************\/\n-\n-    class KeyHandler {\n-        boolean focusVisible;\n-\n-        private void setFocusOwner(final Node value) {\n-            \/\/ Cancel IM composition if there is one in progress.\n-            \/\/ This needs to be done before the focus owner is switched as it\n-            \/\/ generates event that needs to be delivered to the old focus owner.\n-            if (oldFocusOwner != null) {\n-                final Scene s = oldFocusOwner.getScene();\n-                if (s != null) {\n-                    final TKScene peer = s.getPeer();\n-                    if (peer != null) {\n-                        peer.finishInputMethodComposition();\n-                    }\n-                }\n-            }\n-            focusOwner.set(value);\n-        }\n-\n-        private void setFocusVisible(Node node, boolean focusVisible) {\n-            node.focusVisible.set(focusVisible);\n-            node.focusVisible.notifyListeners();\n-        }\n-\n-        private boolean windowFocused;\n-        protected boolean isWindowFocused() { return windowFocused; }\n-        protected void setWindowFocused(boolean value) {\n-            windowFocused = value;\n-            if (getFocusOwner() != null) {\n-                getFocusOwner().setFocusQuietly(windowFocused, focusVisible);\n-                getFocusOwner().notifyFocusListeners();\n-            }\n-            if (windowFocused) {\n-                if (accessible != null) {\n-                    accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);\n-                }\n-            }\n-        }\n-\n-        private void windowForSceneChanged(Window oldWindow, Window window) {\n-            if (oldWindow != null) {\n-                oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);\n-            }\n-\n-            if (window != null) {\n-                window.focusedProperty().addListener(sceneWindowFocusedListener);\n-                setWindowFocused(window.isFocused());\n-            } else {\n-                setWindowFocused(false);\n-            }\n-        }\n-\n-        private final InvalidationListener sceneWindowFocusedListener = valueModel -> setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());\n-\n-        private void process(KeyEvent e) {\n-            final Node sceneFocusOwner = getFocusOwner();\n-            final EventTarget eventTarget =\n-                    (sceneFocusOwner != null && sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner\n-                                              : Scene.this;\n-\n-            \/\/ send the key event to the current focus owner or to scene if\n-            \/\/ the focus owner is not set\n-            Event.fireEvent(eventTarget, e);\n-        }\n-\n-        private void requestFocus(Node node, boolean focusVisible) {\n-            if (node == null) {\n-                setFocusOwner(null);\n-            } else if (node.isCanReceiveFocus()) {\n-                if (node != getFocusOwner()) {\n-                    this.focusVisible = focusVisible;\n-                    setFocusOwner(node);\n-                } else {\n-                    setFocusVisible(node, focusVisible);\n-                }\n-            }\n-        }\n-    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":90,"deletions":100,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import javafx.event.EventTarget;\n@@ -44,0 +45,1 @@\n+import java.util.Collections;\n@@ -52,0 +54,5 @@\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.PickResult;\n+import javafx.scene.input.TouchEvent;\n+import javafx.scene.input.TouchPoint;\n@@ -778,0 +785,19 @@\n+    private void fireMousePressedEvent(EventTarget target) {\n+        double x = 10, y = 10;\n+        PickResult pickResult = new PickResult(target, x, y);\n+        Event.fireEvent(target, new MouseEvent(\n+                MouseEvent.MOUSE_PRESSED, x, y, x, y, MouseButton.PRIMARY, 1,\n+                false, false, false, false,\n+                true, false, false,\n+                false, false, false, pickResult));\n+    }\n+\n+    private void fireTouchPressedEvent(EventTarget target) {\n+        double x = 10, y = 10;\n+        PickResult pickResult = new PickResult(scene, x, y);\n+        Event.fireEvent(target, new TouchEvent(\n+                TouchEvent.TOUCH_PRESSED,\n+                new TouchPoint(0, TouchPoint.State.PRESSED, x, y, x, y, target, pickResult),\n+                Collections.emptyList(), 0, false, false, false, false));\n+    }\n+\n@@ -851,0 +877,38 @@\n+    \/**\n+     * When any region of the window is clicked, the focus owner loses visible focus\n+     * even when the focus owner doesn't change.\n+     *\/\n+    @Test public void testMousePressedClearsFocusVisible() {\n+        Node node1 = n(), node2 = n();\n+        Group g = new Group(node1, node2);\n+        scene.setRoot(g);\n+        fireTabKeyEvent(g);\n+\n+        assertIsFocused(scene, node1);\n+        assertIsFocusVisible(node1);\n+\n+        fireMousePressedEvent(scene);\n+\n+        assertIsFocused(scene, node1);\n+        assertNotFocusVisible(node1);\n+    }\n+\n+    \/**\n+     * When any region of the window is touched, the focus owner loses visible focus\n+     * even when the focus owner doesn't change.\n+     *\/\n+    @Test public void testTouchPressedClearsFocusVisible() {\n+        Node node1 = n(), node2 = n();\n+        Group g = new Group(node1, node2);\n+        scene.setRoot(g);\n+        fireTabKeyEvent(g);\n+\n+        assertIsFocused(scene, node1);\n+        assertIsFocusVisible(node1);\n+\n+        fireTouchPressedEvent(scene);\n+\n+        assertIsFocused(scene, node1);\n+        assertNotFocusVisible(node1);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/FocusTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"}]}