{"files":[{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ Original code is re-licensed to Oracle by the author.\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/common\/util\/Disconnectable.java\n+\/\/ Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+package com.sun.javafx.scene.control;\n+\n+\/**\n+ * A functional interface that provides a {@link #disconnect()} method.\n+ *\/\n+@FunctionalInterface\n+public interface IDisconnectable {\n+    \/**\n+     * Disconnects what has been connected. May be called multiple times, only the\n+     * first invocation actually disconnects.\n+     *\/\n+    public void disconnect();\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/IDisconnectable.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,512 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ Original code is re-licensed to Oracle by the author.\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/fx\/FxDisconnector.java\n+\/\/ Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+package com.sun.javafx.scene.control;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.MapChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.collections.ObservableMap;\n+import javafx.collections.ObservableSet;\n+import javafx.collections.SetChangeListener;\n+import javafx.concurrent.Task;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.SkinBase;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.transform.Transform;\n+import javafx.stage.Window;\n+\n+\/**\n+ * This class provides convenience methods for adding various listeners, both\n+ * strong and weak, as well as a single {@link #disconnect()} method to remove\n+ * all listeners.\n+ * <p>\n+ * There are two usage patterns:\n+ * <ul>\n+ * <li>Client code registers a number of listeners and removes them all at once\n+ * via {@link #disconnect()} call.\n+ * <li>Client code registers a number of listeners and removes one via its\n+ * {@link IDisconnectable} instance.\n+ * <\/ul>\n+ *\n+ * This class is currently used for clean replacement of {@link Skin}s.\n+ * We should consider making this class a part of the public API in {@code javax.base},\n+ * since it proved itself useful in removing listeners and handlers in bulk at the application level.\n+ *\/\n+public class ListenerHelper implements IDisconnectable {\n+    private WeakReference<Object> ownerRef;\n+    private final ArrayList<IDisconnectable> items = new ArrayList<>(4);\n+    private static Function<SkinBase<?>,ListenerHelper> accessor;\n+\n+    public ListenerHelper(Object owner) {\n+        ownerRef = new WeakReference<>(owner);\n+    }\n+\n+    public ListenerHelper() {\n+    }\n+\n+    public static void setAccessor(Function<SkinBase<?>,ListenerHelper> a) {\n+        accessor = a;\n+    }\n+\n+    public static ListenerHelper get(SkinBase<?> skin) {\n+        return accessor.apply(skin);\n+    }\n+\n+    public IDisconnectable addDisconnectable(Runnable r) {\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                items.remove(this);\n+                r.run();\n+            }\n+        };\n+        items.add(d);\n+        return d;\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        for (int i = items.size() - 1; i >= 0; i--) {\n+            IDisconnectable d = items.remove(i);\n+            d.disconnect();\n+        }\n+    }\n+\n+    protected boolean isAliveOrDisconnect() {\n+        if (ownerRef != null) {\n+            if (ownerRef.get() == null) {\n+                disconnect();\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ change listeners\n+\n+    public IDisconnectable addChangeListener(Runnable callback, ObservableValue<?>... props) {\n+        return addChangeListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addChangeListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        ChLi li = new ChLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue p, Object oldValue, Object newValue) {\n+                if (isAliveOrDisconnect()) {\n+                    onChange.run();\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, ChangeListener<T> listener) {\n+        return addChangeListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, boolean fireImmediately, ChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        ChLi<T> li = new ChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends T> src, T oldValue, T newValue) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.changed(src, oldValue, newValue);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        prop.addListener(li);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            listener.changed(prop, null, v);\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, Consumer<T> callback) {\n+        return addChangeListener(prop, false, callback);\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, boolean fireImmediately, Consumer<T> callback) {\n+        if (callback == null) {\n+            throw new NullPointerException(\"Callback must be specified.\");\n+        }\n+\n+        ChLi<T> li = new ChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends T> observable, T oldValue, T newValue) {\n+                if (isAliveOrDisconnect()) {\n+                    callback.accept(newValue);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        prop.addListener(li);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            callback.accept(v);\n+        }\n+\n+        return li;\n+    }\n+\n+    \/\/ invalidation listeners\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, ObservableValue<?>... props) {\n+        return addInvalidationListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (callback == null) {\n+            throw new NullPointerException(\"Callback must be specified.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                if (isAliveOrDisconnect()) {\n+                    callback.run();\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            callback.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, InvalidationListener listener) {\n+        return addInvalidationListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, boolean fireImmediately, InvalidationListener listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void invalidated(Observable observable) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.invalidated(observable);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        prop.addListener(li);\n+\n+        if (fireImmediately) {\n+            listener.invalidated(prop);\n+        }\n+\n+        return li;\n+    }\n+\n+    \/\/ list change listeners\n+\n+    public <T> IDisconnectable addListChangeListener(ObservableList<T> list, ListChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        LiChLi<T> li = new LiChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void onChanged(Change<? extends T> ch) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.onChanged(ch);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        list.addListener(li);\n+\n+        return li;\n+    }\n+\n+    \/\/ map change listener\n+\n+    public <K,V> IDisconnectable addMapChangeListener(ObservableMap<K,V> list, MapChangeListener<K,V> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        MaChLi<K,V> li = new MaChLi<K,V>() {\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void onChanged(Change<? extends K, ? extends V> ch) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.onChanged(ch);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        list.addListener(li);\n+\n+        return li;\n+    }\n+\n+    \/\/ set change listeners\n+\n+    public <T> IDisconnectable addSetChangeListener(ObservableSet<T> set, SetChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        SeChLi<T> li = new SeChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                set.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void onChanged(Change<? extends T> ch) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.onChanged(ch);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        set.addListener(li);\n+\n+        return li;\n+    }\n+\n+    \/\/ event handlers\n+\n+    public <T extends Event> IDisconnectable addEventHandler(Object x, EventType<T> t, EventHandler<T> handler) {\n+        EvHa<T> h = new EvHa<>(handler) {\n+            @Override\n+            public void disconnect() {\n+                if (x instanceof Node n) {\n+                    n.removeEventHandler(t, this);\n+                } else if (x instanceof Window y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Scene y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof MenuItem y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof TreeItem y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof TableColumnBase y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Transform y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Task y) {\n+                    y.removeEventHandler(t, this);\n+                }\n+            }\n+        };\n+\n+        items.add(h);\n+\n+        \/\/ we really need an interface here ... \"HasEventHandlers\"\n+        if (x instanceof Node y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Window y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Scene y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof MenuItem y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof TreeItem y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof TableColumnBase y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Transform y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Task y) {\n+            y.addEventHandler(t, h);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add event handler to \" + x);\n+        }\n+\n+        return h;\n+    }\n+\n+    \/\/ event filters\n+\n+    public <T extends Event> IDisconnectable addEventFilter(Object x, EventType<T> t, EventHandler<T> handler) {\n+        EvHa<T> h = new EvHa<>(handler) {\n+            @Override\n+            public void disconnect() {\n+                if (x instanceof Node n) {\n+                    n.removeEventFilter(t, this);\n+                } else if (x instanceof Window y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Scene y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Transform y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Task y) {\n+                    y.removeEventFilter(t, this);\n+                }\n+            }\n+        };\n+\n+        items.add(h);\n+\n+        \/\/ we really need an interface here ... \"HasEventFilters\"\n+        if (x instanceof Node y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Window y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Scene y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Transform y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Task y) {\n+            y.addEventFilter(t, h);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add event filter to \" + x);\n+        }\n+\n+        return h;\n+    }\n+\n+    \/\/\n+\n+    private static abstract class ChLi<T> implements IDisconnectable, ChangeListener<T> { }\n+\n+    private static abstract class InLi implements IDisconnectable, InvalidationListener { }\n+\n+    private static abstract class LiChLi<T> implements IDisconnectable, ListChangeListener<T> { }\n+\n+    private static abstract class MaChLi<K,V> implements IDisconnectable, MapChangeListener<K,V> { }\n+\n+    private static abstract class SeChLi<T> implements IDisconnectable, SetChangeListener<T> { }\n+\n+    private abstract class EvHa<T extends Event> implements IDisconnectable, EventHandler<T> {\n+        private final EventHandler<T> handler;\n+\n+        public EvHa(EventHandler<T> h) {\n+            this.handler = h;\n+        }\n+\n+        @Override\n+        public void handle(T ev) {\n+            if (isAliveOrDisconnect()) {\n+                handler.handle(ev);\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ListenerHelper.java","additions":512,"deletions":0,"binary":false,"changes":512,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;\n-\n@@ -51,0 +49,3 @@\n+import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;\n+import com.sun.javafx.scene.control.ListenerHelper;\n+\n@@ -61,0 +62,5 @@\n+    static {\n+        \/\/ must be the first code to execute\n+        ListenerHelper.setAccessor((skin) -> skin.listenerHelper());\n+    }\n+\n@@ -84,0 +90,2 @@\n+     *\n+     * TODO remove after migration to ListenerHelper\n@@ -87,1 +95,1 @@\n-\n+    private ListenerHelper listenerHelper;\n@@ -161,0 +169,4 @@\n+        if (listenerHelper != null) {\n+            listenerHelper.disconnect();\n+        }\n+\n@@ -210,0 +222,9 @@\n+    \/**\n+     * Returns the skin's instance of {@link ListenerHelper}, creating it if necessary.\n+     *\/\n+    ListenerHelper listenerHelper() {\n+        if (listenerHelper == null) {\n+            listenerHelper = new ListenerHelper();\n+        }\n+        return listenerHelper;\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/SkinBase.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,465 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene.control;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import java.lang.ref.WeakReference;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.Test;\n+import com.sun.javafx.event.EventUtil;\n+import com.sun.javafx.scene.control.ListenerHelper;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.MapChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.collections.ObservableMap;\n+import javafx.collections.ObservableSet;\n+import javafx.collections.SetChangeListener;\n+import javafx.concurrent.Task;\n+import javafx.event.EventTarget;\n+import javafx.scene.Group;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.skin.LabelSkin;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.Region;\n+import javafx.scene.transform.Scale;\n+import javafx.stage.Stage;\n+import test.com.sun.javafx.scene.control.infrastructure.MouseEventGenerator;\n+import test.util.memory.JMemoryBuddy;\n+\n+\/**\n+ * Tests ListenerHelper utility class.\n+ *\/\n+public class TestListenerHelper {\n+    @Test\n+    public void testCheckAlive() {\n+        Object owner = new Object();\n+        WeakReference<Object> ref = new WeakReference<>(owner);\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+        AtomicInteger disconnected = new AtomicInteger();\n+\n+        ListenerHelper h = new ListenerHelper(owner);\n+\n+        h.addChangeListener(p, (v) -> ct.incrementAndGet());\n+        h.addDisconnectable(() -> disconnected.incrementAndGet());\n+\n+        \/\/ check that the listener is working\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        \/\/ collect\n+        owner = null;\n+        JMemoryBuddy.assertCollectable(ref);\n+\n+        \/\/ fire an event that should be ignored\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+\n+        \/\/ check that helper has disconnected all its items\n+        assertEquals(1, disconnected.get());\n+    }\n+\n+    \/\/ change listeners\n+\n+    @Test\n+    public void testChangeListener_MultipleProperties() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p1 = new SimpleStringProperty();\n+        SimpleStringProperty p2 = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(() -> ct.incrementAndGet(), p1, p2);\n+\n+        p1.set(\"1\");\n+        p2.set(\"2\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p1.set(\"3\");\n+        p2.set(\"4\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_MultipleProperties_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p1 = new SimpleStringProperty();\n+        SimpleStringProperty p2 = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(() -> ct.incrementAndGet(), true, p1, p2);\n+\n+        p1.set(\"1\");\n+        p2.set(\"2\");\n+        assertEquals(3, ct.get());\n+\n+        h.disconnect();\n+\n+        p1.set(\"3\");\n+        p2.set(\"4\");\n+        assertEquals(3, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_Plain() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(p, (s, old, cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_Plain_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(p, true, (s, old, cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_Callback() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(p, (cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_Callback_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(p, true, (cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    \/\/ invalidation listeners\n+\n+    @Test\n+    public void testInvalidationListener_MultipleProperties() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p1 = new SimpleStringProperty();\n+        SimpleStringProperty p2 = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(() -> ct.incrementAndGet(), p1, p2);\n+\n+        p1.set(\"1\");\n+        p2.set(\"2\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p1.set(\"3\");\n+        p2.set(\"4\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_MultipleProperties_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p1 = new SimpleStringProperty();\n+        SimpleStringProperty p2 = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(() -> ct.incrementAndGet(), true, p1, p2);\n+\n+        p1.set(\"1\");\n+        p2.set(\"2\");\n+        assertEquals(3, ct.get());\n+\n+        h.disconnect();\n+\n+        p1.set(\"3\");\n+        p2.set(\"4\");\n+        assertEquals(3, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_Plain() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(p, (x) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_Plain_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(p, true, (x) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_Callback() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(p, (cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_Callback_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(p, true, (cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    \/\/ list change listeners\n+\n+    @Test\n+    public void testListChangeListener() {\n+        ListenerHelper h = new ListenerHelper();\n+        ObservableList<String> list = FXCollections.observableArrayList();\n+        AtomicInteger ct = new AtomicInteger();\n+        ListChangeListener<String> li = (ch) -> ct.incrementAndGet();\n+\n+        h.addListChangeListener(list, li);\n+\n+        list.add(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        list.add(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    \/\/ set change listeners\n+\n+    @Test\n+    public void testSetChangeListener() {\n+        ListenerHelper h = new ListenerHelper();\n+        ObservableSet<String> list = FXCollections.observableSet();\n+        AtomicInteger ct = new AtomicInteger();\n+        SetChangeListener<String> li = (ch) -> ct.incrementAndGet();\n+\n+        h.addSetChangeListener(list, li);\n+\n+        list.add(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        list.add(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    \/\/ map change listeners\n+\n+    @Test\n+    public void testMapChangeListener() {\n+        ListenerHelper h = new ListenerHelper();\n+        ObservableMap<String, String> m = FXCollections.observableHashMap();\n+        AtomicInteger ct = new AtomicInteger();\n+        MapChangeListener<String, String> li = (ch) -> ct.incrementAndGet();\n+\n+        h.addMapChangeListener(m, li);\n+\n+        m.put(\"1\", \"a\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        m.put(\"2\", \"b\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    \/\/ event handlers\n+\n+    @Test\n+    public void testEventHandler() {\n+        EventTarget[] items = eventHandlerTargets();\n+\n+        for (EventTarget item : items) {\n+            ListenerHelper h = new ListenerHelper();\n+            AtomicInteger ct = new AtomicInteger();\n+\n+            h.addEventHandler(item, MouseEvent.ANY, (ev) -> ct.incrementAndGet());\n+\n+            MouseEvent ev = MouseEventGenerator.generateMouseEvent(MouseEvent.MOUSE_CLICKED, 0, 0);\n+            EventUtil.fireEvent(ev, item);\n+\n+            assertEquals(1, ct.get());\n+\n+            h.disconnect();\n+\n+            EventUtil.fireEvent(ev, item);\n+            assertEquals(1, ct.get());\n+        }\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testEventHandlerCheck() {\n+        ListenerHelper h = new ListenerHelper();\n+        h.addEventHandler(new Object(), MouseEvent.ANY, (ev) -> { throw new Error(); });\n+    }\n+\n+    \/\/ event filters\n+\n+    @Test\n+    public void testEventFilter() {\n+        EventTarget[] items = eventHandlerFilters();\n+\n+        for (EventTarget item : items) {\n+            ListenerHelper h = new ListenerHelper();\n+            AtomicInteger ct = new AtomicInteger();\n+\n+            h.addEventFilter(item, MouseEvent.ANY, (ev) -> ct.incrementAndGet());\n+\n+            MouseEvent ev = MouseEventGenerator.generateMouseEvent(MouseEvent.MOUSE_CLICKED, 0, 0);\n+            EventUtil.fireEvent(ev, item);\n+\n+            assertEquals(1, ct.get());\n+\n+            h.disconnect();\n+\n+            EventUtil.fireEvent(ev, item);\n+            assertEquals(1, ct.get());\n+        }\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testEventFilterCheck() {\n+        ListenerHelper h = new ListenerHelper();\n+        h.addEventFilter(new Object(), MouseEvent.ANY, (ev) -> { throw new Error(); });\n+    }\n+\n+    \/\/\n+\n+    protected EventTarget[] eventHandlerTargets() {\n+        return new EventTarget[] {\n+            new Region(),\n+            new Stage(),\n+            new Scene(new Group()),\n+            new MenuItem(),\n+            new TreeItem(),\n+            new TableColumn(),\n+            new Scale(),\n+            new Task() {\n+                @Override\n+                protected Object call() throws Exception {\n+                    return null;\n+                }\n+            }\n+        };\n+    }\n+\n+    protected EventTarget[] eventHandlerFilters() {\n+        return new EventTarget[] {\n+            new Region(),\n+            new Stage(),\n+            new Scene(new Group()),\n+            new Scale(),\n+            new Task() {\n+                @Override\n+                protected Object call() throws Exception {\n+                    return null;\n+                }\n+            }\n+        };\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TestListenerHelper.java","additions":465,"deletions":0,"binary":false,"changes":465,"status":"added"}]}