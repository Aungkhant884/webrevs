{"files":[{"patch":"@@ -921,0 +921,1 @@\n+            adjustAbsoluteOffset();\n@@ -927,3 +928,0 @@\n-        \/\/ When the position is changed explicitly, we need to make sure\n-        \/\/ the absolute offset is changed accordingly.\n-        adjustAbsoluteOffset();\n@@ -1055,15 +1053,8 @@\n-        double origAbsoluteOffset = absoluteOffset;\n-        recalculateEstimatedSize();\n-        \/\/ if the last modification to the position was done via scrollPixels,\n-        \/\/ the absoluteOffset and position are already in sync.\n-        \/\/ However, the position can be modified via different ways (e.g. by\n-        \/\/ moving the scrollbar thumb), so we need to recalculate absoluteOffset\n-        \/\/ There is an exception to this: if cells are added\/removed, we want\n-        \/\/ to keep the absoluteOffset constant, hence we need to adjust the position.\n-\n-        if (lastCellCount != getCellCount()) {\n-            absoluteOffset = origAbsoluteOffset;\n-            adjustPosition();\n-        } else {\n-            adjustAbsoluteOffset();\n-        }\n+        \/\/ when we enter this method, the absoluteOffset and position are\n+        \/\/ already determined. In case this method invokes other methods\n+        \/\/ that may change either absoluteOffset or position, it is the\n+        \/\/ responsability of those methods to make sure both parameters are\n+        \/\/ changed in a consistent way.\n+        \/\/ For example, the recalculateEstimatedSize method also recalculates\n+        \/\/ the absoluteOffset and position.\n+\n@@ -1074,2 +1065,0 @@\n-\/\/            accumCell = null;\n-\/\/            accumCellParent.getChildren().clear();\n@@ -1337,0 +1326,1 @@\n+        recalculateAndImproveEstimatedSize(0);\n@@ -1582,0 +1572,2 @@\n+        \/\/ make sure we have the real size of cells that are likely to be rendered\n+        getCellSizesInExpectedViewport(index);\n@@ -1767,0 +1759,1 @@\n+                resizeCell(cell);\n@@ -1904,0 +1897,3 @@\n+        if (value == this.viewportLength) {\n+            return;\n+        }\n@@ -1906,0 +1902,1 @@\n+        recalculateEstimatedSize();\n@@ -1999,0 +1996,2 @@\n+        \/\/ when a cell is resized, our estimate needs to be updated.\n+        recalculateAndImproveEstimatedSize(0);\n@@ -2314,0 +2313,22 @@\n+    \/**\n+     * Make sure the sizes of the cells that are likely to be visible are known.\n+     * When updates to the cell size estimates are occurring, we don't want the current\n+     * visible content to be modified.\n+     * @param index the index of the cell that should be positioned at the top of\n+     * the viewport in the next layout cycle.\n+     *\/\n+    void getCellSizesInExpectedViewport(int index) {\n+        double estlength = getOrCreateCellSize(index);\n+        int i = index;\n+        while ((estlength < viewportLength) && (++i < getCellCount())) {\n+            estlength = estlength + getOrCreateCellSize(i);\n+        }\n+        if (estlength < viewportLength) {\n+            int j = index;\n+            while ((estlength < viewportLength) && (j-- > 0)) {\n+                estlength = estlength + getOrCreateCellSize(j);\n+            }\n+        }\n+        recalculateEstimatedSize();\n+    }\n+\n@@ -2445,0 +2466,20 @@\n+    \/**\n+     * In case we are not rendering the first cell\n+     * AND\n+     * there is empty room after the last cell,\n+     * the cells need to be shifted down to fill the empty area.\n+     *\/\n+    private void shiftDown() {\n+        T lastNonEmptyCell = getLastVisibleCell();\n+        T firstCell = cells.getFirst();\n+        int index = getCellIndex(firstCell);\n+        double end = getCellPosition(lastNonEmptyCell) + getCellLength(lastNonEmptyCell);\n+        double delta = viewportLength - end;\n+        if ((index > 0) && (delta > 0)) {\n+            for (int i = 0; i < cells.size(); i++) {\n+                T cell = cells.get(i);\n+                positionCell(cell, getCellPosition(cell) + delta);\n+            }\n+        }\n+    }\n+\n@@ -2489,0 +2530,1 @@\n+            shiftDown();\n@@ -2851,0 +2893,3 @@\n+        if (index > 0) getOrCreateCellSize(index-1);\n+        getOrCreateCellSize(index);\n+        recalculateEstimatedSize();\n@@ -2862,1 +2907,1 @@\n-            this.absoluteOffset = targetOffset;\n+            this.absoluteOffset = (estimatedSize < viewportLength)  ? 0  : targetOffset;\n@@ -2957,0 +3002,1 @@\n+        if (idx < 0) return -1;\n@@ -2967,6 +3013,0 @@\n-        \/\/ Do we have a visible cell for this index?\n-        T cell = getVisibleCell(idx);\n-        if (cell == null) { \/\/ we might get the accumcell here\n-            cell = getCell(idx);\n-            doRelease = true;\n-        }\n@@ -2978,1 +3018,0 @@\n-        \/\/ if we have a valid cell, we can populate the cache\n@@ -2980,2 +3019,3 @@\n-        if (isVertical()) {\n-            answer = cell.getLayoutBounds().getHeight();\n+        if (getFixedCellSize() > 0) {\n+            answer = getFixedCellSize();\n+            itemSizeCache.set(idx, answer);\n@@ -2983,3 +3023,6 @@\n-            answer = cell.getLayoutBounds().getWidth();\n-        }\n-        itemSizeCache.set(idx, answer);\n+            \/\/ Do we have a visible cell for this index?\n+            T cell = getVisibleCell(idx);\n+            if (cell == null) { \/\/ we might get the accumcell here\n+                cell = getCell(idx);\n+                doRelease = true;\n+            }\n@@ -2987,2 +3030,11 @@\n-        if (doRelease) { \/\/ we need to release the accumcell\n-            releaseCell(cell);\n+            \/\/ if we have a valid cell, we can populate the cache\n+            if (isVertical()) {\n+                answer = cell.getLayoutBounds().getHeight();\n+            } else {\n+                answer = cell.getLayoutBounds().getWidth();\n+            }\n+            itemSizeCache.set(idx, answer);\n+\n+            if (doRelease) { \/\/ we need to release the accumcell\n+                releaseCell(cell);\n+            }\n@@ -3023,0 +3075,5 @@\n+        boolean keepRatio = ((cacheCount > 0) && !Double.isInfinite(this.absoluteOffset));\n+        double estSize = estimatedSize \/ itemCount;\n+\n+        int oldIndex = computeCurrentIndex();\n+        double oldOffset = computeViewportOffset(getPosition());\n@@ -3038,1 +3095,16 @@\n-        this.estimatedSize = cnt == 0 ? 1d: tot * itemCount \/ cnt;\n+        this.estimatedSize = cnt == 0 ? 1d : tot * itemCount \/ cnt;\n+        estSize = estimatedSize \/ itemCount;\n+\n+        if (keepRatio) {\n+            double newOffset = 0;\n+            for (int i = 0; i < oldIndex; i++) {\n+                double h = getCellSize(i);\n+                if (h < 0) {\n+                    h = estSize;\n+                }\n+                newOffset += h;\n+            }\n+            this.absoluteOffset = newOffset + oldOffset;\n+            adjustPosition();\n+        }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/VirtualFlow.java","additions":108,"deletions":36,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -1837,0 +1837,1 @@\n+    @Ignore(\"JDK-8289909\") \/\/ there is no guarantee that there will be 8 selected items (can be 7 as well)\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ListViewKeyInputTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -1138,1 +1139,1 @@\n-                                assertEquals(5, rt_35395_counter);\n+                                assertTrue(rt_35395_counter < 30);\n@@ -1143,1 +1144,1 @@\n-                                    assertEquals(useFixedCellSize ? 21 : 23, rt_35395_counter);\n+                                    assertEquals(useFixedCellSize ? 17 : 71, rt_35395_counter);\n@@ -2186,0 +2187,239 @@\n+\n+    @Test\n+    public void testUnfixedCellScrollResize() {\n+        final ObservableList<Integer> items = FXCollections.observableArrayList(300, 300, 70, 20);\n+        final ListView<Integer> listView = new ListView(items);\n+        listView.setPrefHeight(400);\n+        double viewportLength = 398; \/\/ it would be better to calculate this from listView but there is no API for this\n+        listView.setCellFactory(lv -> new ListCell<Integer>() {\n+            @Override\n+            public void updateItem(Integer item, boolean empty) {\n+                super.updateItem(item, empty);\n+                if (!empty && (item != null)) {\n+                    this.setPrefHeight(item);\n+                }\n+            }\n+        });\n+        StageLoader sl = new StageLoader(listView);\n+        Toolkit.getToolkit().firePulse();\n+        listView.scrollTo(2);\n+        Toolkit.getToolkit().firePulse();\n+        int cc = VirtualFlowTestUtils.getCellCount(listView);\n+        boolean got70 = false;\n+        boolean got20 = false;\n+        for (int i = 0; i < cc; i++) {\n+            IndexedCell<Integer> cell = VirtualFlowTestUtils.getCell(listView, i);\n+            if ((cell != null) && (cell.getItem() == 20)) {\n+                assertEquals(\"Last cell doesn't end at listview end\", viewportLength - 20, cell.getLayoutY(), 1.);\n+                got20 = true;\n+            }\n+            if ((cell != null) && (cell.getItem() == 70)) {\n+                assertEquals(\"Secondlast cell doesn't end properly\", viewportLength - 20 - 70, cell.getLayoutY(), 1.);\n+                got70 = true;\n+            }\n+        }\n+        assertTrue(got20);\n+        assertTrue(got70);\n+        \/\/ resize cells and make sure they align after scrolling\n+        ObservableList<Integer> list = FXCollections.observableArrayList();\n+        list.addAll(300, 300, 20, 21);\n+        listView.setItems(list);\n+        listView.scrollTo(4);\n+        Toolkit.getToolkit().firePulse();\n+        got20 = false;\n+        boolean got21 = false;\n+        for (int i = 0; i < cc; i++) {\n+            IndexedCell<Integer> cell = VirtualFlowTestUtils.getCell(listView, i);\n+            if ((cell != null) && (cell.getItem() == 21)) {\n+                assertEquals(\"Last cell doesn't end at listview end\", viewportLength - 21, cell.getLayoutY(), 1.);\n+                got21 = true;\n+            }\n+            if ((cell != null) && (cell.getItem() == 20)) {\n+                assertEquals(\"Secondlast cell doesn't end properly\", viewportLength - 21 - 20, cell.getLayoutY(), 1.);\n+                got20 = true;\n+            }\n+        }\n+        assertTrue(got20);\n+        assertTrue(got21);\n+    }\n+\n+    @Test\n+    public void testNoEmptyEnd() {\n+        final ObservableList<Integer> items = FXCollections.observableArrayList(200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20);\n+        final ListView<Integer> listView = new ListView(items);\n+        listView.setPrefHeight(400);\n+        double viewportLength = 398;\n+        listView.setCellFactory(lv -> new ListCell<Integer>() {\n+            @Override\n+            public void updateItem(Integer item, boolean empty) {\n+                super.updateItem(item, empty);\n+                if (!empty && (item != null)) {\n+                    this.setPrefHeight(item);\n+                }\n+            }\n+        });\n+        StageLoader sl = new StageLoader(listView);\n+        Toolkit.getToolkit().firePulse();\n+        listView.scrollTo(14);\n+        Toolkit.getToolkit().firePulse();\n+        int cc = VirtualFlowTestUtils.getCellCount(listView);\n+        assertEquals(cc, 15);\n+        boolean got70 = false;\n+        for (int i = 0; i < cc; i++) {\n+            IndexedCell<Integer> cell = VirtualFlowTestUtils.getCell(listView, i);\n+            int tens = Math.min(15 - i, 7);\n+            int hundreds = Math.max(8 - i, 0);\n+            double exp = 398 - 20 * tens - 200 * hundreds;\n+            double real = cell.getLayoutY();\n+            if (cell.isVisible()) {\n+                assertEquals(exp, real, 0.1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMoreUnfixedCellScrollResize() {\n+\n+        \/\/ Sanity Check - it has to work with cases, where all cells have the same sizes\n+        testScrollTo(360, 3, new Integer[]{20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(360, 3, new Integer[]{20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(360, 1, new Integer[]{20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(360, -1, new Integer[]{20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20});\n+\n+        \/\/ With 100 it's wrong, when addIncremental is set.\n+        testScrollTo(360, 3, new Integer[]{100, 100, 100, 100, 100, 100, 100, 100, 100});\n+        testScrollTo(360, -1, new Integer[]{100, 100, 100, 100, 100, 100, 100, 100, 100});\n+\n+        \/\/ More complicated tests\n+        testScrollTo(360, 2, new Integer[]{300, 300, 70, 20});\n+        testScrollTo(400, 2, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(400, 3, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 500, 20, 500, 20, 500});\n+        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 400, 20, 400, 20, 400});\n+        testScrollTo(400, 2, new Integer[]{500, 500, 20, 20, 100, 100, 100, 100, 100, 100});\n+        testScrollTo(400, 8, new Integer[]{500, 500, 20, 20, 100, 100, 100, 100, 100, 100, 300, 300, 300, 300});\n+\n+        testScrollTo(400, 2, new Integer[]{300, 300, 20, 20});\n+        testScrollTo(400, 2, new Integer[]{300, 300, 20, 20, 200, 200});\n+        testScrollTo(400, 2, new Integer[]{20, 20, 20, 500, 500});\n+\n+        testScrollTo(400, 2, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(400, 3, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 500, 20, 500, 20, 500});\n+        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 400, 20, 400, 20, 400});\n+        testScrollTo(400, 2, new Integer[]{500, 500, 20, 20, 100, 100, 100, 100, 100, 100});\n+        testScrollTo(400, 2, new Integer[]{500, 500, 500, 500, 500});\n+\n+    }\n+\n+    public void testScrollTo(int listViewHeight, int scrollToIndex, Integer[] heights) {\n+        if (scrollToIndex == -1) {\n+            scrollToIndex = heights.length - 1;\n+        }\n+        testScrollTo(false, false, false, listViewHeight, scrollToIndex, heights);\n+        testScrollTo(true, false, false, listViewHeight, scrollToIndex, heights);\n+        testScrollTo(true, true, false, listViewHeight, scrollToIndex, heights);\n+        testScrollTo(true, true, true, listViewHeight, scrollToIndex, heights);\n+\n+    }\n+\n+    public void testScrollTo(boolean addIncremental, boolean layoutTwice, boolean selectIndex, int listViewHeight, int scrollToIndex, Integer[] heights) {\n+        final ListView<Integer> listView = new ListView<Integer>();\n+        listView.setPrefHeight(listViewHeight);\n+        listView.setCellFactory(lv -> new ListCell<Integer>() {\n+            @Override\n+            public void updateItem(Integer item, boolean empty) {\n+                super.updateItem(item, empty);\n+                if (!empty && (item != null)) {\n+                    this.setPrefHeight(item);\n+                }\n+            }\n+        });\n+        StageLoader sl = new StageLoader(new VBox(listView));\n+        if (addIncremental) {\n+            \/\/ Adding the elments incrementally seems to make a difference!\n+            for (var height : heights) {\n+                \/\/ Adding them incrementally seems to be relevant\n+                listView.getItems().add(height);\n+                Toolkit.getToolkit().firePulse();\n+                listView.requestLayout();\n+                Toolkit.getToolkit().firePulse();\n+                listView.requestLayout();\n+\n+            }\n+        } else {\n+            listView.getItems().addAll(heights);\n+            Toolkit.getToolkit().firePulse();\n+\n+        }\n+        listView.scrollTo(scrollToIndex);\n+        Toolkit.getToolkit().firePulse();\n+        if (layoutTwice) {\n+            listView.requestLayout();\n+            Toolkit.getToolkit().firePulse();\n+        }\n+        if (selectIndex) {\n+            listView.getSelectionModel().select(scrollToIndex);\n+            Toolkit.getToolkit().firePulse();\n+        }\n+\n+        verifyListViewScrollTo(listView, listViewHeight, scrollToIndex, heights);\n+    }\n+\n+    public static void verifyListViewScrollTo(ListView listView, int listViewHeight, int scrollToIndex, Integer[] heights) {\n+        double sumOfHeights = 0;\n+        double viewportLength = listViewHeight - 2; \/\/ it would be better to calculate this from listView but there is no API for this\n+\n+        for (int height : heights) {\n+            sumOfHeights += height;\n+        }\n+        double sizeBelow = 0;\n+        for (int i = scrollToIndex; i < heights.length; i += 1) {\n+            sizeBelow += heights[i];\n+        }\n+\n+        IndexedCell<Integer> firstCell = VirtualFlowTestUtils.getCell(listView, 0);\n+        IndexedCell<Integer> scrollToCell = VirtualFlowTestUtils.getCell(listView, scrollToIndex);\n+        IndexedCell<Integer> lastCell = VirtualFlowTestUtils.getCell(listView, heights.length - 1);\n+\n+        double lastCellSize = heights[heights.length - 1];\n+\n+        boolean scrolledToTop = scrollToIndex == 0;\n+        boolean scrolledToBottomElement = scrollToIndex == heights.length - 1;\n+        boolean scrolledToBottom = false;\n+        boolean isLastIndex = scrollToIndex == heights.length - 1;\n+        boolean shouldScrollToBottom = (sizeBelow < viewportLength) || (isLastIndex && lastCellSize >= viewportLength);\n+\n+        if (Math.abs(lastCell.getLayoutY() - (viewportLength - lastCellSize)) <= 1.0) {\n+            scrolledToBottom = true;\n+        }\n+\n+        assertTrue(\"Our cell must be visible!\", scrollToCell.isVisible());\n+\n+        if (lastCell.isVisible() && sumOfHeights >= viewportLength) {\n+            \/\/ There shouldn't be any space between the last cell and the bottom\n+            assertTrue(\"Last cell shouldn't leave space between itself and the bottom\", lastCell.getLayoutY() + 1 > (viewportLength - lastCellSize));\n+        }\n+        if (sumOfHeights < viewportLength) {\n+            \/\/ If we have less cells then space, then all cells are shown, and the position of the last cell, is the sum of the height of the previous cells.\n+            assertEquals(\"Last cell should be at the bottom, if we scroll to it\", sumOfHeights - lastCellSize, lastCell.getLayoutY(), 1.);\n+        }\n+        if (!shouldScrollToBottom && sumOfHeights > viewportLength) {\n+            \/\/ If we don't scroll to the bottom, and the cells are bigger than the available space, then our cell should be at the top.\n+            assertEquals(\"Our cell mut be at the top\", 0, scrollToCell.getLayoutY(), 1.);\n+        }\n+        \/\/ Additional Tests:\n+        double previousLayoutY = scrollToCell.getLayoutY();\n+        if (previousLayoutY == 0) {\n+            \/\/ Upper cell shouldn't move after heights are changed\n+            List<Integer> alternateHeights = Arrays.stream(heights).map(x -> x + 250).collect(Collectors.toList());\n+            listView.getItems().setAll(alternateHeights);\n+            listView.requestLayout();\n+            Toolkit.getToolkit().firePulse();\n+            assertEquals(\"Upper cell shouldn't move after changing heights\", previousLayoutY, scrollToCell.getLayoutY(), 1.);\n+        }\n+\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ListViewTest.java","additions":242,"deletions":2,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -4254,1 +4254,1 @@\n-                        assertTrue(rt_35395_counter < 18);\n+                        assertTrue(rt_35395_counter < 39);\n@@ -4261,1 +4261,1 @@\n-                            assertTrue(rt_35395_counter < 30);\n+                            assertTrue(rt_35395_counter < 90);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableViewTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}