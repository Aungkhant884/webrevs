{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,3 @@\n-import java.net.URLDecoder;\n-import java.nio.charset.Charset;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n@@ -106,1 +107,0 @@\n-        Charset charset = Charset.defaultCharset();\n@@ -115,3 +115,1 @@\n-            base64 ?\n-                Base64.getDecoder().decode(data) :\n-                URLDecoder.decode(data.replace(\"+\", \"%2B\"), charset).getBytes(charset));\n+            base64 ? Base64.getDecoder().decode(data) : decodePercentEncoding(data));\n@@ -211,0 +209,63 @@\n+    private static byte[] decodePercentEncoding(String input) {\n+        try (var output = new ByteArrayOutputStream(input.length())) {\n+            decodePercentEncodingToStream(input, output);\n+            return output.toByteArray();\n+        } catch (IOException ignored) {\n+            \/\/ can never happen for ByteArrayOutputStream\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Decodes percent-encoded text as specified by RFC 3986, page 11.\n+     * This method does not make any assumptions about the allowed character set.\n+     *\/\n+    private static void decodePercentEncodingToStream(String input, OutputStream output) throws IOException {\n+        enum ParseState {\n+            DEFAULT,\n+            FIRST_HEX_DIGIT,\n+            SECOND_HEX_DIGIT\n+        }\n+\n+        ParseState parseState = ParseState.DEFAULT;\n+        int firstDigit = 0;\n+\n+        for (int i = 0; i < input.length(); ++i) {\n+            char c = input.charAt(i);\n+\n+            parseState = switch (parseState) {\n+                case DEFAULT -> {\n+                    if (c == '%') {\n+                        yield ParseState.FIRST_HEX_DIGIT;\n+                    } else {\n+                        output.write(c);\n+                        yield ParseState.DEFAULT;\n+                    }\n+                }\n+\n+                case FIRST_HEX_DIGIT -> {\n+                    firstDigit = hexDigit(c);\n+                    yield ParseState.SECOND_HEX_DIGIT;\n+                }\n+\n+                case SECOND_HEX_DIGIT -> {\n+                    output.write(firstDigit << 4 | hexDigit(c));\n+                    yield ParseState.DEFAULT;\n+                }\n+            };\n+        }\n+\n+        if (parseState != ParseState.DEFAULT) {\n+            throw new IllegalArgumentException(\"Incomplete character escape sequence\");\n+        }\n+    }\n+\n+    private static int hexDigit(char c) {\n+        int digit = Character.digit(c, 16);\n+        if (digit < 0) {\n+            throw new IllegalArgumentException(\"Invalid symbol in character escape sequence\");\n+        }\n+\n+        return digit;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/DataURI.java","additions":68,"deletions":7,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,3 @@\n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n@@ -31,1 +33,1 @@\n-import static org.junit.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -43,1 +45,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -47,1 +49,1 @@\n-        DataURI uri = DataURI.tryParse(data);\n+        assertThrows(IllegalArgumentException.class, () -> DataURI.tryParse(data));\n@@ -177,0 +179,27 @@\n+    @Test\n+    public void testPercentEncodedTextIsDecodedAccordingToRFC3986() {\n+        \/\/ We use URLEncoder here to escape the emoji character using percent-encoding.\n+        \/\/ When DataURI parses its payload, it automatically converts percent-encoded characters back to octets.\n+        String input = URLEncoder.encode(\"ðŸ™‚\", StandardCharsets.UTF_8);\n+        String output = new String(DataURI.tryParse(\"data:,\" + input).getData(), StandardCharsets.UTF_8);\n+        assertEquals(\"ðŸ™‚\", output);\n+\n+        \/\/ In the next case, URLEncoder replaces the space character with '+'.\n+        \/\/ Since DataURI does not know about this special encoding, the '+' character is retained.\n+        input = URLEncoder.encode(\"Hello ðŸ™‚!\", StandardCharsets.UTF_8);\n+        output = new String(DataURI.tryParse(\"data:,\" + input).getData(), StandardCharsets.UTF_8);\n+        assertEquals(\"Hello+ðŸ™‚!\", output);\n+    }\n+\n+    @Test\n+    public void testPercentEncodedTextContainsInvalidEscapeSequence() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> DataURI.tryParse(\"data:,%XY\"));\n+        assertTrue(ex.getMessage().startsWith(\"Invalid\"));\n+\n+        ex = assertThrows(IllegalArgumentException.class, () -> DataURI.tryParse(\"data:,%5G\"));\n+        assertTrue(ex.getMessage().startsWith(\"Invalid\"));\n+\n+        ex = assertThrows(IllegalArgumentException.class, () -> DataURI.tryParse(\"data:,%0\"));\n+        assertTrue(ex.getMessage().startsWith(\"Incomplete\"));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/util\/DataURITest.java","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"}]}