{"files":[{"patch":"@@ -455,0 +455,1 @@\n+     * The returned widths are snapped to pixels in the horizontal direction.\n@@ -475,4 +476,6 @@\n-     * Adjusts the children widths to fit the provided space.\n-     * This might be necessary because the HBox is size-constrained and cannot accommodate the preferred\n-     * widths for all children, or it might be necessary because the HBox is sized to be larger than the\n-     * preferred widths of its children and needs to grow its children to fit its size.\n+     * Adjusts the children widths (within their min-max limits) to fit the provided space.\n+     * This is necessary when the HBox is constrained to be larger or smaller than the combined preferred\n+     * widths of its children. In this case, we grow or shrink the children until they fit the HBox exactly.\n+     *\n+     * @return the pixel-snapped content width, which is the combined width\n+     *         of all children as well as the spacing between them\n@@ -501,1 +504,1 @@\n-     * Shrinking is a one-step process: all children are eligible to be adjusted down to their minimum width.\n+     * In contrast to growing, shrinking does not require two phases of processing.\n@@ -519,1 +522,1 @@\n-     * Growing is a two-step process: first, only children with {@link Priority#ALWAYS} are eligible\n+     * Growing is a two-phase process: first, only children with {@link Priority#ALWAYS} are eligible\n@@ -533,0 +536,4 @@\n+\n+                \/\/ If the child is eligible to grow (as indicated by its horizontal grow priority),\n+                \/\/ we count it towards the 'adjustingNumber', which represents the number of children\n+                \/\/ that can grow in this phase.\n@@ -542,0 +549,2 @@\n+            \/\/ Adjust the children that are eligible in this phase and return early if the children\n+            \/\/ fit the target width (so no second phase is required).\n@@ -565,0 +574,3 @@\n+\n+        \/\/ Current total width and current delta are two important numbers that we continuously\n+        \/\/ update as this method converges towards a solution.\n@@ -568,0 +580,3 @@\n+        \/\/ We repeatedly apply the following algorithm as long as we have space left to\n+        \/\/ distribute (currentDelta), as well as children that are eligible to grow or\n+        \/\/ shrink (adjustingNumber).\n@@ -569,1 +584,3 @@\n-            double portion = snapPortionX(currentDelta \/ adjustingNumber);\n+            \/\/ The amount of space that, in the ideal case, we need to add to or subtract from\n+            \/\/ each eligible child in order to fit the children into the target width.\n+            double idealChange = snapPortionX(currentDelta \/ adjustingNumber);\n@@ -572,0 +589,1 @@\n+                \/\/ If the child is not eligible for adjustment, skip it.\n@@ -576,0 +594,2 @@\n+                \/\/ The actual amount of space that we add to or remove from the child is restricted\n+                \/\/ by its minimum and maximum width.\n@@ -577,1 +597,1 @@\n-                double change = currentDelta > 0 ? Math.min(maxChange, portion) : Math.max(maxChange, portion);\n+                double actualChange = currentDelta > 0 ? Math.min(maxChange, idealChange) : Math.max(maxChange, idealChange);\n@@ -580,1 +600,4 @@\n-                currentWidths[i] = snapSizeX(currentWidths[i] + change);\n+                \/\/ Update the child width and snap the updated width to pixels in the horizontal direction.\n+                \/\/ Since snapping affects the total width, we need to recompute the current total width to\n+                \/\/ know how much space we have left to distribute.\n+                currentWidths[i] = snapSizeX(currentWidths[i] + actualChange);\n@@ -583,0 +606,3 @@\n+                \/\/ Update the amount of space we still need to grow or shrink (currentDelta) for the\n+                \/\/ remaining children. If we overshoot our target, we're done because we can't resize\n+                \/\/ any further.\n@@ -591,1 +617,4 @@\n-                if (Math.abs(change) < Math.abs(portion)) {\n+                \/\/ If the actual change for the current child was restricted (as evidenced by its smaller\n+                \/\/ magnitude when compared to the ideal change), we've reached the limit for this child and\n+                \/\/ need to exclude it from further consideration.\n+                if (Math.abs(actualChange) < Math.abs(idealChange)) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HBox.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -435,0 +435,1 @@\n+     * The returned heights are snapped to pixels in the vertical direction.\n@@ -463,4 +464,6 @@\n-     * Adjusts the children heights to fit the provided space.\n-     * This might be necessary because the VBox is size-constrained and cannot accommodate the preferred\n-     * heights for all children, or it might be necessary because the VBox is sized to be larger than the\n-     * preferred heights of its children and needs to grow its children to fit its size.\n+     * Adjusts the children heights (within their min-max limits) to fit the provided space.\n+     * This is necessary when the VBox is constrained to be larger or smaller than the combined preferred\n+     * heights of its children. In this case, we grow or shrink the children until they fit the VBox exactly.\n+     *\n+     * @return the pixel-snapped content height, which is the combined height\n+     *         of all children as well as the spacing between them\n@@ -489,1 +492,1 @@\n-     * Shrinking is a one-step process: all children are eligible to be adjusted down to their minimum height.\n+     * In contrast to growing, shrinking does not require two phases of processing.\n@@ -505,1 +508,1 @@\n-     * Growing is a two-step process: first, only children with {@link Priority#ALWAYS} are eligible\n+     * Growing is a two-phase process: first, only children with {@link Priority#ALWAYS} are eligible\n@@ -518,0 +521,4 @@\n+\n+                \/\/ If the child is eligible to grow (as indicated by its vertical grow priority),\n+                \/\/ we count it towards the 'adjustingNumber', which represents the number of children\n+                \/\/ that can grow in this phase.\n@@ -526,0 +533,2 @@\n+            \/\/ Adjust the children that are eligible in this phase and return early if the children\n+            \/\/ fit the target height (so no second phase is required).\n@@ -534,1 +543,1 @@\n-     * for each child (their minimum and maximum width). This method will be called once when shrinking,\n+     * for each child (their minimum and maximum height). This method will be called once when shrinking,\n@@ -549,0 +558,3 @@\n+\n+        \/\/ Current total height and current delta are two important numbers that we continuously\n+        \/\/ update as this method converges towards a solution.\n@@ -552,0 +564,3 @@\n+        \/\/ We repeatedly apply the following algorithm as long as we have space left to\n+        \/\/ distribute (currentDelta), as well as children that are eligible to grow or\n+        \/\/ shrink (adjustingNumber).\n@@ -553,1 +568,3 @@\n-            double portion = snapPortionY(currentDelta \/ adjustingNumber);\n+            \/\/ The amount of space that, in the ideal case, we need to add to or subtract from\n+            \/\/ each eligible child in order to fit the children into the target height.\n+            double idealChange = snapPortionY(currentDelta \/ adjustingNumber);\n@@ -556,0 +573,1 @@\n+                \/\/ If the child is not eligible for adjustment, skip it.\n@@ -560,0 +578,2 @@\n+                \/\/ The actual amount of space that we add to or remove from the child is restricted\n+                \/\/ by its minimum and maximum height.\n@@ -561,1 +581,1 @@\n-                double change = currentDelta > 0 ? Math.min(maxChange, portion) : Math.max(maxChange, portion);\n+                double actualChange = currentDelta > 0 ? Math.min(maxChange, idealChange) : Math.max(maxChange, idealChange);\n@@ -564,1 +584,4 @@\n-                currentHeights[i] = snapSizeY(currentHeights[i] + change);\n+                \/\/ Update the child height and snap the updated height to pixels in the vertical direction.\n+                \/\/ Since snapping affects the total height, we need to recompute the current total height to\n+                \/\/ know how much space we have left to distribute.\n+                currentHeights[i] = snapSizeY(currentHeights[i] + actualChange);\n@@ -567,0 +590,3 @@\n+                \/\/ Update the amount of space we still need to grow or shrink (currentDelta) for the\n+                \/\/ remaining children. If we overshoot our target, we're done because we can't resize\n+                \/\/ any further.\n@@ -575,1 +601,4 @@\n-                if (Math.abs(change) < Math.abs(portion)) {\n+                \/\/ If the actual change for the current child was restricted (as evidenced by its smaller\n+                \/\/ magnitude when compared to the ideal change), we've reached the limit for this child and\n+                \/\/ need to exclude it from further consideration.\n+                if (Math.abs(actualChange) < Math.abs(idealChange)) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/VBox.java","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"}]}