{"files":[{"patch":"@@ -164,0 +164,1 @@\n+    private static final Priority[] GROW_PRIORITY = new Priority[] {Priority.ALWAYS, Priority.SOMETIMES};\n@@ -470,1 +471,1 @@\n-    private double adjustAreaWidths(List<Node>managed, double areaWidths[][], double width, double height) {\n+    private double adjustAreaWidths(List<Node> managed, double[][] areaWidths, double width, double height) {\n@@ -475,3 +476,4 @@\n-        double contentWidth = sum(areaWidths[0], managed.size()) + (managed.size()-1)*snapSpaceX(getSpacing());\n-        double extraWidth = width -\n-                snapSpaceX(insets.getLeft()) - snapSpaceX(insets.getRight()) - contentWidth;\n+        double refHeight = shouldFillHeight() && height != -1 ? height - top - bottom : -1;\n+        double totalSpacing = (managed.size() - 1) * snapSpaceX(getSpacing());\n+        double contentWidth = sum(areaWidths[0], managed.size()) + totalSpacing;\n+        double targetWidth = width - snapSpaceX(insets.getLeft()) - snapSpaceX(insets.getRight());\n@@ -479,5 +481,4 @@\n-        if (extraWidth != 0) {\n-            final double refHeight = shouldFillHeight() && height != -1? height - top - bottom : -1;\n-            double remaining = growOrShrinkAreaWidths(managed, areaWidths, Priority.ALWAYS, extraWidth, refHeight);\n-            remaining = growOrShrinkAreaWidths(managed, areaWidths, Priority.SOMETIMES, remaining, refHeight);\n-            contentWidth += (extraWidth - remaining);\n+        if (contentWidth < targetWidth) {\n+            growAreaWidths(managed, areaWidths, targetWidth, refHeight);\n+        } else if (contentWidth > targetWidth) {\n+            shrinkAreaWidths(managed, areaWidths, targetWidth, refHeight);\n@@ -485,1 +486,2 @@\n-        return contentWidth;\n+\n+        return sum(areaWidths[0], managed.size()) + totalSpacing;\n@@ -488,3 +490,13 @@\n-    private double growOrShrinkAreaWidths(List<Node>managed, double areaWidths[][], Priority priority, double extraWidth, double height) {\n-        final boolean shrinking = extraWidth < 0;\n-        int adjustingNumber = 0;\n+    private void shrinkAreaWidths(List<Node> managed, double[][] areaWidths, double targetWidth, double height) {\n+        double[] usedWidths = areaWidths[0];\n+        double[] minWidths = areaWidths[1];\n+        boolean shouldFillHeight = shouldFillHeight();\n+\n+        for (int i = 0, size = managed.size(); i < size; i++) {\n+            final Node child = managed.get(i);\n+            minWidths[i] = computeChildMinAreaWidth(\n+                child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n+        }\n+\n+        adjustWidthsWithinLimits(managed, usedWidths, minWidths, targetWidth, managed.size());\n+    }\n@@ -492,0 +504,1 @@\n+    private void growAreaWidths(List<Node> managed, double[][] areaWidths, double targetWidth, double height) {\n@@ -493,2 +506,5 @@\n-        double[] temp = areaWidths[1];\n-        final boolean shouldFillHeight = shouldFillHeight();\n+        double[] maxWidths = areaWidths[1];\n+        boolean shouldFillHeight = shouldFillHeight();\n+\n+        for (Priority priority : GROW_PRIORITY) {\n+            int adjustingNumber = 0;\n@@ -496,7 +512,0 @@\n-        if (shrinking) {\n-            adjustingNumber = managed.size();\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                final Node child = managed.get(i);\n-                temp[i] = computeChildMinAreaWidth(child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n-            }\n-        } else {\n@@ -506,2 +515,3 @@\n-                    temp[i] = computeChildMaxAreaWidth(child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n-                    adjustingNumber++;\n+                    maxWidths[i] = computeChildMaxAreaWidth(\n+                        child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n+                    ++adjustingNumber;\n@@ -509,1 +519,1 @@\n-                    temp[i] = -1;\n+                    maxWidths[i] = -1;\n@@ -512,0 +522,4 @@\n+\n+            if (adjustWidthsWithinLimits(managed, usedWidths, maxWidths, targetWidth, adjustingNumber)) {\n+                return;\n+            }\n@@ -513,0 +527,1 @@\n+    }\n@@ -514,5 +529,11 @@\n-        double available = extraWidth; \/\/ will be negative in shrinking case\n-        outer:while (Math.abs(available) > 1 && adjustingNumber > 0) {\n-            final double portion = snapPortionX(available \/ adjustingNumber); \/\/ negative in shrinking case\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                if (temp[i] == -1) {\n+    private boolean adjustWidthsWithinLimits(\n+            List<Node> managed, double[] usedWidths, double[] limitWidths, double targetWidth, int adjustingNumber) {\n+        double totalSpacing = (managed.size() - 1) * snapSpaceX(getSpacing());\n+        double currentWidth = sum(usedWidths, managed.size()) + totalSpacing;\n+        double currentDelta = targetWidth - currentWidth;\n+\n+        while ((currentDelta > Double.MIN_VALUE || currentDelta < -Double.MIN_VALUE) && adjustingNumber > 0) {\n+            double portion = snapPortionX(currentDelta \/ adjustingNumber);\n+\n+            for (int i = managed.size() - 1; i >= 0; i--) {\n+                if (limitWidths[i] == -1) {\n@@ -521,6 +542,12 @@\n-                final double limit = temp[i] - usedWidths[i]; \/\/ negative in shrinking case\n-                final double change = Math.abs(limit) <= Math.abs(portion)? limit : portion;\n-                usedWidths[i] += change;\n-                available -= change;\n-                if (Math.abs(available) < 1) {\n-                    break outer;\n+\n+                double maxChange = limitWidths[i] - usedWidths[i];\n+                double change = currentDelta > 0 ? Math.min(maxChange, portion) : Math.max(maxChange, portion);\n+                double oldWidth = usedWidths[i];\n+\n+                usedWidths[i] = snapSizeX(usedWidths[i] + change);\n+                currentWidth = sum(usedWidths, managed.size()) + totalSpacing;\n+\n+                double newDelta = targetWidth - currentWidth;\n+                if (Math.abs(newDelta) > Math.abs(currentDelta)) {\n+                    usedWidths[i] = oldWidth;\n+                    return true;\n@@ -528,0 +555,3 @@\n+\n+                currentDelta = newDelta;\n+\n@@ -529,1 +559,1 @@\n-                    temp[i] = -1;\n+                    limitWidths[i] = -1;\n@@ -535,1 +565,1 @@\n-        return available; \/\/ might be negative in shrinking case\n+        return false;\n@@ -543,2 +573,1 @@\n-    private static double sum(double[] array, int size) {\n-        int i = 0;\n+    private double sum(double[] array, int size) {\n@@ -546,2 +575,2 @@\n-        while (i != size) {\n-            res += array[i++];\n+        for (int i = 0; i < size; ++i) {\n+            res += array[i];\n@@ -549,1 +578,1 @@\n-        return res;\n+        return snapSpaceX(res);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HBox.java","additions":72,"deletions":43,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2610,1 +2610,0 @@\n-\n@@ -2615,1 +2614,1 @@\n-                         snapSize(size.y, isSnapToPixel, snapScaleX));\n+                         snapSize(size.y, isSnapToPixel, snapScaleY));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+    private static final Priority[] GROW_PRIORITY = new Priority[] {Priority.ALWAYS, Priority.SOMETIMES};\n@@ -460,1 +461,1 @@\n-    private double adjustAreaHeights(List<Node>managed, double areaHeights[][], double height, double width) {\n+    private double adjustAreaHeights(List<Node>managed, double[][] areaHeights, double height, double width) {\n@@ -465,3 +466,4 @@\n-        double contentHeight = sum(areaHeights[0], managed.size()) + (managed.size()-1)*snapSpaceY(getSpacing());\n-        double extraHeight = height -\n-                snapSpaceY(insets.getTop()) - snapSpaceY(insets.getBottom()) - contentHeight;\n+        double refWidth = isFillWidth() && width != -1 ? width - left - right : -1;\n+        double totalSpacing = (managed.size() - 1) * snapSpaceY(getSpacing());\n+        double contentHeight = sum(areaHeights[0], managed.size()) + totalSpacing;\n+        double targetHeight = height - snapSpaceY(insets.getTop()) - snapSpaceY(insets.getBottom());\n@@ -469,5 +471,4 @@\n-        if (extraHeight != 0) {\n-            final double refWidth = isFillWidth()&& width != -1? width - left - right : -1;\n-            double remaining = growOrShrinkAreaHeights(managed, areaHeights, Priority.ALWAYS, extraHeight, refWidth);\n-            remaining = growOrShrinkAreaHeights(managed, areaHeights, Priority.SOMETIMES, remaining, refWidth);\n-            contentHeight += (extraHeight - remaining);\n+        if (contentHeight < targetHeight) {\n+            growAreaHeights(managed, areaHeights, targetHeight, refWidth);\n+        } else if (contentHeight > targetHeight) {\n+            shrinkAreaHeights(managed, areaHeights, targetHeight, refWidth);\n@@ -476,1 +477,1 @@\n-        return contentHeight;\n+        return sum(areaHeights[0], managed.size()) + totalSpacing;\n@@ -479,3 +480,11 @@\n-    private double growOrShrinkAreaHeights(List<Node>managed, double areaHeights[][], Priority priority, double extraHeight, double width) {\n-        final boolean shrinking = extraHeight < 0;\n-        int adjustingNumber = 0;\n+    private void shrinkAreaHeights(List<Node> managed, double[][] areaHeights, double targetHeight, double width) {\n+        double[] usedHeights = areaHeights[0];\n+        double[] minHeights = areaHeights[1];\n+\n+        for (int i = 0, size = managed.size(); i < size; i++) {\n+            final Node child = managed.get(i);\n+            minHeights[i] = computeChildMinAreaHeight(child, -1, getMargin(child), width);\n+        }\n+\n+        adjustHeightsWithinLimits(managed, usedHeights, minHeights, targetHeight, managed.size());\n+    }\n@@ -483,0 +492,1 @@\n+    private void growAreaHeights(List<Node> managed, double[][] areaHeights, double targetHeight, double width) {\n@@ -484,1 +494,4 @@\n-        double[] temp = areaHeights[1];\n+        double[] maxHeights = areaHeights[1];\n+\n+        for (Priority priority : GROW_PRIORITY) {\n+            int adjustingNumber = 0;\n@@ -486,2 +499,0 @@\n-        if (shrinking) {\n-            adjustingNumber = managed.size();\n@@ -490,1 +501,6 @@\n-                temp[i] = computeChildMinAreaHeight(child, -1, getMargin(child), width);\n+                if (getVgrow(child) == priority) {\n+                    maxHeights[i] = computeChildMaxAreaHeight(child, -1, getMargin(child), width);\n+                    ++adjustingNumber;\n+                } else {\n+                    maxHeights[i] = -1;\n+                }\n@@ -492,8 +508,3 @@\n-        } else {\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-            final Node child = managed.get(i);\n-            if (getVgrow(child) == priority) {\n-                temp[i] = computeChildMaxAreaHeight(child, -1, getMargin(child), width);\n-                adjustingNumber++;\n-            } else {\n-                temp[i] = -1;\n+\n+            if (adjustHeightsWithinLimits(managed, usedHeights, maxHeights, targetHeight, adjustingNumber)) {\n+                return;\n@@ -502,1 +513,1 @@\n-        }\n+    }\n@@ -504,5 +515,11 @@\n-        double available = extraHeight; \/\/ will be negative in shrinking case\n-        outer: while (Math.abs(available) > 1 && adjustingNumber > 0) {\n-            final double portion = snapPortionY(available \/ adjustingNumber); \/\/ negative in shrinking case\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                if (temp[i] == -1) {\n+    private boolean adjustHeightsWithinLimits(\n+            List<Node> managed, double[] usedHeights, double[] limitHeights, double targetHeight, int adjustingNumber) {\n+        double totalSpacing = (managed.size() - 1) * snapSpaceY(getSpacing());\n+        double currentHeight = sum(usedHeights, managed.size()) + totalSpacing;\n+        double currentDelta = targetHeight - currentHeight;\n+\n+        while ((currentDelta > Double.MIN_VALUE || currentDelta < -Double.MIN_VALUE) && adjustingNumber > 0) {\n+            double portion = snapPortionY(currentDelta \/ adjustingNumber);\n+\n+            for (int i = managed.size() - 1; i >= 0; i--) {\n+                if (limitHeights[i] == -1) {\n@@ -511,6 +528,12 @@\n-                final double limit = temp[i] - usedHeights[i]; \/\/ negative in shrinking case\n-                final double change = Math.abs(limit) <= Math.abs(portion)? limit : portion;\n-                usedHeights[i] += change;\n-                available -= change;\n-                if (Math.abs(available) < 1) {\n-                    break outer;\n+\n+                double maxChange = limitHeights[i] - usedHeights[i];\n+                double change = currentDelta > 0 ? Math.min(maxChange, portion) : Math.max(maxChange, portion);\n+                double oldHeight = usedHeights[i];\n+\n+                usedHeights[i] = snapSizeY(usedHeights[i] + change);\n+                currentHeight = sum(usedHeights, managed.size()) + totalSpacing;\n+\n+                double newDelta = targetHeight - currentHeight;\n+                if (Math.abs(newDelta) > Math.abs(currentDelta)) {\n+                    usedHeights[i] = oldHeight;\n+                    return true;\n@@ -518,0 +541,3 @@\n+\n+                currentDelta = newDelta;\n+\n@@ -519,1 +545,1 @@\n-                    temp[i] = -1;\n+                    limitHeights[i] = -1;\n@@ -525,1 +551,1 @@\n-        return available; \/\/ might be negative in shrinking case\n+        return false;\n@@ -533,2 +559,1 @@\n-    private static double sum(double[] array, int size) {\n-        int i = 0;\n+    private double sum(double[] array, int size) {\n@@ -536,2 +561,2 @@\n-        while (i != size) {\n-            res += array[i++];\n+        for (int i = 0; i < size; ++i) {\n+            res += array[i];\n@@ -539,1 +564,1 @@\n-        return res;\n+        return snapSpaceY(res);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/VBox.java","additions":69,"deletions":44,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Region;\n+import javafx.stage.Stage;\n@@ -908,0 +912,66 @@\n+    \/**\n+     * Given resizable children, the sum of child widths of a HBox must pixel-snap to the\n+     * same value as the width of the HBox itself, independent of render scale.\n+     *\n+     *                   (prefWidth=76.0)\n+     * ╔════════════════╤════════════════╤════════════════╗\n+     * ║ prefWidth=25.3 │ prefWidth=25.3 │ prefWidth=25.4 ║\n+     * ╚════════════════╧════════════════╧════════════════╝\n+     *\/\n+    @Test public void testPixelSnappedContentWidthIsSameAsBoxWidth() {\n+        for (testPixelSnapConfig config : new testPixelSnapConfig[] {\n+            \/\/ For these tests, HBox.prefWidth is specified, so we expect the final width to be exactly that.\n+            \/\/ Child widths will be adjusted appropriately such that the sum of child widths corresponds to HBox.prefWidth.\n+            new testPixelSnapConfig(76.0, 1.0, true),\n+            new testPixelSnapConfig(76.0, 1.25, true),\n+            new testPixelSnapConfig(76.0, 1.5, true),\n+            new testPixelSnapConfig(76.0, 1.75, true),\n+            new testPixelSnapConfig(76.0, 2.0, true),\n+            new testPixelSnapConfig(76.0, 2.25, true),\n+            new testPixelSnapConfig(76.0, 2.5, true),\n+\n+            \/\/ For these tests, HBox.prefWidth is not specified, which means that child widths will not be adjusted.\n+            \/\/ The final width will snap slightly differently for each configuration.\n+            new testPixelSnapConfig(78.0, 1.0, false),\n+            new testPixelSnapConfig(76.8, 1.25, false),\n+            new testPixelSnapConfig(76.66666666666667, 1.5, false),\n+            new testPixelSnapConfig(77.14285714285714, 1.75, false),\n+            new testPixelSnapConfig(76.5, 2.0, false),\n+            new testPixelSnapConfig(76.44444444444444, 2.25, false),\n+            new testPixelSnapConfig(76.8, 2.5, false),\n+        }) {\n+            Region r1 = new Region(); r1.setPrefWidth(25.3);\n+            Region r2 = new Region(); r2.setPrefWidth(25.3);\n+            Region r3 = new Region(); r3.setPrefWidth(25.4);\n+            HBox box = new HBox(r1, r2, r3);\n+            box.setSnapToPixel(true);\n+\n+            if (config.specifyContainerPrefWidth) {\n+                box.setPrefWidth(76.0);\n+            }\n+\n+            SimpleDoubleProperty renderScale = new SimpleDoubleProperty(config.scale);\n+            Stage stage = new Stage();\n+            stage.renderScaleXProperty().bind(renderScale);\n+            stage.renderScaleYProperty().bind(renderScale);\n+            stage.setScene(new Scene(new HBox(box)));\n+            stage.show();\n+\n+            assertEquals(config.expectedWidth, box.getWidth(), 10e-14);\n+            assertEquals(config.expectedWidth, r1.getWidth() + r2.getWidth() + r3.getWidth(), 10e-14);\n+            stage.close();\n+        }\n+    }\n+\n+    private static class testPixelSnapConfig {\n+        final double expectedWidth;\n+        final double scale;\n+        final boolean specifyContainerPrefWidth;\n+\n+        testPixelSnapConfig(double expectedWidth, double scale, boolean specifyContainerPrefWidth) {\n+            this.expectedWidth = expectedWidth;\n+            this.scale = scale;\n+            this.specifyContainerPrefWidth = specifyContainerPrefWidth;\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HBoxTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -28,2 +28,5 @@\n-import test.javafx.scene.layout.MockBiased;\n-import test.javafx.scene.layout.MockRegion;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Region;\n+import javafx.stage.Stage;\n+\n@@ -786,0 +789,70 @@\n+\n+    \/**\n+     * Given resizable children, the sum of child heights of a VBox must pixel-snap to the\n+     * same value as the height of the VBox itself, independent of render scale.\n+     *\n+     *   (prefHeight=76.0)\n+     * ╔═══════════════════╗\n+     * ║  prefHeight=25.3  ║\n+     * ╟───────────────────╢\n+     * ║  prefHeight=25.3  ║\n+     * ╟───────────────────╢\n+     * ║  prefHeight=25.4  ║\n+     * ╚═══════════════════╝\n+     *\/\n+    @Test public void testPixelSnappedContentHeightIsSameAsBoxHeight() {\n+        for (testPixelSnapConfig config : new testPixelSnapConfig[] {\n+            \/\/ For these tests, VBox.prefHeight is specified, so we expect the final height to be exactly that.\n+            \/\/ Child heights will be adjusted appropriately such that the sum of child widths corresponds to VBox.prefHeight.\n+            new testPixelSnapConfig(76.0, 1.0, true),\n+            new testPixelSnapConfig(76.0, 1.25, true),\n+            new testPixelSnapConfig(76.0, 1.5, true),\n+            new testPixelSnapConfig(76.0, 1.75, true),\n+            new testPixelSnapConfig(76.0, 2.0, true),\n+            new testPixelSnapConfig(76.0, 2.25, true),\n+            new testPixelSnapConfig(76.0, 2.5, true),\n+\n+            \/\/ For these tests, VBox.prefHeight is not specified, which means that child heights will not be adjusted.\n+            \/\/ The final height will snap slightly differently for each configuration.\n+            new testPixelSnapConfig(78.0, 1.0, false),\n+            new testPixelSnapConfig(76.8, 1.25, false),\n+            new testPixelSnapConfig(76.66666666666667, 1.5, false),\n+            new testPixelSnapConfig(77.14285714285714, 1.75, false),\n+            new testPixelSnapConfig(76.5, 2.0, false),\n+            new testPixelSnapConfig(76.44444444444444, 2.25, false),\n+            new testPixelSnapConfig(76.8, 2.5, false),\n+        }) {\n+            Region r1 = new Region(); r1.setPrefHeight(25.3);\n+            Region r2 = new Region(); r2.setPrefHeight(25.3);\n+            Region r3 = new Region(); r3.setPrefHeight(25.4);\n+            VBox box = new VBox(r1, r2, r3);\n+            box.setSnapToPixel(true);\n+\n+            if (config.specifyContainerPrefHeight) {\n+                box.setPrefHeight(76.0);\n+            }\n+\n+            SimpleDoubleProperty renderScale = new SimpleDoubleProperty(config.scale);\n+            Stage stage = new Stage();\n+            stage.renderScaleXProperty().bind(renderScale);\n+            stage.renderScaleYProperty().bind(renderScale);\n+            stage.setScene(new Scene(new VBox(box)));\n+            stage.show();\n+\n+            assertEquals(config.expectedHeight, box.getHeight(), 10e-14);\n+            assertEquals(config.expectedHeight, r1.getHeight() + r2.getHeight() + r3.getHeight(), 10e-14);\n+            stage.close();\n+        }\n+    }\n+\n+    private static class testPixelSnapConfig {\n+        final double expectedHeight;\n+        final double scale;\n+        final boolean specifyContainerPrefHeight;\n+\n+        testPixelSnapConfig(double expectedHeight, double scale, boolean specifyContainerPrefHeight) {\n+            this.expectedHeight = expectedHeight;\n+            this.scale = scale;\n+            this.specifyContainerPrefHeight = specifyContainerPrefHeight;\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/VBoxTest.java","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"}]}