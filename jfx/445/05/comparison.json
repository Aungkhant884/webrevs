{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,0 +164,1 @@\n+    private static final Priority[] GROW_PRIORITY = new Priority[] {Priority.ALWAYS, Priority.SOMETIMES};\n@@ -418,2 +419,2 @@\n-            double prefWidths[][] = getAreaWidths(managed, -1, false);\n-            adjustAreaWidths(managed, prefWidths, width, -1);\n+            double[][] prefWidths = computeChildrenWidths(managed, -1, false);\n+            adjustChildrenWidths(managed, prefWidths, width, -1);\n@@ -441,2 +442,2 @@\n-            double prefWidths[][] = getAreaWidths(managed, -1, false);\n-            adjustAreaWidths(managed, prefWidths, width, -1);\n+            double[][] prefWidths = computeChildrenWidths(managed, -1, false);\n+            adjustChildrenWidths(managed, prefWidths, width, -1);\n@@ -452,1 +453,5 @@\n-    private double[][] getAreaWidths(List<Node>managed, double height, boolean minimum) {\n+    \/**\n+     * Calculates the preferred or minimum width for each child.\n+     * The returned widths are snapped to pixels in the horizontal direction.\n+     *\/\n+    private double[][] computeChildrenWidths(List<Node> managed, double height, boolean minimum) {\n@@ -470,1 +475,9 @@\n-    private double adjustAreaWidths(List<Node>managed, double areaWidths[][], double width, double height) {\n+    \/**\n+     * Adjusts the children widths (within their min-max limits) to fit the provided space.\n+     * This is necessary when the HBox is constrained to be larger or smaller than the combined preferred\n+     * widths of its children. In this case, we grow or shrink the children until they fit the HBox exactly.\n+     *\n+     * @return the pixel-snapped content width, which is the combined width\n+     *         of all children as well as the spacing between them\n+     *\/\n+    private double adjustChildrenWidths(List<Node> managed, double[][] childrenWidths, double width, double height) {\n@@ -475,3 +488,4 @@\n-        double contentWidth = sum(areaWidths[0], managed.size()) + (managed.size()-1)*snapSpaceX(getSpacing());\n-        double extraWidth = width -\n-                snapSpaceX(insets.getLeft()) - snapSpaceX(insets.getRight()) - contentWidth;\n+        double refHeight = shouldFillHeight() && height != -1 ? height - top - bottom : -1;\n+        double totalSpacing = (managed.size() - 1) * snapSpaceX(getSpacing());\n+        double contentWidth = snapSpaceX(sum(childrenWidths[0], managed.size())) + totalSpacing;\n+        double targetWidth = width - snapSpaceX(insets.getLeft()) - snapSpaceX(insets.getRight());\n@@ -479,5 +493,4 @@\n-        if (extraWidth != 0) {\n-            final double refHeight = shouldFillHeight() && height != -1? height - top - bottom : -1;\n-            double remaining = growOrShrinkAreaWidths(managed, areaWidths, Priority.ALWAYS, extraWidth, refHeight);\n-            remaining = growOrShrinkAreaWidths(managed, areaWidths, Priority.SOMETIMES, remaining, refHeight);\n-            contentWidth += (extraWidth - remaining);\n+        if (contentWidth < targetWidth) {\n+            growChildrenWidths(managed, childrenWidths, targetWidth, refHeight);\n+        } else if (contentWidth > targetWidth) {\n+            shrinkChildrenWidths(managed, childrenWidths, targetWidth, refHeight);\n@@ -485,1 +498,2 @@\n-        return contentWidth;\n+\n+        return snapSpaceX(sum(childrenWidths[0], managed.size())) + totalSpacing;\n@@ -488,3 +502,14 @@\n-    private double growOrShrinkAreaWidths(List<Node>managed, double areaWidths[][], Priority priority, double extraWidth, double height) {\n-        final boolean shrinking = extraWidth < 0;\n-        int adjustingNumber = 0;\n+    \/**\n+     * Shrinks all children widths to fit the target width.\n+     * In contrast to growing, shrinking does not require two phases of processing.\n+     *\/\n+    private void shrinkChildrenWidths(List<Node> managed, double[][] childrenWidths, double targetWidth, double height) {\n+        double[] usedWidths = childrenWidths[0];\n+        double[] minWidths = childrenWidths[1];\n+        boolean shouldFillHeight = shouldFillHeight();\n+\n+        for (int i = 0, size = managed.size(); i < size; i++) {\n+            final Node child = managed.get(i);\n+            minWidths[i] = computeChildMinAreaWidth(\n+                child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n+        }\n@@ -492,3 +517,16 @@\n-        double[] usedWidths = areaWidths[0];\n-        double[] temp = areaWidths[1];\n-        final boolean shouldFillHeight = shouldFillHeight();\n+        adjustWidthsWithinLimits(managed, usedWidths, minWidths, targetWidth, managed.size());\n+    }\n+\n+    \/**\n+     * Grows all children widths to fit the target width.\n+     * Growing is a two-phase process: first, only children with {@link Priority#ALWAYS} are eligible\n+     * for adjustment. If the first adjustment didn't suffice to fit the target width, children with\n+     * {@link Priority#SOMETIMES} are also eligible for adjustment.\n+     *\/\n+    private void growChildrenWidths(List<Node> managed, double[][] childrenWidths, double targetWidth, double height) {\n+        double[] currentWidths = childrenWidths[0];\n+        double[] maxWidths = childrenWidths[1];\n+        boolean shouldFillHeight = shouldFillHeight();\n+\n+        for (Priority priority : GROW_PRIORITY) {\n+            int adjustingNumber = 0;\n@@ -496,7 +534,0 @@\n-        if (shrinking) {\n-            adjustingNumber = managed.size();\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                final Node child = managed.get(i);\n-                temp[i] = computeChildMinAreaWidth(child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n-            }\n-        } else {\n@@ -505,0 +536,4 @@\n+\n+                \/\/ If the child is eligible to grow (as indicated by its horizontal grow priority),\n+                \/\/ we count it towards the 'adjustingNumber', which represents the number of children\n+                \/\/ that can grow in this phase.\n@@ -506,2 +541,3 @@\n-                    temp[i] = computeChildMaxAreaWidth(child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n-                    adjustingNumber++;\n+                    maxWidths[i] = computeChildMaxAreaWidth(\n+                        child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n+                    ++adjustingNumber;\n@@ -509,1 +545,1 @@\n-                    temp[i] = -1;\n+                    maxWidths[i] = -1;\n@@ -512,0 +548,6 @@\n+\n+            \/\/ Adjust the children that are eligible in this phase and return early if the children\n+            \/\/ fit the target width (so no second phase is required).\n+            if (adjustWidthsWithinLimits(managed, currentWidths, maxWidths, targetWidth, adjustingNumber)) {\n+                return;\n+            }\n@@ -513,0 +555,1 @@\n+    }\n@@ -514,5 +557,34 @@\n-        double available = extraWidth; \/\/ will be negative in shrinking case\n-        outer:while (Math.abs(available) > 1 && adjustingNumber > 0) {\n-            final double portion = snapPortionX(available \/ adjustingNumber); \/\/ negative in shrinking case\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                if (temp[i] == -1) {\n+    \/**\n+     * Resizes the children widths to fit the target width, while taking into account the resize limits\n+     * for each child (their minimum and maximum width). This method will be called once when shrinking,\n+     * and may be called twice when growing.\n+     *\n+     * @param managed the managed children\n+     * @param currentWidths the current children widths\n+     * @param limitWidths the max or min widths for each child, depending on whether we are growing or shrinking;\n+     *                    a value of -1 means the child cannot be resized\n+     * @param targetWidth sum of child widths and spacing\n+     * @param adjustingNumber a number that indicates how many children can be resized\n+     * @return {@code true} if the child widths were successfully resized to fit the target width;\n+     *         {@code false} otherwise\n+     *\/\n+    private boolean adjustWidthsWithinLimits(\n+            List<Node> managed, double[] currentWidths, double[] limitWidths, double targetWidth, int adjustingNumber) {\n+        double totalSpacing = (managed.size() - 1) * snapSpaceX(getSpacing());\n+\n+        \/\/ Current total width and current delta are two important numbers that we continuously\n+        \/\/ update as this method converges towards a solution.\n+        double currentTotalWidth = snapSpaceX(sum(currentWidths, managed.size())) + totalSpacing;\n+        double currentDelta = targetWidth - currentTotalWidth;\n+\n+        \/\/ We repeatedly apply the following algorithm as long as we have space left to\n+        \/\/ distribute (currentDelta), as well as children that are eligible to grow or\n+        \/\/ shrink (adjustingNumber).\n+        while ((currentDelta > Double.MIN_VALUE || currentDelta < -Double.MIN_VALUE) && adjustingNumber > 0) {\n+            \/\/ The amount of space that, in the ideal case, we need to add to or subtract from\n+            \/\/ each eligible child in order to fit the children into the target width.\n+            double idealChange = snapPortionX(currentDelta \/ adjustingNumber);\n+\n+            for (int i = managed.size() - 1; i >= 0; i--) {\n+                \/\/ If the child is not eligible for adjustment, skip it.\n+                if (limitWidths[i] == -1) {\n@@ -521,6 +593,20 @@\n-                final double limit = temp[i] - usedWidths[i]; \/\/ negative in shrinking case\n-                final double change = Math.abs(limit) <= Math.abs(portion)? limit : portion;\n-                usedWidths[i] += change;\n-                available -= change;\n-                if (Math.abs(available) < 1) {\n-                    break outer;\n+\n+                \/\/ The actual amount of space that we add to or remove from the child is restricted\n+                \/\/ by its minimum and maximum width.\n+                double maxChange = limitWidths[i] - currentWidths[i];\n+                double actualChange = currentDelta > 0 ? Math.min(maxChange, idealChange) : Math.max(maxChange, idealChange);\n+\n+                \/\/ Update the child width and snap the updated width to pixels in the horizontal direction.\n+                \/\/ Since snapping affects the total width, we need to recompute the current total width to\n+                \/\/ know how much space we have left to distribute.\n+                double oldWidth = currentWidths[i];\n+                currentWidths[i] = snapSizeX(oldWidth + actualChange);\n+                currentTotalWidth = snapSpaceX(currentTotalWidth + (currentWidths[i] - oldWidth));\n+\n+                \/\/ Update the amount of space we still need to grow or shrink (currentDelta) for the\n+                \/\/ remaining children. If we overshoot our target, we're done because we can't resize\n+                \/\/ any further.\n+                double newDelta = targetWidth - currentTotalWidth;\n+                if (Math.abs(newDelta) > Math.abs(currentDelta)) {\n+                    currentWidths[i] = oldWidth;\n+                    return true;\n@@ -528,2 +614,8 @@\n-                if (Math.abs(change) < Math.abs(portion)) {\n-                    temp[i] = -1;\n+\n+                currentDelta = newDelta;\n+\n+                \/\/ If the actual change for the current child was restricted (as evidenced by its smaller\n+                \/\/ magnitude when compared to the ideal change), we've reached the limit for this child and\n+                \/\/ need to exclude it from further consideration.\n+                if (Math.abs(actualChange) < Math.abs(idealChange)) {\n+                    limitWidths[i] = -1;\n@@ -535,1 +627,1 @@\n-        return available; \/\/ might be negative in shrinking case\n+        return false;\n@@ -538,0 +630,5 @@\n+    \/**\n+     * Calculates the preferred or minimum content width.\n+     * The content width is the total preferred or minimum width of all children,\n+     * including spacing between the children.\n+     *\/\n@@ -539,2 +636,3 @@\n-        return sum(getAreaWidths(managedChildren, height, minimum)[0], managedChildren.size())\n-                + (managedChildren.size()-1)*snapSpaceX(getSpacing());\n+        double[] childrenWidths = computeChildrenWidths(managedChildren, height, minimum)[0];\n+        return snapSpaceX(sum(childrenWidths, managedChildren.size())) +\n+               (managedChildren.size() - 1) * snapSpaceX(getSpacing());\n@@ -630,2 +728,2 @@\n-        final double[][] actualAreaWidths = getAreaWidths(managed, height, false);\n-        double contentWidth = adjustAreaWidths(managed, actualAreaWidths, width, height);\n+        final double[][] actualChildrenWidths = computeChildrenWidths(managed, height, false);\n+        double contentWidth = adjustChildrenWidths(managed, actualChildrenWidths, width, height);\n@@ -639,1 +737,1 @@\n-            baselineOffset = getAreaBaselineOffset(managed, marginAccessor, i -> actualAreaWidths[0][i],\n+            baselineOffset = getAreaBaselineOffset(managed, marginAccessor, i -> actualChildrenWidths[0][i],\n@@ -646,1 +744,1 @@\n-            layoutInArea(child, x, y, actualAreaWidths[0][i], contentHeight,\n+            layoutInArea(child, x, y, actualChildrenWidths[0][i], contentHeight,\n@@ -649,1 +747,1 @@\n-            x += actualAreaWidths[0][i] + space;\n+            x += actualChildrenWidths[0][i] + space;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HBox.java","additions":151,"deletions":53,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -2610,1 +2610,0 @@\n-\n@@ -2615,1 +2614,1 @@\n-                         snapSize(size.y, isSnapToPixel, snapScaleX));\n+                         snapSize(size.y, isSnapToPixel, snapScaleY));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,0 +153,1 @@\n+    private static final Priority[] GROW_PRIORITY = new Priority[] {Priority.ALWAYS, Priority.SOMETIMES};\n@@ -395,2 +396,2 @@\n-            double prefHeights[][] = getAreaHeights(managed, -1, false);\n-            adjustAreaHeights(managed, prefHeights, height, -1);\n+            double[][] prefHeights = computeChildrenHeights(managed, -1, false);\n+            adjustChildrenHeights(managed, prefHeights, height, -1);\n@@ -416,2 +417,2 @@\n-            double prefHeights[][] = getAreaHeights(managed, -1, false);\n-            adjustAreaHeights(managed, prefHeights, height, -1);\n+            double[][] prefHeights = computeChildrenHeights(managed, -1, false);\n+            adjustChildrenHeights(managed, prefHeights, height, -1);\n@@ -427,1 +428,1 @@\n-        double d = snapSpaceY(insets.getTop()) +\n+        return snapSpaceY(insets.getTop()) +\n@@ -430,1 +431,0 @@\n-        return d;\n@@ -433,2 +433,5 @@\n-\n-    private double[][] getAreaHeights(List<Node>managed, double width, boolean minimum) {\n+    \/**\n+     * Calculates the preferred or minimum height for each child.\n+     * The returned heights are snapped to pixels in the vertical direction.\n+     *\/\n+    private double[][] computeChildrenHeights(List<Node> managed, double width, boolean minimum) {\n@@ -460,1 +463,9 @@\n-    private double adjustAreaHeights(List<Node>managed, double areaHeights[][], double height, double width) {\n+    \/**\n+     * Adjusts the children heights (within their min-max limits) to fit the provided space.\n+     * This is necessary when the VBox is constrained to be larger or smaller than the combined preferred\n+     * heights of its children. In this case, we grow or shrink the children until they fit the VBox exactly.\n+     *\n+     * @return the pixel-snapped content height, which is the combined height\n+     *         of all children as well as the spacing between them\n+     *\/\n+    private double adjustChildrenHeights(List<Node> managed, double[][] childrenHeights, double height, double width) {\n@@ -465,3 +476,4 @@\n-        double contentHeight = sum(areaHeights[0], managed.size()) + (managed.size()-1)*snapSpaceY(getSpacing());\n-        double extraHeight = height -\n-                snapSpaceY(insets.getTop()) - snapSpaceY(insets.getBottom()) - contentHeight;\n+        double refWidth = isFillWidth() && width != -1 ? width - left - right : -1;\n+        double totalSpacing = (managed.size() - 1) * snapSpaceY(getSpacing());\n+        double contentHeight = snapSpaceY(sum(childrenHeights[0], managed.size())) + totalSpacing;\n+        double targetHeight = height - snapSpaceY(insets.getTop()) - snapSpaceY(insets.getBottom());\n@@ -469,5 +481,4 @@\n-        if (extraHeight != 0) {\n-            final double refWidth = isFillWidth()&& width != -1? width - left - right : -1;\n-            double remaining = growOrShrinkAreaHeights(managed, areaHeights, Priority.ALWAYS, extraHeight, refWidth);\n-            remaining = growOrShrinkAreaHeights(managed, areaHeights, Priority.SOMETIMES, remaining, refWidth);\n-            contentHeight += (extraHeight - remaining);\n+        if (contentHeight < targetHeight) {\n+            growChildrenHeights(managed, childrenHeights, targetHeight, refWidth);\n+        } else if (contentHeight > targetHeight) {\n+            shrinkChildrenHeights(managed, childrenHeights, targetHeight, refWidth);\n@@ -476,1 +487,1 @@\n-        return contentHeight;\n+        return snapSizeY(sum(childrenHeights[0], managed.size())) + totalSpacing;\n@@ -479,3 +490,7 @@\n-    private double growOrShrinkAreaHeights(List<Node>managed, double areaHeights[][], Priority priority, double extraHeight, double width) {\n-        final boolean shrinking = extraHeight < 0;\n-        int adjustingNumber = 0;\n+    \/**\n+     * Shrinks all children heights to fit the target height.\n+     * In contrast to growing, shrinking does not require two phases of processing.\n+     *\/\n+    private void shrinkChildrenHeights(List<Node> managed, double[][] childrenHeights, double targetHeight, double width) {\n+        double[] usedHeights = childrenHeights[0];\n+        double[] minHeights = childrenHeights[1];\n@@ -483,2 +498,20 @@\n-        double[] usedHeights = areaHeights[0];\n-        double[] temp = areaHeights[1];\n+        for (int i = 0, size = managed.size(); i < size; i++) {\n+            final Node child = managed.get(i);\n+            minHeights[i] = computeChildMinAreaHeight(child, -1, getMargin(child), width);\n+        }\n+\n+        adjustHeightsWithinLimits(managed, usedHeights, minHeights, targetHeight, managed.size());\n+    }\n+\n+    \/**\n+     * Grows all children heights to fit the target height.\n+     * Growing is a two-phase process: first, only children with {@link Priority#ALWAYS} are eligible\n+     * for adjustment. If the first adjustment didn't suffice to fit the target height, children with\n+     * {@link Priority#SOMETIMES} are also eligible for adjustment.\n+     *\/\n+    private void growChildrenHeights(List<Node> managed, double[][] childrenHeights, double targetHeight, double width) {\n+        double[] currentHeights = childrenHeights[0];\n+        double[] maxHeights = childrenHeights[1];\n+\n+        for (Priority priority : GROW_PRIORITY) {\n+            int adjustingNumber = 0;\n@@ -486,2 +519,0 @@\n-        if (shrinking) {\n-            adjustingNumber = managed.size();\n@@ -490,1 +521,10 @@\n-                temp[i] = computeChildMinAreaHeight(child, -1, getMargin(child), width);\n+\n+                \/\/ If the child is eligible to grow (as indicated by its vertical grow priority),\n+                \/\/ we count it towards the 'adjustingNumber', which represents the number of children\n+                \/\/ that can grow in this phase.\n+                if (getVgrow(child) == priority) {\n+                    maxHeights[i] = computeChildMaxAreaHeight(child, -1, getMargin(child), width);\n+                    ++adjustingNumber;\n+                } else {\n+                    maxHeights[i] = -1;\n+                }\n@@ -492,8 +532,5 @@\n-        } else {\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-            final Node child = managed.get(i);\n-            if (getVgrow(child) == priority) {\n-                temp[i] = computeChildMaxAreaHeight(child, -1, getMargin(child), width);\n-                adjustingNumber++;\n-            } else {\n-                temp[i] = -1;\n+\n+            \/\/ Adjust the children that are eligible in this phase and return early if the children\n+            \/\/ fit the target height (so no second phase is required).\n+            if (adjustHeightsWithinLimits(managed, currentHeights, maxHeights, targetHeight, adjustingNumber)) {\n+                return;\n@@ -502,1 +539,1 @@\n-        }\n+    }\n@@ -504,5 +541,34 @@\n-        double available = extraHeight; \/\/ will be negative in shrinking case\n-        outer: while (Math.abs(available) > 1 && adjustingNumber > 0) {\n-            final double portion = snapPortionY(available \/ adjustingNumber); \/\/ negative in shrinking case\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                if (temp[i] == -1) {\n+    \/**\n+     * Resizes the children heights to fit the target height, while taking into account the resize limits\n+     * for each child (their minimum and maximum height). This method will be called once when shrinking,\n+     * and may be called twice when growing.\n+     *\n+     * @param managed the managed children\n+     * @param currentHeights the current children heights\n+     * @param limitHeights the max or min heights for each child, depending on whether we are growing or shrinking;\n+     *                     a value of -1 means the child cannot be resized\n+     * @param targetHeight sum of children heights and spacing\n+     * @param adjustingNumber a number that indicates how many children can be resized\n+     * @return {@code true} if the children heights were successfully resized to fit the target height;\n+     *         {@code false} otherwise\n+     *\/\n+    private boolean adjustHeightsWithinLimits(\n+            List<Node> managed, double[] currentHeights, double[] limitHeights, double targetHeight, int adjustingNumber) {\n+        double totalSpacing = (managed.size() - 1) * snapSpaceY(getSpacing());\n+\n+        \/\/ Current total height and current delta are two important numbers that we continuously\n+        \/\/ update as this method converges towards a solution.\n+        double currentTotalHeight = snapSpaceY(sum(currentHeights, managed.size())) + totalSpacing;\n+        double currentDelta = targetHeight - currentTotalHeight;\n+\n+        \/\/ We repeatedly apply the following algorithm as long as we have space left to\n+        \/\/ distribute (currentDelta), as well as children that are eligible to grow or\n+        \/\/ shrink (adjustingNumber).\n+        while ((currentDelta > Double.MIN_VALUE || currentDelta < -Double.MIN_VALUE) && adjustingNumber > 0) {\n+            \/\/ The amount of space that, in the ideal case, we need to add to or subtract from\n+            \/\/ each eligible child in order to fit the children into the target height.\n+            double idealChange = snapPortionY(currentDelta \/ adjustingNumber);\n+\n+            for (int i = managed.size() - 1; i >= 0; i--) {\n+                \/\/ If the child is not eligible for adjustment, skip it.\n+                if (limitHeights[i] == -1) {\n@@ -511,6 +577,20 @@\n-                final double limit = temp[i] - usedHeights[i]; \/\/ negative in shrinking case\n-                final double change = Math.abs(limit) <= Math.abs(portion)? limit : portion;\n-                usedHeights[i] += change;\n-                available -= change;\n-                if (Math.abs(available) < 1) {\n-                    break outer;\n+\n+                \/\/ The actual amount of space that we add to or remove from the child is restricted\n+                \/\/ by its minimum and maximum height.\n+                double maxChange = limitHeights[i] - currentHeights[i];\n+                double actualChange = currentDelta > 0 ? Math.min(maxChange, idealChange) : Math.max(maxChange, idealChange);\n+\n+                \/\/ Update the child height and snap the updated height to pixels in the vertical direction.\n+                \/\/ Since snapping affects the total height, we need to recompute the current total height to\n+                \/\/ know how much space we have left to distribute.\n+                double oldHeight = currentHeights[i];\n+                currentHeights[i] = snapSizeY(oldHeight + actualChange);\n+                currentTotalHeight = snapSpaceY(currentTotalHeight + (currentHeights[i] - oldHeight));\n+\n+                \/\/ Update the amount of space we still need to grow or shrink (currentDelta) for the\n+                \/\/ remaining children. If we overshoot our target, we're done because we can't resize\n+                \/\/ any further.\n+                double newDelta = targetHeight - currentTotalHeight;\n+                if (Math.abs(newDelta) > Math.abs(currentDelta)) {\n+                    currentHeights[i] = oldHeight;\n+                    return true;\n@@ -518,2 +598,8 @@\n-                if (Math.abs(change) < Math.abs(portion)) {\n-                    temp[i] = -1;\n+\n+                currentDelta = newDelta;\n+\n+                \/\/ If the actual change for the current child was restricted (as evidenced by its smaller\n+                \/\/ magnitude when compared to the ideal change), we've reached the limit for this child and\n+                \/\/ need to exclude it from further consideration.\n+                if (Math.abs(actualChange) < Math.abs(idealChange)) {\n+                    limitHeights[i] = -1;\n@@ -525,1 +611,1 @@\n-        return available; \/\/ might be negative in shrinking case\n+        return false;\n@@ -528,0 +614,5 @@\n+    \/**\n+     * Calculates the preferred or minimum content height.\n+     * The content height is the total preferred or minimum height of all children,\n+     * including spacing between the children.\n+     *\/\n@@ -529,2 +620,3 @@\n-        return sum(getAreaHeights(managedChildren, width, minimum)[0], managedChildren.size())\n-                + (managedChildren.size()-1)*snapSpaceY(getSpacing());\n+        double[] childrenHeights = computeChildrenHeights(managedChildren, width, minimum)[0];\n+        return snapSpaceY(sum(childrenHeights, managedChildren.size())) +\n+               (managedChildren.size() - 1) * snapSpaceY(getSpacing());\n@@ -562,1 +654,1 @@\n-        double[][] actualAreaHeights = getAreaHeights(managed, width, false);\n+        double[][] actualChildrenHeights = computeChildrenHeights(managed, width, false);\n@@ -564,1 +656,1 @@\n-        double contentHeight = adjustAreaHeights(managed, actualAreaHeights, height, width);\n+        double contentHeight = adjustChildrenHeights(managed, actualChildrenHeights, height, width);\n@@ -571,2 +663,2 @@\n-            layoutInArea(child, x, y, contentWidth, actualAreaHeights[0][i],\n-                       \/* baseline shouldn't matter *\/actualAreaHeights[0][i],\n+            layoutInArea(child, x, y, contentWidth, actualChildrenHeights[0][i],\n+                       \/* baseline shouldn't matter *\/actualChildrenHeights[0][i],\n@@ -575,1 +667,1 @@\n-            y += actualAreaHeights[0][i] + space;\n+            y += actualChildrenHeights[0][i] + space;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/VBox.java","additions":149,"deletions":57,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Region;\n+import javafx.stage.Stage;\n@@ -908,0 +912,66 @@\n+    \/**\n+     * Given resizable children, the sum of child widths of a HBox must pixel-snap to the\n+     * same value as the width of the HBox itself, independent of render scale.\n+     *\n+     *                   (prefWidth=76.0)\n+     * ╔════════════════╤════════════════╤════════════════╗\n+     * ║ prefWidth=25.3 │ prefWidth=25.3 │ prefWidth=25.4 ║\n+     * ╚════════════════╧════════════════╧════════════════╝\n+     *\/\n+    @Test public void testPixelSnappedContentWidthIsSameAsBoxWidth() {\n+        class testPixelSnapConfig {\n+            final double expectedWidth;\n+            final double scale;\n+            final boolean specifyContainerPrefWidth;\n+\n+            testPixelSnapConfig(double expectedWidth, double scale, boolean specifyContainerPrefWidth) {\n+                this.expectedWidth = expectedWidth;\n+                this.scale = scale;\n+                this.specifyContainerPrefWidth = specifyContainerPrefWidth;\n+            }\n+        }\n+\n+        for (testPixelSnapConfig config : new testPixelSnapConfig[] {\n+            \/\/ For these tests, HBox.prefWidth is specified, so we expect the final width to be exactly that.\n+            \/\/ Child widths will be adjusted appropriately such that the sum of child widths corresponds to HBox.prefWidth.\n+            new testPixelSnapConfig(76.0, 1.0, true),\n+            new testPixelSnapConfig(76.0, 1.25, true),\n+            new testPixelSnapConfig(76.0, 1.5, true),\n+            new testPixelSnapConfig(76.0, 1.75, true),\n+            new testPixelSnapConfig(76.0, 2.0, true),\n+            new testPixelSnapConfig(76.0, 2.25, true),\n+            new testPixelSnapConfig(76.0, 2.5, true),\n+\n+            \/\/ For these tests, HBox.prefWidth is not specified, which means that child widths will not be adjusted.\n+            \/\/ The final width will snap slightly differently for each configuration.\n+            new testPixelSnapConfig(78.0, 1.0, false),\n+            new testPixelSnapConfig(76.8, 1.25, false),\n+            new testPixelSnapConfig(76.66666666666667, 1.5, false),\n+            new testPixelSnapConfig(77.14285714285714, 1.75, false),\n+            new testPixelSnapConfig(76.5, 2.0, false),\n+            new testPixelSnapConfig(76.44444444444444, 2.25, false),\n+            new testPixelSnapConfig(76.8, 2.5, false),\n+        }) {\n+            Region r1 = new Region(); r1.setPrefWidth(25.3);\n+            Region r2 = new Region(); r2.setPrefWidth(25.3);\n+            Region r3 = new Region(); r3.setPrefWidth(25.4);\n+            HBox box = new HBox(r1, r2, r3);\n+            box.setSnapToPixel(true);\n+\n+            if (config.specifyContainerPrefWidth) {\n+                box.setPrefWidth(76.0);\n+            }\n+\n+            SimpleDoubleProperty renderScale = new SimpleDoubleProperty(config.scale);\n+            Stage stage = new Stage();\n+            stage.renderScaleXProperty().bind(renderScale);\n+            stage.renderScaleYProperty().bind(renderScale);\n+            stage.setScene(new Scene(new HBox(box)));\n+            stage.show();\n+\n+            assertEquals(config.expectedWidth, box.getWidth(), 10e-14);\n+            assertEquals(config.expectedWidth, r1.getWidth() + r2.getWidth() + r3.getWidth(), 10e-14);\n+            stage.close();\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HBoxTest.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,5 @@\n-import test.javafx.scene.layout.MockBiased;\n-import test.javafx.scene.layout.MockRegion;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Region;\n+import javafx.stage.Stage;\n+\n@@ -786,0 +789,71 @@\n+\n+    \/**\n+     * Given resizable children, the sum of child heights of a VBox must pixel-snap to the\n+     * same value as the height of the VBox itself, independent of render scale.\n+     *\n+     *   (prefHeight=76.0)\n+     * ╔═══════════════════╗\n+     * ║  prefHeight=25.3  ║\n+     * ╟───────────────────╢\n+     * ║  prefHeight=25.3  ║\n+     * ╟───────────────────╢\n+     * ║  prefHeight=25.4  ║\n+     * ╚═══════════════════╝\n+     *\/\n+    @Test public void testPixelSnappedContentHeightIsSameAsBoxHeight() {\n+        class testPixelSnapConfig {\n+            final double expectedHeight;\n+            final double scale;\n+            final boolean specifyContainerPrefHeight;\n+\n+            testPixelSnapConfig(double expectedHeight, double scale, boolean specifyContainerPrefHeight) {\n+                this.expectedHeight = expectedHeight;\n+                this.scale = scale;\n+                this.specifyContainerPrefHeight = specifyContainerPrefHeight;\n+            }\n+        }\n+\n+        for (testPixelSnapConfig config : new testPixelSnapConfig[] {\n+            \/\/ For these tests, VBox.prefHeight is specified, so we expect the final height to be exactly that.\n+            \/\/ Child heights will be adjusted appropriately such that the sum of child widths corresponds to VBox.prefHeight.\n+            new testPixelSnapConfig(76.0, 1.0, true),\n+            new testPixelSnapConfig(76.0, 1.25, true),\n+            new testPixelSnapConfig(76.0, 1.5, true),\n+            new testPixelSnapConfig(76.0, 1.75, true),\n+            new testPixelSnapConfig(76.0, 2.0, true),\n+            new testPixelSnapConfig(76.0, 2.25, true),\n+            new testPixelSnapConfig(76.0, 2.5, true),\n+\n+            \/\/ For these tests, VBox.prefHeight is not specified, which means that child heights will not be adjusted.\n+            \/\/ The final height will snap slightly differently for each configuration.\n+            new testPixelSnapConfig(78.0, 1.0, false),\n+            new testPixelSnapConfig(76.8, 1.25, false),\n+            new testPixelSnapConfig(76.66666666666667, 1.5, false),\n+            new testPixelSnapConfig(77.14285714285714, 1.75, false),\n+            new testPixelSnapConfig(76.5, 2.0, false),\n+            new testPixelSnapConfig(76.44444444444444, 2.25, false),\n+            new testPixelSnapConfig(76.8, 2.5, false),\n+        }) {\n+            Region r1 = new Region(); r1.setPrefHeight(25.3);\n+            Region r2 = new Region(); r2.setPrefHeight(25.3);\n+            Region r3 = new Region(); r3.setPrefHeight(25.4);\n+            VBox box = new VBox(r1, r2, r3);\n+            box.setSnapToPixel(true);\n+\n+            if (config.specifyContainerPrefHeight) {\n+                box.setPrefHeight(76.0);\n+            }\n+\n+            SimpleDoubleProperty renderScale = new SimpleDoubleProperty(config.scale);\n+            Stage stage = new Stage();\n+            stage.renderScaleXProperty().bind(renderScale);\n+            stage.renderScaleYProperty().bind(renderScale);\n+            stage.setScene(new Scene(new VBox(box)));\n+            stage.show();\n+\n+            assertEquals(config.expectedHeight, box.getHeight(), 10e-14);\n+            assertEquals(config.expectedHeight, r1.getHeight() + r2.getHeight() + r3.getHeight(), 10e-14);\n+            stage.close();\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/VBoxTest.java","additions":77,"deletions":3,"binary":false,"changes":80,"status":"modified"}]}