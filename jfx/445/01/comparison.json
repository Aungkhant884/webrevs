{"files":[{"patch":"@@ -164,0 +164,1 @@\n+    private static final Priority[] GROW_PRIORITY = new Priority[] {Priority.ALWAYS, Priority.SOMETIMES};\n@@ -418,2 +419,2 @@\n-            double prefWidths[][] = getAreaWidths(managed, -1, false);\n-            adjustAreaWidths(managed, prefWidths, width, -1);\n+            double[][] prefWidths = getChildrenWidths(managed, -1, false);\n+            adjustChildrenWidths(managed, prefWidths, width, -1);\n@@ -441,2 +442,2 @@\n-            double prefWidths[][] = getAreaWidths(managed, -1, false);\n-            adjustAreaWidths(managed, prefWidths, width, -1);\n+            double[][] prefWidths = getChildrenWidths(managed, -1, false);\n+            adjustChildrenWidths(managed, prefWidths, width, -1);\n@@ -452,1 +453,4 @@\n-    private double[][] getAreaWidths(List<Node>managed, double height, boolean minimum) {\n+    \/**\n+     * Calculates the preferred or minimum width for each child.\n+     *\/\n+    private double[][] getChildrenWidths(List<Node> managed, double height, boolean minimum) {\n@@ -470,1 +474,7 @@\n-    private double adjustAreaWidths(List<Node>managed, double areaWidths[][], double width, double height) {\n+    \/**\n+     * Adjusts the children widths to fit the provided space.\n+     * This might be necessary because the HBox is size-constrained and cannot accommodate the preferred\n+     * widths for all children, or it might be necessary because the HBox is sized to be larger than the\n+     * preferred widths of its children and needs to grow its children to fit its size.\n+     *\/\n+    private double adjustChildrenWidths(List<Node> managed, double[][] childrenWidths, double width, double height) {\n@@ -475,3 +485,4 @@\n-        double contentWidth = sum(areaWidths[0], managed.size()) + (managed.size()-1)*snapSpaceX(getSpacing());\n-        double extraWidth = width -\n-                snapSpaceX(insets.getLeft()) - snapSpaceX(insets.getRight()) - contentWidth;\n+        double refHeight = shouldFillHeight() && height != -1 ? height - top - bottom : -1;\n+        double totalSpacing = (managed.size() - 1) * snapSpaceX(getSpacing());\n+        double contentWidth = snappedSum(childrenWidths[0], managed.size()) + totalSpacing;\n+        double targetWidth = width - snapSpaceX(insets.getLeft()) - snapSpaceX(insets.getRight());\n@@ -479,5 +490,4 @@\n-        if (extraWidth != 0) {\n-            final double refHeight = shouldFillHeight() && height != -1? height - top - bottom : -1;\n-            double remaining = growOrShrinkAreaWidths(managed, areaWidths, Priority.ALWAYS, extraWidth, refHeight);\n-            remaining = growOrShrinkAreaWidths(managed, areaWidths, Priority.SOMETIMES, remaining, refHeight);\n-            contentWidth += (extraWidth - remaining);\n+        if (contentWidth < targetWidth) {\n+            growChildrenWidths(managed, childrenWidths, targetWidth, refHeight);\n+        } else if (contentWidth > targetWidth) {\n+            shrinkChildrenWidths(managed, childrenWidths, targetWidth, refHeight);\n@@ -485,1 +495,2 @@\n-        return contentWidth;\n+\n+        return snappedSum(childrenWidths[0], managed.size()) + totalSpacing;\n@@ -488,3 +499,8 @@\n-    private double growOrShrinkAreaWidths(List<Node>managed, double areaWidths[][], Priority priority, double extraWidth, double height) {\n-        final boolean shrinking = extraWidth < 0;\n-        int adjustingNumber = 0;\n+    \/**\n+     * Shrinks all children widths to fit the target width.\n+     * Shrinking is a one-step process: all children are eligible to be adjusted down to their minimum width.\n+     *\/\n+    private void shrinkChildrenWidths(List<Node> managed, double[][] childrenWidths, double targetWidth, double height) {\n+        double[] usedWidths = childrenWidths[0];\n+        double[] minWidths = childrenWidths[1];\n+        boolean shouldFillHeight = shouldFillHeight();\n@@ -492,3 +508,22 @@\n-        double[] usedWidths = areaWidths[0];\n-        double[] temp = areaWidths[1];\n-        final boolean shouldFillHeight = shouldFillHeight();\n+        for (int i = 0, size = managed.size(); i < size; i++) {\n+            final Node child = managed.get(i);\n+            minWidths[i] = computeChildMinAreaWidth(\n+                child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n+        }\n+\n+        adjustWidthsWithinLimits(managed, usedWidths, minWidths, targetWidth, managed.size());\n+    }\n+\n+    \/**\n+     * Grows all children widths to fit the target width.\n+     * Growing is a two-step process: first, only children with {@link Priority#ALWAYS} are eligible\n+     * for adjustment. If the first adjustment didn't suffice to fit the target width, children with\n+     * {@link Priority#SOMETIMES} are also eligible for adjustment.\n+     *\/\n+    private void growChildrenWidths(List<Node> managed, double[][] childrenWidths, double targetWidth, double height) {\n+        double[] currentWidths = childrenWidths[0];\n+        double[] maxWidths = childrenWidths[1];\n+        boolean shouldFillHeight = shouldFillHeight();\n+\n+        for (Priority priority : GROW_PRIORITY) {\n+            int adjustingNumber = 0;\n@@ -496,7 +531,0 @@\n-        if (shrinking) {\n-            adjustingNumber = managed.size();\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                final Node child = managed.get(i);\n-                temp[i] = computeChildMinAreaWidth(child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n-            }\n-        } else {\n@@ -506,2 +534,3 @@\n-                    temp[i] = computeChildMaxAreaWidth(child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n-                    adjustingNumber++;\n+                    maxWidths[i] = computeChildMaxAreaWidth(\n+                        child, getMinBaselineComplement(), getMargin(child), height, shouldFillHeight);\n+                    ++adjustingNumber;\n@@ -509,1 +538,1 @@\n-                    temp[i] = -1;\n+                    maxWidths[i] = -1;\n@@ -512,0 +541,4 @@\n+\n+            if (adjustWidthsWithinLimits(managed, currentWidths, maxWidths, targetWidth, adjustingNumber)) {\n+                return;\n+            }\n@@ -513,0 +546,1 @@\n+    }\n@@ -514,5 +548,25 @@\n-        double available = extraWidth; \/\/ will be negative in shrinking case\n-        outer:while (Math.abs(available) > 1 && adjustingNumber > 0) {\n-            final double portion = snapPortionX(available \/ adjustingNumber); \/\/ negative in shrinking case\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                if (temp[i] == -1) {\n+    \/**\n+     * Resizes the children widths to fit the target width, while taking into account the resize limits\n+     * for each child (their minimum and maximum width). This method will be called once when shrinking,\n+     * and may be called twice when growing.\n+     *\n+     * @param managed the managed children\n+     * @param currentWidths the current children widths\n+     * @param limitWidths the max or min widths for each child, depending on whether we are growing or shrinking;\n+     *                    a value of -1 means the child cannot be resized\n+     * @param targetWidth the target width (sum of child widths and spacing)\n+     * @param adjustingNumber a number that indicates how many children can be resized\n+     * @return {@code true} if the child widths were successfully resized to fit the target width;\n+     *         {@code false} otherwise\n+     *\/\n+    private boolean adjustWidthsWithinLimits(\n+            List<Node> managed, double[] currentWidths, double[] limitWidths, double targetWidth, int adjustingNumber) {\n+        double totalSpacing = (managed.size() - 1) * snapSpaceX(getSpacing());\n+        double currentTotalWidth = snappedSum(currentWidths, managed.size()) + totalSpacing;\n+        double currentDelta = targetWidth - currentTotalWidth;\n+\n+        while ((currentDelta > Double.MIN_VALUE || currentDelta < -Double.MIN_VALUE) && adjustingNumber > 0) {\n+            double portion = snapPortionX(currentDelta \/ adjustingNumber);\n+\n+            for (int i = managed.size() - 1; i >= 0; i--) {\n+                if (limitWidths[i] == -1) {\n@@ -521,6 +575,12 @@\n-                final double limit = temp[i] - usedWidths[i]; \/\/ negative in shrinking case\n-                final double change = Math.abs(limit) <= Math.abs(portion)? limit : portion;\n-                usedWidths[i] += change;\n-                available -= change;\n-                if (Math.abs(available) < 1) {\n-                    break outer;\n+\n+                double maxChange = limitWidths[i] - currentWidths[i];\n+                double change = currentDelta > 0 ? Math.min(maxChange, portion) : Math.max(maxChange, portion);\n+                double oldWidth = currentWidths[i];\n+\n+                currentWidths[i] = snapSizeX(currentWidths[i] + change);\n+                currentTotalWidth = snappedSum(currentWidths, managed.size()) + totalSpacing;\n+\n+                double newDelta = targetWidth - currentTotalWidth;\n+                if (Math.abs(newDelta) > Math.abs(currentDelta)) {\n+                    currentWidths[i] = oldWidth;\n+                    return true;\n@@ -528,0 +588,3 @@\n+\n+                currentDelta = newDelta;\n+\n@@ -529,1 +592,1 @@\n-                    temp[i] = -1;\n+                    limitWidths[i] = -1;\n@@ -535,1 +598,1 @@\n-        return available; \/\/ might be negative in shrinking case\n+        return false;\n@@ -538,0 +601,5 @@\n+    \/**\n+     * Calculates the preferred or minimum content width.\n+     * The content width is the total preferred or minimum width of all children,\n+     * including spacing between the children.\n+     *\/\n@@ -539,1 +607,1 @@\n-        return sum(getAreaWidths(managedChildren, height, minimum)[0], managedChildren.size())\n+        return snappedSum(getChildrenWidths(managedChildren, height, minimum)[0], managedChildren.size())\n@@ -543,2 +611,1 @@\n-    private static double sum(double[] array, int size) {\n-        int i = 0;\n+    private double snappedSum(double[] array, int size) {\n@@ -546,2 +613,2 @@\n-        while (i != size) {\n-            res += array[i++];\n+        for (int i = 0; i < size; ++i) {\n+            res += array[i];\n@@ -549,1 +616,1 @@\n-        return res;\n+        return snapSpaceX(res);\n@@ -630,2 +697,2 @@\n-        final double[][] actualAreaWidths = getAreaWidths(managed, height, false);\n-        double contentWidth = adjustAreaWidths(managed, actualAreaWidths, width, height);\n+        final double[][] actualChildrenWidths = getChildrenWidths(managed, height, false);\n+        double contentWidth = adjustChildrenWidths(managed, actualChildrenWidths, width, height);\n@@ -639,1 +706,1 @@\n-            baselineOffset = getAreaBaselineOffset(managed, marginAccessor, i -> actualAreaWidths[0][i],\n+            baselineOffset = getAreaBaselineOffset(managed, marginAccessor, i -> actualChildrenWidths[0][i],\n@@ -646,1 +713,1 @@\n-            layoutInArea(child, x, y, actualAreaWidths[0][i], contentHeight,\n+            layoutInArea(child, x, y, actualChildrenWidths[0][i], contentHeight,\n@@ -649,1 +716,1 @@\n-            x += actualAreaWidths[0][i] + space;\n+            x += actualChildrenWidths[0][i] + space;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HBox.java","additions":122,"deletions":55,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2610,1 +2610,0 @@\n-\n@@ -2615,1 +2614,1 @@\n-                         snapSize(size.y, isSnapToPixel, snapScaleX));\n+                         snapSize(size.y, isSnapToPixel, snapScaleY));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+    private static final Priority[] GROW_PRIORITY = new Priority[] {Priority.ALWAYS, Priority.SOMETIMES};\n@@ -395,2 +396,2 @@\n-            double prefHeights[][] = getAreaHeights(managed, -1, false);\n-            adjustAreaHeights(managed, prefHeights, height, -1);\n+            double[][] prefHeights = getChildrenHeights(managed, -1, false);\n+            adjustChildrenHeights(managed, prefHeights, height, -1);\n@@ -416,2 +417,2 @@\n-            double prefHeights[][] = getAreaHeights(managed, -1, false);\n-            adjustAreaHeights(managed, prefHeights, height, -1);\n+            double[][] prefHeights = getChildrenHeights(managed, -1, false);\n+            adjustChildrenHeights(managed, prefHeights, height, -1);\n@@ -427,1 +428,1 @@\n-        double d = snapSpaceY(insets.getTop()) +\n+        return snapSpaceY(insets.getTop()) +\n@@ -430,1 +431,0 @@\n-        return d;\n@@ -433,2 +433,4 @@\n-\n-    private double[][] getAreaHeights(List<Node>managed, double width, boolean minimum) {\n+    \/**\n+     * Calculates the preferred or minimum height for each child.\n+     *\/\n+    private double[][] getChildrenHeights(List<Node> managed, double width, boolean minimum) {\n@@ -460,1 +462,7 @@\n-    private double adjustAreaHeights(List<Node>managed, double areaHeights[][], double height, double width) {\n+    \/**\n+     * Adjusts the children heights to fit the provided space.\n+     * This might be necessary because the HBox is size-constrained and cannot accommodate the preferred\n+     * heights for all children, or it might be necessary because the HBox is sized to be larger than the\n+     * preferred heights of its children and needs to grow its children to fit its size.\n+     *\/\n+    private double adjustChildrenHeights(List<Node> managed, double[][] childrenHeights, double height, double width) {\n@@ -465,3 +473,21 @@\n-        double contentHeight = sum(areaHeights[0], managed.size()) + (managed.size()-1)*snapSpaceY(getSpacing());\n-        double extraHeight = height -\n-                snapSpaceY(insets.getTop()) - snapSpaceY(insets.getBottom()) - contentHeight;\n+        double refWidth = isFillWidth() && width != -1 ? width - left - right : -1;\n+        double totalSpacing = (managed.size() - 1) * snapSpaceY(getSpacing());\n+        double contentHeight = snappedSum(childrenHeights[0], managed.size()) + totalSpacing;\n+        double targetHeight = height - snapSpaceY(insets.getTop()) - snapSpaceY(insets.getBottom());\n+\n+        if (contentHeight < targetHeight) {\n+            growChildrenHeights(managed, childrenHeights, targetHeight, refWidth);\n+        } else if (contentHeight > targetHeight) {\n+            shrinkChildrenHeights(managed, childrenHeights, targetHeight, refWidth);\n+        }\n+\n+        return snappedSum(childrenHeights[0], managed.size()) + totalSpacing;\n+    }\n+\n+    \/**\n+     * Shrinks all children heights to fit the target height.\n+     * Shrinking is a one-step process: all children are eligible to be adjusted down to their minimum height.\n+     *\/\n+    private void shrinkChildrenHeights(List<Node> managed, double[][] childrenHeights, double targetHeight, double width) {\n+        double[] usedHeights = childrenHeights[0];\n+        double[] minHeights = childrenHeights[1];\n@@ -469,5 +495,3 @@\n-        if (extraHeight != 0) {\n-            final double refWidth = isFillWidth()&& width != -1? width - left - right : -1;\n-            double remaining = growOrShrinkAreaHeights(managed, areaHeights, Priority.ALWAYS, extraHeight, refWidth);\n-            remaining = growOrShrinkAreaHeights(managed, areaHeights, Priority.SOMETIMES, remaining, refWidth);\n-            contentHeight += (extraHeight - remaining);\n+        for (int i = 0, size = managed.size(); i < size; i++) {\n+            final Node child = managed.get(i);\n+            minHeights[i] = computeChildMinAreaHeight(child, -1, getMargin(child), width);\n@@ -476,1 +500,1 @@\n-        return contentHeight;\n+        adjustHeightsWithinLimits(managed, usedHeights, minHeights, targetHeight, managed.size());\n@@ -479,3 +503,9 @@\n-    private double growOrShrinkAreaHeights(List<Node>managed, double areaHeights[][], Priority priority, double extraHeight, double width) {\n-        final boolean shrinking = extraHeight < 0;\n-        int adjustingNumber = 0;\n+    \/**\n+     * Grows all children heights to fit the target height.\n+     * Growing is a two-step process: first, only children with {@link Priority#ALWAYS} are eligible\n+     * for adjustment. If the first adjustment didn't suffice to fit the target height, children with\n+     * {@link Priority#SOMETIMES} are also eligible for adjustment.\n+     *\/\n+    private void growChildrenHeights(List<Node> managed, double[][] childrenHeights, double targetHeight, double width) {\n+        double[] currentHeights = childrenHeights[0];\n+        double[] maxHeights = childrenHeights[1];\n@@ -483,2 +513,2 @@\n-        double[] usedHeights = areaHeights[0];\n-        double[] temp = areaHeights[1];\n+        for (Priority priority : GROW_PRIORITY) {\n+            int adjustingNumber = 0;\n@@ -486,2 +516,0 @@\n-        if (shrinking) {\n-            adjustingNumber = managed.size();\n@@ -490,1 +518,6 @@\n-                temp[i] = computeChildMinAreaHeight(child, -1, getMargin(child), width);\n+                if (getVgrow(child) == priority) {\n+                    maxHeights[i] = computeChildMaxAreaHeight(child, -1, getMargin(child), width);\n+                    ++adjustingNumber;\n+                } else {\n+                    maxHeights[i] = -1;\n+                }\n@@ -492,8 +525,3 @@\n-        } else {\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-            final Node child = managed.get(i);\n-            if (getVgrow(child) == priority) {\n-                temp[i] = computeChildMaxAreaHeight(child, -1, getMargin(child), width);\n-                adjustingNumber++;\n-            } else {\n-                temp[i] = -1;\n+\n+            if (adjustHeightsWithinLimits(managed, currentHeights, maxHeights, targetHeight, adjustingNumber)) {\n+                return;\n@@ -502,1 +530,1 @@\n-        }\n+    }\n@@ -504,5 +532,25 @@\n-        double available = extraHeight; \/\/ will be negative in shrinking case\n-        outer: while (Math.abs(available) > 1 && adjustingNumber > 0) {\n-            final double portion = snapPortionY(available \/ adjustingNumber); \/\/ negative in shrinking case\n-            for (int i = 0, size = managed.size(); i < size; i++) {\n-                if (temp[i] == -1) {\n+    \/**\n+     * Resizes the children heights to fit the target height, while taking into account the resize limits\n+     * for each child (their minimum and maximum width). This method will be called once when shrinking,\n+     * and may be called twice when growing.\n+     *\n+     * @param managed the managed children\n+     * @param currentHeights the current children heights\n+     * @param limitHeights the max or min heights for each child, depending on whether we are growing or shrinking;\n+     *                    a value of -1 means the child cannot be resized\n+     * @param targetHeight the target height (sum of children heights and spacing)\n+     * @param adjustingNumber a number that indicates how many children can be resized\n+     * @return {@code true} if the children heights were successfully resized to fit the target height;\n+     *         {@code false} otherwise\n+     *\/\n+    private boolean adjustHeightsWithinLimits(\n+            List<Node> managed, double[] currentHeights, double[] limitHeights, double targetHeight, int adjustingNumber) {\n+        double totalSpacing = (managed.size() - 1) * snapSpaceY(getSpacing());\n+        double currentTotalHeight = snappedSum(currentHeights, managed.size()) + totalSpacing;\n+        double currentDelta = targetHeight - currentTotalHeight;\n+\n+        while ((currentDelta > Double.MIN_VALUE || currentDelta < -Double.MIN_VALUE) && adjustingNumber > 0) {\n+            double portion = snapPortionY(currentDelta \/ adjustingNumber);\n+\n+            for (int i = managed.size() - 1; i >= 0; i--) {\n+                if (limitHeights[i] == -1) {\n@@ -511,6 +559,12 @@\n-                final double limit = temp[i] - usedHeights[i]; \/\/ negative in shrinking case\n-                final double change = Math.abs(limit) <= Math.abs(portion)? limit : portion;\n-                usedHeights[i] += change;\n-                available -= change;\n-                if (Math.abs(available) < 1) {\n-                    break outer;\n+\n+                double maxChange = limitHeights[i] - currentHeights[i];\n+                double change = currentDelta > 0 ? Math.min(maxChange, portion) : Math.max(maxChange, portion);\n+                double oldHeight = currentHeights[i];\n+\n+                currentHeights[i] = snapSizeY(currentHeights[i] + change);\n+                currentTotalHeight = snappedSum(currentHeights, managed.size()) + totalSpacing;\n+\n+                double newDelta = targetHeight - currentTotalHeight;\n+                if (Math.abs(newDelta) > Math.abs(currentDelta)) {\n+                    currentHeights[i] = oldHeight;\n+                    return true;\n@@ -518,0 +572,3 @@\n+\n+                currentDelta = newDelta;\n+\n@@ -519,1 +576,1 @@\n-                    temp[i] = -1;\n+                    limitHeights[i] = -1;\n@@ -525,1 +582,1 @@\n-        return available; \/\/ might be negative in shrinking case\n+        return false;\n@@ -528,0 +585,5 @@\n+    \/**\n+     * Calculates the preferred or minimum content height.\n+     * The content height is the total preferred or minimum height of all children,\n+     * including spacing between the children.\n+     *\/\n@@ -529,1 +591,1 @@\n-        return sum(getAreaHeights(managedChildren, width, minimum)[0], managedChildren.size())\n+        return snappedSum(getChildrenHeights(managedChildren, width, minimum)[0], managedChildren.size())\n@@ -533,2 +595,1 @@\n-    private static double sum(double[] array, int size) {\n-        int i = 0;\n+    private double snappedSum(double[] array, int size) {\n@@ -536,2 +597,2 @@\n-        while (i != size) {\n-            res += array[i++];\n+        for (int i = 0; i < size; ++i) {\n+            res += array[i];\n@@ -539,1 +600,1 @@\n-        return res;\n+        return snapSpaceY(res);\n@@ -562,1 +623,1 @@\n-        double[][] actualAreaHeights = getAreaHeights(managed, width, false);\n+        double[][] actualChildrenHeights = getChildrenHeights(managed, width, false);\n@@ -564,1 +625,1 @@\n-        double contentHeight = adjustAreaHeights(managed, actualAreaHeights, height, width);\n+        double contentHeight = adjustChildrenHeights(managed, actualChildrenHeights, height, width);\n@@ -571,2 +632,2 @@\n-            layoutInArea(child, x, y, contentWidth, actualAreaHeights[0][i],\n-                       \/* baseline shouldn't matter *\/actualAreaHeights[0][i],\n+            layoutInArea(child, x, y, contentWidth, actualChildrenHeights[0][i],\n+                       \/* baseline shouldn't matter *\/actualChildrenHeights[0][i],\n@@ -575,1 +636,1 @@\n-            y += actualAreaHeights[0][i] + space;\n+            y += actualChildrenHeights[0][i] + space;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/VBox.java","additions":120,"deletions":59,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Region;\n+import javafx.stage.Stage;\n@@ -908,0 +912,66 @@\n+    \/**\n+     * Given resizable children, the sum of child widths of a HBox must pixel-snap to the\n+     * same value as the width of the HBox itself, independent of render scale.\n+     *\n+     *                   (prefWidth=76.0)\n+     * ╔════════════════╤════════════════╤════════════════╗\n+     * ║ prefWidth=25.3 │ prefWidth=25.3 │ prefWidth=25.4 ║\n+     * ╚════════════════╧════════════════╧════════════════╝\n+     *\/\n+    @Test public void testPixelSnappedContentWidthIsSameAsBoxWidth() {\n+        for (testPixelSnapConfig config : new testPixelSnapConfig[] {\n+            \/\/ For these tests, HBox.prefWidth is specified, so we expect the final width to be exactly that.\n+            \/\/ Child widths will be adjusted appropriately such that the sum of child widths corresponds to HBox.prefWidth.\n+            new testPixelSnapConfig(76.0, 1.0, true),\n+            new testPixelSnapConfig(76.0, 1.25, true),\n+            new testPixelSnapConfig(76.0, 1.5, true),\n+            new testPixelSnapConfig(76.0, 1.75, true),\n+            new testPixelSnapConfig(76.0, 2.0, true),\n+            new testPixelSnapConfig(76.0, 2.25, true),\n+            new testPixelSnapConfig(76.0, 2.5, true),\n+\n+            \/\/ For these tests, HBox.prefWidth is not specified, which means that child widths will not be adjusted.\n+            \/\/ The final width will snap slightly differently for each configuration.\n+            new testPixelSnapConfig(78.0, 1.0, false),\n+            new testPixelSnapConfig(76.8, 1.25, false),\n+            new testPixelSnapConfig(76.66666666666667, 1.5, false),\n+            new testPixelSnapConfig(77.14285714285714, 1.75, false),\n+            new testPixelSnapConfig(76.5, 2.0, false),\n+            new testPixelSnapConfig(76.44444444444444, 2.25, false),\n+            new testPixelSnapConfig(76.8, 2.5, false),\n+        }) {\n+            Region r1 = new Region(); r1.setPrefWidth(25.3);\n+            Region r2 = new Region(); r2.setPrefWidth(25.3);\n+            Region r3 = new Region(); r3.setPrefWidth(25.4);\n+            HBox box = new HBox(r1, r2, r3);\n+            box.setSnapToPixel(true);\n+\n+            if (config.specifyContainerPrefWidth) {\n+                box.setPrefWidth(76.0);\n+            }\n+\n+            SimpleDoubleProperty renderScale = new SimpleDoubleProperty(config.scale);\n+            Stage stage = new Stage();\n+            stage.renderScaleXProperty().bind(renderScale);\n+            stage.renderScaleYProperty().bind(renderScale);\n+            stage.setScene(new Scene(new HBox(box)));\n+            stage.show();\n+\n+            assertEquals(config.expectedWidth, box.getWidth(), 10e-14);\n+            assertEquals(config.expectedWidth, r1.getWidth() + r2.getWidth() + r3.getWidth(), 10e-14);\n+            stage.close();\n+        }\n+    }\n+\n+    private static class testPixelSnapConfig {\n+        final double expectedWidth;\n+        final double scale;\n+        final boolean specifyContainerPrefWidth;\n+\n+        testPixelSnapConfig(double expectedWidth, double scale, boolean specifyContainerPrefWidth) {\n+            this.expectedWidth = expectedWidth;\n+            this.scale = scale;\n+            this.specifyContainerPrefWidth = specifyContainerPrefWidth;\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HBoxTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -28,2 +28,5 @@\n-import test.javafx.scene.layout.MockBiased;\n-import test.javafx.scene.layout.MockRegion;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Region;\n+import javafx.stage.Stage;\n+\n@@ -786,0 +789,70 @@\n+\n+    \/**\n+     * Given resizable children, the sum of child heights of a VBox must pixel-snap to the\n+     * same value as the height of the VBox itself, independent of render scale.\n+     *\n+     *   (prefHeight=76.0)\n+     * ╔═══════════════════╗\n+     * ║  prefHeight=25.3  ║\n+     * ╟───────────────────╢\n+     * ║  prefHeight=25.3  ║\n+     * ╟───────────────────╢\n+     * ║  prefHeight=25.4  ║\n+     * ╚═══════════════════╝\n+     *\/\n+    @Test public void testPixelSnappedContentHeightIsSameAsBoxHeight() {\n+        for (testPixelSnapConfig config : new testPixelSnapConfig[] {\n+            \/\/ For these tests, VBox.prefHeight is specified, so we expect the final height to be exactly that.\n+            \/\/ Child heights will be adjusted appropriately such that the sum of child widths corresponds to VBox.prefHeight.\n+            new testPixelSnapConfig(76.0, 1.0, true),\n+            new testPixelSnapConfig(76.0, 1.25, true),\n+            new testPixelSnapConfig(76.0, 1.5, true),\n+            new testPixelSnapConfig(76.0, 1.75, true),\n+            new testPixelSnapConfig(76.0, 2.0, true),\n+            new testPixelSnapConfig(76.0, 2.25, true),\n+            new testPixelSnapConfig(76.0, 2.5, true),\n+\n+            \/\/ For these tests, VBox.prefHeight is not specified, which means that child heights will not be adjusted.\n+            \/\/ The final height will snap slightly differently for each configuration.\n+            new testPixelSnapConfig(78.0, 1.0, false),\n+            new testPixelSnapConfig(76.8, 1.25, false),\n+            new testPixelSnapConfig(76.66666666666667, 1.5, false),\n+            new testPixelSnapConfig(77.14285714285714, 1.75, false),\n+            new testPixelSnapConfig(76.5, 2.0, false),\n+            new testPixelSnapConfig(76.44444444444444, 2.25, false),\n+            new testPixelSnapConfig(76.8, 2.5, false),\n+        }) {\n+            Region r1 = new Region(); r1.setPrefHeight(25.3);\n+            Region r2 = new Region(); r2.setPrefHeight(25.3);\n+            Region r3 = new Region(); r3.setPrefHeight(25.4);\n+            VBox box = new VBox(r1, r2, r3);\n+            box.setSnapToPixel(true);\n+\n+            if (config.specifyContainerPrefHeight) {\n+                box.setPrefHeight(76.0);\n+            }\n+\n+            SimpleDoubleProperty renderScale = new SimpleDoubleProperty(config.scale);\n+            Stage stage = new Stage();\n+            stage.renderScaleXProperty().bind(renderScale);\n+            stage.renderScaleYProperty().bind(renderScale);\n+            stage.setScene(new Scene(new VBox(box)));\n+            stage.show();\n+\n+            assertEquals(config.expectedHeight, box.getHeight(), 10e-14);\n+            assertEquals(config.expectedHeight, r1.getHeight() + r2.getHeight() + r3.getHeight(), 10e-14);\n+            stage.close();\n+        }\n+    }\n+\n+    private static class testPixelSnapConfig {\n+        final double expectedHeight;\n+        final double scale;\n+        final boolean specifyContainerPrefHeight;\n+\n+        testPixelSnapConfig(double expectedHeight, double scale, boolean specifyContainerPrefHeight) {\n+            this.expectedHeight = expectedHeight;\n+            this.scale = scale;\n+            this.specifyContainerPrefHeight = specifyContainerPrefHeight;\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/VBoxTest.java","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"}]}