{"files":[{"patch":"@@ -419,2 +419,2 @@\n-            double prefWidths[][] = getAreaWidths(managed, -1, false);\n-            adjustAreaWidths(managed, prefWidths, width, -1);\n+            double[][] prefWidths = getChildrenWidths(managed, -1, false);\n+            adjustChildrenWidths(managed, prefWidths, width, -1);\n@@ -442,2 +442,2 @@\n-            double prefWidths[][] = getAreaWidths(managed, -1, false);\n-            adjustAreaWidths(managed, prefWidths, width, -1);\n+            double[][] prefWidths = getChildrenWidths(managed, -1, false);\n+            adjustChildrenWidths(managed, prefWidths, width, -1);\n@@ -453,1 +453,4 @@\n-    private double[][] getAreaWidths(List<Node>managed, double height, boolean minimum) {\n+    \/**\n+     * Calculates the preferred or minimum width for each child.\n+     *\/\n+    private double[][] getChildrenWidths(List<Node> managed, double height, boolean minimum) {\n@@ -471,1 +474,7 @@\n-    private double adjustAreaWidths(List<Node> managed, double[][] areaWidths, double width, double height) {\n+    \/**\n+     * Adjusts the children widths to fit the provided space.\n+     * This might be necessary because the HBox is size-constrained and cannot accommodate the preferred\n+     * widths for all children, or it might be necessary because the HBox is sized to be larger than the\n+     * preferred widths of its children and needs to grow its children to fit its size.\n+     *\/\n+    private double adjustChildrenWidths(List<Node> managed, double[][] childrenWidths, double width, double height) {\n@@ -478,1 +487,1 @@\n-        double contentWidth = sum(areaWidths[0], managed.size()) + totalSpacing;\n+        double contentWidth = snappedSum(childrenWidths[0], managed.size()) + totalSpacing;\n@@ -482,1 +491,1 @@\n-            growAreaWidths(managed, areaWidths, targetWidth, refHeight);\n+            growChildrenWidths(managed, childrenWidths, targetWidth, refHeight);\n@@ -484,1 +493,1 @@\n-            shrinkAreaWidths(managed, areaWidths, targetWidth, refHeight);\n+            shrinkChildrenWidths(managed, childrenWidths, targetWidth, refHeight);\n@@ -487,1 +496,1 @@\n-        return sum(areaWidths[0], managed.size()) + totalSpacing;\n+        return snappedSum(childrenWidths[0], managed.size()) + totalSpacing;\n@@ -490,3 +499,7 @@\n-    private void shrinkAreaWidths(List<Node> managed, double[][] areaWidths, double targetWidth, double height) {\n-        double[] usedWidths = areaWidths[0];\n-        double[] minWidths = areaWidths[1];\n+    \/**\n+     * Shrinks all children widths to fit the target width.\n+     * Shrinking is a one-step process: all children are eligible to be adjusted down to their minimum width.\n+     *\/\n+    private void shrinkChildrenWidths(List<Node> managed, double[][] childrenWidths, double targetWidth, double height) {\n+        double[] usedWidths = childrenWidths[0];\n+        double[] minWidths = childrenWidths[1];\n@@ -504,3 +517,9 @@\n-    private void growAreaWidths(List<Node> managed, double[][] areaWidths, double targetWidth, double height) {\n-        double[] usedWidths = areaWidths[0];\n-        double[] maxWidths = areaWidths[1];\n+    \/**\n+     * Grows all children widths to fit the target width.\n+     * Growing is a two-step process: first, only children with {@link Priority#ALWAYS} are eligible\n+     * for adjustment. If the first adjustment didn't suffice to fit the target width, children with\n+     * {@link Priority#SOMETIMES} are also eligible for adjustment.\n+     *\/\n+    private void growChildrenWidths(List<Node> managed, double[][] childrenWidths, double targetWidth, double height) {\n+        double[] currentWidths = childrenWidths[0];\n+        double[] maxWidths = childrenWidths[1];\n@@ -523,1 +542,1 @@\n-            if (adjustWidthsWithinLimits(managed, usedWidths, maxWidths, targetWidth, adjustingNumber)) {\n+            if (adjustWidthsWithinLimits(managed, currentWidths, maxWidths, targetWidth, adjustingNumber)) {\n@@ -529,0 +548,14 @@\n+    \/**\n+     * Resizes the children widths to fit the target width, while taking into account the resize limits\n+     * for each child (their minimum and maximum width). This method will be called once when shrinking,\n+     * and may be called twice when growing.\n+     *\n+     * @param managed the managed children\n+     * @param currentWidths the current children widths\n+     * @param limitWidths the max or min widths for each child, depending on whether we are growing or shrinking;\n+     *                    a value of -1 means the child cannot be resized\n+     * @param targetWidth the target width (sum of child widths and spacing)\n+     * @param adjustingNumber a number that indicates how many children can be resized\n+     * @return {@code true} if the child widths were successfully resized to fit the target width;\n+     *         {@code false} otherwise\n+     *\/\n@@ -530,1 +563,1 @@\n-            List<Node> managed, double[] usedWidths, double[] limitWidths, double targetWidth, int adjustingNumber) {\n+            List<Node> managed, double[] currentWidths, double[] limitWidths, double targetWidth, int adjustingNumber) {\n@@ -532,2 +565,2 @@\n-        double currentWidth = sum(usedWidths, managed.size()) + totalSpacing;\n-        double currentDelta = targetWidth - currentWidth;\n+        double currentTotalWidth = snappedSum(currentWidths, managed.size()) + totalSpacing;\n+        double currentDelta = targetWidth - currentTotalWidth;\n@@ -543,1 +576,1 @@\n-                double maxChange = limitWidths[i] - usedWidths[i];\n+                double maxChange = limitWidths[i] - currentWidths[i];\n@@ -545,1 +578,1 @@\n-                double oldWidth = usedWidths[i];\n+                double oldWidth = currentWidths[i];\n@@ -547,2 +580,2 @@\n-                usedWidths[i] = snapSizeX(usedWidths[i] + change);\n-                currentWidth = sum(usedWidths, managed.size()) + totalSpacing;\n+                currentWidths[i] = snapSizeX(currentWidths[i] + change);\n+                currentTotalWidth = snappedSum(currentWidths, managed.size()) + totalSpacing;\n@@ -550,1 +583,1 @@\n-                double newDelta = targetWidth - currentWidth;\n+                double newDelta = targetWidth - currentTotalWidth;\n@@ -552,1 +585,1 @@\n-                    usedWidths[i] = oldWidth;\n+                    currentWidths[i] = oldWidth;\n@@ -568,0 +601,5 @@\n+    \/**\n+     * Calculates the preferred or minimum content width.\n+     * The content width is the total preferred or minimum width of all children,\n+     * including spacing between the children.\n+     *\/\n@@ -569,1 +607,1 @@\n-        return sum(getAreaWidths(managedChildren, height, minimum)[0], managedChildren.size())\n+        return snappedSum(getChildrenWidths(managedChildren, height, minimum)[0], managedChildren.size())\n@@ -573,1 +611,1 @@\n-    private double sum(double[] array, int size) {\n+    private double snappedSum(double[] array, int size) {\n@@ -659,2 +697,2 @@\n-        final double[][] actualAreaWidths = getAreaWidths(managed, height, false);\n-        double contentWidth = adjustAreaWidths(managed, actualAreaWidths, width, height);\n+        final double[][] actualChildrenWidths = getChildrenWidths(managed, height, false);\n+        double contentWidth = adjustChildrenWidths(managed, actualChildrenWidths, width, height);\n@@ -668,1 +706,1 @@\n-            baselineOffset = getAreaBaselineOffset(managed, marginAccessor, i -> actualAreaWidths[0][i],\n+            baselineOffset = getAreaBaselineOffset(managed, marginAccessor, i -> actualChildrenWidths[0][i],\n@@ -675,1 +713,1 @@\n-            layoutInArea(child, x, y, actualAreaWidths[0][i], contentHeight,\n+            layoutInArea(child, x, y, actualChildrenWidths[0][i], contentHeight,\n@@ -678,1 +716,1 @@\n-            x += actualAreaWidths[0][i] + space;\n+            x += actualChildrenWidths[0][i] + space;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HBox.java","additions":71,"deletions":33,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -396,2 +396,2 @@\n-            double prefHeights[][] = getAreaHeights(managed, -1, false);\n-            adjustAreaHeights(managed, prefHeights, height, -1);\n+            double[][] prefHeights = getChildrenHeights(managed, -1, false);\n+            adjustChildrenHeights(managed, prefHeights, height, -1);\n@@ -417,2 +417,2 @@\n-            double prefHeights[][] = getAreaHeights(managed, -1, false);\n-            adjustAreaHeights(managed, prefHeights, height, -1);\n+            double[][] prefHeights = getChildrenHeights(managed, -1, false);\n+            adjustChildrenHeights(managed, prefHeights, height, -1);\n@@ -428,1 +428,1 @@\n-        double d = snapSpaceY(insets.getTop()) +\n+        return snapSpaceY(insets.getTop()) +\n@@ -431,1 +431,0 @@\n-        return d;\n@@ -434,2 +433,4 @@\n-\n-    private double[][] getAreaHeights(List<Node>managed, double width, boolean minimum) {\n+    \/**\n+     * Calculates the preferred or minimum height for each child.\n+     *\/\n+    private double[][] getChildrenHeights(List<Node> managed, double width, boolean minimum) {\n@@ -461,1 +462,7 @@\n-    private double adjustAreaHeights(List<Node>managed, double[][] areaHeights, double height, double width) {\n+    \/**\n+     * Adjusts the children heights to fit the provided space.\n+     * This might be necessary because the HBox is size-constrained and cannot accommodate the preferred\n+     * heights for all children, or it might be necessary because the HBox is sized to be larger than the\n+     * preferred heights of its children and needs to grow its children to fit its size.\n+     *\/\n+    private double adjustChildrenHeights(List<Node> managed, double[][] childrenHeights, double height, double width) {\n@@ -468,1 +475,1 @@\n-        double contentHeight = sum(areaHeights[0], managed.size()) + totalSpacing;\n+        double contentHeight = snappedSum(childrenHeights[0], managed.size()) + totalSpacing;\n@@ -472,1 +479,1 @@\n-            growAreaHeights(managed, areaHeights, targetHeight, refWidth);\n+            growChildrenHeights(managed, childrenHeights, targetHeight, refWidth);\n@@ -474,1 +481,1 @@\n-            shrinkAreaHeights(managed, areaHeights, targetHeight, refWidth);\n+            shrinkChildrenHeights(managed, childrenHeights, targetHeight, refWidth);\n@@ -477,1 +484,1 @@\n-        return sum(areaHeights[0], managed.size()) + totalSpacing;\n+        return snappedSum(childrenHeights[0], managed.size()) + totalSpacing;\n@@ -480,3 +487,7 @@\n-    private void shrinkAreaHeights(List<Node> managed, double[][] areaHeights, double targetHeight, double width) {\n-        double[] usedHeights = areaHeights[0];\n-        double[] minHeights = areaHeights[1];\n+    \/**\n+     * Shrinks all children heights to fit the target height.\n+     * Shrinking is a one-step process: all children are eligible to be adjusted down to their minimum height.\n+     *\/\n+    private void shrinkChildrenHeights(List<Node> managed, double[][] childrenHeights, double targetHeight, double width) {\n+        double[] usedHeights = childrenHeights[0];\n+        double[] minHeights = childrenHeights[1];\n@@ -492,3 +503,9 @@\n-    private void growAreaHeights(List<Node> managed, double[][] areaHeights, double targetHeight, double width) {\n-        double[] usedHeights = areaHeights[0];\n-        double[] maxHeights = areaHeights[1];\n+    \/**\n+     * Grows all children heights to fit the target height.\n+     * Growing is a two-step process: first, only children with {@link Priority#ALWAYS} are eligible\n+     * for adjustment. If the first adjustment didn't suffice to fit the target height, children with\n+     * {@link Priority#SOMETIMES} are also eligible for adjustment.\n+     *\/\n+    private void growChildrenHeights(List<Node> managed, double[][] childrenHeights, double targetHeight, double width) {\n+        double[] currentHeights = childrenHeights[0];\n+        double[] maxHeights = childrenHeights[1];\n@@ -509,1 +526,1 @@\n-            if (adjustHeightsWithinLimits(managed, usedHeights, maxHeights, targetHeight, adjustingNumber)) {\n+            if (adjustHeightsWithinLimits(managed, currentHeights, maxHeights, targetHeight, adjustingNumber)) {\n@@ -515,0 +532,14 @@\n+    \/**\n+     * Resizes the children heights to fit the target height, while taking into account the resize limits\n+     * for each child (their minimum and maximum width). This method will be called once when shrinking,\n+     * and may be called twice when growing.\n+     *\n+     * @param managed the managed children\n+     * @param currentHeights the current children heights\n+     * @param limitHeights the max or min heights for each child, depending on whether we are growing or shrinking;\n+     *                    a value of -1 means the child cannot be resized\n+     * @param targetHeight the target height (sum of children heights and spacing)\n+     * @param adjustingNumber a number that indicates how many children can be resized\n+     * @return {@code true} if the children heights were successfully resized to fit the target height;\n+     *         {@code false} otherwise\n+     *\/\n@@ -516,1 +547,1 @@\n-            List<Node> managed, double[] usedHeights, double[] limitHeights, double targetHeight, int adjustingNumber) {\n+            List<Node> managed, double[] currentHeights, double[] limitHeights, double targetHeight, int adjustingNumber) {\n@@ -518,2 +549,2 @@\n-        double currentHeight = sum(usedHeights, managed.size()) + totalSpacing;\n-        double currentDelta = targetHeight - currentHeight;\n+        double currentTotalHeight = snappedSum(currentHeights, managed.size()) + totalSpacing;\n+        double currentDelta = targetHeight - currentTotalHeight;\n@@ -529,1 +560,1 @@\n-                double maxChange = limitHeights[i] - usedHeights[i];\n+                double maxChange = limitHeights[i] - currentHeights[i];\n@@ -531,1 +562,1 @@\n-                double oldHeight = usedHeights[i];\n+                double oldHeight = currentHeights[i];\n@@ -533,2 +564,2 @@\n-                usedHeights[i] = snapSizeY(usedHeights[i] + change);\n-                currentHeight = sum(usedHeights, managed.size()) + totalSpacing;\n+                currentHeights[i] = snapSizeY(currentHeights[i] + change);\n+                currentTotalHeight = snappedSum(currentHeights, managed.size()) + totalSpacing;\n@@ -536,1 +567,1 @@\n-                double newDelta = targetHeight - currentHeight;\n+                double newDelta = targetHeight - currentTotalHeight;\n@@ -538,1 +569,1 @@\n-                    usedHeights[i] = oldHeight;\n+                    currentHeights[i] = oldHeight;\n@@ -554,0 +585,5 @@\n+    \/**\n+     * Calculates the preferred or minimum content height.\n+     * The content height is the total preferred or minimum height of all children,\n+     * including spacing between the children.\n+     *\/\n@@ -555,1 +591,1 @@\n-        return sum(getAreaHeights(managedChildren, width, minimum)[0], managedChildren.size())\n+        return snappedSum(getChildrenHeights(managedChildren, width, minimum)[0], managedChildren.size())\n@@ -559,1 +595,1 @@\n-    private double sum(double[] array, int size) {\n+    private double snappedSum(double[] array, int size) {\n@@ -587,1 +623,1 @@\n-        double[][] actualAreaHeights = getAreaHeights(managed, width, false);\n+        double[][] actualChildrenHeights = getChildrenHeights(managed, width, false);\n@@ -589,1 +625,1 @@\n-        double contentHeight = adjustAreaHeights(managed, actualAreaHeights, height, width);\n+        double contentHeight = adjustChildrenHeights(managed, actualChildrenHeights, height, width);\n@@ -596,2 +632,2 @@\n-            layoutInArea(child, x, y, contentWidth, actualAreaHeights[0][i],\n-                       \/* baseline shouldn't matter *\/actualAreaHeights[0][i],\n+            layoutInArea(child, x, y, contentWidth, actualChildrenHeights[0][i],\n+                       \/* baseline shouldn't matter *\/actualChildrenHeights[0][i],\n@@ -600,1 +636,1 @@\n-            y += actualAreaHeights[0][i] + space;\n+            y += actualChildrenHeights[0][i] + space;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/VBox.java","additions":72,"deletions":36,"binary":false,"changes":108,"status":"modified"}]}