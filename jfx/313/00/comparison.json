{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,2 @@\n-            if (disclosureNode != null) {\n+          \/\/ fix JDK-8253597: check disclosure node for visibility along with existence\n+          if (disclosureNode != null && disclosureNode.isVisible()) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TreeTableCellBehavior.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.Arrays;\n+import java.util.List;\n+\n@@ -33,0 +36,1 @@\n+import javafx.geometry.Point2D;\n@@ -40,3 +44,7 @@\n-import java.util.Arrays;\n-import java.util.List;\n-\n+\/**\n+ * Helper to fire MouseEvents onto a EventTarget which is either Node or Scene.\n+ * There are methods to configure the event by eventType, clickCount, location (delta from default),\n+ * mouseButton and keyModifiers.\n+ * <p>\n+ * The default local coordinates are the center of the target.\n+ *\/\n@@ -50,0 +58,2 @@\n+    private boolean alternative;\n+\n@@ -76,0 +86,13 @@\n+    \/**\n+     * Instantiates a MouseEventFirer on the given node.\n+     * <p>\n+     * Note: this was added as hot-fix for JDK-8253769.\n+     *\n+     * @param target the node to fire on\n+     * @param alternative uses alternative creation path for mouseEvent if true.\n+     *\/\n+    public MouseEventFirer(Node target, boolean alternative) {\n+        this(target);\n+        this.alternative = alternative;\n+    }\n+\n@@ -161,0 +184,9 @@\n+        if (alternative) {\n+            fireMouseEventAlternative(evtType, button, clickCount, deltaX, deltaY, modifiers);\n+            return;\n+        }\n+        \/\/ TBD: JDK-8253769\n+        \/\/ the mouseEvent created here seems to be valid (in regard to coordinate transformations\n+        \/\/ of local\/scene\/screen) only if the target is glued to the upper leading edge of the scene\n+        \/\/ and zero deltaX\/Y!\n+\n@@ -224,0 +256,49 @@\n+    \/**\n+     * Fires a mouseEvent with the given configuration options onto the target.\n+     * Hot-fix for JDK-8253769.\n+     * The mouseEvent is created such that coordiate transformation constraints seem to be respected.\n+     *\/\n+    private void fireMouseEventAlternative(EventType<MouseEvent> evtType, MouseButton button, int clickCount, double deltaX, double deltaY, KeyModifier... modifiers) {\n+\n+        \/\/ width \/ height of target node\n+        final double w = targetBounds.getWidth();\n+        final double h = targetBounds.getHeight();\n+\n+        \/\/ x \/ y click position is centered\n+        final double x = w \/ 2.0 + deltaX;\n+        final double y = h \/ 2.0 + deltaY;\n+\n+        Node node = (Node) target;\n+\n+        Point2D localP = new Point2D(x, y);\n+        Point2D sceneP = node.localToScene(localP);\n+        Point2D screenP = node.localToScreen(localP);\n+\n+        final List<KeyModifier> ml = Arrays.asList(modifiers);\n+\n+        MouseEvent evt = new MouseEvent(\n+                target, \/\/ target of this firer\n+                null,   \/\/ default source (don't care, event dispatch will take over)\n+                evtType,\n+                sceneP.getX(), sceneP.getY(), \/\/ can use scene coordinates because source is null\n+                screenP.getX(), screenP.getY(),\n+                button,\n+                clickCount,\n+                ml.contains(KeyModifier.SHIFT),    \/\/ shiftDown\n+                ml.contains(KeyModifier.CTRL),     \/\/ ctrlDown\n+                ml.contains(KeyModifier.ALT),      \/\/ altDown\n+                ml.contains(KeyModifier.META),     \/\/ metaData\n+                button == MouseButton.PRIMARY,     \/\/ primary button\n+                button == MouseButton.MIDDLE,      \/\/ middle button\n+                button == MouseButton.SECONDARY,   \/\/ secondary button\n+                button == MouseButton.BACK,        \/\/ back button\n+                button == MouseButton.FORWARD,     \/\/ forward button\n+                false,                             \/\/ synthesized\n+                button == MouseButton.SECONDARY,   \/\/ is popup trigger\n+                true,                              \/\/ still since pick\n+                null    \/\/ default pick (don't care, event constructor will take over)\n+                );\n+\n+        Event.fireEvent(target, evt);\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/infrastructure\/MouseEventFirer.java","additions":85,"deletions":4,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.scene.control.infrastructure;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.sun.javafx.tk.Toolkit;\n+\n+import static javafx.scene.layout.AnchorPane.*;\n+import static org.junit.Assert.*;\n+\n+import javafx.geometry.Bounds;\n+import javafx.geometry.Point2D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Labeled;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.AnchorPane;\n+import javafx.stage.Stage;\n+\n+\/**\n+ * Test for MouseEventFirer.\n+ * <p>\n+ * The test is parameterized on not\/using (old\/new) the alternative mouseEvent creation\n+ * path.\n+ *\/\n+@RunWith(Parameterized.class)\n+public class MouseEventFirerTest {\n+\n+    \/\/------------ fields\n+\n+    private Scene scene;\n+    private Stage stage;\n+    private AnchorPane content;\n+\n+    private static final double EPS = 1;\n+    \/\/ margins for center node\n+    private final double VERTICAL_DISTANCE = 100.;\n+    private final double HORIZONTAL_DISTANCE = 20.;\n+\n+    private Node topLeft, center, bottomRight;\n+\n+\/\/------- standalone node\n+\n+    @Test\n+    public void testLocalStandaloneDeltaNegative() {\n+        Button button = new Button(\"standalone button, a bit longish\");\n+        assertLocal(button, - 10, - 5);\n+    }\n+\n+    @Test\n+    public void testLocalStandaloneDelta() {\n+        Button button = new Button(\"standalone button, a bit longish\");\n+        assertLocal(button, 10, 5);\n+    }\n+\n+    @Test\n+    public void testLocalStandalone() {\n+        Button button = new Button(\"standalone button, a bit longish\");\n+        assertLocal(button, 0, 0);\n+    }\n+\n+    @Test\n+    public void testMouseCoordinatesStandaloneDeltaNegative() {\n+        Button button = new Button(\"standalone button, a bit longish\");\n+        assertMouseCoordinatesDelta(button, - 10, - 5);\n+    }\n+\n+    @Test\n+    public void testMouseCoordinatesStandaloneDelta() {\n+        Button button = new Button(\"standalone button, a bit longish\");\n+        assertMouseCoordinatesDelta(button, 10, 5);\n+    }\n+\n+    @Test\n+    public void testMouseCoordinatesStandalone() {\n+        Button button = new Button(\"standalone button, a bit longish\");\n+        assertMouseCoordinatesDelta(button, 0, 0);\n+    }\n+\n+\/\/ --------- test local coordinates\n+\n+    @Test\n+    public void testLocalDeltaNegative() {\n+        content.getChildren().forEach(child -> assertLocal(child, - 10, - 5));\n+    }\n+\n+    @Test\n+    public void testLocalDelta() {\n+        content.getChildren().forEach(child -> assertLocal(child, 10, 5));\n+    }\n+\n+    @Test\n+    public void testLocal() {\n+        content.getChildren().forEach(child -> assertLocal(child, 0, 0));\n+    }\n+\n+    \/**\n+     * Fires a mousePressed with the given x\/y location on the given target\n+     * and asserts the local mouse coordinates.\n+     *\n+     *\/\n+    protected void assertLocal(Node target, double deltaX, double deltaY) {\n+        MouseEventFirer firer = new MouseEventFirer(target, useAlternative);\n+        String text = target instanceof Labeled ? ((Labeled) target).getText() : target.getId();\n+        target.setOnMousePressed(e -> {\n+            double width = target.getLayoutBounds().getWidth();\n+            double height = target.getLayoutBounds().getHeight();\n+            assertEquals(\"local x of \" + text, width \/2 + deltaX, e.getX(), EPS);\n+            assertEquals(\"local y of \" + text, height \/ 2 + deltaY, e.getY(), EPS);\n+        });\n+        firer.fireMousePressed(deltaX, deltaY);\n+    }\n+\n+\/\/------------ test scene\/screen coordinates\n+\n+    @Test\n+    public void testMouseCoordinatesDeltaNegative() {\n+        content.getChildren().forEach(child -> assertMouseCoordinatesDelta(child, - 10, - 5));\n+    }\n+\n+    @Test\n+    public void testMouseCoordinatesDelta() {\n+        content.getChildren().forEach(child -> assertMouseCoordinatesDelta(child, 10, 5));\n+    }\n+\n+    @Test\n+    public void testMouseCoordinates() {\n+        content.getChildren().forEach(child -> assertMouseCoordinatesDelta(child, 0, 0));\n+    }\n+\n+    \/**\n+     * Fires a mousePressed with the given x\/y location on the given target\n+     *  and asserts basic mouseEvent constraints.\n+     *\/\n+    protected void assertMouseCoordinatesDelta(Node target, double deltaX, double deltaY) {\n+        MouseEventFirer firer = new MouseEventFirer(target, useAlternative);\n+        target.setOnMousePressed(this::assertMouseEventCoordinates);\n+        firer.fireMousePressed(deltaX, deltaY);\n+    }\n+\n+    \/**\n+     * Asserts scene\/screen coordinates of event are same as localToScene\/Screen.\n+     *\/\n+    protected void assertMouseEventCoordinates(MouseEvent mouse) {\n+        assertSame(mouse.getTarget(), mouse.getSource());\n+        Node receiver = (Node) mouse.getTarget();\n+        String text = receiver instanceof Labeled ? ((Labeled) receiver).getText() : receiver.getId();\n+\n+        Point2D sceneP = receiver.localToScene(mouse.getX(), mouse.getY());\n+        assertEquals(\"sceneX of \" + text, sceneP.getX(), mouse.getSceneX(), EPS);\n+        assertEquals(\"sceneY of \" + text, sceneP.getY(), mouse.getSceneY(), EPS);\n+        Point2D screenP = receiver.localToScreen(mouse.getX(), mouse.getY());\n+        assertEquals(\"screenX of \" + text, screenP.getX(), mouse.getScreenX(), EPS);\n+        assertEquals(\"screenY of \" + text, screenP.getY(), mouse.getScreenY(), EPS);\n+    }\n+\n+ \/\/ ------------- parameterized in not\/alternative mouseEvent creation\n+\n+    private boolean useAlternative;\n+\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        \/\/ current \/ alternative mouseEvent creation\n+        Object[][] data = new Object[][] {\n+            \/\/ @Ignore(\"8253769\")\n+            \/\/ {false},\n+            {true},\n+        };\n+        return Arrays.asList(data);\n+    }\n+\n+    public MouseEventFirerTest(boolean useAlternative) {\n+        this.useAlternative = useAlternative;\n+    }\n+\n+ \/\/ ------------ setup\/cleanup\/intial\n+\n+    @Test\n+    public void testFirer() {\n+        new MouseEventFirer(topLeft, true);\n+        assertSame(\"sanity: firer must not change hierarchy\", scene, topLeft.getScene());\n+        assertSame(\"sanity: firer must not change hierarchy\", stage, topLeft.getScene().getWindow());\n+    }\n+\n+    @Test\n+    public void testAnchorRight() {\n+        setLeftAnchor(topLeft, null);\n+        setRightAnchor(topLeft, 0.);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(content.getWidth() - topLeft.prefWidth(-1), topLeft.getBoundsInParent().getMinX(), EPS);\n+    }\n+\n+    @Test\n+    public void testLayoutBounds() {\n+        Bounds initial = topLeft.getLayoutBounds();\n+        setLeftAnchor(topLeft, null);\n+        setRightAnchor(topLeft, 0.);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(\"sanity: layout bounds unchanged\", initial, topLeft.getLayoutBounds());\n+    }\n+\n+    @Test\n+    public void testContentLayout() {\n+        assertTrue(stage.isShowing());\n+        \/\/ content sizing controlled by big middle node\n+        assertEquals(2* VERTICAL_DISTANCE + center.prefHeight(-1), content.getHeight(), EPS);\n+        assertEquals(2* HORIZONTAL_DISTANCE + center.prefWidth(-1), content.getWidth(), EPS);\n+        \/\/ middle\n+        assertEquals(HORIZONTAL_DISTANCE, center.getBoundsInParent().getMinX(), EPS);\n+        assertEquals(VERTICAL_DISTANCE, center.getBoundsInParent().getMinY(),EPS);\n+        \/\/ top\n+        assertEquals(0, topLeft.getBoundsInParent().getMinX(), EPS);\n+        assertEquals(0, topLeft.getBoundsInParent().getMinY(), EPS);\n+        \/\/ bottom\n+        assertEquals(0, bottomRight.getBoundsInParent().getMinX(), EPS);\n+        assertEquals(content.getHeight() - bottomRight.prefHeight(-1), bottomRight.getBoundsInParent().getMinY(), EPS);\n+    }\n+\n+    @Before\n+    public void setup() {\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+        topLeft = new Button(\"topLeft\");\n+        \/\/ glue to topLeft\n+        setTopAnchor(topLeft, 0.);\n+        setLeftAnchor(topLeft, 0.);\n+\n+        center = new Button(\"center: a longish text nearly filling horizontally\");\n+        \/\/ glue into center\n+        setTopAnchor(center, VERTICAL_DISTANCE);\n+        setBottomAnchor(center, VERTICAL_DISTANCE);\n+        setLeftAnchor(center, HORIZONTAL_DISTANCE);\n+        setRightAnchor(center, HORIZONTAL_DISTANCE);\n+\n+        bottomRight = new Button(\"botRight\");\n+        \/\/ glue to bottom-right\n+        setBottomAnchor(bottomRight, 0.);\n+        setLeftAnchor(bottomRight, 0.);\n+\n+        content = new AnchorPane(topLeft, center, bottomRight);\n+        scene = new Scene(content);\n+        stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        if (stage != null) stage.hide();\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/infrastructure\/MouseEventFirerTest.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,324 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control.skin;\n+\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import com.sun.javafx.tk.Toolkit;\n+\n+import static org.junit.Assert.*;\n+import static test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils.*;\n+\n+import javafx.beans.property.ReadOnlyStringWrapper;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableCell;\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTableRow;\n+import javafx.scene.control.TreeTableView;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.Stage;\n+import test.com.sun.javafx.scene.control.infrastructure.MouseEventFirer;\n+\n+\/**\n+ * Tests around disclosure node.\n+ *\/\n+public class TreeTableViewDisclosureNodeTest {\n+\n+\/\/------------ fields\n+\n+    private Scene scene;\n+    private Stage stage;\n+    private Pane content;\n+\n+    private TreeTableView<String> treeTable;\n+    private TreeItem<String> root;\n+    private TreeTableView.TreeTableViewSelectionModel<?> sm;\n+\n+    \/\/ indices of root children\n+    private int rootLeafChildIndex;\n+    private int rootExpandedChildIndex;\n+    private int rootCollapsedChildIndex;\n+\n+\/\/------------\n+\n+    \/**\n+     * Test fix for JDK-8253597.\n+     *\/\n+    @Test\n+    public void testSelectChildLeafAfterExpand() {\n+        showTreeTable();\n+        TreeItem<String> child = root.getChildren().get(rootCollapsedChildIndex);\n+        \/\/ expand child that was initially collapsed\n+        child.setExpanded(true);\n+        Toolkit.getToolkit().firePulse();\n+\n+        TreeItem<String> grandChild = child.getChildren().get(0);\n+        int grandChildRowIndex = treeTable.getRow(grandChild);\n+        assertTrue(\"sanity: grandChild is leaf\", grandChild.isLeaf());\n+        assertFalse(\"sanity: grandChild not selected\", sm.isSelected(grandChildRowIndex));\n+        fireMouseIntoIndentationRegion(grandChildRowIndex);\n+        assertTrue(\"grandChild must be selected \" + grandChildRowIndex, sm.isSelected(grandChildRowIndex));\n+    }\n+\n+    \/**\n+     * This is the deeper reason for JDK-8253597: on re-use of a treeTableRow\n+     * in leaf rows, the disclosureNode is not removed\n+     *\/\n+    @Test @Ignore(\"real-cleanup\")\n+    public void testRowReuse() {\n+        showTreeTable();\n+        TreeItem<String> expandedChild = root.getChildren().get(rootExpandedChildIndex);\n+        TreeItem<String> grandChild = expandedChild.getChildren().get(0);\n+        int grandChildRowIndex = treeTable.getRow(grandChild);\n+        assertNull(\"leaf must not have disclosureNode\", getDisclosureNode(grandChildRowIndex));\n+        \/\/ collapse\/expand cycle\n+        expandedChild.setExpanded(false);\n+        Toolkit.getToolkit().firePulse();\n+        expandedChild.setExpanded(true);\n+        Toolkit.getToolkit().firePulse();\n+        assertNull(\"leaf must not have disclosureNode\", getDisclosureNode(grandChildRowIndex));\n+    }\n+\n+    \/**\n+     * Sanity: firing into disclosure node region of initially visible child leaf selects.\n+     *\/\n+    @Test\n+    public void testSelectChildLeaf() {\n+        showTreeTable();\n+        TreeItem<String> expandedChild = root.getChildren().get(rootExpandedChildIndex);\n+        TreeItem<String> grandChild = expandedChild.getChildren().get(0);\n+        int grandChildRowIndex = treeTable.getRow(grandChild);\n+        fireMouseIntoIndentationRegion(grandChildRowIndex);\n+        assertTrue(\"row must be selected\" + grandChildRowIndex, sm.isSelected(grandChildRowIndex));\n+    }\n+\n+    \/**\n+     * Sanity: firing into disclosure node region top-level leaf child selects.\n+     *\/\n+    @Test\n+    public void testSelectRootLeaf() {\n+        showTreeTable();\n+        TreeItem<String> leafChild = root.getChildren().get(rootLeafChildIndex);\n+        int leafChildRowIndex = treeTable.getRow(leafChild);\n+        fireMouseIntoIndentationRegion(leafChildRowIndex);\n+        assertTrue(\"row must be selected\" + leafChildRowIndex, sm.isSelected(leafChildRowIndex));\n+   }\n+\n+    \/**\n+     * Sanity test: firing into disclosure node region of collapsed child must expand it.\n+     *\/\n+    @Test\n+    public void testExpandCollapsedChild() {\n+        showTreeTable();\n+        TreeItem<String> child = root.getChildren().get(rootCollapsedChildIndex);\n+        boolean expanded = child.isExpanded();\n+        fireMouseIntoIndentationRegion(treeTable.getRow(child));\n+        assertEquals(\"expansion state changed\" + child.getValue(), !expanded,  child.isExpanded());\n+    }\n+\n+    \/**\n+     * Test inital state of disclosureNode.\n+     * Note that a leaf row that was visible initially, does not have\n+     * a disclosureNode.\n+     *\/\n+    @Test\n+    public void testInitialRowState() {\n+        showTreeTable();\n+        \/\/ root\n+        assertHasVisibleDisclosureNode(0);\n+        \/\/ leaf child of root\n+        assertNull(getDisclosureNode(rootLeafChildIndex + 1));\n+        \/\/ expanded child of root\n+        assertHasVisibleDisclosureNode(rootExpandedChildIndex + 1);\n+        assertNull(getDisclosureNode(rootExpandedChildIndex + 2));\n+    }\n+\n+    \/**\n+     * Fires a mouse pressed\/released into the indentation region of the\n+     * first (single) tableCell of the given row.\n+     *\/\n+    protected void fireMouseIntoIndentationRegion(int rowIndex) {\n+        TreeTableRow<?> grandChildTableRow = getTableRow(rowIndex);\n+        \/\/ single column == single child cell\n+        TreeTableCell<?, ?> cell = (TreeTableCell<?, ?>) grandChildTableRow.lookup(\".tree-table-cell\");\n+        MouseEventFirer mouse = new MouseEventFirer(cell, true);\n+        \/\/ target to hit disclosure\n+        double targetX = - cell.getWidth() \/ 2; \/\/ compensate default center offset to zero\n+        mouse.fireMousePressAndRelease(1, targetX, 0);\n+        Toolkit.getToolkit().firePulse();\n+    }\n+\n+    \/**\n+     * Asserts that the tableRow at the given row has a disclosureNode with the\n+     * given visibility.\n+     *\n+     *\/\n+    protected void assertHasVisibleDisclosureNode(int rowIndex) {\n+        Node disclosure = getDisclosureNode(rowIndex);\n+        assertNotNull(\"disclosureNode must added\", disclosure);\n+        assertTrue(\"disclosureNode must be visible\", disclosure.isVisible());\n+    }\n+\n+\/\/ ------ accessor helpers\n+\n+    \/**\n+     * Returns the disclosureNode for the given rowIndex.\n+     *\/\n+    protected Node getDisclosureNode(int rowIndex) {\n+        TreeTableRow<?> tableRow = getTableRow(rowIndex);\n+        Node disclosure = tableRow.lookup(\".tree-disclosure-node\");\n+        return disclosure;\n+    }\n+\n+    \/**\n+     * Returns the TreeTableRow for the given treeItem. The item must be\n+     * accessible as specified by treeTable.getRow(treeItem).\n+     *\/\n+    protected TreeTableRow<?> getTableRow(TreeItem<String> treeItem) {\n+        return getTableRow(treeTable.getRow(treeItem));\n+    }\n+\n+    \/**\n+     * Returns the TreeTableRow for the given rowIndex. The index must\n+     * be in the range 0 <= rowIndex < treeTable.getExpandedItemCount()\n+     *\/\n+    protected TreeTableRow<?> getTableRow(int rowIndex) {\n+        IndexedCell<?> tableRow = getCell(treeTable, rowIndex);\n+        assertTrue(\"sanity: expect TreeTableRow but was: \" + tableRow, tableRow instanceof TreeTableRow);\n+        assertEquals(\"sanity: row index\", rowIndex, tableRow.getIndex());\n+        return (TreeTableRow<?>) tableRow;\n+    }\n+\n+  \/\/---------------- setup and initial\n+\n+    @Test\n+    public void testInitialTreeTableState() {\n+        assertTrue(treeTable.isShowRoot());\n+        assertSame(root, treeTable.getRoot());\n+        assertTrue(root.getChildren().get(rootLeafChildIndex).isLeaf());\n+        assertTrue(root.getChildren().get(rootExpandedChildIndex).isExpanded());\n+        assertFalse(root.getChildren().get(rootCollapsedChildIndex).isExpanded());\n+        int rowCount = root.getChildren().size() + 1 \/\/ root and direct children\n+                + root.getChildren().get(rootExpandedChildIndex).getChildren().size(); \/\/ expanded child,\n+        assertEquals(rowCount, treeTable.getExpandedItemCount());\n+        showTreeTable();\n+        List<Node> children = List.of(treeTable);\n+        assertEquals(children, content.getChildren());\n+        assertTrue(sm.isEmpty());\n+    }\n+\n+    protected void showTreeTable() {\n+        showControl(treeTable);\n+    }\n+\n+    \/**\n+     * Ensures the control is shown and focused in an active scenegraph.\n+     *\/\n+    protected void showControl(Control control) {\n+        if (content == null) {\n+            content = new VBox();\n+            scene = new Scene(content);\n+            stage = new Stage();\n+            stage.setScene(scene);\n+        }\n+        if (!content.getChildren().contains(control)) {\n+            content.getChildren().add(control);\n+        }\n+        stage.show();\n+        stage.requestFocus();\n+        control.requestFocus();\n+        assertTrue(control.isFocused());\n+        assertSame(control, scene.getFocusOwner());\n+    }\n+\n+    \/**\n+     Tree structure:\n+\n+         -v expanded root\n+               leaf             \/\/ rootLeafChildIndex\n+            -v expanded child   \/\/ rootExpandedChildIndex\n+                 child leaf\n+                 child leaf\n+                 child leaf\n+            -> collapsed child  \/\/ rootCollapsedChildIndex\n+            -> collapsed child\n+           ...\n+     *\/\n+    protected void fillTree(TreeItem<String> rootItem) {\n+        rootItem.setExpanded(true);\n+        rootItem.getChildren().add(0, new TreeItem<>(\"leafChild\"));\n+        for (int i = 0; i < 10; i++) {\n+            TreeItem<String> newChild = new TreeItem<>(\"child \" + i);\n+            if (i == 0) newChild.setExpanded(true);\n+            rootItem.getChildren().add(newChild);\n+            for (int j = 0; j < 3; j++) {\n+                TreeItem<String> newChild2 = new TreeItem<>(i + \" grandChild \" + j);\n+                newChild.getChildren().add(newChild2);\n+            }\n+        }\n+    }\n+\n+    @Before\n+    public void setup() {\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+        rootLeafChildIndex = 0;\n+        rootExpandedChildIndex = 1;\n+        rootCollapsedChildIndex = 2;\n+        root = new TreeItem<>(\"Root\");\n+        treeTable = new TreeTableView<String>(root);\n+        fillTree(root);\n+\n+        sm = treeTable.getSelectionModel();\n+\n+        TreeTableColumn<String, String> treeColumn = new TreeTableColumn<>(\"Col1\");\n+        treeColumn.setPrefWidth(200);\n+        treeColumn.setCellValueFactory(call -> new ReadOnlyStringWrapper(call.getValue().getValue()));\n+        treeTable.getColumns().add(treeColumn);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        if (stage != null) stage.hide();\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TreeTableViewDisclosureNodeTest.java","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"}]}