{"files":[{"patch":"@@ -0,0 +1,317 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.util.memory;\n+\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import javax.management.MBeanServer;\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.lang.ref.WeakReference;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\n+\/**\n+ * JMemoryBuddy provides various methods to test for memory leaks.\n+ * It makes it easy to verify the memory behavior in a unit test ensuring the stability and quality of your code.\n+ * Checkout <a href=\"https:\/\/github.com\/Sandec\/JMemoryBuddy\">https:\/\/github.com\/Sandec\/JMemoryBuddy<\/a> for more documentation.\n+ *\/\n+public class JMemoryBuddy {\n+\n+    private static int steps = 10;\n+    private static int testDuration = 1000;\n+    private static int sleepDuration = testDuration \/ steps;\n+    private static boolean createHeapdump = false;\n+    private static int garbageAmount = 999999;\n+    private static String mxBeanProxyName = \"com.sun.management:type=HotSpotDiagnostic\";\n+    private static String outputFolderString = \".\";\n+\n+    static {\n+        outputFolderString = System.getProperty(\"jmemorybuddy.output\", getDefaultOutputFolder());\n+        testDuration = Integer.parseInt(System.getProperty(\"jmemorybuddy.testDuration\",\"1000\"));\n+        steps = Integer.parseInt(System.getProperty(\"jmemorybuddy.steps\", \"10\"));\n+        createHeapdump = Boolean.parseBoolean(System.getProperty(\"jmemorybuddy.createHeapdump\", \"false\"));\n+        garbageAmount = Integer.parseInt(System.getProperty(\"jmemorybuddy.garbageAmount\", \"10\"));\n+    }\n+\n+    private static String getDefaultOutputFolder() {\n+        File folder1 = new File(\"target\");\n+        File folder2 = new File(\"build\");\n+\n+        if (folder1.exists()) return folder1.getAbsolutePath();\n+        if (folder2.exists()) return folder2.getAbsolutePath();\n+        return \".\";\n+    }\n+\n+    static void createGarbage() {\n+        LinkedList list = new LinkedList<Integer>();\n+        int counter = 0;\n+        while (counter < garbageAmount) {\n+            counter += 1;\n+            list.add(1);\n+        }\n+    }\n+\n+    \/**\n+     * Checks whether the content of the WeakReference can be collected.\n+     * @param weakReference The WeakReference to check.\n+     *\/\n+    public static void assertCollectable(WeakReference weakReference) {\n+        if (!checkCollectable(weakReference)) {\n+            AssertCollectable assertCollectable = new AssertCollectable(weakReference);\n+            createHeapDump();\n+            throw new AssertionError(\"Content of WeakReference was not collected. content: \" + weakReference.get());\n+        }\n+    }\n+\n+    \/**\n+     * Checks whether the content of the WeakReference can be collected.\n+     * @param weakReference The WeakReference to check.\n+     * @return Returns true, when the provided WeakReference can be collected.\n+     *\/\n+    public static boolean checkCollectable(WeakReference weakReference) {\n+        return checkCollectable(steps, weakReference) > 0;\n+    }\n+\n+    private static int checkCollectable(int stepsLeft, WeakReference weakReference) {\n+        int counter = stepsLeft;\n+\n+        if (weakReference.get() != null) {\n+            createGarbage();\n+            System.gc();\n+            System.runFinalization();\n+        }\n+\n+        while (counter > 0 && weakReference.get() != null) {\n+            try {\n+                Thread.sleep(sleepDuration);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            counter = counter - 1;\n+            createGarbage();\n+            System.gc();\n+            System.runFinalization();\n+        }\n+\n+        if (weakReference.get() == null && counter < steps \/ 3) {\n+            int percentageUsed = (int) ((steps - counter) \/ steps * 100);\n+            System.out.println(\"Warning test seems to be unstable. time used: \" + percentageUsed + \"%\");\n+        }\n+\n+        return counter;\n+    }\n+\n+    \/**\n+     * Checks whether the content of the WeakReference cannot be collected.\n+     * @param weakReference The WeakReference to check.\n+     *\/\n+    public static void assertNotCollectable(WeakReference weakReference) {\n+        if (!checkNotCollectable(weakReference)) {\n+            throw new AssertionError(\"Content of WeakReference was collected!\");\n+        }\n+    }\n+\n+    \/**\n+     * Checks whether the content of the WeakReference cannot be collected.\n+     * @param weakReference The WeakReference to check.\n+     * @return Returns true, when the provided WeakReference cannot be collected.\n+     *\/\n+    public static boolean checkNotCollectable(WeakReference weakReference) {\n+        createGarbage();\n+        System.gc();\n+        System.runFinalization();\n+        createGarbage();\n+        System.gc();\n+        return weakReference.get() != null;\n+    }\n+\n+    \/**\n+     * A standard method to define a test which checks code for specific memory semantic.\n+     * The parameter of the lambda provides an API to define the required memory semantic.\n+     * @param f A function which get's executed with the API to define the required memory semantic.\n+     *\/\n+    public static void memoryTest(Consumer<MemoryTestAPI> f) {\n+        LinkedList<WeakReference> toBeCollected = new LinkedList<WeakReference>();\n+        LinkedList<AssertNotCollectable> toBeNotCollected = new LinkedList<AssertNotCollectable>();\n+        LinkedList<SetAsReferenced> toBeReferenced = new LinkedList<SetAsReferenced>();\n+\n+        f.accept(new MemoryTestAPI() {\n+            public void assertCollectable(Object ref) {\n+                Objects.requireNonNull(ref);\n+                toBeCollected.add(new WeakReference<Object>(ref));\n+            }\n+            public void assertNotCollectable(Object ref) {\n+                Objects.requireNonNull(ref);\n+                toBeNotCollected.add(new AssertNotCollectable(ref));\n+            }\n+            public void setAsReferenced(Object ref) {\n+                Objects.requireNonNull(ref);\n+                toBeReferenced.add(new SetAsReferenced(ref));\n+            }\n+        });\n+\n+        int stepsLeft = steps;\n+        boolean failed = false;\n+\n+        for (WeakReference wRef: toBeCollected) {\n+            stepsLeft = checkCollectable(stepsLeft, wRef);\n+        }\n+        if (stepsLeft == 0) {\n+            failed = true;\n+        }\n+        for (AssertNotCollectable wRef: toBeNotCollected) {\n+            if (!checkNotCollectable(wRef.getWeakReference())) {\n+                failed = true;\n+            };\n+        }\n+\n+        if (failed) {\n+            LinkedList<AssertCollectable> toBeCollectedMarked = new LinkedList<AssertCollectable>();\n+            LinkedList<AssertNotCollectable> toBeNotCollectedMarked = new LinkedList<AssertNotCollectable>();\n+\n+            for (WeakReference wRef: toBeCollected) {\n+                if (wRef.get() != null) {\n+                    toBeCollectedMarked.add(new AssertCollectable(wRef));\n+                }\n+            }\n+            for (AssertNotCollectable wRef: toBeNotCollected) {\n+                if (wRef.getWeakReference().get() == null) {\n+                    toBeNotCollectedMarked.add(wRef);\n+                }\n+            }\n+            createHeapDump();\n+            if (toBeNotCollectedMarked.isEmpty()) {\n+                throw new AssertionError(\"The following references should be collected: \" + toBeCollectedMarked);\n+            } else {\n+                throw new AssertionError(\"The following references should be collected: \" + toBeCollectedMarked + \" and \" + toBeNotCollected.size() + \" should not be collected: \" + toBeNotCollectedMarked);\n+            }\n+        }\n+    }\n+\n+    static void createHeapDump() {\n+        if (createHeapdump) {\n+            try {\n+                String dateString = new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss\").format(new Date());\n+                String fileName = \"heapdump_jmemb_\" + dateString + \".hprof\";\n+                File outputFolder = new File(outputFolderString);\n+                String heapdumpFile = new java.io.File(outputFolder, fileName).getAbsolutePath();\n+                System.out.println(\"Creating Heapdump at: \" + heapdumpFile);\n+                getHotspotMBean().dumpHeap(heapdumpFile, true);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        } else {\n+            System.out.println(\"No Heapdump was created. You might want to change the configuration to get a HeapDump.\");\n+        }\n+    }\n+\n+    private static void setMxBeanProxyName(String mxBeanName) {\n+        mxBeanProxyName = mxBeanName;\n+    }\n+\n+    private static HotSpotDiagnosticMXBean getHotspotMBean() throws IOException {\n+        MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n+        HotSpotDiagnosticMXBean bean =\n+                ManagementFactory.newPlatformMXBeanProxy(server,\n+                        mxBeanProxyName, HotSpotDiagnosticMXBean.class);\n+        return bean;\n+    }\n+\n+    \/**\n+     * This class provides different methods, which can be used to declare memory-constraints.\n+     * You can get an instance through the lambda of the method JMemoryBuddy.memoryTest.\n+     *\/\n+    public static interface MemoryTestAPI {\n+        \/**\n+         * After executing the lambda, the provided ref must be collectable. Otherwise an Exception is thrown.\n+         * @param ref The reference which should be collectable.\n+         *\/\n+        public void assertCollectable(Object ref);\n+        \/**\n+         * After executing the lambda, the provided ref must be not collectable. Otherwise an Exception is thrown.\n+         * @param ref The reference which should not be collectable.\n+         *\/\n+        public void assertNotCollectable(Object ref);\n+\n+        \/**\n+         * The provided reference will be reference hard, so it won't be collected, until memoryTest finishes.\n+         * @param ref The reference which should get a hard reference for this test.\n+         *\/\n+        public void setAsReferenced(Object ref);\n+    }\n+\n+    static class AssertCollectable {\n+        WeakReference<Object> assertCollectable;\n+\n+        AssertCollectable(WeakReference<Object> ref) {\n+            this.assertCollectable = ref;\n+        }\n+\n+        WeakReference<Object> getWeakReference() {\n+            return assertCollectable;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            Object el = assertCollectable.get();\n+            return el != null ? el.toString() : \"null\";\n+        }\n+    }\n+\n+    private static class AssertNotCollectable {\n+        WeakReference<Object> assertNotCollectable;\n+        String originalResultOfToString;\n+\n+        AssertNotCollectable(Object ref) {\n+            this.assertNotCollectable = new WeakReference<>(ref);\n+            originalResultOfToString = ref.toString();\n+        }\n+\n+        WeakReference<Object> getWeakReference() {\n+            return assertNotCollectable;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return originalResultOfToString;\n+        }\n+    }\n+\n+    private static class SetAsReferenced {\n+        Object setAsReferenced;\n+\n+        SetAsReferenced(Object ref) {\n+            this.setAsReferenced = ref;\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/memory\/JMemoryBuddy.java","additions":317,"deletions":0,"binary":false,"changes":317,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.ref.WeakReference;\n@@ -45,0 +44,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -160,1 +160,3 @@\n-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);\n+        JMemoryBuddy.memoryTest(checker -> {\n+            toggleGroup.getToggles().add(toggle);\n+            toggleGroup.getToggles().clear();\n@@ -162,7 +164,3 @@\n-        toggleGroup.getToggles().add(toggle);\n-        toggleGroup.getToggles().clear();\n-\n-        toggle = null;\n-        attemptGC(ref, 5);\n-\n-        assertNull(ref.get());\n+            checker.assertCollectable(toggle);\n+            toggle = null;\n+        });\n@@ -172,1 +170,3 @@\n-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);\n+        JMemoryBuddy.memoryTest(checker -> {\n+            toggle.setToggleGroup(toggleGroup);\n+            toggle.setToggleGroup(null);\n@@ -174,7 +174,3 @@\n-        toggle.setToggleGroup(toggleGroup);\n-        toggle.setToggleGroup(null);\n-\n-        toggle = null;\n-        attemptGC(ref, 5);\n-\n-        assertNull(ref.get());\n+            checker.assertCollectable(toggle);\n+            toggle = null;\n+        });\n@@ -184,1 +180,3 @@\n-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);\n+        JMemoryBuddy.memoryTest(checker -> {\n+            toggle.setToggleGroup(toggleGroup);\n+            toggleGroup.getToggles().clear();\n@@ -186,7 +184,3 @@\n-        toggle.setToggleGroup(toggleGroup);\n-        toggleGroup.getToggles().clear();\n-\n-        toggle = null;\n-        attemptGC(ref, 5);\n-\n-        assertNull(ref.get());\n+            checker.assertCollectable(toggle);\n+            toggle = null;\n+        });\n@@ -196,7 +190,3 @@\n-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);\n-\n-        toggleGroup.getToggles().add(toggle);\n-        toggle.setToggleGroup(null);\n-\n-        toggle = null;\n-        attemptGC(ref, 5);\n+        JMemoryBuddy.memoryTest(checker -> {\n+            toggleGroup.getToggles().add(toggle);\n+            toggle.setToggleGroup(null);\n@@ -204,1 +194,3 @@\n-        assertNull(ref.get());\n+            checker.assertCollectable(toggle);\n+            toggle = null;\n+        });\n@@ -208,11 +200,9 @@\n-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);\n-\n-        ToggleGroup anotherToggleGroup = new ToggleGroup();\n-        toggle.setToggleGroup(toggleGroup);\n-        toggle.setToggleGroup(anotherToggleGroup);\n-        toggle.setToggleGroup(null);\n-\n-        toggle = null;\n-        attemptGC(ref, 5);\n-\n-        assertNull(ref.get());\n+        JMemoryBuddy.memoryTest(checker -> {\n+            ToggleGroup anotherToggleGroup = new ToggleGroup();\n+            toggle.setToggleGroup(toggleGroup);\n+            toggle.setToggleGroup(anotherToggleGroup);\n+            toggle.setToggleGroup(null);\n+\n+            checker.assertCollectable(toggle);\n+            toggle = null;\n+        });\n@@ -257,17 +247,0 @@\n-\n-    private void attemptGC(WeakReference<? extends Object> weakRef, int n) {\n-        \/\/ Attempt gc n times\n-        for (int i = 0; i < n; i++) {\n-            System.gc();\n-            System.runFinalization();\n-\n-            if (weakRef.get() == null) {\n-                break;\n-            }\n-            try {\n-                Thread.sleep(500);\n-            } catch (InterruptedException e) {\n-                fail(\"InterruptedException occurred during Thread.sleep()\");\n-            }\n-        }\n-    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ToggleButtonTest.java","additions":34,"deletions":61,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -178,9 +179,1 @@\n-        for (int j = 0; j < 5; ++j) {\n-            System.gc();\n-            System.runFinalization();\n-            if (firstRowRef.get() == null) {\n-                break;\n-            }\n-            MILLISECONDS.sleep(100);\n-        }\n-        assertEquals(null, firstRowRef.get());\n+        JMemoryBuddy.assertCollectable(firstRowRef);\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/accessibility\/virtualflow\/VirtualFlowMemoryLeakTest.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -88,11 +89,1 @@\n-        for (int j = 0; j < 10; j++) {\n-            System.gc();\n-            System.runFinalization();\n-\n-            if (groupWRef.get() == null) {\n-                break;\n-            }\n-\n-            Util.sleep(500);\n-        }\n-        Assert.assertNull(\"Couldn't collect Node\", groupWRef.get());\n+        JMemoryBuddy.assertCollectable(groupWRef);\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/InitialNodesMemoryLeakTest.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -84,17 +85,1 @@\n-        assertCollectable(detIndicator);\n-    }\n-\n-    public static void assertCollectable(WeakReference weakReference) throws Exception {\n-        int counter = 0;\n-\n-        System.gc();\n-        System.runFinalization();\n-\n-        while (counter < 10 && weakReference.get() != null) {\n-            Thread.sleep(100);\n-            counter = counter + 1;\n-            System.gc();\n-            System.runFinalization();\n-        }\n-\n-        Assert.assertNull(weakReference.get());\n+        JMemoryBuddy.assertCollectable(detIndicator);\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/control\/ProgressIndicatorLeakTest.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"}]}