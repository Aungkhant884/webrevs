{"files":[{"patch":"@@ -324,1 +324,1 @@\n-     * Keeps only elements that are included the specified collection.\n+     * Keeps only elements that are included in the specified collection.\n@@ -328,1 +328,1 @@\n-     * @see java.util.Set in JDK API documentation\n+     * @see java.util.Set\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableSetWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,3 +170,2 @@\n-     * The method onInvalidating() can be overridden by extending classes to\n-     * react, if this binding becomes invalid. The default implementation is\n-     * empty.\n+     * Called when this binding becomes invalid. Can be overridden by extending classes to react to the invalidation.\n+     * The default implementation is empty.\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/ObjectBinding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n- * properties independent of their type.\n- *\n+ * properties, independent of their type.\n@@ -94,1 +93,1 @@\n-     * Remove a bidirectional binding between this {@code Property} and another\n+     * Removes a bidirectional binding between this {@code Property} and another\n@@ -103,1 +102,1 @@\n-     *     property1.bindBirectional(property2);\n+     *     property1.bindBidirectional(property2);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/Property.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- *     in the desired format. A default text supplier can be used to provide the intial text.<\/li>\n+ *     in the desired format. A default text supplier can be used to provide the initial text.<\/li>\n@@ -43,1 +43,2 @@\n- *     If the control is editable and the text is changed by the user, the value is then updated to correspond to the text.\n+ *     If the control is editable and the text is changed by the user, the value is then updated to correspond to the\n+ *     text.\n@@ -46,2 +47,2 @@\n- * It's possible to have a formatter with just filter or value converter. If value converter is not provided however, setting a value will\n- * result in an {@code IllegalStateException} and the value is always null.\n+ * It's possible to have a formatter with just a filter or a value converter. If a value converter is not provided,\n+ * setting a value will result in an {@code IllegalStateException} and the value is always {@code null}.\n@@ -49,2 +50,2 @@\n- * Since {@code Formatter} contains a value which represents the state of the {@code TextInputControl} to which it is currently assigned, a single\n- * {@code Formatter} instance can be used only in one {@code TextInputControl} at a time.\n+ * Since {@code Formatter} contains a value that represents the state of the {@code TextInputControl} to which it is\n+ * currently assigned, a single {@code Formatter} instance can be used only in one {@code TextInputControl} at a time.\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TextFormatter.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * <p>The ScheduledService is a {@link Service} which will automatically restart\n+ * <p>The ScheduledService is a {@link Service} that will automatically restart\n@@ -73,1 +73,1 @@\n- * a failed ScheduledService, you must call restart manually.<\/p>\n+ * a failed ScheduledService, you must call <code>restart<\/code> manually.<\/p>\n@@ -85,1 +85,1 @@\n- * backoffStrategy. After <code>maximumFailureCount<\/code> is reached, the\n+ * <code>backoffStrategy<\/code>. After <code>maximumFailureCount<\/code> is reached, the\n@@ -130,2 +130,2 @@\n- * milliseconds. Any null Duration is treated as Duration.ZERO. Any custom implementation of an backoff strategy\n- * callback must be prepared to handle these different potential values.<\/p>\n+ * milliseconds. Any {@code null} Duration is treated as {@code Duration.ZERO}. Any custom implementation of a backoff\n+ * strategy callback must be prepared to handle these different potential values.<\/p>\n@@ -133,5 +133,5 @@\n- * <p>The ScheduledService introduces a new property called {@link #lastValueProperty() lastValue}. The lastValue is the value that\n- * was last successfully computed. Because a Service clears its {@code value} property on each run, and\n- * because the ScheduledService will reschedule a run immediately after completion (unless it enters the\n- * cancelled or failed states), the value property is not overly useful on a ScheduledService. In most cases\n- * you will want to instead use the value returned by lastValue.<\/p>\n+ * <p>The ScheduledService introduces a new property called {@link #lastValueProperty() lastValue}. The\n+ * {@code lastValue} is the value that was last successfully computed. Because a Service clears its {@code value}\n+ * property on each run, and because the ScheduledService will reschedule a run immediately after completion (unless it\n+ * enters the cancelled or failed states), the value property is not overly useful on a ScheduledService. In most cases\n+ * you will want to instead use the value returned by {@code lastValue}.<\/p>\n@@ -139,1 +139,1 @@\n- * <b>Implementer Note:<\/b> The {@link #ready()}, {@link #scheduled()}, {@link #running()}, {@link #succeeded()},\n+ * @implNote The {@link #ready()}, {@link #scheduled()}, {@link #running()}, {@link #succeeded()},\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/concurrent\/ScheduledService.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n- *     A Service is a non-visual component encapsulating the information required\n+ *     A {@code Service} is a non-visual component encapsulating the information required\n@@ -69,1 +69,1 @@\n- *     JavaFX UI library, the Service knows about the JavaFX Application thread\n+ *     JavaFX UI library, the {@code Service} knows about the JavaFX Application thread\n@@ -72,1 +72,1 @@\n- *     such, all of the methods and state on the Service are intended to be\n+ *     such, all of the methods and state on the {@code Service} are intended to be\n@@ -74,3 +74,3 @@\n- *     to this, is when initially configuring a Service, which may safely be done\n- *     from any thread, and initially starting a Service, which may also safely\n- *     be done from any thread. However, once the Service has been initialized and\n+ *     to this is when initially configuring a {@code Service}, which may safely be done\n+ *     from any thread, and initially starting a {@code Service}, which may also safely\n+ *     be done from any thread. However, once the {@code Service} has been initialized and\n@@ -80,1 +80,1 @@\n- *     A Service creates and manages a {@link Task} that performs the work\n+ *     A {@code Service} creates and manages a {@link Task} that performs the work\n@@ -84,1 +84,1 @@\n- *     Worker, meaning that it can be reset and restarted. Due to this, a Service\n+ *     Worker, meaning that it can be reset and restarted. Due to this, a {@code Service}\n@@ -86,4 +86,4 @@\n- *     Once a Service is started, it will schedule its Task and listen for\n- *     changes to the state of the Task. A Task does not hold a reference to the\n- *     Service that started it, meaning that a running Task will not prevent\n- *     the Service from being garbage collected.\n+ *     Once a {@code Service} is started, it will schedule its {@code Task} and listen for\n+ *     changes to the state of the {@code Task}. A {@code Task} does not hold a reference to the\n+ *     {@code Service} that started it, meaning that a running {@code Task} will not prevent\n+ *     the {@code Service} from being garbage collected.\n@@ -92,1 +92,1 @@\n- *     If an {@link java.util.concurrent.Executor} is specified on the Service,\n+ *     If an {@link java.util.concurrent.Executor} is specified on the {@code Service},\n@@ -95,1 +95,1 @@\n- *     non-daemon threads, then specify a custom Executor (for example,\n+ *     non-daemon threads, then specify a custom {@code Executor} (for example,\n@@ -100,1 +100,1 @@\n- *     Because a Service is intended to simplify declarative use cases, subclasses\n+ *     Because a {@code Service} is intended to simplify declarative use cases, subclasses\n@@ -102,4 +102,3 @@\n- *     For example, suppose I wanted to write a Service which read the first line\n- *     from any URL and returned it as a String. Such a Service might be defined,\n- *     such that it had a single property, {@code url}. It might be implemented\n- *     as:\n+ *     For example, to write a {@code Service} that reads the first line\n+ *     from any URL and returns it as a {@code String}, it might be defined with\n+ *     a single property, {@code url}, and might be implemented as:\n@@ -130,1 +129,1 @@\n- *     The Service by default uses a thread pool Executor with some unspecified\n+ *     The {@code Service} by default uses a {@code ThreadPoolExecutor} with some unspecified\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/concurrent\/Service.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  <title>javafx.task<\/title>\n+  <title>javafx.concurrent<\/title>\n@@ -36,1 +36,1 @@\n-<p>Provides the set of classes for javafx.task.<\/p>\n+<p>Provides the set of classes for javafx.concurrent.<\/p>\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/concurrent\/package.html","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}